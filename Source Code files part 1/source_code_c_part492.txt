ng_t enc, ASN1iterator_t **val, ASN1iterator_encfn pfnIterator);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSeqOf_NoSize(ASN1decoding_t dec, ASN1iterator_t **val, ASN1iterator_decfn pfnIterator, ASN1uint32_t cbElementSize);
extern ASN1_PUBLIC int ASN1API ASN1PEREncSeqOf_VarSize(ASN1encoding_t enc, ASN1iterator_t **val, ASN1iterator_encfn pfnIterator, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits);
extern ASN1_PUBLIC int ASN1API ASN1PERDecSeqOf_VarSize(ASN1decoding_t dec, ASN1iterator_t **val, ASN1iterator_decfn pfnIterator, ASN1uint32_t cbElementSize, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits);
extern ASN1_PUBLIC void ASN1API ASN1PERFreeSeqOf(ASN1iterator_t **val, ASN1iterator_freefn pfnIterator);

extern ASN1_PUBLIC int ASN1API ASN1PERDecSkipNormallySmallExtensionFragmented(ASN1decoding_t dec);
__inline int ASN1PERDecExtensionBit(ASN1decoding_t dec, ASN1uint32_t *val)
{
    return ASN1PERDecBit(dec, val);
}


/* --------------------------------------------------------- */
/* The following is not supported.                           */
/* --------------------------------------------------------- */

extern ASN1_PUBLIC int ASN1API ASN1PEREncCheckTableCharString(ASN1uint32_t nchars, ASN1char_t *val, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncCheckTableChar16String(ASN1uint32_t nchars, ASN1char16_t *val, ASN1stringtable_t *table);
extern ASN1_PUBLIC int ASN1API ASN1PEREncCheckTableChar32String(ASN1uint32_t nchars, ASN1char32_t *val, ASN1stringtable_t *table);

extern ASN1_PUBLIC int ASN1API ASN1PEREncUTF8String(ASN1encoding_t enc, ASN1uint32_t nchars, WCHAR *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecUTF8String(ASN1decoding_t dec, ASN1uint32_t nchars, WCHAR **val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecUTF8StringEx(ASN1decoding_t dec, ASN1uint32_t *nchars, WCHAR **val);

extern ASN1_PUBLIC int ASN1API ASN1PEREncExternal(ASN1encoding_t enc, ASN1external_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncEmbeddedPdv(ASN1encoding_t enc, ASN1embeddedpdv_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncEmbeddedPdvOpt(ASN1encoding_t enc, ASN1embeddedpdv_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncCharacterString(ASN1encoding_t enc, ASN1characterstring_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PEREncCharacterStringOpt(ASN1encoding_t enc, ASN1characterstring_t *val);

extern ASN1_PUBLIC int ASN1API ASN1PERDecExternal(ASN1decoding_t dec, ASN1external_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecEmbeddedPdv(ASN1decoding_t dec, ASN1embeddedpdv_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecEmbeddedPdvOpt(ASN1decoding_t dec, ASN1embeddedpdv_t *val, ASN1objectidentifier_t *abstract, ASN1objectidentifier_t *transfer);
extern ASN1_PUBLIC int ASN1API ASN1PERDecCharacterString(ASN1decoding_t dec, ASN1characterstring_t *val);
extern ASN1_PUBLIC int ASN1API ASN1PERDecCharacterStringOpt(ASN1decoding_t dec, ASN1characterstring_t *val, ASN1objectidentifier_t *abstract, ASN1objectidentifier_t *transfer);

#ifdef __cplusplus
}
#endif

#endif // __MS_PER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\nmasn\msber.inl ===
/* DER variant of BER */

__inline int ASN1API ASN1DEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1generalizedtime_t *val)
{
    return ASN1CEREncGeneralizedTime(enc, tag, val);
}
__inline int ASN1API ASN1DEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1utctime_t *val)
{
    return ASN1CEREncUTCTime(enc, tag, val);
}

__inline int ASN1API ASN1DEREncBeginBlk(ASN1encoding_t enc, ASN1blocktype_e eBlkType, void **ppBlk)
{
    return ASN1CEREncBeginBlk(enc, eBlkType, ppBlk);
}
__inline int ASN1API ASN1DEREncNewBlkElement(void *pBlk, ASN1encoding_t *enc2)
{
    return ASN1CEREncNewBlkElement(pBlk, enc2);
}
__inline int ASN1API ASN1DEREncFlushBlkElement(void *pBlk)
{
    return ASN1CEREncFlushBlkElement(pBlk);
}
__inline int ASN1API ASN1DEREncEndBlk(void *pBlk)
{
    return ASN1CEREncEndBlk(pBlk);
}

__inline int ASN1API ASN1DEREncCharString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char_t *val)
{
    return ASN1BEREncCharString(enc, tag, len, val);
}
__inline int ASN1API ASN1DEREncChar16String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char16_t *val)
{
    return ASN1BEREncChar16String(enc, tag, len, val);
}
__inline int ASN1API ASN1DEREncChar32String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char32_t *val)
{
    return ASN1BEREncChar32String(enc, tag, len, val);
}
__inline int ASN1API ASN1DEREncBitString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    return ASN1BEREncBitString(enc, tag, len, val);
}
__inline int ASN1API ASN1DEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1ztcharstring_t val)
{
    return ASN1BEREncZeroMultibyteString(enc, tag, val);
}
__inline int ASN1API ASN1DEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1charstring_t *val)
{
    return ASN1BEREncMultibyteString(enc, tag, val);
}
__inline int ASN1API ASN1DEREncOctetString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    return ASN1BEREncOctetString(enc, tag, len, val);
}

__inline int ASN1API ASN1DEREncUTF8String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t length, WCHAR *value)
{
    return ASN1BEREncUTF8String(enc, tag, length, value);
}
__inline int ASN1API ASN1CEREncUTF8String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t length, WCHAR *value)
{
    return ASN1BEREncUTF8String(enc, tag, length, value);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\nmasn\pkiasn1.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  File:       pkiasn1.h
//
//  Contents:   PKI ASN.1 support functions.
//
//  APIs:       PkiAsn1ErrToHr
//              PkiAsn1Encode
//              PkiAsn1FreeEncoded
//              PkiAsn1Encode2
//              PkiAsn1Decode
//              PkiAsn1Decode2
//              PkiAsn1FreeDecoded
//              PkiAsn1SetEncodingRule
//              PkiAsn1GetEncodingRule
//              PkiAsn1EncodedOidToDotVal
//              PkiAsn1FreeDotVal
//              PkiAsn1DotValToEncodedOid
//              PkiAsn1FreeEncodedOid
//
//              PkiAsn1Alloc
//              PkiAsn1Free
//              PkiAsn1ReverseBytes
//              PkiAsn1AllocAndReverseBytes
//              PkiAsn1GetOctetString
//              PkiAsn1SetHugeInteger
//              PkiAsn1FreeHugeInteger
//              PkiAsn1GetHugeInteger
//              PkiAsn1SetHugeUINT
//              PkiAsn1FreeHugeUINT
//              PkiAsn1GetHugeUINT
//              PkiAsn1SetBitString
//              PkiAsn1GetBitString
//              PkiAsn1GetIA5String
//              PkiAsn1SetUnicodeConvertedToIA5String
//              PkiAsn1FreeUnicodeConvertedToIA5String
//              PkiAsn1GetIA5StringConvertedToUnicode
//              PkiAsn1GetBMPString
//              PkiAsn1SetAny
//              PkiAsn1GetAny
//              PkiAsn1EncodeInfo
//              PkiAsn1DecodeAndAllocInfo
//              PkiAsn1FreeInfo
//              PkiAsn1EncodeInfoEx
//              PkiAsn1DecodeAndAllocInfo
//              PkiAsn1AllocStructInfoEx
//              PkiAsn1DecodeAndAllocInfoEx
//
//              PkiAsn1ToObjectIdentifier
//              PkiAsn1FromObjectIdentifier
//              PkiAsn1ToUTCTime
//              PkiAsn1FromUTCTime
//              PkiAsn1ToGeneralizedTime
//              PkiAsn1FromGeneralizedTime
//              PkiAsn1ToChoiceOfTime
//              PkiAsn1FromChoiceOfTime
//
//  Notes:      According to the <draft-ietf-pkix-ipki-part1-03.txt> :
//              For UTCTime. Where YY is greater than 50, the year shall
//              be interpreted as 19YY. Where YY is less than or equal to
//              50, the year shall be interpreted as 20YY.
//
//  History:    23-Oct-98    philh   created
//--------------------------------------------------------------------------

#ifndef __PKIASN1_H__
#define __PKIASN1_H__

#include <msber.h>
#include <msasn1.h>
#include <winerror.h>
#include <pkialloc.h>

#ifdef OSS_CRYPT_ASN1
#include "asn1hdr.h"
#include "asn1code.h"
#include "ossglobl.h"
#include "pkioss.h"
#include "ossutil.h"
#include "ossconv.h"
#endif  // OSS_CRYPT_ASN1

#ifndef OSS_CRYPT_ASN1

//+-------------------------------------------------------------------------
//  Convert Asn1 error to a HRESULT.
//--------------------------------------------------------------------------
__inline
HRESULT
WINAPI
PkiAsn1ErrToHr(ASN1error_e Asn1Err) {
    if (0 > Asn1Err)
        return CRYPT_E_OSS_ERROR + 0x100 + (-Asn1Err -1000);
    else
        return CRYPT_E_OSS_ERROR + 0x200 + (Asn1Err -1000);
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output is allocated and must be freed
//  by calling PkiAsn1FreeEncoded().
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Encode(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    );

//+-------------------------------------------------------------------------
//  Free encoded output returned by PkiAsn1Encode().
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeEncoded(
    IN ASN1encoding_t pEnc,
    IN void *pvEncoded
    )
{
    if (pvEncoded)
        ASN1_FreeEncoded(pEnc, pvEncoded);
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output isn't allocated.
//
//  If pbEncoded is NULL, does a length only calculation.
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Encode2(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT OPTIONAL BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    );

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Decode(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    );

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//
//  For a successful decode, *ppbEncoded is advanced
//  past the decoded bytes and *pcbDecoded is decremented by the number
//  of decoded bytes.
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Decode2(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    );

//+-------------------------------------------------------------------------
//  Free decoded structure returned by PkiAsn1Decode() or PkiAsn1Decode2().
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeDecoded(
    IN ASN1decoding_t pDec,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id
    )
{
    if (pvAsn1Info)
        ASN1_FreeDecoded(pDec, pvAsn1Info, id);
}

//+-------------------------------------------------------------------------
//  Asn1 Set/Get encoding rule functions
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1SetEncodingRule(
    IN ASN1encoding_t pEnc,
    IN ASN1encodingrule_e eRule
    );

ASN1encodingrule_e
WINAPI
PkiAsn1GetEncodingRule(
    IN ASN1encoding_t pEnc
    );

//+-------------------------------------------------------------------------
//  Asn1 EncodedOid To/From DotVal functions
//--------------------------------------------------------------------------
__inline
LPSTR
WINAPI
PkiAsn1EncodedOidToDotVal(
    IN ASN1decoding_t pDec,
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    LPSTR pszDotVal = NULL;
    if (ASN1BEREoid2DotVal(pDec, pEncodedOid, &pszDotVal))
        return pszDotVal;
    else
        return NULL;
}

__inline
void
WINAPI
PkiAsn1FreeDotVal(
    IN ASN1decoding_t pDec,
    IN LPSTR pszDotVal
    )
{
    if (pszDotVal)
        ASN1Free(pszDotVal);
}

// Returns nonzero for success
__inline
int
WINAPI
PkiAsn1DotValToEncodedOid(
    IN ASN1encoding_t pEnc,
    IN LPSTR pszDotVal,
    OUT ASN1encodedOID_t *pEncodedOid
    )
{
    return ASN1BERDotVal2Eoid(pEnc, pszDotVal, pEncodedOid);
}

__inline
void
WINAPI
PkiAsn1FreeEncodedOid(
    IN ASN1encoding_t pEnc,
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    if (pEncodedOid->value)
        ASN1_FreeEncoded(pEnc, pEncodedOid->value);
}

//+-------------------------------------------------------------------------
//  PkiAsn1 allocation and free functions
//--------------------------------------------------------------------------
#define PkiAsn1Alloc    PkiNonzeroAlloc
#define PkiAsn1Free     PkiFree

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes in place
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1ReverseBytes(
			IN OUT PBYTE pbIn,
			IN DWORD cbIn
            );

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes to a new buffer. PkiAsn1Free() must be
//  called to free allocated bytes.
//--------------------------------------------------------------------------
PBYTE
WINAPI
PkiAsn1AllocAndReverseBytes(
			IN PBYTE pbIn,
			IN DWORD cbIn
            );


inline void WINAPI
PkiAsn1SetOctetString(IN PCRYPT_DATA_BLOB pInfo,
                      OUT ASN1octetstring_t * pAsn1)
{
    memset(pAsn1, 0, sizeof(*pAsn1));
    pAsn1->length = pInfo->cbData;
    pAsn1->value = pInfo->pbData;
}

//+-------------------------------------------------------------------------
//  Get Octet String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetOctetString(
        IN ASN1uint32_t Asn1Length,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

inline void WINAPI
PkiAsn1GetOctetString(
                      IN ASN1octetstring_t * pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
                      )
{
    PkiAsn1GetOctetString(pAsn1->length, pAsn1->value, dwFlags, pInfo, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get HugeInteger
//
//  PkiAsn1FreeHugeInteger must be called to free the allocated OssValue.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetHugeInteger(
        IN PCRYPT_INTEGER_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1Length,
        OUT ASN1octet_t **ppAsn1Value
        );

inline BOOL WINAPI
PkiAsn1SetHugeInteger(
                      IN PCRYPT_INTEGER_BLOB pInfo,
                      OUT ASN1intx_t * pAsn1)
{
    return PkiAsn1SetHugeInteger(pInfo, &pAsn1->length, &pAsn1->value);
}
            

void
WINAPI
PkiAsn1FreeHugeInteger(
        IN ASN1octet_t *pAsn1Value
        );

inline void WINAPI
PkiAsn1FreeHugeInteger(ASN1intx_t asn1)
{
    PkiAsn1FreeHugeInteger(asn1.value);
}
 
void
WINAPI
PkiAsn1GetHugeInteger(
        IN ASN1uint32_t Asn1Length,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_INTEGER_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

inline void
WINAPI
PkiAsn1GetHugeInteger(
                      ASN1intx_t asn1,
        IN DWORD dwFlags,
        OUT PCRYPT_INTEGER_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetHugeInteger(asn1.length, asn1.value, dwFlags, pInfo, ppbExtra,
                          plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Free/Get Huge Unsigned Integer
//
//  Set inserts a leading 0x00 before reversing.
//  Get removes a leading 0x00 if present, after reversing.
//
//  PkiAsn1FreeHugeUINT must be called to free the allocated OssValue.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetHugeUINT(
        IN PCRYPT_UINT_BLOB pInfo,
        OUT ASN1intx_t * pAsn1);

#define PkiAsn1FreeHugeUINT     PkiAsn1FreeHugeInteger

void
WINAPI
PkiAsn1GetHugeUINT(
                   IN ASN1intx_t pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_UINT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Get BitString
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1SetBitString(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT ASN1uint32_t *pAsn1BitLength,
        OUT ASN1octet_t **ppAsn1Value
        );

void
WINAPI
PkiAsn1GetBitString(
        IN ASN1uint32_t Asn1BitLength,
        IN ASN1octet_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Get IA5 String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetIA5String(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPSTR *ppsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Free/Get Unicode mapped to IA5 String
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1SetUnicodeConvertedToIA5String(
        IN LPWSTR pwsz,
        OUT ASN1uint32_t *pAsn1Length,
        OUT ASN1char_t **ppAsn1Value
        );

void
WINAPI
PkiAsn1FreeUnicodeConvertedToIA5String(
        IN ASN1char_t *pAsn1Value
        );

void
WINAPI
PkiAsn1GetIA5StringConvertedToUnicode(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Get BMP String
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1GetBMPString(
        IN ASN1uint32_t Asn1Length,
        IN ASN1char16_t *pAsn1Value,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );


//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1SetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT ASN1open_t *pAsn1
        );

void
WINAPI
PkiAsn1GetAny(
        IN ASN1open_t *pAsn1,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1EncodeInfo(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

//+-------------------------------------------------------------------------
//  Decode into an allocated, ASN1 formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvAsn1Info
        );

//+-------------------------------------------------------------------------
//  Free an allocated, ASN1 formatted info structure
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info
        )
{
    if (pvAsn1Info)
        ASN1_FreeDecoded(pDec, pvAsn1Info, id);
}

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure.
//
//  If CRYPT_ENCODE_ALLOC_FLAG is set, allocate memory for pbEncoded and
//  return *((BYTE **) pvEncoded) = pbAllocEncoded. Otherwise,
//  pvEncoded points to byte array to be updated.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1EncodeInfoEx(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );

typedef BOOL (WINAPI *PFN_PKI_ASN1_DECODE_EX_CALLBACK)(
    IN void *pvAsn1Info,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT LONG *plRemainExtra
    );

//+-------------------------------------------------------------------------
//  Call the callback to convert the ASN1 structure into the 'C' structure.
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1AllocStructInfoEx(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  Decode the ASN1 formatted info structure and call the callback
//  function to convert the ASN1 structure to the 'C' structure.
//
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfoEx(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  Convert the ascii string ("1.2.9999") to ASN1's Object Identifier
//  represented as an array of unsigned longs.
//
//  Returns TRUE for a successful conversion. 
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToObjectIdentifier(
    IN LPCSTR pszObjId,
    IN OUT ASN1uint16_t *pCount,
    OUT ASN1uint32_t rgulValue[]
    );

//+-------------------------------------------------------------------------
//  Convert from OSS's Object Identifier represented as an array of
//  unsigned longs to an ascii string ("1.2.9999").
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromObjectIdentifier(
    IN ASN1uint16_t Count,
    IN ASN1uint32_t rgulValue[],
    OUT LPSTR * ppszObjId,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's UTCTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToUTCTime(
    IN LPFILETIME pFileTime,
    OUT ASN1utctime_t *pAsn1Time
    );

//+-------------------------------------------------------------------------
//  Convert from ASN1's UTCTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromUTCTime(
    IN ASN1utctime_t *pAsn1Time,
    OUT LPFILETIME pFileTime
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's GeneralizedTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToGeneralizedTime(
    IN LPFILETIME pFileTime,
    OUT ASN1generalizedtime_t *pAsn1Time
    );

//+-------------------------------------------------------------------------
//  Convert from ASN1's GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromGeneralizedTime(
    IN ASN1generalizedtime_t *pAsn1Time,
    OUT LPFILETIME pFileTime
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to ASN1's UTCTime or GeneralizedTime.
//
//  If 1950 < FILETIME < 2005, then UTCTime is chosen. Otherwise,
//  GeneralizedTime is chosen. GeneralizedTime values shall not include
//  fractional seconds.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToChoiceOfTime(
    IN LPFILETIME pFileTime,
    OUT WORD *pwChoice,
    OUT ASN1generalizedtime_t *pGeneralTime,
    OUT ASN1utctime_t *pUtcTime
    );

#define PKI_ASN1_UTC_TIME_CHOICE            1
#define PKI_ASN1_GENERALIZED_TIME_CHOICE    2

//+-------------------------------------------------------------------------
//  Convert from ASN1's UTCTime or GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromChoiceOfTime(
    IN WORD wChoice,
    IN ASN1generalizedtime_t *pGeneralTime,
    IN ASN1utctime_t *pUtcTime,
    OUT LPFILETIME pFileTime
    );

#else 

//+=========================================================================
// The following map to the OSS ASN1 routines
//==========================================================================

//+-------------------------------------------------------------------------
//  Convert Asn1 error to a HRESULT.
//--------------------------------------------------------------------------
__inline
HRESULT
WINAPI
PkiAsn1ErrToHr(ASN1error_e Asn1Err) {
    if (0 <= Asn1Err && 1000 > Asn1Err)
        return CRYPT_E_OSS_ERROR + Asn1Err;
    else if (0 > Asn1Err)
        return CRYPT_E_OSS_ERROR + 0x100 + (-Asn1Err -1000);
    else
        return CRYPT_E_OSS_ERROR + 0x200 + (Asn1Err -1000);
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output is allocated and must be freed
//  by calling PkiAsn1FreeEncoded().
//--------------------------------------------------------------------------
__inline
ASN1error_e
WINAPI
PkiAsn1Encode(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT BYTE **ppbEncoded,
    OUT OPTIONAL DWORD *pcbEncoded = NULL
    )
{
    return (ASN1error_e) PkiOssEncode(
        (OssGlobal *) pEnc,
        pvAsn1Info,
        (int) id,
        ppbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Free encoded output returned by PkiAsn1Encode().
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeEncoded(
    IN ASN1encoding_t pEnc,
    IN void *pvEncoded
    )
{
    if (pvEncoded)
        ossFreeBuf((OssGlobal *) pEnc, pvEncoded);
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output isn't allocated.
//
//  If pbEncoded is NULL, does a length only calculation.
//--------------------------------------------------------------------------
__inline
ASN1error_e
WINAPI
PkiAsn1Encode2(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT OPTIONAL BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    return (ASN1error_e) PkiOssEncode2(
        (OssGlobal *) pEnc,
        pvAsn1Info,
        (int) id,
        pbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//--------------------------------------------------------------------------
__inline
ASN1error_e
WINAPI
PkiAsn1Decode(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    )
{
    return (ASN1error_e) PkiOssDecode(
        (OssGlobal *) pDec,
        ppvAsn1Info,
        (int) id,
        pbEncoded,
        cbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//
//  For a successful decode, *ppbEncoded is advanced
//  past the decoded bytes and *pcbDecoded is decremented by the number
//  of decoded bytes.
//--------------------------------------------------------------------------
__inline
ASN1error_e
WINAPI
PkiAsn1Decode2(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    return (ASN1error_e) PkiOssDecode2(
        (OssGlobal *) pDec,
        ppvAsn1Info,
        (int) id,
        ppbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Free decoded structure returned by PkiAsn1Decode() or PkiAsn1Decode2().
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeDecoded(
    IN ASN1decoding_t pDec,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id
    )
{
    if (pvAsn1Info)
        ossFreePDU((OssGlobal *) pDec, (int) id, pvAsn1Info);
}


//+-------------------------------------------------------------------------
//  Asn1 Set/Get encoding rules functions
//--------------------------------------------------------------------------
__inline
ASN1error_e
WINAPI
PkiAsn1SetEncodingRule(
    IN ASN1encoding_t pEnc,
    IN ASN1encodingrule_e eRule
    )
{
    ossEncodingRules ossRules;
    if (ASN1_BER_RULE_BER == eRule)
        ossRules = OSS_BER;
    else
        ossRules = OSS_DER;

    return (ASN1error_e) ossSetEncodingRules((OssGlobal *) pEnc, ossRules);
}

__inline
ASN1encodingrule_e
WINAPI
PkiAsn1GetEncodingRule(
    IN ASN1encoding_t pEnc
    )
{
    ossEncodingRules ossRules;
    ossRules = ossGetEncodingRules((OssGlobal *) pEnc);
    if (OSS_BER == ossRules)
        return ASN1_BER_RULE_BER;
    else
        return ASN1_BER_RULE_DER;
}

//+-------------------------------------------------------------------------
//  Asn1 EncodedOid To/From DotVal functions
//--------------------------------------------------------------------------
__inline
LPSTR
WINAPI
PkiAsn1EncodedOidToDotVal(
    IN ASN1decoding_t pDec,
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    OssEncodedOID OssEncodedOid;
    OssBuf dotOid;
    memset(&dotOid, 0, sizeof(dotOid));

    OssEncodedOid.length = pEncodedOid->length;
    OssEncodedOid.value = pEncodedOid->value;
    if (0 == ossEncodedOidToDotVal((OssGlobal *) pDec, &OssEncodedOid,
            &dotOid))
        return (LPSTR) dotOid.value;
    else
        return NULL;
}

__inline
void
WINAPI
PkiAsn1FreeDotVal(
    IN ASN1decoding_t pDec,
    IN LPSTR pszDotVal
    )
{
    if (pszDotVal)
        ossFreeBuf((OssGlobal *) pDec, pszDotVal);
}

// Returns nonzero for success
__inline
int
WINAPI
PkiAsn1DotValToEncodedOid(
    IN ASN1encoding_t pEnc,
    IN LPSTR pszDotVal,
    OUT ASN1encodedOID_t *pEncodedOid
    )
{
    OssEncodedOID eoid;
    memset(&eoid, 0, sizeof(eoid));
    if (0 == ossDotValToEncodedOid((OssGlobal *) pEnc, pszDotVal, &eoid)) {
        pEncodedOid->length = eoid.length;
        pEncodedOid->value = eoid.value;
        return 1;
    } else {
        pEncodedOid->length = 0;
        pEncodedOid->value = NULL;
        return 0;
    }
}

__inline
void
WINAPI
PkiAsn1FreeEncodedOid(
    IN ASN1encoding_t pEnc,
    IN ASN1encodedOID_t *pEncodedOid
    )
{
    if (pEncodedOid->value)
        ossFreeBuf((OssGlobal *) pEnc, pEncodedOid->value);
}

#define PkiAsn1Alloc OssUtilAlloc
#define PkiAsn1Free OssUtilFree
#define PkiAsn1ReverseBytes OssUtilReverseBytes
#define PkiAsn1AllocAndReverseBytes OssUtilAllocAndReverseBytes
#define PkiAsn1GetOctetString OssUtilGetOctetString
#define PkiAsn1SetHugeInteger OssUtilSetHugeInteger
#define PkiAsn1FreeHugeInteger OssUtilFreeHugeInteger
#define PkiAsn1GetHugeInteger OssUtilGetHugeInteger
#define PkiAsn1SetHugeUINT OssUtilSetHugeUINT
#define PkiAsn1FreeHugeUINT OssUtilFreeHugeInteger
#define PkiAsn1GetHugeUINT OssUtilGetHugeUINT
#define PkiAsn1SetBitString OssUtilSetBitString
#define PkiAsn1GetBitString OssUtilGetBitString
#define PkiAsn1GetIA5String OssUtilGetIA5String
#define PkiAsn1SetUnicodeConvertedToIA5String OssUtilSetUnicodeConvertedToIA5String
#define PkiAsn1FreeUnicodeConvertedToIA5String OssUtilFreeUnicodeConvertedToIA5String
#define PkiAsn1GetIA5StringConvertedToUnicode OssUtilGetIA5StringConvertedToUnicode
#define PkiAsn1GetBMPString OssUtilGetBMPString
#define PkiAsn1SetAny OssUtilSetAny
#define PkiAsn1GetAny OssUtilGetAny

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure
//--------------------------------------------------------------------------
__inline
BOOL
WINAPI
PkiAsn1EncodeInfo(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssUtilEncodeInfo(
        (OssGlobal *) pEnc,
        (int) id,
        pvAsn1Info,
        pbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Decode into an allocated, OSS formatted info structure
//--------------------------------------------------------------------------
__inline
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvAsn1Info
        )
{
    return OssUtilDecodeAndAllocInfo(
        (OssGlobal *) pDec,
        (int) id,
        pbEncoded,
        cbEncoded,
        ppvAsn1Info
        );
}

//+-------------------------------------------------------------------------
//  Free an allocated, OSS formatted info structure
//--------------------------------------------------------------------------
__inline
void
WINAPI
PkiAsn1FreeInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info
        )
{
    OssUtilFreeInfo(
        (OssGlobal *) pDec,
        (int) id,
        pvAsn1Info
        );
}

//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure.
//
//  If CRYPT_ENCODE_ALLOC_FLAG is set, allocate memory for pbEncoded and
//  return *((BYTE **) pvEncoded) = pbAllocEncoded. Otherwise,
//  pvEncoded points to byte array to be updated.
//--------------------------------------------------------------------------
__inline
BOOL
WINAPI
PkiAsn1EncodeInfoEx(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return OssUtilEncodeInfoEx(
        (OssGlobal *) pEnc,
        (int) id,
        pvAsn1Info,
        dwFlags,
        pEncodePara,
        pvEncoded,
        pcbEncoded
        );
}

typedef BOOL (WINAPI *PFN_PKI_ASN1_DECODE_EX_CALLBACK)(
    IN void *pvAsn1Info,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT LONG *plRemainExtra
    );

//+-------------------------------------------------------------------------
//  Call the callback to convert the ASN1 structure into the 'C' structure.
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
__inline
BOOL
WINAPI
PkiAsn1AllocStructInfoEx(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return OssUtilAllocStructInfoEx(
        pvAsn1Info,
        dwFlags,
        pDecodePara,
        (PFN_OSS_UTIL_DECODE_EX_CALLBACK) pfnDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

//+-------------------------------------------------------------------------
//  Decode the ASN1 formatted info structure and call the callback
//  function to convert the ASN1 structure to the 'C' structure.
//
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
__inline
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfoEx(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    return OssUtilDecodeAndAllocInfoEx(
        (OssGlobal *) pDec,
        (int) id,
        pbEncoded,
        cbEncoded,
        dwFlags,
        pDecodePara,
        (PFN_OSS_UTIL_DECODE_EX_CALLBACK) pfnDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
}

#define PkiAsn1ToObjectIdentifier OssConvToObjectIdentifier
#define PkiAsn1FromObjectIdentifier OssConvFromObjectIdentifier
#define PkiAsn1ToUTCTime OssConvToUTCTime
#define PkiAsn1FromUTCTime OssConvFromUTCTime
#define PkiAsn1ToGeneralizedTime OssConvToGeneralizedTime
#define PkiAsn1FromGeneralizedTime OssConvFromGeneralizedTime


__inline
BOOL
WINAPI
PkiAsn1ToChoiceOfTime(
    IN LPFILETIME pFileTime,
    OUT WORD *pwChoice,
    OUT GeneralizedTime *pGeneralTime,
    OUT UTCTime *pUtcTime
    )
{
    return OssConvToChoiceOfTime(
        pFileTime,
        pwChoice,
        pGeneralTime
        );
}

#define PKI_ASN1_UTC_TIME_CHOICE            OSS_UTC_TIME_CHOICE
#define PKI_ASN1_GENERALIZED_TIME_CHOICE    OSS_GENERALIZED_TIME_CHOICE

__inline
BOOL
WINAPI
PkiAsn1FromChoiceOfTime(
    IN WORD wChoice,
    IN GeneralizedTime *pGeneralTime,
    IN UTCTime *pUtcTime,
    OUT LPFILETIME pFileTime
    )
{
    return OssConvFromChoiceOfTime(
        wChoice,
        pGeneralTime,
        pFileTime
        );
}

#endif  // OSS_CRYPT_ASN1
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\nmasn\pkialloc.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  File:       pkialloc.h
//
//  Contents:   PKI Allocation Functions
//
//  APIs: 
//              PkiAlloc
//
//  History:    19-Jan-98    philh   created
//--------------------------------------------------------------------------

#ifndef __PKIALLOC_H__
#define __PKIALLOC_H__

#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  The following functions use the 'C' runtime's allocation functions
//  when DBG is defined.  Otherwise, use LocalAlloc, LocalReAlloc or
//  LocalFree Win32 APIs.
//--------------------------------------------------------------------------

// Calls malloc when DBG is defined. Otherwise, does a
// ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiAlloc(
    IN UINT cbBytes
    );

// Calls malloc and does a memory clear when DBG is defined.
// Otherwise, does a ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiZeroAlloc(
    IN UINT cbBytes
    );

// Calls malloc when DBG is defined. Otherwise, does a
// LocalAlloc without ZEOINIT.
LPVOID
WINAPI
PkiNonzeroAlloc(
    IN size_t cbBytes
    );

LPVOID
WINAPI
PkiRealloc(
    IN LPVOID pvOrg,
    IN UINT cbBytes
    );

VOID
WINAPI
PkiFree(
    IN LPVOID pv
    );

//+-------------------------------------------------------------------------
//  The following functions always use LocalAlloc and LocalFree Win32 APIs.
//--------------------------------------------------------------------------
LPVOID
WINAPI
PkiDefaultCryptAlloc(
    IN UINT cbSize
    );
VOID
WINAPI
PkiDefaultCryptFree(
    IN LPVOID pv
    );

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
extern CRYPT_ENCODE_PARA PkiEncodePara;

//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetEncodeAllocFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    );

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetEncodeFreeFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    );

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
extern CRYPT_DECODE_PARA PkiDecodePara;

//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetDecodeAllocFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    );

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetDecodeFreeFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    );


#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\nmasn\utf8.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:       utf8.h
//
//  Contents:   WideChar (UNICODE) to/from UTF8 APIs
//
//  APIs:       WideCharToUTF8
//              UTF8ToWideChar
//
//  History:    19-Feb-97   philh   created
//--------------------------------------------------------------------------

#ifndef __UTF8_H__
#define __UTF8_H__

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Maps a wide-character (Unicode) string to a new UTF-8 encoded character
//  string.
//
//  The wide characters are mapped as follows:
//
//  Start   End     Bits    UTF-8 Characters
//  ------  ------  ----    --------------------------------
//  0x0000  0x007F  7       0x0xxxxxxx
//  0x0080  0x07FF  11      0x110xxxxx 0x10xxxxxx
//  0x0800  0xFFFF  16      0x1110xxxx 0x10xxxxxx 0x10xxxxxx
//
//  The parameter and return value semantics are the same as for the
//  Win32 API, WideCharToMultiByte.
//
//  Note, starting with NT 4.0, WideCharToMultiByte supports CP_UTF8. CP_UTF8
//  isn't supported on Win95.
//--------------------------------------------------------------------------
int
WINAPI
WideCharToUTF8(
    IN LPCWSTR lpWideCharStr,
    IN int cchWideChar,
    OUT LPSTR lpUTF8Str,
    IN int cchUTF8
    );

//+-------------------------------------------------------------------------
//  Maps a UTF-8 encoded character string to a new wide-character (Unicode)
//  string.
// 
//  See CertWideCharToUTF8 for how the UTF-8 characters are mapped to wide
//  characters.
//
//  The parameter and return value semantics are the same as for the
//  Win32 API, MultiByteToWideChar.
//
//  If the UTF-8 characters don't contain the expected high order bits,
//  ERROR_INVALID_PARAMETER is set and 0 is returned.
//
//  Note, starting with NT 4.0, MultiByteToWideChar supports CP_UTF8. CP_UTF8
//  isn't supported on Win95.
//--------------------------------------------------------------------------
int
WINAPI
UTF8ToWideChar(
    IN LPCSTR lpUTF8Str,
    IN int cchUTF8,
    OUT LPWSTR lpWideCharStr,
    IN int cchWideChar
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\oss\crtem.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       crtem.h
//
//  Contents:   'C' Run Time Emulation Definitions
//
//  History:	03-Jun-96   philh   created
//--------------------------------------------------------------------------

#ifndef __CRTEM_H__
#define __CRTEM_H__


///////////////////////////////////////////////////////////////////////
//
// Definitions that help reduce our dependence on the C runtimes
//
#define wcslen(sz)      lstrlenW(sz)            // yes it IS implemented by Win95

#define strlen(sz)      lstrlenA(sz)
#define strcpy(s1,s2)   lstrcpyA(s1,s2)
#define strcmp(s1,s2)   lstrcmpA(s1,s2)
#define _stricmp(s1,s2)  lstrcmpiA(s1,s2)
#define strcat(s1,s2)   lstrcatA(s1,s2)


///////////////////////////////////////////////////////////////////////
//
// C runtime excluders that we only use in non-debug builds
//

////////////////////////////////////////////
//
// enable intrinsics that we can
//
#if !DBG

    #ifdef __cplusplus
        #ifndef _M_PPC
            #pragma intrinsic(memcpy)
            #pragma intrinsic(memcmp)
            #pragma intrinsic(memset)
        #endif
    #endif

////////////////////////////////////////////
//
// memory management
//
#define malloc(cb)          ((void*)LocalAlloc(LPTR, cb))
#define free(pv)            (LocalFree((HLOCAL)pv))
#define realloc(pv, cb)     ((void*)LocalReAlloc((HLOCAL)pv, cb, LMEM_MOVEABLE))

#endif  // !DBG

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\oss\dbgdef.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       dbgdef.h
//
//  Contents:   Defines for debug exports in crypt32 (crypt32d.lib)
//
//  History:    17-Apr-96   kevinr   created
//              05-Sep-1997 pberkman added subsystem id's
//
//--------------------------------------------------------------------------

#ifndef DBGDEF_H
#define DBGDEF_H

#ifdef __cplusplus
    extern "C" 
    {
#endif


#if (DBG)

    //--------------------------------------------------------------------------
    // OSS and heap-checking
    //--------------------------------------------------------------------------
#   include <crtdbg.h>

    // To turn on heap checking (the whole nine yards) (slow):
    // set DEBUG_MASK=0x26
    // To only check for leaks:
    // set DEBUG_MASK=0x20

#   ifndef NO_OSS_DEBUG

#       include <asn1code.h>

        // To turn on OSS tracing (all encodes and decodes):
        // set OSS_DEBUG_MASK=0x02
        //
        // To turn on OSS tracing of only decoder errors
        // set OSS_DEBUG_MASK=0x10
        //
        // To send the OSS tracing output to a file:
        // set OSS_DEBUG_TRACEFILE=<filename>

        extern BOOL WINAPI DbgInitOSS( OssGlobal *pog);

#   endif  // NO_OSS_DEBUG

#endif  // DBG


//
//  05-Sep-1997 pberkman:
//
//      DEBUG_PRINT_MASK settings to turn on sub-system debugs
//
#define DBG_SS_CRYPT32                      0x00000001

#define DBG_SS_TRUSTCOMMON                  0x00010000
#define DBG_SS_TRUST                        0x00020000
#define DBG_SS_TRUSTPROV                    0x00040000
#define DBG_SS_SIP                          0x00080000
#define DBG_SS_CATALOG                      0x00100000
#define DBG_SS_SIGNING                      0x00200000
#define DBG_SS_OFFSIGN                      0x00400000

#define DBG_SS_APP                          0x10000000

typedef struct _DBG_SS_TAG
{
    DWORD       dwSS;
    const char  *pszTag;    // 7 characters!

} DBG_SS_TAG;

#define __DBG_SS_TAGS       { \
                                DBG_SS_CRYPT32,     "CRYPT32",  \
                                DBG_SS_TRUSTCOMMON, "PKITRST",  \
                                DBG_SS_TRUST,       "WINTRST",  \
                                DBG_SS_TRUSTPROV,   "SOFTPUB",  \
                                DBG_SS_CATALOG,     "MSCAT32",  \
                                DBG_SS_SIP,         "MSSIP32",  \
                                DBG_SS_SIGNING,     "MSSGN32",  \
                                DBG_SS_OFFSIGN,     "OFFSIGN",  \
                                DBG_SS_APP,         "CONAPPL",  \
                                NULL, NULL                      \
                            }

//--------------------------------------------------------------------------
// DBG_TRACE 
//--------------------------------------------------------------------------
#if DBG

    extern int WINAPIV DbgPrintf( DWORD dwSubSysId, LPCSTR lpFmt, ...);

#   define DBG_TRACE_EX(argFmt) DbgPrintf argFmt
#   define DBG_TRACE(argFmt)   DBG_TRACE_EX((DBG_SS_CRYPT32,argFmt))

#   define DBG_PRINTF(args)     DbgPrintf args

#else

#   define DBG_TRACE_EX(argFmt)
#   define DBG_TRACE(argFmt)

#   define DBG_PRINTF(args)

#endif  // DBG


//--------------------------------------------------------------------------
// Error-handling 
//--------------------------------------------------------------------------
#ifndef ERROR_RETURN_LABEL
#define ERROR_RETURN_LABEL ErrorReturn
#endif

#define TRACE_ERROR_EX(id,name)                                         \
name##:                                                                 \
    DBG_TRACE_EX((id,"(" #name ":%s,%d)\n", __FILE__, __LINE__));       \
    goto ERROR_RETURN_LABEL;

#define SET_ERROR_EX(id,name,err)                                       \
name##:                                                                 \
    SetLastError( (DWORD)(err));                                        \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": SetLastError " #err "\n", __FILE__, __LINE__)); \
    goto ERROR_RETURN_LABEL;

#define SET_ERROR_VAR_EX(id,name,err)                                   \
name##:                                                                 \
    SetLastError( (DWORD)(err));                                        \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": SetLastError(0x%x)\n", __FILE__, __LINE__, (err))); \
    goto ERROR_RETURN_LABEL;

#define SET_HRESULT_EX(id,name,err)                                     \
name##:                                                                 \
    hr = (HRESULT) (err);                                               \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = " #err "\n", __FILE__, __LINE__)); \
    goto ERROR_RETURN_LABEL;

#define SET_HRESULT_VAR_EX(id,name,err)                                 \
name##:                                                                 \
    hr = (HRESULT) (err);                                               \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = 0x%x\n" , __FILE__, __LINE__, (hr))); \
    goto ERROR_RETURN_LABEL;

#define TRACE_HRESULT_EX(id,name)                                       \
name##:                                                                 \
    DBG_TRACE_EX((id, "%s, %d\n         " #name ": hr = 0x%x\n", __FILE__, __LINE__, (hr))); \
    goto ERROR_RETURN_LABEL;

#define TRACE_ERROR(name)               TRACE_ERROR_EX(DBG_SS_CRYPT32,name)
#define SET_ERROR(name,err)             SET_ERROR_EX(DBG_SS_CRYPT32,name,err)
#define SET_ERROR_VAR(name,err)         SET_ERROR_VAR_EX(DBG_SS_CRYPT32,name,err)
#define SET_HRESULT(name,err)           SET_HRESULT_EX(DBG_SS_CRYPT32,name,err)
#define SET_HRESULT_VAR(name,err)       SET_HRESULT_VAR_EX(DBG_SS_CRYPT32,name,err)
#define TRACE_HRESULT(name)             TRACE_HRESULT_EX(DBG_SS_CRYPT32,name)


#ifdef __cplusplus
    }       // balance of extern "C"
#endif

#endif // DBGDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\nmasn\msber.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation 1997-1998, All rights reserved. */

#ifndef __MS_BER_H__
#define __MS_BER_H__

#include <msasn1.h>

#ifdef __cplusplus
extern "C" {
#endif

extern ASN1_PUBLIC int ASN1API ASN1BEREncCharString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t, ASN1char_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncChar16String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t, ASN1char16_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncChar32String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t, ASN1char32_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncOctetString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BEREncBitString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t, ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncDouble(ASN1encoding_t enc, ASN1uint32_t tag, double);
extern ASN1_PUBLIC int ASN1API ASN1BEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncS32(ASN1encoding_t enc, ASN1uint32_t tag, ASN1int32_t);
extern ASN1_PUBLIC int ASN1API ASN1BEREncSX(ASN1encoding_t enc, ASN1uint32_t tag, ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1ztcharstring_t);
extern ASN1_PUBLIC int ASN1API ASN1BEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncNull(ASN1encoding_t enc, ASN1uint32_t tag);
extern ASN1_PUBLIC int ASN1API ASN1BEREncObjectIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, ASN1objectidentifier_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncObjectIdentifier2(ASN1encoding_t enc, ASN1uint32_t tag, ASN1objectidentifier2_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BEREncRemoveZeroBits(ASN1uint32_t *, ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1utctime_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncFlush(ASN1encoding_t enc);
extern ASN1_PUBLIC int ASN1API ASN1BEREncOpenType(ASN1encoding_t enc, ASN1open_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecExplicitTag(ASN1decoding_t dec, ASN1uint32_t tag, ASN1decoding_t *dd, ASN1octet_t **di);
extern ASN1_PUBLIC int ASN1API ASN1BERDecEndOfContents(ASN1decoding_t dec, ASN1decoding_t dd, ASN1octet_t *di);
extern ASN1_PUBLIC int ASN1API ASN1BERDecOctetString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BERDecOctetString2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BERDecBitString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecBitString2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecChar16String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1char16string_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecChar32String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1char32string_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecCharString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecDouble(ASN1decoding_t dec, ASN1uint32_t tag, double *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecGeneralizedTime(ASN1decoding_t dec, ASN1uint32_t tag, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecZeroMultibyteString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztcharstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecMultibyteString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecNull(ASN1decoding_t dec, ASN1uint32_t tag);
extern ASN1_PUBLIC int ASN1API ASN1BERDecObjectIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, ASN1objectidentifier_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecObjectIdentifier2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1objectidentifier2_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecS8Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int8_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecS16Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int16_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecS32Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int32_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecSXVal(ASN1decoding_t dec, ASN1uint32_t tag, ASN1intx_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecU8Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint8_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecU16Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint16_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecUTCTime(ASN1decoding_t dec, ASN1uint32_t tag, ASN1utctime_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecZeroChar16String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztchar16string_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecZeroChar32String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztchar32string_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecZeroCharString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztcharstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecSkip(ASN1decoding_t dec);
extern ASN1_PUBLIC int ASN1API ASN1BERDecFlush(ASN1decoding_t dec);
extern ASN1_PUBLIC int ASN1API ASN1BERDecOpenType(ASN1decoding_t dec, ASN1open_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecOpenType2(ASN1decoding_t dec, ASN1open_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncCheck(ASN1encoding_t enc, ASN1uint32_t noctets);
extern ASN1_PUBLIC int ASN1API ASN1BEREncTag(ASN1encoding_t enc, ASN1uint32_t tag);
extern ASN1_PUBLIC int ASN1API ASN1BEREncExplicitTag(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t *pLengthOffset);
extern ASN1_PUBLIC int ASN1API ASN1BEREncEndOfContents(ASN1encoding_t enc, ASN1uint32_t LengthOffset);
extern ASN1_PUBLIC int ASN1API ASN1BEREncLength(ASN1encoding_t enc, ASN1uint32_t len);
extern ASN1_PUBLIC int ASN1API ASN1BERDecCheck(ASN1decoding_t dec, ASN1uint32_t len);
extern ASN1_PUBLIC int ASN1API ASN1BERDecTag(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint32_t *constructed);
extern ASN1_PUBLIC int ASN1API ASN1BERDecLength(ASN1decoding_t dec, ASN1uint32_t *len, ASN1uint32_t *infinite);
extern ASN1_PUBLIC int ASN1API ASN1BERDecNotEndOfContents(ASN1decoding_t dec, ASN1octet_t *di);
extern ASN1_PUBLIC int ASN1API ASN1BERDecPeekTag(ASN1decoding_t dec, ASN1uint32_t *tag);
extern ASN1_PUBLIC int ASN1API ASN1BEREncU32(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t);
extern ASN1_PUBLIC int ASN1API ASN1BERDecU32Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint32_t *val);
extern ASN1_PUBLIC int ASN1API ASN1BEREncBool(ASN1encoding_t enc, ASN1uint32_t tag, ASN1bool_t);
extern ASN1_PUBLIC int ASN1API ASN1BERDecBool(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bool_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncEoid(ASN1encoding_t enc, ASN1uint32_t tag, ASN1encodedOID_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecEoid(ASN1decoding_t dec, ASN1uint32_t tag, ASN1encodedOID_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDotVal2Eoid(ASN1encoding_t enc, char *pszDotVal, ASN1encodedOID_t *pOut);
extern ASN1_PUBLIC int ASN1API ASN1BEREoid2DotVal(ASN1decoding_t dec, ASN1encodedOID_t *pIn, char **ppszDotVal);
extern ASN1_PUBLIC void ASN1API ASN1BEREoid_free(ASN1encodedOID_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncUTF8String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t length, WCHAR *value);
extern ASN1_PUBLIC int ASN1API ASN1BERDecUTF8String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1wstring_t *val);

/* CER variant of BER */

extern ASN1_PUBLIC int ASN1API ASN1CEREncCharString(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1char_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncChar16String(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1char16_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncChar32String(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1char32_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncBitString(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t, ASN1generalizedtime_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t, ASN1ztcharstring_t);
extern ASN1_PUBLIC int ASN1API ASN1CEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t, ASN1charstring_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncOctetString(ASN1encoding_t enc, ASN1uint32_t, ASN1uint32_t, ASN1octet_t *);
extern ASN1_PUBLIC int ASN1API ASN1CEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t, ASN1utctime_t *);

extern ASN1_PUBLIC int ASN1API ASN1CEREncBeginBlk(ASN1encoding_t enc, ASN1blocktype_e eBlkType, void **ppBlk);
extern ASN1_PUBLIC int ASN1API ASN1CEREncNewBlkElement(void *pBlk, ASN1encoding_t *enc2);
extern ASN1_PUBLIC int ASN1API ASN1CEREncFlushBlkElement(void *pBlk);
extern ASN1_PUBLIC int ASN1API ASN1CEREncEndBlk(void *pBlk);


/* --------------------------------------------------------- */
/* The following is not supported.                           */
/* --------------------------------------------------------- */

extern ASN1_PUBLIC int ASN1API ASN1BEREncEmbeddedPdv(ASN1encoding_t enc, ASN1uint32_t tag, ASN1embeddedpdv_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncExternal(ASN1encoding_t enc, ASN1uint32_t tag, ASN1external_t *);
extern ASN1_PUBLIC int ASN1API ASN1BEREncCharacterString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1characterstring_t *);

extern ASN1_PUBLIC int ASN1API ASN1BERDecEmbeddedPdv(ASN1decoding_t dec, ASN1uint32_t tag, ASN1embeddedpdv_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecExternal(ASN1decoding_t dec, ASN1uint32_t tag, ASN1external_t *);
extern ASN1_PUBLIC int ASN1API ASN1BERDecCharacterString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1characterstring_t *);

#ifdef __cplusplus
}
#endif

#endif // __MS_BER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\oss\pkialloc.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  File:       pkialloc.h
//
//  Contents:   PKI Allocation Functions
//
//  APIs: 
//              PkiAlloc
//
//  History:    19-Jan-98    philh   created
//--------------------------------------------------------------------------

#ifndef __PKIALLOC_H__
#define __PKIALLOC_H__

#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  The following functions use the 'C' runtime's allocation functions
//  when DBG is defined.  Otherwise, use LocalAlloc, LocalReAlloc or
//  LocalFree Win32 APIs.
//--------------------------------------------------------------------------

// Calls malloc when DBG is defined. Otherwise, does a
// ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiAlloc(
    IN UINT cbBytes
    );

// Calls malloc and does a memory clear when DBG is defined.
// Otherwise, does a ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiZeroAlloc(
    IN UINT cbBytes
    );

// Calls malloc when DBG is defined. Otherwise, does a
// LocalAlloc without ZEOINIT.
LPVOID
WINAPI
PkiNonzeroAlloc(
    IN size_t cbBytes
    );

LPVOID
WINAPI
PkiRealloc(
    IN LPVOID pvOrg,
    IN UINT cbBytes
    );

VOID
WINAPI
PkiFree(
    IN LPVOID pv
    );

//+-------------------------------------------------------------------------
//  The following functions always use LocalAlloc and LocalFree Win32 APIs.
//--------------------------------------------------------------------------
LPVOID
WINAPI
PkiDefaultCryptAlloc(
    IN UINT cbSize
    );
VOID
WINAPI
PkiDefaultCryptFree(
    IN LPVOID pv
    );

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
extern CRYPT_ENCODE_PARA PkiEncodePara;

//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetEncodeAllocFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    );

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetEncodeFreeFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    );

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
extern CRYPT_DECODE_PARA PkiDecodePara;

//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetDecodeAllocFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    );

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetDecodeFreeFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    );


#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\oss\crypthlp.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:       crypthlp.h
//
//  Contents:   Misc internal crypt/certificate helper APIs
//
//  APIs:       I_CryptGetDefaultCryptProv
//              I_CryptGetDefaultCryptProvForEncrypt
//              I_CryptGetFileVersion
//              I_CertSyncStore
//
//  History:    01-Jun-97   philh   created
//--------------------------------------------------------------------------

#ifndef __CRYPTHLP_H__
#define __CRYPTHLP_H__

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Acquire default CryptProv according to the public key algorithm supported
//  by the provider type. The provider is acquired with only
//  CRYPT_VERIFYCONTEXT.
//
//  Setting aiPubKey to 0, gets the default provider for RSA_FULL.
//
//  Note, the returned CryptProv must not be released. Once acquired, the
//  CryptProv isn't released until ProcessDetach. This allows the returned 
//  HCRYPTPROVs to be shared.
//--------------------------------------------------------------------------
HCRYPTPROV
WINAPI
I_CryptGetDefaultCryptProv(
    IN ALG_ID aiPubKey
    );

//+-------------------------------------------------------------------------
//  Acquire default CryptProv according to the public key algorithm, encrypt
//  key algorithm and encrypt key length supported by the provider type.
//
//  dwBitLen = 0, assumes the aiEncrypt's default bit length. For example,
//  CALG_RC2 has a default bit length of 40.
//
//  Note, the returned CryptProv must not be released. Once acquired, the
//  CryptProv isn't released until ProcessDetach. This allows the returned 
//  CryptProvs to be shared.
//--------------------------------------------------------------------------
HCRYPTPROV
WINAPI
I_CryptGetDefaultCryptProvForEncrypt(
    IN ALG_ID aiPubKey,
    IN ALG_ID aiEncrypt,
    IN DWORD dwBitLen
    );

//+-------------------------------------------------------------------------
//  crypt32.dll release version numbers
//--------------------------------------------------------------------------
#define IE4_CRYPT32_DLL_VER_MS          ((    5 << 16) | 101 )
#define IE4_CRYPT32_DLL_VER_LS          (( 1670 << 16) |   1 )

//+-------------------------------------------------------------------------
//  Get file version of the specified file
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptGetFileVersion(
    IN LPCWSTR pwszFilename,
    OUT DWORD *pdwFileVersionMS,    /* e.g. 0x00030075 = "3.75" */
    OUT DWORD *pdwFileVersionLS     /* e.g. 0x00000031 = "0.31" */
    );

//+-------------------------------------------------------------------------
//  Synchronize the original store with the new store.
//
//  Assumptions: Both are cache stores. The new store is temporary
//  and local to the caller. The new store's contexts can be deleted or
//  moved to the original store.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertSyncStore(
    IN OUT HCERTSTORE hOriginalStore,
    IN OUT HCERTSTORE hNewStore
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\oss\certprot.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1997
//
//  File:       certprot.h
//
//  Contents:   Certificate Protection APIs
//
//  APIs:       I_CertProtectFunction
//              I_CertSrvProtectFunction
//
//  History:    27-Nov-97   philh   created
//--------------------------------------------------------------------------

#ifndef __CERTPROT_H__
#define __CERTPROT_H__

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Calls the services process to do a protected certificate function,
//  such as, add or delete a protected root certificate.
//
//  CryptMemFree must be called to free the returned *ppbOut.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CertProtectFunction(
    IN DWORD dwFuncId,
    IN DWORD dwFlags,
    IN OPTIONAL LPCWSTR pwszIn,
    IN OPTIONAL BYTE *pbIn,
    IN DWORD cbIn,
    OUT OPTIONAL BYTE **ppbOut,
    OUT OPTIONAL DWORD *pcbOut
    );

#define CERT_PROT_INIT_ROOTS_FUNC_ID            1
#define CERT_PROT_PURGE_LM_ROOTS_FUNC_ID        2
#define CERT_PROT_ADD_ROOT_FUNC_ID              3
#define CERT_PROT_DELETE_ROOT_FUNC_ID           4
#define CERT_PROT_DELETE_UNKNOWN_ROOTS_FUNC_ID  5


//+-------------------------------------------------------------------------
//  CERT_PROT_INIT_ROOTS_FUNC_ID
//
//  Initialize the protected list of CurrentUser roots. Note, no UI.
//
//  No IN/OUT parameters.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_PROT_PURGE_LM_ROOTS_FUNC_ID
//  
//  Purge all CurrentUser roots from the protected list that also exist
//  in the LocalMachine SystemRegistry "Root" store. Also removes duplicated
//  certificates from the CurrentUser SystemRegistry "Root" store.
//
//  Note, no UI. Purging can be disabled by setting the
//  CERT_PROT_ROOT_INHIBIT_PURGE_LM_FLAG in the registry's ProtectedRootFlags
//  value.
//
//  No IN/OUT parameters.
//
//  Even if purging is disabled, the protected list of roots is still
//  initialized.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_PROT_ADD_ROOT_FUNC_ID
//  
//  Add the specified certificate to the CurrentUser SystemRegistry "Root"
//  store and the protected list of roots. The user is prompted before doing
//  the add.
//
//  pbIn and cbIn must be updated with the pointer to and length of the
//  serialized certificate context to be added. No other IN/OUT parameters.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_PROT_DELETE_ROOT_FUNC_ID
//  
//  Delete the specified certificate from the CurrentUser SystemRegistry "Root"
//  store and the protected list of roots. The user is prompted before doing
//  the delete.
//
//  pbIn and cbIn must be updated with the pointer to and length of the
//  certificate's SHA1 hash property. No other IN/OUT parameters.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  CERT_PROT_DELETE_UNKNOWN_ROOTS_FUNC_ID
//  
//  Delete all CurrentUser roots from the protected list that don't also
//  exist in the CurrentUser SystemRegistry "Root" store. The user is
//  prompted before doing the delete.
//
//  No IN/OUT parameters.
//--------------------------------------------------------------------------

typedef void __RPC_FAR * (__RPC_USER *PFN_CERT_PROT_MIDL_USER_ALLOC)(
    IN size_t cb
    );
typedef void (__RPC_USER *PFN_CERT_PROT_MIDL_USER_FREE)(
    IN void __RPC_FAR *pv
    );

//+-------------------------------------------------------------------------
//  Called from the services process to process a protected certificate 
//  function.
//
//  Returns the error status, ie, not returned in LastError.
//--------------------------------------------------------------------------
DWORD
WINAPI
I_CertSrvProtectFunction(
    IN handle_t hRpc,
    IN DWORD dwFuncId,
    IN DWORD dwFlags,
    IN LPCWSTR pwszIn,
    IN BYTE *pbIn,
    IN DWORD cbIn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut,
    IN PFN_CERT_PROT_MIDL_USER_ALLOC pfnAlloc,
    IN PFN_CERT_PROT_MIDL_USER_FREE pfnFree
    );

typedef DWORD (WINAPI *PFN_CERT_SRV_PROTECT_FUNCTION)(
    IN handle_t hRpc,
    IN DWORD dwFuncId,
    IN DWORD dwFlags,
    IN LPCWSTR pwszIn,
    IN BYTE *pbIn,
    IN DWORD cbIn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut,
    IN PFN_CERT_PROT_MIDL_USER_ALLOC pfnAlloc,
    IN PFN_CERT_PROT_MIDL_USER_FREE pfnFree
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\oss\utf8.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:       utf8.h
//
//  Contents:   WideChar (UNICODE) to/from UTF8 APIs
//
//  APIs:       WideCharToUTF8
//              UTF8ToWideChar
//
//  History:    19-Feb-97   philh   created
//--------------------------------------------------------------------------

#ifndef __UTF8_H__
#define __UTF8_H__

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Maps a wide-character (Unicode) string to a new UTF-8 encoded character
//  string.
//
//  The wide characters are mapped as follows:
//
//  Start   End     Bits    UTF-8 Characters
//  ------  ------  ----    --------------------------------
//  0x0000  0x007F  7       0x0xxxxxxx
//  0x0080  0x07FF  11      0x110xxxxx 0x10xxxxxx
//  0x0800  0xFFFF  16      0x1110xxxx 0x10xxxxxx 0x10xxxxxx
//
//  The parameter and return value semantics are the same as for the
//  Win32 API, WideCharToMultiByte.
//
//  Note, starting with NT 4.0, WideCharToMultiByte supports CP_UTF8. CP_UTF8
//  isn't supported on Win95.
//--------------------------------------------------------------------------
int
WINAPI
WideCharToUTF8(
    IN LPCWSTR lpWideCharStr,
    IN int cchWideChar,
    OUT LPSTR lpUTF8Str,
    IN int cchUTF8
    );

//+-------------------------------------------------------------------------
//  Maps a UTF-8 encoded character string to a new wide-character (Unicode)
//  string.
// 
//  See CertWideCharToUTF8 for how the UTF-8 characters are mapped to wide
//  characters.
//
//  The parameter and return value semantics are the same as for the
//  Win32 API, MultiByteToWideChar.
//
//  If the UTF-8 characters don't contain the expected high order bits,
//  ERROR_INVALID_PARAMETER is set and 0 is returned.
//
//  Note, starting with NT 4.0, MultiByteToWideChar supports CP_UTF8. CP_UTF8
//  isn't supported on Win95.
//--------------------------------------------------------------------------
int
WINAPI
UTF8ToWideChar(
    IN LPCSTR lpUTF8Str,
    IN int cchUTF8,
    OUT LPWSTR lpWideCharStr,
    IN int cchWideChar
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\oss\ossutil.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       ossutil.h
//
//  Contents:   OSS ASN.1 compiler utility functions.
//
//  APIs: 
//              OssUtilAlloc
//              OssUtilFree
//              OssUtilReverseBytes
//              OssUtilAllocAndReverseBytes
//              OssUtilGetOctetString
//              OssUtilSetHugeInteger
//              OssUtilFreeHugeInteger
//              OssUtilGetHugeInteger
//              OssUtilSetHugeUINT
//              OssUtilFreeHugeUINT
//              OssUtilGetHugeUINT
//              OssUtilSetBitString
//              OssUtilGetBitString
//              OssUtilGetIA5String
//              OssUtilSetUnicodeConvertedToIA5String
//              OssUtilFreeUnicodeConvertedToIA5String
//              OssUtilGetIA5StringConvertedToUnicode
//              OssUtilGetBMPString
//              OssUtilSetAny
//              OssUtilGetAny
//              OssUtilEncodeInfo
//              OssUtilDecodeAndAllocInfo
//              OssUtilFreeInfo
//              OssUtilEncodeInfoEx
//              OssUtilDecodeAndAllocInfo
//              OssUtilAllocStructInfoEx
//              OssUtilDecodeAndAllocInfoEx
//
//  History:    17-Nov-96    philh   created
//--------------------------------------------------------------------------

#ifndef __OSSUTIL_H__
#define __OSSUTIL_H__

#include <wincrypt.h>
#include <pkialloc.h>

#include "asn1hdr.h"
#include "ossglobl.h"

#ifdef __cplusplus
extern "C" {
#endif


//+-------------------------------------------------------------------------
//  OssUtil allocation and free functions
//--------------------------------------------------------------------------
#define OssUtilAlloc    PkiNonzeroAlloc
#define OssUtilFree     PkiFree

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes in place
//--------------------------------------------------------------------------
void
WINAPI
OssUtilReverseBytes(
			IN OUT PBYTE pbIn,
			IN DWORD cbIn
            );

//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes to a new buffer. OssUtilFree() must be
//  called to free allocated bytes.
//--------------------------------------------------------------------------
PBYTE
WINAPI
OssUtilAllocAndReverseBytes(
			IN PBYTE pbIn,
			IN DWORD cbIn
            );


//+-------------------------------------------------------------------------
//  Get Octet String
//--------------------------------------------------------------------------
void
WINAPI
OssUtilGetOctetString(
        IN unsigned int OssLength,
        IN unsigned char *OssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Free/Get HugeInteger
//
//  BUGBUG: BYTE reversal::
//   - this only needs to be done for little endian
//   - this needs to be fixed in the OSS compiler
//
//  OssUtilFreeHugeInteger must be called to free the allocated OssValue.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilSetHugeInteger(
        IN PCRYPT_INTEGER_BLOB pInfo,
        OUT unsigned int *pOssLength,
        OUT unsigned char **ppOssValue
        );

void
WINAPI
OssUtilFreeHugeInteger(
        IN unsigned char *pOssValue
        );

void
WINAPI
OssUtilGetHugeInteger(
        IN unsigned int OssLength,
        IN unsigned char *pOssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_INTEGER_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Free/Get Huge Unsigned Integer
//
//  Set inserts a leading 0x00 before reversing.
//  Get removes a leading 0x00 if present, after reversing.
//
//  OssUtilFreeHugeUINT must be called to free the allocated OssValue.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilSetHugeUINT(
        IN PCRYPT_UINT_BLOB pInfo,
        OUT unsigned int *pOssLength,
        OUT unsigned char **ppOssValue
        );

#define OssUtilFreeHugeUINT     OssUtilFreeHugeInteger

void
WINAPI
OssUtilGetHugeUINT(
        IN unsigned int OssLength,
        IN unsigned char *pOssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_UINT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Get BitString
//--------------------------------------------------------------------------
void
WINAPI
OssUtilSetBitString(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT unsigned int *pOssBitLength,
        OUT unsigned char **ppOssValue
        );

void
WINAPI
OssUtilGetBitString(
        IN unsigned int OssBitLength,
        IN unsigned char *pOssValue,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Get IA5 String
//--------------------------------------------------------------------------
void
WINAPI
OssUtilGetIA5String(
        IN unsigned int OssLength,
        IN char *pOssValue,
        IN DWORD dwFlags,
        OUT LPSTR *ppsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Set/Free/Get Unicode mapped to IA5 String
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilSetUnicodeConvertedToIA5String(
        IN LPWSTR pwsz,
        OUT unsigned int *pOssLength,
        OUT char **ppOssValue
        );

void
WINAPI
OssUtilFreeUnicodeConvertedToIA5String(
        IN char *pOssValue
        );

void
WINAPI
OssUtilGetIA5StringConvertedToUnicode(
        IN unsigned int OssLength,
        IN char *pOssValue,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Get BMP String
//--------------------------------------------------------------------------
void
WINAPI
OssUtilGetBMPString(
        IN unsigned int OssLength,
        IN unsigned short *pOssValue,
        IN DWORD dwFlags,
        OUT LPWSTR *ppwsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );


//+-------------------------------------------------------------------------
//  Set/Get "Any" DER BLOB
//--------------------------------------------------------------------------
void
WINAPI
OssUtilSetAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT OpenType *pOss
        );

void
WINAPI
OssUtilGetAny(
        IN OpenType *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_OBJID_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        );

//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilEncodeInfo(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN void *pvOssInfo,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

//+-------------------------------------------------------------------------
//  Decode into an allocated, OSS formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilDecodeAndAllocInfo(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvOssInfo
        );

//+-------------------------------------------------------------------------
//  Free an allocated, OSS formatted info structure
//--------------------------------------------------------------------------
void
WINAPI
OssUtilFreeInfo(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN void *pvOssInfo
        );

//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure.
//
//  If CRYPT_ENCODE_ALLOC_FLAG is set, allocate memory for pbEncoded and
//  return *((BYTE **) pvEncoded) = pbAllocEncoded. Otherwise,
//  pvEncoded points to byte array to be updated.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilEncodeInfoEx(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN void *pvOssInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        );

typedef BOOL (WINAPI *PFN_OSS_UTIL_DECODE_EX_CALLBACK)(
    IN void *pvOssInfo,
    IN DWORD dwFlags,
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
    OUT OPTIONAL void *pvStructInfo,
    IN OUT LONG *plRemainExtra
    );

//+-------------------------------------------------------------------------
//  Call the callback to convert the OSS structure into the 'C' structure.
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilAllocStructInfoEx(
        IN void *pvOssInfo,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_OSS_UTIL_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );

//+-------------------------------------------------------------------------
//  Decode the OSS formatted info structure and call the callback
//  function to convert the OSS structure to the 'C' structure.
//
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
OssUtilDecodeAndAllocInfoEx(
        IN OssGlobal *Pog,
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_OSS_UTIL_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        );


////////////////////////////////////////////////////////// 4.0 routines

BOOL
WINAPI
OssConvToObjectIdentifier(
    IN LPCSTR pszObjId,
    IN OUT unsigned short *pCount,
    OUT unsigned long rgulValue[]
    )
;

BOOL
WINAPI
OssConvFromObjectIdentifier(
    IN unsigned short Count,
    IN unsigned long rgulValue[],
    OUT LPSTR pszObjId,
    IN OUT DWORD *pcbObjId
    )
;

#ifdef __cplusplus
}       // Balance extern "C" above
#endif




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\fntcache\list.h ===
#ifndef _LIST_H
#define _LIST_H

#include "msoedbg.h"
// =================================================================================
// CNode class definition and implementation
// =================================================================================
template<class Value_T>
class CNode   
{
private:
    CNode<Value_T> *m_pNext,
                   *m_pPrev; 
    Value_T         m_pValue;

public:
    CNode<Value_T>(): m_pNext(NULL), m_pPrev(NULL), m_pValue(0) {}

    CNode<Value_T>* GetNext() {return m_pNext;}
    CNode<Value_T>* GetPrev() {return m_pPrev;}

    void SetNext(CNode<Value_T> *pNext) {m_pNext = pNext;}
    void SetPrev(CNode<Value_T> *pPrev) {m_pPrev = pPrev;}

    Value_T GetValue() {return m_pValue;}

    static HRESULT CreateNode(CNode<Value_T> **ppNode, Value_T value);
};

//***************************************************
template<class Value_T>
HRESULT CNode<Value_T>::CreateNode(CNode<Value_T> **ppNode, Value_T value)
{
    HRESULT hr = S_OK;

    CNode<Value_T> *pNode = new CNode<Value_T>;
    if (NULL == pNode)
        {
        hr = E_OUTOFMEMORY;
        goto Exit;
        }
    
    pNode->m_pValue = value;

Exit:
    *ppNode = pNode;
    return hr;
}

// =================================================================================
// CList template class
// Basic list for keeping some class Value_T
// Value_T must have AddRef and Release defined
// =================================================================================

template<class Value_T>
class CList
{
private:
    CNode<Value_T> *m_pHead;
    ULONG           m_cCount;

public:
    CList<Value_T>();
    ~CList<Value_T>();
    void ClearList();

    ULONG GetCount() {return m_cCount;}

    HRESULT AddValue(Value_T value, DWORD *pdwCookie);
    HRESULT RemoveValue(DWORD dwCookie);
    HRESULT GetNext(Value_T *value, DWORD *pdwCookie);
};

// =================================================================================
// CList function implementaions
// =================================================================================
template<class Value_T>
CList<Value_T>::CList<Value_T>(): m_pHead(NULL), m_cCount(0)
{
}

//***************************************************
template<class Value_T>
CList<Value_T>::~CList<Value_T>()
{
    ClearList();
}

//***************************************************
template<class Value_T>
void CList<Value_T>::ClearList()
{
    CNode<Value_T> *pNext;
                        
    while (m_pHead)
        {
        pNext = m_pHead->GetNext();
        (m_pHead->GetValue())->Release();
        delete m_pHead;
        m_pHead = pNext;
        }
    m_cCount = 0;
}

//***************************************************
template<class Value_T>
HRESULT CList<Value_T>::AddValue(Value_T value, DWORD *pdwCookie)
{
    CNode<Value_T> *pNode = NULL;

    HRESULT hr = CNode<Value_T>::CreateNode(&pNode, value);
    if (SUCCEEDED(hr))
        {
        value->AddRef();
        m_cCount++;
        if (m_pHead)
            {
            m_pHead->SetPrev(pNode);
            pNode->SetNext(m_pHead);
            }
        m_pHead = pNode;
        *pdwCookie = reinterpret_cast<DWORD>(pNode);
        }
    else
        *pdwCookie = 0;
    return hr;
}


//***************************************************
template<class Value_T>
HRESULT CList<Value_T>::RemoveValue(DWORD dwCookie)
{
    CNode<Value_T>  *pCurr = reinterpret_cast< CNode<Value_T>* >(dwCookie);
    CNode<Value_T>  *pPrev = pCurr->GetPrev(),
                    *pNext = pCurr->GetNext();

    Assert(pCurr);

    if (pPrev)
        pPrev->SetNext(pNext);
    else
        m_pHead = pNext;

    if (pNext)
        pNext->SetPrev(pPrev);

    (pCurr->GetValue())->Release();
    delete pCurr;
    m_cCount--;

    return S_OK;
}

//***************************************************
// *pdwCookie must equal 0 for first time.
template<class Value_T>
HRESULT CList<Value_T>::GetNext(Value_T *pValue, DWORD* pdwCookie)
{
    CNode<Value_T> *pNode = reinterpret_cast< CNode<Value_T>* >(*pdwCookie);
    if (0 == m_cCount)
        return E_FAIL;

    if (pNode)
        {
        pNode = pNode->GetNext();
        if (!pNode)
            {
            *pdwCookie = 0;
            *pValue = 0;
            return E_FAIL;
            }
        }
    else
        pNode = m_pHead;


    if (pNode)
        {
        *pValue = pNode->GetValue();
        *pdwCookie = reinterpret_cast<DWORD>(pNode);
        (*pValue)->AddRef();
        }
    else
        {
        *pValue = NULL;
        *pdwCookie = 0;
        }
    return S_OK;
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\oss\ossconv.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       ossconv.h
//
//  Contents:   Conversion APIs to/from OSS ASN.1 data structures
//
//  APIs:       OssConvToObjectIdentifier
//              OssConvFromObjectIdentifier
//              OssConvToUTCTime
//              OssConvFromUTCTime
//              OssConvToGeneralizedTime
//              OssConvFromGeneralizedTime
//              OssConvToChoiceOfTime
//              OssConvFromChoiceOfTime
//
//  Notes:      According to the <draft-ietf-pkix-ipki-part1-03.txt> :
//              For UTCTime. Where YY is greater than 50, the year shall
//              be interpreted as 19YY. Where YY is less than or equal to
//              50, the year shall be interpreted as 20YY.
//
//  History:    28-Mar-96   philh   created
//
//--------------------------------------------------------------------------

#ifndef __OSSCONV_H__
#define __OSSCONV_H__

#include "asn1hdr.h"

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Convert the ascii string ("1.2.9999") to OSS's Object Identifier
//  represented as an array of unsigned longs.
//
//  Returns TRUE for a successful conversion. 
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToObjectIdentifier(
    IN LPCSTR pszObjId,
    IN OUT unsigned short *pCount,
    OUT unsigned long rgulValue[]
    );

//+-------------------------------------------------------------------------
//  Convert from OSS's Object Identifier represented as an array of
//  unsigned longs to an ascii string ("1.2.9999").
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromObjectIdentifier(
    IN unsigned short Count,
    IN unsigned long rgulValue[],
    OUT LPSTR pszObjId,
    IN OUT DWORD *pcbObjId
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to OSS's UTCTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToUTCTime(
    IN LPFILETIME pFileTime,
    OUT UTCTime *pOssTime
    );

//+-------------------------------------------------------------------------
//  Convert from OSS's UTCTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromUTCTime(
    IN UTCTime *pOssTime,
    OUT LPFILETIME pFileTime
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to OSS's GeneralizedTime.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToGeneralizedTime(
    IN LPFILETIME pFileTime,
    OUT GeneralizedTime *pOssTime
    );

//+-------------------------------------------------------------------------
//  Convert from OSS's GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromGeneralizedTime(
    IN GeneralizedTime *pOssTime,
    OUT LPFILETIME pFileTime
    );

//+-------------------------------------------------------------------------
//  Convert FILETIME to OSS's UTCTime or GeneralizedTime.
//
//  If 1950 < FILETIME < 2005, then UTCTime is chosen. Otherwise,
//  GeneralizedTime is chosen. GeneralizedTime values shall not include
//  fractional seconds.
//
//  Returns TRUE for a successful conversion
//
//  Note, in asn1hdr.h, UTCTime has same typedef as GeneralizedTime.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvToChoiceOfTime(
    IN LPFILETIME pFileTime,
    OUT WORD *pwChoice,
    OUT GeneralizedTime *pOssTime
    );

#define OSS_UTC_TIME_CHOICE             1
#define OSS_GENERALIZED_TIME_CHOICE     2

//+-------------------------------------------------------------------------
//  Convert from OSS's UTCTime or GeneralizedTime to FILETIME.
//
//  Returns TRUE for a successful conversion.
//
//  Note, in asn1hdr.h, UTCTime has same typedef as GeneralizedTime.
//--------------------------------------------------------------------------
BOOL
WINAPI
OssConvFromChoiceOfTime(
    IN WORD wChoice,
    IN GeneralizedTime *pOssTime,
    OUT LPFILETIME pFileTime
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\oss\crypttls.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:       crypttls.h
//
//  Contents:   Crypt Thread Local Storage (TLS) and OssGlobal "world"
//              installation and allocation functions
//
//  APIs:
//              I_CryptAllocTls
//              I_CryptGetTls
//              I_CryptSetTls
//              I_CryptDetachTls
//              I_CryptInstallOssGlobal
//              I_CryptGetOssGlobal
//
//
//  History:    17-Nov-96    philh   created
//--------------------------------------------------------------------------

#ifndef __CRYPTTLS_H__
#define __CRYPTTLS_H__

#include "ossglobl.h"

#ifdef __cplusplus
extern "C" {
#endif


// Handle to an allocated Crypt TLS entry
typedef DWORD HCRYPTTLS;

// Handle to an installed OssGlobal table
typedef DWORD HCRYPTOSSGLOBAL;

// Pointer to OssGlobal. Returned by I_CryptGetOssGlobal()
typedef  OssGlobal  *POssGlobal;

//+-------------------------------------------------------------------------
//  Install a thread local storage entry and return a handle for future access.
//--------------------------------------------------------------------------
HCRYPTTLS
WINAPI
I_CryptAllocTls();

//+-------------------------------------------------------------------------
//  Get the thread specific pointer specified by the
//  hCryptTls returned by I_CryptAllocTls().
//
//  Returns NULL for an error or uninitialized pointer.
//--------------------------------------------------------------------------
void *
WINAPI
I_CryptGetTls(
    IN HCRYPTTLS hCryptTls
    );

//+-------------------------------------------------------------------------
//  Set the thread specific pointer specified by the
//  hCryptTls returned by I_CryptAllocTls().
//
//  Returns FALSE for an invalid handle or unable to allocate memory.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptSetTls(
    IN HCRYPTTLS hCryptTls,
    IN void *pvTls
    );

//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH or DLL_THREAD_DETACH to free the thread's
//  TLS entry specified by the hCryptTls. Returns the thread specific pointer
//  to be freed by the caller.
//--------------------------------------------------------------------------
void *
WINAPI
I_CryptDetachTls(
    IN HCRYPTTLS hCryptTls
    );

//+-------------------------------------------------------------------------
//  Install an OssGlobal entry and return a handle for future access.
//
//  Each thread has its own copy of OssGlobal. Allocation and
//  initialization are deferred until first referenced by the thread.
//
//  The parameter, pvCtlTbl is passed to ossinit() to initialize the OssGlobal.
//
//  I_CryptGetOssGlobal must be called with the handled returned by
//  I_CryptInstallOssGlobal to get the thread specific OssGlobal.
//
//  Currently, dwFlags and pvReserved aren't used and must be set to 0.
//--------------------------------------------------------------------------
HCRYPTOSSGLOBAL
WINAPI
I_CryptInstallOssGlobal(
    IN void *pvCtlTbl,
    IN DWORD dwFlags,
    IN void *pvReserved
    );

//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the OssGlobal specified by the
//  hOssGlobal returned by CryptInstallOssGlobal. If the
//  OssGlobal doesn't exist, then, its allocated and initialized using
//  the pvCtlTbl associated with hOssGlobal.
//--------------------------------------------------------------------------
POssGlobal
WINAPI
I_CryptGetOssGlobal(
    IN HCRYPTOSSGLOBAL hOssGlobal
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\exrwlck\exrwlck.cpp ===
//
// This file contains test implmentations of reader and writer locks.
// These are intended to be used with the template class in rw.h so that
// different implementations can be plugged in and tested.
// 
// The semantics of the read/write classes should be as follows : 
//	Functions CAN NOT be recursively called,
//	Multiple Readers should be able to enter the lock 
//	Only a single writer may execute at a time.
//


#ifndef WIN16


#include	<windows.h>
#include	<limits.h>

#define Assert(x)	// Just define a dummy Assert, so we don't get
                    // compilation errors from exrwlck.h

#include "badstrfunctions.h"
#include	"exrwlck.h"

#ifdef	DEBUG
#ifndef	_VALIDATE
#define	_VALIDATE( f )	if( (f) ) ; else DebugBreak() 
#endif
#else
#ifndef	_VALIDATE
#define	_VALIDATE( f ) 
#endif
#endif

long	const	BlockValue = (-LONG_MAX) / 2; 
                            // Large in magnitude, negative value.  Used to 
                            // indicate a waiting writer in cReadLock


CExShareLock::CExShareLock( ) : cReadLock( 0  ), cOutRdrs( 0 )	{
    InitializeCriticalSection( &critWriters ) ;
    hWaitingWriters = CreateSemaphore( NULL, 0, 1, NULL ) ;
    hWaitingReaders = CreateSemaphore( NULL, 0, LONG_MAX, NULL ) ;
}

CExShareLock::~CExShareLock( ) {
    CloseHandle( hWaitingWriters ) ;
    CloseHandle( hWaitingReaders ) ;
    DeleteCriticalSection( &critWriters ) ;
}


void
CExShareLock::ShareLock( ) {
    long	sign = InterlockedIncrement( &cReadLock ) ;
    if( sign > 0 ) {
        return ;
    }	else 	{
        // There must be a writer in the lock.  Wait for him to leave.
        // The InterlockedIncrement recorded our presence so that the writer
        // can later release the correct number of threads.
        WaitForSingleObject( hWaitingReaders, INFINITE ) ;
    }
}

void
CExShareLock::ShareUnlock( ) {
    //
    // Leave the lock.  The return value will be negative if there is a writer
    // waiting.
    BOOL fWriterWaiting = InterlockedDecrement( &cReadLock ) < 0 ;

    if( fWriterWaiting ) {
        //
        // The following increment occurs when there is writer waiting, but
        // readers own the lock.  So although cReadLock is temporarily inaccurate
        // about the number of readers waiting for the lock, it is not inaccurate 
        // when it matters in WriteUnlock (which assumes a writer owns the lock.)
        //
        long junk = InterlockedIncrement( &cReadLock ) ;	// restore the value in cReadLock, so that we
                                                // end up with an accurate count of readers waiting
                                                // for entry.  

        long sign = InterlockedDecrement( &cOutRdrs ) ;	// Make sure we don't lose track of the 
                                                // number for readers who have left the lock.
        //
        // Are we the last reader out of the lock ?
        //
        if( sign == 0 ) {
            //
            // Definately the last reader out !
            //
            ReleaseSemaphore( hWaitingWriters, 1, &junk ) ;
        }
    }
}

void
CExShareLock::ExclusiveLock( ) {
    // Only one writer allowed to try for the lock at a time.
    //
    EnterCriticalSection( &critWriters ) ;

    //
    // Need to track the number of readers who leave the lock while we 
    // are trying to grab it.
    //
    cOutRdrs = 0 ;
    // Grab the lock 
 	long	oldsign = InterlockedExchange( &cReadLock, BlockValue ) ;
    // How many readers left while we grabbed the lock ??
    long	oldval = InterlockedExchange( &cOutRdrs, oldsign ) ;

    //
    // Accurately track all the readers who left the lock.
    //
    long	cursign = 1 ;	// Initialize to 1 so that if while loop not executed
                            // following if statement works correctly.
    while( oldval++ ) 
        cursign = InterlockedDecrement( &cOutRdrs ) ; 

    //
    // Do we own the lock ?  Only if there were no readers, or they have all left already.
    //
    if( oldsign == 0 || cursign == 0 ) {
        // We have the lock
    }	else	{
        // Wait for a reader to signal us.
        WaitForSingleObject( hWaitingWriters, INFINITE ) ;
    }
}



void
CExShareLock::ExclusiveUnlock( ) 	{

    // Estimate how many readers are waiting for the lock
    long	cWaiting = cReadLock - BlockValue ;

    // This Exchange allows any readers who have just arrived to grab the lock.
    // Also, it accounts for cWaiting of the blocked readers.
    long	cNewWaiting = InterlockedExchange( &cReadLock, cWaiting ) - BlockValue ;
    
    // cNewWaiting is the EXACT number of blocked readers - we will increment cReadLock
    // until we have accounted for the difference between our estimate and the correct
    // number !
    long	cTotal = cNewWaiting ;	// Save cNewWaiting for later use
    while( cNewWaiting-- > cWaiting ) 
        InterlockedIncrement( &cReadLock ) ;

    if( cTotal > 0 ) {
        long	junk = 0 ;
        ReleaseSemaphore( hWaitingReaders, cTotal, &junk ) ;	// let all those readers go!
    }
    // Let the next writer take his shot at the lock!
    LeaveCriticalSection( &critWriters ) ;
}


BOOL
CExShareLock::SharedToExclusive( )	{

    // tbd - implement this!
    return( FALSE ) ;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\ess\oss\unicode.h ===
#ifndef __ECM_UNICODE_H__
#define __ECM_UNICODE_H__

// necessary defns -- remove?
#include <rpc.h>
#include <rpcdce.h>
#include <wincrypt.h>

#include <shfusion.h>

#ifdef __cplusplus
extern "C" {
#endif

BOOL WINAPI FIsWinNT(void);
BOOL WINAPI FIsWinNT5(VOID);
BOOL WINAPI MkMBStrEx(PBYTE pbBuff, DWORD cbBuff, LPCWSTR wsz, int cchW, char ** pszMB, int *pcbConverted);
BOOL WINAPI MkMBStr(PBYTE pbBuff, DWORD cbBuff, LPCWSTR wsz, char ** pszMB);
void WINAPI FreeMBStr(PBYTE pbBuff, char * szMB);

LPWSTR WINAPI MkWStr(char * szMB);
void WINAPI FreeWStr(LPWSTR wsz);


BOOL WINAPI wstr2guid(const WCHAR *pwszIn, GUID *pgOut);
BOOL WINAPI guid2wstr(const GUID *pgIn, WCHAR *pwszOut);

// The following is also needed for non-x86 due to a bug in advapi32 for
// CryptAcquireContextW.
BOOL WINAPI CryptAcquireContextU(
    HCRYPTPROV *phProv,
    LPCWSTR lpContainer,
    LPCWSTR lpProvider,
    DWORD dwProvType,
    DWORD dwFlags
    );

BOOL WINAPI CryptEnumProvidersU(
    DWORD dwIndex,
    DWORD *pdwReserved,
    DWORD dwFlags,
    DWORD *pdwProvType,
    LPWSTR pwszProvName,
    DWORD *pcbProvName
    );

// The following is also needed for non-x86 due to the fact that the
// A/W versions of the ListView_ functions do not exist.
// (these are implemented in ispu\common\unicode\commctrl.cpp)

int WINAPI ListView_InsertItemU(
    HWND hwnd,
    const LPLVITEMW pitem
    );

void WINAPI ListView_SetItemTextU(
    HWND hwnd,
    int i,
    int iSubItem,
    LPCWSTR pszText
    );

int WINAPI ListView_InsertColumnU(
    HWND hwnd,
    int i,
    const LPLVCOLUMNW plvC);

BOOL WINAPI ListView_GetItemU(
    HWND hwnd,
    LPLVITEMW pitem
    );


LONG WINAPI RegOpenHKCUKeyExA(
    HKEY hKey,  // handle of open key
    LPCSTR lpSubKey,    // address of name of subkey to open
    DWORD ulOptions,    // reserved
    REGSAM samDesired,  // security access mask
    PHKEY phkResult     // address of handle of open key
    );

//
//  the following api's handle the problem with impersinating another user
//  and having the HKEY_CURRENT_USER opened to an incorrect user's SID.
//
LONG WINAPI RegCreateHKCUKeyExU (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

LONG WINAPI RegCreateHKCUKeyExA (
    HKEY hKey,
    LPCSTR lpSubKey,
    DWORD Reserved,
    LPSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

LONG WINAPI RegOpenHKCUKeyExU(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
   );

LONG
WINAPI
RegOpenHKCU(
    HKEY *phKeyCurrentUser
    );

LONG
WINAPI
RegOpenHKCUEx(
    HKEY *phKeyCurrentUser,
    DWORD dwFlags
    );

// Normally, HKEY_USERS\CurrentSid is opened as the HKCU. However, if
// HKEY_USERS\CurrentSid doesn't exist, then, HKEY_USERS\.Default is
// opened.  Set the following flag to only open
// HKEY_USERS\.Default if the current user is the LocalSystem SID.
#define REG_HKCU_LOCAL_SYSTEM_ONLY_DEFAULT_FLAG     0x1

LONG
WINAPI
RegCloseHKCU(
    HKEY hKeyCurrentUser
    );

BOOL
WINAPI
GetUserTextualSidHKCU(
    IN      LPWSTR  wszTextualSid,
    IN  OUT LPDWORD pcchTextualSid
    );


#ifdef _M_IX86


// Reg.cpp
LONG WINAPI RegCreateKeyExU (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD Reserved,
    LPWSTR lpClass,
    DWORD dwOptions,
    REGSAM samDesired,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    PHKEY phkResult,
    LPDWORD lpdwDisposition
    );

LONG WINAPI RegDeleteKeyU(
    HKEY hKey,
    LPCWSTR lpSubKey
   );

LONG WINAPI RegEnumKeyExU (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
   );

LONG WINAPI RegEnumValueU (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpValueName,
    LPDWORD lpcbValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

LONG RegQueryValueExU(
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

LONG WINAPI RegSetValueExU (
    HKEY hKey,
    LPCWSTR lpValueName,
    DWORD Reserved,
    DWORD dwType,
    CONST BYTE* lpData,
    DWORD cbData
    );

LONG WINAPI RegDeleteValueU (
    HKEY hKey,
    LPCWSTR lpValueName
    );

LONG WINAPI RegQueryInfoKeyU (
    HKEY hKey,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    LPDWORD lpReserved,
    LPDWORD lpcSubKeys,
    LPDWORD lpcbMaxSubKeyLen,
    LPDWORD lpcbMaxClassLen,
    LPDWORD lpcValues,
    LPDWORD lpcbMaxValueNameLen,
    LPDWORD lpcbMaxValueLen,
    LPDWORD lpcbSecurityDescriptor,
    PFILETIME lpftLastWriteTime
    );

LONG WINAPI RegOpenKeyExU(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
   );

LONG WINAPI RegConnectRegistryU (
    LPWSTR lpMachineName,
    HKEY hKey,
    PHKEY phkResult
    );

// File.cpp
HANDLE WINAPI CreateFileU (
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );

BOOL
WINAPI
DeleteFileU(
    LPCWSTR lpFileName
    );

BOOL
WINAPI
CopyFileU(
          LPCWSTR lpwExistingFileName,
          LPCWSTR lpwNewFileName,
          BOOL bFailIfExists
          );

BOOL
WINAPI
MoveFileExU(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    DWORD dwFlags);

DWORD
WINAPI
GetFileAttributesU(
    LPCWSTR lpFileName
    );

BOOL
WINAPI
SetFileAttributesU(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
    );

DWORD
WINAPI
GetCurrentDirectoryU(
    DWORD nBufferLength,
    LPWSTR lpBuffer);

BOOL
WINAPI
CreateDirectoryU(
    LPCWSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

UINT
WINAPI
GetWindowsDirectoryU(
    LPWSTR lpBuffer,
    UINT uSize
    );

HINSTANCE WINAPI LoadLibraryU(
    LPCWSTR lpLibFileName
    );

HINSTANCE WINAPI LoadLibraryExU(
    LPCWSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    );

DWORD
WINAPI
ExpandEnvironmentStringsU(
    LPCWSTR lpSrc,
    LPWSTR lpDst,
    DWORD nSize
    );


// capi.cpp
BOOL WINAPI CryptSignHashU(
    HCRYPTHASH hHash,
    DWORD dwKeySpec,
    LPCWSTR lpDescription,
    DWORD dwFlags,
    BYTE *pbSignature,
    DWORD *pdwSigLen
    );

BOOL WINAPI CryptVerifySignatureU(
    HCRYPTHASH hHash,
    CONST BYTE *pbSignature,
    DWORD dwSigLen,
    HCRYPTKEY hPubKey,
    LPCWSTR lpDescription,
    DWORD dwFlags
    );

BOOL WINAPI CryptSetProviderU(
    LPCWSTR lpProvName,
    DWORD dwProvType
    );

// Ole.cpp
RPC_STATUS RPC_ENTRY UuidToStringU(
    UUID *  Uuid,
    WCHAR * *  StringUuid
   );

// nt.cpp
BOOL WINAPI GetUserNameU(
    LPWSTR lpBuffer,
    LPDWORD nSize
   );

BOOL WINAPI GetComputerNameU(
    LPWSTR lpBuffer,
    LPDWORD nSize
    );

DWORD WINAPI GetModuleFileNameU(
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
   );

HMODULE WINAPI GetModuleHandleU(
    LPCWSTR lpModuleName    // address of module name to return handle for
   );

// user.cpp
int WINAPI LoadStringU(
    HINSTANCE hInstance,
    UINT uID,
    LPWSTR lpBuffer,
    int nBufferMax
   );

DWORD WINAPI FormatMessageU(
    DWORD dwFlags,
    LPCVOID lpSource,
    DWORD dwMessageId,
    DWORD dwLanguageId,
    LPWSTR lpBuffer,
    DWORD nSize,
    va_list *Arguments
   );

BOOL WINAPI SetWindowTextU(
    HWND hWnd,
    LPCWSTR lpString
   );

int WINAPI DialogBoxParamU(
    HINSTANCE hInstance,
    LPCWSTR lpTemplateName,
    HWND hWndParent,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam
    );

UINT WINAPI GetDlgItemTextU(
    HWND hDlg,
    int nIDDlgItem,
    LPWSTR lpString,
    int nMaxCount
   );

BOOL WINAPI SetDlgItemTextU(
    HWND hDlg,
    int nIDDlgItem,
    LPCWSTR lpString
    );

int WINAPI MessageBoxU(
    HWND hWnd ,
    LPCWSTR lpText,
    LPCWSTR lpCaption,
    UINT uType
    );

int WINAPI LCMapStringU(
    LCID Locale,
    DWORD dwMapFlags,
    LPCWSTR lpSrcStr,
    int cchSrc,
    LPWSTR lpDestStr,
    int cchDest
    );

int WINAPI GetDateFormatU(
    LCID Locale,
    DWORD dwFlags,
    CONST SYSTEMTIME *lpDate,
    LPCWSTR lpFormat,
    LPWSTR lpDateStr,
    int cchDate
    );

int WINAPI GetTimeFormatU(
    LCID Locale,
    DWORD dwFlags,
    CONST SYSTEMTIME *lpTime,
    LPCWSTR lpFormat,
    LPWSTR lpTimeStr,
    int cchTime
    );

BOOL WINAPI WinHelpU(
    HWND hWndMain,
    LPCWSTR lpszHelp,
    UINT uCommand,
    DWORD dwData
    );

LRESULT WINAPI SendMessageU(
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    );

LONG WINAPI
SendDlgItemMessageU(
    HWND hDlg,
    int nIDDlgItem,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam
    );

LPWSTR
WINAPI
GetCommandLineU(void);

BOOL
WINAPI
IsBadStringPtrU(IN LPWSTR lpsz, UINT ucchMax);

void
WINAPI
OutputDebugStringU(IN LPWSTR lpwsz);

int
WINAPI
DrawTextU(
    HDC     hDC,
    LPCWSTR lpString,
    int     nCount,
    LPRECT  lpRect,
    UINT    uFormat
);

// event.cpp
HANDLE
WINAPI
CreateEventU(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName);

HANDLE
WINAPI
RegisterEventSourceU(
                    LPCWSTR lpUNCServerName,
                    LPCWSTR lpSourceName);

HANDLE
WINAPI
OpenEventU(
           DWORD dwDesiredAccess,
           BOOL bInheritHandle,
           LPCWSTR lpName);

HANDLE
WINAPI
CreateMutexU(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCWSTR lpName);

HANDLE
WINAPI
OpenMutexU(
           DWORD dwDesiredAccess,
           BOOL bInheritHandle,
           LPCWSTR lpName);

HFONT
WINAPI
CreateFontIndirectU(CONST LOGFONTW *lplf);

#else

#define RegQueryValueExU        RegQueryValueExW
#define RegCreateKeyExU         RegCreateKeyExW
#define RegDeleteKeyU           RegDeleteKeyW
#define RegEnumKeyExU           RegEnumKeyExW
#define RegEnumValueU           RegEnumValueW
#define RegSetValueExU          RegSetValueExW
#define RegQueryInfoKeyU        RegQueryInfoKeyW
#define RegDeleteValueU         RegDeleteValueW
#define RegOpenKeyExU           RegOpenKeyExW
#define RegConnectRegistryU     RegConnectRegistryW
#define ExpandEnvironmentStringsU ExpandEnvironmentStringsW

#define CreateFileU             CreateFileW
#define DeleteFileU             DeleteFileW
#define CopyFileU               CopyFileW
#define GetFileAttributesU      GetFileAttributesW
#define SetFileAttributesU      SetFileAttributesW
#define GetCurrentDirectoryU    GetCurrentDirectoryW
#define CreateDirectoryU        CreateDirectoryW
#define GetWindowsDirectoryU    GetWindowsDirectoryW
#define LoadLibraryU            LoadLibraryW
#define LoadLibraryExU          LoadLibraryExW

#define CryptSignHashU          CryptSignHashW
#define CryptVerifySignatureU   CryptVerifySignatureW
#define CryptSetProviderU       CryptSetProviderW

#define UuidToStringU           UuidToStringW

#define GetUserNameU            GetUserNameW
#define GetComputerNameU        GetComputerNameW
#define GetModuleFileNameU      GetModuleFileNameW
#define GetModuleHandleU        GetModuleHandleW

#define LoadStringU             LoadStringW
#define FormatMessageU          FormatMessageW
#define SetWindowTextU          SetWindowTextW
#define DialogBoxParamU         DialogBoxParamW
#define GetDlgItemTextU         GetDlgItemTextW
#define SetDlgItemTextU         SetDlgItemTextW
#define MessageBoxU     MessageBoxW
#define LCMapStringU            LCMapStringW
#define GetDateFormatU          GetDateFormatW
#define GetTimeFormatU          GetTimeFormatW
#define WinHelpU                WinHelpW
#define SendMessageU            SendMessageW
#define SendDlgItemMessageU     SendDlgItemMessageW
#define IsBadStringPtrU         IsBadStringPtrW
#define OutputDebugStringU      OutputDebugStringW
#define GetCommandLineU         GetCommandLineW
#define DrawTextU               DrawTextW

#define CreateEventU            CreateEventW
#define RegisterEventSourceU    RegisterEventSourceW
#define OpenEventU              OpenEventW
#define CreateMutexU            CreateMutexW
#define OpenMutexU              OpenMutexW

#define CreateFontIndirectU     CreateFontIndirectW

#endif // _M_IX86

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\fntcache\fontcash.h ===
#ifndef _FONTCASH_H
#define _FONTCASH_H

#include "privunk.h"
#include "mimeole.h"
#include "msoert.h"
#include <ocidl.h>

typedef struct FONTCACHEENTRY_tag 
{
    UINT            uiCodePage;
    TCHAR           szFaceName[LF_FACESIZE];
    HFONT           rgFonts[FNT_SYS_LAST];
} FONTCACHEENTRY, *PFONTCACHEENTRY;

// =================================================================================
// Font Cache Definition
// =================================================================================
class CFontCache :  public CPrivateUnknown, 
                    public IFontCache, 
                    public IConnectionPoint
{
private:
    HRESULT InitResources();
    HRESULT FreeResources();

    void SendPostChangeNotifications();
    void SendPreChangeNotifications();

    HRESULT InitSysFontEntry();
    HRESULT GetSysFont(FNTSYSTYPE fntType, HFONT *phFont);

    HRESULT SetGDIAndFaceNameInLF(UINT uiCodePage, CODEPAGEID cpID, LOGFONT *lpLF);
    HRESULT SetFaceNameFromCPID(UINT cpID, LPTSTR szFaceName, DWORD cchFaceName);
    HRESULT SetFaceNameFromGDI(BYTE bGDICharSet, LPTSTR szFaceName, DWORD cchFaceName);
    HRESULT SetFaceNameFromReg(UINT uiCodePage, LPTSTR szFaceName, DWORD cchFaceName);

    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);

    IUnknownList       *m_pAdviseRegistry;
    IVoidPtrList       *m_pFontEntries;
    FONTCACHEENTRY      *m_pSysCacheEntry;
    HKEY                m_hkey;
    TCHAR               m_szIntlKeyPath[1024];
    CRITICAL_SECTION    m_rFontCritSect,
                        m_rAdviseCritSect;
    BOOL                m_bISO_2022_JP_ESC_SIO_Control;
    UINT                m_uiSystemCodePage;

public:
    CFontCache(IUnknown *pUnkOuter=NULL);
    virtual ~CFontCache();
    
    // IUnknown members
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { 
        return CPrivateUnknown::QueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void) { 
        return CPrivateUnknown::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) { 
        return CPrivateUnknown::Release(); };

    // IFontCache functions
    virtual HRESULT STDMETHODCALLTYPE Init(HKEY hkey, LPCSTR pszIntlKey, DWORD dwFlags);

    virtual HRESULT STDMETHODCALLTYPE GetFont(
                    FNTSYSTYPE fntType, 
                    HCHARSET hCharset,
                    HFONT *phFont);

    virtual HRESULT STDMETHODCALLTYPE OnOptionChange();

    virtual HRESULT STDMETHODCALLTYPE GetJP_ISOControl(BOOL *pfUseSIO);

    // IConnectionPoint functions
    virtual HRESULT STDMETHODCALLTYPE GetConnectionInterface(IID *pIID);        

    virtual HRESULT STDMETHODCALLTYPE GetConnectionPointContainer(
                    IConnectionPointContainer **ppCPC);

    virtual HRESULT STDMETHODCALLTYPE Advise(IUnknown *pUnkSink, DWORD *pdwCookie);        

    virtual HRESULT STDMETHODCALLTYPE Unadvise(DWORD dwCookie);        

    virtual HRESULT STDMETHODCALLTYPE EnumConnections(IEnumConnections **ppEnum);

    static HRESULT CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\fntcache\fontcash.cpp ===
#include "pch.hxx"
#include "shlwapi.h"
#include "fontcash.h"
#include "strconst.h"
#include "inetreg.h"
#include "oleutil.h"
#include "msoedbg.h"
#include <wingdi.h>
#include "demand.h"


HRESULT CreateFontCacheEntry(FONTCACHEENTRY **ppNewEntry)
{
    HRESULT hr = S_OK;
    FONTCACHEENTRY* pNew;

    if (!MemAlloc((LPVOID *)&pNew, sizeof(FONTCACHEENTRY)))
        hr = E_OUTOFMEMORY;
    else
        {
        pNew->uiCodePage = 0;
        pNew->szFaceName[0] = TCHAR(0);
        for (int i = 0; i < FNT_SYS_LAST; i++)
            pNew->rgFonts[i] = 0;
        }
    *ppNewEntry = pNew;
    return S_OK;
}

void FreeFontsInEntry(FONTCACHEENTRY *pEntry)
{
    for (int i = 0; i < FNT_SYS_LAST; i++)
        if (pEntry->rgFonts[i])
            {
            DeleteObject(pEntry->rgFonts[i]);
            pEntry->rgFonts[i] = 0;
            }
}

HRESULT FreeFontCacheEntry(FONTCACHEENTRY *pEntry)
{
    Assert(pEntry);

    FreeFontsInEntry(pEntry);
    MemFree(pEntry);

    return S_OK;
}


// =================================================================================
// Font Cache Implementation
// =================================================================================

CFontCache::CFontCache(IUnknown *pUnkOuter) : CPrivateUnknown(pUnkOuter),
            m_pAdviseRegistry(NULL), m_pFontEntries(NULL), 
            m_pSysCacheEntry(NULL), m_bISO_2022_JP_ESC_SIO_Control(false),
            m_uiSystemCodePage(0)
{
    InitializeCriticalSection(&m_rFontCritSect);
    InitializeCriticalSection(&m_rAdviseCritSect);
}

//***************************************************
CFontCache::~CFontCache()
{
    if (m_pAdviseRegistry)
        m_pAdviseRegistry->Release();

    if (m_pFontEntries)
        m_pFontEntries->Release();

    if (m_pSysCacheEntry)
        FreeFontCacheEntry(m_pSysCacheEntry);

    DeleteCriticalSection(&m_rFontCritSect);
    DeleteCriticalSection(&m_rAdviseCritSect);
}

//***************************************************
HRESULT CFontCache::InitSysFontEntry()
{
    // Locals
    NONCLIENTMETRICS    ncm;
    CHARSETINFO         rCharsetInfo={0};
    UINT                nACP;
    HRESULT             hr = S_OK;
    LOGFONT             rSysLogFonts;

    Assert(m_pSysCacheEntry);

    // Get system ansi code page
    nACP = GetACP();
    m_pSysCacheEntry->uiCodePage = nACP;
    m_uiSystemCodePage = nACP;

    // Get the charset for the current ANSI code page
    TranslateCharsetInfo((DWORD *)IntToPtr(MAKELONG(nACP, 0)), &rCharsetInfo, TCI_SRCCODEPAGE);

    // Get icon font metrics
    if (SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &rSysLogFonts, 0))
        {
        StrCpyN(m_pSysCacheEntry->szFaceName, rSysLogFonts.lfFaceName, ARRAYSIZE(m_pSysCacheEntry->szFaceName));

        // Reset lfCharset depending on the current ansi code page
        rSysLogFonts.lfCharSet = (BYTE) rCharsetInfo.ciCharset;

        //$HACK - This code is necessary to work around a bug in Windows.
        //        If the icon font has never been changed from the default,
        //        SystemParametersInfo returns the wrong height.  We need
        //        to select the font into a DC and get the textmetrics to
        //        determine the correct height.  (EricAn)        
        HFONT hFont;
        if (hFont = CreateFontIndirect(&rSysLogFonts))
            {
            HDC hdc;
            if (hdc = GetDC(NULL))
                {
                TEXTMETRIC tm;
                HFONT hFontOld = SelectFont(hdc, hFont);
                GetTextMetrics(hdc, &tm);
                rSysLogFonts.lfHeight = -(tm.tmHeight - tm.tmInternalLeading);
                SelectFont(hdc, hFontOld);
                ReleaseDC(NULL, hdc);
                }
            DeleteObject(hFont);
            }
        if (m_pSysCacheEntry->rgFonts[FNT_SYS_ICON] == 0)
            m_pSysCacheEntry->rgFonts[FNT_SYS_ICON] = CreateFontIndirect(&rSysLogFonts);

        // Bold Icon Font
        if (m_pSysCacheEntry->rgFonts[FNT_SYS_ICON_BOLD] == 0)
            {
            LONG lOldWeight = rSysLogFonts.lfWeight;
            rSysLogFonts.lfWeight = (rSysLogFonts.lfWeight < 700) ? 700 : 1000;
            m_pSysCacheEntry->rgFonts[FNT_SYS_ICON_BOLD] = CreateFontIndirect(&rSysLogFonts);
            rSysLogFonts.lfWeight = lOldWeight;
            }

        if (m_pSysCacheEntry->rgFonts[FNT_SYS_ICON_STRIKEOUT] == 0)
            {
            rSysLogFonts.lfStrikeOut = TRUE;
            m_pSysCacheEntry->rgFonts[FNT_SYS_ICON_STRIKEOUT] = CreateFontIndirect(&rSysLogFonts);
            }
        }
    else
        {
        AssertSz (FALSE, "SystemParametersInfo (SPI_GETICONTITLELOGFONT) - Failed ---.");
        hr = E_FAIL;
        goto Exit;
        }
 
    if (m_pSysCacheEntry->rgFonts[FNT_SYS_MENU] == 0)
        {
#ifndef WIN16   // WIN16FF - SPI_GETNONCLIENTMETRICS
        // Prepare to get icon metrics
        ncm.cbSize = sizeof(ncm);
    
        // Get system menu font
        if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0))
            {
            CopyMemory((LPBYTE)&rSysLogFonts, (LPBYTE)&ncm.lfMenuFont, sizeof(LOGFONT));
            m_pSysCacheEntry->rgFonts[FNT_SYS_MENU] = CreateFontIndirect(&rSysLogFonts);
            }
        else
            {
            AssertSz (FALSE, "SystemParametersInfo (SPI_GETNONCLIENTMETRICS) - Failed ---.");
            hr = E_FAIL;
            goto Exit;
            }
#else
        m_pSysCacheEntry->rgFonts[FNT_SYS_MENU] = m_pSysCacheEntry->rgFonts[FNT_SYS_ICON];
#endif
        }
Exit:
    return hr;
}

//***************************************************
HRESULT CFontCache::GetSysFont(FNTSYSTYPE fntType, HFONT *phFont)
{
    // check params
    Assert(fntType < FNT_SYS_LAST);
    Assert(m_pSysCacheEntry);

    EnterCriticalSection(&m_rFontCritSect);

    // System Font
    if (m_pSysCacheEntry->rgFonts[fntType] == NULL)
        // This call might fail, but we can return NULL fonts, so is OK
        (void)InitSysFontEntry();

    // Done
    *phFont = m_pSysCacheEntry->rgFonts[fntType];

    LeaveCriticalSection(&m_rFontCritSect);

    return ((*phFont) ? S_OK : E_FAIL);
}

//***************************************************
HRESULT CFontCache::FreeResources()
{
    m_pFontEntries->ClearList();
    FreeFontsInEntry(m_pSysCacheEntry);

    return S_OK;
}

//***************************************************
HRESULT CFontCache::InitResources()
{
    DWORD dummyCookie = 0;

#ifdef DEBUG
    DWORD cCount;
    m_pFontEntries->GetCount(&cCount);
    Assert(cCount == 0);
#endif

    HRESULT hr = InitSysFontEntry();

    return hr;
}

//***************************************************
void CFontCache::SendPostChangeNotifications()
{
    DWORD cookie = 0;
    IFontCacheNotify* pCurr;
    IUnknown* pTempCurr;

    while(SUCCEEDED(m_pAdviseRegistry->GetNext(LD_FORWARD, &pTempCurr, &cookie)))
    {
        if (pTempCurr->QueryInterface(IID_IFontCacheNotify, (LPVOID *)&pCurr)==S_OK)
        {
            pCurr->OnPostFontChange();
            pCurr->Release();
        }

        pTempCurr->Release();
    }
}

//***************************************************
void CFontCache::SendPreChangeNotifications()
{
    DWORD cookie = 0;
    IFontCacheNotify* pCurr;
    IUnknown* pTempCurr;

    while(SUCCEEDED(m_pAdviseRegistry->GetNext(LD_FORWARD, &pTempCurr, &cookie)))
    {
        if (pTempCurr->QueryInterface(IID_IFontCacheNotify, (LPVOID *)&pCurr)==S_OK)
        {
            pCurr->OnPreFontChange();
            pCurr->Release();
        }

        pTempCurr->Release();
    }
}


//************************************
// IFontCache interface implementation
//************************************
HRESULT CFontCache::Init(HKEY hkey, LPCSTR pszIntlKey, DWORD dwFlags)
{
    HRESULT hr;
    DWORD   dummyCookie, dw, cb;
    HKEY    hTopkey;

    if (m_pSysCacheEntry)
        return E_UNEXPECTED;

    EnterCriticalSection(&m_rFontCritSect);
    EnterCriticalSection(&m_rAdviseCritSect);

    hr = IUnknownList_CreateInstance(&m_pAdviseRegistry);
    if (FAILED(hr))
        goto Exit;
    hr = m_pAdviseRegistry->Init(NULL, 0, 0);
    if (FAILED(hr))
        goto Exit;
    
    hr = IVoidPtrList_CreateInstance(&m_pFontEntries);
    if (FAILED(hr))
        goto Exit;

    hr = m_pFontEntries->Init(NULL, 0, (IVPL_FREEITEMFUNCTYPE)(&FreeFontCacheEntry), 0);
    if (FAILED(hr))
        goto Exit;

    hr = CreateFontCacheEntry(&m_pSysCacheEntry);
    if (FAILED(hr))
        goto Exit;

    hr = InitResources();
    if (FAILED(hr))
        goto Exit;

    m_hkey = hkey;
    StrCpyN(m_szIntlKeyPath, pszIntlKey, ARRAYSIZE(m_szIntlKeyPath));
    if (RegOpenKeyEx(m_hkey, m_szIntlKeyPath, NULL, KEY_READ, &hTopkey) == ERROR_SUCCESS)
        {
        cb = sizeof(dw);
        if (RegQueryValueEx(hTopkey, c_szISO2022JPControl, NULL, NULL, (LPBYTE)&dw, &cb) == ERROR_SUCCESS)
            m_bISO_2022_JP_ESC_SIO_Control = (BOOL) dw;
        else
            m_bISO_2022_JP_ESC_SIO_Control = false;
        RegCloseKey(hTopkey);
        }
    else
        m_bISO_2022_JP_ESC_SIO_Control = false;

Exit:
    LeaveCriticalSection(&m_rAdviseCritSect);
    LeaveCriticalSection(&m_rFontCritSect);

    return hr;
}

//***************************************************
HRESULT CFontCache::GetFont(FNTSYSTYPE fntType, HCHARSET hCharset, HFONT *phFont)
{
    INETCSETINFO    CsetInfo;
    UINT            uiCodePage = 0;
    FONTCACHEENTRY  *pCurrEntry = NULL;
    DWORD           cookie = 0;

    // check params
    Assert(fntType < FNT_SYS_LAST);

    Assert(m_pSysCacheEntry);

    if (hCharset == NULL)
        return GetSysFont(fntType, phFont);

    *phFont = 0;

    /* get CodePage from HCHARSET */
    MimeOleGetCharsetInfo(hCharset,&CsetInfo);
    uiCodePage = (CP_JAUTODETECT == CsetInfo.cpiWindows) ? 932 : CsetInfo.cpiWindows;
    if ( uiCodePage == CP_KAUTODETECT )
        uiCodePage = 949 ;

    // Don't want to duplicate the system codepage in the list.
    if (m_pSysCacheEntry && (uiCodePage == m_uiSystemCodePage))
        return GetSysFont(fntType, phFont);

    EnterCriticalSection(&m_rFontCritSect);
    
    // Check to see if code page is in cache
    while (SUCCEEDED(m_pFontEntries->GetNext(LD_FORWARD, (LPVOID *)&pCurrEntry, &cookie)))
        if (pCurrEntry->uiCodePage == uiCodePage)
            break;

    // If code page not in cache, add it
    if (NULL == pCurrEntry)
        {
        if (FAILED(CreateFontCacheEntry(&pCurrEntry)))
            goto ErrorExit;
        if (FAILED(m_pFontEntries->AddItem(pCurrEntry, &cookie)))
            goto ErrorExit;
        pCurrEntry->uiCodePage = uiCodePage;
        }

    // See if desired font is available for code page. If not, create code page
    if (0 == pCurrEntry->rgFonts[fntType])
        {
        // Locals
        LOGFONT lf;
        TCHAR  szFaceName[LF_FACESIZE] = { TCHAR(0) } ;
        BYTE bGDICharset;

        // Get logfont for charset
        if (0 == GetObject(m_pSysCacheEntry->rgFonts[fntType], sizeof (LOGFONT), &lf))
            goto ErrorExit;

        if (FAILED(SetGDIAndFaceNameInLF(uiCodePage, CsetInfo.cpiWindows, &lf)))
            goto ErrorExit;

        // Create the font
        if ((CP_UNICODE == uiCodePage) || IsValidCodePage(uiCodePage))
            pCurrEntry->rgFonts[fntType] = CreateFontIndirect(&lf);
        else
            goto ErrorExit;
        }

    *phFont = pCurrEntry->rgFonts[fntType];

    LeaveCriticalSection(&m_rFontCritSect);

    return S_OK;

ErrorExit:
    LeaveCriticalSection(&m_rFontCritSect);
    return GetSysFont(fntType, phFont);
}

//***************************************************
HRESULT CFontCache::OnOptionChange()
{
    HRESULT hr;
    
    EnterCriticalSection(&m_rAdviseCritSect);
    SendPreChangeNotifications();
    EnterCriticalSection(&m_rFontCritSect);

    FreeResources();
    // Even if this fails, still need to send notifications
    InitResources();

    LeaveCriticalSection(&m_rFontCritSect);    
    SendPostChangeNotifications();
    LeaveCriticalSection(&m_rAdviseCritSect);    

    return S_OK;
}

//***************************************************
HRESULT CFontCache::GetJP_ISOControl(BOOL *pfUseSIO)
{
    // 0 means use ESC, 1 means use SIO
    *pfUseSIO = m_bISO_2022_JP_ESC_SIO_Control;

    return S_OK;
}

//******************************************
// IConnectionPoint interface implementation
//
// The only functions we care about right now
// are the Advise and Unadvise functions. The
// others return E_NOTIMPL
//******************************************
HRESULT CFontCache::Advise(IUnknown *pUnkSink, DWORD *pdwCookie)        
{
    EnterCriticalSection(&m_rAdviseCritSect);
    HRESULT hr = m_pAdviseRegistry->AddItem(pUnkSink, pdwCookie);
    LeaveCriticalSection(&m_rAdviseCritSect);    
    return hr;
}

//***************************************************
HRESULT CFontCache::Unadvise(DWORD dwCookie)        
{
    EnterCriticalSection(&m_rAdviseCritSect);
    HRESULT hr = m_pAdviseRegistry->RemoveItem(dwCookie);
    LeaveCriticalSection(&m_rAdviseCritSect);    
    return hr;
}

//***************************************************
HRESULT CFontCache::GetConnectionInterface(IID *pIID)        
{
    return E_NOTIMPL;
}

//***************************************************
HRESULT CFontCache::GetConnectionPointContainer(IConnectionPointContainer **ppCPC)
{
    *ppCPC = NULL;
    return E_NOTIMPL;
}

//***************************************************
HRESULT CFontCache::EnumConnections(IEnumConnections **ppEnum)
{
    *ppEnum = NULL;
    return E_NOTIMPL;
}

//***************************************************
HRESULT CFontCache::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    TraceCall("CFontCache::PrivateQueryInterface");

    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IFontCache))
        *lplpObj = (LPVOID)(IFontCache *)this;
    else if (IsEqualIID(riid, IID_IConnectionPoint))
        *lplpObj = (LPVOID)(IConnectionPoint *)this;
    else
        {
        *lplpObj = NULL;
        return E_NOINTERFACE;
        }
    AddRef();
    return NOERROR;
}



//***************************************************
// szFaceName is assumed to be from LOGFONT->lfFaceName
HRESULT CFontCache::SetFaceNameFromReg(UINT uiCodePage, LPTSTR szFaceName, DWORD cchFaceName)
{
    HKEY    hkey, hTopkey;
    DWORD   cb, dw, i = 0;
    TCHAR   szName[LF_FACESIZE];

    szFaceName[0] = TCHAR(0);

    if (RegOpenKeyEx(m_hkey, m_szIntlKeyPath, NULL, KEY_READ, &hTopkey) == ERROR_SUCCESS)
        {
        cb = sizeof(szName);
        while (ERROR_NO_MORE_ITEMS != RegEnumKeyEx(hTopkey, i++, szName, &cb, 0, NULL, NULL, NULL))
            {
            UINT uiTempCodePage = StrToInt(szName);
            if (uiTempCodePage == uiCodePage)
                {
                if (RegOpenKeyEx(hTopkey, szName, NULL, KEY_READ, &hkey) == ERROR_SUCCESS)
                    {
                    cb = sizeof(TCHAR)*cchFaceName;
                    RegQueryValueEx(hkey, REGSTR_VAL_PROP_FONT, NULL, NULL, (LPBYTE)szFaceName, &cb);

                    RegCloseKey(hkey);
                    break;
                    }
                }
            cb = sizeof(szName);
            }
        RegCloseKey(hTopkey);
        }

    if (TCHAR(0) == szFaceName[0])
        return E_FAIL;

    return S_OK;
}

// =================================================================================
// EnumFontFamExProc
// =================================================================================
INT CALLBACK EnumFontFamExProc (ENUMLOGFONTEX   *lpelfe,	
                                NEWTEXTMETRICEX *lpntme, 
                                INT              FontType,
                                LPARAM           lParam)
{
    // Check Param
    Assert (lpelfe && lpntme && lParam);

    // NOTE: Assuming size of buffer is LF_FACESIZE. If it changes below, change
    // here also.
    StrCpyN((LPTSTR)lParam, lpelfe->elfLogFont.lfFaceName, LF_FACESIZE);

    // End the enumeration by return 0
    return 0;
}

//***************************************************
// szFaceName is assumed to be from LOGFONT->lfFaceName
HRESULT CFontCache::SetFaceNameFromGDI(BYTE bGDICharSet, LPTSTR szFaceName, DWORD cchFaceName)
{
    HDC     hdc;
    LOGFONT rSysLogFont;

    // I know these charsets support Arial
    if (bGDICharSet == ANSI_CHARSET    || bGDICharSet == EASTEUROPE_CHARSET ||
        bGDICharSet == RUSSIAN_CHARSET || bGDICharSet == BALTIC_CHARSET     ||
        bGDICharSet == GREEK_CHARSET   || bGDICharSet == TURKISH_CHARSET)
        {
        StrCpyN(szFaceName, TEXT("Arial"), cchFaceName);
        goto Exit;
        }

    if (0 == GetObject(m_pSysCacheEntry->rgFonts[FNT_SYS_ICON], sizeof (LOGFONT), &rSysLogFont))
        {
        StrCpyN(szFaceName, rSysLogFont.lfFaceName, cchFaceName);
        if (TCHAR(0) != szFaceName[0])
            goto Exit;
        }

    // Get an hdc from the hwnd
    hdc = GetDC (NULL);

    TCHAR szName[LF_FACESIZE]; // Note: If we change size, change callback above.

    // EnumFontFamilies
    EnumFontFamiliesEx(hdc, &rSysLogFont, (FONTENUMPROC)EnumFontFamExProc, (LPARAM)szName, 0);

    StrCpyN(szFaceName, szName, cchFaceName);

    // Done
    ReleaseDC (NULL, hdc);

Exit:
    return (0 != *szFaceName) ? S_OK : E_FAIL;
}

//***************************************************
// szFaceName is assumed to be from LOGFONT->lfFaceName
HRESULT CFontCache::SetFaceNameFromCPID(UINT cpID, LPTSTR szFaceName, DWORD cchFaceName)
{
    CODEPAGEINFO CodePageInfo ;

    /* get CodePageInfo from HCHARSET */
    MimeOleGetCodePageInfo(cpID,&CodePageInfo);
    if ( CodePageInfo.szVariableFont[0] != '\0' )
        StrCpyN(szFaceName, CodePageInfo.szVariableFont, cchFaceName);
    else
        StrCpyN(szFaceName, CodePageInfo.szFixedFont, cchFaceName);

    if (szFaceName[0] == '\0')
        return E_FAIL;
    
    return S_OK;
}

//***************************************************
HRESULT CFontCache::SetGDIAndFaceNameInLF(UINT uiCodePage, CODEPAGEID cpID, LOGFONT *lpLF)
{
    HRESULT     hr = S_OK;
    BOOL        fDoLastChance = false;
    CHARSETINFO rCharsetInfo;

    if (FAILED(SetFaceNameFromReg(uiCodePage, lpLF->lfFaceName, ARRAYSIZE(lpLF->lfFaceName))))
        if (FAILED(SetFaceNameFromCPID(cpID, lpLF->lfFaceName, ARRAYSIZE(lpLF->lfFaceName))))
            fDoLastChance = true;

    if ( TranslateCharsetInfo((LPDWORD) IntToPtr(uiCodePage), &rCharsetInfo, TCI_SRCCODEPAGE))
        lpLF->lfCharSet = (BYTE) rCharsetInfo.ciCharset;
    else
        lpLF->lfCharSet = DEFAULT_CHARSET;

    if (fDoLastChance)
        hr = SetFaceNameFromGDI(lpLF->lfCharSet, lpLF->lfFaceName, ARRAYSIZE(lpLF->lfFaceName));

    return hr;
}

//***************************************************
HRESULT CFontCache::CreateInstance(IUnknown* pUnkOuter, IUnknown** ppUnknown)
{
    // Invalid Arg
    Assert(ppUnknown);

    // Initialize
    *ppUnknown = NULL;

    // Create me
    CFontCache *pNew = new CFontCache(pUnkOuter);
    if (NULL == pNew)
        return (E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = (IFontCache*)pNew;

    // Done
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\asynconn.cpp ===
/*
 *    asynconn.cpp
 *    
 *    Purpose:
 *        implementation of the async connection class
 *    
 *    Owner:
 *        EricAn
 *
 *    History:
 *      Apr 96: Created.
 *    
 *    Copyright (C) Microsoft Corp. 1996
 */

#include <pch.hxx>
#include <process.h>
#include "imnxport.h"
#include "dllmain.h"
#include "asynconn.h"
#include "thorsspi.h"
#include "resource.h"
#include "strconst.h"
#include "lookup.h"
#include <demand.h>
#include <shlwapi.h>

ASSERTDATA

#define STREAM_BUFSIZE  8192
#define FLOGSESSION  (m_pLogFile && TRUE /* profile setting to enable logging should be here */)

// These are the notification messages that we register for the asynchronous
// socket operations that we use.
#define SPM_WSA_SELECT          (WM_USER + 1)

// Async Timer Message used for doing Timeouts
#define SPM_ASYNCTIMER          (WM_USER + 3)

#ifdef DEBUG
#define EnterCS(_pcs)                   \
            {                           \
            EnterCriticalSection(_pcs); \
            m_cLock++;                  \
            IxpAssert(m_cLock > 0);     \
            }
#define LeaveCS(_pcs)                   \
            {                           \
            m_cLock--;                  \
            IxpAssert(m_cLock >= 0);    \
            LeaveCriticalSection(_pcs); \
            }
#else
#define EnterCS(_pcs)                   \
            EnterCriticalSection(_pcs);
#define LeaveCS(_pcs)                   \
            LeaveCriticalSection(_pcs);
#endif

BOOL FEndLine(char *psz, int iLen);

static const char s_szConnWndClass[] = "ThorConnWndClass";

extern LPSRVIGNORABLEERROR g_pSrvErrRoot;

// This function try to find server and ignorable error, assigned to this server
// if not found then add to list and set ignorable error to S_OK

LPSRVIGNORABLEERROR FindOrAddServer(TCHAR * pchServerName, LPSRVIGNORABLEERROR pSrvErr, LPSRVIGNORABLEERROR  *ppSrv)
{
    int i = 0;

    // if we already had entry in tree then recurse search
    if(pSrvErr)
    {
        i = lstrcmpi(pchServerName, pSrvErr->pchServerName);
        if(i > 0)
        {
            pSrvErr->pRight = FindOrAddServer(pchServerName, pSrvErr->pRight, ppSrv);
            return(pSrvErr);
        }
        else if(i < 0)
        {
            pSrvErr->pLeft = FindOrAddServer(pchServerName, pSrvErr->pLeft, ppSrv);
            return(pSrvErr);
        }
        else
        {
            *ppSrv = pSrvErr;
            return(pSrvErr);
        }
    }

    // if we don't have node, create it
    i = lstrlen(pchServerName);

    // if server name is empty return
    if(i == 0)
        return(NULL);


    // Allocate memory for structure
    if (!MemAlloc((LPVOID*)&pSrvErr, sizeof(SRVIGNORABLEERROR)))
        return(NULL);

    pSrvErr->pRight = NULL;
    pSrvErr->pLeft = NULL;
    pSrvErr->hrError = S_OK;

    if (!MemAlloc((LPVOID*)&(pSrvErr->pchServerName), (i+1) * sizeof(pSrvErr->pchServerName[0]) ))
    {
        MemFree(pSrvErr);
        return(NULL);
    }

    StrCpyN(pSrvErr->pchServerName, pchServerName, (i+1));

    *ppSrv = pSrvErr;

    return(pSrvErr);
}

void FreeSrvErr(LPSRVIGNORABLEERROR pSrvErr)
{
    // if structure NULL return immediately
    if(!pSrvErr)
        return;

    FreeSrvErr(pSrvErr->pRight);
    FreeSrvErr(pSrvErr->pLeft);

    if(pSrvErr->pchServerName)
    {
        MemFree(pSrvErr->pchServerName);
        pSrvErr->pchServerName = NULL;
    }

    MemFree(pSrvErr);
    pSrvErr = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// 
// PUBLIC METHODS - these need to be synchronized as they are accessed by the
//                  owning thread and the asynchronous socket pump thread.
//
/////////////////////////////////////////////////////////////////////////////

CAsyncConn::CAsyncConn(ILogFile *pLogFile, IAsyncConnCB *pCB, IAsyncConnPrompt *pPrompt)
{
    m_cRef = 1;
    m_chPrev = '\0';
    m_fStuffDots = FALSE;
    m_sock = INVALID_SOCKET;
    m_fLookup = FALSE;
    m_state = AS_DISCONNECTED;
    m_fCachedAddr = FALSE;
    m_fRedoLookup = FALSE;
    m_pszServer = NULL;
    m_iDefaultPort = 0;
    m_iLastError = 0;
    InitializeCriticalSection(&m_cs);
    m_pLogFile = pLogFile;
    if (m_pLogFile)
        m_pLogFile->AddRef();
    Assert(pCB);
    m_pCB = pCB;
    m_cbQueued = 0;
    m_lpbQueued = m_lpbQueueCur = NULL;
    m_pStream = NULL;
    m_pRecvHead = m_pRecvTail = NULL;
    m_iRecvOffset = 0;
    m_fNeedRecvNotify = FALSE;
    m_hwnd = NULL;
    m_fNegotiateSecure = FALSE;
    m_fSecure = FALSE;
    ZeroMemory(&m_hContext, sizeof(m_hContext));
    m_iCurSecPkg = 0; // current security package being tried
    m_pbExtra = NULL;
    m_cbExtra = 0;
    m_cbSent = 0;
    m_pPrompt = pPrompt;
    m_dwLastActivity = 0;
    m_dwTimeout = 0;
    m_uiTimer = 0;
#ifdef DEBUG
    m_cLock = 0;
#endif
    m_fPaused = FALSE;
    m_dwEventMask = 0;
}

CAsyncConn::~CAsyncConn()
{
    DOUT("CAsyncConn::~CAsyncConn %lx: m_cRef = %d", this, m_cRef);

    // Bug #22622 - We need to make sure there isn't a timer pending
    StopWatchDog();

    Assert(!m_fLookup);
    SafeMemFree(m_pszServer);
    SafeRelease(m_pLogFile);
    CleanUp();
    if ((NULL != m_hwnd) && (FALSE != IsWindow(m_hwnd)))
        SendMessage(m_hwnd, WM_CLOSE, 0, 0);
    DeleteCriticalSection(&m_cs);
#ifdef DEBUG
    IxpAssert(m_cLock == 0);
#endif
}

ULONG CAsyncConn::AddRef(void)
{
    ULONG cRefNew;

    EnterCS(&m_cs);
    DOUT("CAsyncConn::AddRef %lx ==> %d", this, m_cRef+1);
    cRefNew = ++m_cRef;
    LeaveCS(&m_cs);

    return cRefNew;
}

ULONG CAsyncConn::Release(void)
{
    ULONG cRefNew;

    EnterCS(&m_cs);
    DOUT("CAsyncConn::Release %lx ==> %d", this, m_cRef-1);
    cRefNew = --m_cRef;
    LeaveCS(&m_cs);

    if (cRefNew == 0)
        delete this;
    return cRefNew;
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::HrInit
//
//   Allocates recv buffer, sets servername, servicename, and port
//
HRESULT CAsyncConn::HrInit(char *szServer, int iDefaultPort, BOOL fSecure, DWORD dwTimeout)
{
    HRESULT hr = NOERROR;

    EnterCS(&m_cs);

    if (!m_hwnd && !CreateWnd())
        {
        hr = E_FAIL;
        goto error;
        }

    if (m_state != AS_DISCONNECTED)
        {
        hr = IXP_E_ALREADY_CONNECTED;
        goto error;
        }

    Assert(szServer);

    // if nothing has changed, then use the current settings
    if (m_pszServer && 
        !lstrcmpi(m_pszServer, szServer) && 
        (iDefaultPort == m_iDefaultPort) && 
        (fSecure == m_fNegotiateSecure))
        goto error;

    m_fCachedAddr = FALSE;
    m_fRedoLookup = FALSE;
    SafeMemFree(m_pszServer);
    DWORD cchSize = (lstrlen(szServer)+1);

    if (!MemAlloc((LPVOID*)&m_pszServer, cchSize * sizeof(m_pszServer[0])))
        {
        hr = E_OUTOFMEMORY;
        goto error;
        }
    StrCpyN(m_pszServer, szServer, cchSize);

    Assert(iDefaultPort > 0);
    m_iDefaultPort = (u_short) iDefaultPort;
    m_fNegotiateSecure = fSecure;

    // If dwTimeout == 0, no timeout detection will be installed.
    m_dwTimeout = dwTimeout;

error:
    LeaveCS(&m_cs);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::SetWindow
//
//  creates a window used by async. winsock. ResetWindow()
//	must be called before invoking this function, so as to avoid
//  window handle leakage.
//
HRESULT CAsyncConn::SetWindow(void)
{
    HRESULT hr = NOERROR;

    EnterCS(&m_cs);

    if (NULL != m_hwnd && IsWindow(m_hwnd) && 
            GetWindowThreadProcessId(m_hwnd, NULL) == GetCurrentThreadId())
        {
            // no need to create the new window for this thread
            goto error;
        }
    else if (NULL != m_hwnd && IsWindow(m_hwnd))
        {
            // leaks one window handle; the previous worker thread 
            // didn't call ResetWindow().
            Assert(FALSE);
        }

    if (!CreateWnd())
        {
           hr = E_FAIL;
           goto error;
        }

    if (m_sock != INVALID_SOCKET)
        {
        if (SOCKET_ERROR == WSAAsyncSelect(m_sock, m_hwnd, SPM_WSA_SELECT, FD_READ|FD_WRITE|FD_CLOSE))
            {
            m_iLastError = WSAGetLastError();
            hr = IXP_E_CONN;
            goto error;
            }
        }

error:
    LeaveCS(&m_cs);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::ResetWindow
//
//   closes the window used by async. winsock
//
HRESULT CAsyncConn::ResetWindow(void)
{
    HRESULT hr = NOERROR;

    EnterCS(&m_cs);

    if ((NULL == m_hwnd) || (FALSE == IsWindow(m_hwnd)))
        goto error;

    if (GetWindowThreadProcessId(m_hwnd, NULL) == GetCurrentThreadId())
        {
        SendMessage(m_hwnd, WM_CLOSE, 0, 0);
        m_hwnd = NULL;
        }
    else
        {
        // A caller forgot to call ResetWindow. Only the owner thread can destroy
        // the window.
        Assert(FALSE);
        }

error:
    LeaveCS(&m_cs);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::Connect
//
//   starts the name lookup and connection process
//
HRESULT CAsyncConn::Connect()
{
    HRESULT hr;
    HANDLE  hThreadLookup;
    BOOL    fNotify = FALSE;
    BOOL    fAsync = FALSE;

    EnterCS(&m_cs);

    if (m_state != AS_DISCONNECTED && m_state != AS_RECONNECTING)
        {
        hr = IXP_E_ALREADY_CONNECTED;
        goto error;
        }

    Assert(m_pszServer);

    if (FLOGSESSION) 
        {
        char szBuffer[512], lb[256];
        if (LoadString(g_hLocRes, idsNlogIConnect, lb, 256)) 
            {
            wnsprintf(szBuffer, ARRAYSIZE(szBuffer), lb, m_pszServer, m_iDefaultPort);
            m_pLogFile->DebugLog(szBuffer);
            }
        }

    ZeroMemory(&m_sa, sizeof(m_sa));
    m_sa.sin_port = htons(m_iDefaultPort);
    m_sa.sin_family = AF_INET;
    m_sa.sin_addr.s_addr = inet_addr(m_pszServer);

    if (m_sa.sin_addr.s_addr != -1)
        // server name is dotted decimal, so no need to look it up
        fAsync = TRUE;
    else
        {
        // Start a name lookup on a separate thread because WinSock caches the DNS server in TLS.
        // The separate thread enables us to connect to a LAN DNS and a RAS DNS in the same session.

        hr = LookupHostName(m_pszServer, m_hwnd, &(m_sa.sin_addr.s_addr), &m_fCachedAddr, m_fRedoLookup);
        if (SUCCEEDED(hr))
            {
            m_fLookup = fNotify = !m_fCachedAddr;
            fAsync = m_fCachedAddr;
            }
        else
            {
            m_iLastError = WSAENOBUFS;
            hr = IXP_E_CONN;
            }
        }

error:
    LeaveCS(&m_cs);
    if (fAsync)
        hr = AsyncConnect();
    if (fNotify)
        ChangeState(AS_LOOKUPINPROG, AE_NONE);
    return hr;
}

void CAsyncConn::StartWatchDog(void)
{
    if (m_dwTimeout < 5) m_dwTimeout =  30;
    m_dwLastActivity = GetTickCount();
    Assert(m_hwnd);
    StopWatchDog();
    m_uiTimer = SetTimer(m_hwnd, SPM_ASYNCTIMER, 5000, NULL);
}

void CAsyncConn::StopWatchDog(void)
{
    if (m_uiTimer)
    {
        KillTimer(m_hwnd, SPM_ASYNCTIMER);
        m_uiTimer = 0;
    }
}

void CAsyncConn::OnWatchDogTimer(void)
{
    BOOL        fNotify = FALSE;
    ASYNCSTATE  as;

    EnterCS(&m_cs);
    if (((GetTickCount() - m_dwLastActivity) / 1000) >= m_dwTimeout)
        {
        fNotify = TRUE;
        as = m_state;
        }
    LeaveCS(&m_cs);

    if (fNotify)
        ChangeState(as, AE_TIMEOUT);        
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::Close
//
//   closes the connection
//
HRESULT CAsyncConn::Close()
{
    BOOL fNotify = FALSE;
    BOOL fClose = FALSE;

    EnterCS(&m_cs);
    if (m_fLookup)
        {
        CancelLookup(m_pszServer, m_hwnd);
        m_fLookup = FALSE;
        fNotify = TRUE;
        }
    fClose = (m_sock != INVALID_SOCKET);
    LeaveCS(&m_cs);

    if (fNotify)
        ChangeState(AS_DISCONNECTED, AE_LOOKUPDONE);

    if (fClose)
        OnClose(AS_DISCONNECTED);

    return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::ReadLine
//
// Purpose: retrieves a single complete line from the buffered data
//
// Args:    ppszBuf - pointer to receive allocated buffer, caller must free
//          pcbRead - pointer to receive line length
//
// Returns: NOERROR - a complete line was read
//          IXP_E_INCOMPLETE - a complete line is not available
//          E_OUTOFMEMORY - mem error
//
// Comments:
//  If IXP_E_INCOMPLETE is returned, the caller will recieve an AE_RECV event
//  the next time a complete line is available.
//
HRESULT CAsyncConn::ReadLine(char **ppszBuf, int *pcbRead)
{
    HRESULT     hr;
    int         iLines;

    EnterCS(&m_cs);

    hr = IReadLines(ppszBuf, pcbRead, &iLines, TRUE);

    LeaveCS(&m_cs);
    return hr;    
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::ReadLines
//
// Purpose: retrieves all available complete lines from the buffered data
//
// Args:    ppszBuf - pointer to receive allocated buffer, caller must free
//          pcbRead - pointer to receive line length
//          pcLines - pointer to receive number or lines read
//
// Returns: NOERROR - a complete line was read
//          IXP_E_INCOMPLETE - a complete line is not available
//          E_OUTOFMEMORY - mem error
//
// Comments:
//  If IXP_E_INCOMPLETE is returned or if there is extra data buffered after the
//  the last complete line, the caller will recieve an AE_RECV event
//  the next time a complete line is available.
//
HRESULT CAsyncConn::ReadLines(char **ppszBuf, int *pcbRead, int *pcLines)
{
    HRESULT     hr;

    EnterCS(&m_cs);

    hr = IReadLines(ppszBuf, pcbRead, pcLines, FALSE);

    LeaveCS(&m_cs);
    return hr;    
}



/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::ReadBytes
//
// Purpose:
//   This function returns up to the number of bytes requested, from the
// current head buffer.
//
// Arguments:
//   char **ppszBuf [out] - this function returns a pointer to an allocated
//     buffer, if successful. It is the caller's responsibility to MemFree
//     this buffer.
//   int cbBytesWanted [in] - the number of bytes requested by the caller.
//      The requested number of bytes may be returned, or less.
//   int *pcbRead [out] - the number of bytes returned in ppszBuf.
//
// Returns: NOERROR - success. Either the remainder of the current buffer
//                    was returned, or the number of bytes asked for.
//          IXP_E_INCOMPLETE - a complete line is not available
//          E_OUTOFMEMORY - mem error
//          E_INVALIDARG - NULL arguments
//
// Comments:
//  If the caller wishes to receive an AE_RECV event the next time data has
// been received from the server, he must either call ReadLines (once), or
// he must continue to call ReadBytes or ReadLine until IXP_E_INCOMPLETE is
// returned.
//
HRESULT CAsyncConn::ReadBytes(char **ppszBuf, int cbBytesWanted, int *pcbRead)
{
    int iNumBytesToReturn, i;
    char *pResult, *p;
    HRESULT hrResult;
    BOOL bResult;

    // Check arguments
    if (NULL == ppszBuf || NULL == pcbRead) {
        AssertSz(FALSE, "Check your arguments, buddy");
        return E_INVALIDARG;
    }

    // Initialize variables
    *ppszBuf = NULL;
    *pcbRead = 0;
    hrResult = NOERROR;

    EnterCS(&m_cs);

    if (NULL == m_pRecvHead) {
        hrResult = IXP_E_INCOMPLETE;
        goto exit;
    }

    // Get a buffer to return the results in and fill it in
    iNumBytesToReturn = min(m_pRecvHead->cbLen - m_iRecvOffset, cbBytesWanted);
    bResult = MemAlloc((void **)&pResult, iNumBytesToReturn + 1); // Leave room for null-term
    if (FALSE == bResult) {
        hrResult = E_OUTOFMEMORY;
        goto exit;
    }
    CopyMemory(pResult, m_pRecvHead->szBuf + m_iRecvOffset, iNumBytesToReturn);
    *(pResult + iNumBytesToReturn) = '\0'; // Null-terminate the buffer
    // The null-term should never be read, but doing so allows us to return a
    // buffer for when 0 bytes are requested, instead of returning a NULL pointer.

    // Advance our position in the current buffer
    m_iRecvOffset += iNumBytesToReturn;
    if (m_iRecvOffset >= m_pRecvHead->cbLen) {
        PRECVBUFQ pTemp;

        Assert(m_iRecvOffset == m_pRecvHead->cbLen);

        // This buffer's done, advance to the next buffer in the chain
        pTemp = m_pRecvHead;
        m_pRecvHead = m_pRecvHead->pNext;
        if (NULL == m_pRecvHead)
            m_pRecvTail = NULL;
        m_iRecvOffset = 0;
        MemFree(pTemp);
    }

    // Search and destroy nulls: apparently some servers can send these,
    // and most parsing code can't handle it
    for (i = 0, p = pResult; i < iNumBytesToReturn; i++, p++)
        if (*p == '\0')
            *p = ' ';

exit:
    // This is the only time we reset the AE_RECV trigger
    if (IXP_E_INCOMPLETE == hrResult)
        m_fNeedRecvNotify = TRUE;

    LeaveCS(&m_cs);

    if (NOERROR == hrResult) {
        *ppszBuf = pResult;
        *pcbRead = iNumBytesToReturn;
    }
    return hrResult;
} // ReadBytes



/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::UlGetSendByteCount
//
ULONG CAsyncConn::UlGetSendByteCount(VOID)
{
    return m_cbSent;
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::HrStuffDots
//
//   Makes sure that leading dots are stuffed
//
#define CB_STUFF_GROW 256
HRESULT CAsyncConn::HrStuffDots(CHAR *pchPrev, LPSTR pszIn, INT cbIn, LPSTR *ppszOut,
    INT *pcbOut)
    {
    // Locals
    HRESULT hr=S_OK;
    int     iIn=0;
    int     iOut=0;
    LPSTR   pszOut=NULL;
    int     cbOut=0;

    // Invalid Arg
    Assert(pchPrev);
    Assert(pszIn);
    Assert(cbIn);
    Assert(ppszOut);
    Assert(pcbOut);

    if (!pchPrev || !pszIn || !ppszOut || !pcbOut || (cbIn <= 0))
    {
        return E_INVALIDARG;
    }

    // Set cbOut
    cbOut = cbIn;

    // Allocate
    CHECKHR(hr = HrAlloc((LPVOID *)&pszOut, cbIn));

    // Setup Loop
    while (iIn < cbIn)
        {
        // Need a realloc
        if (iOut + 3 > cbOut)
            {
            // Allocate a buffer
            CHECKHR(hr = HrRealloc((LPVOID *)&pszOut, cbOut + CB_STUFF_GROW));

            // Set cbAlloc
            cbOut += CB_STUFF_GROW;
            }

        // Dot at the start of a line...
        if ('.' == pszIn[iIn] && ('\0' == *pchPrev || '\r' == *pchPrev || '\n' == *pchPrev))
            {
            // Write this dot across
            pszOut[iOut++] = pszIn[iIn++];

            // Stuff the dot
            pszOut[iOut++] = '.';

            // Set pchPrev
            *pchPrev = '.';
            }
        else
            {
            // Remember Previous Character
            *pchPrev = pszIn[iIn];

            // Write
            pszOut[iOut++] = pszIn[iIn++];
            }
        }

    // Set Source
    *ppszOut = pszOut;
    *pcbOut = iOut;

exit:
    return(hr);
    }

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::SendBytes
//
//   sends data to the socket
//
HRESULT CAsyncConn::SendBytes(const char *pszIn, int cbIn, int *pcbSent, 
    BOOL fStuffDots /* FALSE */, CHAR *pchPrev /* NULL */)
{
    HRESULT hr = S_OK;
    int     iSent=0;
    int     iSentTotal=0;
    LPSTR   pszBuf=NULL;
    LPSTR   pszFree=NULL;
    LPSTR   pszFree2=NULL;
    LPSTR   pszSource=(LPSTR)pszIn;
    LPSTR   pszStuffed=NULL;
    int     cbStuffed;
    int     cbBuf;
    int     cbSource=cbIn;

    EnterCS(&m_cs);
    
    Assert(pszSource && cbSource);
#ifdef DEBUG
    if (m_cbQueued)
    {
        DebugBreak();
    }
#endif
//    Assert(!m_cbQueued);
    Assert(!m_lpbQueued);
    Assert(!m_lpbQueueCur);

    if (m_state < AS_CONNECTED)
        {
        hr = IXP_E_NOT_CONNECTED;
        goto error;
        }

    if (fStuffDots)
        {
        if (FAILED(HrStuffDots(pchPrev, pszSource, cbSource, &pszStuffed, &cbStuffed)))
            {
            hr = E_FAIL;
            goto error;
            }

        pszSource = pszStuffed;
        cbSource = cbStuffed;
        }

    if (m_fSecure)
        {
        SECURITY_STATUS scRet;
        scRet = EncryptData(&m_hContext, (LPVOID)pszSource, cbSource, (LPVOID*)&pszBuf, &cbBuf);
        if (scRet != ERROR_SUCCESS)
            {
            hr = E_FAIL;
            goto error;
            }
        pszFree = pszBuf;
        }
    else
        {
        pszBuf = (LPSTR)pszSource;
        cbBuf = cbSource;
        }

    while (cbBuf && pszBuf && ((iSent = send(m_sock, pszBuf, cbBuf, 0)) != SOCKET_ERROR))
        {
        iSentTotal += iSent;
        pszBuf += iSent;
        cbBuf -= iSent;
        }

    if (cbBuf)
        {
        m_iLastError = WSAGetLastError();
        hr = IXP_E_CONN_SEND;
        if (WSAEWOULDBLOCK == m_iLastError)
            {
            if (MemAlloc((LPVOID*)&m_lpbQueued, cbBuf))
                {
                m_cbQueued = cbBuf;
                m_lpbQueueCur = m_lpbQueued;
                CopyMemory(m_lpbQueued, pszBuf, cbBuf);
                hr = IXP_E_WOULD_BLOCK;
                }
            else
                hr = E_OUTOFMEMORY;
            }
        }
    else
        hr = NOERROR;

error:
    *pcbSent = iSentTotal;
    LeaveCS(&m_cs);
    if (pszFree)
        g_pMalloc->Free(pszFree);
    if (pszStuffed)
        g_pMalloc->Free(pszStuffed);
    return hr;        
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::SendStream
//
//   sends data to the socket
//
HRESULT CAsyncConn::SendStream(LPSTREAM pStream, int *pcbSent, BOOL fStuffDots /* FALSE */)
{
    HRESULT hr;
    char    rgb[STREAM_BUFSIZE];  //$REVIEW - should we heap allocate this instead?
    DWORD   cbRead;
    int     iSent, iSentTotal = 0;

    EnterCS(&m_cs);

    Assert(pStream && pcbSent);
    Assert(!m_cbQueued);
    Assert(!m_lpbQueued);
    Assert(!m_lpbQueueCur);
    Assert(!m_pStream);

    if (m_state < AS_CONNECTED)
        {
        hr = IXP_E_NOT_CONNECTED;
        goto error;
        }

    HrRewindStream(pStream);

    m_chPrev = '\0';
    m_fStuffDots = fStuffDots;

    while (SUCCEEDED(hr = pStream->Read(rgb, STREAM_BUFSIZE, &cbRead)) && cbRead) 
        {
        hr = SendBytes(rgb, cbRead, &iSent, m_fStuffDots, &m_chPrev);
        iSentTotal += iSent;
        if (FAILED(hr))
            {
            if (WSAEWOULDBLOCK == m_iLastError)
                {
                // hang onto the stream
                m_pStream = pStream;
                m_pStream->AddRef();
                }
            break;
            }
        }

error:
    *pcbSent = iSentTotal;
    LeaveCS(&m_cs);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::OnNotify
//
//   called for network events that we have registered interest in
//
void CAsyncConn::OnNotify(UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD       dwLookupThreadId;
    SOCKET      sock;
    ASYNCSTATE  state;

    EnterCS(&m_cs);
    sock = m_sock;
    state = m_state;
    LeaveCS(&m_cs);

    switch (msg)
        {
        case SPM_WSA_GETHOSTBYNAME:
            EnterCS(&m_cs);
            m_sa.sin_addr.s_addr = (ULONG)lParam;
            m_iLastError = (int)wParam;
            if (FLOGSESSION)
                {
                char szBuffer[512];
                if (m_iLastError)
                    {
                    char lb[256];
                    if (LoadString(g_hLocRes, idsErrConnLookup, lb, 256)) 
                        {
                        wnsprintf(szBuffer, ARRAYSIZE(szBuffer), lb, m_iLastError);
                        m_pLogFile->DebugLog(szBuffer);
                        }
                    }
                else
                    {
                    wnsprintf(szBuffer, ARRAYSIZE(szBuffer), 
                             "srv_name = \"%.200s\" srv_addr = %.200s\r\n", 
                             m_pszServer,
                             inet_ntoa(m_sa.sin_addr)); 
                    m_pLogFile->DebugLog(szBuffer);
                    }
                }
            LeaveCS(&m_cs);
            OnLookupDone((int)wParam);
            break;

        case SPM_WSA_SELECT:
            if (wParam == (WPARAM)sock)
                {
                EnterCS(&m_cs);
                m_iLastError = WSAGETSELECTERROR(lParam);
                if (m_iLastError && FLOGSESSION)
                    {
                    char szBuffer[256], lb[256];
                    if (LoadString(g_hLocRes, idsErrConnSelect, lb, 256)) 
                        {
                        wnsprintf(szBuffer, ARRAYSIZE(szBuffer), lb, WSAGETSELECTEVENT(lParam), m_iLastError);
                        m_pLogFile->DebugLog(szBuffer);
                        }
                    }
                if (m_fPaused)
                    {
                    m_dwEventMask |= WSAGETSELECTEVENT(lParam);
                    LeaveCS(&m_cs);
                    break;
                    }
                LeaveCS(&m_cs);
                switch (WSAGETSELECTEVENT(lParam))
                    {
                    case FD_CONNECT:
                        OnConnect();
                        break;
                    case FD_CLOSE:
                        if (AS_HANDSHAKING == state)
                            OnSSLError();
                        else
                            OnClose(AS_DISCONNECTED);
                        break;
                    case FD_READ:
                        OnRead();
                        break;
                    case FD_WRITE:
                        OnWrite();
                        break;
                    }
                }
            else
                DOUTL(2, 
                      "Got notify for old socket = %x, evt = %x, err = %x", 
                      wParam, 
                      WSAGETSELECTEVENT(lParam), 
                      WSAGETSELECTERROR(lParam));
            break;
        }
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::GetConnectStatusString
//
//   returns the string ID for the status
//
int CAsyncConn::GetConnectStatusString() 
{ 
    return idsNotConnected + (m_state - AS_DISCONNECTED); 
}

/////////////////////////////////////////////////////////////////////////////
// 
// PRIVATE METHODS
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::AsyncConnect
//
//   starts the connection process
//
HRESULT CAsyncConn::AsyncConnect()
{
    HRESULT hr = NOERROR;
    BOOL    fConnect = FALSE;

    EnterCS(&m_cs);
    if (!(AS_DISCONNECTED == m_state || AS_RECONNECTING == m_state || AS_LOOKUPDONE == m_state))
        {
        hr = IXP_E_INVALID_STATE;
        goto exitCS;
        }
    Assert(m_sa.sin_addr.s_addr != -1);

    if (m_sock == INVALID_SOCKET) 
        {
        if ((m_sock = socket(PF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET) 
            {
            m_iLastError = WSAGetLastError();
            hr = IXP_E_CONN;
            goto exitCS;
            }
        }

    if (SOCKET_ERROR == WSAAsyncSelect(m_sock, m_hwnd, SPM_WSA_SELECT, FD_CONNECT))
        {
        m_iLastError = WSAGetLastError();
        hr = IXP_E_CONN;
        goto exitCS;
        }
    LeaveCS(&m_cs);

    ChangeState(AS_CONNECTING, AE_NONE);

    EnterCS(&m_cs);
    if (connect(m_sock, (struct sockaddr *)&m_sa, sizeof(m_sa)) == SOCKET_ERROR)
        {
        m_iLastError = WSAGetLastError();
        if (WSAEWOULDBLOCK == m_iLastError)
            {
            // this is the expected result
            m_iLastError = 0;
            }
        else
            {
            if (FLOGSESSION)
                {
                char szBuffer[256], lb[256];
                if (LoadString(g_hLocRes, idsNlogErrConnError, lb, 256)) 
                    {
                    wnsprintf(szBuffer, ARRAYSIZE(szBuffer), lb, m_iLastError);
                    m_pLogFile->DebugLog(szBuffer);
                    }
                }
            }
        }
    else
        {
        Assert(m_iLastError == 0);
        fConnect = TRUE;
        }
    LeaveCS(&m_cs);

    if (m_iLastError)
        {
        ChangeState(AS_DISCONNECTED, AE_NONE);
        return IXP_E_CONN;
        }
    else if (fConnect)
        OnConnect();

    return NOERROR;

exitCS:
    LeaveCS(&m_cs);
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::OnLookupDone
//
//   called once an async database lookup finishes
//
HRESULT CAsyncConn::OnLookupDone(int iLastError)
{
    ASYNCSTATE as;

    EnterCS(&m_cs);
    Assert(AS_LOOKUPINPROG == m_state);
    m_fLookup = FALSE;
    LeaveCS(&m_cs);

    if (iLastError)
        ChangeState(AS_DISCONNECTED, AE_LOOKUPDONE);
    else
        {
        ChangeState(AS_LOOKUPDONE, AE_LOOKUPDONE);
        AsyncConnect();
        }

    return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::OnConnect
//
//   called once a connection is established
//
HRESULT CAsyncConn::OnConnect()
{
    BOOL fConnect = FALSE;

    EnterCS(&m_cs);

    Assert(AS_CONNECTING == m_state);

    if (!m_iLastError)
        {
        BOOL fTrySecure = m_fNegotiateSecure && FIsSecurityEnabled();
        if (SOCKET_ERROR == WSAAsyncSelect(m_sock, m_hwnd, SPM_WSA_SELECT, FD_READ|FD_WRITE|FD_CLOSE))
            {
            m_iLastError = WSAGetLastError();
            LeaveCS(&m_cs);
            return IXP_E_CONN;
            }
        LeaveCS(&m_cs);
        if (fTrySecure)
            TryNextSecurityPkg();
        else
            ChangeState(AS_CONNECTED, AE_CONNECTDONE);
        }
    else
        {
        LeaveCS(&m_cs);
        ChangeState(AS_DISCONNECTED, AE_CONNECTDONE);
        EnterCS(&m_cs);
        if (m_fCachedAddr && !m_fRedoLookup)
            {
            // maybe our cached address went bad - try one more time
            m_fRedoLookup = TRUE;
            fConnect = TRUE;
            }
        LeaveCS(&m_cs);
        if (fConnect)
            Connect();
        return IXP_E_CONN;
        }
    return NOERROR;                
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::OnClose
//
//   called when a connection is dropped
//
HRESULT CAsyncConn::OnClose(ASYNCSTATE asNew)
{
    MSG msg;

    EnterCS(&m_cs);
    // unregister and clean up the socket    
    Assert(m_sock != INVALID_SOCKET);
    closesocket(m_sock);
    m_sock = INVALID_SOCKET;
    if (FLOGSESSION && m_pszServer) 
        {
        char szBuffer[256], lb[256];
        if (LoadString(g_hLocRes, idsNlogErrConnClosed, lb, 256)) 
            {
            wnsprintf(szBuffer, ARRAYSIZE(szBuffer), lb, m_iLastError);
            m_pLogFile->DebugLog(szBuffer);
            }
        }

    while (PeekMessage(&msg, m_hwnd, SPM_WSA_SELECT, SPM_WSA_GETHOSTBYNAME, PM_REMOVE))
        {
        DOUTL(2, "Flushing pending socket messages...");
        }
    LeaveCS(&m_cs);
    
    ChangeState(asNew, AE_CLOSE);
    EnterCS(&m_cs);
    CleanUp();
    LeaveCS(&m_cs);
    return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::OnRead
//
//   called when an FD_READ notification is received
//
HRESULT CAsyncConn::OnRead()
{
    HRESULT hr;
    int     iRecv;
    char    szRecv[STREAM_BUFSIZE];

    EnterCS(&m_cs);
    if (m_state < AS_CONNECTED)
        {
        Assert(FALSE);
        LeaveCS(&m_cs);
        return IXP_E_NOT_CONNECTED;
        }

    iRecv = recv(m_sock, szRecv, sizeof(szRecv), 0);
    m_iLastError = WSAGetLastError();
    LeaveCS(&m_cs);

    if (SOCKET_ERROR == iRecv)
        {
        hr = IXP_E_CONN_RECV;
        }
    else if (iRecv == 0)
        {
        // this means the server has disconnected us.
        //$TODO - not sure what we should do here
        hr = IXP_E_NOT_CONNECTED;
        }
    else
        {
        hr = OnDataAvail(szRecv, iRecv, FALSE);
        }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::OnDataAvail
//
//   called when there is incoming data to be queued
//
HRESULT CAsyncConn::OnDataAvail(LPSTR pszRecv, int iRecv, BOOL fIncomplete)
{
    HRESULT     hr = NOERROR;
    BOOL        fNotify = FALSE, fHandshake = FALSE, fClose = FALSE;
    PRECVBUFQ   pNew;
    int         iQueue = 0;
    LPSTR       pszFree = NULL;
    ASYNCSTATE  as;

    EnterCS(&m_cs);

    if (m_state < AS_CONNECTED)
        {
        Assert(FALSE);
        hr = IXP_E_NOT_CONNECTED;
        goto error;
        }

    if (m_fSecure)
        {
        SECURITY_STATUS scRet;
        int             cbEaten = 0;

        if (m_cbExtra)
            {
            Assert(m_pbExtra);
            // there's data left over from the last call to DecryptData
            if (MemAlloc((LPVOID*)&pszFree, m_cbExtra + iRecv))
                {
                // combine the extra and new buffers
                CopyMemory(pszFree, m_pbExtra, m_cbExtra);
                CopyMemory(pszFree + m_cbExtra, pszRecv, iRecv);
                pszRecv = pszFree;
                iRecv += m_cbExtra;
                MemFree(m_pbExtra);
                m_pbExtra = NULL;
                m_cbExtra = 0;
                }
            else
                {
                hr = E_OUTOFMEMORY;
                goto error;
                }
            }
        scRet = DecryptData(&m_hContext, pszRecv, iRecv, &iQueue, &cbEaten);
        if (scRet == ERROR_SUCCESS || scRet == SEC_E_INCOMPLETE_MESSAGE)
            {
            if (cbEaten != iRecv)
                {
                // we need to save away the extra bytes until we receive more data
                Assert(cbEaten < iRecv);
                DOUTL(2, "cbEaten = %d, iRecv = %d, cbExtra = %d", cbEaten, iRecv, iRecv - cbEaten);
                if (MemAlloc((LPVOID*)&m_pbExtra, iRecv - cbEaten))
                    {
                    m_cbExtra = iRecv - cbEaten;
                    CopyMemory(m_pbExtra, pszRecv + cbEaten, m_cbExtra);
                    }
                else
                    {
                    hr = E_OUTOFMEMORY;
                    goto error;
                    }
                }
            if (scRet == SEC_E_INCOMPLETE_MESSAGE)
                goto error;
            }
        else
            {
            // security error, so disconnect.
            fClose = TRUE;
            hr = E_FAIL;
            goto error;
            }
        }
    else
        iQueue = iRecv;

    if (MemAlloc((LPVOID*)&pNew, sizeof(RECVBUFQ) + iQueue - sizeof(char)))
        {
        pNew->pNext = NULL;
        pNew->cbLen = iQueue;
        CopyMemory(pNew->szBuf, pszRecv, iQueue);
        if (m_pRecvTail)
            {
            m_pRecvTail->pNext = pNew;
            if ((AS_CONNECTED == m_state) && m_fNeedRecvNotify)
                fNotify = FEndLine(pszRecv, iQueue);
            }
        else
            {
            Assert(!m_pRecvHead);
            m_pRecvHead = pNew;
            if (AS_CONNECTED == m_state)
                {
                fNotify = FEndLine(pszRecv, iQueue);
                if (!fNotify)
                    m_fNeedRecvNotify = TRUE;
                }
            }
        m_pRecvTail = pNew;
        hr = NOERROR;
        }
    else
        {
        //$TODO - we should disconnect here and notify the caller
        hr = E_OUTOFMEMORY;
        }

    // notify the owner that there is at least one line of data available
    if (fNotify)
        {
        m_fNeedRecvNotify = FALSE;
        as = m_state;
        }
    else if (AS_HANDSHAKING == m_state && SUCCEEDED(hr) && !fIncomplete)
        {
        Assert(!m_fSecure);
        fHandshake = TRUE;
        }

    LeaveCS(&m_cs);

    if (fNotify)
        ChangeState(as, AE_RECV);
    else if (fHandshake)
        OnRecvHandshakeData();

    EnterCS(&m_cs);

error:
    LeaveCS(&m_cs);
    SafeMemFree(pszFree);
    if (fClose)
        Close();
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::OnWrite
//
//   called when an FD_WRITE notification is received
//
HRESULT CAsyncConn::OnWrite()
{
    int         iSent;
    ASYNCEVENT  ae;
    ASYNCSTATE  as;

    EnterCS(&m_cs);

    m_cbSent = 0;

    if (m_state < AS_CONNECTED)
        {
        Assert(FALSE);
        LeaveCS(&m_cs);
        return IXP_E_NOT_CONNECTED;
        }

    if (m_cbQueued)
        {
        // send some more data from the queued buffer    
        while (m_cbQueued && ((iSent = send(m_sock, m_lpbQueueCur, m_cbQueued, 0)) != SOCKET_ERROR))
            {
            m_cbSent += iSent;
            m_lpbQueueCur += iSent;
            m_cbQueued -= iSent;
            }
        if (m_cbQueued)
            {
            m_iLastError = WSAGetLastError();
            if (WSAEWOULDBLOCK != m_iLastError)
                {
                //$TODO - handle this error somehow
                Assert(FALSE);
                }
            }
        else
            {
            MemFree(m_lpbQueued);
            m_lpbQueued = m_lpbQueueCur = NULL;
            }
        }

    if (m_pStream && !m_cbQueued)
        {
        char    rgb[STREAM_BUFSIZE];  //$REVIEW - should we heap allocate this instead?
        DWORD   cbRead;
        HRESULT hr;

        // send some more data from the queued stream
        while (SUCCEEDED(hr = m_pStream->Read(rgb, STREAM_BUFSIZE, &cbRead)) && cbRead) 
            {
            hr = SendBytes(rgb, cbRead, &iSent, m_fStuffDots, &m_chPrev);
            if (FAILED(hr))
                {
                if (WSAEWOULDBLOCK != m_iLastError)
                    {
                    //$TODO - handle this error somehow, probably free the stream
                    Assert(FALSE);
                    }
                break;
                }
            else
                m_cbSent += iSent;
            }
        if (!cbRead)
            {
            m_pStream->Release();
            m_pStream = NULL;
            }
        }
    
    as = m_state;
    if (!m_cbQueued)
        ae = AE_SENDDONE;
    else
        ae = AE_WRITE;

    LeaveCS(&m_cs);

    ChangeState(as, ae);
    return NOERROR;
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::ChangeState
//
//   changes the connection state, notifies the owner
//
void CAsyncConn::ChangeState(ASYNCSTATE asNew, ASYNCEVENT ae)
{
    ASYNCSTATE      asOld;
    IAsyncConnCB   *pCB;

    EnterCS(&m_cs);
    asOld = m_state;
    m_state = asNew;
    m_dwLastActivity = GetTickCount();
    pCB = m_pCB;
    // pCB->AddRef(); $BUGBUG - we REALLY need to handle this, but IMAP4 doesn't call close before it's destructor
#ifdef DEBUG
    IxpAssert(m_cLock == 1);
#endif
    LeaveCS(&m_cs);

    pCB->OnNotify(asOld, asNew, ae);
    // pCB->Release();
}

/////////////////////////////////////////////////////////////////////////////
// 
// CAsyncConn::IReadLines
//
// Purpose: retrieves one or all available complete lines from the buffer
//
// Args:    ppszBuf - pointer to receive allocated buffer, caller must free
//          pcbRead - pointer to receive line length
//          pcLines - pointer to receive number or lines read
//          fOne    - TRUE if only reading one line
//
// Returns: NOERROR - a complete line was read
//          IXP_E_INCOMPLETE - a complete line is not available
//          E_OUTOFMEMORY - mem error
//
// Comments:
//  If IXP_E_INCOMPLETE is returned or if there is extra data buffered after the
//  the last complete line, the caller will recieve an AE_RECV event
//  the next time a complete line is available.
//
HRESULT CAsyncConn::IReadLines(char **ppszBuf, int *pcbRead, int *pcLines, BOOL fOne)
{
    HRESULT     hr;
    int         iRead = 0, iScan = 0, iLines = 0;
    char *      pszBuf = NULL;
    char *      psz;
    int         iOffset, iLeft;
    PRECVBUFQ   pRecv;
    BOOL        fFound = FALSE;

    if (!m_pRecvHead)
        {
        hr = IXP_E_INCOMPLETE;
        goto error;
        }

    pRecv = m_pRecvHead;
    iOffset = m_iRecvOffset;
    while (pRecv)
        {
        psz = pRecv->szBuf + iOffset;
        iLeft = pRecv->cbLen - iOffset;
        while (iLeft--)
            {
            iScan++;
            if (*psz++ == '\n')
                {
                iRead = iScan;
                iLines++;
                if (fOne)
                    {
#if 0
                    // One-eyed t-crash fix
                    while (iLeft > 0 && (*psz == '\r' || *psz == '\n'))
                        {
                        iLeft--;
                        iScan++;
                        psz++;
                        iRead++;
                        }
#endif
                    break;
                    }
                }
            }
        if (iLines && fOne)
            break;
        iOffset = 0;
        pRecv = pRecv->pNext;
        }

    if (iLines)
        {
        int iCopy = 0, cb;
        if (!MemAlloc((LPVOID*)&pszBuf, iRead + 1))
            {
            hr = E_OUTOFMEMORY;
            goto error;
            }
        while (iCopy < iRead)
            {
            cb = min(iRead-iCopy, m_pRecvHead->cbLen - m_iRecvOffset);
            CopyMemory(pszBuf + iCopy, m_pRecvHead->szBuf + m_iRecvOffset, cb);
            iCopy += cb;
            if (cb == (m_pRecvHead->cbLen - m_iRecvOffset))
                {
                PRECVBUFQ pTemp = m_pRecvHead;
                m_pRecvHead = m_pRecvHead->pNext;
                if (!m_pRecvHead)
                    m_pRecvTail = NULL;
                m_iRecvOffset = 0;
                MemFree(pTemp);
                }
            else
                {
                Assert(iCopy == iRead);    
                m_iRecvOffset += cb;
                }
            }

        for (iScan = 0, psz = pszBuf; iScan < iCopy; iScan++, psz++)
            if (*psz == 0)
                *psz = ' ';

        pszBuf[iCopy] = 0;
        hr = NOERROR;
        }
    else
        hr = IXP_E_INCOMPLETE;

    // set the flag to notify when a complete line is received
    if ((IXP_E_INCOMPLETE == hr) || (m_pRecvHead && !fOne))
        m_fNeedRecvNotify = TRUE;

error:
    *ppszBuf = pszBuf;
    *pcbRead = iRead;
    *pcLines = iLines;
    return hr;    
}

HRESULT CAsyncConn::ReadAllBytes(char **ppszBuf, int *pcbRead)
{
    HRESULT     hr = S_OK;
    int         iRead = 0, iCopy = 0, cb;
    char *      pszBuf = NULL;
    int         iOffset;
    PRECVBUFQ   pTemp;

    if (!m_pRecvHead)
        {
        hr = IXP_E_INCOMPLETE;
        goto error;
        }

    // calculate how much to copy
    pTemp = m_pRecvHead;
    iOffset = m_iRecvOffset;
    while (pTemp)
        {
        iCopy += pTemp->cbLen - iOffset;
        iOffset = 0;
        pTemp = pTemp->pNext;
        }

    if (!MemAlloc((LPVOID*)&pszBuf, iCopy))
        {
        hr = E_OUTOFMEMORY;
        goto error;
        }

    while (m_pRecvHead)
        {
        cb = min(iCopy-iRead, m_pRecvHead->cbLen - m_iRecvOffset);
        CopyMemory(pszBuf + iRead, m_pRecvHead->szBuf + m_iRecvOffset, cb);
        iRead += cb;
        pTemp = m_pRecvHead;
        m_pRecvHead = m_pRecvHead->pNext;
        if (!m_pRecvHead)
            m_pRecvTail = NULL;
        m_iRecvOffset = 0;
        MemFree(pTemp);
        }

    Assert(!m_pRecvHead && !m_iRecvOffset);

error:
    *ppszBuf = pszBuf;
    *pcbRead = iRead;
    return hr;
}

HWND CAsyncConn::CreateWnd()
{    
    WNDCLASS wc;

    if (!GetClassInfo(g_hLocRes, s_szConnWndClass, &wc))
        {
        wc.style            = 0;
        wc.lpfnWndProc      = CAsyncConn::SockWndProc;
        wc.cbClsExtra       = 0;
        wc.cbWndExtra       = 0;
        wc.hInstance        = g_hLocRes;
        wc.hIcon            = NULL;
        wc.hCursor          = NULL;
        wc.hbrBackground    = NULL;
        wc.lpszMenuName     = NULL;
        wc.lpszClassName    = s_szConnWndClass;
        RegisterClass(&wc);
        }

    m_hwnd = CreateWindowEx(0,
                            s_szConnWndClass,
                            s_szConnWndClass,
                            WS_POPUP,
                            CW_USEDEFAULT,    
                            CW_USEDEFAULT,    
                            CW_USEDEFAULT,    
                            CW_USEDEFAULT,    
                            NULL,
                            NULL,
                            g_hLocRes,
                            (LPVOID)this);
    return m_hwnd;
}

LRESULT CALLBACK CAsyncConn::SockWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CAsyncConn *pThis = (CAsyncConn*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    
    switch (msg)
        {
        case WM_TIMER:
            Assert(pThis);
            if (SPM_ASYNCTIMER == wParam && pThis)
                pThis->OnWatchDogTimer();
        break;

        case WM_NCCREATE:
            pThis = (CAsyncConn*)((LPCREATESTRUCT)lParam)->lpCreateParams;
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pThis);            
            break;

        case WM_NCDESTROY:
            pThis->m_hwnd = NULL;
            break;

        case SPM_WSA_SELECT:
        case SPM_WSA_GETHOSTBYNAME:
            pThis->OnNotify(msg, wParam, lParam);
            return 0;
        }
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

HRESULT CAsyncConn::TryNextSecurityPkg()
{
    HRESULT         hr = NOERROR;
    SecBuffer       OutBuffer;
    SECURITY_STATUS sc;

    EnterCS(&m_cs);
    sc = InitiateSecConnection(m_pszServer,
                               FALSE,
                               &m_iCurSecPkg,
                               &m_hContext,
                               &OutBuffer);
    LeaveCS(&m_cs);

    if (SEC_I_CONTINUE_NEEDED == sc)
        {
        if (FLOGSESSION)
            {
            char szBuffer[256], lb[256];
            if (LoadString(g_hLocRes, idsNegotiatingSSL, lb, 256)) 
                {
                EnterCS(&m_cs);
                wnsprintf(szBuffer, ARRAYSIZE(szBuffer), lb, s_SecProviders[m_iCurSecPkg].pszName);
                m_pLogFile->DebugLog(szBuffer);
                LeaveCS(&m_cs);
                }
            }
        ChangeState(AS_HANDSHAKING, AE_CONNECTDONE);
        if (OutBuffer.cbBuffer && OutBuffer.pvBuffer)
            {
            int iSent;
            hr = SendBytes((char *)OutBuffer.pvBuffer, OutBuffer.cbBuffer, &iSent);
            g_FreeContextBuffer(OutBuffer.pvBuffer);
            }
        else
            {
            AssertSz(0, "Preventing a NULL, 0 sized call to send");
            }
        }
    else
        {
        // we can't connect securely, so error out and disconnect
        Close();
        }
    return hr;
}

HRESULT CAsyncConn::OnSSLError()
{
    HRESULT hr = NOERROR;
    BOOL    fReconnect;

    EnterCS(&m_cs);
    if (m_iCurSecPkg + 1 < g_cSSLProviders)
        {
        m_iCurSecPkg++;
        fReconnect = TRUE;
        }
    else
        {
        m_iCurSecPkg = 0;
        fReconnect = FALSE;
        }
    LeaveCS(&m_cs);

    if (fReconnect)
        {
        OnClose(AS_RECONNECTING);
        Connect();
        }
    else
        OnClose(AS_DISCONNECTED);

    return hr;
}

HRESULT CAsyncConn::OnRecvHandshakeData()
{
    HRESULT         hr;
    LPSTR           pszBuf;
    int             cbRead, cbEaten;
    SECURITY_STATUS sc;
    SecBuffer       OutBuffer;

    if (SUCCEEDED(hr = ReadAllBytes(&pszBuf, &cbRead)))
        {
        EnterCS(&m_cs);
        sc = ContinueHandshake(m_iCurSecPkg, &m_hContext, pszBuf, cbRead, &cbEaten, &OutBuffer);
        LeaveCS(&m_cs);
        // if there's a response to send, then do it
        if (OutBuffer.cbBuffer && OutBuffer.pvBuffer)
            {
            int iSent;
            hr = SendBytes((char *)OutBuffer.pvBuffer, OutBuffer.cbBuffer, &iSent);
            g_FreeContextBuffer(OutBuffer.pvBuffer);
            }
        if (sc == SEC_E_OK)
            {
            HRESULT hrCert;

            EnterCS(&m_cs);
            m_fSecure = TRUE;

            LPSRVIGNORABLEERROR pIgnorerror = NULL;
            g_pSrvErrRoot = FindOrAddServer(m_pszServer, g_pSrvErrRoot, &pIgnorerror);

            hrCert = ChkCertificateTrust(&m_hContext, m_pszServer);
            LeaveCS(&m_cs);

            if (hrCert && (!pIgnorerror || (hrCert != pIgnorerror->hrError)))
                {
                TCHAR   szError[CCHMAX_RES + CCHMAX_RES],
                        szPrompt[CCHMAX_RES],
                        szCaption[CCHMAX_RES];
                IAsyncConnPrompt *pPrompt;
                DWORD dw;
                const DWORD cLineWidth = 64;

                LoadString(g_hLocRes, idsSecurityErr, szCaption, ARRAYSIZE(szCaption));
                LoadString(g_hLocRes, idsInvalidCert, szError, ARRAYSIZE(szError));
                LoadString(g_hLocRes, idsIgnoreSecureErr, szPrompt, ARRAYSIZE(szPrompt));

                StrCatBuff(szError, c_szCRLFCRLF, ARRAYSIZE(szError));
                dw = lstrlen(szError);
                if (!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | cLineWidth,
                                   NULL, hrCert, 0, szError+dw, ARRAYSIZE(szError)-dw, NULL))
                {
                    TCHAR szErrNum[16];

                    wnsprintf(szErrNum, ARRAYSIZE(szErrNum), "0x%x", hrCert);
                    StrCatBuff(szError, szErrNum, ARRAYSIZE(szError));
                }

                Assert(lstrlen(szError) + lstrlen(szPrompt) + lstrlen("\r\n\r\n") < ARRAYSIZE(szError));
                StrCatBuff(szError, c_szCRLFCRLF, ARRAYSIZE(szError));
                StrCatBuff(szError, szPrompt, ARRAYSIZE(szError));

                EnterCS(&m_cs);
                pPrompt = m_pPrompt;
                if (pPrompt)
                    pPrompt->AddRef();
                LeaveCS(&m_cs);
            
                EnterPausedState();
                if (pPrompt && IDYES == pPrompt->OnPrompt(hrCert, szError, szCaption, MB_YESNO | MB_ICONEXCLAMATION  | MB_SETFOREGROUND))
                    {
                    // Set ignorable error 
                    if(pIgnorerror)
                        pIgnorerror->hrError =  hrCert;

                    ChangeState(AS_CONNECTED, AE_CONNECTDONE);
                    if (cbEaten < cbRead)
                        {
                        // there were bytes left over, so hold onto them
                        hr = OnDataAvail(pszBuf + cbEaten, cbRead - cbEaten, sc == SEC_E_INCOMPLETE_MESSAGE);
                        }
                    LeavePausedState();
                    }
                else
                    Close();
        
                if (pPrompt)
                    pPrompt->Release();

                MemFree(pszBuf);
                return hr;
                }

            ChangeState(AS_CONNECTED, AE_CONNECTDONE);
            }
        else if (sc != SEC_I_CONTINUE_NEEDED && sc != SEC_E_INCOMPLETE_MESSAGE)
            {
            // unexpected error - we should reset the socket and try the next package
            DOUTL(2, "unexpected error from ContinueHandshake() - closing socket.");
            return OnSSLError();
            }
        else
            {
            Assert(sc == SEC_I_CONTINUE_NEEDED || sc == SEC_E_INCOMPLETE_MESSAGE);
            // stay inside the handshake loop, waiting for more data to arrive
            }
        if (cbEaten < cbRead)
            {
            // there were bytes left over, so hold onto them
            hr = OnDataAvail(pszBuf + cbEaten, cbRead - cbEaten, sc == SEC_E_INCOMPLETE_MESSAGE);
            }
        MemFree(pszBuf);
        }
    return hr;
}

void CAsyncConn::CleanUp()
{
    PRECVBUFQ pRecv = m_pRecvHead, pTemp;
    SafeMemFree(m_lpbQueued);
    m_lpbQueueCur = NULL;
    m_cbQueued = 0;
    SafeMemFree(m_pbExtra);
    m_cbExtra = 0;
    SafeRelease(m_pStream);
    while (pRecv)
        {
        pTemp = pRecv;
        pRecv = pRecv->pNext;
        MemFree(pTemp);
        }
    m_pRecvHead = m_pRecvTail = NULL;
    m_iRecvOffset = 0;
    m_iLastError = 0;
    m_fNeedRecvNotify = FALSE;
    m_fSecure = FALSE;
    m_fPaused = FALSE;
}

void CAsyncConn::EnterPausedState()
{
    EnterCS(&m_cs);
    m_fPaused = TRUE;
    m_dwEventMask = 0;
    StopWatchDog();
    LeaveCS(&m_cs);
}

void CAsyncConn::LeavePausedState()
{
    DWORD dwEventMask;

    EnterCS(&m_cs);
    m_fPaused = FALSE;
    dwEventMask = m_dwEventMask;
    LeaveCS(&m_cs);

    if (dwEventMask & FD_CLOSE)
        Close();
    else
        { 
        if (dwEventMask & FD_READ)
            OnRead();
        if (dwEventMask & FD_WRITE)
            OnWrite();
        }
}

/////////////////////////////////////////////////////////////////////////////
// 
// UTILITY FUNCTIONS
//
/////////////////////////////////////////////////////////////////////////////
BOOL FEndLine(char *psz, int iLen)
{
    while (iLen--)
        {
        if (*psz++ == '\n')
            return TRUE;
        }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\asynconn.h ===
/*
 *    asynconn.h
 *    
 *    Purpose:
 *        prototypes for the async connection class
 *    
 *    Owner:
 *        EricAn
 *
 *    History:
 *      Apr 96: Created.
 *    
 *    Copyright (C) Microsoft Corp. 1996
 */

#ifndef __ASYNCONN_H__
#define __ASYNCONN_H__

#include "thorsspi.h"

interface ILogFile;

typedef struct tagRECVBUFQ * PRECVBUFQ;
typedef struct tagRECVBUFQ {
    PRECVBUFQ   pNext;
    int         cbLen;
    char        szBuf[1];
} RECVBUFQ;
        
// this is structure for server's ignorable errors
typedef struct _SRVIGNORABLEERROR 
{
    TCHAR *pchServerName;
    HRESULT hrError;
    struct _SRVIGNORABLEERROR * pLeft;
    struct _SRVIGNORABLEERROR * pRight;
} SRVIGNORABLEERROR, *LPSRVIGNORABLEERROR;

void FreeSrvErr(LPSRVIGNORABLEERROR pSrvErr);

// This interface takes the place of any call to AtheMessageBox in asynconn.cpp. The
// user of the CAsyncConn class must provide an implementation of this interface.
interface IAsyncConnPrompt : IUnknown
{
    // This method works very much like MessageBox. It is expected that the implementor
    // of this method will display a MessageBox. For example:
    //
    // int CPOP3AsyncConnPrompt::OnPrompt(HRESULT hrError, 
    //                                    LPCTSTR pszText, 
    //                                    LPCTSTR pszCaption, 
    //                                    UINT    uType)
    // {
    //     Assert(pszText && pszCaption);
    //     return MessageBox(m_hwnd, pszText, pszCaption, uType);
    // }
    //
    // The user can compare against the hrError if they want to display their own
    // error messages for the corresponding HRESULT.
    // 
    virtual int OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType) PURE;
};

typedef enum {
    AS_DISCONNECTED,
    AS_RECONNECTING,
    AS_LOOKUPINPROG,
    AS_LOOKUPDONE,
    AS_CONNECTING,
    AS_CONNECTED,
    AS_HANDSHAKING,
} ASYNCSTATE;

typedef enum {
    AE_NONE,
    AE_LOOKUPDONE,
    AE_CONNECTDONE,
    AE_RECV,
    AE_SENDDONE,
    AE_CLOSE,
    AE_WRITE,
    AE_TIMEOUT
} ASYNCEVENT;

interface IAsyncConnCB : IUnknown
{
    virtual void  OnNotify(ASYNCSTATE asOld, ASYNCSTATE asNew, ASYNCEVENT ae) = 0;
};

class CAsyncConnNotify : public IAsyncConnCB
{
public:
    CAsyncConnNotify(HWND hwnd, UINT msg) 
    { 
        m_hwnd = hwnd;
        m_msg = msg; 
        m_cRef = 1; 
    }
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv)
    {
        return E_NOTIMPL;
    }
    STDMETHODIMP_(ULONG) AddRef(void)  
    { 
        return ++m_cRef; 
    }
    STDMETHODIMP_(ULONG) Release(void) 
    { 
        if (--m_cRef == 0) 
            { 
            delete this; 
            return 0; 
            } 
        return m_cRef; 
    }
    virtual void  OnNotify(ASYNCSTATE asOld, ASYNCSTATE asNew, ASYNCEVENT ae) 
    {
#ifndef WIN16
        PostMessage(m_hwnd, m_msg, MAKEWPARAM(asOld, asNew), (LPARAM)ae);
#else
        PostMessage(m_hwnd, m_msg, (WPARAM)ae, MAKELPARAM(asOld, asNew));
#endif // !WIN16
    }

private:
    ULONG m_cRef;
    HWND  m_hwnd;
    UINT  m_msg;
};

class CAsyncConn
{
public:
    CAsyncConn(ILogFile *pLogFile, IAsyncConnCB *pCB, IAsyncConnPrompt *pPrompt);
    ~CAsyncConn();

    // ISocketCB methods
    virtual ULONG AddRef(void);
    virtual ULONG Release(void);
    virtual void  OnNotify(UINT msg, WPARAM wParam, LPARAM lParam);

    HRESULT HrInit(char *szServer, int iDefaultPort, BOOL fSecure = FALSE, DWORD dwTimeout=0);
    HRESULT Connect();
    HRESULT Close();
    HRESULT ReadLine(char **ppszBuf, int *pcbRead);
    HRESULT ReadLines(char **ppszBuf, int *pcbRead, int *pcLines);
    HRESULT ReadBytes(char **ppszBuf, int cbBytesWanted, int *pcbRead);
    HRESULT SendBytes(const char *pszBuf, int cbBuf, int *pcbSent, BOOL fStuffDots=FALSE, CHAR *pchPrev=NULL);
    HRESULT SendStream(LPSTREAM pStream, int *pcbSent, BOOL fStuffDots=FALSE);
#ifdef WIN16
#ifdef GetLastError
#undef GetLastError
#endif
#endif // WIN16
    int     GetLastError() { return m_iLastError; }
    int     GetConnectStatusString();

    ULONG   UlGetSendByteCount(VOID);

    void StartWatchDog(void);
    void StopWatchDog(void);
    void OnWatchDogTimer(void);

    HRESULT SetWindow(void);
    HRESULT ResetWindow(void);
    
    HRESULT TryNextSecurityPkg();

private:
    void    ChangeState(ASYNCSTATE asNew, ASYNCEVENT ae);
    HRESULT HrStuffDots(CHAR *pchPrev, LPSTR pszIn, INT cbIn, LPSTR *ppszOut, INT *pcbOut);
    HRESULT AsyncConnect();
    HRESULT OnLookupDone(int iLastError);
    HRESULT OnConnect();
    HRESULT OnClose(ASYNCSTATE asNew);
    HRESULT OnRead();
    HRESULT OnDataAvail(LPSTR szRecv, int iRecv, BOOL fIncomplete);
    HRESULT OnWrite();
    HRESULT IReadLines(char **ppszBuf, int *pcbRead, int *pcLines, BOOL fOne);
    HRESULT ReadAllBytes(char **ppszBuf, int *pcbRead);
    HRESULT OnSSLError();
    HRESULT OnRecvHandshakeData();

    void   CleanUp();    
    void   EnterPausedState();
    void   LeavePausedState();
    HWND   CreateWnd();
    static LRESULT CALLBACK SockWndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);

private:
    ULONG            m_cRef;
    CHAR             m_chPrev;
    BOOL             m_fStuffDots;
    ULONG            m_cbSent;
    SOCKET           m_sock;
    BOOL             m_fLookup;
    ASYNCSTATE       m_state;
    SOCKADDR_IN      m_sa;
    BOOL             m_fCachedAddr;
    BOOL             m_fRedoLookup;
    LPSTR            m_pszServer;
    u_short          m_iDefaultPort;
    int              m_iLastError;
    CRITICAL_SECTION m_cs;
    ILogFile *       m_pLogFile;
    IAsyncConnCB *   m_pCB;
    IAsyncConnPrompt *m_pPrompt;
    DWORD            m_cbQueued;
    char *           m_lpbQueued;
    char *           m_lpbQueueCur;
    LPSTREAM         m_pStream;
    PRECVBUFQ        m_pRecvHead;
    PRECVBUFQ        m_pRecvTail;
    int              m_iRecvOffset;
    BOOL             m_fNeedRecvNotify;
    HWND             m_hwnd;
    BOOL             m_fNegotiateSecure;
    BOOL             m_fSecure;
    CtxtHandle       m_hContext;
    int              m_iCurSecPkg;
    LPSTR            m_pbExtra;
    int              m_cbExtra;

    // For Timeout Handling
    DWORD            m_dwLastActivity;
    DWORD            m_dwTimeout;
    UINT_PTR         m_uiTimer;
#ifdef DEBUG
    int              m_cLock;
#endif
    BOOL             m_fPaused;
    DWORD            m_dwEventMask;
};

#endif // __ASYNCONN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\davdef.h ===
// Elements in the DAV namespace

#ifndef PROP_DAV
#define PROP_DAV(name, value)
#endif
#ifndef PROP_HTTP
#define PROP_HTTP(name, value)
#endif
#ifndef PROP_HOTMAIL
#define PROP_HOTMAIL(name, value)
#endif
#ifndef PROP_MAIL
#define PROP_MAIL(name, value)
#endif
#ifndef PROP_CONTACTS
#define PROP_CONTACTS(name, value)
#endif

PROP_DAV(ALLPROP, allprop)
PROP_DAV(DISPLAYNAME, displayname)
PROP_DAV(GETCONTENTLENGTH, getcontentlength)
PROP_DAV(HASSUBS, hassubs)
PROP_DAV(HREF, href)
PROP_DAV(ID, id)
PROP_DAV(ISFOLDER, isfolder)
PROP_DAV(ISHIDDEN, ishidden)
PROP_DAV(LOCATION, location)
PROP_DAV(MULTISTATUS, multistatus)
PROP_DAV(NOSUBS, nosubs)
PROP_DAV(PROP, prop)
PROP_DAV(PROPFIND, propfind)
PROP_DAV(PROPSTAT, propstat)
PROP_DAV(RESPONSE, response)
PROP_DAV(STATUS, status)
PROP_DAV(TARGET, target)
PROP_DAV(VISIBLECOUNT, visiblecount)

// Elements in the HTTPMail namespace

PROP_HTTP(ANSWERED, answered)
PROP_HTTP(CALENDAR, calendar)
PROP_HTTP(CONTACTS, contacts)
PROP_HTTP(DELETEDITEMS, deleteditems)
PROP_HTTP(DRAFT, draft)
PROP_HTTP(DRAFTS, drafts)
PROP_HTTP(FLAG, flag)
PROP_HTTP(INBOX, inbox)
PROP_HTTP(MSGFOLDERROOT, msgfolderroot)
PROP_HTTP(OUTBOX, outbox)
PROP_HTTP(READ, read)
PROP_HTTP(SENDMSG, sendmsg)
PROP_HTTP(SENTITEMS, sentitems)
PROP_HTTP(SPECIAL, special)
PROP_HTTP(UNREADCOUNT, unreadcount)

// Elements in the HotMail namespace
// These should be in the alphabetical order of their tags.
PROP_HOTMAIL(ADBAR, adbar)
PROP_HOTMAIL(MAXPOLLINGINTERVAL, maxpoll)
PROP_HOTMAIL(MODIFIED, modified)
PROP_HOTMAIL(SIG, sig)

// Elements in the Mail namespace
PROP_MAIL(BCC, bcc)
PROP_MAIL(CC, cc)
PROP_MAIL(DATE, date)
PROP_MAIL(FROM, from)
PROP_MAIL(HASATTACHMENT, hasattachment)
PROP_MAIL(PRIORITY, priority)
PROP_MAIL(RECEIVED, received)
PROP_MAIL(SUBJECT, subject)
PROP_MAIL(TO, to)

PROP_CONTACTS(BDAY, bday)
PROP_CONTACTS(CN, cn)
PROP_CONTACTS(FRIENDLYCOUNTRYNAME, co)
PROP_CONTACTS(CONTACT, contact)
PROP_CONTACTS(FACSIMILETELEPHONENUMBER, facsimiletelephonenumber)
PROP_CONTACTS(GIVENNAME, givenName)
PROP_CONTACTS(GROUP, group)
PROP_CONTACTS(HOMECITY, homeCity)
PROP_CONTACTS(HOMECOUNTRY, homeCountry)
PROP_CONTACTS(HOMEFAX, homeFax)
PROP_CONTACTS(HOMEPHONE, homePhone)
PROP_CONTACTS(HOMEPOSTALCODE, homePostalCode)
PROP_CONTACTS(HOMESTATE, homeState)
PROP_CONTACTS(HOMESTREET, homeStreet)
PROP_CONTACTS(L, l)
PROP_CONTACTS(MAIL, mail)
PROP_CONTACTS(MOBILE, mobile)
PROP_CONTACTS(NICKNAME, nickname)
PROP_CONTACTS(O, o)
PROP_CONTACTS(OTHERTELEPHONE, otherTelephone)
PROP_CONTACTS(PAGER, pager)
PROP_CONTACTS(POSTALCODE, postalcode)
PROP_CONTACTS(SN, sn)
PROP_CONTACTS(ST, st)
PROP_CONTACTS(STREET, street)
PROP_CONTACTS(TELEPHONENUMBER, telephoneNumber)

// undefine the macros
#undef PROP_DAV
#undef PROP_HTTP
#undef PROP_HOTMAIL
#undef PROP_MAIL
#undef PROP_CONTACTS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\davprops.h ===
// --------------------------------------------------------------------------------
// davprops.h
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved
// Greg Friedman
// --------------------------------------------------------------------------------


#ifndef _DAVPROPS_H__
#define _DAVPROPS_H__

#define PROP_DAV(name, value)      HMELE_DAV_##name,
#define PROP_HTTP(name, value)     HMELE_HTTPMAIL_##name,
#define PROP_HOTMAIL(name, value)  HMELE_HOTMAIL_##name,
#define PROP_MAIL(name, value)     HMELE_MAIL_##name,
#define PROP_CONTACTS(name, value) HMELE_CONTACTS_##name,

enum HMELE
{
    HMELE_UNKNOWN = 0,
    #include "davdef.h"
    HMELE_LAST
};

#endif // _DAVPROPS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\davparse.cpp ===
#include <pch.hxx>
#include "davparse.h"
#include "strconst.h"
#include "shlwapi.h"

#define DEFINE_DAVSTRS
#include "davstrs.h"
#undef DEFINE_DAVSTRS

typedef struct tagELEINFO
{
    const WCHAR     *pwcTagName;
    ULONG           ulLen;
    HMELE           eleID;
} ELEINFO, *LPELEINFO;

typedef struct tagNAMESPACEINFO
{
    const WCHAR     *pszwNamespace;
    DWORD           dwLen;
    DWORD           dwNamespaceID;
} NAMESPACEINFO, *LPNAMESPACEINFO;

static const ELEINFO c_rgDavElements[] =
{
#define PROP_DAV(prop, value) \
    { c_szwDAV##prop, ulDAV##prop##Len, HMELE_DAV_##prop },
#include "davdef.h"
};

static const ELEINFO c_rgHTTPMailElements[] =
{
#define PROP_HTTP(prop, value) \
    { c_szwDAV##prop, ulDAV##prop##Len, HMELE_HTTPMAIL_##prop },
#include "davdef.h"
};

static const ELEINFO c_rgHotMailElements[] =
{
#define PROP_HOTMAIL(prop, value) \
    { c_szwDAV##prop, ulDAV##prop##Len, HMELE_HOTMAIL_##prop },
#include "davdef.h"
};

static const ELEINFO c_rgMailElements[] =
{
#define PROP_MAIL(prop, value) \
    { c_szwDAV##prop, ulDAV##prop##Len, HMELE_MAIL_##prop },
#include "davdef.h"
};

static const ELEINFO c_rgContactElements[] =
{
#define PROP_CONTACTS(prop, value) \
    { c_szwDAV##prop, ulDAV##prop##Len, HMELE_CONTACTS_##prop },
#include "davdef.h"
};

const HMDICTINFO rgHTTPMailDictionary[] =
{
#define PROP_DAV(prop, value)      { DAVNAMESPACE_DAV, c_szDAV##prop },
#define PROP_HTTP(prop, value)     { DAVNAMESPACE_HTTPMAIL, c_szDAV##prop },
#define PROP_HOTMAIL(prop, value)  { DAVNAMESPACE_HOTMAIL, c_szDAV##prop },
#define PROP_MAIL(prop, value)     { DAVNAMESPACE_MAIL, c_szDAV##prop },
#define PROP_CONTACTS(prop, value) { DAVNAMESPACE_CONTACTS, c_szDAV##prop },

    { DAVNAMESPACE_UNKNOWN, NULL }, // HMELE_UNKNOWN
#include "davdef.h"
};

static NAMESPACEINFO c_rgNamespaceInfo[] =
{
    { DAV_STR_LEN(DavNamespace), DAVNAMESPACE_DAV },
    { DAV_STR_LEN(HTTPMailNamespace), DAVNAMESPACE_HTTPMAIL },
    { DAV_STR_LEN(HotMailNamespace), DAVNAMESPACE_HOTMAIL },
    { DAV_STR_LEN(MailNamespace), DAVNAMESPACE_MAIL },
    { DAV_STR_LEN(ContactsNamespace), DAVNAMESPACE_CONTACTS }
};

CXMLNamespace::CXMLNamespace(CXMLNamespace *pParent) : 
    m_cRef(1),
    m_pParent(NULL),
    m_pwcPrefix(NULL),
    m_ulPrefixLen(0),
    m_dwNsID(DAVNAMESPACE_UNKNOWN)
{
    if (NULL != pParent)
        SetParent(pParent);
}

CXMLNamespace::~CXMLNamespace(void)
{
    SafeRelease(m_pParent);
    SafeMemFree(m_pwcPrefix);
}

ULONG CXMLNamespace::AddRef(void)
{
    return (++m_cRef);
}

ULONG CXMLNamespace::Release(void)
{
    if (0 == --m_cRef)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

HRESULT CXMLNamespace::Init(
                        const WCHAR *pwcNamespace,
                        ULONG ulNSLen,
                        const WCHAR* pwcPrefix,
                        ULONG ulPrefixLen)
{
    HRESULT         hr = S_OK;
    
    if (FAILED(hr = SetPrefix(pwcPrefix, ulPrefixLen)))
        goto exit;

    hr = SetNamespace(pwcNamespace, ulNSLen);

exit:
    return hr;
}

HRESULT CXMLNamespace::SetNamespace(const WCHAR *pwcNamespace, ULONG ulLen)
{
    DWORD           dwIndex;
    LPNAMESPACEINFO pnsi = NULL;

    // determine if the namespace is known
    for (dwIndex = 0; dwIndex < ARRAYSIZE(c_rgNamespaceInfo); ++dwIndex)
    {
        pnsi = &c_rgNamespaceInfo[dwIndex];

        if ((ulLen == c_rgNamespaceInfo[dwIndex].dwLen) &&  (0 == StrCmpNW(pwcNamespace, c_rgNamespaceInfo[dwIndex].pszwNamespace, ulLen)))
        {
            m_dwNsID = c_rgNamespaceInfo[dwIndex].dwNamespaceID;
            break;
        }
    }

    return S_OK;
}

HRESULT CXMLNamespace::SetPrefix(const WCHAR *pwcPrefix, ULONG ulLen)
{
    HRESULT hr = S_OK;

    SafeMemFree(m_pwcPrefix);
    m_ulPrefixLen = 0;

    if (pwcPrefix && ulLen > 0)
    {
        // duplicate the prefix, and add it to the map
        if (!MemAlloc((void **)&m_pwcPrefix, sizeof(WCHAR) * ulLen))
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        CopyMemory(m_pwcPrefix, pwcPrefix, sizeof(WCHAR) * ulLen);
        m_ulPrefixLen = ulLen;
    }
exit:
    return hr;
}

DWORD CXMLNamespace::_MapPrefix(
                        const WCHAR *pwcPrefix, 
                        ULONG ulPrefixLen, 
                        BOOL *pbFoundDefaultNamespace)
{
    BOOL    bFoundDefault = FALSE;
    DWORD   dwNsID = DAVNAMESPACE_UNKNOWN;
    
    if ((ulPrefixLen > 0) && (ulPrefixLen == m_ulPrefixLen) && (0 == StrCmpNW(pwcPrefix, m_pwcPrefix, ulPrefixLen)))
    {
        dwNsID = m_dwNsID;
        goto exit;
    }

    // look for a match in the parent.
    if (m_pParent)
        dwNsID = m_pParent->_MapPrefix(pwcPrefix, ulPrefixLen, &bFoundDefault);

    // if we are a default namespace, and either we didn't find a match in the parent, or
    // we found a default namespace match in the parent, this becomes the namespace
    if ((NULL == m_pwcPrefix) && (DAVNAMESPACE_UNKNOWN == dwNsID || bFoundDefault))
    {
        dwNsID = m_dwNsID;
        bFoundDefault = TRUE; // may not be true if !bFoundInParent
    }

exit:
    if (NULL != pbFoundDefaultNamespace)
        *pbFoundDefaultNamespace = bFoundDefault;
    
    return dwNsID;
}


static BOOL GetNamespace(
                const WCHAR *pwcNamespace,
                ULONG ulNsLen,
                CXMLNamespace *pNamespace,
                const ELEINFO **pprgEleInfo,
                DWORD *pdwInfoLength)
{
    if (NULL == pNamespace || NULL == pprgEleInfo || NULL == pdwInfoLength)
        return FALSE;
    
    BOOL bResult = TRUE;
    switch (pNamespace->MapPrefix(pwcNamespace, ulNsLen))
    {
        case DAVNAMESPACE_DAV:
            *pprgEleInfo = c_rgDavElements;
            *pdwInfoLength = ARRAYSIZE(c_rgDavElements);
            break;
    
        case DAVNAMESPACE_HTTPMAIL:
            *pprgEleInfo = c_rgHTTPMailElements;
            *pdwInfoLength = ARRAYSIZE(c_rgHTTPMailElements);
            break;
        
        case DAVNAMESPACE_HOTMAIL:
            *pprgEleInfo = c_rgHotMailElements;
            *pdwInfoLength =  ARRAYSIZE(c_rgHotMailElements);
            break;

        case DAVNAMESPACE_MAIL :
            *pprgEleInfo = c_rgMailElements;
            *pdwInfoLength =  ARRAYSIZE(c_rgMailElements);
            break;

        case DAVNAMESPACE_CONTACTS:
            *pprgEleInfo = c_rgContactElements;
            *pdwInfoLength = ARRAYSIZE(c_rgContactElements);
            break;

        default:
            *pprgEleInfo = NULL;
            *pdwInfoLength = 0;
            bResult = FALSE;
            break;
    }

    return bResult;
}

HMELE SearchNamespace(const WCHAR *pwcText, ULONG ulLen, const ELEINFO *prgEleInfo, DWORD cInfo)
{
    HMELE       hmEle = HMELE_UNKNOWN;
    ULONG       ulLeft = 0;
    ULONG       ulRight = cInfo - 1;
    ULONG       ulCur;
    int         iCompare;

    while (ulLeft <= ulRight)
    {
        ulCur = ulLeft + ((ulRight - ulLeft) / 2);
        iCompare = StrCmpNW(pwcText, prgEleInfo[ulCur].pwcTagName, min(ulLen, prgEleInfo[ulCur].ulLen));   
    
        if (0 == iCompare)
        {
            // if the lengths are the same, it's really a match
            if (ulLen == prgEleInfo[ulCur].ulLen)
            {
                hmEle = prgEleInfo[ulCur].eleID;
                break;
            }
            // if the lengths aren't the same, figure out which string is longer
            else if (ulLen > prgEleInfo[ulCur].ulLen)
                iCompare = 1;
            else
                iCompare = -1;
        }

        if (iCompare < 0)
        {
            if (ulCur > 0)
                ulRight = ulCur - 1;
            else
                break;
        }
        else
            ulLeft = ulCur + 1;
    }

    return hmEle;
}

HMELE XMLElementToID(
            const WCHAR *pwcText,
            ULONG ulLen,
            ULONG ulNamespaceLen,
            CXMLNamespace *pNamespace)
{
    HMELE           hmEle = HMELE_UNKNOWN;
    const ELEINFO   *pEleInfo = NULL;
    DWORD           cInfo = 0;
    ULONG           ulNameLen = ulLen;


    // if the lengths are the same, there is either no namespace
    // or no tagname. either way, we aren't going to find a match.
    if ((NULL == pwcText) || (NULL == pNamespace))
        goto exit;

    // if a namespace was specified, subtract it out of the tag name length
    if (0 < ulNamespaceLen)
        ulNameLen -= (ulNamespaceLen + 1);

    // null terminate the namespace string while we figure out if
    // the namespace is known
    if (GetNamespace(pwcText, ulNamespaceLen, pNamespace, &pEleInfo, &cInfo))
        hmEle = SearchNamespace(&pwcText[ulNamespaceLen + 1], ulNameLen, pEleInfo, cInfo);
    
exit:
    return hmEle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\davparse.h ===
#ifndef __DAVPARSE_H_
#define __DAVPARSE_H_

#include "davprops.h"

#define DAV_STR_LEN(name) \
    c_szwDAV##name, ulDAV##name##Len

typedef struct tagHMDICTINFO
{
    DWORD       dwNamespaceID;
    const char* pszName;
} HMDICTINFO, *LPHMDICTINFO;

EXTERN_C const HMDICTINFO rgHTTPMailDictionary[];

class CXMLNamespace
{
public:
    CXMLNamespace(CXMLNamespace *pParent = NULL);

    ULONG AddRef(void);
    ULONG Release(void);
private:
    ~CXMLNamespace(void);

    // unimplemented
    CXMLNamespace(const CXMLNamespace& other);
    CXMLNamespace& operator=(const CXMLNamespace& other);

public:
    HRESULT Init(
            const WCHAR *pwcNamespace,
            ULONG ulNsLen,
            const WCHAR* pwcPrefix,
            ULONG ulPrefix);

    HRESULT SetNamespace(const WCHAR *pwcNamespace, ULONG ulNsLen);
    HRESULT SetPrefix(const WCHAR *pwcPrefix, ULONG ulPrefix);

    DWORD MapPrefix(
                const WCHAR *pwcPrefix, 
                ULONG ulPrefixLen)
    {
        return _MapPrefix(pwcPrefix, ulPrefixLen);
    }

    void SetParent(CXMLNamespace* pParent)
    {
        SafeRelease(m_pParent);
        m_pParent = pParent;
        if (m_pParent)
            m_pParent->AddRef();
    }

    CXMLNamespace* GetParent(void)
    {
        if (m_pParent)
            m_pParent->AddRef();
        
        return m_pParent;
    }

private:
    DWORD _MapPrefix(const WCHAR *pwcPrefix, ULONG ulPrefixLen, BOOL *pbFoundDefault = NULL);

private:
    ULONG           m_cRef;
    CXMLNamespace   *m_pParent;
    WCHAR           *m_pwcPrefix;
    ULONG           m_ulPrefixLen;
    DWORD           m_dwNsID;
};

HMELE XMLElementToID(
            const WCHAR *pwcText,
            ULONG ulLen,
            ULONG ulNamespaceLen,
            CXMLNamespace *pNamespace);
    
#endif // __DAVPARSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\davstrs.h ===
#ifdef DEFINE_DAVSTRS

#define DAVSTR(name, value) \
    EXTERN_C const WCHAR c_szwDAV##name[] = L#value; \
    EXTERN_C const ULONG ulDAV##name##Len = (ARRAYSIZE(c_szwDAV##name) - 1); \
    EXTERN_C const char c_szDAV##name[] = #value;

#define STRCONST(name, value) \
    EXTERN_C const WCHAR c_szwDAV##name[] = L##value; \
    EXTERN_C const ULONG ulDAV##name##Len = (ARRAYSIZE(c_szwDAV##name) - 1); \
    EXTERN_C const char c_szDAV##name[] = value;

#else // DEFINE_DAVSTRS

#define DAVSTR(name, value) \
    EXTERN_C const WCHAR c_szwDAV##name[]; \
    EXTERN_C const ULONG ulDAV##name##Len; \
    EXTERN_C const char c_szDAV##name[];

#define STRCONST(name, value) \
    EXTERN_C const WCHAR c_szwDAV##name[]; \
    EXTERN_C const ULONG ulDAV##name##Len; \
    EXTERN_C const char c_szDAV##name[];

#endif // DEFINE_DAVSTRS

#define PROP_DAV(name, value)      DAVSTR(name, value)
#define PROP_HTTP(name, value)     DAVSTR(name, value)
#define PROP_HOTMAIL(name, value)  DAVSTR(name, value)
#define PROP_MAIL(name, value)     DAVSTR(name, value)
#define PROP_CONTACTS(name, value) DAVSTR(name, value)

#include "davdef.h"

// Namespaces

STRCONST(DavNamespace, "DAV:")
STRCONST(HotMailNamespace, "http://schemas.microsoft.com/hotmail/")
STRCONST(HTTPMailNamespace, "urn:schemas:httpmail:")
STRCONST(MailNamespace, "urn:schemas:mailheader:")
STRCONST(ContactsNamespace, "urn:schemas:contacts:")

// Special Folders
STRCONST(InboxSpecialFolder,          "inbox");
STRCONST(DeletedItemsSpecialFolder,   "deleteditems");
STRCONST(DraftsSpecialFolder,         "drafts");
STRCONST(OutboxSpecialFolder,         "outbox");
STRCONST(SentItemsSpecialFolder,      "sentitems");
STRCONST(ContactsSpecialFolder,       "contacts");
STRCONST(CalendarSpecialFolder,       "calendar");
STRCONST(MsnPromoSpecialFolder,       "msnpromo");
STRCONST(BulkMailSpecialFolder,       "bulkmail");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\ixpbase.cpp ===
// --------------------------------------------------------------------------------
// Ixpbase.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "ixpbase.h"
#include "imnact.h"
#include "ixputil.h"
#include "sicily.h"
#include "resource.h"
#include "demand.h"
#include "shlwapi.h"

// --------------------------------------------------------------------------------
// CIxpBase::CIxpBase
// --------------------------------------------------------------------------------
CIxpBase::CIxpBase(IXPTYPE ixptype) : m_ixptype(ixptype)
{
    m_fBusy = FALSE;
    m_status = IXP_DISCONNECTED;
    m_cRef = 1;
    m_pszResponse = NULL;
    m_uiResponse = 0;
    m_hrResponse = S_OK;
    m_pLogFile = NULL;
    m_pSocket = NULL;
    m_pCallback = NULL;
    ZeroMemory(&m_rServer, sizeof(m_rServer));
    m_fConnectAuth = FALSE;
    m_fConnectTLS = FALSE;
    m_fCommandLogging = FALSE;
    m_fAuthenticated = FALSE;
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CIxpBase::~CIxpBase
// --------------------------------------------------------------------------------
CIxpBase::~CIxpBase(void)
{
    Reset();
    DeleteCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CIxpBase::Reset
// --------------------------------------------------------------------------------
void CIxpBase::Reset(void)
{
    EnterCriticalSection(&m_cs);
    m_fBusy = FALSE;
    m_status = IXP_DISCONNECTED;
    SafeMemFree(m_pszResponse);
    m_uiResponse = 0;
    m_hrResponse = S_OK;
    SafeRelease(m_pLogFile);
    if (NULL != m_pSocket) 
    {
        m_pSocket->Close();
        SafeRelease(m_pSocket);
    }
    SafeRelease(m_pCallback);
    ZeroMemory(&m_rServer, sizeof(m_rServer));
    m_fConnectAuth = FALSE;
    m_fConnectTLS = FALSE;
    m_fCommandLogging = FALSE;
    m_fAuthenticated = FALSE;
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CIxpBase::IsState
// --------------------------------------------------------------------------------
STDMETHODIMP CIxpBase::IsState(IXPISSTATE isstate) 
{
    // Locals
    HRESULT hr=S_FALSE;

    // Thread Safety
	EnterCriticalSection(&m_cs);

#if 0
    // Initialized
    if (NULL == m_pSocket || NULL == m_pCallback)
    {
        hr = TrapError(IXP_E_NOT_INIT);
        goto exit;
    }
#endif

    // Handle IsType
    switch(isstate)
    {
    // Are we connected
    case IXP_IS_CONNECTED:
        hr =  (IXP_DISCONNECTED == m_status) ? S_FALSE : S_OK;
        break;

    // Are we busy
    case IXP_IS_BUSY:
        hr = (TRUE == m_fBusy) ? S_OK : S_FALSE;
        break;

    // Are we busy
    case IXP_IS_READY:
        hr = (FALSE == m_fBusy) ? S_OK : S_FALSE;
        break;

    // Have we been authenticated yet
    case IXP_IS_AUTHENTICATED:
        hr = (TRUE == m_fAuthenticated) ? S_OK : S_FALSE;
        break;

    // Unhandled ixpistype
    default:
        IxpAssert(FALSE);
        break;
    }

    // Thread Safety
	LeaveCriticalSection(&m_cs);

    // Done
	return hr;
}

// --------------------------------------------------------------------------------
// CIxpBase::OnPrompt
// --------------------------------------------------------------------------------
int CIxpBase::OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType)
{
    // $$BUGBUG$$ Need to return an error
    if (NULL == m_pCallback)
        return TrapError(IXP_E_NOT_INIT);

    // Call the callback
    return m_pCallback->OnPrompt(hrError, pszText, pszCaption, uType, this);
}

// --------------------------------------------------------------------------------
// CIxpBase::OnError
// --------------------------------------------------------------------------------
void CIxpBase::OnError(HRESULT hrResult, LPSTR pszProblem)
{
    // Locals
    IXPRESULT rIxpResult;

    // No Callback
    if (NULL == m_pCallback)
        return;

    // Zero It
    ZeroMemory(&rIxpResult, sizeof(IXPRESULT));

	// Save current state
    rIxpResult.hrResult = hrResult;
    rIxpResult.pszResponse = PszDupA(m_pszResponse);
    rIxpResult.uiServerError = m_uiResponse;
    rIxpResult.hrServerError = m_hrResponse;
    rIxpResult.dwSocketError = m_pSocket->GetLastError();
    rIxpResult.pszProblem = PszDupA(pszProblem);


    if (m_pLogFile && pszProblem)
    {
        // Locals
        char szErrorTxt[1024];

        // Build the Error
        wnsprintf(szErrorTxt, ARRAYSIZE(szErrorTxt), "ERROR: \"%.900s\", hr=%lu", pszProblem, hrResult);

        // Write the error
        m_pLogFile->WriteLog(LOGFILE_DB, szErrorTxt);
    }

    // Tell the watchdog to take a nap
    m_pSocket->StopWatchDog();

    // Give to callback
    m_pCallback->OnError(m_status, &rIxpResult, this);

    // Start the watchdog and wait for normal socket activity
    m_pSocket->StartWatchDog();

    // Free stuff
    SafeMemFree(rIxpResult.pszResponse);
    SafeMemFree(rIxpResult.pszProblem);
}

// --------------------------------------------------------------------------------
// CIxpBase::OnStatus
// --------------------------------------------------------------------------------
void CIxpBase::OnStatus(IXPSTATUS ixpstatus)
{
    // Save new Status
    m_status = ixpstatus;

    if (IXP_AUTHORIZED == ixpstatus)
        m_fAuthenticated = TRUE;
    else if (IXP_DISCONNECTED == ixpstatus || IXP_DISCONNECTING == ixpstatus)
        m_fAuthenticated = FALSE;

    // Give Status to callback
    if (m_pCallback)
        m_pCallback->OnStatus(ixpstatus, this);

    // If we're informing caller that we're authorized, head immediately to IXP_CONNECTED
    // UNLESS m_status is changed: this indicates state change (eg, disconnect) during callback
    if (IXP_AUTHORIZED == ixpstatus && IXP_AUTHORIZED == m_status) 
    {
        m_status = IXP_CONNECTED;
        if (m_pCallback)
            m_pCallback->OnStatus(IXP_CONNECTED, this);
    }
}

// --------------------------------------------------------------------------------
// CIxpBase::HrEnterBusy
// --------------------------------------------------------------------------------
HRESULT CIxpBase::HrEnterBusy(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Initialized
    if (NULL == m_pSocket || NULL == m_pCallback)
    {
        hr = TrapError(IXP_E_NOT_INIT);
        goto exit;
    }

    // Not Ready
    if (TRUE == m_fBusy)
    {
        hr = TrapError(IXP_E_BUSY);
        goto exit;
    }

    // Start WatchDog
    m_pSocket->StartWatchDog();

    // Busy
    m_fBusy = TRUE;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CIxpBase::LeaveBusy
// --------------------------------------------------------------------------------
void CIxpBase::LeaveBusy(void)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Start WatchDog
    if (NULL != m_pSocket)
    {
        m_pSocket->StopWatchDog();
    }

    // Busy
    m_fBusy = FALSE;

    // Thread Safety
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CIxpBase::HandsOffCallback
// --------------------------------------------------------------------------------
STDMETHODIMP CIxpBase::HandsOffCallback(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No current callback
    if (NULL == m_pCallback)
    {
        hr = TrapError(S_FALSE);
        goto exit;
    }

    // Release it
    SafeRelease(m_pCallback);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CIxpBase::OnInitNew
// --------------------------------------------------------------------------------
HRESULT CIxpBase::OnInitNew(LPSTR pszProtocol, LPSTR pszLogFilePath, DWORD dwShareMode,
                            ITransportCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;

    // check params
    if (NULL == pCallback || NULL == pszProtocol)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Not connected
    if (IXP_DISCONNECTED != m_status)
    {
        hr = TrapError(IXP_E_ALREADY_CONNECTED);
        goto exit;
    }

    // release current objects
    Reset();
    ResetBase();

    // open log file
    if (pszLogFilePath)
    {
        // create the log file
        CreateLogFile(g_hInst, pszLogFilePath, pszProtocol, DONT_TRUNCATE, &m_pLogFile, dwShareMode);
    }

    // Create the socket
    m_pSocket = new CAsyncConn(m_pLogFile, (IAsyncConnCB *)this, (IAsyncConnPrompt *)this);
    if (NULL == m_pSocket)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

	// Add Ref callback
	m_pCallback = pCallback;
	m_pCallback->AddRef();

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CIxpBase::GetServerInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CIxpBase::GetServerInfo(LPINETSERVER pInetServer)
{
    // check params
    if (NULL == pInetServer)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Copy Server information
    CopyMemory(pInetServer, &m_rServer, sizeof(INETSERVER));

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CIxpBase::Disconnect
// --------------------------------------------------------------------------------
STDMETHODIMP CIxpBase::Disconnect(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No socket...
    if (NULL == m_pSocket)
    {
        hr = TrapError(IXP_E_NOT_INIT);
        goto exit;
    }

    // Not connected
    if (IXP_DISCONNECTED == m_status)
    {
        hr = TrapError(IXP_E_NOT_CONNECTED);
        goto exit;
    }

    // Disconnecting
    OnStatus(IXP_DISCONNECTING);

    // State
    DoQuit();

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CIxpBase::DropConnection
// --------------------------------------------------------------------------------
STDMETHODIMP CIxpBase::DropConnection(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No socket...
    if (NULL == m_pSocket)
    {
        hr = TrapError(IXP_E_NOT_INIT);
        goto exit;
    }

    // Already IXP_DISCONNECTED
    if (IXP_DISCONNECTED != m_status)
    {
        // State
        OnStatus(IXP_DISCONNECTING);

        // Done
        CHECKHR(hr = m_pSocket->Close());
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CIxpBase::InetServerFromAccount
// --------------------------------------------------------------------------------
STDMETHODIMP CIxpBase::InetServerFromAccount(IImnAccount *pAccount, LPINETSERVER pInetServer)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           fAlwaysPromptPassword=FALSE;

    // check params
    if (NULL == pAccount || NULL == pInetServer)
        return TrapError(E_INVALIDARG);

    // ZeroInit
    ZeroMemory(pInetServer, sizeof(INETSERVER));

    // Get the account name
    hr = pAccount->GetPropSz(AP_ACCOUNT_NAME, pInetServer->szAccount, ARRAYSIZE(pInetServer->szAccount));
    if (FAILED(hr))
    {
        hr = TrapError(IXP_E_INVALID_ACCOUNT);
        goto exit;
    }

    // Get the RAS connectoid
    if (FAILED(pAccount->GetPropSz(AP_RAS_CONNECTOID, pInetServer->szConnectoid, ARRAYSIZE(pInetServer->szConnectoid))))
        *pInetServer->szConnectoid = '\0';

    // Connection Type
    Assert(sizeof(pInetServer->rasconntype) == sizeof(DWORD));
    if (FAILED(pAccount->GetPropDw(AP_RAS_CONNECTION_TYPE, (DWORD *)&pInetServer->rasconntype)))
        pInetServer->rasconntype = RAS_CONNECT_LAN;

    // Connection Flags

    // IXP_SMTP
    if (IXP_SMTP == m_ixptype)
    {
        // Locals
        SMTPAUTHTYPE authtype;

        // Get Server Name
        hr = pAccount->GetPropSz(AP_SMTP_SERVER, pInetServer->szServerName, sizeof(pInetServer->szServerName));
        if (FAILED(hr))
        {
            hr = TrapError(IXP_E_INVALID_ACCOUNT);
            goto exit;
        }

        // SSL
        Assert(sizeof(pInetServer->fSSL) == sizeof(DWORD));
        pAccount->GetPropDw(AP_SMTP_SSL, (DWORD *)&pInetServer->fSSL);

        // Sicily
        Assert(sizeof(authtype) == sizeof(DWORD));
        if (FAILED(pAccount->GetPropDw(AP_SMTP_USE_SICILY, (DWORD *)&authtype)))
            authtype = SMTP_AUTH_NONE;

        if (SMTP_AUTH_NONE != authtype)
        {
            pInetServer->dwFlags |= ISF_QUERYAUTHSUPPORT;
        }
        
        // SMTP_AUTH_USE_POP3ORIMAP_SETTINGS
        if (SMTP_AUTH_USE_POP3ORIMAP_SETTINGS == authtype)
        {
            // Locals
            DWORD dwServers;
            DWORD dw;
            BOOL fIMAP;

            // Get Server Types
            if (FAILED(pAccount->GetServerTypes(&dwServers)))
            {
                hr = TrapError(IXP_E_INVALID_ACCOUNT);
                goto exit;
            }

            // fIMAP
            fIMAP = (ISFLAGSET(dwServers, SRV_IMAP)) ? TRUE : FALSE;

            // Using DPA
            if (SUCCEEDED(pAccount->GetPropDw(fIMAP ? AP_IMAP_USE_SICILY : AP_POP3_USE_SICILY, &dw)) && dw)
                pInetServer->fTrySicily = TRUE;

            // Get default username and password
            pAccount->GetPropSz(fIMAP ? AP_IMAP_USERNAME : AP_POP3_USERNAME, pInetServer->szUserName, sizeof(pInetServer->szUserName));
            if (FAILED(pAccount->GetPropDw(fIMAP ? AP_IMAP_PROMPT_PASSWORD : AP_POP3_PROMPT_PASSWORD, &fAlwaysPromptPassword)) ||
                FALSE == fAlwaysPromptPassword)
            {
                pAccount->GetPropSz(fIMAP ? AP_IMAP_PASSWORD : AP_POP3_PASSWORD, pInetServer->szPassword, sizeof(pInetServer->szPassword));
            }
            if (!pInetServer->fTrySicily && fAlwaysPromptPassword)
                pInetServer->dwFlags|=ISF_ALWAYSPROMPTFORPASSWORD;
        }

        // SMTP_AUTH_USE_SMTP_SETTINGS
        else if (SMTP_AUTH_USE_SMTP_SETTINGS == authtype)
        {
            pInetServer->fTrySicily = TRUE;
            pAccount->GetPropSz(AP_SMTP_USERNAME, pInetServer->szUserName, sizeof(pInetServer->szUserName));
            if (FAILED(pAccount->GetPropDw(AP_SMTP_PROMPT_PASSWORD, &fAlwaysPromptPassword)) ||
                FALSE == fAlwaysPromptPassword)
            {
                pAccount->GetPropSz(AP_SMTP_PASSWORD, pInetServer->szPassword, sizeof(pInetServer->szPassword));
            }
            if (fAlwaysPromptPassword)
                pInetServer->dwFlags|=ISF_ALWAYSPROMPTFORPASSWORD;
        }

        // Handle Authenticatin type
        else if (SMTP_AUTH_SICILY == authtype)
            pInetServer->fTrySicily = TRUE;

        // Port
        if (FAILED(pAccount->GetPropDw(AP_SMTP_PORT, &pInetServer->dwPort)))
            pInetServer->dwPort = DEFAULT_SMTP_PORT;

        // Timeout
        pAccount->GetPropDw(AP_SMTP_TIMEOUT, &pInetServer->dwTimeout);
        if (0 == pInetServer->dwTimeout)
            pInetServer->dwTimeout = 30;

        // Use STARTTLS?
        if ((FALSE != pInetServer->fSSL) && (DEFAULT_SMTP_PORT == pInetServer->dwPort))
            pInetServer->dwFlags|=ISF_SSLONSAMEPORT;
    }

    // IXP_POP3
    else if (IXP_POP3 == m_ixptype)
    {
        // Get Server Name
        hr = pAccount->GetPropSz(AP_POP3_SERVER, pInetServer->szServerName, sizeof(pInetServer->szServerName));
        if (FAILED(hr))
        {
            hr = TrapError(IXP_E_INVALID_ACCOUNT);
            goto exit;
        }

        // Password
        if (FAILED(pAccount->GetPropDw(AP_POP3_PROMPT_PASSWORD, &fAlwaysPromptPassword)) || 
            FALSE == fAlwaysPromptPassword)
            pAccount->GetPropSz(AP_POP3_PASSWORD, pInetServer->szPassword, sizeof(pInetServer->szPassword));

        // SSL
        Assert(sizeof(pInetServer->fSSL) == sizeof(DWORD));
        pAccount->GetPropDw(AP_POP3_SSL, (DWORD *)&pInetServer->fSSL);

        // Sicily
        Assert(sizeof(pInetServer->fTrySicily) == sizeof(DWORD));
        pAccount->GetPropDw(AP_POP3_USE_SICILY, (DWORD *)&pInetServer->fTrySicily);

        if (!pInetServer->fTrySicily && fAlwaysPromptPassword)
            pInetServer->dwFlags|=ISF_ALWAYSPROMPTFORPASSWORD;

        // Port
        if (FAILED(pAccount->GetPropDw(AP_POP3_PORT, &pInetServer->dwPort)))
            pInetServer->dwPort = 110;

        // User Name
        pAccount->GetPropSz(AP_POP3_USERNAME, pInetServer->szUserName, sizeof(pInetServer->szUserName));

        // Timeout
        pAccount->GetPropDw(AP_POP3_TIMEOUT, &pInetServer->dwTimeout);
    }

    // IXP_IMAP
    else if (IXP_IMAP == m_ixptype)
    {
        // User name, password and server
        hr = pAccount->GetPropSz(AP_IMAP_USERNAME, pInetServer->szUserName,
            ARRAYSIZE(pInetServer->szUserName));
        if (FAILED(hr))
            pInetServer->szUserName[0] = '\0'; // If this is incorrect, we will re-prompt user

        hr = pAccount->GetPropDw(AP_IMAP_PROMPT_PASSWORD, &fAlwaysPromptPassword);
        if (FAILED(hr) || FALSE == fAlwaysPromptPassword)
            {
            hr = pAccount->GetPropSz(AP_IMAP_PASSWORD, pInetServer->szPassword,
                ARRAYSIZE(pInetServer->szPassword));
            if (FAILED(hr))
                pInetServer->szPassword[0] = '\0'; // If this is incorrect, we will re-prompt user
            }

        if (FAILED(hr = pAccount->GetPropSz(AP_IMAP_SERVER, pInetServer->szServerName,
            ARRAYSIZE(pInetServer->szServerName))))
            goto exit; // We NEED to have a server name, so fail this function
        Assert(*pInetServer->szServerName);

        // Da port
        if (FAILED(hr = pAccount->GetPropDw(AP_IMAP_PORT, &pInetServer->dwPort)))
            pInetServer->dwPort = 143; // Default port number

        // Convert DWORD to boolean
        Assert(sizeof(pInetServer->fSSL) == sizeof(DWORD));
        hr = pAccount->GetPropDw(AP_IMAP_SSL, (DWORD *)&pInetServer->fSSL);
        if (FAILED(hr))
            pInetServer->fSSL = FALSE; // Default this value

        Assert(sizeof(pInetServer->fTrySicily) == sizeof(DWORD));
        hr = pAccount->GetPropDw(AP_IMAP_USE_SICILY, (DWORD *)&pInetServer->fTrySicily);
        if (FAILED(hr))
            pInetServer->fTrySicily = FALSE; // Default this value

        if (!pInetServer->fTrySicily && fAlwaysPromptPassword)
            pInetServer->dwFlags|=ISF_ALWAYSPROMPTFORPASSWORD;

        // Get the timeout
        hr = pAccount->GetPropDw(AP_IMAP_TIMEOUT, &pInetServer->dwTimeout);
        if (FAILED(hr))
            pInetServer->dwTimeout = 30; // Default this value

        // If we've reached this point, we may have a failed HRESULT, but since we
        // must have defaulted the value, we should return success.
        hr = S_OK;
    }

    // IXP_NNTP
    else if (IXP_NNTP == m_ixptype)
    {
        // Get the server name
        hr = pAccount->GetPropSz(AP_NNTP_SERVER, pInetServer->szServerName, sizeof(pInetServer->szServerName));
        if (FAILED(hr))
        {
            hr = TrapError(IXP_E_INVALID_ACCOUNT);
            goto exit;
        }

        // Password
        if (FAILED(pAccount->GetPropDw(AP_NNTP_PROMPT_PASSWORD, &fAlwaysPromptPassword)) ||
            FALSE == fAlwaysPromptPassword)
            pAccount->GetPropSz(AP_NNTP_PASSWORD, pInetServer->szPassword, sizeof(pInetServer->szPassword));
        
        // SSL
        Assert(sizeof(pInetServer->fSSL) == sizeof(DWORD));
        pAccount->GetPropDw(AP_NNTP_SSL, (DWORD *)&pInetServer->fSSL);

        // Sicily
        Assert(sizeof(pInetServer->fTrySicily) == sizeof(DWORD));
        pAccount->GetPropDw(AP_NNTP_USE_SICILY, (DWORD *)&pInetServer->fTrySicily);

        if (!pInetServer->fTrySicily && fAlwaysPromptPassword)
            pInetServer->dwFlags|=ISF_ALWAYSPROMPTFORPASSWORD;

        // Port
        if (FAILED(pAccount->GetPropDw(AP_NNTP_PORT, &pInetServer->dwPort)))
            pInetServer->dwPort = 119;

        // User Name
        pAccount->GetPropSz(AP_NNTP_USERNAME, pInetServer->szUserName, sizeof(pInetServer->szUserName));

        // Timeout
        pAccount->GetPropDw(AP_NNTP_TIMEOUT, &pInetServer->dwTimeout);
    }

    // Fix timeout
    if (pInetServer->dwTimeout < 30)
        pInetServer->dwTimeout = 30;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CIxpBase::Connect
// --------------------------------------------------------------------------------
STDMETHODIMP CIxpBase::Connect(LPINETSERVER pInetServer, boolean fAuthenticate, boolean fCommandLogging)
{
    // Locals
    HRESULT         hr=S_OK;
    BOOL            fSecureSocket = FALSE;
    BOOL            fConnectTLS = FALSE;
    
    // check params
    if (NULL == pInetServer || FIsEmptyA(pInetServer->szServerName) || pInetServer->dwPort == 0)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // not init
    if (NULL == m_pSocket || NULL == m_pCallback)
    {
        hr = TrapError(IXP_E_NOT_INIT);
        goto exit;
    }

    // busy
    if (IXP_DISCONNECTED != m_status)
    {
        hr = TrapError(IXP_E_ALREADY_CONNECTED);
        goto exit;
    }

    // Initialize Winsock
    CHECKHR(hr = HrInitializeWinsock());

    // invalid sicily params
    if (pInetServer->fTrySicily && !FIsSicilyInstalled())
    {
        hr = TrapError(IXP_E_LOAD_SICILY_FAILED);
        goto exit;
    }

    // Copy Server information
    CopyMemory(&m_rServer, pInetServer, sizeof(INETSERVER));

    // Reset current
    ResetBase();

    // Do we really want to connect to SMTP securely
    if (FALSE != m_rServer.fSSL)
    {
        // Do we want to connect to SMTP via a secure socket?
        fSecureSocket = (0 == (m_rServer.dwFlags & ISF_SSLONSAMEPORT));

        // Do we want to use STARTTLS to get the secure connection?
        fConnectTLS = (0 != (m_rServer.dwFlags & ISF_SSLONSAMEPORT));

        Assert(fSecureSocket != fConnectTLS);
    }
    
    // Get connection info needed to init async socket
    hr = m_pSocket->HrInit(m_rServer.szServerName, m_rServer.dwPort, fSecureSocket, m_rServer.dwTimeout);
    if (FAILED(hr))
    {
        hr = TrapError(IXP_E_SOCKET_INIT_ERROR);
        goto exit;
    }

    // Finding Host Progress
    OnStatus(IXP_FINDINGHOST);

    // Connect to server
    hr = m_pSocket->Connect();
    if (FAILED(hr))
    {
        hr = TrapError(IXP_E_SOCKET_CONNECT_ERROR);
        goto exit;
    }

    // Were busy
    m_fBusy = TRUE;

    // Start WatchDog
    m_pSocket->StartWatchDog();

    // Authenticate
    m_fConnectAuth = fAuthenticate;
    m_fConnectTLS = fConnectTLS;
    m_fCommandLogging = fCommandLogging;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CIxpBase::GetIXPType
// --------------------------------------------------------------------------------
STDMETHODIMP_(IXPTYPE) CIxpBase::GetIXPType(void)
{
    return m_ixptype;
}

// --------------------------------------------------------------------------------
// CIxpBase::OnConnected
// --------------------------------------------------------------------------------
void CIxpBase::OnConnected(void)
{
    OnStatus(IXP_CONNECTED);
}

// --------------------------------------------------------------------------------
// CIxpBase::OnDisconnected
// --------------------------------------------------------------------------------
void CIxpBase::OnDisconnected(void)
{
    LeaveBusy();
    OnStatus(IXP_DISCONNECTED);
}

// --------------------------------------------------------------------------------
// CIxpBase::OnNotify
// --------------------------------------------------------------------------------
void CIxpBase::OnNotify(ASYNCSTATE asOld, ASYNCSTATE asNew, ASYNCEVENT ae)
{
    // Enter Critical Section
    EnterCriticalSection(&m_cs);

    switch(ae)
    {
    // --------------------------------------------------------------------------------
    case AE_LOOKUPDONE:
        if (AS_DISCONNECTED == asNew)
        {
            char szFmt[CCHMAX_STRINGRES];
            char szFailureText[CCHMAX_STRINGRES];

            LoadString(g_hLocRes, idsHostNotFoundFmt, szFmt, ARRAYSIZE(szFmt));
            wnsprintf(szFailureText, ARRAYSIZE(szFailureText), szFmt, m_rServer.szServerName);
            OnError(IXP_E_CANT_FIND_HOST, szFailureText);
            OnDisconnected();
        }
        else
            OnStatus(IXP_CONNECTING);
        break;

    // --------------------------------------------------------------------------------
    case AE_CONNECTDONE:
        if (AS_DISCONNECTED == asNew)
        {
            char szFailureText[CCHMAX_STRINGRES];

            LoadString(g_hLocRes, idsFailedToConnect, szFailureText,
                ARRAYSIZE(szFailureText));
            OnError(IXP_E_FAILED_TO_CONNECT, szFailureText);
            OnDisconnected();
        }
        else if (AS_HANDSHAKING == asNew)
        {
            OnStatus(IXP_SECURING);
        }
        else
            OnConnected();
        break;

    // --------------------------------------------------------------------------------
    case AE_TIMEOUT:
        // Tell the watch dog to take nap
        m_pSocket->StopWatchDog();

        // Provide the client with a change to continue, or abort
        if (m_pCallback && m_pCallback->OnTimeout(&m_rServer.dwTimeout, this) == S_OK)
        {
            // Start the watchdog and wait for normal socket activity
            m_pSocket->StartWatchDog();
        }

        // Otherwise, if we are connected
        else
        {
            // Drop the connection now
            DropConnection();
        }
        break;

    // --------------------------------------------------------------------------------
    case AE_CLOSE:
        if (AS_RECONNECTING != asNew && IXP_AUTHRETRY != m_status)
        {
            if (IXP_DISCONNECTING != m_status && IXP_DISCONNECTED  != m_status)
            {
                char szFailureText[CCHMAX_STRINGRES];

                if (AS_HANDSHAKING == asOld)
                {
                    LoadString(g_hLocRes, idsFailedToConnectSecurely, szFailureText,
                        ARRAYSIZE(szFailureText));
                    OnError(IXP_E_SECURE_CONNECT_FAILED, szFailureText);
                }
                else
                {
                    LoadString(g_hLocRes, idsUnexpectedTermination, szFailureText,
                        ARRAYSIZE(szFailureText));
                    OnError(IXP_E_CONNECTION_DROPPED, szFailureText);
                }
            }
            OnDisconnected();
        }
        break;
    }

    // Leave Critical Section
    LeaveCriticalSection(&m_cs);
}

// ------------------------------------------------------------------------------------
// CIxpBase::HrReadLine
// ------------------------------------------------------------------------------------
HRESULT CIxpBase::HrReadLine(LPSTR *ppszLine, INT *pcbLine, BOOL *pfComplete)
{
    // Locals
    HRESULT hr = E_INVALIDARG;

    // check params
    IxpAssert(ppszLine && pcbLine && pfComplete);
    if (!ppszLine || !pcbLine || !pfComplete)
        goto exit;

    // Init
    *ppszLine = NULL;
    *pcbLine = 0;

    // Read the line
    hr = m_pSocket->ReadLine(ppszLine, pcbLine);

    // Incomplete line - wait for next AE_RECV
    if (IXP_E_INCOMPLETE == hr)
    {
        hr = S_OK;
        *pfComplete = FALSE;
        goto exit;
    }

    // Otherwise, if failure...
    else if (FAILED(hr))
    {
        hr = TrapError(IXP_E_SOCKET_READ_ERROR);
        goto exit;
    }

    // Complete
    *pfComplete = TRUE;

    // Log it
    if (m_pLogFile)
        m_pLogFile->WriteLog(LOGFILE_RX, (*ppszLine));

    // StripCRLF
    StripCRLF((*ppszLine), (ULONG *)pcbLine);

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CIxpBase::HrSendLine
// ------------------------------------------------------------------------------------
HRESULT CIxpBase::HrSendLine(LPSTR pszLine)
{
    // Locals
    HRESULT     hr=S_OK;
    int         iSent;

    // Check Params
    Assert(m_pSocket && pszLine && pszLine[lstrlen(pszLine)-1] == '\n');

    // Reset Last Response
    SafeMemFree(m_pszResponse);
    m_hrResponse = S_OK;
    m_uiResponse = 0;

    // Add Detail
    if (m_fCommandLogging && m_pCallback)
        m_pCallback->OnCommand(CMD_SEND, pszLine, S_OK, this);

    // Log it
    if (m_pLogFile)
        m_pLogFile->WriteLog(LOGFILE_TX, pszLine);

    // Send it
    hr = m_pSocket->SendBytes(pszLine, lstrlen(pszLine), &iSent);
    if (FAILED(hr) && hr != IXP_E_WOULD_BLOCK)
    {
        hr = TrapError(IXP_E_SOCKET_WRITE_ERROR);
        goto exit;
    }

    // Success
    hr = S_OK;

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CIxpBase::HrSendCommand
// ------------------------------------------------------------------------------------
HRESULT CIxpBase::HrSendCommand(LPSTR pszCommand, LPSTR pszParameters, BOOL fDoBusy)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszLine=NULL;

    // check params
    if (NULL == pszCommand)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Busy...
    if (fDoBusy)
    {
        CHECKHR(hr = HrEnterBusy());
    }

    // Allocate if parameters
    if (pszParameters)
    {
        // Allocate Command Line
        DWORD cchSize = (lstrlen(pszCommand) + lstrlen(pszParameters) + 5);
        pszLine = PszAlloc(cchSize);
        if (NULL == pszLine)
        {
            hr = TrapError(E_OUTOFMEMORY);
            goto exit;
        }

        // Make Line
        wnsprintf(pszLine, cchSize, "%s %s\r\n", pszCommand, pszParameters);

        // Send
        CHECKHR(hr = HrSendLine(pszLine));
    }

    // Ohterwise, just send the command
    else
    {
        Assert(pszCommand[lstrlen(pszCommand)-1] == '\n');
        CHECKHR(hr = HrSendLine(pszCommand));
    }

exit:
    // Failure
    if (fDoBusy && FAILED(hr))
        LeaveBusy();

    // Cleanup
    SafeMemFree(pszLine);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}



// --------------------------------------------------------------------------------
// CIxpBase::GetStatus
// --------------------------------------------------------------------------------
STDMETHODIMP CIxpBase::GetStatus(IXPSTATUS *pCurrentStatus)
{
    if (NULL == pCurrentStatus)
        return E_INVALIDARG;

    *pCurrentStatus = m_status;
    return S_OK;
} // GetStatus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\ixpbase.h ===
// --------------------------------------------------------------------------------
// Ixpbase.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __IXPBASE_H
#define __IXPBASE_H

// ------------------------------------------------------------------------------------
// Depends
// ------------------------------------------------------------------------------------
#include "imnxport.h"
#include "asynconn.h"

// --------------------------------------------------------------------------------
// CIxpBase
// --------------------------------------------------------------------------------
class CIxpBase : public IInternetTransport, public IAsyncConnCB, public IAsyncConnPrompt
{

protected:
    BOOL                m_fBusy;          // Are we in the busy state
    IXPSTATUS           m_status;         // Status of the transport
    ULONG               m_cRef;           // Reference Count
    LPSTR               m_pszResponse;    // Last Server Response String
    UINT                m_uiResponse;     // Server Response Error
    HRESULT             m_hrResponse;     // Server Response Error
    ILogFile           *m_pLogFile;       // Logfile Object
    CAsyncConn         *m_pSocket;        // Socket Object
    ITransportCallback *m_pCallback;      // Transport callback object
    INETSERVER          m_rServer;        // Internet Server information
    BOOL                m_fConnectAuth;   // Proceed with user auth
    BOOL                m_fConnectTLS;    // Proceed with TLS encryption
    BOOL                m_fCommandLogging;// Do ITransportCallback::OnCommand
    BOOL                m_fAuthenticated; // Has the user been authenticated successfully...
    IXPTYPE             m_ixptype;        // Transport type
    CRITICAL_SECTION    m_cs;             // Thread Safety

protected:
    HRESULT HrSendLine(LPSTR pszLine);
    HRESULT HrReadLine(LPSTR *ppszLine, INT *pcbLine, BOOL *pfComplete);
    HRESULT HrSendCommand(LPSTR pszCommand, LPSTR pszParameters, BOOL fDoBusy=TRUE);
    HRESULT OnInitNew(LPSTR pszProtocol, LPSTR pszLogFilePath, DWORD dwShareMode, ITransportCallback *pCallback);
    void Reset(void);
    HRESULT HrEnterBusy(void);
    void OnStatus(IXPSTATUS ixpstatus);
    void OnError(HRESULT hrResult, LPSTR pszProblem=NULL);
    void LeaveBusy(void);
    virtual void ResetBase(void) PURE;
    virtual void DoQuit(void) PURE;
    virtual void OnConnected(void);
    virtual void OnDisconnected(void);
    virtual void OnEnterBusy(void) PURE;
    virtual void OnLeaveBusy(void) PURE;

public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CIxpBase(IXPTYPE ixptype);
    virtual ~CIxpBase(void);

    // ----------------------------------------------------------------------------
    // IAsyncConnPrompt methods
    // ----------------------------------------------------------------------------
    int OnPrompt(HRESULT hrError, LPCTSTR pszText, LPCTSTR pszCaption, UINT uType);

    // ----------------------------------------------------------------------------
    // IAsyncConnCB methods
    // ----------------------------------------------------------------------------
    virtual void OnNotify(ASYNCSTATE asOld, ASYNCSTATE asNew, ASYNCEVENT ae);

    // ----------------------------------------------------------------------------
    // IInternetTransport methods
    // ----------------------------------------------------------------------------
    virtual STDMETHODIMP Connect(LPINETSERVER pInetServer, boolean fAuthenticate, boolean fCommandLogging);
    virtual STDMETHODIMP Disconnect(void);
    STDMETHODIMP DropConnection(void);
    STDMETHODIMP IsState(IXPISSTATE isstate);
    STDMETHODIMP GetServerInfo(LPINETSERVER pInetServer);
    STDMETHODIMP_(IXPTYPE) GetIXPType(void);
    STDMETHODIMP InetServerFromAccount(IImnAccount *pAccount, LPINETSERVER pInetServer);
    STDMETHODIMP HandsOffCallback(void);
    STDMETHODIMP GetStatus(IXPSTATUS *pCurrentStatus);
};

#endif // __IXPBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\imap4.h ===
//***************************************************************************
// IMAP4 Protocol Class Header File(CImap4Agent)
// Written by Raymond Cheng, 3/21/96
//
// This class allows its callers to use IMAP4 client commands without concern
// for the actual command syntax and without having to parse the response
// from the IMAP4 server (which may contain information unrelated to the
// original command).
//
// Given a server, this class makes a connection to the IMAP server when it
// is first required, and retains this connection (periodically sending NoOps
// if necessary) until this class is destroyed. Thus, for online usage, this
// class should be retained throughout the entire session with the user. For
// disconnected or offline operation, this class should be retained for only
// as long as it takes to download new mail and synchronize the cache. After
// these operations are complete, this class should be destroyed (which
// closes the connection) before continuing with the user's mail session.
//***************************************************************************

#ifndef __IMAP4Protocol_H
#define __IMAP4Protocol_H



//---------------------------------------------------------------------------
// CImap4Agent Required Includes
//---------------------------------------------------------------------------
#include "imnxport.h"
#include "ASynConn.h"
#include "ixpbase.h"
#include "sicily.h"


//---------------------------------------------------------------------------
// CImap4Agent Forward Declarations
//---------------------------------------------------------------------------
class CImap4Agent;
interface IMimeInternational;


//---------------------------------------------------------------------------
// CImap4Agent Constants and Defines
//---------------------------------------------------------------------------
const int CMDLINE_BUFSIZE = 512; // For command lines sent to IMAP server
const int RESPLINE_BUFSIZE = 2048; // For lines received from IMAP server
const int NUM_TAG_CHARS = 4;

const boolean DONT_USE_UIDS = FALSE;
const boolean USE_UIDS = TRUE;

const BOOL USE_LAST_RESPONSE = TRUE;
const BOOL DONT_USE_LAST_RESPONSE = FALSE;

// IMAP-defined Transaction ID's
const DWORD tidDONT_CARE = 0; // Means that transaction ID is unimportant or unavailable

#define DEFAULT_CBHANDLER NULL // Pass this as a IIMAPCallback ptr if you wish to substitute
                               // the default CB Handler (and make it clear to the reader)
#define MAX_AUTH_TOKENS 32


//---------------------------------------------------------------------------
// CImap4Agent Data Types
//---------------------------------------------------------------------------

// The following are IMAP-specific HRESULTs.
// When this is ready to roll in, these values will be migrated to Errors.h
// Assert(FALSE) (placeholder)
enum IMAP_HRESULT {
    hrIMAP_S_FOUNDLITERAL = 0,
    hrIMAP_S_NOTFOUNDLITERAL,
    hrIMAP_S_QUOTED,
    hrIMAP_S_ATOM,
    hrIMAP_S_NIL_NSTRING
}; // IMAP_HRESULTS


enum IMAP_COMMAND {
    icNO_COMMAND, // This indicates there are no cmds currently in progress
    icLOGIN_COMMAND,
    icCAPABILITY_COMMAND,
    icSELECT_COMMAND,
    icEXAMINE_COMMAND,
    icCREATE_COMMAND,
    icDELETE_COMMAND,
    icRENAME_COMMAND,
    icSUBSCRIBE_COMMAND,
    icUNSUBSCRIBE_COMMAND,
    icLIST_COMMAND,
    icLSUB_COMMAND,
    icAPPEND_COMMAND,
    icCLOSE_COMMAND,
    icEXPUNGE_COMMAND,
    icSEARCH_COMMAND,
    icFETCH_COMMAND,
    icSTORE_COMMAND,
    icCOPY_COMMAND,
    icLOGOUT_COMMAND,
    icNOOP_COMMAND,
    icAUTHENTICATE_COMMAND,
    icSTATUS_COMMAND,
    icIDLE_COMMAND,
    icALL_COMMANDS
}; // IMAP_COMMAND



enum IMAP_RESPONSE_ID {
    irNONE, // This represents an unknown IMAP response
    irOK_RESPONSE,
    irNO_RESPONSE,
    irBAD_RESPONSE,
    irCMD_CONTINUATION,
    irPREAUTH_RESPONSE,
    irBYE_RESPONSE,
    irCAPABILITY_RESPONSE,
    irLIST_RESPONSE,
    irLSUB_RESPONSE,
    irSEARCH_RESPONSE,
    irFLAGS_RESPONSE,
    irEXISTS_RESPONSE,
    irRECENT_RESPONSE,
    irEXPUNGE_RESPONSE,
    irFETCH_RESPONSE,
    irSTATUS_RESPONSE,
    irALERT_RESPONSECODE,
    irPARSE_RESPONSECODE,
    irPERMANENTFLAGS_RESPONSECODE,
    irREADWRITE_RESPONSECODE,
    irREADONLY_RESPONSECODE,
    irTRYCREATE_RESPONSECODE,
    irUIDVALIDITY_RESPONSECODE,
    irUNSEEN_RESPONSECODE
}; // IMAP_RESPONSE_ID



// States of the receiver FSM
enum IMAP_RECV_STATE {
    irsUNINITIALIZED,
    irsNOT_CONNECTED,
    irsSVR_GREETING,
    irsIDLE,
    irsLITERAL,
    irsFETCH_BODY
}; // IMAP_RECV_STATE



enum IMAP_SEND_EVENT {
    iseSEND_COMMAND, // New command is available to be sent. Does nothing right now.
    iseSENDDONE, // Indicates receipt of AE_SENDDONE from CAsyncConn - we can send at will
    iseCMD_CONTINUATION, // Indicates server has given permission to send our literal
    iseUNPAUSE // Indicates that currently paused command may be unpaused
}; // IMAP_SEND_EVENT


enum IMAP_LINEFRAG_TYPE {
    iltLINE,
    iltLITERAL,
    iltRANGELIST,
    iltPAUSE,
    iltSTOP,
    iltLAST
}; // IMAP_LINEFRAG_TYPE



enum IMAP_LITERAL_STORETYPE {
    ilsSTRING,
    ilsSTREAM
}; // IMAP_LITERAL_STORETYPE



enum IMAP_PROTOCOL_STATUS {
    ipsNotConnected,
    ipsConnected,
    ipsAuthorizing,
    ipsAuthorized
}; // IMAP_PROTOCOL_STATUS



// The following is used to track what state the server SHOULD be in
enum SERVERSTATE {ssNotConnected, ssConnecting, ssNonAuthenticated,
    ssAuthenticated, ssSelected};



const DWORD INVALID_UID = 0;


// Holds fragments of a command/response line to/from the IMAP server
typedef struct tagIMAPLineFragment {
    IMAP_LINEFRAG_TYPE iltFragmentType; // We get/send lines and literals to/from IMAP svr
    IMAP_LITERAL_STORETYPE ilsLiteralStoreType; // Literals are stored as strings or streams
    DWORD dwLengthOfFragment;
    union {
        char *pszSource;
        LPSTREAM pstmSource;
        IRangeList *prlRangeList;
    } data;
    struct tagIMAPLineFragment *pilfNextFragment;
    struct tagIMAPLineFragment *pilfPrevFragment; // NB: I DO NOT update this after line is fully constructed
} IMAP_LINE_FRAGMENT;



// Points to first fragment in queue of fragments
typedef struct tagIMAPLineFragmentQueue {
    IMAP_LINE_FRAGMENT *pilfFirstFragment;  // Points to head of queue (this advances during transmission)
    IMAP_LINE_FRAGMENT *pilfLastFragment;   // Points to tail of queue for quick enqueuing
} IMAP_LINEFRAG_QUEUE;
const IMAP_LINEFRAG_QUEUE ImapLinefragQueue_INIT = {NULL, NULL};


enum AUTH_STATE {
    asUNINITIALIZED = 0,
    asWAITFOR_CONTINUE,
    asWAITFOR_CHALLENGE,
    asWAITFOR_AUTHENTICATION,
    asCANCEL_AUTHENTICATION
}; // enum AUTH_STATE

enum AUTH_EVENT {
    aeStartAuthentication = 0,
    aeOK_RESPONSE,
    aeBAD_OR_NO_RESPONSE,
    aeCONTINUE,
    aeABORT_AUTHENTICATION
}; // enum AUTH_EVENT

typedef struct tagAuthStatus {
    AUTH_STATE asCurrentState;
    BOOL fPromptForCredentials;
    int iCurrentAuthToken; // Ordinal (NOT index) of current auth token
    int iNumAuthTokens;    // Num of auth mechanisms advertised by svr (rgpszAuthTokens)
    LPSTR rgpszAuthTokens[MAX_AUTH_TOKENS]; // Array of ptrs to auth mech strings
    SSPICONTEXT rSicInfo;          // Data used for logging onto a sicily server
    LPSSPIPACKAGE pPackages;      // Array of installed security packages
    ULONG cPackages;           // Number of installed security packages (pPackages)
} AUTH_STATUS;


//***************************************************************************
// CIMAPCmdInfo Class:
// This class contains information about an IMAP command, such as a queue
// of line fragments which constitute the actual command, the tag of the
// command, and the transaction ID used to identify the command to the
// CImap4Agent user.
//***************************************************************************
class CIMAPCmdInfo {
public:
    // Constructor, Destructor
    CIMAPCmdInfo(CImap4Agent *pImap4Agent, IMAP_COMMAND icCmd,
        SERVERSTATE ssMinimumStateArg, WPARAM wParamArg,
        LPARAM lParamArg, IIMAPCallback *pCBHandlerArg);
    ~CIMAPCmdInfo(void);

    // Module variables
    IMAP_COMMAND icCommandID; // IMAP command currently in progress
    SERVERSTATE ssMinimumState; // Minimum server state for this cmd
    boolean fUIDRangeList; // TRUE if a UID rangelist is involved, FALSE by default
    char szTag[NUM_TAG_CHARS+1]; // Tag of currently executing command
    IMAP_LINEFRAG_QUEUE *pilqCmdLineQueue;
    WPARAM wParam;  // User-supplied number which identifies this transaction
    LPARAM lParam;  // User-supplied number which identifies this transaction
    IIMAPCallback *pCBHandler; // User-supplied CB handler (NULL means use default CB handler)
    CIMAPCmdInfo *piciNextCommand;

private:
    CImap4Agent *m_pImap4Agent;
}; // CIMAPCmdInfo





//---------------------------------------------------------------------------
// CImap4Agent Class Definition
//---------------------------------------------------------------------------
class CImap4Agent :
    public IIMAPTransport2,
    public CIxpBase
{
    friend CIMAPCmdInfo;

public:
    //***********************************************************************
    // Public Section
    //***********************************************************************
    
    // Constructor/Destructor
    CImap4Agent(void);
    ~CImap4Agent(void);

    HRESULT STDMETHODCALLTYPE SetWindow(void);
    HRESULT STDMETHODCALLTYPE ResetWindow(void);

    // IUnknown Methods
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppvObject);
    ULONG STDMETHODCALLTYPE AddRef(void);
    ULONG STDMETHODCALLTYPE Release(void);

    // IASyncConnCB Method
    void OnNotify(ASYNCSTATE asOld, ASYNCSTATE asNew, ASYNCEVENT ae);

    // Administration Functions
    HRESULT STDMETHODCALLTYPE InitNew(LPSTR pszLogFilePath, IIMAPCallback *pCBHandler);
    HRESULT STDMETHODCALLTYPE HandsOffCallback(void);
    HRESULT STDMETHODCALLTYPE SetDefaultCBHandler(IIMAPCallback *pCBHandler);

    // Utility Functions
    HRESULT STDMETHODCALLTYPE NewIRangeList(IRangeList **pprlNewRangeList);

    // IIMAPTransport functions
    // IMAP Client Commands, in same order of definition as in RFC-1730
    // Not all commands are available, as some commands are used exclusively
    // inside this class and thus need not be exported.
    HRESULT STDMETHODCALLTYPE Capability(DWORD *pdwCapabilityFlags);
    HRESULT STDMETHODCALLTYPE Select(WPARAM wParam, LPARAM lParam,
        IIMAPCallback *pCBHandler, LPSTR lpszMailboxName);
    HRESULT STDMETHODCALLTYPE Examine(WPARAM wParam, LPARAM lParam,
        IIMAPCallback *pCBHandler, LPSTR lpszMailboxName);
    HRESULT STDMETHODCALLTYPE Create(WPARAM wParam, LPARAM lParam,
        IIMAPCallback *pCBHandler, LPSTR lpszMailboxName);
    HRESULT STDMETHODCALLTYPE Delete(WPARAM wParam, LPARAM lParam,
        IIMAPCallback *pCBHandler, LPSTR lpszMailboxName);
    HRESULT STDMETHODCALLTYPE Rename(WPARAM wParam, LPARAM lParam,
        IIMAPCallback *pCBHandler, LPSTR lpszMailboxName, LPSTR lpszNewMailboxName);
    HRESULT STDMETHODCALLTYPE Subscribe(WPARAM wParam, LPARAM lParam,
        IIMAPCallback *pCBHandler, LPSTR lpszMailboxName);
    HRESULT STDMETHODCALLTYPE Unsubscribe(WPARAM wParam, LPARAM lParam,
        IIMAPCallback *pCBHandler, LPSTR lpszMailboxName);

    HRESULT STDMETHODCALLTYPE List(WPARAM wParam, LPARAM lParam, IIMAPCallback *pCBHandler,
        LPSTR lpszMailboxNameReference, LPSTR lpszMailboxNamePattern);
    HRESULT STDMETHODCALLTYPE Lsub(WPARAM wParam, LPARAM lParam, IIMAPCallback *pCBHandler,
        LPSTR lpszMailboxNameReference, LPSTR lpszMailboxNamePattern);
    
    HRESULT STDMETHODCALLTYPE Append(WPARAM wParam, LPARAM lParam, IIMAPCallback *pCBHandler,
        LPSTR lpszMailboxName, LPSTR lpszMessageFlags, FILETIME ftMessageDateTime,
        LPSTREAM lpstmMessageToSave);
    HRESULT STDMETHODCALLTYPE Close(WPARAM wParam, LPARAM lParam, IIMAPCallback *pCBHandler);
    HRESULT STDMETHODCALLTYPE Expunge(WPARAM wParam, LPARAM lParam, IIMAPCallback *pCBHandler);
    
    HRESULT STDMETHODCALLTYPE Search(WPARAM wParam, LPARAM lParam, IIMAPCallback *pCBHandler,
        LPSTR lpszSearchCriteria, boolean bReturnUIDs, IRangeList *pMsgRange,
        boolean bUIDRangeList);    
    HRESULT STDMETHODCALLTYPE Fetch(WPARAM wParam, LPARAM lParam, IIMAPCallback *pCBHandler,
        IRangeList *pMsgRange, boolean bUIDMsgRange, LPSTR lpszFetchArgs);
    HRESULT STDMETHODCALLTYPE Store(WPARAM wParam, LPARAM lParam, IIMAPCallback *pCBHandler,
        IRangeList *pMsgRange, boolean bUIDRangeList, LPSTR lpszStoreArgs);
    HRESULT STDMETHODCALLTYPE Copy(WPARAM wParam, LPARAM lParam, IIMAPCallback *pCBHandler,
        IRangeList *pMsgRange, boolean bUIDRangeList, LPSTR lpszMailboxName);
    HRESULT STDMETHODCALLTYPE Status(WPARAM wParam, LPARAM lParam,
        IIMAPCallback *pCBHandler, LPSTR pszMailboxName, LPSTR pszStatusCmdArgs);
    HRESULT STDMETHODCALLTYPE Noop(WPARAM wParam, LPARAM lParam, IIMAPCallback *pCBHandler);

    DWORD GenerateMsgSet(LPSTR lpszDestination, DWORD dwSizeOfDestination,
        DWORD *pMsgID, DWORD cMsgID);

    // Message Sequence Number to UID member functions - the caller may use
    // these functions to map from MSN's to UID's, if the caller uses UIDs
    // to refer to messages. If the caller uses MSN's, there is no need to
    // invoke the following functions.
    HRESULT STDMETHODCALLTYPE ResizeMsgSeqNumTable(DWORD dwSizeOfMbox);
    HRESULT STDMETHODCALLTYPE UpdateSeqNumToUID(DWORD dwMsgSeqNum, DWORD dwUID);
    HRESULT STDMETHODCALLTYPE RemoveSequenceNum(DWORD dwDeletedMsgSeqNum);
    HRESULT STDMETHODCALLTYPE MsgSeqNumToUID(DWORD dwMsgSeqNum, DWORD *pdwUID);
    HRESULT STDMETHODCALLTYPE GetMsgSeqNumToUIDArray(DWORD **ppdwMsgSeqNumToUIDArray,
        DWORD *pdwNumberOfElements);
    HRESULT STDMETHODCALLTYPE GetHighestMsgSeqNum(DWORD *pdwHighestMSN);
    HRESULT STDMETHODCALLTYPE ResetMsgSeqNumToUID(void);


    // IInternetTransport functions
    HRESULT STDMETHODCALLTYPE GetServerInfo(LPINETSERVER pInetServer);
    IXPTYPE STDMETHODCALLTYPE GetIXPType(void);
    HRESULT STDMETHODCALLTYPE IsState(IXPISSTATE isstate);
    HRESULT STDMETHODCALLTYPE InetServerFromAccount(IImnAccount *pAccount,
        LPINETSERVER pInetServer);
    HRESULT STDMETHODCALLTYPE Connect(LPINETSERVER pInetServer,
        boolean fAuthenticate, boolean fCommandLogging);
    HRESULT STDMETHODCALLTYPE Disconnect(void);
    HRESULT STDMETHODCALLTYPE DropConnection(void);
    HRESULT STDMETHODCALLTYPE GetStatus(IXPSTATUS *pCurrentStatus);

    // IIMAPTransport2 functions
    HRESULT STDMETHODCALLTYPE SetDefaultCP(DWORD dwTranslateFlags, UINT uiCodePage);
    HRESULT STDMETHODCALLTYPE MultiByteToModifiedUTF7(LPCSTR pszSource,
        LPSTR *ppszDestination, UINT uiSourceCP, DWORD dwFlags);
    HRESULT STDMETHODCALLTYPE ModifiedUTF7ToMultiByte(LPCSTR pszSource,
        LPSTR *ppszDestination, UINT uiDestinationCP, DWORD dwFlags);
    HRESULT STDMETHODCALLTYPE SetIdleMode(DWORD dwIdleFlags);
    HRESULT STDMETHODCALLTYPE EnableFetchEx(DWORD dwFetchExFlags);


protected:
    // CIxpBase [pure] virtual functions
    void OnDisconnected(void);
    void ResetBase(void);
    void DoQuit(void);
    void OnEnterBusy(void);
    void OnLeaveBusy(void);



private:
    //***********************************************************************
    // Private Section
    //***********************************************************************



    //---------------------------------------------------------------------------
    // Module Data Types
    //---------------------------------------------------------------------------


    //---------------------------------------------------------------------------
    // Module Variables
    //---------------------------------------------------------------------------
    SERVERSTATE m_ssServerState; // Tracks server state to catch bad usage of module
    DWORD m_dwCapabilityFlags; // Bit-flags indicate capabilities supported by
                               // both us and the server
    char m_szLastResponseText[RESPLINE_BUFSIZE]; // Holds human-readable text of
                                                 // last server response
    LONG m_lRefCount; // Reference count for this module
    IIMAPCallback *m_pCBHandler; // Object containing all callbacks for this class

    IMAP_RECV_STATE m_irsState; // State of receiver FSM
    boolean m_bFreeToSend; // Set to TRUE by send subsystem when hrWouldBlock returned
    boolean m_fIDLE; // Set to TRUE when server has accepted our IDLE command
    IMAP_LINEFRAG_QUEUE m_ilqRecvQueue; // Received fragments placed here until ready to parse

    // Critical Sections: to avoid deadlock, if more than one CS must be entered, enter them
    // in the order listed below. Note that CIxpBase::m_cs should always be entered FIRST.
    CRITICAL_SECTION m_csTag;       // Protects static szCurrentTag var in GenerateCommandTag()
    CRITICAL_SECTION m_csSendQueue; // Protects command send queue
    CRITICAL_SECTION m_csPendingList; // Protects list of pending commands

    IMAP_LINE_FRAGMENT *m_pilfLiteralInProgress; // Literals in progress live here until finished
    DWORD m_dwLiteralInProgressBytesLeft;        // This tells us when we're finished
    FETCH_BODY_PART m_fbpFetchBodyPartInProgress; // Allows us to persist data during body part download
    DWORD m_dwAppendStreamUploaded; // Num bytes already uploaded during APPEND, for progress
    DWORD m_dwAppendStreamTotal; // Size of stream uploaded during APPEND, for progress indication

    boolean m_bCurrentMboxReadOnly; // For debugging purposes (verify proper access requests)

    CIMAPCmdInfo *m_piciSendQueue; // Queue of commands waiting to be sent
    CIMAPCmdInfo *m_piciPendingList; // List of commands pending server response
    CIMAPCmdInfo *m_piciCmdInSending; // The command in m_piciSendQueue currently being sent to server

    IMimeInternational *m_pInternational; // MIME object for international conversions
    DWORD m_dwTranslateMboxFlags;
    UINT m_uiDefaultCP;
    AUTH_STATUS m_asAuthStatus;

    // Message Sequence Number to UID mapping variables
    DWORD *m_pdwMsgSeqNumToUID;
    DWORD m_dwSizeOfMsgSeqNumToUID;
    DWORD m_dwHighestMsgSeqNum;

    DWORD m_dwFetchFlags;


    //---------------------------------------------------------------------------
    // Internal Module Functions
    //---------------------------------------------------------------------------

    // IMAP Response-Parsing Functions
    HRESULT ParseSvrResponseLine (IMAP_LINE_FRAGMENT **ppilfLine,
        boolean *lpbTaggedResponse, LPSTR lpszTagFromSvr,
        IMAP_RESPONSE_ID *pirParseResult);
    HRESULT ParseStatusResponse (LPSTR lpszStatusResponseLine,
        IMAP_RESPONSE_ID *pirParseResult);
    HRESULT ParseResponseCode(LPSTR lpszResponseCode);
    HRESULT ParseSvrMboxResponse (IMAP_LINE_FRAGMENT **ppilfLine,
        LPSTR lpszSvrMboxResponseLine, IMAP_RESPONSE_ID *pirParseResult);
    HRESULT ParseMsgStatusResponse (IMAP_LINE_FRAGMENT **ppilfLine,
        LPSTR lpszMsgResponseLine, IMAP_RESPONSE_ID *pirParseResult);
    HRESULT ParseListLsubResponse(IMAP_LINE_FRAGMENT **ppilfLine,
        LPSTR lpszListResponse, IMAP_RESPONSE_ID irListLsubID);
    IMAP_MBOXFLAGS ParseMboxFlag(LPSTR lpszFlagToken);
    HRESULT ParseFetchResponse (IMAP_LINE_FRAGMENT **ppilfLine,
        DWORD dwMsgSeqNum, LPSTR lpszFetchResp);
    HRESULT ParseSearchResponse(LPSTR lpszSearchResponse);
    HRESULT ParseMsgFlagList(LPSTR lpszStartOfFlagList,
        IMAP_MSGFLAGS *lpmfMsgFlags, LPDWORD lpdwNumBytesRead);
    void parseCapability (LPSTR lpszCapabilityToken);
    void AddAuthMechanism(LPSTR pszAuthMechanism);
    HRESULT ParseMboxStatusResponse(IMAP_LINE_FRAGMENT **ppilfLine, LPSTR pszStatusResponse);
    HRESULT ParseEnvelope(FETCH_CMD_RESULTS_EX *pEnvResults, IMAP_LINE_FRAGMENT **ppilfLine,
        LPSTR *ppCurrent);
    HRESULT ParseIMAPAddresses(IMAPADDR **ppiaResults, IMAP_LINE_FRAGMENT **ppilfLine,
        LPSTR *ppCurrent);
    void DowngradeFetchResponse(FETCH_CMD_RESULTS *pfcrOldFetchStruct,
        FETCH_CMD_RESULTS_EX *pfcreNewFetchStruct);


    // IMAP String-Conversion Functions
    HRESULT QuotedToString(LPSTR *ppszDestinationBuf, LPDWORD pdwSizeOfDestination,
        LPSTR *ppCurrentSrcPos);
    HRESULT AStringToString(IMAP_LINE_FRAGMENT **ppilfLine,
        LPSTR *ppszDestination, LPDWORD pdwSizeOfDestination, LPSTR *ppCurrentSrcPos);
    inline boolean isTEXT_CHAR(char c);
    inline boolean isATOM_CHAR(char c);
    HRESULT NStringToString(IMAP_LINE_FRAGMENT **ppilfLine,
        LPSTR *ppszDestination, LPDWORD pdwLengthOfDestination, LPSTR *ppCurrentSrcPos);
    HRESULT NStringToStream(IMAP_LINE_FRAGMENT **ppilfLine,
        LPSTREAM *ppstmResult, LPSTR *ppCurrentSrcPos);
    HRESULT AppendSendAString(CIMAPCmdInfo *piciCommand, LPSTR lpszCommandLine,
        LPSTR *ppCmdLinePos, DWORD dwSizeOfCommandLine, LPCSTR lpszSource,
        BOOL fPrependSpace = TRUE);
    HRESULT StringToQuoted(LPSTR lpszDestination, LPCSTR lpszSource,
        DWORD dwSizeOfDestination, LPDWORD lpdwNumCharsWritten);
    inline boolean isPrintableUSASCII(BOOL fUnicode, LPCSTR pszIn);
    inline boolean isIMAPModifiedBase64(const char c);
    inline boolean isEqualUSASCII(BOOL fUnicode, LPCSTR pszIn, const char c);
    inline void SetUSASCIIChar(BOOL fUnicode, LPSTR pszOut, char cUSASCII);
    HRESULT NonUSStringToModifiedUTF7(UINT uiCurrentACP, LPCSTR pszStartOfNonUSASCII,
        int iLengthOfNonUSASCII, LPSTR *ppszOut, LPINT piNumCharsWritten);
    HRESULT UnicodeToUSASCII(LPSTR *ppszUSASCII, LPCWSTR pwszUnicode,
        DWORD dwSrcLenInBytes, LPDWORD pdwUSASCIILen);
    HRESULT ASCIIToUnicode(LPWSTR *ppwszUnicode, LPCSTR pszASCII, DWORD dwSrcLen);
    HRESULT _MultiByteToModifiedUTF7(LPCSTR pszSource, LPSTR *ppszDestination);
    HRESULT _ModifiedUTF7ToMultiByte(LPCSTR pszSource, LPSTR *ppszDestination);
    HRESULT ConvertString(UINT uiSourceCP, UINT uiDestCP, LPCSTR pszSource, int *piSrcLen,
        LPSTR *ppszDest, int *piDestLen, int iOutputExtra);
    HRESULT HandleFailedTranslation(BOOL fUnicode, BOOL fToUTF7, LPCSTR pszSource, LPSTR *ppszDest);

    // IMAP Command Construction Function
    void GenerateCommandTag(LPSTR lpszTag);
    HRESULT OneArgCommand(LPCSTR lpszCommandVerb, LPSTR lpszMboxName,
        IMAP_COMMAND icCommandID, WPARAM wParam, LPARAM lParam,
        IIMAPCallback *pCBHandler);
    HRESULT NoArgCommand(LPCSTR lpszCommandVerb, IMAP_COMMAND icCommandID,
        SERVERSTATE ssMinimumState, WPARAM wParam, LPARAM lParam,
        IIMAPCallback *pCBHandler);
    HRESULT TwoArgCommand(LPCSTR lpszCommandVerb, LPCSTR lpszFirstArg,
        LPCSTR lpszSecondArg, IMAP_COMMAND icCommandID,
        SERVERSTATE ssMinimumState, WPARAM wParam, LPARAM lParam,
        IIMAPCallback *pCBHandler);
    HRESULT RangedCommand(LPCSTR lpszCommandVerb, boolean bUIDPrefix,
        IRangeList *pMsgRange, boolean bUIDRangeList, boolean bAStringCmdArgs,
        LPSTR lpszCmdArgs, IMAP_COMMAND icCommandID, WPARAM wParam, LPARAM lParam,
        IIMAPCallback *pCBHandler);
    HRESULT TwoMailboxCommand(LPCSTR lpszCommandVerb, LPSTR lpszFirstMbox,
        LPSTR lpszSecondMbox, IMAP_COMMAND icCommandID, SERVERSTATE ssMinimumState,
        WPARAM wParam, LPARAM lParam, IIMAPCallback *pCBHandler);
    void AppendMsgRange(LPSTR *ppDest, const DWORD cchSizeDest, const DWORD idStartOfRange,
        const DWORD idEndOfRange, boolean bSuppressComma);
    void EnterIdleMode(void);


    // IMAP Fragment Manipulation Functions
    void EnqueueFragment(IMAP_LINE_FRAGMENT *pilfSourceFragment,
        IMAP_LINEFRAG_QUEUE *pilqLineFragQueue);
    void InsertFragmentBeforePause(IMAP_LINE_FRAGMENT *pilfSourceFragment,
        IMAP_LINEFRAG_QUEUE *pilqLineFragQueue);
    IMAP_LINE_FRAGMENT *DequeueFragment(IMAP_LINEFRAG_QUEUE *pilqLineFraqQueue);
    boolean NextFragmentIsLiteral(IMAP_LINEFRAG_QUEUE *pilqLineFragQueue);
    void FreeFragment(IMAP_LINE_FRAGMENT **ppilfFragment);


    // IMAP Receiver Functions
    void AddPendingCommand(CIMAPCmdInfo *piciNewCommand);
    CIMAPCmdInfo *RemovePendingCommand(LPSTR pszTag);
    WORD FindTransactionID (WPARAM *pwParam, LPARAM *plParam,
        IIMAPCallback **ppCBHandler, IMAP_COMMAND icTarget1,
        IMAP_COMMAND icTarget2 = icNO_COMMAND);
    void ProcessServerGreeting(char *pszResponseLine, DWORD dwNumBytesReceived);
    void OnCommandCompletion(LPSTR szTag, HRESULT hrCompletionResult,
        IMAP_RESPONSE_ID irCompletionResponse);
    void CheckForCompleteResponse(LPSTR pszResponseLine, DWORD dwNumBytesRead,
        IMAP_RESPONSE_ID *pirParseResult);
    void AddBytesToLiteral(LPSTR pszResponseBuf, DWORD dwNumBytesRead);
    HRESULT ProcessResponseLine(void);
    void GetTransactionID(WPARAM *pwParam, LPARAM *plParam,
        IIMAPCallback **ppCBHandler, IMAP_RESPONSE_ID irResponseType);
    HRESULT PrepareForLiteral(DWORD dwSizeOfLiteral);
    void PrepareForFetchBody(DWORD dwMsgSeqNum, DWORD dwSizeOfLiteral, LPSTR pszBodyTag);
    BOOL isFetchResponse(IMAP_LINEFRAG_QUEUE *pilqCurrentResponse, LPDWORD pdwMsgSeqNum);
    BOOL isFetchBodyLiteral(IMAP_LINE_FRAGMENT *pilfCurrent, LPSTR pszStartOfLiteralSize,
        LPSTR *ppszBodyTag);
    void DispatchFetchBodyPart(LPSTR pszResponseBuf, DWORD dwNumBytesRead,
        BOOL fFreeBodyTagAtEnd);
    void UploadStreamProgress(DWORD dwBytesUploaded);

    
    // IMAP Authentication Functions
    HRESULT GetAccountInfo(void);
    void LoginUser(void);
    void ReLoginUser(void);
    void AuthenticateUser(AUTH_EVENT aeEvent, LPSTR pszServerData, DWORD dwSizeOfData);
    HRESULT TryAuthMethod(BOOL fNextAuthMethod, UINT *puiFailureTextID);
    HRESULT CancelAuthentication(void);
    void FreeAuthStatus(void);

    // IMAP Send Functions
    CIMAPCmdInfo *DequeueCommand(void);
    void ProcessSendQueue(IMAP_SEND_EVENT iseEvent);
    HRESULT SendCmdLine(CIMAPCmdInfo *piciCommand, DWORD dwFlags,
        LPCSTR lpszCommandText, DWORD dwCmdLineLength);
    HRESULT SendLiteral(CIMAPCmdInfo *piciCommand, LPSTREAM pstmLiteral,
        DWORD dwSizeOfStream);
    HRESULT SendRangelist(CIMAPCmdInfo *piciCommand, IRangeList *pRangeList,
        boolean bUIDRangeList);
    HRESULT SendPause(CIMAPCmdInfo *piciCommand);
    HRESULT SendStop(CIMAPCmdInfo *piciCommand);
    HRESULT SubmitIMAPCommand(CIMAPCmdInfo *picfCommand);
    void GetNextCmdToSend(void);
    boolean isValidNonWaitingCmdSequence(void);
    boolean CanStreamCommand(IMAP_COMMAND icCommandID);
    void CompressCommand(CIMAPCmdInfo *pici);


    // Miscellaneous Helper Functions
    void OnIMAPError(HRESULT hrResult, LPSTR pszFailureText,
        BOOL bIncludeLastResponse, LPSTR pszDetails = NULL);
    void FreeAllData(HRESULT hrTerminatedCmdResult);
    void OnIMAPResponse(IIMAPCallback *pCBHandler, IMAP_RESPONSE *pirIMAPResponse);
    void FreeFetchResponse(FETCH_CMD_RESULTS_EX *pcreFreeMe);
    void FreeIMAPAddresses(IMAPADDR *piaFreeMe);

}; // CIMAP4 Class


#endif // #ifdef __IMAP4Protocol_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\imap4.cpp ===
//***************************************************************************
// IMAP4 Protocol Class Implementation (CImap4Agent)
// Written by Raymond Cheng, 3/21/96
//
// This class allows its callers to use IMAP4 client commands without having
// to parse incidental responses from the IMAP4 server (which may contain
// information unrelated to the original command). For instance, during a
// SEARCH command, the IMAP server may issue EXISTS and RECENT responses to
// indicate the arrival of new mail.
//
// The user of this class first creates a connection by calling
// Connect. It is the caller's responsibility to ensure that the
// connection is not severed due to inactivity (autologout). The caller
// can guard against this by periodically sending Noop's.
//***************************************************************************

//---------------------------------------------------------------------------
// Includes
//---------------------------------------------------------------------------
#include "pch.hxx"
#include <iert.h>
#include "IMAP4.h"
#include "range.h"
#include "dllmain.h"
#include "resource.h"
#include "mimeole.h"
#include <shlwapi.h>
#include "strconst.h"
#include "demand.h"

// I chose the IInternetTransport from IIMAPTransport instead
// of CIxpBase, because I override some of CIxpBase's IInternetTransport
// implementations, and I want CImap4Agent's versions to take priority.
#define THIS_IInternetTransport ((IInternetTransport *) (IIMAPTransport *) this)


//---------------------------------------------------------------------------
// Module Constants
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
// Module Constants
//---------------------------------------------------------------------------
// *** Stolen from msgout.cpp! Find out how we can SHARE ***
// Assert(FALSE); // Placeholder
// The following is used to allow us to output dates in IMAP-compliant fashion
static LPSTR lpszMonthsOfTheYear[] =
{
    "Filler",
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" 
};


const int TAG_BUFSIZE = NUM_TAG_CHARS + 1;
const int MAX_RESOURCESTRING = 512;


// IMAP Stuff
const char cCOMMAND_CONTINUATION_PREFIX = '+';
const char cUNTAGGED_RESPONSE_PREFIX = '*';
const char cSPACE = ' ';

const char c_szIMAP_MSG_ANSWERED[] = "Answered";
const char c_szIMAP_MSG_FLAGGED[] = "Flagged";
const char c_szIMAP_MSG_DELETED[] = "Deleted";
const char c_szIMAP_MSG_DRAFT[] = "Draft";
const char c_szIMAP_MSG_SEEN[] = "Seen";

const char c_szDONE[] = "DONE\r\n";


// *** Unless you can guarantee that g_szSPACE and c_szCRLF stay
// *** US-ASCII, I'll use these. Assert(FALSE); (placeholder)
// const char c_szCRLF[] = "\r\n";
// const char g_szSpace[] = " ";

const boolean TAGGED = TRUE;
const boolean UNTAGGED = FALSE;
const BOOL fFREE_BODY_TAG = TRUE;
const BOOL fDONT_FREE_BODY_TAG = FALSE;
const BOOL tamNEXT_AUTH_METHOD = TRUE;
const BOOL tamCURRENT_AUTH_METHOD = FALSE;
const BOOL rcASTRING_ARG = TRUE;
const BOOL rcNOT_ASTRING_ARG = FALSE;

// For use with SendCmdLine
const DWORD sclAPPEND_TO_END        = 0x00000000; // This option happens by default
const DWORD sclINSERT_BEFORE_PAUSE  = 0x00000001;
const DWORD sclAPPEND_CRLF          = 0x00000002;

const DWORD dwLITERAL_THRESHOLD = 128; // On the conservative side

const MBOX_MSGCOUNT mcMsgCount_INIT = {FALSE, 0L, FALSE, 0L, FALSE, 0L};
const FETCH_BODY_PART FetchBodyPart_INIT = {0, NULL, 0, 0, 0, FALSE, NULL, 0, 0};
const AUTH_STATUS AuthStatus_INIT = {asUNINITIALIZED, FALSE, 0, 0, {0}, {0}, NULL, 0};


//---------------------------------------------------------------------------
// Functions
//---------------------------------------------------------------------------


//***************************************************************************
// Function: CImap4Agent (Constructor)
//***************************************************************************
CImap4Agent::CImap4Agent (void) : CIxpBase(IXP_IMAP)
{
    DOUT("CImap4Agent - CONSTRUCTOR");
    
    // Initialize module variables
    m_ssServerState = ssNotConnected;
    m_dwCapabilityFlags = 0;
    *m_szLastResponseText = '\0';
    DllAddRef();
    m_lRefCount = 1;
    m_pCBHandler = NULL;
    m_irsState = irsUNINITIALIZED;
    m_bFreeToSend = TRUE;
    m_fIDLE = FALSE;
    m_ilqRecvQueue = ImapLinefragQueue_INIT;

    InitializeCriticalSection(&m_csTag);
    InitializeCriticalSection(&m_csSendQueue);
    InitializeCriticalSection(&m_csPendingList);

    m_pilfLiteralInProgress = NULL;
    m_dwLiteralInProgressBytesLeft = 0;
    m_fbpFetchBodyPartInProgress = FetchBodyPart_INIT;
    m_dwAppendStreamUploaded = 0;
    m_dwAppendStreamTotal = 0;

    m_bCurrentMboxReadOnly = TRUE;

    m_piciSendQueue = NULL;
    m_piciPendingList = NULL;
    m_piciCmdInSending = NULL;

    m_pInternational = NULL;
    m_dwTranslateMboxFlags = IMAP_MBOXXLATE_DEFAULT;
    m_uiDefaultCP = GetACP(); // Must be default CP because we shipped like this
    m_asAuthStatus = AuthStatus_INIT;

    m_pdwMsgSeqNumToUID = NULL;
    m_dwSizeOfMsgSeqNumToUID = 0;
    m_dwHighestMsgSeqNum = 0;

    m_dwFetchFlags = 0;
} // CImap4Agent



//***************************************************************************
// Function: ~CImap4Agent (Destructor)
//***************************************************************************
CImap4Agent::~CImap4Agent(void)
{
    DOUT("CImap4Agent - DESTRUCTOR");

    Assert(0 == m_lRefCount);

    DropConnection(); // Ignore return result, since there's nothing we can do
    FreeAllData(E_FAIL); // General failure result, if cmds pending while destructor invoked

    DeleteCriticalSection(&m_csTag);
    DeleteCriticalSection(&m_csSendQueue);
    DeleteCriticalSection(&m_csPendingList);

    if (NULL != m_pInternational)
        m_pInternational->Release();

    if (NULL != m_pCBHandler)
        m_pCBHandler->Release();

    DllRelease();
} // ~CImap4Agent



//***************************************************************************
// Function: QueryInterface
//
// Purpose:
//   Read the Win32SDK OLE Programming References (Interfaces) about the
// IUnknown::QueryInterface function for details. This function returns a
// pointer to the requested interface.
//
// Arguments:
//   REFIID iid [in] - an IID identifying the interface to return.
//   void **ppvObject [out] - if successful, this function returns a pointer
//     to the requested interface in this argument.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::QueryInterface(REFIID iid, void **ppvObject)
{
    HRESULT hrResult;

    Assert(m_lRefCount > 0);
    Assert(NULL != ppvObject);

    // Init variables, check the arguments
    hrResult = E_NOINTERFACE;
    if (NULL == ppvObject) {
        hrResult = E_INVALIDARG;
        goto exit;
    }

    *ppvObject = NULL;

    // Find a ptr to the interface
    if (IID_IUnknown == iid) {
        // Choose the IIMAPTransport path to IUnknown over the other 3 paths
        // (all through CIxpBase) because this guarantees that CImap4Agent
        // provides the IUnknown implementation.
        *ppvObject = (IUnknown *) (IIMAPTransport *) this;
        ((IUnknown *) (IIMAPTransport *) this)->AddRef();
    }

    if (IID_IInternetTransport == iid) {
        *ppvObject = THIS_IInternetTransport;
        (THIS_IInternetTransport)->AddRef();
    }

    if (IID_IIMAPTransport == iid) {
        *ppvObject = (IIMAPTransport *) this;
        ((IIMAPTransport *) this)->AddRef();
    }

    if (IID_IIMAPTransport2 == iid) {
        *ppvObject = (IIMAPTransport2 *) this;
        ((IIMAPTransport2 *) this)->AddRef();
    }

    // Return success if we managed to snag an interface
    if (NULL != *ppvObject)
        hrResult = S_OK;

exit:
    return hrResult;
} // QueryInterface



//***************************************************************************
// Function: AddRef
//
// Purpose:
//   This function should be called whenever someone makes a copy of a
// pointer to this object. It bumps the reference count so that we know
// there is one more pointer to this object, and thus we need one more
// release before we delete ourselves.
//
// Returns:
//   A ULONG representing the current reference count. Although technically
// our reference count is signed, we should never return a negative number,
// anyways.
//***************************************************************************
ULONG STDMETHODCALLTYPE CImap4Agent::AddRef(void)
{
    Assert(m_lRefCount > 0);

    m_lRefCount += 1;

    DOUT ("CImap4Agent::AddRef, returned Ref Count=%ld", m_lRefCount);
    return m_lRefCount;
} // AddRef



//***************************************************************************
// Function: Release
//
// Purpose:
//   This function should be called when a pointer to this object is to
// go out of commission. It knocks the reference count down by one, and
// automatically deletes the object if we see that nobody has a pointer
// to this object.
//
// Returns:
//   A ULONG representing the current reference count. Although technically
// our reference count is signed, we should never return a negative number,
// anyways.
//***************************************************************************
ULONG STDMETHODCALLTYPE CImap4Agent::Release(void)
{
    Assert(m_lRefCount > 0);
    
    m_lRefCount -= 1;
    DOUT("CImap4Agent::Release, returned Ref Count = %ld", m_lRefCount);

    if (0 == m_lRefCount) {
        delete this;
        return 0;
    }
    else
        return m_lRefCount;
} // Release



//***************************************************************************
// Function: InitNew
//
// Purpose:
//   This function initializes the CImap4Agent class. This function
// must be the next function called after instantiating the CImap4Agent class.
//
// Arguments:
//   LPSTR pszLogFilePath [in] - path to a log file (where all input and
//     output is logged), if the caller wishes to log IMAP transactions.
//   IIMAPCallback *pCBHandler [in] - pointer to a IIMAPCallback object.
//     This object allows the CImap4Agent class to report all IMAP response
//     results to its user.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::InitNew(LPSTR pszLogFilePath, IIMAPCallback *pCBHandler)
{
    HRESULT hrResult;

    Assert(m_lRefCount > 0);
    Assert(ssNotConnected == m_ssServerState);
    Assert(irsUNINITIALIZED == m_irsState);

    Assert(NULL != pCBHandler);

    pCBHandler->AddRef();
    m_pCBHandler = pCBHandler;
    m_irsState = irsNOT_CONNECTED;

    hrResult = MimeOleGetInternat(&m_pInternational);
    if (FAILED(hrResult))
        return hrResult;

    return CIxpBase::OnInitNew("IMAP", pszLogFilePath, FILE_SHARE_READ,
        (ITransportCallback *)pCBHandler);
} // InitNew



//***************************************************************************
// Function: SetDefaultCBHandler
//
// Purpose: This function changes the current default IIMAPCallback handler
//   to the given one.
//
// Arguments:
//   IIMAPCallback *pCBHandler [in] - a pointer to the new callback handler.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::SetDefaultCBHandler(IIMAPCallback *pCBHandler)
{
    Assert(NULL != pCBHandler);
    if (NULL == pCBHandler)
        return E_INVALIDARG;

    if (NULL != m_pCBHandler)
        m_pCBHandler->Release();

    if (NULL != m_pCallback)
        m_pCallback->Release();

    m_pCBHandler = pCBHandler;
    m_pCBHandler->AddRef();
    m_pCallback = pCBHandler;
    m_pCallback->AddRef();
    return S_OK;
} // SetDefaultCBHandler



//***************************************************************************
// Function: SetWindow
//
// Purpose:
//   This function creates the current window handle for async winsock process.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::SetWindow(void)
{
    Assert(NULL != m_pSocket);
    return m_pSocket->SetWindow();
} // SetWindow



//***************************************************************************
// Function: ResetWindow
//
// Purpose:
//   This function closes the current window handle for async winsock process.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::ResetWindow(void)
{
    Assert(NULL != m_pSocket);
    return m_pSocket->ResetWindow();
} // ResetWindow



//***************************************************************************
// Function: Connect
//
// Purpose:
//   This function is called to establish a connection with the IMAP server,
// get its capabilities, and to authenticate the user.
//
// Arguments:
//   See explanation in imnxport.idl.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Connect(LPINETSERVER pInetServer,
                                               boolean fAuthenticate,
                                               boolean fCommandLogging)
{
    HRESULT hrResult;

    Assert(m_lRefCount > 0);
    Assert(ssAuthenticated > m_ssServerState);
    Assert(irsUNINITIALIZED < m_irsState);

    // We do not accept all combinations of argument: the caller cannot
    // perform his own authentication, and thus we MUST be responsible for
    // this. Even if PREAUTH is expected, we expect fAuthenticate to be TRUE.
    if (FALSE == fAuthenticate) {
        AssertSz(FALSE, "Current IIMAPTransport interface requires that fAuthenticate be TRUE.");
        return E_FAIL;
    }

    // Neither can we call the OnCommand callback
    if (fCommandLogging) {
        AssertSz(FALSE, "Current IIMAPTransport interface requires that fCommandLogging be FALSE.");
        return E_FAIL;
    }

    // Does user want us to always prompt for his password? Prompt him here to avoid
    // inactivity timeouts while the prompt is up. Do not prompt if password supplied.
    if (ISFLAGSET(pInetServer->dwFlags, ISF_ALWAYSPROMPTFORPASSWORD) &&
        '\0' == pInetServer->szPassword[0]) {
        if (NULL != m_pCallback)
            hrResult = m_pCallback->OnLogonPrompt(pInetServer, THIS_IInternetTransport);

        if (NULL == m_pCallback || S_OK != hrResult)
            return IXP_E_USER_CANCEL;
    }

    // If we reach this point, we need to establish a connection to IMAP server
    Assert(ssNotConnected == m_ssServerState);
    Assert(irsNOT_CONNECTED == m_irsState);

    hrResult = CIxpBase::Connect(pInetServer, fAuthenticate, fCommandLogging);
    if (SUCCEEDED(hrResult)) {
        m_irsState = irsSVR_GREETING;
        m_ssServerState = ssConnecting;
    }

    return hrResult;
} // Connect



//***************************************************************************
// Function: ReLoginUser
//
// Purpose:
//   This function is called to re-attempt user authentication after a
// failed attempt. It calls ITransportCallback::OnLogonPrompt to allow
// the user to provide the correct logon information.
//***************************************************************************
void CImap4Agent::ReLoginUser(void)
{
    HRESULT hrResult;
    char szFailureText[MAX_RESOURCESTRING];

    AssertSz(FALSE == m_fBusy, "We should not be expecting any server responses here!");

    if (NULL == m_pCallback) {
        // We can't do a damned thing, drop connection (this can happen due to HandsOffCallback)
        DropConnection();
        return;
    }

    // Init variables
    szFailureText[0] = '\0';

    // First, put us in IXP_AUTHRETRY mode so that OnStatus is not called
    // for changes to the connection status
    OnStatus(IXP_AUTHRETRY);

    // OK, connection status is no longer being reported to the user
    // Ask the user for his stinking password
    hrResult = m_pCallback->OnLogonPrompt(&m_rServer, THIS_IInternetTransport);
    if (FAILED(hrResult) || S_FALSE == hrResult) {
        AssertSz(SUCCEEDED(hrResult), "OnLogonPrompt is supposed to return S_OK or S_FALSE!");

        DropConnection();
        goto exit;
    }

    // If we've reached this point, user hit the "OK" button
    // Check if we're still connected to the IMAP server
    if (irsNOT_CONNECTED < m_irsState) {
        // Still connected! Just try to authenticate
        LoginUser();
    }
    else {
        // Connect to server. We'll authenticate after connection established
        hrResult = Connect(&m_rServer, (boolean) !!m_fConnectAuth, (boolean) !!m_fCommandLogging);
        if (FAILED(hrResult))
            LoadString(g_hLocRes, idsConnectError, szFailureText,
                ARRAYSIZE(szFailureText));
    }

exit:
    if (FAILED(hrResult)) {
        // Terminate login procedure and notify user
        OnIMAPError(hrResult, szFailureText, DONT_USE_LAST_RESPONSE);
    }
} // ReLoginUser



//***************************************************************************
// Function: Disconnect
//
// Purpose:
//    This function issues a LOGOUT command to the IMAP server and waits for
// the server to process the LOGOUT command before dropping the connection.
// This allows any currently executing commands to complete their execution.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Disconnect(void)
{
    return CIxpBase::Disconnect();
} // Disconnect



//***************************************************************************
// Function: DropConnection
//
// Purpose:
//   This function issues a LOGOUT command to the IMAP server (if we
// currently have nothing in the send queue), then drops the connection
// before logout command completes.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::DropConnection(void)
{
    Assert(m_lRefCount >= 0); // This function is called during destruction

    // You have to be connected to send a LOGOUT: ignore authorization states
    if (IXP_CONNECTED != m_status)
        goto exit; // Just close the CAsyncConn class

    // We send a logout command IF WE CAN, just as a courtesy. Our main goal
    // is to drop the connection, NOW.

    // If no commands in our send queue, send Logout command. Note that this
    // is no guarantee that CASyncConn is idle, but at least there's a chance
    if (NULL == m_piciCmdInSending ||
        (m_fIDLE && icIDLE_COMMAND == m_piciCmdInSending->icCommandID &&
        iltPAUSE == m_piciCmdInSending->pilqCmdLineQueue->pilfFirstFragment->iltFragmentType)) {
        HRESULT hrLogoutResult;
        const char cszLogoutCmd[] = "ZZZZ LOGOUT\r\n";
        char sz[ARRAYSIZE(cszLogoutCmd) + ARRAYSIZE(c_szDONE)]; // Bigger than I need, but who cares
        int iNumBytesSent, iStrLen;

        // Construct logout or done+logout string
        if (m_fIDLE)
        {
            StrCpyN(sz, c_szDONE, ARRAYSIZE(sz));
            StrCpyN(sz + ARRAYSIZE(c_szDONE) - 1, cszLogoutCmd, (ARRAYSIZE(sz) - ARRAYSIZE(c_szDONE) + 1));
            iStrLen = ARRAYSIZE(c_szDONE) + ARRAYSIZE(cszLogoutCmd) - 2;
        }
        else
        {
            StrCpyN(sz, cszLogoutCmd, ARRAYSIZE(sz));
            iStrLen = ARRAYSIZE(cszLogoutCmd) - 1;
        }
        Assert(iStrLen == lstrlen(sz));

        hrLogoutResult = m_pSocket->SendBytes(sz, iStrLen, &iNumBytesSent);
        Assert(SUCCEEDED(hrLogoutResult));
        Assert(iNumBytesSent == iStrLen);
        if (m_pLogFile)
            m_pLogFile->WriteLog(LOGFILE_TX, "Dropping connection, LOGOUT sent");
    }
    else {
        if (m_pLogFile)
            m_pLogFile->WriteLog(LOGFILE_TX, "Dropping connection, LOGOUT not sent");
    } // else

exit:
    // Drop our connection, with status indication
    return CIxpBase::DropConnection();
} // DropConnection



//***************************************************************************
// Function: ProcessServerGreeting
//
// Purpose:
//   This function is invoked when the receiver state machine is in
// irsSVR_GREETING and a response line is received from the server. This
// function takes a server greeting line (issued immediately when a
// connection is established with the IMAP server) and parses it to
// determine if: a) We are pre-authorized, and therefore do not need to
// login, b) We have been refused the connection, or c) We must login.
//
// Arguments:
//   char *pszResponseLine [in] - the server greeting issued upon connection.
//   DWORD dwNumBytesReceived [in] - length of pszResponseLine string.
//***************************************************************************
void CImap4Agent::ProcessServerGreeting(char *pszResponseLine,
                                        DWORD dwNumBytesReceived)
{
    HRESULT hrResult;
    IMAP_RESPONSE_ID irResult;
    char szFailureText[MAX_RESOURCESTRING];
    BOOL bUseLastResponse;
    
    Assert(m_lRefCount > 0);
    Assert(NULL != pszResponseLine);

    // Initialize variables
    szFailureText[0] = '\0';
    hrResult = E_FAIL;
    bUseLastResponse = FALSE;

    // Whatever happens next, we no longer expect server greeting - change state
    m_irsState = irsIDLE;

    // We have some kind of server response, so leave the busy state
    AssertSz(m_fBusy, "Check your logic: we should be busy until we get svr greeting!");
    LeaveBusy();

    // Server response is either OK, BYE or PREAUTH - find out which
    CheckForCompleteResponse(pszResponseLine, dwNumBytesReceived, &irResult);

    // Even if above fn fails, irResult should be valid (eg, irNONE)
    switch (irResult) {
        case irPREAUTH_RESPONSE:
            // We were pre-authorized by the server! Login is complete.
            // Send capability command
            Assert(ssAuthenticated == m_ssServerState);
            hrResult = NoArgCommand("CAPABILITY", icCAPABILITY_COMMAND,
                ssNonAuthenticated, 0, 0, DEFAULT_CBHANDLER);
            break;
    
        case irBYE_RESPONSE:
            // Server blew us off (ie, issued BYE)! Login failed.
            Assert(ssNotConnected == m_ssServerState);
            hrResult = IXP_E_IMAP_CONNECTION_REFUSED;
            LoadString(g_hLocRes, idsSvrRefusesConnection, szFailureText,
                ARRAYSIZE(szFailureText));
            bUseLastResponse = TRUE;
            break;
        
        case irOK_RESPONSE: {
            // Server response was "OK". We need to log in.
            Assert(ssConnecting == m_ssServerState);
            m_ssServerState = ssNonAuthenticated;

            // Send capability command - on its completion, we'll authenticate
            hrResult = NoArgCommand("CAPABILITY", icCAPABILITY_COMMAND,
                ssNonAuthenticated, 0, 0, DEFAULT_CBHANDLER);
            break;
        } // case hrIMAP_S_OK_RESPONSE

        default:
            // Has server gone absolutely LOOPY?
            AssertSz(FALSE, "What kind of server greeting is this?");
            hrResult = E_FAIL;
            LoadString(g_hLocRes, idsUnknownIMAPGreeting, szFailureText,
                ARRAYSIZE(szFailureText));
            bUseLastResponse = TRUE;
            break;
    } // switch(hrResult)

    if (FAILED(hrResult)) {
        if ('\0' == szFailureText[0]) {
            LoadString(g_hLocRes, idsFailedIMAPCmdSend, szFailureText,
                ARRAYSIZE(szFailureText));
        }

        // Terminate login procedure and notify user
        OnIMAPError(hrResult, szFailureText, bUseLastResponse);
        DropConnection();
    }
} // ProcessServerGreeting



//***************************************************************************
// Function: LoginUser
//
// Purpose:
//   This function is responsible for kickstarting the login process.
//
// Returns:
//   Nothing, because any errors are reported via CmdCompletionNotification
// callback to the user. Any errors encountered in this function will be
// encountered during command transmittal, and so there's nothing further we
// can do... may as well end the login process here.
//***************************************************************************
void CImap4Agent::LoginUser(void)
{
    HRESULT hrResult;

    Assert(m_lRefCount > 0);
    Assert(ssNotConnected != m_ssServerState);
    AssertSz(FALSE == m_fBusy, "We should not be expecting any server responses here!");

    // Put us in Authentication mode
    OnStatus(IXP_AUTHORIZING);

    // Check first if we're already authenticated (eg, by PREAUTH greeting)
    if (ssAuthenticated <= m_ssServerState) {
        // We were preauthed. Notify user that login is complete
        OnStatus(IXP_AUTHORIZED);
        return;
    }

    // Use the old "Login" trick (cleartext passwords and all)
    hrResult = TwoArgCommand("LOGIN", m_rServer.szUserName, m_rServer.szPassword,
        icLOGIN_COMMAND, ssNonAuthenticated, 0, 0, DEFAULT_CBHANDLER);

    if (FAILED(hrResult)) {
        char szFailureText[MAX_RESOURCESTRING];

        // Could not send cmd: terminate login procedure and notify user
        LoadString(g_hLocRes, idsFailedIMAPCmdSend, szFailureText,
            ARRAYSIZE(szFailureText));
        OnIMAPError(hrResult, szFailureText, DONT_USE_LAST_RESPONSE);
        DropConnection();
    }
} // LoginUser



//***************************************************************************
// Function: AuthenticateUser
//
// Purpose:
//   This function handles our behaviour during non-cleartext (SSPI)
// authentication. It is very heavily based on CPOP3Transport::ResponseAUTH.
// Note that due to server interpretation problems during testing, I decided
// that BAD and NO responses will be treated as the same thing for purposes
// of authentication.
//
// Arguments:
//   AUTH_EVENT aeEvent [in] - the authentication event currently occuring.
//     This can be something like aeCONTINUE, for instance.
//   LPSTR pszServerData [in] - any data from the server associated with the
//     current authentication event. Set to NULL if no data is applicable.
//   DWORD dwSizeOfData [in] - the size of the buffer pointed to by
//     pszServerData.
//***************************************************************************
void CImap4Agent::AuthenticateUser(AUTH_EVENT aeEvent, LPSTR pszServerData,
                                   DWORD dwSizeOfData)
{
    HRESULT hrResult;
    UINT uiFailureTextID;
    BOOL fUseLastResponse;

    // Initialize variables
    hrResult = S_OK;
    uiFailureTextID = 0;
    fUseLastResponse = FALSE;

    // Suspend the watchdog for this entire function
    LeaveBusy();

    // Handle the events for which the current state is unimportant
    if (aeBAD_OR_NO_RESPONSE == aeEvent && asUNINITIALIZED < m_asAuthStatus.asCurrentState) {
        BOOL fTryNextAuthPkg;

        // Figure out whether we should try the next auth pkg, or re-try current
        if (asWAITFOR_CHALLENGE == m_asAuthStatus.asCurrentState ||
            asWAITFOR_AUTHENTICATION == m_asAuthStatus.asCurrentState)
            fTryNextAuthPkg = tamCURRENT_AUTH_METHOD;
        else
            fTryNextAuthPkg = tamNEXT_AUTH_METHOD;

        // Send the AUTHENTICATE command
        hrResult = TryAuthMethod(fTryNextAuthPkg, &uiFailureTextID);
        if (FAILED(hrResult))
            // No more auth methods to try: disconnect and end session
            fUseLastResponse = TRUE;
        else {
            // OK, wait for server response
            m_asAuthStatus.asCurrentState = asWAITFOR_CONTINUE;
            if (tamCURRENT_AUTH_METHOD == fTryNextAuthPkg)
                m_asAuthStatus.fPromptForCredentials = TRUE;
        }

        goto exit;
    }
    else if (aeABORT_AUTHENTICATION == aeEvent) {
        // We received an unknown tagged response from the server: bail
        hrResult = E_FAIL;
        uiFailureTextID = idsIMAPAbortAuth;
        fUseLastResponse = TRUE;
        goto exit;
    }


    // Now, process auth events based on our current state
    switch (m_asAuthStatus.asCurrentState) {
        case asUNINITIALIZED: {
            BOOL fResult;

            // Check conditions
            if (aeStartAuthentication != aeEvent) {
                AssertSz(FALSE, "You can only start authentication in this state");
                break;
            }
            Assert(NULL == pszServerData && 0 == dwSizeOfData);

            // Put us in Authentication mode
            OnStatus(IXP_AUTHORIZING);

            // Check first if we're already authenticated (eg, by PREAUTH greeting)
            if (ssAuthenticated <= m_ssServerState) {
                // We were preauthed. Notify user that login is complete
                OnStatus(IXP_AUTHORIZED);
                break;
            }

            // Initialize SSPI
            fResult = FIsSicilyInstalled();
            if (FALSE == fResult) {
                hrResult = E_FAIL;
                uiFailureTextID = idsIMAPSicilyInitFail;
                break;
            }

            hrResult = SSPIGetPackages(&m_asAuthStatus.pPackages,
                &m_asAuthStatus.cPackages);
            if (FAILED(hrResult)) {
                uiFailureTextID = idsIMAPSicilyPkgFailure;
                break;
            }

            // Send AUTHENTICATE command
            Assert(0 == m_asAuthStatus.iCurrentAuthToken);
            hrResult = TryAuthMethod(tamNEXT_AUTH_METHOD, &uiFailureTextID);
            if (FAILED(hrResult))
                break;

            m_asAuthStatus.asCurrentState = asWAITFOR_CONTINUE;
        } // case asUNINITIALIZED
            break; // case asUNINITIALIZED


        case asWAITFOR_CONTINUE: {
            SSPIBUFFER Negotiate;

            if (aeCONTINUE != aeEvent) {
                AssertSz(FALSE, "What am I supposed to do with this auth-event in this state?");
                break;
            }

            // Server wants us to continue: send negotiation string
            hrResult = SSPILogon(&m_asAuthStatus.rSicInfo, m_asAuthStatus.fPromptForCredentials, SSPI_BASE64,
                m_asAuthStatus.rgpszAuthTokens[m_asAuthStatus.iCurrentAuthToken-1], &m_rServer, m_pCBHandler);
            if (FAILED(hrResult)) {
                // Suppress error reportage - user may have hit cancel
                hrResult = CancelAuthentication();
                break;
            }

            if (m_asAuthStatus.fPromptForCredentials) {
                m_asAuthStatus.fPromptForCredentials = FALSE; // Don't prompt again
            }

            hrResult = SSPIGetNegotiate(&m_asAuthStatus.rSicInfo, &Negotiate);
            if (FAILED(hrResult)) {
                // Suppress error reportage - user may have hit cancel
                // Or the command was killed (with the connection)
                // Only cancel if we still have a pending command...
                if(m_piciCmdInSending)
                    hrResult = CancelAuthentication();
                break;
            }

            // Append CRLF to negotiation string
            Negotiate.szBuffer[Negotiate.cbBuffer - 1] = '\r';
            Negotiate.szBuffer[Negotiate.cbBuffer] = '\n';
            Negotiate.szBuffer[Negotiate.cbBuffer + 1] = '\0';
            Negotiate.cbBuffer += 2;
            Assert(Negotiate.cbBuffer <= sizeof(Negotiate.szBuffer));
            Assert(Negotiate.szBuffer[Negotiate.cbBuffer - 1] == '\0');

            hrResult = SendCmdLine(m_piciCmdInSending, sclINSERT_BEFORE_PAUSE,
                Negotiate.szBuffer, Negotiate.cbBuffer - 1);
            if (FAILED(hrResult))
                break;

            m_asAuthStatus.asCurrentState = asWAITFOR_CHALLENGE;
        } // case asWAITFOR_CONTINUE
            break; // case asWAITFOR_CONTINUE


        case asWAITFOR_CHALLENGE: {
            SSPIBUFFER rChallenge, rResponse;
            int iChallengeLen;

            if (aeCONTINUE != aeEvent) {
                AssertSz(FALSE, "What am I supposed to do with this auth-event in this state?");
                break;
            }

            // Server has given us a challenge: respond to challenge
            SSPISetBuffer(pszServerData, SSPI_STRING, 0, &rChallenge);

            hrResult = SSPIResponseFromChallenge(&m_asAuthStatus.rSicInfo, &rChallenge, &rResponse);
            if (FAILED(hrResult)) {
                // Suppress error reportage - user could have hit cancel
                hrResult = CancelAuthentication();
                break;
            }

            // Append CRLF to response string
            rResponse.szBuffer[rResponse.cbBuffer - 1] = '\r';
            rResponse.szBuffer[rResponse.cbBuffer] = '\n';
            rResponse.szBuffer[rResponse.cbBuffer + 1] = '\0';
            rResponse.cbBuffer += 2;
            Assert(rResponse.cbBuffer <= sizeof(rResponse.szBuffer));
            Assert(rResponse.szBuffer[rResponse.cbBuffer - 1] == '\0');

            hrResult = SendCmdLine(m_piciCmdInSending, sclINSERT_BEFORE_PAUSE,
                rResponse.szBuffer, rResponse.cbBuffer - 1);
            if (FAILED(hrResult))
                break;

            if (FALSE == rResponse.fContinue)
                m_asAuthStatus.asCurrentState = asWAITFOR_AUTHENTICATION;
        } // case asWAITFOR_CHALLENGE
            break; // case asWAITFOR_CHALLENGE


        case asWAITFOR_AUTHENTICATION:

            // If OK response, do nothing
            if (aeOK_RESPONSE != aeEvent) {
                AssertSz(FALSE, "What am I supposed to do with this auth-event in this state?");
                break;
            }
            break; // case asWAITFOR_AUTHENTICATION


        case asCANCEL_AUTHENTICATION:
            AssertSz(aeBAD_OR_NO_RESPONSE == aeEvent, "I cancelled an authentication and didn't get BAD");
            break; // case asCANCEL_AUTHENTICATION


        default:
            AssertSz(FALSE, "Invalid or unhandled state?");
            break; // Default case
    } // switch (aeEvent)

exit:
    if (FAILED(hrResult)) {
        char szFailureText[MAX_RESOURCESTRING];
        char szFailureFmt[MAX_RESOURCESTRING/4];
        char szGeneral[MAX_RESOURCESTRING/4]; // Ack, how big could the word, "General" be?
        LPSTR p, pszAuthPkg;

        LoadString(g_hLocRes, idsIMAPAuthFailedFmt, szFailureFmt, ARRAYSIZE(szFailureFmt));
        if (0 == m_asAuthStatus.iCurrentAuthToken) {
            LoadString(g_hLocRes, idsGeneral, szGeneral, ARRAYSIZE(szGeneral));
            pszAuthPkg = szGeneral;
        }
        else
            pszAuthPkg = m_asAuthStatus.rgpszAuthTokens[m_asAuthStatus.iCurrentAuthToken-1];

        p = szFailureText;
        p += wnsprintf(szFailureText, ARRAYSIZE(szFailureText), szFailureFmt, pszAuthPkg);
        if (0 != uiFailureTextID)
            LoadString(g_hLocRes, uiFailureTextID, p,
                ARRAYSIZE(szFailureText) - (DWORD) (p - szFailureText));
        OnIMAPError(hrResult, szFailureText, fUseLastResponse);
        
        DropConnection();
    }
    // Reawaken the watchdog, if required
    else if (FALSE == m_fBusy &&
        (NULL != m_piciPendingList || NULL != m_piciCmdInSending)) {
        hrResult = HrEnterBusy();
        Assert(SUCCEEDED(hrResult));
    }
} // AuthenticateUser



//***************************************************************************
// Function: TryAuthMethod
//
// Purpose:
//   This function sends out an AUTHENTICATE command to the server with the
// appropriate authentication method. The caller can choose which method is
// more appropriate: he can re-try the current authentication method, or
// move on to the next authentication command which is supported by both
// server and client.
//
// Arguments:
//   BOOL fNextAuthMethod [in] - TRUE if we should attempt to move on to
//     the next authentication package. FALSE if we should re-try the
//     current authentication package.
//   UINT *puiFailureTextID [out] - in case of failure, (eg, no more auth
//     methods to try), this function returns a string resource ID here which
//     describes the error.
//
// Returns:
//   HRESULT indicating success or failure. Expected failure codes include:
//     IXP_E_IMAP_AUTH_NOT_POSSIBLE - indicates server does not support
//       any auth packages which are recognized on this computer.
//     IXP_E_IMAP_OUT_OF_AUTH_METHODS - indicates that one or more auth
//       methods were attempted, and no more auth methods are left to try.
//***************************************************************************
HRESULT CImap4Agent::TryAuthMethod(BOOL fNextAuthMethod, UINT *puiFailureTextID)
{
    BOOL fFoundMatch;
    HRESULT hrResult;
    char szBuffer[CMDLINE_BUFSIZE];
    CIMAPCmdInfo *piciCommand;
    int iStartingAuthToken;
    LPSTR p;

    Assert(m_lRefCount > 0);

    // Initialize variables
    hrResult = S_OK;
    piciCommand = NULL;

    // Only accept cmds if server is in proper state
    if (ssNonAuthenticated != m_ssServerState) {
        AssertSz(FALSE, "The IMAP server is not in the correct state to accept this command.");
        return IXP_E_IMAP_IMPROPER_SVRSTATE;
    }

    // If we've already tried an auth pkg, free its info
    if (0 != m_asAuthStatus.iCurrentAuthToken)
        SSPIFreeContext(&m_asAuthStatus.rSicInfo);

    // Find the next auth token (returned by svr) that we support on this computer
    fFoundMatch = FALSE;
    iStartingAuthToken = m_asAuthStatus.iCurrentAuthToken;
    while (fFoundMatch == FALSE &&
        m_asAuthStatus.iCurrentAuthToken < m_asAuthStatus.iNumAuthTokens &&
        fNextAuthMethod) {
        ULONG ul = 0;

        // Current m_asAuthStatus.iCurrentAuthToken serves as idx to NEXT auth token
        // Compare current auth token with all installed packages
        for (ul = 0; ul < m_asAuthStatus.cPackages; ul++) {
            if (0 == lstrcmpi(m_asAuthStatus.pPackages[ul].pszName,
                m_asAuthStatus.rgpszAuthTokens[m_asAuthStatus.iCurrentAuthToken])) {
                fFoundMatch = TRUE;
                break;
            } // if
        } // for

        // Update this to indicate the current auth token ORDINAL (not idx)
        m_asAuthStatus.iCurrentAuthToken += 1;
    } // while

    if (FALSE == fFoundMatch && fNextAuthMethod) {
        // Could not find next authentication method match-up
        if (0 == iStartingAuthToken) {
            *puiFailureTextID = idsIMAPAuthNotPossible;
            return IXP_E_IMAP_AUTH_NOT_POSSIBLE;
        }
        else {
            *puiFailureTextID = idsIMAPOutOfAuthMethods;
            return IXP_E_IMAP_OUT_OF_AUTH_METHODS;
        }
    }

    // OK, m_asAuthStatus.iCurrentAuthToken should now point to correct match
    piciCommand = new CIMAPCmdInfo(this, icAUTHENTICATE_COMMAND, ssNonAuthenticated,
        0, 0, NULL);
    if (NULL == piciCommand) {
        *puiFailureTextID = idsMemory;
        return E_OUTOFMEMORY;
    }

    // Construct command line
    p = szBuffer;
    p += wnsprintf(szBuffer, ARRAYSIZE(szBuffer), "%s %s %.300s\r\n", piciCommand->szTag, "AUTHENTICATE",
        m_asAuthStatus.rgpszAuthTokens[m_asAuthStatus.iCurrentAuthToken-1]);

    // Send command
    hrResult = SendCmdLine(piciCommand, sclAPPEND_TO_END, szBuffer, (DWORD) (p - szBuffer));
    if (FAILED(hrResult))
        goto SendError;

    // Insert a pause, so we can perform challenge/response
    hrResult = SendPause(piciCommand);
    if (FAILED(hrResult))
        goto SendError;

    // Transmit command and register with IMAP response parser    
    hrResult = SubmitIMAPCommand(piciCommand);

SendError:
    if (FAILED(hrResult))
        delete piciCommand;

    return hrResult;
} // TryAuthMethod



//***************************************************************************
// Function: CancelAuthentication
//
// Purpose:
//   This function cancels the authentication currently in progress,
// typically due to a failure result from a Sicily function. It sends a "*"
// to the server and puts us into cancellation mode.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::CancelAuthentication(void)
{
    HRESULT hrResult;

    hrResult = SendCmdLine(m_piciCmdInSending, sclINSERT_BEFORE_PAUSE, "*\r\n", 3);
    m_asAuthStatus.asCurrentState = asCANCEL_AUTHENTICATION;
    return hrResult;
} // CancelAuthentication



//***************************************************************************
// Function: OnCommandCompletion
//
// Purpose:
//   This function is called whenever we have received a tagged response line
// terminating the current command in progress, whether or not the command
// result was successful or not. This function notifies the user of the
// command's results, and handles other tasks such as updating our internal
// mirror of the server state and calling notification functions.
//
// Arguments:
//   LPSTR szTag [in] - the tag found in the tagged response line. This will
//     be used to compare with a list of commands in progress when we allow
//     multiple simultaneous commands, but is not currently used.
//   HRESULT hrCompletionResult [in] - the HRESULT returned by the IMAP line
//     parsing functions, eg, S_OK or IXP_E_IMAP_SVR_SYNTAXERR.
//   IMAP_RESPONSE_ID irCompletionResponse [in] - identifies the status response
//     of the tagged response line (OK/NO/BAD).
//***************************************************************************
void CImap4Agent::OnCommandCompletion(LPSTR szTag, HRESULT hrCompletionResult,
                                      IMAP_RESPONSE_ID irCompletionResponse)
{
    CIMAPCmdInfo *piciCompletedCmd;
    boolean bSuppressCompletionNotification;

    Assert(m_lRefCount > 0);
    Assert(NULL != szTag);
    Assert(NULL != m_piciPendingList || NULL != m_piciCmdInSending);

    bSuppressCompletionNotification = FALSE;

    // ** STEP ONE: Identify the corresponding command for given tagged response
    // Search the pending-command chain for the given tag
    piciCompletedCmd = RemovePendingCommand(szTag);
    if (NULL == piciCompletedCmd) {
        BOOL fLeaveBusy = FALSE;

        // Couldn't find in pending list, check the command in sending
        EnterCriticalSection(&m_csSendQueue);
        if (NULL != m_piciCmdInSending &&
            0 == lstrcmp(szTag, m_piciCmdInSending->szTag)) {
            piciCompletedCmd = DequeueCommand();
            fLeaveBusy = TRUE;
        }
        else {
            AssertSz(FALSE, "Could not find cmd corresponding to tagged response!");
        }
        LeaveCriticalSection(&m_csSendQueue);

        // Now we're out of &m_csSendQueue, call LeaveBusy (needs m_cs). Avoids deadlock.
        if (fLeaveBusy)
            LeaveBusy(); // This needs CIxpBase::m_cs, so having &m_csSendQueue may deadlock
    }

    // Did we find a command which matches the given tag?
    if (NULL == piciCompletedCmd)
        return; // $REVIEW: Should probably return an error to user
                // $REVIEW: I don't think I need to bother to pump the send queue


    
	// ** STEP TWO: Perform end-of-command actions
    // Translate hrCompletionResult depending on response received
    switch (irCompletionResponse) {
        case irOK_RESPONSE:
            Assert(S_OK == hrCompletionResult);
            break;

        case irNO_RESPONSE:
            Assert(S_OK == hrCompletionResult);
            hrCompletionResult = IXP_E_IMAP_TAGGED_NO_RESPONSE;
            break;

        case irBAD_RESPONSE:
            Assert(S_OK == hrCompletionResult);
            hrCompletionResult = IXP_E_IMAP_BAD_RESPONSE;
            break;

        default:
            // If none of the above, hrResult had better be failure
            Assert(FAILED(hrCompletionResult));
            break;
    }

    // Perform any actions which follow the successful (or unsuccessful)
    // completion of an IMAP command
    switch (piciCompletedCmd->icCommandID) {
        case icAUTHENTICATE_COMMAND: {
            AUTH_EVENT aeEvent;

            // We always suppress completion notification for this command,
            // because it is sent by internal code (not by the user)
            bSuppressCompletionNotification = TRUE;

            if (irOK_RESPONSE == irCompletionResponse)
                aeEvent = aeOK_RESPONSE;
            else if (irNO_RESPONSE == irCompletionResponse ||
                     irBAD_RESPONSE == irCompletionResponse)
                aeEvent = aeBAD_OR_NO_RESPONSE;
            else
                aeEvent = aeABORT_AUTHENTICATION;

            AuthenticateUser(aeEvent, NULL, 0);

            if (SUCCEEDED(hrCompletionResult)) {
                m_ssServerState = ssAuthenticated;
                AssertSz(FALSE == m_fBusy, "We should not be expecting any server responses here!");
                OnStatus(IXP_AUTHORIZED);
            }

            // Make sure we were paused
            Assert(iltPAUSE == piciCompletedCmd->pilqCmdLineQueue->
                pilfFirstFragment->iltFragmentType);
        } // case icAUTHENTICATE_COMMAND
            break; // case icAUTHENTICATE_COMMAND

        case icLOGIN_COMMAND:
            // We always suppress completion notification for this command,
            // because it is sent by internal code (not by the user)
            bSuppressCompletionNotification = TRUE;

            if (SUCCEEDED(hrCompletionResult)) {
                m_ssServerState = ssAuthenticated;
                AssertSz(FALSE == m_fBusy, "We should not be expecting any server responses here!");
                OnStatus(IXP_AUTHORIZED);
            }
            else {
                char szFailureText[MAX_RESOURCESTRING];

                Assert(ssAuthenticated > m_ssServerState);
                LoadString(g_hLocRes, idsFailedLogin, szFailureText,
                    ARRAYSIZE(szFailureText));
                OnIMAPError(IXP_E_IMAP_LOGINFAILURE, szFailureText, USE_LAST_RESPONSE);
                ReLoginUser(); // Re-attempt login
            } // else
            
            break; // case icLOGIN_COMMAND

        case icCAPABILITY_COMMAND:
            // We always suppress completion notification for this command
            // because it is sent by internal code (not by the user)
            bSuppressCompletionNotification = TRUE;
            
            if (SUCCEEDED(hrCompletionResult)) {
                AssertSz(m_fConnectAuth, "Now just HOW does IIMAPTransport user do auth?");
                if (m_rServer.fTrySicily)
                    AuthenticateUser(aeStartAuthentication, NULL, 0);
                else
                    LoginUser();
            }
            else {
                char szFailureText[MAX_RESOURCESTRING];

                // Stop login process and report error to caller
                LoadString(g_hLocRes, idsIMAPFailedCapability, szFailureText,
                    ARRAYSIZE(szFailureText));
                OnIMAPError(hrCompletionResult, szFailureText, USE_LAST_RESPONSE);
                DropConnection();
            }

            break; // case icCAPABILITY_COMMAND


        case icSELECT_COMMAND:
        case icEXAMINE_COMMAND:
            if (SUCCEEDED(hrCompletionResult))
                m_ssServerState = ssSelected;
            else
                m_ssServerState = ssAuthenticated;

            break; // case icSELECT_COMMAND and icEXAMINE_COMMAND

        case icCLOSE_COMMAND:
            // $REVIEW: Should tagged NO response also go to ssAuthenticated?
            if (SUCCEEDED(hrCompletionResult)) {
                m_ssServerState = ssAuthenticated;
                ResetMsgSeqNumToUID();
            }

            break; // case icCLOSE_COMMAND

        case icLOGOUT_COMMAND:
            // We always suppress completion notification for this command
            bSuppressCompletionNotification = TRUE; // User can't send logout: it's sent internally

            // Drop the connection (without status indication) regardless of
            // whether LOGOUT succeeded or failed
            Assert(SUCCEEDED(hrCompletionResult)); // Debug-only detection of hanky-panky
            m_pSocket->Close();
            ResetMsgSeqNumToUID(); // Just in case, SHOULD be handled by OnDisconnected,FreeAllData

            break; // case icLOGOUT_COMMAND;

        case icIDLE_COMMAND:
            bSuppressCompletionNotification = TRUE; // User can't send IDLE: it's sent internally
            m_fIDLE = FALSE; // We are now out of IDLE mode
            break; // case icIDLE_COMMAND

        case icAPPEND_COMMAND:
            m_dwAppendStreamUploaded = 0;
            m_dwAppendStreamTotal = 0;
            break; // case icAPPEND_COMMAND
    } // switch (piciCompletedCmd->icCommandID)


    // ** STEP THREE: Perform notifications.    
    // Notify the user that this command has completed, unless we're told to
    // suppress it (usually done to treat the multi-step login process as
    // one operation).
    if (FALSE == bSuppressCompletionNotification) {
        IMAP_RESPONSE irIMAPResponse;

        irIMAPResponse.wParam = piciCompletedCmd->wParam;
        irIMAPResponse.lParam = piciCompletedCmd->lParam;
        irIMAPResponse.hrResult = hrCompletionResult;
        irIMAPResponse.lpszResponseText = m_szLastResponseText;
        irIMAPResponse.irtResponseType = irtCOMMAND_COMPLETION;
        OnIMAPResponse(piciCompletedCmd->pCBHandler, &irIMAPResponse);
    }

    // Delete CIMAPCmdInfo object
    // Note that deleting a CIMAPCmdInfo object automatically flushes its send queue
    delete piciCompletedCmd;

    // Finally, pump the send queue, if another cmd is available
    if (NULL != m_piciSendQueue)
        ProcessSendQueue(iseSEND_COMMAND);
    else if (NULL == m_piciPendingList &&
        m_ssServerState >= ssAuthenticated && irsIDLE == m_irsState)
        // Both m_piciSendQueue and m_piciPendingList are empty: send IDLE cmd
        EnterIdleMode();
} // OnCommandCompletion



//***************************************************************************
// Function: CheckForCompleteResponse
//
// Purpose:
//   Given a response line (which isn't part of a literal), this function
// checks the end of the line to see if a literal is coming. If so, then we
// prepare the receiver FSM for it. Otherwise, this constitutes the end
// of an IMAP response, so we may parse as required.
//
// Arguments:
//   LPSTR pszResponseLine [in] - this points to the response line sent to
//     us by the IMAP server.
//   DWORD dwNumBytesRead [in] - the length of pszResponseLine.
//   IMAP_RESPONSE_ID *pirParseResult [out] - if the function determines that
//     we can parse the response, the parse result is stored here (eg,
//     irOK_RESPONSE). Otherwise, irNONE is written to the pointed location.
//***************************************************************************
void CImap4Agent::CheckForCompleteResponse(LPSTR pszResponseLine,
                                           DWORD dwNumBytesRead,
                                           IMAP_RESPONSE_ID *pirParseResult)
{
    HRESULT hrResult;
    boolean bTagged;
    IMAP_LINE_FRAGMENT *pilfLine;
    LPSTR psz;
    BOOL fLiteral = FALSE;

    Assert(m_lRefCount > 0);
    Assert(NULL != pszResponseLine);
    Assert(NULL == m_pilfLiteralInProgress);
    Assert(0 == m_dwLiteralInProgressBytesLeft);
    Assert(NULL != pirParseResult);
    Assert(irsIDLE == m_irsState || irsSVR_GREETING == m_irsState);

    *pirParseResult = irNONE;

    // This is a LINE (not literal), so we're OK to nuke CRLF at end
    Assert(dwNumBytesRead >= 2); // All lines must have at least CRLF
    *(pszResponseLine + dwNumBytesRead - 2) = '\0';

    // Create line fragment    
    pilfLine = new IMAP_LINE_FRAGMENT;
    pilfLine->iltFragmentType = iltLINE;
    pilfLine->ilsLiteralStoreType = ilsSTRING;
    pilfLine->dwLengthOfFragment = dwNumBytesRead - 2; // Subtract nuked CRLF
    pilfLine->data.pszSource = pszResponseLine;
    pilfLine->pilfNextFragment = NULL;
    pilfLine->pilfPrevFragment = NULL;

    EnqueueFragment(pilfLine, &m_ilqRecvQueue);

    // Now check last char in line (exclude CRLF) to see if a literal is forthcoming
    psz = pszResponseLine + dwNumBytesRead -
        min(dwNumBytesRead, 3); // Points to '}' if literal is coming
    if ('}' == *psz) {
        LPSTR pszLiteral;

        // IE5 bug #30672: It is valid for a line to end in "}" and not be a literal.
        // We must confirm that there are digits and an opening brace "{" to detect a literal
        pszLiteral = psz;
        while (TRUE) {
            pszLiteral -= 1;

            if (pszLiteral < pszResponseLine)
                break;

            if ('{' == *pszLiteral) {
                fLiteral = TRUE;
                psz = pszLiteral;
                break;
            }
            else if (*pszLiteral < '0' || *pszLiteral > '9')
                // Assert(FALSE) (placeholder)
                // *** Consider using isdigit or IsDigit? ***
                break; // This is not a literal
        }
    }

    if (FALSE == fLiteral) {
        char szTag[NUM_TAG_CHARS+1];
        // No literal is forthcoming. This is a complete line, so let's parse

        // Get ptr to first fragment, then nuke receive queue so we can
        // continue to receive response lines while parsing this one
        pilfLine = m_ilqRecvQueue.pilfFirstFragment;
        m_ilqRecvQueue = ImapLinefragQueue_INIT;

        // Parse line. Note that parsing code is responsible for advancing
        // pilfLine so that it points to the current fragment being parsed.
        // Fragments which have been fully processed should be freed by
        // the parsing code (except for the last fragment)
        hrResult = ParseSvrResponseLine(&pilfLine, &bTagged, szTag, pirParseResult);

        // Flush rest of recv queue, regardless of parse result
        while (NULL != pilfLine) {
            IMAP_LINE_FRAGMENT *pilfTemp;

            pilfTemp = pilfLine->pilfNextFragment;
            FreeFragment(&pilfLine);
            pilfLine = pilfTemp;
        }
        
        if (bTagged)
            OnCommandCompletion(szTag, hrResult, *pirParseResult);
        else if (FAILED(hrResult)) {
            IMAP_RESPONSE irIMAPResponse;
            IIMAPCallback *pCBHandler;

            // Report untagged response failures via ErrorNotification callback
            GetTransactionID(&irIMAPResponse.wParam, &irIMAPResponse.lParam,
                &pCBHandler, *pirParseResult);
            irIMAPResponse.hrResult = hrResult;
            irIMAPResponse.lpszResponseText = m_szLastResponseText;
            irIMAPResponse.irtResponseType = irtERROR_NOTIFICATION;

            // Log it
            if (m_pLogFile) {
                char szErrorTxt[64];

                wnsprintf(szErrorTxt, ARRAYSIZE(szErrorTxt), "PARSE ERROR: hr=%lu", hrResult);
                m_pLogFile->WriteLog(LOGFILE_DB, szErrorTxt);
            }

            OnIMAPResponse(pCBHandler, &irIMAPResponse);
        }
    }
    else {
        DWORD dwLengthOfLiteral, dwMsgSeqNum;
        LPSTR pszBodyTag;

        if ('{' != *psz) {
            Assert(FALSE); // What is this?
            return; // Nothing we can do, we obviously can't get size of literal
        }
        else
            dwLengthOfLiteral = StrToUint(psz + 1);

        // Prepare either for FETCH body, or a regular literal
        if (isFetchResponse(&m_ilqRecvQueue, &dwMsgSeqNum) &&
            isFetchBodyLiteral(pilfLine, psz, &pszBodyTag)) {
            // Prepare (tombstone) literal first, because it puts us in literal mode
            hrResult = PrepareForLiteral(0);

            // This will override literal mode, putting us in fetch body part mode
            // Ignore PrepareForLiteral failure: if we don't, we interpret EACH LINE of
            // the fetch body as an IMAP response line.
            PrepareForFetchBody(dwMsgSeqNum, dwLengthOfLiteral, pszBodyTag);
        }
        else
            hrResult = PrepareForLiteral(dwLengthOfLiteral);

        Assert(SUCCEEDED(hrResult)); // Not much else we can do
    } // else: handles case where a literal is coming after this line
} // CheckForCompleteResponse



//***************************************************************************
// Function: PrepareForLiteral
//
// Purpose:
//   This function prepares the receiver code to receive a literal from the
// IMAP server.
//
// Arguments:
//   DWORD dwSizeOfLiteral [in] - the size of the incoming literal as
//     reported by the IMAP server.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::PrepareForLiteral(DWORD dwSizeOfLiteral)
{
    IMAP_LINE_FRAGMENT *pilfLiteral;
    HRESULT hrResult;

    // Initialize variables
    hrResult = S_OK;

    // Construct line fragment of type iltLITERAL
    Assert(NULL == m_pilfLiteralInProgress);
    pilfLiteral = new IMAP_LINE_FRAGMENT;
    if (NULL == pilfLiteral)
        return E_OUTOFMEMORY;

    pilfLiteral->iltFragmentType = iltLITERAL;
    pilfLiteral->dwLengthOfFragment = dwSizeOfLiteral;
    pilfLiteral->pilfNextFragment = NULL;
    pilfLiteral->pilfPrevFragment = NULL;

    // Allocate string or stream to hold literal, depending on its size
    if (pilfLiteral->dwLengthOfFragment > dwLITERAL_THRESHOLD) {
        // Literal is big, so store it as stream (large literals often represent
        // data which we return to the user as a stream, eg, message bodies)
        pilfLiteral->ilsLiteralStoreType = ilsSTREAM;
        hrResult = MimeOleCreateVirtualStream(&pilfLiteral->data.pstmSource);
    }
    else {
        BOOL bResult;

        // Literal is small. Store it as a string rather than a stream, since
        // CImap4Agent functions probably expect it as a string, anyways.
        pilfLiteral->ilsLiteralStoreType = ilsSTRING;
        bResult = MemAlloc((void **) &pilfLiteral->data.pszSource,
            pilfLiteral->dwLengthOfFragment + 1); // Room for null-term
        if (FALSE == bResult)
            hrResult = E_OUTOFMEMORY;
        else {
            hrResult = S_OK;
            *(pilfLiteral->data.pszSource) = '\0'; // Null-terminate the string
        }
    }

    if (FAILED(hrResult))
        delete pilfLiteral; // Failure means no data.pstmSource or data.pszSource to dealloc
    else {
        // Set up receive FSM to receive the proper number of bytes for literal
        m_pilfLiteralInProgress = pilfLiteral;
        m_dwLiteralInProgressBytesLeft = dwSizeOfLiteral;
        m_irsState = irsLITERAL;
    }

    return hrResult;
} // PrepareForLiteral



//***************************************************************************
// Function: isFetchResponse
//
// Purpose:
//   This function determines if the given IMAP line fragment queue holds
// a FETCH response. If so, its message sequence number may be returned to
// the caller.
//
// Arguments:
//   IMAP_LINEFRAG_QUEUE *pilqCurrentResponse [in] - a line fragment queue
//     which may or may not hold a FETCH response.
//   LPDWORD pdwMsgSeqNum [out] - if pilqCurrentResponse points to a FETCH
//     response, its message sequence number is returned here. This argument
//     may be NULL if the user does not care.
//
// Returns:
//   TRUE if pilqCurrentResponse held a FETCH response. Otherwise, FALSE.
//***************************************************************************
BOOL CImap4Agent::isFetchResponse(IMAP_LINEFRAG_QUEUE *pilqCurrentResponse,
                                  LPDWORD pdwMsgSeqNum)
{
    LPSTR pszMsgSeqNum;

    Assert(NULL != pilqCurrentResponse);
    Assert(NULL != pilqCurrentResponse->pilfFirstFragment);
    Assert(iltLINE == pilqCurrentResponse->pilfFirstFragment->iltFragmentType);

    if (NULL != pdwMsgSeqNum)
        *pdwMsgSeqNum = 0; // At least it won't be random

    pszMsgSeqNum = pilqCurrentResponse->pilfFirstFragment->data.pszSource;
    // Advance pointer to the message sequence number
    if ('*' != *pszMsgSeqNum)
        return FALSE; // We only handle tagged responses

    pszMsgSeqNum += 1;
    if (cSPACE != *pszMsgSeqNum)
        return FALSE;

    pszMsgSeqNum += 1;
    if (*pszMsgSeqNum >= '0' && *pszMsgSeqNum <= '9') {
        LPSTR pszEndOfNumber;
        int iResult;

        pszEndOfNumber = StrChr(pszMsgSeqNum, cSPACE); // Find the end of the number
        if (NULL == pszEndOfNumber)
            return FALSE; // This ain't no FETCH response

        iResult = StrCmpNI(pszEndOfNumber + 1, "FETCH ", 6);
        if (0 == iResult) {
            if (NULL != pdwMsgSeqNum)
                *pdwMsgSeqNum = StrToUint(pszMsgSeqNum);
            return TRUE;
        }
    }

    // If we hit this point, it wasn't a FETCH response
    return FALSE;
} // isFetchResponse



//***************************************************************************
// Function: isFetchBodyLiteral
//
// Purpose:
//   This function is called when the caller knows he has a FETCH response,
// and when the FETCH response is about to send a literal. This function will
// determine whether the literal about to be sent contains a message body
// part (like RFC822), or whether the literal is something else (like an
// nstring sent as a literal inside a BODYSTRUCTURE).
//
// Arguments:
//   IMAP_LINE_FRAGMENT *pilfCurrent [in] - a pointer to the current line
//     fragment received from the server. It is used by this function to
//     rewind past any literals we may have received in the "section" of
//     the BODY "msg_att" (see RFC2060 formal syntax).
//   LPSTR pszStartOfLiteralSize [in] - a pointer to the start of the '{'
//     character which indicates that a literal is coming (eg, {123}
//     indicates a literal of size 123 is coming, and pszStartOfLiteralSize
//     would point to the '{' in this case).
//   LPSTR *ppszBodyTag [out] - if the literal about to be sent contains a
//     message body part, a dup of the tag (eg, "RFC822" or "BODY[2.2]") is
//     returned to the caller here. It is the caller's responsibility to
//     MemFree this tag. THIS TAG WILL NOT CONTAIN ANY SPACES. Thus even though
//     the server may return "BODY[HEADER.FIELDS (foo bar)]", this function
//     only returns "BODY[HEADER.FIELDS".
//
// Returns:
//   TRUE if the literal about to be sent contains a message body part.
// FALSE otherwise.
//***************************************************************************
BOOL CImap4Agent::isFetchBodyLiteral(IMAP_LINE_FRAGMENT *pilfCurrent,
                                     LPSTR pszStartOfLiteralSize,
                                     LPSTR *ppszBodyTag)
{
    LPSTR pszStartOfLine;
    LPSTR pszStartOfFetchAtt;
    LPSTR pszMostRecentSpace;
    int iNumDelimiters;
    BOOL fBodySection = FALSE;

    Assert(NULL != pilfCurrent);
    Assert(NULL != pszStartOfLiteralSize);
    Assert(pszStartOfLiteralSize >= pilfCurrent->data.pszSource &&
           pszStartOfLiteralSize < (pilfCurrent->data.pszSource + pilfCurrent->dwLengthOfFragment));
    Assert(NULL != ppszBodyTag);

    // Initialize variables
    *ppszBodyTag = NULL;
    Assert('{' == *pszStartOfLiteralSize);

    // Get pointer to current msg_att: we only care about RFC822* or BODY[...]. ENVELOPE ({5} doesn't count
    iNumDelimiters = 0;
    pszStartOfLine = pilfCurrent->data.pszSource;
    pszStartOfFetchAtt = pszStartOfLiteralSize;
    pszMostRecentSpace = pszStartOfLiteralSize;
    while (iNumDelimiters < 2) {
        // Check if we have recoiled to the start of current string buffer
        if (pszStartOfFetchAtt <= pszStartOfLine) {
            // We need to recoil to previous string buffer. It is likely that a literal
            // is in the way, and it is likely that this literal belongs to HEADER.FIELDS
            // (but this can also happen inside an ENVELOPE)

            // Skip literals and anything else that's not a line
            do {
                pilfCurrent = pilfCurrent->pilfPrevFragment;
            } while (NULL != pilfCurrent && iltLINE != pilfCurrent->iltFragmentType);

            if (NULL == pilfCurrent || 0 == pilfCurrent->dwLengthOfFragment) {
                // This ain't no FETCH BODY, near as I can tell
                Assert(iNumDelimiters < 2);
                break;
            }
            else {
                // Reset string pointers
                Assert(iltLINE == pilfCurrent->iltFragmentType &&
                    ilsSTRING == pilfCurrent->ilsLiteralStoreType);
                pszStartOfLine = pilfCurrent->data.pszSource;

                // Note that pszStartOfFetchAtt will recoil past literal size decl ("{123}")
                // That's OK because it won't contain any of the delimiters we're looking for
                pszStartOfFetchAtt = pszStartOfLine + pilfCurrent->dwLengthOfFragment; // Points to null-term
                pszMostRecentSpace = pszStartOfFetchAtt; // Points to null-term (that's OK)
            }
        }

        // Set pszMostRecentSpace before pszStartOfFetchAtt decrement so pszMostRecentSpace
        // isn't set to the space BEFORE the fetch body tag
        if (cSPACE == *pszStartOfFetchAtt)
            pszMostRecentSpace = pszStartOfFetchAtt;
        
        pszStartOfFetchAtt -= 1;

        // Check for nested brackets (should not be allowed)
        Assert(']' != *pszStartOfFetchAtt || fBodySection == FALSE);

        // Disable delimiter-counting if we're in the middle of RFC2060 formal syntax "section"
        // because the HEADER.FIELDS (...) section contains spaces and parentheses
        if (']' == *pszStartOfFetchAtt)
            fBodySection = TRUE;
        else if ('[' == *pszStartOfFetchAtt)
            fBodySection = FALSE;

        if (FALSE == fBodySection && (cSPACE == *pszStartOfFetchAtt || '(' == *pszStartOfFetchAtt))
            iNumDelimiters += 1;
    }

    if (iNumDelimiters < 2)
        return FALSE; // This isn't a body tag

    Assert(2 == iNumDelimiters);
    Assert(cSPACE == *pszStartOfFetchAtt || '(' == *pszStartOfFetchAtt);
    pszStartOfFetchAtt += 1; // Make it point to the start of the tag
    if (0 == StrCmpNI(pszStartOfFetchAtt, "RFC822", 6) ||
        0 == StrCmpNI(pszStartOfFetchAtt, "BODY[", 5)) {
        int iSizeOfBodyTag;
        BOOL fResult;

        Assert(pszMostRecentSpace >= pszStartOfLine && (NULL == pilfCurrent ||
               pszMostRecentSpace <= pszStartOfLine + pilfCurrent->dwLengthOfFragment));
        Assert(pszStartOfFetchAtt >= pszStartOfLine && (NULL == pilfCurrent ||
               pszStartOfFetchAtt <= pszStartOfLine + pilfCurrent->dwLengthOfFragment));
        Assert(pszMostRecentSpace >= pszStartOfFetchAtt);

        // Return a duplicate of the body tag, up until the first space +1 for null-term
        iSizeOfBodyTag = (int) (pszMostRecentSpace - pszStartOfFetchAtt + 1);
        fResult = MemAlloc((void **)ppszBodyTag, iSizeOfBodyTag);
        if (FALSE == fResult)
            return FALSE;

        CopyMemory(*ppszBodyTag, pszStartOfFetchAtt, iSizeOfBodyTag);
        *(*ppszBodyTag + iSizeOfBodyTag - 1) = '\0'; // Null-terminate the body tag dup
        return TRUE;
    }

    // If we reached this point, this is not a body tag
    return FALSE;
} // isFetchBodyLiteral



//***************************************************************************
// Function: PrepareForFetchBody
//
// Purpose:
//   This function prepares the receiver code to receive a literal which
// contains a message body part. This literal will always be part of a FETCH
// response from the IMAP server.
//
// Arguments:
//   DWORD dwMsgSeqNum [in] - the message sequence number of the FETCH
//     response currently being received from the IMAP server.
//   DWORD dwSizeOfLiteral [in] - the size of the literal about to be received
//     from the server.
//   LPSTR pszBodyTag [in] - a pointer to a dup of the IMAP msg_att (eg,
//     "RFC822" or "BODY[2.2]") which identifies the current literal. Look up
//     msg_att in RFC2060's formal syntax section for details. This dup will
//     be MemFree'ed when it is no longer needed.
//***************************************************************************
void CImap4Agent::PrepareForFetchBody(DWORD dwMsgSeqNum, DWORD dwSizeOfLiteral,
                                      LPSTR pszBodyTag)
{
    Assert(0 == m_dwLiteralInProgressBytesLeft);
    
    m_fbpFetchBodyPartInProgress.dwMsgSeqNum = dwMsgSeqNum;
    m_fbpFetchBodyPartInProgress.pszBodyTag = pszBodyTag;
    m_fbpFetchBodyPartInProgress.dwTotalBytes = dwSizeOfLiteral;
    m_fbpFetchBodyPartInProgress.dwSizeOfData = 0;
    m_fbpFetchBodyPartInProgress.dwOffset = 0;
    m_fbpFetchBodyPartInProgress.fDone = 0;
    m_fbpFetchBodyPartInProgress.pszData = NULL;
    // Leave the cookies alone, so they persist throughout FETCH response

    m_dwLiteralInProgressBytesLeft = dwSizeOfLiteral;
    m_irsState = irsFETCH_BODY;
} // PrepareForFetchBody



//***************************************************************************
// Function: AddBytesToLiteral
//
// Purpose:
//   This function is called whenever we receive an AE_RECV from the IMAP
// server while the receiver FSM is in irsLITERAL mode. The caller is
// expected to call CASyncConn::ReadBytes and update the literal byte-count.
// This function just handles the buffer-work.
//
// Arguments:
//   LPSTR pszResponseBuf [in] - the buffer of data returned via
//     CASyncConn::ReadBytes.
//   DWORD dwNumBytesRead [in] - the size of the buffer pointed to by
//     CASyncConn::ReadBytes.
//***************************************************************************
void CImap4Agent::AddBytesToLiteral(LPSTR pszResponseBuf, DWORD dwNumBytesRead)
{
    Assert(m_lRefCount > 0);
    Assert(NULL != pszResponseBuf);

    if (NULL == m_pilfLiteralInProgress) {
        AssertSz(FALSE, "I'm still in irsLITERAL state, but I'm not set up to recv literals!");
        m_irsState = irsIDLE;
        goto exit;
    }

    // Find out if this literal will be stored as a string or stream (this
    // decision was made in CheckForCompleteResponse using size of literal).
    Assert(iltLITERAL == m_pilfLiteralInProgress->iltFragmentType);
    if (ilsSTREAM == m_pilfLiteralInProgress->ilsLiteralStoreType) {
        HRESULT hrResult;
        ULONG ulNumBytesWritten;

        // Store literal as stream
        hrResult = (m_pilfLiteralInProgress->data.pstmSource)->Write(pszResponseBuf,
            dwNumBytesRead, &ulNumBytesWritten);
        Assert(SUCCEEDED(hrResult) && ulNumBytesWritten == dwNumBytesRead);
    }
    else {
        LPSTR pszLiteralStartPoint;

        // Concatenate literal to literal in progress
        // $REVIEW: Perf enhancement - CALCULATE insertion point
        pszLiteralStartPoint = m_pilfLiteralInProgress->data.pszSource +
            lstrlen(m_pilfLiteralInProgress->data.pszSource);
        Assert(pszLiteralStartPoint + dwNumBytesRead <=
            m_pilfLiteralInProgress->data.pszSource +
            m_pilfLiteralInProgress->dwLengthOfFragment);
        CopyMemory(pszLiteralStartPoint, pszResponseBuf, dwNumBytesRead);
        *(pszLiteralStartPoint + dwNumBytesRead) = '\0'; // Null-terminate
    }

    // Check for end-of-literal
    if (0 == m_dwLiteralInProgressBytesLeft) {
        // We now have the complete literal! Queue it up and move on
        EnqueueFragment(m_pilfLiteralInProgress, &m_ilqRecvQueue);
        m_irsState = irsIDLE;
        m_pilfLiteralInProgress = NULL;
    }

exit:
    SafeMemFree(pszResponseBuf);
} // AddBytesToLiteral



//***************************************************************************
// Function: DispatchFetchBodyPart
//
// Purpose:
//   This function is called whenever receive a packet which is part of a
// message body part of a FETCH response. This packet is dispatched to the
// caller in this function via the OnResponse(irtFETCH_BODY) callback. If
// the message body part is finished, this function also restores the
// receiver code to receive lines so that the FETCH response may be completed.
//
// Arguments:
//   LPSTR pszResponseBuf [in] - a pointer to the packet which is part of
//     the message body part of the current FETCH response.
//   DWORD dwNumBytesRead [in] - the size of the data pointed to by
//     pszResponseBuf.
//   BOOL fFreeBodyTagAtEnd [in] - TRUE if
//     m_fbpFetchBodyPartInProgress.pszBodyTag points to a string dup, in
//     which case it must be MemFree'ed when the message body part is
//     finished. FALSE if the pszBodyTag member must not be MemFree'ed.
//***************************************************************************
void CImap4Agent::DispatchFetchBodyPart(LPSTR pszResponseBuf,
                                        DWORD dwNumBytesRead,
                                        BOOL fFreeBodyTagAtEnd)
{
    IMAP_RESPONSE irIMAPResponse;

    AssertSz(0 != m_fbpFetchBodyPartInProgress.dwMsgSeqNum,
        "Are you sure you're set up to receive a Fetch Body Part?");

    // Update the FETCH body part structure
    m_fbpFetchBodyPartInProgress.dwSizeOfData = dwNumBytesRead;
    m_fbpFetchBodyPartInProgress.pszData = pszResponseBuf;
    m_fbpFetchBodyPartInProgress.fDone =
        (m_fbpFetchBodyPartInProgress.dwOffset + dwNumBytesRead >=
        m_fbpFetchBodyPartInProgress.dwTotalBytes);

    // Send an IMAP response callback for this body part
    irIMAPResponse.wParam = 0;
    irIMAPResponse.lParam = 0;    
    irIMAPResponse.hrResult = S_OK;
    irIMAPResponse.lpszResponseText = NULL; // Not relevant
    irIMAPResponse.irtResponseType = irtFETCH_BODY;
    irIMAPResponse.irdResponseData.pFetchBodyPart = &m_fbpFetchBodyPartInProgress;
    AssertSz(S_OK == irIMAPResponse.hrResult,
        "Make sure fDone is TRUE if FAILED(hrResult))");
    OnIMAPResponse(m_pCBHandler, &irIMAPResponse);

    // Update the next buffer's offset
    m_fbpFetchBodyPartInProgress.dwOffset += dwNumBytesRead;

    // Check for end of body part
    if (m_fbpFetchBodyPartInProgress.dwOffset >=
        m_fbpFetchBodyPartInProgress.dwTotalBytes) {

        Assert(0 == m_dwLiteralInProgressBytesLeft);
        Assert(TRUE == m_fbpFetchBodyPartInProgress.fDone);
        Assert(m_fbpFetchBodyPartInProgress.dwOffset == m_fbpFetchBodyPartInProgress.dwTotalBytes);
        if (fFreeBodyTagAtEnd)
            MemFree(m_fbpFetchBodyPartInProgress.pszBodyTag);

        // Enqueue the tombstone literal, if fetch body nstring was sent as literal
        if (NULL != m_pilfLiteralInProgress) {
            EnqueueFragment(m_pilfLiteralInProgress, &m_ilqRecvQueue);
            m_pilfLiteralInProgress = NULL;
        }

        // Zero the fetch body part structure, but leave the cookies
        PrepareForFetchBody(0, 0, NULL);
        m_irsState = irsIDLE; // Overrides irsFETCH_BODY set by PrepareForFetchBody
    }
    else {
        Assert(FALSE == m_fbpFetchBodyPartInProgress.fDone);
    }
} // DispatchFetchBodyPart



//***************************************************************************
// Function: UploadStreamProgress
//
// Purpose:
//   This function sends irtAPPEND_PROGRESS responses to the callback so
// that the IIMAPTransport user can report the progress of an APPEND command.
//
// Arguments:
//   DWORD dwBytesUploaded [in] - number of bytes just uploaded to the
//     server. This function retains a running count of bytes uploaded.
//***************************************************************************
void CImap4Agent::UploadStreamProgress(DWORD dwBytesUploaded)
{
    APPEND_PROGRESS ap;
    IMAP_RESPONSE irIMAPResponse;

    // Check if we should report APPEND upload progress. We report if we are currently executing
    // APPEND and the CRLF is waiting to be sent
    if (NULL == m_piciCmdInSending || icAPPEND_COMMAND != m_piciCmdInSending->icCommandID ||
        NULL == m_piciCmdInSending->pilqCmdLineQueue)
        return;
    else {
        IMAP_LINE_FRAGMENT *pilf = m_piciCmdInSending->pilqCmdLineQueue->pilfFirstFragment;

        // It's an APPEND command with non-empty linefrag queue, now check that next
        // linefrag fits description for linefrag after msg body
        if (NULL == pilf || iltLINE != pilf->iltFragmentType ||
            ilsSTRING != pilf->ilsLiteralStoreType || 2 != pilf->dwLengthOfFragment ||
            '\r' != pilf->data.pszSource[0] || '\n' != pilf->data.pszSource[1] ||
            NULL != pilf->pilfNextFragment)
            return;
    }

    // Report current progress of message upload
    m_dwAppendStreamUploaded += dwBytesUploaded;
    ap.dwUploaded = m_dwAppendStreamUploaded;
    ap.dwTotal = m_dwAppendStreamTotal;
    Assert(0 != ap.dwTotal);
    Assert(ap.dwTotal >= ap.dwUploaded);

    irIMAPResponse.wParam = m_piciCmdInSending->wParam;
    irIMAPResponse.lParam = m_piciCmdInSending->lParam;
    irIMAPResponse.hrResult = S_OK;
    irIMAPResponse.lpszResponseText = NULL;
    irIMAPResponse.irtResponseType = irtAPPEND_PROGRESS;
    irIMAPResponse.irdResponseData.papAppendProgress = &ap;
    OnIMAPResponse(m_piciCmdInSending->pCBHandler, &irIMAPResponse);
} // UploadStreamProgress



//***************************************************************************
// Function: OnNotify
//
// Purpose: This function is required for the IAsyncConnCB which we derive
//   from (callback for CAsyncConn class). This function acts on CASyncConn
//   state changes and events.
//***************************************************************************
void CImap4Agent::OnNotify(ASYNCSTATE asOld, ASYNCSTATE asNew, ASYNCEVENT ae)
{
    char szLogFileLine[128];

    // Check refcount, but exception is that we can get AE_CLOSE. CImap4Agent's
    // destructor calls CASyncConn's Close() member, which generates one last
    // message, the event AE_CLOSE, with m_lRefCount == 0.
    Assert(m_lRefCount > 0 || (0 == m_lRefCount && AE_CLOSE == ae));

    // Record AsyncConn event/state-change in log file
    wnsprintf(szLogFileLine, ARRAYSIZE(szLogFileLine), "OnNotify: asOld = %d, asNew = %d, ae = %d",
        asOld, asNew, ae);
    if (m_pLogFile)
        m_pLogFile->WriteLog(LOGFILE_DB, szLogFileLine);

    // Check for disconnect
    if (AS_DISCONNECTED == asNew) {
        m_irsState = irsNOT_CONNECTED;
        m_ssServerState = ssNotConnected;
        m_fIDLE = FALSE;
        m_bFreeToSend = TRUE;
    }

    // Act on async event
    switch (ae) {
        case AE_RECV: {
            HRESULT hrResult;

            // Process response lines until no more lines (hrIncomplete result)
            do {
                hrResult = ProcessResponseLine();
            } while (SUCCEEDED(hrResult));

            // If error is other than IXP_E_INCOMPLETE, drop connection
            if (IXP_E_INCOMPLETE != hrResult) {
                char szFailureText[MAX_RESOURCESTRING];

                // Looks fatal, better warn the user that disconnection is imminent
                LoadString(g_hLocRes, idsIMAPSocketReadError, szFailureText,
                    ARRAYSIZE(szFailureText));
                OnIMAPError(hrResult, szFailureText, DONT_USE_LAST_RESPONSE);
                
                // What else can we do but drop the connection?
                DropConnection();
            } // if error other than IXP_E_INCOMPLETE
            break;
        } // case AE_RECV

        case AE_SENDDONE:
            UploadStreamProgress(m_pSocket->UlGetSendByteCount());

            // Received AE_SENDDONE from CAsyncConn class. We are free to send more data
            m_bFreeToSend = TRUE;
            ProcessSendQueue(iseSENDDONE); // Informs them that they may start sending again
            break;

        case AE_WRITE:
            UploadStreamProgress(m_pSocket->UlGetSendByteCount());
            break;
        
        default:
            CIxpBase::OnNotify(asOld, asNew, ae);
            break; // case default
    } // switch (ae)
} // OnNotify



//***************************************************************************
// Function: ProcessResponseLine
//
// Purpose:
//   This functions handles the AE_RECV event of the OnNotify() callback.
// It gets a response line from the server (if available) and dispatches
// the line to the proper recipient based on the state of the receiver FSM.
//
// Returns:
//   HRESULT indicating success or failure of CAsyncConn line retrieval.
// hrIncomplete (an error code) is returned if no more complete lines can
// be retrieved from CAsyncConn's buffer.
//***************************************************************************
HRESULT CImap4Agent::ProcessResponseLine(void)
{
    HRESULT hrASyncResult;
    char *pszResponseBuf;
    int cbRead;

    Assert(m_lRefCount > 0);

    // We are always in one of two modes: line mode, or byte mode. Figure out which.
    if (irsLITERAL != m_irsState && irsFETCH_BODY != m_irsState) {
        // We're in line mode. Get response line from server
        hrASyncResult = m_pSocket->ReadLine(&pszResponseBuf, &cbRead);
        if (FAILED(hrASyncResult))
            return hrASyncResult;

        // Record received line in log file
        if (m_pLogFile)
            m_pLogFile->WriteLog(LOGFILE_RX, pszResponseBuf);
    } // if-line mode
    else {
        // We're in literal mode. Get as many bytes as we can.
        hrASyncResult = m_pSocket->ReadBytes(&pszResponseBuf,
            m_dwLiteralInProgressBytesLeft, &cbRead);
        if (FAILED(hrASyncResult))
            return hrASyncResult;

        // Update our byte count
        Assert((DWORD)cbRead <= m_dwLiteralInProgressBytesLeft);
        m_dwLiteralInProgressBytesLeft -= cbRead;

        // Make note of received blob in log file
        if (m_pLogFile) {
            char szLogLine[CMDLINE_BUFSIZE];

            wnsprintf(szLogLine, ARRAYSIZE(szLogLine), "Buffer (literal) of length %i", cbRead);
            m_pLogFile->WriteLog(LOGFILE_RX, szLogLine);
        }
    } // else-not line mode
    
    // Process it
    switch (m_irsState) {
        case irsUNINITIALIZED:
            AssertSz(FALSE, "Attempted to use Imap4Agent class without initializing");
            SafeMemFree(pszResponseBuf);
            break;

        case irsNOT_CONNECTED:
            AssertSz(FALSE, "Received response from server when not connected");
            SafeMemFree(pszResponseBuf);
            break;

        case irsSVR_GREETING:
            ProcessServerGreeting(pszResponseBuf, cbRead);
            break;

        case irsIDLE: {
            IMAP_RESPONSE_ID irParseResult;

            CheckForCompleteResponse(pszResponseBuf, cbRead, &irParseResult);
            
            // Check for unsolicited BYE response, and notify user of error
            // Solicited BYE responses (eg, during LOGOUT cmd) can be ignored
            if (irBYE_RESPONSE == irParseResult &&
                IXP_AUTHRETRY != m_status &&
                IXP_DISCONNECTING != m_status &&
                IXP_DISCONNECTED  != m_status) {
                char szFailureText[MAX_RESOURCESTRING];

                // Looks like an unsolicited BYE response to me
                // Drop connection to avoid IXP_E_CONNECTION_DROPPED err
                DropConnection();

                // Report to user (sometimes server provides useful error text)
                LoadString(g_hLocRes, idsIMAPUnsolicitedBYE, szFailureText,
                    ARRAYSIZE(szFailureText));
                OnIMAPError(IXP_E_IMAP_UNSOLICITED_BYE, szFailureText,
                    USE_LAST_RESPONSE);
            }
        } // case irsIDLE
            break;

        case irsLITERAL:
            AddBytesToLiteral(pszResponseBuf, cbRead);
            break;

        case irsFETCH_BODY:
            DispatchFetchBodyPart(pszResponseBuf, cbRead, fFREE_BODY_TAG);
            SafeMemFree(pszResponseBuf);
            break;

        default:
            AssertSz(FALSE, "Unhandled receiver state in ProcessResponseLine()");
            SafeMemFree(pszResponseBuf);
            break;
    } // switch (m_irsState)

    return hrASyncResult;
} // ProcessResponseLine



//***************************************************************************
// Function: ProcessSendQueue
//
// Purpose:
//   This function is responsible for all transmissions from the client to
// the IMAP server. It is called when certain events occur, such as the
// receipt of the AE_SENDDONE event in OnNotify().
//
// Arguments:
//   IMAP_SEND_EVENT iseEvent [in] - the send event which just occurred,
//     such as iseSEND_COMMAND (used to initiate a command) or
//     iseCMD_CONTINUATION (when command continuation response received from
//     the IMAP server).
//***************************************************************************
void CImap4Agent::ProcessSendQueue(IMAP_SEND_EVENT iseEvent)
{
    boolean bFreeToSendLiteral, bFreeToUnpause;
    IMAP_LINE_FRAGMENT *pilfNextFragment;

    Assert(m_lRefCount > 0);
    Assert(ssNotConnected < m_ssServerState);
    Assert(irsNOT_CONNECTED < m_irsState);

    // Initialize variables
    bFreeToSendLiteral = FALSE;
    bFreeToUnpause = FALSE;

    // Peek at current fragment
    EnterCriticalSection(&m_cs); // Reserve this NOW to avoid deadlock
    EnterCriticalSection(&m_csSendQueue);
    GetNextCmdToSend();
    if (NULL != m_piciCmdInSending)
        pilfNextFragment = m_piciCmdInSending->pilqCmdLineQueue->pilfFirstFragment;
    else
        pilfNextFragment = NULL;

    // Act on the IMAP send event posted to us
    switch (iseEvent) {
        case iseSEND_COMMAND:
        case iseSENDDONE:
            // We don't have to do anything special for these events
            break;

        case iseCMD_CONTINUATION:
            // Received command continuation from IMAP server. We are free to send literal
            bFreeToSendLiteral = TRUE;
            Assert(NULL != pilfNextFragment &&
                iltLITERAL == pilfNextFragment->iltFragmentType);
            break;

        case iseUNPAUSE:
            bFreeToUnpause = TRUE;
            IxpAssert(NULL != pilfNextFragment &&
                iltPAUSE == pilfNextFragment->iltFragmentType);
            break;

        default:
            AssertSz(FALSE, "Received unknown IMAP send event");
            break;
    }


    // Send as many fragments as we can. We must stop sending if:
    //   a) Any AsyncConn send command returns hrWouldBlock.
    //   b) The send queue is empty
    //   c) Next fragment is a literal and we don't have cmd continuation from svr
    //   d) We are at a iltPAUSE fragment, and we don't have the go-ahead to unpause
    //   e) We are at a iltSTOP fragment.
    while (TRUE == m_bFreeToSend && NULL != pilfNextFragment &&
          ((iltLITERAL != pilfNextFragment->iltFragmentType) || TRUE == bFreeToSendLiteral) &&
          ((iltPAUSE != pilfNextFragment->iltFragmentType) || TRUE == bFreeToUnpause) &&
          (iltSTOP != pilfNextFragment->iltFragmentType))
    {
        HRESULT hrResult;
        int iNumBytesSent;
        IMAP_LINE_FRAGMENT *pilf;

        // We are free to send the next fragment, whether it's a line, literal or rangelist
        // Put us into busy mode to enable the watchdog timer
        if (FALSE == m_fBusy) {
            hrResult = HrEnterBusy();
            Assert(SUCCEEDED(hrResult));
            // In retail, we want to try to continue even if HrEnterBusy failed.
        }

        // Send next fragment (have to check if stored as a string or a stream)
        pilfNextFragment = pilfNextFragment->pilfNextFragment; // Peek at next frag
        pilf = DequeueFragment(m_piciCmdInSending->pilqCmdLineQueue); // Get current frag
        if (iltPAUSE == pilf->iltFragmentType) {
            hrResult = S_OK; // Do nothing
        }
        else if (iltSTOP == pilf->iltFragmentType) {
            AssertSz(FALSE, "What are we doing trying to process a STOP?");
            hrResult = S_OK; // Do nothing
        }
        else if (iltRANGELIST == pilf->iltFragmentType) {
            AssertSz(FALSE, "All rangelists should have been coalesced!");
            hrResult = S_OK; // Do nothing
        }
        else if (ilsSTRING == pilf->ilsLiteralStoreType) {
            hrResult = m_pSocket->SendBytes(pilf->data.pszSource,
                pilf->dwLengthOfFragment, &iNumBytesSent);

            // Record sent line in log file
            if (m_pLogFile) {
                // Hide the LOGIN command from logfile, for security reasons
                if (icLOGIN_COMMAND != m_piciCmdInSending->icCommandID)
                    m_pLogFile->WriteLog(LOGFILE_TX, pilf->data.pszSource);
                else
                    m_pLogFile->WriteLog(LOGFILE_TX, "LOGIN command sent");
            }
        }
        else if (ilsSTREAM == pilf->ilsLiteralStoreType) {
            char szLogLine[128];

            // No need to rewind stream - CAsyncConn::SendStream does it for us
            hrResult = m_pSocket->SendStream(pilf->data.pstmSource, &iNumBytesSent);

            // Record stream size in log file
            wnsprintf(szLogLine, ARRAYSIZE(szLogLine), "Stream of length %lu", pilf->dwLengthOfFragment);
            if (m_pLogFile)
                m_pLogFile->WriteLog(LOGFILE_TX, szLogLine);

            // Record stream size for progress indication
            if (icAPPEND_COMMAND == m_piciCmdInSending->icCommandID) {
                m_dwAppendStreamUploaded = 0;
                m_dwAppendStreamTotal = pilf->dwLengthOfFragment;
                UploadStreamProgress(iNumBytesSent);
            }
        }
        else {
            AssertSz(FALSE, "What is in my send queue?");
            hrResult = S_OK; // Ignore it and try to continue
        }

        // Clean up variables after the send
        bFreeToSendLiteral = FALSE; // We've used up the cmd continuation
        bFreeToUnpause = FALSE; // We've used this up, too
        FreeFragment(&pilf);

        // Handle errors in sending.
        // If either send command returns hrWouldBlock, this means we cannot send
        // more data until we receive an AE_SENDDONE event from CAsyncConn.
        if (IXP_E_WOULD_BLOCK == hrResult) {
            m_bFreeToSend = FALSE;
            hrResult = S_OK; // $REVIEW: TEMPORARY until EricAn makes hrWouldBlock a success code
        }
        else if (FAILED(hrResult)) {
            IMAP_RESPONSE irIMAPResponse;
            char szFailureText[MAX_RESOURCESTRING];

            // Send error: Report this command as terminated
            irIMAPResponse.wParam = m_piciCmdInSending->wParam;
            irIMAPResponse.lParam = m_piciCmdInSending->lParam;
            irIMAPResponse.hrResult = hrResult;
            LoadString(g_hLocRes, idsFailedIMAPCmdSend, szFailureText,
                ARRAYSIZE(szFailureText));
            irIMAPResponse.lpszResponseText = szFailureText;
            irIMAPResponse.irtResponseType = irtCOMMAND_COMPLETION;
            OnIMAPResponse(m_piciCmdInSending->pCBHandler, &irIMAPResponse);
        }


        // Are we finished with the current command?
        if (NULL == pilfNextFragment || FAILED(hrResult)) {
            CIMAPCmdInfo *piciFinishedCmd;

            // Dequeue current command from send queue
            piciFinishedCmd = DequeueCommand();
            if (NULL != piciFinishedCmd) {
                if (SUCCEEDED(hrResult)) {
                    // We successfully finished sending current command. Put it in
                    // list of commands waiting for a server response
                    AddPendingCommand(piciFinishedCmd);
                    Assert(NULL == pilfNextFragment);
                }
                else {
                    // Failed commands don't deserve to live
                    delete piciFinishedCmd;
                    pilfNextFragment = NULL; // No longer valid

                    // Drop out of busy mode
                    AssertSz(m_fBusy, "Check your logic, I'm calling LeaveBusy "
                        "although not in a busy state!");
                    LeaveBusy();
                }
            }
            else {
                // Hey, someone pulled the rug out!
                AssertSz(FALSE, "I had this cmd... and now it's GONE!");
            }
        } // if (NULL == pilfNextFragment || FAILED(hrResult))


        // If we finished sending current cmd, set us up to send next command
        if (NULL == pilfNextFragment && NULL != m_piciSendQueue) {
            GetNextCmdToSend();
            if (NULL != m_piciCmdInSending)
                pilfNextFragment = m_piciCmdInSending->pilqCmdLineQueue->pilfFirstFragment;
        }

    } // while

    LeaveCriticalSection(&m_csSendQueue);
    LeaveCriticalSection(&m_cs);
} // ProcessSendQueue



//***************************************************************************
// Function: GetNextCmdToSend
//
// Purpose:
//   This function leaves a pointer to the next command to send, in
// m_piciCmdInSending. If m_piciCmdInSending is already non-NULL (indicating
// a command in progress), then this function does nothing. Otherwise, this
// function chooses the next command from m_piciSendQueue using a set of
// rules described within.
//***************************************************************************
void CImap4Agent::GetNextCmdToSend(void)
{
    CIMAPCmdInfo *pici;

    // First check if we're connected
    if (IXP_CONNECTED != m_status &&
        IXP_AUTHORIZING != m_status &&
        IXP_AUTHRETRY != m_status &&
        IXP_AUTHORIZED != m_status &&
        IXP_DISCONNECTING != m_status) {
        Assert(NULL == m_piciCmdInSending);
        return;
    }

    // Check if we're already in the middle of sending a command
    if (NULL != m_piciCmdInSending)
        return;

    // Loop through the send queue looking for next eligible candidate to send
    pici = m_piciSendQueue;
    while (NULL != pici) {
        IMAP_COMMAND icCurrentCmd;

        // For a command to be sent, it must meet the following criteria:
        // (1) The server must be in the correct server state. Authenticated cmds such
        //     as SELECT must wait until non-Authenticated cmds like LOGIN are complete.
        // (2) Commands for which we want to guarantee proper wParam, lParam for their
        //     untagged responses cannot be streamed. See CanStreamCommand for details.
        // (3) If the command is NON-UID FETCH/STORE/SEARCH or COPY, then all pending
        //     cmds must be NON-UID FETCH/STORE/SEARCH.

        icCurrentCmd = pici->icCommandID;
        if (m_ssServerState >= pici->ssMinimumState && CanStreamCommand(icCurrentCmd)) {
            if ((icFETCH_COMMAND == icCurrentCmd || icSTORE_COMMAND == icCurrentCmd ||
                icSEARCH_COMMAND == icCurrentCmd || icCOPY_COMMAND == icCurrentCmd) &&
                FALSE == pici->fUIDRangeList) {
                if (isValidNonWaitingCmdSequence())
                    break; // This command is good to go
            }
            else
                break; // This command is good to go
        }

        // Advance ptr to next command
        pici = pici->piciNextCommand;
    } // while

    // If we found a command, coalesce its iltLINE and iltRANGELIST elements
    if (NULL != pici) {
        CompressCommand(pici);
        m_piciCmdInSending = pici;
    }
} // GetNextCmdToSend



//***************************************************************************
// Function: CanStreamCommand
//
// Purpose:
//   This function determines whether or not the given command can be
// streamed. All commands can be streamed except for the following:
// SELECT, EXAMINE, LIST, LSUB and SEARCH.
//
// SELECT and EXAMINE cannot be streamed because it doesn't make much sense
// to allow that.
// LIST, LSUB and SEARCH cannot be streamed because we want to guarantee
// that we can identify the correct wParam, lParam and pCBHandler when we call
// OnResponse for their untagged responses.
//
// Arguments:
//   IMAP_COMMAND icCommandID [in] - the command which you would like to send
//     to the server.
//
// Returns:
//   TRUE if the given command may be sent. FALSE if you cannot send the
// given command at this time (try again later).
//***************************************************************************
boolean CImap4Agent::CanStreamCommand(IMAP_COMMAND icCommandID)
{
    boolean fResult;
    WORD wNumberOfMatches;

    fResult = TRUE;
    wNumberOfMatches = 0;
    switch (icCommandID) {
        // We don't stream any of the following commands

        case icSELECT_COMMAND:
        case icEXAMINE_COMMAND:
            wNumberOfMatches = FindTransactionID(NULL, NULL, NULL,
                icSELECT_COMMAND, icEXAMINE_COMMAND);
            break;

        case icLIST_COMMAND:
            wNumberOfMatches = FindTransactionID(NULL, NULL, NULL, icLIST_COMMAND);
            break;

        case icLSUB_COMMAND:
            wNumberOfMatches = FindTransactionID(NULL, NULL, NULL, icLSUB_COMMAND);
            break;

        case icSEARCH_COMMAND:
            wNumberOfMatches = FindTransactionID(NULL, NULL, NULL, icSEARCH_COMMAND);
            break;
    } //switch

    if (wNumberOfMatches > 0)
        fResult = FALSE;

    return fResult;
} // CanStreamCommand



//***************************************************************************
// Function: isValidNonWaitingCmdSequence
//
// Purpose:
//   This function is called whenever we would like to send a FETCH, STORE,
// SEARCH or COPY command (all NON-UID) to the server. These commands are
// subject to waiting rules as discussed in section 5.5 of RFC2060.
//
// Returns:
//   TRUE if the non-UID FETCH/STORE/SEARCH/COPY command can be sent at
// this time. FALSE if the command cannot be sent at this time (try again
// later).
//***************************************************************************
boolean CImap4Agent::isValidNonWaitingCmdSequence(void)
{
    CIMAPCmdInfo *pici;
    boolean fResult;

    // Loop through the list of pending commands
    pici = m_piciPendingList;
    fResult = TRUE;
    while (NULL != pici) {
        IMAP_COMMAND icCurrentCmd;

        // non-UID FETCH/STORE/SEARCH/COPY can only execute if the only
        // pending commands are non-UID FETCH/STORE/SEARCH.
        icCurrentCmd = pici->icCommandID;
        if (icFETCH_COMMAND != icCurrentCmd &&
            icSTORE_COMMAND != icCurrentCmd &&
            icSEARCH_COMMAND != icCurrentCmd ||
            pici->fUIDRangeList) {
            fResult = FALSE;
            break;
        }

        // Advance pointer to next command
        pici = pici->piciNextCommand;
    } // while

    return fResult;
} // isValidNonWaitingCmdSequence



//***************************************************************************
// Function: CompressCommand
//
// Purpose: This function walks through the given command's linefrag queue
//   and combines all sequential iltLINE and iltRANGELIST linefrag elements
//   into a single iltLINE element for transmitting purposes. The reason we
//   have to combine these is because I had a pipe dream once that CImap4Agent
//   would auto-detect EXPUNGE responses and modify all iltRANGELIST elements
//   in m_piciSendQueue to reflect the new msg seq num reality. Who knows,
//   it might even come true some day.
//
//   When it does come true, this function can still exist: once a command
//   enters m_piciCmdInSending, it is too late to modify its rangelist.
//
// Arguments:
//   CIMAPCmdInfo *pici [in] - pointer to the IMAP command to compress.
//***************************************************************************
void CImap4Agent::CompressCommand(CIMAPCmdInfo *pici)
{
    IMAP_LINE_FRAGMENT *pilfCurrent, *pilfStartOfRun, *pilfPreStartOfRun;
    HRESULT hrResult;

    // Codify assumptions
    Assert(NULL != pici);
    Assert(5 == iltLAST); // If this changes, update this function

    // Initialize variables
    hrResult = S_OK;
    pilfCurrent = pici->pilqCmdLineQueue->pilfFirstFragment;
    pilfStartOfRun = pilfCurrent;
    pilfPreStartOfRun = NULL; // Points to linefrag element before pilfStartOfRun
    while (1) {
        if (NULL == pilfCurrent || 
            (iltLINE != pilfCurrent->iltFragmentType &&
            iltRANGELIST != pilfCurrent->iltFragmentType)) {
            // We've hit a non-coalescable linefrag, coalesce previous run
            // We only coalesce runs which are greater than one linefrag element
            if (NULL != pilfStartOfRun && pilfCurrent != pilfStartOfRun->pilfNextFragment) {
                IMAP_LINE_FRAGMENT *pilf, *pilfSuperLine;
                CByteStream bstmCmdLine;

                // Run length > 1, coalesce the entire run
                pilf = pilfStartOfRun;
                while (pilf != pilfCurrent) {
                    if (iltLINE == pilf->iltFragmentType) {
                        hrResult = bstmCmdLine.Write(pilf->data.pszSource,
                            pilf->dwLengthOfFragment, NULL);
                        if (FAILED(hrResult))
                            goto exit;
                    }
                    else {
                        LPSTR pszMsgRange;
                        DWORD dwLengthOfString;

                        // Convert rangelist to string
                        Assert(iltRANGELIST == pilf->iltFragmentType);
                        hrResult = pilf->data.prlRangeList->
                            RangeToIMAPString(&pszMsgRange, &dwLengthOfString);
                        if (FAILED(hrResult))
                            goto exit;

                        hrResult = bstmCmdLine.Write(pszMsgRange, dwLengthOfString, NULL);
                        MemFree(pszMsgRange);
                        if (FAILED(hrResult))
                            goto exit;

                        // Append a space behind the rangelist
                        hrResult = bstmCmdLine.Write(g_szSpace, 1, NULL);
                        if (FAILED(hrResult))
                            goto exit;
                    } // else

                    pilf = pilf->pilfNextFragment;
                } // while (pilf != pilfCurrent)

                // OK, now we've coalesced the run data into a stream
                // Create a iltLINE fragment to hold the super-string
                pilfSuperLine = new IMAP_LINE_FRAGMENT;
                if (NULL == pilfSuperLine) {
                    hrResult = E_OUTOFMEMORY;
                    goto exit;
                }
                pilfSuperLine->iltFragmentType = iltLINE;
                pilfSuperLine->ilsLiteralStoreType = ilsSTRING;
                hrResult = bstmCmdLine.HrAcquireStringA(&pilfSuperLine->dwLengthOfFragment,
                    &pilfSuperLine->data.pszSource, ACQ_DISPLACE);
                if (FAILED(hrResult)) {
                    delete pilfSuperLine;
                    goto exit;
                }

                // OK, we've created the uber-line, now link it into list
                pilfSuperLine->pilfNextFragment = pilfCurrent;
                pilfSuperLine->pilfPrevFragment = pilfPreStartOfRun;
                Assert(pilfPreStartOfRun == pilfStartOfRun->pilfPrevFragment);
                if (NULL == pilfPreStartOfRun)
                    // Insert at head of queue
                    pici->pilqCmdLineQueue->pilfFirstFragment = pilfSuperLine;
                else
                    pilfPreStartOfRun->pilfNextFragment = pilfSuperLine;

                // Special case: if pilfCurrent is NULL, pilfSuperLine is new last frag
                if (NULL == pilfCurrent)
                    pici->pilqCmdLineQueue->pilfLastFragment = pilfSuperLine;

                // Free the old run of linefrag elements
                pilf = pilfStartOfRun;
                while(pilf != pilfCurrent) {
                    IMAP_LINE_FRAGMENT *pilfNext;

                    pilfNext = pilf->pilfNextFragment;
                    FreeFragment(&pilf);
                    pilf = pilfNext;
                } // while(pilf != pilfCurrent)
            } // if run length > 1

            // Start collecting line fragments for next coalescing run
            if (NULL != pilfCurrent) {
                pilfStartOfRun = pilfCurrent->pilfNextFragment;
                pilfPreStartOfRun = pilfCurrent;
            } // if
        } // if current linefrag is non-coalescable

        // Advance to next line fragment
        if (NULL != pilfCurrent)
            pilfCurrent = pilfCurrent->pilfNextFragment;
        else
            break; // Our work here is done
    } // while (NULL != pilfCurrent)

exit:
    AssertSz(SUCCEEDED(hrResult), "Could not compress an IMAP command");
} // CompressCommand



//***************************************************************************
// Function: SendCmdLine
//
// Purpose:
//   This function enqueues an IMAP line fragment (as opposed to an IMAP
// literal fragment) on the send queue of the given CIMAPCmdInfo structure.
// The insertion point can either be in front 
// All IMAP commands are constructed in full before being submitted to the
// send machinery, so this function does not actually transmit anything.
//
// Arguments:
//   CIMAPCmdInfo *piciCommand [in] - pointer to an info structure describing
//     the IMAP command currently under construction.
//   DWORD dwFlags [in] - various options:
//     sclINSERT_BEFORE_PAUSE: line fragment will be inserted before the
//                             first iltPAUSE fragment in the queue. It is the
//                             caller's responsibility to ensure that a iltPAUSE
//                             fragment exists.
//     sclAPPEND_TO_END: (DEFAULT CASE, there is no flag for this) line fragment
//                             will be appended to the end of the queue.
//     sclAPPEND_CRLF:  Appends CRLF to contents of lpszCommandText when
//                      constructing the line fragment.
//
//   LPCSTR lpszCommandText [in] - a pointer to the line fragment to enqueue.
//     The first line fragment of all commands should include a tag. This
//     function does not provide command tags, and does not append CRLF to
//     the end of each line by default (see sclAPPEND_CRLF above).
//   DWORD dwCmdLineLength [in] - the length of the text pointed to by
//     lpszCommandText.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::SendCmdLine(CIMAPCmdInfo *piciCommand, DWORD dwFlags,
                                 LPCSTR lpszCommandText, DWORD dwCmdLineLength)
{
    IMAP_LINE_FRAGMENT *pilfLine;
    BOOL bResult;
    BOOL fAppendCRLF;
    
    Assert(m_lRefCount > 0);
    Assert(NULL != piciCommand);
    Assert(NULL != lpszCommandText);

    // Create and fill out a line fragment element
    fAppendCRLF = !!(dwFlags & sclAPPEND_CRLF);
    pilfLine = new IMAP_LINE_FRAGMENT;
    if (NULL == pilfLine)
        return E_OUTOFMEMORY;

    pilfLine->iltFragmentType = iltLINE;
    pilfLine->ilsLiteralStoreType = ilsSTRING;
    pilfLine->dwLengthOfFragment = dwCmdLineLength + (fAppendCRLF ? 2 : 0);
    pilfLine->pilfNextFragment = NULL;
    pilfLine->pilfPrevFragment = NULL;
    DWORD cchSize = (pilfLine->dwLengthOfFragment + 1); // Room for null-term
    bResult = MemAlloc((void **)&pilfLine->data.pszSource, cchSize * sizeof(pilfLine->data.pszSource[0]));
    if (FALSE == bResult)
    {
        delete pilfLine;
        return E_OUTOFMEMORY;
    }
    CopyMemory(pilfLine->data.pszSource, lpszCommandText, dwCmdLineLength);
    if (fAppendCRLF)
        StrCpyN(pilfLine->data.pszSource + dwCmdLineLength, c_szCRLF, cchSize - dwCmdLineLength);
    else
        *(pilfLine->data.pszSource + dwCmdLineLength) = '\0'; // Null-terminate the line

    // Queue it up
    if (dwFlags & sclINSERT_BEFORE_PAUSE) {
        InsertFragmentBeforePause(pilfLine, piciCommand->pilqCmdLineQueue);
        ProcessSendQueue(iseSEND_COMMAND); // Pump send queue in this case
    }
    else
        EnqueueFragment(pilfLine, piciCommand->pilqCmdLineQueue);

    return S_OK;
} // SendCmdLine



//***************************************************************************
// Function: SendLiteral
//
// Purpose:
//   This function enqueues an IMAP literal fragment (as opposed to an IMAP
// line fragment) on the send queue of the given CIMAPCmdInfo structure.
// All IMAP commands are constructed in full before being submitted to the
// send machinery, so this function does not actually transmit anything.
//
// Arguments:
//   CIMAPCmdInfo *piciCommand [in] - pointer to an info structure describing
//     the IMAP command currently under construction.
//   LPSTREAM pstmLiteral [in] - a pointer to the stream containing the
//     literal to be sent.
//   DWORD dwSizeOfStream [in] - the size of the stream.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::SendLiteral(CIMAPCmdInfo *piciCommand,
                                 LPSTREAM pstmLiteral, DWORD dwSizeOfStream)
{
    IMAP_LINE_FRAGMENT *pilfLiteral;

    Assert(m_lRefCount > 0);
    Assert(NULL != pstmLiteral);

    // Create and fill out a fragment structure for the literal
    pilfLiteral = new IMAP_LINE_FRAGMENT;
    if (NULL == pilfLiteral)
        return E_OUTOFMEMORY;

    pilfLiteral->iltFragmentType = iltLITERAL;
    pilfLiteral->ilsLiteralStoreType = ilsSTREAM;
    pilfLiteral->dwLengthOfFragment = dwSizeOfStream;
    pstmLiteral->AddRef(); // We're about to make a copy of this
    pilfLiteral->data.pstmSource = pstmLiteral;
    pilfLiteral->pilfNextFragment = NULL;
    pilfLiteral->pilfPrevFragment = NULL;

    // Queue it up to send out when we receive command continuation from svr
    EnqueueFragment(pilfLiteral, piciCommand->pilqCmdLineQueue);
    return S_OK;
} // SendLiteral



//***************************************************************************
// Function: SendRangelist
//
// Purpose:
//   This function enqueues a rangelist on the send queue of the given
// CIMAPCmdInfo structure. All IMAP commands are constructed in full before
// being submitted to the send machinery, so this function does not actually
// transmit anything. The reason for storing rangelists is so that if the
// rangelist represents a message sequence number range, we can resequence it
// if we receive EXPUNGE responses before the command is transmitted.
//
// Arguments:
//   CIMAPCmdInfo *piciCommand [in] - pointer to an info structure describing
//     the IMAP command currently under construction.
//   IRangeList *prlRangeList [in] - rangelist which will be converted to an
//     IMAP message set during command transmission.
//   boolean bUIDRangeList [in] - TRUE if rangelist represents a UID message
//     set, FALSE if it represents a message sequence number message set.
//     UID message sets are not subject to resequencing after an EXPUNGE
//     response is received from the server.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::SendRangelist(CIMAPCmdInfo *piciCommand,
                                   IRangeList *prlRangeList, boolean bUIDRangeList)
{
    IMAP_LINE_FRAGMENT *pilfRangelist;
    
    Assert(m_lRefCount > 0);
    Assert(NULL != piciCommand);
    Assert(NULL != prlRangeList);

    // Create and fill out a rangelist element
    pilfRangelist = new IMAP_LINE_FRAGMENT;
    if (NULL == pilfRangelist)
        return E_OUTOFMEMORY;

    pilfRangelist->iltFragmentType = iltRANGELIST;
    pilfRangelist->ilsLiteralStoreType = ilsSTRING;
    pilfRangelist->dwLengthOfFragment = 0;
    pilfRangelist->pilfNextFragment = NULL;
    pilfRangelist->pilfPrevFragment = NULL;
    prlRangeList->AddRef();
    pilfRangelist->data.prlRangeList = prlRangeList;

    // Queue it up
    EnqueueFragment(pilfRangelist, piciCommand->pilqCmdLineQueue);
    return S_OK;
} // SendRangelist



//***************************************************************************
// Function: SendPause
//
// Purpose:
//   This function enqueues a pause on the send queue of the given
// CIMAPCmdInfo structure. All IMAP commands are constructed in full before
// being submitted to the send machinery, so this function does not actually
// transmit anything. A pause is used to freeze the send queue until we signal
// it to proceed again. It is used in commands which involve bi-directional
// communication, such as AUTHENTICATE or the IDLE extension.
//
// Arguments:
//   CIMAPCmdInfo *piciCommand [in] - pointer to an info structure describing
//     the IMAP command currently under construction.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::SendPause(CIMAPCmdInfo *piciCommand)
{
    IMAP_LINE_FRAGMENT *pilfPause;
    
    Assert(m_lRefCount > 0);
    Assert(NULL != piciCommand);

    // Create and fill out a pause element
    pilfPause = new IMAP_LINE_FRAGMENT;
    if (NULL == pilfPause)
        return E_OUTOFMEMORY;

    pilfPause->iltFragmentType = iltPAUSE;
    pilfPause->ilsLiteralStoreType = ilsSTRING;
    pilfPause->dwLengthOfFragment = 0;
    pilfPause->pilfNextFragment = NULL;
    pilfPause->pilfPrevFragment = NULL;
    pilfPause->data.pszSource = NULL;

    // Queue it up
    EnqueueFragment(pilfPause, piciCommand->pilqCmdLineQueue);
    return S_OK;
} // SendPause



//***************************************************************************
// Function: SendStop
//
// Purpose:
//   This function enqueues a STOP on the send queue of the given
// CIMAPCmdInfo structure. All IMAP commands are constructed in full before
// being submitted to the send machinery, so this function does not actually
// transmit anything. A STOP is used to freeze the send queue until that
// command is removed from the send queue by tagged command completion.
// Currently only used in the IDLE command, because we don't want to send
// any commands until the server indicates that we are out of IDLE mode.
//
// Arguments:
//   CIMAPCmdInfo *piciCommand [in] - pointer to an info structure describing
//     the IMAP command currently under construction.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::SendStop(CIMAPCmdInfo *piciCommand)
{
    IMAP_LINE_FRAGMENT *pilfStop;
    
    Assert(m_lRefCount > 0);
    Assert(NULL != piciCommand);

    // Create and fill out a stop element
    pilfStop = new IMAP_LINE_FRAGMENT;
    if (NULL == pilfStop)
        return E_OUTOFMEMORY;

    pilfStop->iltFragmentType = iltSTOP;
    pilfStop->ilsLiteralStoreType = ilsSTRING;
    pilfStop->dwLengthOfFragment = 0;
    pilfStop->pilfNextFragment = NULL;
    pilfStop->pilfPrevFragment = NULL;
    pilfStop->data.pszSource = NULL;

    // Queue it up
    EnqueueFragment(pilfStop, piciCommand->pilqCmdLineQueue);
    return S_OK;
} // SendStop



//***************************************************************************
// Function: ParseSvrResponseLine
//
// Purpose:
//   Given a line, this function classifies the line
// as an untagged response, a command continuation, or a tagged response.
// Depending on the classification, the line is then dispatched to helper
// functions to parse and act on the line.
//
// Arguments:
//   IMAP_LINE_FRAGMENT **ppilfLine [in/out] - IMAP line fragment to parse.
//     The given pointer is updated so that it always points to the last
//     IMAP line fragment processed. The caller need only free this fragment.
//     All previous fragments will have already been freed.
//   boolean *lpbTaggedResponse [out] - sets to TRUE if response is tagged.
//   LPSTR lpszTagFromSvr [out] - returns tag here if response was tagged.
//   IMAP_RESPONSE_ID *pirParseResult [out] - identifies the IMAP response,
//     if we recognized it. Otherwise returns irNONE.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::ParseSvrResponseLine (IMAP_LINE_FRAGMENT **ppilfLine,
                                           boolean *lpbTaggedResponse,
                                           LPSTR lpszTagFromSvr,
                                           IMAP_RESPONSE_ID *pirParseResult)
{
    LPSTR p, lpszSvrResponseLine;
    HRESULT hrResult;
    
    // Check arguments
    Assert(m_lRefCount > 0);
    Assert(NULL != ppilfLine);
    Assert(NULL != *ppilfLine);
    Assert(NULL != lpbTaggedResponse);
    Assert(NULL != lpszTagFromSvr);
    Assert(NULL != pirParseResult);

    *lpbTaggedResponse = FALSE; // Assume untagged response to start
    *pirParseResult = irNONE;

    // Make sure we have a line fragment, not a literal
    if (iltLINE != (*ppilfLine)->iltFragmentType) {
        AssertSz(FALSE, "I was passed a literal to parse!");
        return IXP_E_IMAP_RECVR_ERROR;
    }
    else
        lpszSvrResponseLine = (*ppilfLine)->data.pszSource;

    // Determine if server response was command continuation, untagged or tagged
    // Look at first character of response line to figure it out
    hrResult = S_OK;
    p = lpszSvrResponseLine + 1;
    switch(*lpszSvrResponseLine) {

        case cCOMMAND_CONTINUATION_PREFIX:
            if (NULL != m_piciCmdInSending &&
                icAUTHENTICATE_COMMAND == m_piciCmdInSending->icCommandID) {
                LPSTR pszStartOfData;
                DWORD dwLengthOfData;

                if ((*ppilfLine)->dwLengthOfFragment <= 2) {
                    pszStartOfData = NULL;
                    dwLengthOfData = 0;
                }
                else {
                    pszStartOfData = p + 1;
                    dwLengthOfData = (*ppilfLine)->dwLengthOfFragment - 2;
                }
                AuthenticateUser(aeCONTINUE, pszStartOfData, dwLengthOfData);
            }
            else if (NULL != m_piciCmdInSending &&
                icIDLE_COMMAND == m_piciCmdInSending->icCommandID) {
                // Leave busy mode, as we may be sitting idle for some time
                LeaveBusy();
                m_fIDLE = TRUE; // We are now in IDLE mode

                // Check if any commands are waiting to be sent
                if ((NULL != m_piciCmdInSending) && (NULL != m_piciCmdInSending->piciNextCommand))
                    ProcessSendQueue(iseUNPAUSE); // Let's get out of IDLE
            }
            else {
                // Literal continuation response
                // Save response text - assume space follows "+", no big deal if it doesn't
                StrCpyN(m_szLastResponseText, p + 1, ARRAYSIZE(m_szLastResponseText));
                ProcessSendQueue(iseCMD_CONTINUATION); // Go ahead and send the literal
            }

            break; // case cCOMMAND_CONTINUATION_PREFIX


        case cUNTAGGED_RESPONSE_PREFIX:
            if (cSPACE == *p) {
                // Server response fits spec'd form, parse as untagged response

                p += 1; // Advance p to point to next word

                // Untagged responses can be status, server/mailbox status or
                // message status responses.

                // Check for message status responses, first, by seeing
                // if first char of next word is a number
                // *** Consider using isdigit or IsDigit? ***
                // Assert(FALSE) (placeholder)
                if (*p >= '0' && *p <= '9')
                    hrResult = ParseMsgStatusResponse(ppilfLine, p, pirParseResult);
                else {
                    // It wasn't a msg status response, try status response
                    hrResult = ParseStatusResponse(p, pirParseResult);

                    // Check for error. The only error we ignore in this case is
                    // IXP_E_IMAP_UNRECOGNIZED_RESP, since this only means we
                    // should try to parse as a server/mailbox response
                    if (FAILED(hrResult) &&
                        IXP_E_IMAP_UNRECOGNIZED_RESP != hrResult)
                        break;

                    if (irNONE == *pirParseResult)
                        // It wasn't a status response, check if it's server/mailbox resp
                        hrResult = ParseSvrMboxResponse(ppilfLine, p, pirParseResult);
                }
            } // if(cSPACE == *p)
            else
                // Must be a garbled response line
                hrResult = IXP_E_IMAP_SVR_SYNTAXERR;

            break; // case cUNTAGGED_RESPONSE_PREFIX

        default:
            // Assume it's a tagged response

            // Check if response line is big enough to hold one of our tags
            if ((*ppilfLine)->dwLengthOfFragment <= NUM_TAG_CHARS) {
                hrResult = IXP_E_IMAP_UNRECOGNIZED_RESP;
                break;
            }

            // Skip past tag and check for the space
            p = lpszSvrResponseLine + NUM_TAG_CHARS;
            if (cSPACE == *p) {
                // Server response fits spec'd form, parse status response
                *p = '\0'; // Null-terminate at the tag, so we can retrieve it
                
                // Inform caller that this response was tagged, and return tag
                *lpbTaggedResponse = TRUE;
                StrCpyN(lpszTagFromSvr, lpszSvrResponseLine, TAG_BUFSIZE);

                // Now process and return status response
                hrResult = ParseStatusResponse(p + 1, pirParseResult);
            }
            else
                // Must be a garbled response line
                hrResult = IXP_E_IMAP_UNRECOGNIZED_RESP;

            break; // case DEFAULT (assumed to be tagged)
    } // switch (*lpszSvrResponseLine)


    // If an error occurred, return contents of the last processed fragment
    if (FAILED(hrResult))
        StrCpyN(m_szLastResponseText, (*ppilfLine)->data.pszSource, ARRAYSIZE(m_szLastResponseText));

    return hrResult;
} // ParseSvrResponseLine



//***************************************************************************
// Function: ParseStatusResponse
//
// Purpose:
//   This function parses and acts on Status Responses (section 7.1 of
// RFC-1730) (ie, OK/NO/BAD/PREAUTH/BYE). Response codes (eg, ALERT,
// TRYCREATE) are dispatched to a helper function, ParseResponseCode, for
// processing. The human-readable text associated with the response is
// stored in the module variable, m_szLastResponseText.
//
// Arguments:
//   LPSTR lpszStatusResponseLine [in] - a pointer to the text which possibly
//     represents a status response. The text should not include the first
//     part of the line, which identifies the response as tagged ("0000 ")
//     or untagged ("* ").
//   IMAP_RESPONSE_ID *pirParseResult [out] - identifies the IMAP response,
//     if we recognized it. Otherwise does not write a value out. The caller
//     must initialize this variable to irNONE before calling this function.
//
// Returns:
//   HRESULT indicating success or failure. If this function identifies the
// response as a status response, it returns S_OK. If it cannot recognize
// the response, it returns IXP_E_IMAP_UNRECOGNIZED_RESP. If we recognize
// the response but not the response CODE, it returns
// IXP_S_IMAP_UNRECOGNIZED_RESP (success code because we don't want
// to ever send an error to user based on unrecognized response code).
//***************************************************************************
HRESULT CImap4Agent::ParseStatusResponse (LPSTR lpszStatusResponseLine,
                                          IMAP_RESPONSE_ID *pirParseResult)
{
    HRESULT hrResult;
    LPSTR lpszResponseText;

    // Check arguments
    Assert(m_lRefCount > 0);
    Assert(NULL != lpszStatusResponseLine);
    Assert(NULL != pirParseResult);
    Assert(irNONE == *pirParseResult);

    hrResult = S_OK;

    // We can distinguish between all status responses by looking at second char
    // First, determine that string is at least 1 character long
    if ('\0' == *lpszStatusResponseLine)
        return IXP_E_IMAP_UNRECOGNIZED_RESP; // It's not a status response that we understand

    lpszResponseText = lpszStatusResponseLine;
    switch (*(lpszStatusResponseLine+1)) {
        int iResult;
    
        case 'k':
        case 'K': // Possibly the "OK" Status response
            iResult = StrCmpNI(lpszStatusResponseLine, "OK ", 3);
            if (0 == iResult) {
                // Definitely an "OK" status response
                *pirParseResult = irOK_RESPONSE;
                lpszResponseText += 3;                
            }           
            break; // case 'K' for possible "OK"
        
        case 'o':
        case 'O': // Possibly the "NO" status response
            iResult = StrCmpNI(lpszStatusResponseLine, "NO ", 3);
            if (0 == iResult) {
                // Definitely a "NO" response
                *pirParseResult = irNO_RESPONSE;
                lpszResponseText += 3;
            }
            break; // case 'O' for possible "NO"

        case 'a':
        case 'A': // Possibly the "BAD" status response
            iResult = StrCmpNI(lpszStatusResponseLine, "BAD ", 4);
            if (0 == iResult) {
                // Definitely a "BAD" response
                *pirParseResult = irBAD_RESPONSE;
                lpszResponseText += 4;
            }
            break; // case 'A' for possible "BAD"

        case 'r':
        case 'R': // Possibly the "PREAUTH" status response
            iResult = StrCmpNI(lpszStatusResponseLine, "PREAUTH ", 8);
            if (0 == iResult) {
                // Definitely a "PREAUTH" response:
                // PREAUTH is issued only as a greeting - check for proper context
                // If improper context, ignore PREAUTH response
                if (ssConnecting == m_ssServerState) {
                    *pirParseResult = irPREAUTH_RESPONSE;
                    lpszResponseText += 8;
                    m_ssServerState = ssAuthenticated;                    
                }                
            }
            break; // case 'R' for possible "PREAUTH"

        case 'y':
        case 'Y': // Possibly the "BYE" status response
            iResult = StrCmpNI(lpszStatusResponseLine, "BYE ", 4);
            if (0 == iResult) {
                // Definitely a "BYE" response:
                // Set server state to not connected
                *pirParseResult = irBYE_RESPONSE;
                lpszResponseText += 4;
                m_ssServerState = ssNotConnected;                
            }
            break; // case 'Y' for possible "BYE"
    } // switch (*(lpszStatusResponseLine+1))

    // If we recognized the command, proceed to process the response code
    if (SUCCEEDED(hrResult) && irNONE != *pirParseResult) {
        // We recognized the command, so lpszResponseText points to resp_text
        // as defined in RFC-1730. Look for optional response code
        if ('[' == *lpszResponseText) {
            HRESULT hrResponseCodeResult;

            hrResponseCodeResult = ParseResponseCode(lpszResponseText + 1);
            if (FAILED(hrResponseCodeResult))
                hrResult = hrResponseCodeResult;
        }
        else
            // No response code, record response text for future retrieval
            StrCpyN(m_szLastResponseText, lpszResponseText, ARRAYSIZE(m_szLastResponseText));
    }

    // If we didn't recognize the command, translate hrResult
    if (SUCCEEDED(hrResult) && irNONE == *pirParseResult)
        hrResult = IXP_E_IMAP_UNRECOGNIZED_RESP;

    return hrResult;

} // ParseStatusResponse



//***************************************************************************
// Function: ParseResponseCode
//
// Purpose:
//   This function parses and acts on the response code which may be
// returned with a status response (eg, PERMANENTFLAGS or ALERT). It is
// called by ParseStatusResponse upon detection of a response code. This
// function saves the human-readable text of the response code to
// m_szLastResponseLine.
//
// Arguments:
//   LPSTR lpszResponseCode [in] - a pointer to the response code portion
//     of a response line, omitting the opening bracket ("[").
//
// Returns:
//   HRESULT indicating success or failure. If we cannot recognize the
// response code, we return IXP_S_IMAP_UNRECOGNIZED_RESP.
//***************************************************************************
HRESULT CImap4Agent::ParseResponseCode(LPSTR lpszResponseCode)
{
    HRESULT hrResult;
    WORD wHashValue;

    // Check arguments
    Assert(m_lRefCount > 0);
    Assert(NULL != lpszResponseCode);

    hrResult = IXP_S_IMAP_UNRECOGNIZED_RESP;

    switch (*lpszResponseCode) {
        int iResult;

        case 'A':
        case 'a': // Possibly the "ALERT" response code
            iResult = StrCmpNI(lpszResponseCode, "ALERT] ", 7);
            if (0 == iResult) {
                IMAP_RESPONSE irIMAPResponse;

                // Definitely the "ALERT" response code:
                irIMAPResponse.wParam = 0;
                irIMAPResponse.lParam = 0;
                irIMAPResponse.hrResult = S_OK;
                irIMAPResponse.lpszResponseText = lpszResponseCode + 7;
                irIMAPResponse.irtResponseType = irtSERVER_ALERT;
                OnIMAPResponse(m_pCBHandler, &irIMAPResponse);

                hrResult = S_OK;
                break;
            }

            // *** FALL THROUGH *** to default case

        case 'P':
        case 'p': // Possibly the "PARSE" or "PERMANENTFLAGS" response code
            iResult = StrCmpNI(lpszResponseCode, "PERMANENTFLAGS ", 15);
            if (0 == iResult) {
                IMAP_MSGFLAGS PermaFlags;
                LPSTR p;
                DWORD dwNumBytesRead;

                // Definitely the "PERMANENTFLAGS" response code:                
                // Parse flag list
                p = lpszResponseCode + 15; // p now points to start of flag list
                hrResult = ParseMsgFlagList(p, &PermaFlags, &dwNumBytesRead);
                if (SUCCEEDED(hrResult)) {
                    IMAP_RESPONSE irIMAPResponse;
                    IIMAPCallback *pCBHandler;

                    // Record response text
                    p += dwNumBytesRead + 3; // p now points to response text
                    StrCpyN(m_szLastResponseText, p, ARRAYSIZE(m_szLastResponseText));

                    GetTransactionID(&irIMAPResponse.wParam, &irIMAPResponse.lParam,
                        &pCBHandler, irPERMANENTFLAGS_RESPONSECODE);
                    irIMAPResponse.hrResult = S_OK;
                    irIMAPResponse.lpszResponseText = m_szLastResponseText;
                    irIMAPResponse.irtResponseType = irtPERMANENT_FLAGS;
                    irIMAPResponse.irdResponseData.imfImapMessageFlags = PermaFlags;
                    OnIMAPResponse(pCBHandler, &irIMAPResponse);
                }
                break;
            } // end of PERMANENTFLAGS response code

            iResult = StrCmpNI(lpszResponseCode, "PARSE] ", 7);
            if (0 == iResult) {
                IMAP_RESPONSE irIMAPResponse;

                // Definitely the "PARSE" response code:
                irIMAPResponse.wParam = 0;
                irIMAPResponse.lParam = 0;
                irIMAPResponse.hrResult = S_OK;
                irIMAPResponse.lpszResponseText = lpszResponseCode + 7;
                irIMAPResponse.irtResponseType = irtPARSE_ERROR;
                OnIMAPResponse(m_pCBHandler, &irIMAPResponse);

                hrResult = S_OK;
                break;
            } // end of PARSE response code

            // *** FALL THROUGH *** to default case

        case 'R':
        case 'r': // Possibly "READ-ONLY" or "READ-WRITE" response
            iResult = StrCmpNI(lpszResponseCode, "READ-WRITE] ", 12);
            if (0 == iResult) {
                IMAP_RESPONSE irIMAPResponse;
                IIMAPCallback *pCBHandler;

                // Definitely the "READ-WRITE" response code:
                hrResult = S_OK;
               
                // Record this for enforcement purposes
                m_bCurrentMboxReadOnly = FALSE;

                // Record response text for future reference
                StrCpyN(m_szLastResponseText, lpszResponseCode + 12, ARRAYSIZE(m_szLastResponseText));

                GetTransactionID(&irIMAPResponse.wParam, &irIMAPResponse.lParam,
                    &pCBHandler, irREADWRITE_RESPONSECODE);
                irIMAPResponse.hrResult = S_OK;
                irIMAPResponse.lpszResponseText = m_szLastResponseText;
                irIMAPResponse.irtResponseType = irtREADWRITE_STATUS;
                irIMAPResponse.irdResponseData.bReadWrite = TRUE;
                OnIMAPResponse(pCBHandler, &irIMAPResponse);

                break;
            } // end of READ-WRITE response
            
            iResult = StrCmpNI(lpszResponseCode, "READ-ONLY] ", 11);
            if (0 == iResult) {
                IMAP_RESPONSE irIMAPResponse;
                IIMAPCallback *pCBHandler;

                // Definitely the "READ-ONLY" response code:
                hrResult = S_OK;
               
                // Record this for enforcement purposes
                m_bCurrentMboxReadOnly = TRUE;

                // Record response text for future reference
                StrCpyN(m_szLastResponseText, lpszResponseCode + 11, ARRAYSIZE(m_szLastResponseText));

                GetTransactionID(&irIMAPResponse.wParam, &irIMAPResponse.lParam,
                    &pCBHandler, irREADONLY_RESPONSECODE);
                irIMAPResponse.hrResult = S_OK;
                irIMAPResponse.lpszResponseText = m_szLastResponseText;
                irIMAPResponse.irtResponseType = irtREADWRITE_STATUS;
                irIMAPResponse.irdResponseData.bReadWrite = FALSE;
                OnIMAPResponse(pCBHandler, &irIMAPResponse);

                break;
            } // end of READ-ONLY response

            // *** FALL THROUGH *** to default case

        case 'T':
        case 't': // Possibly the "TRYCREATE" response
            iResult = StrCmpNI(lpszResponseCode, "TRYCREATE] ", 11);
            if (0 == iResult) {
                IMAP_RESPONSE irIMAPResponse;
                IIMAPCallback *pCBHandler;

                // Definitely the "TRYCREATE" response code:
                hrResult = S_OK;
               
                StrCpyN(m_szLastResponseText, lpszResponseCode + 11, ARRAYSIZE(m_szLastResponseText));

                GetTransactionID(&irIMAPResponse.wParam, &irIMAPResponse.lParam,
                    &pCBHandler, irTRYCREATE_RESPONSECODE);
                irIMAPResponse.hrResult = S_OK;
                irIMAPResponse.lpszResponseText = m_szLastResponseText;
                irIMAPResponse.irtResponseType = irtTRYCREATE;
                OnIMAPResponse(pCBHandler, &irIMAPResponse);
                break;
            }

            // *** FALL THROUGH *** to default case

        case 'U':
        case 'u': // Possibly the "UIDVALIDITY" or "UNSEEN" response codes
            iResult = StrCmpNI(lpszResponseCode, "UIDVALIDITY ", 12);
            if (0 == iResult) {
                LPSTR p, lpszEndOfNumber;
                IMAP_RESPONSE irIMAPResponse;
                IIMAPCallback *pCBHandler;

                // Definitely the "UIDVALIDITY" response code:
                hrResult = S_OK;
               
                // Return value to our caller so they can determine sync issues                
                p = lpszResponseCode + 12; // p points to UID number
                lpszEndOfNumber = StrChr(p, ']'); // Find closing bracket
                if (NULL == lpszEndOfNumber) {
                    hrResult = IXP_E_IMAP_SVR_SYNTAXERR;
                    break;
                }

                *lpszEndOfNumber = '\0'; // Null-terminate the number
                AssertSz(cSPACE == *(lpszEndOfNumber+1), "Flakey Server?");

                StrCpyN(m_szLastResponseText, lpszEndOfNumber + 2, ARRAYSIZE(m_szLastResponseText));

                GetTransactionID(&irIMAPResponse.wParam, &irIMAPResponse.lParam,
                    &pCBHandler, irUIDVALIDITY_RESPONSECODE);
                irIMAPResponse.hrResult = S_OK;
                irIMAPResponse.lpszResponseText = m_szLastResponseText;
                irIMAPResponse.irtResponseType = irtUIDVALIDITY;
                irIMAPResponse.irdResponseData.dwUIDValidity = StrToUint(p);
                OnIMAPResponse(pCBHandler, &irIMAPResponse);
                break;
            } // end of UIDVALIDITY response code

            iResult = StrCmpNI(lpszResponseCode, "UNSEEN ", 7);
            if (0 == iResult) {
                LPSTR p, lpszEndOfNumber;
                IMAP_RESPONSE irIMAPResponse;
                MBOX_MSGCOUNT mcMsgCount;

                // Definitely the "UNSEEN" response code:
                hrResult = S_OK;
               
                // Record the returned number for reference during new mail DL
                p = lpszResponseCode + 7; // p now points to first unseen msg num
                lpszEndOfNumber = StrChr(p, ']'); // Find closing bracket
                if (NULL == lpszEndOfNumber) {
                    hrResult = IXP_E_IMAP_SVR_SYNTAXERR;
                    break;
                }

                *lpszEndOfNumber = '\0'; // Null-terminate the number

                // Store response code for notification after command completion
                mcMsgCount = mcMsgCount_INIT;
                mcMsgCount.dwUnseen = StrToUint(p);
                mcMsgCount.bGotUnseenResponse = TRUE;
                irIMAPResponse.wParam = 0;
                irIMAPResponse.lParam = 0;
                irIMAPResponse.hrResult = S_OK;
                irIMAPResponse.lpszResponseText = NULL; // Not relevant here
                irIMAPResponse.irtResponseType = irtMAILBOX_UPDATE;
                irIMAPResponse.irdResponseData.pmcMsgCount = &mcMsgCount;
                OnIMAPResponse(m_pCBHandler, &irIMAPResponse);

                AssertSz(cSPACE == *(lpszEndOfNumber+1), "Flakey Server?");

                StrCpyN(m_szLastResponseText, lpszEndOfNumber + 2, ARRAYSIZE(m_szLastResponseText));
                break;
            } // end of UNSEEN response code

            // *** FALL THROUGH *** to default case

        default:
            StrCpyN(m_szLastResponseText, lpszResponseCode, ARRAYSIZE(m_szLastResponseText));
            break; // Default case: response code not recognized
    } // switch(*lpszResponseCode)

    return hrResult;

} // ParseResponseCode



//***************************************************************************
// Function: ParseSvrMboxResponse
//
// Purpose:
//   This function parses and acts on Server and Mailbox Status Responses
// from the IMAP server (see section 7.2 of RFC-1730) (eg, CAPABILITY and
// SEARCH responses).
//
// Arguments:
//   IMAP_LINE_FRAGMENT **ppilfLine [in/out] - a pointer to the IMAP line
//     fragment to parse. It is used to retrieve the literals sent with the
//     response. This pointer is updated so that it always points to the last
//     processed fragment. The caller need only free the last fragment. All
//     other fragments will already be freed when this function returns.
//   LPSTR lpszSvrMboxResponseLine [in] - a pointer to the svr/mbox response
//     line, omitting the first part of the line which identifies the response
//     as tagged ("0001 ") or untagged ("* ").
//   IMAP_RESPONSE_ID *pirParseResult [out] - identifies the IMAP response,
//     if we recognized it. Otherwise does not write a value out. The caller
//     must initialize this variable to irNONE before calling this function.
//
// Returns:
//   HRESULT indicating success or failure. If the response is not recognized,
// this function returns IXP_E_IMAP_UNRECOGNIZED_RESP.
//***************************************************************************
HRESULT CImap4Agent::ParseSvrMboxResponse (IMAP_LINE_FRAGMENT **ppilfLine,
                                           LPSTR lpszSvrMboxResponseLine,
                                           IMAP_RESPONSE_ID *pirParseResult)
{
    LPSTR pszTok;
    HRESULT hrResult;

    // Check arguments
    Assert(m_lRefCount > 0);
    Assert(NULL != ppilfLine);
    Assert(NULL != *ppilfLine);
    Assert(NULL != lpszSvrMboxResponseLine);
    Assert(NULL != pirParseResult);
    Assert(irNONE == *pirParseResult);

    hrResult = S_OK;

    // We can ID all svr/mbox status responses by looking at second char
    // First, determine that the line is at least 1 character long
    if ('\0' == *lpszSvrMboxResponseLine)
        return IXP_E_IMAP_UNRECOGNIZED_RESP; // It's not a svr/mbox response

    switch (*(lpszSvrMboxResponseLine+1)) {
        int iResult;

        case 'a':
        case 'A': // Possibly the "CAPABILITY" response
            iResult = StrCmpNI(lpszSvrMboxResponseLine, "CAPABILITY ", 11);
            if (0 == iResult) {
                LPSTR p;

                // Definitely a "CAPABILITY" response
                *pirParseResult = irCAPABILITY_RESPONSE;

                // Search for and record known capabilities, discard unknowns
                p = lpszSvrMboxResponseLine + 11; // p points to first cap. token

                pszTok = p;
                p = StrTokEx(&pszTok, g_szSpace); // p now points to next token
                while (NULL != p) {
                    parseCapability(p); // Record capabilities which we recognize
                    p = StrTokEx(&pszTok, g_szSpace); // Grab next capability token
                }
            } // if(0 == iResult)
            break; // case 'A' for possible "CAPABILITY"

        case 'i':
        case 'I': // Possibly the "LIST" response:
            iResult = StrCmpNI(lpszSvrMboxResponseLine, "LIST ", 5);
            if (0 == iResult) {
                // Definitely a "LIST" response
                *pirParseResult = irLIST_RESPONSE;
                hrResult = ParseListLsubResponse(ppilfLine,
                    lpszSvrMboxResponseLine + 5, irLIST_RESPONSE);
            } // if (0 == iResult)
            break; // case 'I' for possible "LIST"

        case 's':
        case 'S': // Possibly the "LSUB" response:
            iResult = StrCmpNI(lpszSvrMboxResponseLine, "LSUB ", 5);
            if (0 == iResult) {
                // Definitely a "LSUB" response:
                *pirParseResult = irLSUB_RESPONSE;
                hrResult = ParseListLsubResponse(ppilfLine,
                    lpszSvrMboxResponseLine + 5, irLSUB_RESPONSE);
            } // if (0 == iResult)
            break; // case 'S' for possible "LSUB"

        case 'e':
        case 'E': // Possibly the "SEARCH" response:
            iResult = StrCmpNI(lpszSvrMboxResponseLine, "SEARCH", 6);
            if (0 == iResult) {
                // Definitely a "SEARCH" response:
                *pirParseResult = irSEARCH_RESPONSE;

                // Response can be "* SEARCH" or "* SEARCH <nums>". Check for null case
                if (cSPACE == *(lpszSvrMboxResponseLine + 6))
                    hrResult = ParseSearchResponse(lpszSvrMboxResponseLine + 7);
            }
            break; // case 'E' for possible "SEARCH"

        case 'l':
        case 'L': // Possibly the "FLAGS" response:
            iResult = StrCmpNI(lpszSvrMboxResponseLine, "FLAGS ", 6);
            if (0 == iResult) {
                IMAP_MSGFLAGS FlagsResult;
                DWORD dwThrowaway;

                // Definitely a "FLAGS" response:
                *pirParseResult = irFLAGS_RESPONSE;

                // Parse flag list
                hrResult = ParseMsgFlagList(lpszSvrMboxResponseLine + 6,
                    &FlagsResult, &dwThrowaway);

                if (SUCCEEDED(hrResult)) {
                    IMAP_RESPONSE irIMAPResponse;
                    IIMAPCallback *pCBHandler;

                    GetTransactionID(&irIMAPResponse.wParam, &irIMAPResponse.lParam,
                        &pCBHandler, irFLAGS_RESPONSE);
                    irIMAPResponse.hrResult = S_OK;
                    irIMAPResponse.lpszResponseText = NULL; // Not relevant
                    irIMAPResponse.irtResponseType = irtAPPLICABLE_FLAGS;
                    irIMAPResponse.irdResponseData.imfImapMessageFlags = FlagsResult;
                    OnIMAPResponse(pCBHandler, &irIMAPResponse);
                }
            } // if (0 == iResult)
            break; // Case 'L' for possible "FLAGS" response

        case 't':
        case 'T': // Possibly the "STATUS" response:
            iResult = StrCmpNI(lpszSvrMboxResponseLine, "STATUS ", 7);
            if (0 == iResult) {
                // Definitely a "STATUS" response
                *pirParseResult = irSTATUS_RESPONSE;
                hrResult = ParseMboxStatusResponse(ppilfLine,
                    lpszSvrMboxResponseLine + 7);
            } // if (0 == iResult)
            break; // Case 'T' for possible "STATUS" response

    } // case(*(lpszSvrMboxResponseLine+1))

    // Did we recognize the response? Return error if we didn't
    if (irNONE == *pirParseResult && SUCCEEDED(hrResult))
        hrResult = IXP_E_IMAP_UNRECOGNIZED_RESP;

    return hrResult;

} // ParseSvrMboxResponse



//***************************************************************************
// Function: ParseMsgStatusResponse
//
// Purpose:
//   This function parses and acts on Message Status Responses from the IMAP
// server (see section 7.3 of RFC-1730) (eg, FETCH and EXISTS responses).
//
// Arguments:
//   IMAP_LINE_FRAGMENT **ppilfLine [in/out] - a pointer to the IMAP line
//     fragment to parse. It is used to retrieve the literals sent with the
//     response. This pointer is updated so that it always points to the last
//     processed fragment. The caller need only free the last fragment. All
//     other fragments will already be freed when this function returns.
//   LPSTR lpszMsgResponseLine [in] - pointer to response line, starting at
//     the number argument.
//   IMAP_RESPONSE_ID *pirParseResult [out] - identifies the IMAP response,
//     if we recognized it. Otherwise does not write a value out. The caller
//     must initialize this variable to irNONE before calling this function.
//
// Returns:
//   HRESULT indicating success or failure. If the response is not recognized,
// this function returns IXP_E_IMAP_UNRECOGNIZED_RESP.
//***************************************************************************
HRESULT CImap4Agent::ParseMsgStatusResponse (IMAP_LINE_FRAGMENT **ppilfLine,
                                             LPSTR lpszMsgResponseLine,
                                             IMAP_RESPONSE_ID *pirParseResult)
{
    HRESULT hrResult;
    WORD wHashValue;
    DWORD dwNumberArg;
    LPSTR p;

    // Check arguments
    Assert(m_lRefCount > 0);
    Assert(NULL != ppilfLine);
    Assert(NULL != *ppilfLine);
    Assert(NULL != lpszMsgResponseLine);
    Assert(NULL != pirParseResult);
    Assert(irNONE == *pirParseResult);

    hrResult = S_OK;

    // First, fetch the number argument
    p = StrChr(lpszMsgResponseLine, cSPACE); // Find the end of the number
    if (NULL == p)
        return IXP_E_IMAP_SVR_SYNTAXERR;

    dwNumberArg = StrToUint(lpszMsgResponseLine);
    p += 1; // p now points to start of message response identifier

    switch (*p) {
        int iResult;

        case 'E':
        case 'e': // Possibly the "EXISTS" or "EXPUNGE" response
            iResult = lstrcmpi(p, "EXISTS");
            if (0 == iResult) {
                IMAP_RESPONSE irIMAPResponse;
                MBOX_MSGCOUNT mcMsgCount;

                // Definitely the "EXISTS" response:
                *pirParseResult = irEXISTS_RESPONSE;

                // Record mailbox size for notification at completion of command
                mcMsgCount = mcMsgCount_INIT;
                mcMsgCount.dwExists = dwNumberArg;
                mcMsgCount.bGotExistsResponse = TRUE;
                irIMAPResponse.wParam = 0;
                irIMAPResponse.lParam = 0;
                irIMAPResponse.hrResult = S_OK;
                irIMAPResponse.lpszResponseText = NULL; // Not relevant here
                irIMAPResponse.irtResponseType = irtMAILBOX_UPDATE;
                irIMAPResponse.irdResponseData.pmcMsgCount = &mcMsgCount;
                OnIMAPResponse(m_pCBHandler, &irIMAPResponse);
                break;
            }

            iResult = lstrcmpi(p, "EXPUNGE");
            if (0 == iResult) {
                IMAP_RESPONSE irIMAPResponse;

                // Definitely the "EXPUNGE" response: Inform caller via callback
                *pirParseResult = irEXPUNGE_RESPONSE;

                irIMAPResponse.wParam = 0;
                irIMAPResponse.lParam = 0;
                irIMAPResponse.hrResult = S_OK;
                irIMAPResponse.lpszResponseText = NULL; // Not relevant
                irIMAPResponse.irtResponseType = irtDELETED_MSG;
                irIMAPResponse.irdResponseData.dwDeletedMsgSeqNum = dwNumberArg;
                OnIMAPResponse(m_pCBHandler, &irIMAPResponse);
                break;
            }

            break; // Case 'E' or 'e' for possible "EXISTS" or "EXPUNGE" response


        case 'R':
        case 'r': // Possibly the "RECENT" response
            iResult = lstrcmpi(p, "RECENT");
            if (0 == iResult) {
                IMAP_RESPONSE irIMAPResponse;
                MBOX_MSGCOUNT mcMsgCount;

                // Definitely the "RECENT" response:
                *pirParseResult = irRECENT_RESPONSE;
                
                // Record number for future reference
                mcMsgCount = mcMsgCount_INIT;
                mcMsgCount.dwRecent = dwNumberArg;
                mcMsgCount.bGotRecentResponse = TRUE;
                irIMAPResponse.wParam = 0;
                irIMAPResponse.lParam = 0;
                irIMAPResponse.hrResult = S_OK;
                irIMAPResponse.lpszResponseText = NULL; // Not relevant here
                irIMAPResponse.irtResponseType = irtMAILBOX_UPDATE;
                irIMAPResponse.irdResponseData.pmcMsgCount = &mcMsgCount;
                OnIMAPResponse(m_pCBHandler, &irIMAPResponse);
            }

            break; // Case 'R' or 'r' for possible "RECENT" response


        case 'F':
        case 'f': // Possibly the "FETCH" response
            iResult = StrCmpNI(p, "FETCH ", 6);
            if (0 == iResult) {
                // Definitely the "FETCH" response
                *pirParseResult = irFETCH_RESPONSE;

                p += 6;
                hrResult = ParseFetchResponse(ppilfLine, dwNumberArg, p);
            } // if (0 == iResult)
            break; // Case 'F' or 'f' for possible "FETCH" response
    } // switch(*p)

    // Did we recognize the response? Return error if we didn't
    if (irNONE == *pirParseResult && SUCCEEDED(hrResult))
        hrResult = IXP_E_IMAP_UNRECOGNIZED_RESP;

    return hrResult;

} // ParseMsgStatusResponse



//***************************************************************************
// Function: ParseListLsubResponse
//
// Purpose:
//   This function parses LIST and LSUB responses and invokes the
// ListLsubResponseNotification() callback to inform the user.
//
// Arguments:
//   IMAP_LINE_FRAGMENT **ppilfLine [in/out] - a pointer to the current
//     IMAP response fragment. This is used to retrieve the next fragment
//     in the chain (literal or line) since literals may be sent with LIST
//     responses. This pointer is always updated to point to the fragment
//     currently in use, so that the caller may free the last one himself.
//   LPSTR lpszListResponse [in] - actually can be LIST or LSUB, but I don't
//     want to have to type "ListLsub" all the time. This points into the
//     middle of the LIST/LSUB response, where the mailbox_list begins (see
//     RFC1730, Formal Syntax). In other words, the caller should skip past
//     the initial "* LIST " or "* LSUB ", and so this ptr should point to
//     a "(".
//   IMAP_RESPONSE_ID irListLsubID [in] - either irLIST_RESPONSE or
//     irLSUB_RESPONSE. This information is required so that we can retrieve
//     the transaction ID associated with the response.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::ParseListLsubResponse(IMAP_LINE_FRAGMENT **ppilfLine,
                                           LPSTR lpszListResponse,
                                           IMAP_RESPONSE_ID irListLsubID)
{
    LPSTR p, lpszClosingParenthesis, pszTok;
    HRESULT hrResult = S_OK;
    HRESULT hrTranslateResult = E_FAIL;
    IMAP_MBOXFLAGS MboxFlags;
    char cHierarchyChar;
    IMAP_RESPONSE irIMAPResponse;
    IIMAPCallback *pCBHandler;
    IMAP_LISTLSUB_RESPONSE *pillrd;
    LPSTR pszDecodedMboxName = NULL;
    LPSTR pszMailboxName = NULL;

    Assert(m_lRefCount > 0);
    Assert(NULL != ppilfLine);
    Assert(NULL != *ppilfLine);
    Assert(NULL != lpszListResponse);
    Assert(irLIST_RESPONSE == irListLsubID ||
           irLSUB_RESPONSE == irListLsubID);

    // We received an untagged LIST/LSUB response
    // lpszListResponse = <flag list> <hierarchy char> <mailbox name>
    if ('(' != *lpszListResponse)
        return IXP_E_IMAP_SVR_SYNTAXERR; // We expect an opening parenthesis
                
    p = lpszListResponse + 1; // p now points to start of first flag token
                
    // Find position of closing parenthesis. I don't like the
    // lack of efficiency, but I can fix this later. Assert(FALSE) (placeholder)
    lpszClosingParenthesis = StrChr(p, ')');
    if (NULL == lpszClosingParenthesis)
        return IXP_E_IMAP_SVR_SYNTAXERR; // We expect a closing parenthesis

    // Now process each mailbox flag returned by LIST/LSUB
    *lpszClosingParenthesis = '\0'; // Null-terminate flag list
    MboxFlags = IMAP_MBOX_NOFLAGS;
    pszTok = p;
    p = StrTokEx(&pszTok, g_szSpace); // Null-terminate first flag token
    while (NULL != p) {
        MboxFlags |= ParseMboxFlag(p);
        p = StrTokEx(&pszTok, g_szSpace); // Grab next flag token
    }
        
    // Next, grab the hierarchy character, and advance p
    // Server either sends (1) "<quoted char>" or (2) NIL
    p = lpszClosingParenthesis + 1; // p now points past flag list
    if (cSPACE == *p) {
        LPSTR pszHC = NULL;
        DWORD dwLengthOfHC;

        p += 1; // p now points to start of hierarchy char spec
        
        hrResult = NStringToString(ppilfLine, &pszHC, &dwLengthOfHC, &p);
        if (FAILED(hrResult))
            return hrResult;

        if (hrIMAP_S_NIL_NSTRING == hrResult)
            cHierarchyChar = '\0'; // Got a "NIL" for hierarchy char
        else if (hrIMAP_S_QUOTED == hrResult) {
            if (1 != dwLengthOfHC)
                return IXP_E_IMAP_SVR_SYNTAXERR; // We should only exactly ONE char back!
            else
                cHierarchyChar = pszHC[0];
        }
        else {
            // It's a literal, or something else unexpected
            MemFree(pszHC);
            return IXP_E_IMAP_SVR_SYNTAXERR;
        }
        MemFree(pszHC);

        // p now points past the closing quote (thanks to NStringToString)
    }
    else
        return IXP_E_IMAP_SVR_SYNTAXERR;


    if (cSPACE != *p)
        return IXP_E_IMAP_SVR_SYNTAXERR;


    // Grab the mailbox name - assume size of lpszListResponse is
    // whatever p has already uncovered. We expect nothing past
    // this point, so we should be safe.
    p += 1;
    hrResult = AStringToString(ppilfLine, &pszMailboxName, NULL, &p);
    if (FAILED(hrResult))
        return hrResult;

    // Convert the mailbox name from UTF7 to MultiByte and remember the result
    hrTranslateResult = _ModifiedUTF7ToMultiByte(pszMailboxName, &pszDecodedMboxName);
    if (FAILED(hrTranslateResult)) {
        hrResult = hrTranslateResult;
        goto error;
    }

    // Make sure the command line is finished (debug only)
    Assert('\0' == *p);

    // Notify the caller of our findings
    GetTransactionID(&irIMAPResponse.wParam, &irIMAPResponse.lParam,
        &pCBHandler, irListLsubID);
    irIMAPResponse.hrResult = hrTranslateResult; // Could be IXP_S_IMAP_VERBATIM_MBOX
    irIMAPResponse.lpszResponseText = NULL; // Not relevant
    irIMAPResponse.irtResponseType = irtMAILBOX_LISTING;

    pillrd = &irIMAPResponse.irdResponseData.illrdMailboxListing;
    pillrd->pszMailboxName = pszDecodedMboxName;
    pillrd->imfMboxFlags = MboxFlags;
    pillrd->cHierarchyChar = cHierarchyChar;
    
    OnIMAPResponse(pCBHandler, &irIMAPResponse);

error:
    if (NULL != pszDecodedMboxName)
        MemFree(pszDecodedMboxName);

    if (NULL != pszMailboxName)
        MemFree(pszMailboxName);

    return hrResult;
} // ParseListLsubResponse



//***************************************************************************
// Function: ParseMboxFlag
//
// Purpose:
//   Given a mailbox_list flag (see RFC1730, Formal Syntax), this function
// returns the IMAP_MBOX_* value which corresponds to that mailbox flag.
// For instance, given the string, "\Noinferiors", this function returns
// IMAP_MBOX_NOINFERIORS.
//
// Arguments:
//   LPSTR lpszFlagToken [in] - a null-terminated string representing a
// mailbox_list flag.
//
// Returns:
//   IMAP_MBOXFLAGS value. If flag is unrecognized, IMAP_MBOX_NOFLAGS is
// returned.
//***************************************************************************
IMAP_MBOXFLAGS CImap4Agent::ParseMboxFlag(LPSTR lpszFlagToken)
{
    Assert(m_lRefCount > 0);
    Assert(NULL != lpszFlagToken);

    // We can identify the mailbox flags we know about by looking at the
    // fourth character of the flag name. $REVIEW: you don't have to check
    // the initial backslash, during lstrcmpi call in switch statement

    // First, check that there are at least three characters
    if ('\\' != *lpszFlagToken ||
        '\0' == *(lpszFlagToken + 1) ||
        '\0' == *(lpszFlagToken + 2))
        return IMAP_MBOX_NOFLAGS;

    switch (*(lpszFlagToken + 3)) {
        int iResult;

        case 'R':
        case 'r': // Possible "\Marked" flag
            iResult = lstrcmpi(lpszFlagToken, "\\Marked");
            if (0 == iResult)
                return IMAP_MBOX_MARKED; // Definitely the \Marked flag

            break; // case 'r': // Possible "\Marked" flag

        case 'I':
        case 'i': // Possible "\Noinferiors" flag
            iResult = lstrcmpi(lpszFlagToken, "\\Noinferiors");
            if (0 == iResult)
                return IMAP_MBOX_NOINFERIORS; // Definitely the \Noinferiors flag

            break; // case 'i': // Possible "\Noinferiors" flag

        case 'S':
        case 's': // Possible "\Noselect" flag
            iResult = lstrcmpi(lpszFlagToken, "\\Noselect");
            if (0 == iResult)
                return IMAP_MBOX_NOSELECT; // Definitely the \Noselect flag

            break; // case 's': // Possible "\Noselect" flag

        case 'M':
        case 'm': // Possible "\Unmarked" flag
            iResult = lstrcmpi(lpszFlagToken, "\\Unmarked");
            if (0 == iResult)
                return IMAP_MBOX_UNMARKED;

            break; // case 'm': // Possible "\Unmarked" flag
    } // switch (*(lpszFlagToken + 3))

    return IMAP_MBOX_NOFLAGS;
} // ParseMboxFlag



//***************************************************************************
// Function: ParseFetchResponse
//
// Purpose:
//   This function parses FETCH responses and calls the
// UpdateMsgNotification() callback to inform the user.
//
// Arguments:
//   IMAP_LINE_FRAGMENT **ppilfLine [in/out] - a pointer to the current
//     IMAP response fragment. This is used to retrieve the next fragment
//     in the chain (literal or line) since literals may be sent with FETCH
//     responses. This pointer is always updated to point to the fragment
//     currently in use, so that the caller may free the last one himself.
//   DWORD dwMsgSeqNum [in] - message sequence number of this fetch resp.
//   LPSTR lpszFetchResp [in] - a pointer to the portion of the fetch
//     response after "<num> FETCH " (the msg_att portion of a message_data
//     item. See RFC1730 formal syntax).
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::ParseFetchResponse (IMAP_LINE_FRAGMENT **ppilfLine,
                                         DWORD dwMsgSeqNum, LPSTR lpszFetchResp)
{
    LPSTR p;
    FETCH_CMD_RESULTS_EX fetchResults;
	FETCH_CMD_RESULTS    fcrOldFetchStruct;
    IMAP_RESPONSE irIMAPResponse;
    HRESULT hrResult;

    Assert(m_lRefCount > 0);
    Assert(NULL != ppilfLine);
    Assert(NULL != *ppilfLine);
    Assert(0 != dwMsgSeqNum);
    Assert(NULL != lpszFetchResp);

    // Initialize variables
    ZeroMemory(&fetchResults, sizeof(fetchResults));

    p = lpszFetchResp;
    if ('(' != *p) {
        hrResult = IXP_E_IMAP_SVR_SYNTAXERR; // We expect opening parenthesis
        goto exit;
    }


    // Parse each FETCH response tag (eg, RFC822, FLAGS, etc.)
    hrResult = S_OK;
    do {
        // We'll identify FETCH tags based on the first character of tag
        p += 1; // Advance p to first char
        switch (*p) {
            int iResult;

            case 'b':
            case 'B':
            case 'r':
            case 'R':
                iResult = StrCmpNI(p, "RFC822.SIZE ", 12);
                if (0 == iResult) {
                    // Definitely the RFC822.SIZE tag:
                    // Read the nstring into a stream
                    p += 12; // Advance p to point to number

                    fetchResults.bRFC822Size = TRUE;
                    fetchResults.dwRFC822Size = StrToUint(p);

                    // Advance p to point past number
                    while ('0' <= *p && '9' >= *p)
                        p += 1;

                    break; // case 'r' or 'R': Possible RFC822.SIZE tag
                } // if (0 == iResult) for RFC822.HEADER

                if (0 == StrCmpNI(p, "RFC822", 6) || 0 == StrCmpNI(p, "BODY[", 5)) {
                    LPSTR pszBodyTag;
                    LPSTR pszBody;
                    DWORD dwLengthOfBody;
                    IMAP_LINE_FRAGMENT *pilfBodyTag = NULL; // Line fragment containing the body tag

                    // Find the body tag. We null-terminate all body tags after first space
                    pszBodyTag = p;
                    p = StrChr(p + 6, cSPACE);
                    if (NULL == p) {
                        hrResult = IXP_E_IMAP_SVR_SYNTAXERR;
                        goto exit;
                    }

                    *p = '\0'; // Null-terminate the body tag
                    p += 1; // Advance p to point to nstring

                    // Check if this is BODY[HEADER.FIELDS: this is the only tag that can
                    // include spaces and literals. We must skip past all of these.
                    if (0 == lstrcmpi("BODY[HEADER.FIELDS", pszBodyTag)) {

                        // Advance p until we find a ']'
                        while ('\0' != *p && ']' != *p) {
                            p += 1;

                            // Check for end of this string buffer
                            if ('\0' == *p) {
                                if (NULL == pilfBodyTag)
                                    pilfBodyTag = *ppilfLine; // Retain for future reference

                                // Advance to next fragment, discarding any literals that we find
                                do {
                                    if (NULL == (*ppilfLine)->pilfNextFragment) {
                                        // No more runway! Couldn't find ']'. Free all data and bail
                                        hrResult = IXP_E_IMAP_SVR_SYNTAXERR;
                                        while (NULL != pilfBodyTag && pilfBodyTag != *ppilfLine) {
                                            IMAP_LINE_FRAGMENT *pilfDead;

                                            pilfDead = pilfBodyTag;
                                            pilfBodyTag = pilfBodyTag->pilfNextFragment;
                                            FreeFragment(&pilfDead);
                                        }
                                        goto exit;
                                    }
                                    else
                                        *ppilfLine = (*ppilfLine)->pilfNextFragment;
                                } while (iltLINE != (*ppilfLine)->iltFragmentType);
                                
                                p = (*ppilfLine)->data.pszSource;
                            }
                        }

                        // Terminate HEADER.FIELDS chain but keep it around because we may need pszBodyTag
                        if (NULL != pilfBodyTag && NULL != (*ppilfLine)->pilfPrevFragment)
                            (*ppilfLine)->pilfPrevFragment->pilfNextFragment = NULL;

                        Assert(']' == *p);
                        Assert(cSPACE == *(p+1));
                        p += 2; // This should point us to the body nstring
                    }

                    // Read the nstring into a string
                    hrResult = NStringToString(ppilfLine, &pszBody, &dwLengthOfBody, &p);
                    if (FAILED(hrResult))
                        goto exit;

                    // If literal, it's already been handled. If NIL or string, report it to user
                    if (hrIMAP_S_QUOTED == hrResult || hrIMAP_S_NIL_NSTRING == hrResult) {
                        PrepareForFetchBody(dwMsgSeqNum, dwLengthOfBody, pszBodyTag);
                        m_dwLiteralInProgressBytesLeft = 0; // Override this
                        DispatchFetchBodyPart(pszBody, dwLengthOfBody, fDONT_FREE_BODY_TAG);
                        Assert(irsIDLE == m_irsState);
                    }

                    // Free any chains associated with HEADER.FIELDS
                    while (NULL != pilfBodyTag) {
                        IMAP_LINE_FRAGMENT *pilfDead;

                        pilfDead = pilfBodyTag;
                        pilfBodyTag = pilfBodyTag->pilfNextFragment;
                        FreeFragment(&pilfDead);
                    }

                    MemFree(pszBody);
                    break;
                } // if FETCH body tag like RFC822* or BODY[*

                // If not recognized, flow through (long way) to default case

            case 'u':
            case 'U':
                iResult = StrCmpNI(p, "UID ", 4);
                if (0 == iResult) {
                    LPSTR lpszUID;

                    // Definitely the UID tag
                    // First, find the end of the number (and verify it)
                    p += 4; // p now points to start of UID
                    lpszUID = p;
                    while ('\0' != *p && *p >= '0' && *p <= '9') // $REVIEW: isDigit?
                        p += 1;

                    // OK, we found end of number, and verified number is all digits
                    fetchResults.bUID = TRUE;
                    fetchResults.dwUID = StrToUint(lpszUID);

                    break; // case 'u' or 'U': Possible UID tag
                } // if (0 == iResult)

                // If not recognized, flow through (long way) to default case

            case 'f':
            case 'F':
                iResult = StrCmpNI(p, "FLAGS ", 6);
                if (0 == iResult) {
                    DWORD dwNumBytesRead;

                    // Definitely a FLAGS response: Parse the list
                    p += 6;
                    hrResult = ParseMsgFlagList(p, &fetchResults.mfMsgFlags,
                        &dwNumBytesRead);
                    if (FAILED(hrResult))
                        goto exit;

                    fetchResults.bMsgFlags = TRUE;
                    p += dwNumBytesRead + 1; // Advance p past end of flag list

                    break; // case 'f' or 'F': Possible FLAGS tag
                } // if (0 == iResult)

                // If not recognized, flow through to default case

            case 'i':
            case 'I':
                iResult = StrCmpNI(p, "INTERNALDATE ", 13);
                if (0 == iResult) {
                    LPSTR lpszEndOfDate;

                    // Definitely an INTERNALDATE response: convert to FILETIME
                    p += 13;
                    if ('\"' == *p)
                        p += 1; // Advance past the opening double-quote
                    else {
                        AssertSz(FALSE, "Server error: date_time starts without double-quote!");
                    }

                    lpszEndOfDate = StrChr(p, '\"'); // Find closing double-quote
                    if (NULL == lpszEndOfDate) {
                        AssertSz(FALSE, "Server error: date_time ends without double-quote!");
                        hrResult = IXP_E_IMAP_SVR_SYNTAXERR; // Can't continue, don't know where to go from
                        goto exit;
                    }

                    // Null-terminate end of date, for MimeOleInetDateToFileTime's sake
                    *lpszEndOfDate = '\0';

                    hrResult = MimeOleInetDateToFileTime(p, &fetchResults.ftInternalDate);
                    if (FAILED(hrResult))
                        goto exit;

                    p = lpszEndOfDate + 1;
                    fetchResults.bInternalDate = TRUE;
                    break; // case 'i' or 'I': Possible INTERNALDATE tag
                } // (0 == iResult)

                // If not recognized, flow through to default case

            case 'e':
            case 'E':
                iResult = StrCmpNI(p, "ENVELOPE ", 9);
                if (0 == iResult) {
                    // Definitely an envelope: parse each field!
                    p += 9;
                    hrResult = ParseEnvelope(&fetchResults, ppilfLine, &p);
                    if (FAILED(hrResult))
                        goto exit;

                    fetchResults.bEnvelope = TRUE;
                    break;
                }

                // If not recognized, flow through to default case

            default:
                // Unrecognized FETCH tag!
                // $REVIEW: We should skip past the data based on common-sense
                // rules. For now, just flip out. Be sure that above rules flow
                // through to here if unrecognized cmd
                Assert(FALSE);
                goto exit;
                break; // default case
        } // switch (*lpszFetchResp)

        // If *p is a space, we have another FETCH tag coming
    } while (cSPACE == *p);

    // Check if we ended on a closing parenthesis (as we always should)
    if (')' != *p) {
        hrResult = IXP_E_IMAP_SVR_SYNTAXERR;
        goto exit;
    }

    // Check that there's no stuff afterwards (debug only - retail ignores)
    Assert('\0' == *(p+1));

exit:
    // Finished parsing the FETCH response. Call the UPDATE callback
    fetchResults.dwMsgSeqNum = dwMsgSeqNum;
    // Persist the cookies from body part in progress
    fetchResults.lpFetchCookie1 = m_fbpFetchBodyPartInProgress.lpFetchCookie1;
    fetchResults.lpFetchCookie2 = m_fbpFetchBodyPartInProgress.lpFetchCookie2;

    irIMAPResponse.wParam = 0;
    irIMAPResponse.lParam = 0;    
    irIMAPResponse.hrResult = hrResult;
    irIMAPResponse.lpszResponseText = NULL; // Not relevant

    if (IMAP_FETCHEX_ENABLE & m_dwFetchFlags)
    {
        irIMAPResponse.irtResponseType = irtUPDATE_MSG_EX;
        irIMAPResponse.irdResponseData.pFetchResultsEx = &fetchResults;
    }
    else
    {
        DowngradeFetchResponse(&fcrOldFetchStruct, &fetchResults);

        irIMAPResponse.irtResponseType = irtUPDATE_MSG;
        irIMAPResponse.irdResponseData.pFetchResults = &fcrOldFetchStruct;
    }
    OnIMAPResponse(m_pCBHandler, &irIMAPResponse);

    m_fbpFetchBodyPartInProgress = FetchBodyPart_INIT;
    FreeFetchResponse(&fetchResults);
    return hrResult;
} // ParseFetchResponse



//***************************************************************************
// Function: ParseSearchResponse
//
// Purpose:
//   This function parses SEARCH responses and calls the
// SearchResponseNotification() callback to inform the user.
//
// Arguments:
//   LPSTR lpszFetchResp [in] - a pointer to the data of the search response.
//     This means that the "* SEARCH" portion should be omitted.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::ParseSearchResponse(LPSTR lpszSearchResponse)
{
    LPSTR p, pszTok;
    IMAP_RESPONSE irIMAPResponse;
    IIMAPCallback *pCBHandler;
    CRangeList *pSearchResults;

    Assert(m_lRefCount > 0);
    Assert(NULL != lpszSearchResponse);

    // First, check for the situation where there are 0 responses
    p = lpszSearchResponse;
    while ('\0' != *p && ('0' > *p || '9' < *p))
        p += 1; // Keep going until we hit a digit

    if ('\0' == *p)
        return S_OK;

    // Create CRangeList object
    pSearchResults = new CRangeList;
    if (NULL == pSearchResults)
        return E_OUTOFMEMORY;

    // Parse search responses
    pszTok = lpszSearchResponse;
    p = StrTokEx(&pszTok, g_szSpace);
    while (NULL != p) {
        DWORD dw;
        
        dw = StrToUint(p);
        if (0 != dw) {
            HRESULT hrResult;

            hrResult = pSearchResults->AddSingleValue(dw);
            Assert(SUCCEEDED(hrResult));
        }
        else {
            // Discard unusable results
            AssertSz(FALSE, "Hmm, this server is into kinky search responses.");
        }

        p = StrTokEx(&pszTok, g_szSpace); // p now points to next number. $REVIEW: Use Opie's fstrtok!
    }

    // Notify user of search response.
    GetTransactionID(&irIMAPResponse.wParam, &irIMAPResponse.lParam,
        &pCBHandler, irSEARCH_RESPONSE);
    irIMAPResponse.hrResult = S_OK;
    irIMAPResponse.lpszResponseText = NULL; // Not relevant
    irIMAPResponse.irtResponseType = irtSEARCH;
    irIMAPResponse.irdResponseData.prlSearchResults = (IRangeList *) pSearchResults;
    OnIMAPResponse(pCBHandler, &irIMAPResponse);

    pSearchResults->Release();
    return S_OK;
} // ParseSearchResponse



//***************************************************************************
// Function: ParseMboxStatusResponse
//
// Purpose:
//   This function parses an untagged STATUS response and calls the default
// CB handler with an irtMAILBOX_STATUS callback.
//
// Arguments:
//   IMAP_LINE_FRAGMENT **ppilfLine [in/out] - a pointer to the current
//     IMAP response fragment. This is used to retrieve the next fragment
//     in the chain (literal or line) since literals may be sent with STATUS
//     responses. This pointer is always updated to point to the fragment
//     currently in use, so that the caller may free the last one himself.
//   LPSTR pszStatusResponse [in] - a pointer to the STATUS response, after
//     the "<tag> STATUS " portion (should point to the mailbox parameter).
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::ParseMboxStatusResponse(IMAP_LINE_FRAGMENT **ppilfLine,
                                             LPSTR pszStatusResponse)
{
    LPSTR p, pszDecodedMboxName;
    LPSTR pszMailbox;
    HRESULT hrTranslateResult = E_FAIL;
    HRESULT hrResult;
    IMAP_STATUS_RESPONSE isrResult;
    IMAP_RESPONSE irIMAPResponse;

    // Initialize variables
    p = pszStatusResponse;
    ZeroMemory(&isrResult, sizeof(isrResult));
    pszDecodedMboxName = NULL;
    pszMailbox = NULL;

    // Get the name of the mailbox
    hrResult = AStringToString(ppilfLine, &pszMailbox, NULL, &p);
    if (FAILED(hrResult))
        goto exit;

    // Convert the mailbox name from UTF7 to MultiByte and remember the result
    hrTranslateResult = _ModifiedUTF7ToMultiByte(pszMailbox, &pszDecodedMboxName);
    if (FAILED(hrTranslateResult)) {
        hrResult = hrTranslateResult;
        goto exit;
    }

    // Advance to first status tag
    Assert(cSPACE == *p);
    p += 1;
    Assert('(' == *p);

    // Loop through all status attributes
    while ('\0' != *p && ')' != *p) {
        LPSTR pszTag, pszTagValue;
        DWORD dwTagValue;

        // Get pointers to tag and tag value
        Assert('(' == *p || cSPACE == *p);
        p += 1;
        pszTag = p;
        while ('\0' != *p && cSPACE != *p && ')' != *p)
            p += 1;

        Assert(cSPACE == *p); // We expect space, then tag value
        if (cSPACE == *p) {
            p += 1;
            Assert(*p >= '0' && *p <= '9');
            pszTagValue = p;
            dwTagValue = StrToUint(p);
        }

        // Advance us past number to next tag in prep for next loop iteration
        while ('\0' != *p && cSPACE != *p && ')' != *p)
            p += 1;

        switch (*pszTag) {
            int iResult;

            case 'm':
            case 'M': // Possibly the "MESSAGES" attribute
                iResult = StrCmpNI(pszTag, "MESSAGES ", 9);
                if (0 == iResult) {
                    // Definitely the "MESSAGES" tag
                    isrResult.fMessages = TRUE;
                    isrResult.dwMessages = dwTagValue;
                } // if (0 == iResult)
                break; // case 'M' for possible "MESSAGES"

            case 'r':
            case 'R': // Possibly the "RECENT" attribute
                iResult = StrCmpNI(pszTag, "RECENT ", 7);
                if (0 == iResult) {
                    // Definitely the "RECENT" tag
                    isrResult.fRecent = TRUE;
                    isrResult.dwRecent = dwTagValue;
                } // if (0 == iResult)
                break; // case 'R' for possible "RECENT"

            case 'u':
            case 'U': // Possibly UIDNEXT, UIDVALIDITY or UNSEEN
                // Check for the 3 possible tags in order of expected popularity
                iResult = StrCmpNI(pszTag, "UNSEEN ", 7);
                if (0 == iResult) {
                    // Definitely the "UNSEEN" tag
                    isrResult.fUnseen = TRUE;
                    isrResult.dwUnseen = dwTagValue;
                } // if (0 == iResult)

                iResult = StrCmpNI(pszTag, "UIDVALIDITY ", 12);
                if (0 == iResult) {
                    // Definitely the "UIDVALIDITY" tag
                    isrResult.fUIDValidity = TRUE;
                    isrResult.dwUIDValidity = dwTagValue;
                } // if (0 == iResult)

                iResult = StrCmpNI(pszTag, "UIDNEXT ", 8);
                if (0 == iResult) {
                    // Definitely the "UIDNEXT" tag
                    isrResult.fUIDNext = TRUE;
                    isrResult.dwUIDNext = dwTagValue;
                } // if (0 == iResult)
                break; // case 'U' for possible UIDNEXT, UIDVALIDITY or UNSEEN
        } // switch (*p)
    } // while ('\0' != *p)
    Assert(')' == *p);

    // Call the callback with our new-found information
    isrResult.pszMailboxName = pszDecodedMboxName;
    irIMAPResponse.wParam = 0;
    irIMAPResponse.lParam = 0;
    irIMAPResponse.hrResult = hrTranslateResult; // Could be IXP_S_IMAP_VERBATIM_MBOX
    irIMAPResponse.lpszResponseText = NULL; // Not relevant here
    irIMAPResponse.irtResponseType = irtMAILBOX_STATUS;
    irIMAPResponse.irdResponseData.pisrStatusResponse = &isrResult;
    OnIMAPResponse(m_pCBHandler, &irIMAPResponse);

exit:
    if (NULL != pszDecodedMboxName)
        MemFree(pszDecodedMboxName);

    if (NULL != pszMailbox)
        MemFree(pszMailbox);

    return hrResult;
} // ParseMboxStatusResponse



//***************************************************************************
// Function: ParseEnvelope
//
// Purpose:
//   This function parses the ENVELOPE tag returned via a FETCH response.
//
// Arguments:
//   FETCH_CMD_RESULTS_EX *pEnvResults [out] - the results of parsing the
//     ENVELOPE tag are outputted to this structure. It is the caller's
//     responsibility to call FreeFetchResponse when finished with the data.
//   IMAP_LINE_FRAGMENT **ppilfLine [in/out] - a pointer to the current IMAP
//     response fragment. This is advanced to the next fragment in the chain
//     as necessary (due to literals). On function exit, this will point
//     to the new current response fragment so the caller may continue parsing
//     as usual.
//   LPSTR *ppCurrent [in/out] - a pointer to the first '(' after the ENVELOPE
//     tag. On function exit, this pointer is updated to point past the ')'
//     after the ENVELOPE tag so the caller may continue parsing as usual.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::ParseEnvelope(FETCH_CMD_RESULTS_EX *pEnvResults,
                                   IMAP_LINE_FRAGMENT **ppilfLine,
                                   LPSTR *ppCurrent)
{
    HRESULT hrResult;
    LPSTR   p;
    LPSTR   pszTemp;

    TraceCall("CImap4Agent::ParseEnvelope");

    p = *ppCurrent;
    if ('(' != *p)
    {
        hrResult = TraceResult(IXP_E_IMAP_SVR_SYNTAXERR);
        goto exit;
    }

    // (1) Parse the envelope date (ignore error)
    p += 1;
    hrResult = NStringToString(ppilfLine, &pszTemp, NULL, &p);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    hrResult = MimeOleInetDateToFileTime(pszTemp, &pEnvResults->ftENVDate);
    MemFree(pszTemp);
    TraceError(hrResult); // Record but otherwise ignore error

    // (2) Get the "Subject" field
    Assert(cSPACE == *p);
    p += 1;
    hrResult = NStringToString(ppilfLine, &pEnvResults->pszENVSubject, NULL, &p);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // (3) Get the "From" field
    Assert(cSPACE == *p);
    p += 1;
    hrResult = ParseIMAPAddresses(&pEnvResults->piaENVFrom, ppilfLine, &p);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // (4) Get the "Sender" field
    Assert(cSPACE == *p);
    p += 1;
    hrResult = ParseIMAPAddresses(&pEnvResults->piaENVSender, ppilfLine, &p);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // (5) Get the "Reply-To" field
    Assert(cSPACE == *p);
    p += 1;
    hrResult = ParseIMAPAddresses(&pEnvResults->piaENVReplyTo, ppilfLine, &p);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // (6) Get the "To" field
    Assert(cSPACE == *p);
    p += 1;
    hrResult = ParseIMAPAddresses(&pEnvResults->piaENVTo, ppilfLine, &p);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // (7) Get the "Cc" field
    Assert(cSPACE == *p);
    p += 1;
    hrResult = ParseIMAPAddresses(&pEnvResults->piaENVCc, ppilfLine, &p);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // (8) Get the "Bcc" field
    Assert(cSPACE == *p);
    p += 1;
    hrResult = ParseIMAPAddresses(&pEnvResults->piaENVBcc, ppilfLine, &p);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // (9) Get the "InReplyTo" field
    Assert(cSPACE == *p);
    p += 1;
    hrResult = NStringToString(ppilfLine, &pEnvResults->pszENVInReplyTo, NULL, &p);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // (10) Get the "MessageID" field
    Assert(cSPACE == *p);
    p += 1;
    hrResult = NStringToString(ppilfLine, &pEnvResults->pszENVMessageID, NULL, &p);
    if (FAILED(hrResult))
    {
        TraceResult(hrResult);
        goto exit;
    }

    // Read in closing parenthesis
    Assert(')' == *p);
    p += 1;

exit:
    *ppCurrent = p;
    return hrResult;
} // ParseEnvelope



//***************************************************************************
// Function: ParseIMAPAddresses
//
// Purpose:
//   This function parses a LIST of "address" constructs as defined in RFC2060
// formal syntax. There is no formal syntax token for this LIST, but an example
// can be found in the "env_from" token in RFC2060's formal syntax. This
// function would be called to parse "env_from".
//
// Arguments:
//   IMAPADDR **ppiaResults [out] - a pointer to a chain of IMAPADDR structures
//     is returned here.
//   IMAP_LINE_FRAGMENT **ppilfLine [in/out] - a pointer to the current IMAP
//     response fragment. This is advanced to the next fragment in the chain
//     as necessary (due to literals). On function exit, this will point
//     to the new current response fragment so the caller may continue parsing
//     as usual.
//   LPSTR *ppCurrent [in/out] - a pointer to the first '(' after the ENVELOPE
//     tag. On function exit, this pointer is updated to point past the ')'
//     after the ENVELOPE tag so the caller may continue parsing as usual.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::ParseIMAPAddresses(IMAPADDR **ppiaResults,
                                        IMAP_LINE_FRAGMENT **ppilfLine,
                                        LPSTR *ppCurrent)
{
    HRESULT     hrResult = S_OK;
    BOOL        fResult;
    IMAPADDR   *piaCurrent;
    LPSTR       p;

    TraceCall("CImap4Agent::ParseIMAPAddresses");

    // Initialize output
    *ppiaResults = NULL;
    p = *ppCurrent;

    // ppCurrent either points to an address list, or "NIL"
    if ('(' != *p)
    {
        int iResult;

        // Check for "NIL"
        iResult = StrCmpNI(p, "NIL", 3);
        if (0 == iResult) {
            hrResult = S_OK;
            p += 3; // Skip past NIL
        }
        else
            hrResult = TraceResult(IXP_E_IMAP_SVR_SYNTAXERR);

        goto exit;
    }
    else
        p += 1; // Skip opening parenthesis

    // Loop over all addresses
    piaCurrent = NULL;
    while ('\0' != *p && ')' != *p) {

        // Skip any whitespace
        while (cSPACE == *p)
            p += 1;

        // Skip opening parenthesis
        Assert('(' == *p);
        p += 1;

        // Allocate a structure to hold current address
        if (NULL == piaCurrent) {
            fResult = MemAlloc((void **)ppiaResults, sizeof(IMAPADDR));
            piaCurrent = *ppiaResults;
        }
        else {
            fResult = MemAlloc((void **)&piaCurrent->pNext, sizeof(IMAPADDR));
            piaCurrent = piaCurrent->pNext;
        }

        if (FALSE == fResult)
        {
            hrResult = TraceResult(E_OUTOFMEMORY);
            goto exit;
        }

        ZeroMemory(piaCurrent, sizeof(IMAPADDR));

        // (1) Parse addr_name (see RFC2060)
        hrResult = NStringToString(ppilfLine, &piaCurrent->pszName, NULL, &p);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            goto exit;
        }

        // (2) Parse addr_adl (see RFC2060)
        Assert(cSPACE == *p);
        p += 1;
        hrResult = NStringToString(ppilfLine, &piaCurrent->pszADL, NULL, &p);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            goto exit;
        }

        // (3) Parse addr_mailbox (see RFC2060)
        Assert(cSPACE == *p);
        p += 1;
        hrResult = NStringToString(ppilfLine, &piaCurrent->pszMailbox, NULL, &p);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            goto exit;
        }

        // (4) Parse addr_host (see RFC2060)
        Assert(cSPACE == *p);
        p += 1;
        hrResult = NStringToString(ppilfLine, &piaCurrent->pszHost, NULL, &p);
        if (FAILED(hrResult))
        {
            TraceResult(hrResult);
            goto exit;
        }

        // Skip closing parenthesis
        Assert(')' == *p);
        p += 1;

    } // while

    // Read past closing parenthesis
    Assert(')' == *p);
    p += 1;

exit:
    if (FAILED(hrResult))
    {
        FreeIMAPAddresses(*ppiaResults);
        *ppiaResults = NULL;
    }

    *ppCurrent = p;
    return hrResult;
} // ParseIMAPAddresses



//***************************************************************************
// Function: DowngradeFetchResponse
//
// Purpose:
//   For IIMAPTransport users who do not enable FETCH_CMD_RESULTS_EX structures
// via IIMAPTransport2::EnableFetchEx, we have to continue to report FETCH
// results using FETCH_CMD_RESULTS. This function copies the relevant data
// from a FETCH_CMD_RESULTS_EX structure to FETCH_CMD_RESULTS. Too bad IDL
// doesn't support inheritance in structures...
//
// Arguments:
//   FETCH_CMD_RESULTS *pcfrOldFetchStruct [out] - points to destination for
//     data contained in pfcreNewFetchStruct.
//   FETCH_CMD_RESULTS_EX *pfcreNewFetchStruct [in] - points to source data
//     which is to be transferred to pfcrOldFetchStruct.
//***************************************************************************
void CImap4Agent::DowngradeFetchResponse(FETCH_CMD_RESULTS *pfcrOldFetchStruct,
                                         FETCH_CMD_RESULTS_EX *pfcreNewFetchStruct)
{
    pfcrOldFetchStruct->dwMsgSeqNum = pfcreNewFetchStruct->dwMsgSeqNum;
    pfcrOldFetchStruct->bMsgFlags = pfcreNewFetchStruct->bMsgFlags;
    pfcrOldFetchStruct->mfMsgFlags = pfcreNewFetchStruct->mfMsgFlags;

    pfcrOldFetchStruct->bRFC822Size = pfcreNewFetchStruct->bRFC822Size;
    pfcrOldFetchStruct->dwRFC822Size = pfcreNewFetchStruct->dwRFC822Size;

    pfcrOldFetchStruct->bUID = pfcreNewFetchStruct->bUID;
    pfcrOldFetchStruct->dwUID = pfcreNewFetchStruct->dwUID;

    pfcrOldFetchStruct->bInternalDate = pfcreNewFetchStruct->bInternalDate;
    pfcrOldFetchStruct->ftInternalDate = pfcreNewFetchStruct->ftInternalDate;

    pfcrOldFetchStruct->lpFetchCookie1 = pfcreNewFetchStruct->lpFetchCookie1;
    pfcrOldFetchStruct->lpFetchCookie2 = pfcreNewFetchStruct->lpFetchCookie2;
} // DowngradeFetchResponse



//***************************************************************************
// Function: QuotedToString
//
// Purpose:
//   This function, given a "quoted" (see RFC1730, Formal Syntax), converts
// it to a regular string, that is, a character array without any escape
// characters or delimiting double quotes. For instance, the quoted,
// "\"FUNKY\"\\MAN!!!!" would be converted to "FUNKY"\MAN!!!!.
//
// Arguments:
//   LPSTR *ppszDestination [out] - the translated quoted is returned as
//     a regular string in this destination buffer. It is the caller's
//     responsibility to MemFree this buffer when finished with it.
//   LPDWORD pdwLengthOfDestination [out] - the length of *ppszDestination is
//     returned here. Pass NULL if not interested.
//   LPSTR *ppCurrentSrcPos [in/out] - this is a ptr to a ptr to the quoted,
//     including opening and closing double-quotes. The function returns
//     a pointer to the end of the quoted so that the caller may continue
//     parsing the response line.
//
// Returns:
//   HRESULT indicating success or failure. If successful, returns
// hrIMAP_S_QUOTED.
//***************************************************************************
HRESULT CImap4Agent::QuotedToString(LPSTR *ppszDestination,
                                    LPDWORD pdwLengthOfDestination,
                                    LPSTR *ppCurrentSrcPos)
{
    LPSTR lpszSourceBuf, lpszUnescapedSequence;
    CByteStream bstmQuoted;
    int iUnescapedSequenceLen;
    HRESULT hrResult;

    Assert(m_lRefCount > 0);
    Assert(NULL != ppszDestination);
    Assert(NULL != ppCurrentSrcPos);
    Assert(NULL != *ppCurrentSrcPos);   

    lpszSourceBuf = *ppCurrentSrcPos;
    if ('\"' != *lpszSourceBuf)
        return IXP_E_IMAP_SVR_SYNTAXERR; // Need opening double-quote

    // Walk through string, translating escape characters as we go
    lpszSourceBuf += 1;
    lpszUnescapedSequence = lpszSourceBuf;
    while('\"' != *lpszSourceBuf && '\0' != *lpszSourceBuf) {
        if ('\\' == *lpszSourceBuf) {
            char cEscaped;

            // Escape character found, get next character
            iUnescapedSequenceLen = (int) (lpszSourceBuf - lpszUnescapedSequence);
            lpszSourceBuf += 1;

            switch(*lpszSourceBuf) {
                case '\\':
                    cEscaped = '\\';
                    break;

                case '\"':
                    cEscaped = '\"';
                    break;

                default:
                    // (Includes case '\0':)
                    // This isn't a spec'ed escape char!
                    // Return syntax error, but consider robust course of action $REVIEW
                    Assert(FALSE);
                    return IXP_E_IMAP_SVR_SYNTAXERR;
            } // switch(*lpszSourceBuf)

            // First, flush unescaped sequence leading up to escape sequence
            if (iUnescapedSequenceLen > 0) {
                hrResult = bstmQuoted.Write(lpszUnescapedSequence,
                    iUnescapedSequenceLen, NULL);
                if (FAILED(hrResult))
                    return hrResult;
            }

            // Append escaped character
            hrResult = bstmQuoted.Write(&cEscaped, 1, NULL);
            if (FAILED(hrResult))
                return hrResult;

            // Set us up to find next unescaped sequence
            lpszUnescapedSequence = lpszSourceBuf + 1;
        } // if ('\' == *lpszSourceBuf)
        else if (FALSE == isTEXT_CHAR(*lpszSourceBuf))
            return IXP_E_IMAP_SVR_SYNTAXERR;

        lpszSourceBuf += 1;
    } // while not closing quote or end of string

    // Flush any remaining unescaped sequences
    iUnescapedSequenceLen = (int) (lpszSourceBuf - lpszUnescapedSequence);
    if (iUnescapedSequenceLen > 0) {
        hrResult = bstmQuoted.Write(lpszUnescapedSequence, iUnescapedSequenceLen, NULL);
        if (FAILED(hrResult))
            return hrResult;
    }

    *ppCurrentSrcPos = lpszSourceBuf + 1; // Update user's ptr to point PAST quoted
    if ('\0' == *lpszSourceBuf)
        return IXP_E_IMAP_SVR_SYNTAXERR; // Quoted str ended before closing quote!
    else {
        hrResult = bstmQuoted.HrAcquireStringA(pdwLengthOfDestination,
            ppszDestination, ACQ_DISPLACE);
        if (FAILED(hrResult))
            return hrResult;
        else
            return hrIMAP_S_QUOTED;
    }
} // Convert QuotedToString



//***************************************************************************
// Function: AStringToString
//
// Purpose:
//   This function, given an astring (see RFC1730, Formal Syntax), converts
// it to a regular string, that is, a character array without any escape
// characters or delimiting double quotes or literal size specifications.
// As specified in RFC1730, an astring may be expressed as an atom, a
// quoted, or a literal.
//
// Arguments:
//   IMAP_LINE_FRAGMENT **ppilfLine [in/out] - a pointer to the current
//     IMAP response fragment. This is used to retrieve the next fragment
//     in the chain (literal or line) since astrings can be sent as literals.
//     This pointer is always updated to point to the fragment currently in
//     use, so that the caller may free the last one himself.
//   LPSTR *ppszDestination [out] - the translated astring is returned as a
//     regular string in this destination buffer. It is the caller's
//     responsibility to MemFree the returned buffer when finished with it.
//   LPDWORD pdwLengthOfDestination [in] - the length of *ppszDestination.
//     Pass NULL if not interested.
//   LPSTR *ppCurrentSrcPos [in/out] - this is a ptr to a ptr to the astring,
//     including opening and closing double-quotes if it's a quoted, or the
//     literal size specifier (ie, {#}) if it's a literal. A pointer to the
//     end of the astring is returned to the caller, so that they may
//     continue parsing the response line.
//
// Returns:
//   HRESULT indicating success or failure. Success codes include:
//     hrIMAP_S_FOUNDLITERAL - a literal was found and copied to destination
//     hrIMAP_S_QUOTED - a quoted was found and copied to destination
//     hrIMAP_S_ATOM - an atom was found and copied to destination
//***************************************************************************
HRESULT CImap4Agent::AStringToString(IMAP_LINE_FRAGMENT **ppilfLine,
                                     LPSTR *ppszDestination,
                                     LPDWORD pdwLengthOfDestination,
                                     LPSTR *ppCurrentSrcPos)
{
    LPSTR pSrc;

    // Check args
    Assert(m_lRefCount > 0);
    Assert(NULL != ppilfLine);
    Assert(NULL != *ppilfLine);
    Assert(NULL != ppszDestination);
    Assert(NULL != ppCurrentSrcPos);
    Assert(NULL != *ppCurrentSrcPos);

    // Identify astring as atom, quoted or literal
    pSrc = *ppCurrentSrcPos;
    switch(*pSrc) {
        case '{': {
            IMAP_LINE_FRAGMENT *pilfLiteral, *pilfLine;

            // It's a literal
            // $REVIEW: We ignore the literal size spec and anything after it. Should we?
            pilfLiteral = (*ppilfLine)->pilfNextFragment;
            if (NULL == pilfLiteral)
                return IXP_E_IMAP_INCOMPLETE_LINE;

            Assert(iltLITERAL == pilfLiteral->iltFragmentType);
            if (ilsSTRING == pilfLiteral->ilsLiteralStoreType) {
                if (ppszDestination)
                    *ppszDestination = PszDupA(pilfLiteral->data.pszSource);
                if (pdwLengthOfDestination)
                    *pdwLengthOfDestination = lstrlen(pilfLiteral->data.pszSource);
            }
            else {
                HRESULT hrResult;
                LPSTREAM pstmSource = pilfLiteral->data.pstmSource;

                // Append a null-terminator to stream
                hrResult = pstmSource->Write(c_szEmpty, 1, NULL);
                if (FAILED(hrResult))
                    return hrResult;

                // Copy stream into a memory block
                hrResult = HrStreamToByte(pstmSource, (LPBYTE *)ppszDestination,
                    pdwLengthOfDestination);
                if (FAILED(hrResult))
                    return hrResult;

                if (pdwLengthOfDestination)
                    *pdwLengthOfDestination -= 1; // includes null-term, so decrease by 1
            }


            // OK, now set up next line so caller may continue parsing the response
            pilfLine = pilfLiteral->pilfNextFragment;
            if (NULL == pilfLine)
                return IXP_E_IMAP_INCOMPLETE_LINE;

            // Update user's pointer into the source line
            Assert(iltLINE == pilfLine->iltFragmentType);
            *ppCurrentSrcPos = pilfLine->data.pszSource;

            // Clean up and exit
            FreeFragment(&pilfLiteral);
            FreeFragment(ppilfLine);
            *ppilfLine = pilfLine; // Update this ptr so it always points to LAST fragment

            return hrIMAP_S_FOUNDLITERAL;
        } // case AString == LITERAL

        case '\"':
            // It's a QUOTED STING, convert it to regular string
            return QuotedToString(ppszDestination, pdwLengthOfDestination,
                ppCurrentSrcPos);

        default: {
            DWORD dwLengthOfAtom;

            // It's an atom: find the end of the atom
            while (isATOM_CHAR(*pSrc))
                pSrc += 1;

            // Copy the atom into a buffer for the user
            dwLengthOfAtom = (DWORD) (pSrc - *ppCurrentSrcPos);
            if (ppszDestination) {
                BOOL fResult;

                fResult = MemAlloc((void **)ppszDestination, dwLengthOfAtom + 1);
                if (FALSE == fResult)
                    return E_OUTOFMEMORY;

                CopyMemory(*ppszDestination, *ppCurrentSrcPos, dwLengthOfAtom);
                (*ppszDestination)[dwLengthOfAtom] = '\0';
            }

            if (pdwLengthOfDestination)
                *pdwLengthOfDestination = dwLengthOfAtom;

            // Update user's pointer
            *ppCurrentSrcPos = pSrc;
            return hrIMAP_S_ATOM;
        } // case AString == ATOM
    } // switch(*pSrc)
} // AStringToString



//***************************************************************************
// Function: isTEXT_CHAR
//
// Purpose:
//   This function identifies characters which are TEXT_CHARs as defined in
// RFC1730's Formal Syntax section.
//
// Returns:
//   This function returns TRUE if the given character fits the definition.
//***************************************************************************
inline boolean CImap4Agent::isTEXT_CHAR(char c)
{
    // $REVIEW: signed/unsigned char, 8/16-bit char issues with 8th bit check
    // Assert(FALSE);
    if (c != (c & 0x7F) || // 7-bit
        '\0' == c ||
        '\r' == c ||
        '\n' == c)
        return FALSE;
    else
        return TRUE;
} // isTEXT_CHAR
    


//***************************************************************************
// Function: isATOM_CHAR
//
// Purpose:
//   This function identifies characters which are ATOM_CHARs as defined in
// RFC1730's Formal Syntax section.
//
// Returns:
//   This function returns TRUE if the given character fits the definition.
//***************************************************************************
inline boolean CImap4Agent::isATOM_CHAR(char c)
{
    // $REVIEW: signed/unsigned char, 8/16-bit char issues with 8th bit check
    // Assert(FALSE);
    if (c != (c & 0x7F) || // 7-bit
        '\0' == c ||       // At this point, we know it's a CHAR
        '(' == c ||        // Explicit atom_specials char
        ')' == c ||        // Explicit atom_specials char
        '{' == c ||        // Explicit atom_specials char
        cSPACE == c ||     // Explicit atom_specials char
        c < 0x1f ||        // Check for CTL
        0x7f == c ||       // Check for CTL
        '%' == c ||        // Check for list_wildcards
        '*' == c ||        // Check for list_wildcards
        '\\' == c ||       // Check for quoted_specials
        '\"' == c)         // Check for quoted_specials
        return FALSE;
    else
        return TRUE;
} // isATOM_CHAR



//***************************************************************************
// Function: NStringToString
//
// Purpose:
//   This function, given an nstring (see RFC1730, Formal Syntax), converts
// it to a regular string, that is, a character array without any escape
// characters or delimiting double quotes or literal size specifications.
// As specified in RFC1730, an nstring may be expressed as a quoted,
// a literal, or "NIL".
//
// Arguments:
//   IMAP_LINE_FRAGMENT **ppilfLine [in/out] - a pointer to the current
//     IMAP response fragment. This is used to retrieve the next fragment
//     in the chain (literal or line) since nstrings can be sent as literals.
//     This pointer is always updated to point to the fragment currently in
//     use, so that the caller may free the last one himself.
//   LPSTR *ppszDestination [out] - the translated nstring is returned as
//     a regular string in this destination buffer. It is the caller's
//     responsibility to MemFree this buffer when finished with it.
//   LPDWORD pdwLengthOfDestination [out] - the length of *ppszDestination is
//     returned here. Pass NULL if not interested.
//   LPSTR *ppCurrentSrcPos [in/out] - this is a ptr to a ptr to the nstring,
//     including opening and closing double-quotes if it's a quoted, or the
//     literal size specifier (ie, {#}) if it's a literal. A pointer to the
//     end of the nstring is returned to the caller, so that they may
//     continue parsing the response line.
//
// Returns:
//   HRESULT indicating success or failure. Success codes include:
//     hrIMAP_S_FOUNDLITERAL - a literal was found and copied to destination
//     hrIMAP_S_QUOTED - a quoted was found and copied to destination
//     hrIMAP_S_NIL_NSTRING - "NIL" was found.
//***************************************************************************
HRESULT CImap4Agent::NStringToString(IMAP_LINE_FRAGMENT **ppilfLine,
                                     LPSTR *ppszDestination,
                                     LPDWORD pdwLengthOfDestination,
                                     LPSTR *ppCurrentSrcPos)
{
    HRESULT hrResult;

    Assert(m_lRefCount > 0);
    Assert(NULL != ppilfLine);
    Assert(NULL != *ppilfLine);
    Assert(NULL != ppszDestination);
    Assert(NULL != ppCurrentSrcPos);
    Assert(NULL != *ppCurrentSrcPos);

    // nstrings are almost exactly like astrings, but nstrings cannot
    // have any value other than "NIL" expressed as an atom.
    hrResult = AStringToString(ppilfLine, ppszDestination, pdwLengthOfDestination,
        ppCurrentSrcPos);

    // If AStringToString found an ATOM, the only acceptable response is "NIL"
    if (hrIMAP_S_ATOM == hrResult) {
        if (0 == lstrcmpi("NIL", *ppszDestination)) {
            **ppszDestination = '\0'; // Blank str in case someone tries to use it
            if (pdwLengthOfDestination)
                *pdwLengthOfDestination = 0;

            return hrIMAP_S_NIL_NSTRING;
        }
        else {
            MemFree(*ppszDestination);
            *ppszDestination = NULL;
            if (pdwLengthOfDestination)
                *pdwLengthOfDestination = 0;

            return IXP_E_IMAP_SVR_SYNTAXERR;
        }
    }
    else
        return hrResult;
} // NStringToString




//***************************************************************************
// Function: NStringToStream
//
// Purpose:
//   This function is performs exactly the same job as NStringToString, but
// places the result in a stream, instead. This function should be used when
// the caller expects potentially LARGE results.
//
// Arguments:
//   Similar to NStringToString (minus string buffer output args), plus:
//   LPSTREAM *ppstmResult [out] - A stream is created for the caller, and
//     the translated nstring is written as a regular string to the stream
//     and returned via this argument. The returned stream is not rewound
//     on exit.
//
// Returns:
//   HRESULT indicating success or failure. Success codes include:
//     hrIMAP_S_FOUNDLITERAL - a literal was found and copied to destination
//     hrIMAP_S_QUOTED - a quoted was found and copied to destination
//     hrIMAP_S_NIL_NSTRING - "NIL" was found.
//***************************************************************************
HRESULT CImap4Agent::NStringToStream(IMAP_LINE_FRAGMENT **ppilfLine,
                                     LPSTREAM *ppstmResult,
                                     LPSTR *ppCurrentSrcPos)
{
    Assert(m_lRefCount > 0);
    Assert(NULL != ppilfLine);
    Assert(NULL != *ppilfLine);
    Assert(NULL != ppstmResult);
    Assert(NULL != ppCurrentSrcPos);
    Assert(NULL != *ppCurrentSrcPos);

    // Check if this nstring is a literal
    if ('{' == **ppCurrentSrcPos) {
        IMAP_LINE_FRAGMENT *pilfLine, *pilfLiteral;

        // Yup, it's a literal! Write the literal to a stream
        // $REVIEW: We ignore the literal size spec and anything after it. Should we?
        pilfLiteral = (*ppilfLine)->pilfNextFragment;
        if (NULL == pilfLiteral)
            return IXP_E_IMAP_INCOMPLETE_LINE;

        Assert(iltLITERAL == pilfLiteral->iltFragmentType);
        if (ilsSTRING == pilfLiteral->ilsLiteralStoreType) {
            HRESULT hrStreamResult;
            ULONG ulNumBytesWritten;

            // Literal is stored as string. Create stream and write to it
            hrStreamResult = MimeOleCreateVirtualStream(ppstmResult);
            if (FAILED(hrStreamResult))
                return hrStreamResult;

            hrStreamResult = (*ppstmResult)->Write(pilfLiteral->data.pszSource,
                pilfLiteral->dwLengthOfFragment, &ulNumBytesWritten);
            if (FAILED(hrStreamResult))
                return hrStreamResult;

            Assert(ulNumBytesWritten == pilfLiteral->dwLengthOfFragment);
        }
        else {
            // Literal is stored as stream. Just AddRef() and return ptr
            (pilfLiteral->data.pstmSource)->AddRef();
            *ppstmResult = pilfLiteral->data.pstmSource;
        }

        // No need to null-terminate streams

        // OK, now set up next line fragment so caller may continue parsing response
        pilfLine = pilfLiteral->pilfNextFragment;
        if (NULL == pilfLine)
            return IXP_E_IMAP_INCOMPLETE_LINE;

        // Update user's pointer into the source line
        Assert(iltLINE == pilfLine->iltFragmentType);
        *ppCurrentSrcPos = pilfLine->data.pszSource;

        // Clean up and exit
        FreeFragment(&pilfLiteral);
        FreeFragment(ppilfLine);
        *ppilfLine = pilfLine; // Update this ptr so it always points to LAST fragment

        return hrIMAP_S_FOUNDLITERAL;
    }
    else {
        HRESULT hrResult, hrStreamResult;
        ULONG ulLiteralLen, ulNumBytesWritten;
        LPSTR pszLiteralSrc;

        // Not a literal. Translate NString to string (in-place).
        // Add 1 to destination size calculation for null-terminator
        hrResult = NStringToString(ppilfLine, &pszLiteralSrc,
            &ulLiteralLen, ppCurrentSrcPos);
        if (FAILED(hrResult))
            return hrResult;

        // Create stream to hold result
        hrStreamResult = MimeOleCreateVirtualStream(ppstmResult);
        if (FAILED(hrStreamResult)) {
            MemFree(pszLiteralSrc);
            return hrStreamResult;
        }

        // Write the result to the stream
        hrStreamResult = (*ppstmResult)->Write(pszLiteralSrc, ulLiteralLen,
            &ulNumBytesWritten);
        MemFree(pszLiteralSrc);
        if (FAILED(hrStreamResult))
            return hrStreamResult;

        Assert(ulLiteralLen == ulNumBytesWritten); // Debug-only paranoia
        return hrResult;
    }
} // NStringToStream



//***************************************************************************
// Function: ParseMsgFlagList
//
// Purpose:
//   Given a flag_list (see RFC1730, Formal Syntax section), this function
// returns the IMAP_MSG_* bit-flags which correspond to the flags in the
// list. For instance, given the flag list, "(\Answered \Draft)", this
// function returns IMAP_MSG_ANSWERED | IMAP_MSG_DRAFT. Any unrecognized
// flags are ignored.
//
// Arguments:
//   LPSTR lpszStartOfFlagList [in/out] - a pointer the start of a flag_list,
//     including opening and closing parentheses. This function does not
//     explicitly output anything to this string, but it does MODIFY the
//     string by null-terminating spaces and the closing parenthesis.
//   IMAP_MSGFLAGS *lpmfMsgFlags [out] - IMAP_MSGFLAGS value corresponding
//     to the given flag list. If the given flag list is empty, this
//     function returns IMAP_MSG_NOFLAGS.
//   LPDWORD lpdwNumBytesRead [out] - the number of bytes between the
//     opening parenthesis and the closing parenthesis of the flag list.
//     Adding this number to the address of the start of the flag list
//     yields a pointer to the closing parenthesis.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::ParseMsgFlagList(LPSTR lpszStartOfFlagList,
                                      IMAP_MSGFLAGS *lpmfMsgFlags,
                                      LPDWORD lpdwNumBytesRead)
{
    LPSTR p, lpszEndOfFlagList, pszTok;

    Assert(m_lRefCount > 0);
    Assert(NULL != lpszStartOfFlagList);
    Assert(NULL != lpmfMsgFlags);
    Assert(NULL != lpdwNumBytesRead);

    p = lpszStartOfFlagList;
    if ('(' != *p)
        // Opening parenthesis was not found
        return IXP_E_IMAP_SVR_SYNTAXERR;

    // Look for closing parenthesis Assert(FALSE); // *** $REVIEW: C-RUNTIME ALERT
    lpszEndOfFlagList = StrChr(p, ')');
    if (NULL == lpszEndOfFlagList)
        // Closing parenthesis was not found
        return IXP_E_IMAP_SVR_SYNTAXERR;

    
    *lpdwNumBytesRead = (DWORD) (lpszEndOfFlagList - lpszStartOfFlagList);
    *lpszEndOfFlagList = '\0'; // Null-terminate flag list
    *lpmfMsgFlags = IMAP_MSG_NOFLAGS; // Initialize output
    pszTok = lpszStartOfFlagList + 1;
    p = StrTokEx(&pszTok, g_szSpace); // Get ptr to first token

    while (NULL != p) {
        // We'll narrow the search down for the flag by looking at its
        // first letter. Although there's a conflict between \Deleted and
        // \Draft, this is the best way for case-insensitive search
        // (first non-conflicting letter is five characters in!)    

        // First, check that there is at least one character
        if ('\\' == *p) {
            p += 1;
            switch (*p) {
                int iResult;

                case 'a':
                case 'A': // Possible "Answered" flag
                    iResult = lstrcmpi(p, c_szIMAP_MSG_ANSWERED);
                    if (0 == iResult)
                        *lpmfMsgFlags |= IMAP_MSG_ANSWERED; // Definitely the \Answered flag
                    break;

                case 'f':
                case 'F': // Possible "Flagged" flag
                    iResult = lstrcmpi(p, c_szIMAP_MSG_FLAGGED);
                    if (0 == iResult)
                        *lpmfMsgFlags |= IMAP_MSG_FLAGGED; // Definitely the \Flagged flag
                    break;

                case 'd':
                case 'D': // Possible "Deleted" or "Draft" flags
                    // "Deleted" is more probable, so check it first
                    iResult = lstrcmpi(p, c_szIMAP_MSG_DELETED);
                    if (0 == iResult) {
                        *lpmfMsgFlags |= IMAP_MSG_DELETED; // Definitely the \Deleted flag
                        break;
                    }

                    iResult = lstrcmpi(p, c_szIMAP_MSG_DRAFT);
                    if (0 == iResult) {
                        *lpmfMsgFlags |= IMAP_MSG_DRAFT; // Definitely the \Draft flag
                        break;
                    }

                    break;

                case 's':
                case 'S': // Possible "Seen" flags
                    iResult = lstrcmpi(p, c_szIMAP_MSG_SEEN);
                    if (0 == iResult)
                        *lpmfMsgFlags |= IMAP_MSG_SEEN; // Definitely the \Seen flag

                    break;
            } // switch(*p)
        } // if ('\\' == *p)

        p = StrTokEx(&pszTok, g_szSpace); // Grab next token
    } // while (NULL != p)

    return S_OK; // If we hit this point, we're all done
} // ParseMsgFlagList



//****************************************************************************
// Function: AppendSendAString
//
// Purpose:
//   This function is intended to be used by a caller who is constructing a
// command line which contains IMAP astrings (see RFC1730 Formal Syntax).
// This function takes a regular C string and converts it to an IMAP astring,
// appending it to the end of the command line under construction.
//
// An astring may take the form of an atom, a quoted, or a literal. For
// performance reasons (both conversion and network), I don't see any reason
// we should ever output an atom. Thus, this function returns either a quoted
// or a literal.
//
// Although IMAP's most expressive form of astring is the literal, it can
// result in costly network handshaking between client and server, and
// thus should be avoided unless required. Another consideration to use
// in deciding to use literal/quoted is size of the string. Most IMAP servers
// will have some internal limit to the maximum length of a line. To avoid
// exceeding this limit, it is wise to encode large strings as literals
// (where large typically means 1024 bytes).
//
// If the function converts the C string to a quoted, it appends it to the
// end of the partially-constructed command line. If it must send as a literal,
// it enqueues the partially-constructed command line in the send queue of the
// command-in-progress, enqueues the literal as well, then creates a new line
// fragment so the caller may continue constructing the command. The caller's
// pointer to the end of the command line is reset so that the user may
// append the next argument without concern of whether the C string
// was sent as a quoted or a literal. Although the caller may pretend
// that he's constructing a command line simply by appending to it, when this
// function returns, he caller may not be appending to the same string buffer.
// (Not that the caller should care.)
//
// This function prepends a SPACE by default, so this function may be called
// as many times in a row as desired. Each astring will be separated by a
// space.
//
// Arguments:
//   CIMAPCmdInfo *piciCommand [in] - a pointer to the command currently under
//     construction. This argument is needed so we can enqueue command
//     fragments to the command's send queue.
//   LPSTR lpszCommandLine [in] - a pointer to a partially constructed
//     command line suitable for passing to SendCmdLine (which supplies the
//     tag). For instance, this argument could point to a string, "SELECT".
//   LPSTR *ppCmdLinePos [in/out] - a pointer to the end of the command
//     line. If this function converts the C string to a quoted, the quoted
//     is appended to lpszCommandLine, and *ppCmdLinePos is updated to point
//     to the end of the quoted. If the C string is converted to a literal,
//     lpszCommandLine is made blank (null-terminated), and *ppCmdLinePos
//     is reset to the start of the line. In either case, the user should
//     continue to construct the command line using the updated *ppCmdLinePos
//     pointer, and send lpszCommandLine as usual to SendCmdLine.
//   DWORD dwSizeOfCommandLine [in] - size of the command line buffer, for
//     buffer overflow-checking purposes.
//   LPSTR lpszSource [in] - pointer to the source string.
//   BOOL fPrependSpace [in] - TRUE if we should prepend a space, FALSE if no
//     space should be prepended. Usually TRUE unless this AString follows
//     a rangelist.
//
// Returns:
//   HRESULT indicating success or failure. In particular, there are two
// success codes (which the caller need not act on):
//
//   hrIMAP_S_QUOTED - indicates that the source string was successfully
//     converted to a quoted, and has been appended to lpszCommandLine.
//     *ppCmdLinePos has been updated to point to the end of the new line
//     should the caller wish to continue appending arguments.
//   hrIMAP_S_FOUNDLITERAL - indicates that the source string was
//     sent as a literal. The command line has been blanked, and the user
//     may continue constructing the command line with his *ppCmdLinePos ptr.
//****************************************************************************
HRESULT CImap4Agent::AppendSendAString(CIMAPCmdInfo *piciCommand,
                                       LPSTR lpszCommandLine, LPSTR *ppCmdLinePos,
                                       DWORD dwSizeOfCommandLine, LPCSTR lpszSource,
                                       BOOL fPrependSpace)
{
    HRESULT hrResult;
    DWORD dwMaxQuotedSize;
    DWORD dwSizeOfQuoted;

    Assert(m_lRefCount > 0);
    Assert(NULL != piciCommand);
    Assert(NULL != lpszCommandLine);
    Assert(NULL != ppCmdLinePos);
    Assert(NULL != *ppCmdLinePos);
    Assert(0 != dwSizeOfCommandLine);
    Assert(NULL != lpszSource);
    Assert(*ppCmdLinePos < lpszCommandLine + dwSizeOfCommandLine);


    // Assume quoted string at start. If we have to send as literal, then too
    // bad, the quoted conversion work is wasted.

    // Prepend a space if so directed by user
    if (fPrependSpace) {
        **ppCmdLinePos = cSPACE;
        *ppCmdLinePos += 1;
    }

    dwMaxQuotedSize = min(dwLITERAL_THRESHOLD,
        (DWORD) (lpszCommandLine + dwSizeOfCommandLine - *ppCmdLinePos));
    hrResult = StringToQuoted(*ppCmdLinePos, lpszSource, dwMaxQuotedSize,
        &dwSizeOfQuoted);

    // Always check for buffer overflow
    Assert(*ppCmdLinePos + dwSizeOfQuoted < lpszCommandLine + dwSizeOfCommandLine);
    
    if (SUCCEEDED(hrResult)) {
        Assert(hrIMAP_S_QUOTED == hrResult);

        // Successfully converted to quoted,
        *ppCmdLinePos += dwSizeOfQuoted; // Advance user's ptr into cmd line
    }
    else {
        BOOL bResult;
        DWORD dwLengthOfLiteral;
        DWORD dwLengthOfLiteralSpec;
        IMAP_LINE_FRAGMENT *pilfLiteral;

        // OK, couldn't convert to quoted (buffer overflow? 8-bit char?)
        // Looks like it's literal time. We SEND this puppy.

        // Find out length of literal, append to command line and send
        dwLengthOfLiteral = lstrlen(lpszSource); // Yuck, but I'm betting most Astrings are quoted
        dwLengthOfLiteralSpec = wnsprintf(*ppCmdLinePos, dwSizeOfCommandLine - (DWORD)(*ppCmdLinePos - lpszCommandLine),
            "{%lu}\r\n", dwLengthOfLiteral);
        Assert(*ppCmdLinePos + dwLengthOfLiteralSpec < lpszCommandLine + dwSizeOfCommandLine);
        hrResult = SendCmdLine(piciCommand, sclAPPEND_TO_END, lpszCommandLine,
            (DWORD) (*ppCmdLinePos + dwLengthOfLiteralSpec - lpszCommandLine)); // Send entire command line
        if (FAILED(hrResult))
            return hrResult;

        // Queue the literal up - send FSM will wait for cmd continuation
        pilfLiteral = new IMAP_LINE_FRAGMENT;
        pilfLiteral->iltFragmentType = iltLITERAL;
        pilfLiteral->ilsLiteralStoreType = ilsSTRING;
        pilfLiteral->dwLengthOfFragment = dwLengthOfLiteral;        
        pilfLiteral->pilfNextFragment = NULL;
        pilfLiteral->pilfPrevFragment = NULL;
        DWORD cchSize = (dwLengthOfLiteral + 1);
        bResult = MemAlloc((void **) &pilfLiteral->data.pszSource, cchSize * sizeof(pilfLiteral->data.pszSource[0]));
        if (FALSE == bResult)
        {
            delete pilfLiteral;
            return E_OUTOFMEMORY;
        }
        StrCpyN(pilfLiteral->data.pszSource, lpszSource, cchSize);

        EnqueueFragment(pilfLiteral, piciCommand->pilqCmdLineQueue);

        // Done with sending cmd line w/ literal. Blank out old cmd line and rewind ptr
        *ppCmdLinePos = lpszCommandLine;
        *lpszCommandLine = '\0';
        
        hrResult = hrIMAP_S_FOUNDLITERAL;
    } // else: convert AString to Literal

    return hrResult;
} // AppendSendAString



//****************************************************************************
// Function: StringToQuoted
//
// Purpose:
//   This function converts a regular C string to an IMAP quoted (see RFC1730
// Formal Syntax).
//
// Arguments:
//   LPSTR lpszDestination [out] - the output buffer where the quoted should
//     be placed.
//   LPSTR lpszSource [in] - the source string.
//   DWORD dwSizeOfDestination [in] - the size of the output buffer,
//     lpszDestination. Note that in the worst case, the size of the output
//     buffer must be at least one character larger than the quoted actually
//     needs. This is because before translating a character from source to
//     destination, the loop checks if there is enough room for the worst
//     case, a quoted_special, which needs 2 bytes.
//   LPDWORD lpdwNumCharsWritten [out] - the number of characters written
//     to the output buffer, not including the null-terminator. Adding this
//     value to lpszDestination will result in a pointer to the end of the
//     quoted.
//
// Returns:
//   HRESULT indicating success or failure. In particular, this function
// returns hrIMAP_S_QUOTED if it was successful in converting the source
// string to a quoted. If not, the function returns E_FAIL.
//****************************************************************************
HRESULT CImap4Agent::StringToQuoted(LPSTR lpszDestination, LPCSTR lpszSource,
                                    DWORD dwSizeOfDestination,
                                    LPDWORD lpdwNumCharsWritten)
{
    LPCSTR p;
    DWORD dwNumBytesWritten;

    Assert(NULL != lpszDestination);
    Assert(NULL != lpszSource);

    // Initialize return value
    *lpdwNumCharsWritten = 0;

    if (dwSizeOfDestination >= 3)
        dwSizeOfDestination -= 2; // Leave room for closing quote and null-term at end
    else {
        Assert(FALSE); // Smallest quoted is 3 chars ('\"\"\0')
        return IXP_E_IMAP_BUFFER_OVERFLOW;
    }

    p = lpszSource;
    *lpszDestination = '\"'; // Start us off with an opening quote
    lpszDestination += 1;
    dwNumBytesWritten = 1;
    // Keep looping until we hit source null-term, or until we don't have
    // enough room in destination for largest output (2 chars for quoted_special)
    dwSizeOfDestination -= 1; // This ensures always room for quoted_special
    while (dwNumBytesWritten < dwSizeOfDestination && '\0' != *p) {

        if (FALSE == isTEXT_CHAR(*p))
            return E_FAIL; // Quoted's can only represent TEXT_CHAR's

        if ('\\' == *p || '\"' == *p) {
            *lpszDestination = '\\'; // Prefix with escape character
            lpszDestination += 1;
            dwNumBytesWritten += 1;
        } // if quoted_special

        *lpszDestination = *p;
        lpszDestination += 1;
        dwNumBytesWritten += 1;
        p += 1;
    } // while ('\0' != *p)

    *lpszDestination = '\"'; // Install closing quote
    *(lpszDestination + 1) = '\0'; // Null-terminate the string
    *lpdwNumCharsWritten = dwNumBytesWritten + 1; // Incl closing quote in size

    if ('\0' == *p)
        return hrIMAP_S_QUOTED;
    else
        return IXP_E_IMAP_BUFFER_OVERFLOW; // Buffer overflow
} // StringToQuoted



//***************************************************************************
// Function: GenerateCommandTag
//
// Purpose:
//   This function generates a unique tag so that a command issuer may
// identify his command to the IMAP server (and so that the server response
// may be identified with the command). It is a simple base-36 (alphanumeric)
// counter which increments a static 4-digit base-36 number on each call.
// (Digits are 0,1,2,3,4,6,7,8,9,A,B,C,...,Z).
//
// Returns:
//   No return value. This function always succeeds.
//***************************************************************************
void CImap4Agent::GenerateCommandTag(LPSTR lpszTag)
{
    static char szCurrentTag[NUM_TAG_CHARS+1] = "ZZZZ";
    LPSTR p;
    boolean bWraparound;

    // Check arguments
    Assert(m_lRefCount > 0);
    Assert(NULL != lpszTag);

    EnterCriticalSection(&m_csTag);

    // Increment current tag
    p = szCurrentTag + NUM_TAG_CHARS - 1; // p now points to last tag character
    do {
        bWraparound = FALSE;
        *p += 1;
        
        // Increment from '9' should jump to 'A'
        if (*p > '9' && *p < 'A')
            *p = 'A';
        else if (*p > 'Z') {
            // Increment from 'Z' should wrap around to '0'
            *p = '0';
            bWraparound = TRUE;
            p -= 1; // Advance pointer to more significant character
        }
    } while (TRUE == bWraparound && szCurrentTag <= p);

    LeaveCriticalSection(&m_csTag);

    // Return result to caller
    StrCpyN(lpszTag, szCurrentTag, TAG_BUFSIZE);
} // GenerateCommandTag



//***************************************************************************
// Function NoArgCommand
//
// Purpose:
//   This function can construct a command line for any function of the
// form: <tag> <command>.
//
// This function constructs the command line, sends it out, and returns the
// result of the send operation.
//
// Arguments:
//   LPCSTR lpszCommandVerb [in] - the command verb, eg, "CREATE".
//   IMAP_COMMAND icCommandID [in] - the command ID for this command,
//     eg, icCREATE_COMMAND.
//   SERVERSTATE ssMinimumState [in] - minimum server state required for
//     the given command. Used for debug purposes only.
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - wParam and lParam form a unique ID assigned by the
//     caller to this IMAP command and its responses. Can be anything, but
//     note that the value of 0, 0 is reserved for unsolicited responses.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::NoArgCommand(LPCSTR lpszCommandVerb,
                                  IMAP_COMMAND icCommandID,
                                  SERVERSTATE ssMinimumState,
                                  WPARAM wParam, LPARAM lParam,
                                  IIMAPCallback *pCBHandler)
{
    HRESULT hrResult;
    char szBuffer[CMDLINE_BUFSIZE];
    CIMAPCmdInfo *piciCommand;
    DWORD dwCmdLineLen;

    // Verify proper server state and set us up as current command
    Assert(m_lRefCount > 0);
    Assert(NULL != lpszCommandVerb);
    Assert(icNO_COMMAND != icCommandID);

    // Only accept cmds if server is in proper state, OR if we're connecting,
    // and the cmd requires Authenticated state or less
    if (ssMinimumState > m_ssServerState &&
        (ssConnecting != m_ssServerState || ssMinimumState > ssAuthenticated)) {
        // Forgive the NOOP command, due to bug #31968 (err msg build-up if svr drops conn)
        AssertSz(icNOOP_COMMAND == icCommandID,
            "The IMAP server is not in the correct state to accept this command.");
        return IXP_E_IMAP_IMPROPER_SVRSTATE;
    }

    piciCommand = new CIMAPCmdInfo(this, icCommandID, ssMinimumState,
        wParam, lParam, pCBHandler);
    if (piciCommand == NULL) {
        hrResult = E_OUTOFMEMORY;
        goto error;
    }
    dwCmdLineLen = wnsprintf(szBuffer, ARRAYSIZE(szBuffer), "%s %s\r\n", piciCommand->szTag, lpszCommandVerb);

    // Send command to server
    hrResult = SendCmdLine(piciCommand, sclAPPEND_TO_END, szBuffer, dwCmdLineLen);
    if (FAILED(hrResult))
        goto error;

    // Transmit command and register with IMAP response parser
    hrResult = SubmitIMAPCommand(piciCommand);

error:
    if (FAILED(hrResult))
        delete piciCommand;

    return hrResult;
} // NoArgCommand



//***************************************************************************
// Function OneArgCommand
//
// Purpose:
//   This function can construct a command line for any function of the
// form: <tag> <command> <astring>. This currently includes SELECT, EXAMINE,
// CREATE, DELETE, SUBSCRIBE and UNSUBSCRIBE. Since all of these commands
// require the server to be in Authorized state, I don't bother asking for
// a minimum SERVERSTATE argument.
//
// This function constructs the command line, sends it out, and returns the
// result of the send operation.
//
// Arguments:
//   LPCSTR lpszCommandVerb [in] - the command verb, eg, "CREATE".
//   LPSTR lpszMboxName [in] - a C string representing the argument for the
//     command. It is automatically converted to an IMAP astring.
//   IMAP_COMMAND icCommandID [in] - the command ID for this command,
//     eg, icCREATE_COMMAND.
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::OneArgCommand(LPCSTR lpszCommandVerb, LPSTR lpszMboxName,
                                   IMAP_COMMAND icCommandID,
                                   WPARAM wParam, LPARAM lParam,
                                   IIMAPCallback *pCBHandler)
{
    HRESULT hrResult;
    char szBuffer[CMDLINE_BUFSIZE];
    CIMAPCmdInfo *piciCommand;
    LPSTR p, pszUTF7MboxName;

    // Verify proper server state and set us up as current command
    Assert(m_lRefCount > 0);
    Assert(NULL != lpszCommandVerb);
    Assert(NULL != lpszMboxName);
    Assert(icNO_COMMAND != icCommandID);

    // Only accept cmds if server is in proper state, OR if we're connecting,
    // and the cmd requires Authenticated state or less (always TRUE in this case)
    if (ssAuthenticated > m_ssServerState && ssConnecting != m_ssServerState) {
        AssertSz(FALSE, "The IMAP server is not in the correct state to accept this command.");
        return IXP_E_IMAP_IMPROPER_SVRSTATE;
    }

    // Initialize variables
    pszUTF7MboxName = NULL;

    piciCommand = new CIMAPCmdInfo(this, icCommandID, ssAuthenticated,
        wParam, lParam, pCBHandler);

    // Construct command line
    p = szBuffer;
    p += wnsprintf(szBuffer, ARRAYSIZE(szBuffer), "%s %s", piciCommand->szTag, lpszCommandVerb);

    // Convert mailbox name to UTF-7
    hrResult = _MultiByteToModifiedUTF7(lpszMboxName, &pszUTF7MboxName);
    if (FAILED(hrResult))
        goto error;

    // Don't worry about long mailbox name overflow, long mbox names will be sent as literals
    hrResult = AppendSendAString(piciCommand, szBuffer, &p, sizeof(szBuffer), pszUTF7MboxName);
    if (FAILED(hrResult))
        goto error;

    // Send command
    p += wnsprintf(p, ARRAYSIZE(szBuffer) - (DWORD)(p - szBuffer), "\r\n"); // Append CRLF
    hrResult = SendCmdLine(piciCommand, sclAPPEND_TO_END, szBuffer, (DWORD) (p - szBuffer));
    if (FAILED(hrResult))
        goto error;

    // Transmit command and register with IMAP response parser    
    hrResult = SubmitIMAPCommand(piciCommand);

error:
    if (FAILED(hrResult))
        delete piciCommand;

    if (NULL != pszUTF7MboxName)
        MemFree(pszUTF7MboxName);

    return hrResult;
} // OneArgCommand



//***************************************************************************
// Function TwoArgCommand
//
// Purpose:
//   This function can construct a command line for any function of the
// form: <tag> <command> <astring> <astring>.
//
// This function constructs the command line, sends it out, and returns the
// result of the send operation.
//
// Arguments:
//   LPCSTR lpszCommandVerb [in] - the command verb, eg, "CREATE".
//   LPCSTR lpszFirstArg [in] - a C string representing the first argument for
//     the command. It is automatically converted to an IMAP astring.
//   LPCSTR lpszSecondArg [in] - a C string representing the first argument
//     for the command. It is automatically converted to an IMAP astring.
//   IMAP_COMMAND icCommandID [in] - the command ID for this command,
//     eg, icCREATE_COMMAND.
//   SERVERSTATE ssMinimumState [in] - minimum server state required for
//     the given command. Used for debug purposes only.
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::TwoArgCommand(LPCSTR lpszCommandVerb,
                                   LPCSTR lpszFirstArg,
                                   LPCSTR lpszSecondArg,
                                   IMAP_COMMAND icCommandID,
                                   SERVERSTATE ssMinimumState,
                                   WPARAM wParam, LPARAM lParam,
                                   IIMAPCallback *pCBHandler)
{
    HRESULT hrResult;
    CIMAPCmdInfo *piciCommand;
    char szCommandLine[CMDLINE_BUFSIZE];
    LPSTR p;

    // Verify proper server state and set us up as current command
    Assert(m_lRefCount > 0);
    Assert(NULL != lpszCommandVerb);
    Assert(NULL != lpszFirstArg);
    Assert(NULL != lpszSecondArg);
    Assert(icNO_COMMAND != icCommandID);

    // Only accept cmds if server is in proper state, OR if we're connecting,
    // and the cmd requires Authenticated state or less
    if (ssMinimumState > m_ssServerState &&
        (ssConnecting != m_ssServerState || ssMinimumState > ssAuthenticated)) {
        AssertSz(FALSE, "The IMAP server is not in the correct state to accept this command.");
        return IXP_E_IMAP_IMPROPER_SVRSTATE;
    }
    
    piciCommand = new CIMAPCmdInfo(this, icCommandID, ssMinimumState,
        wParam, lParam, pCBHandler);
    if (piciCommand == NULL) {
        hrResult = E_OUTOFMEMORY;
        goto error;
    }

    // Send command to server, wait for response
    p = szCommandLine;
    p += wnsprintf(szCommandLine, ARRAYSIZE(szCommandLine), "%s %s", piciCommand->szTag, lpszCommandVerb);

    // Don't worry about buffer overflow, long strings will be sent as literals
    hrResult = AppendSendAString(piciCommand, szCommandLine, &p,
        sizeof(szCommandLine), lpszFirstArg);
    if (FAILED(hrResult))
        goto error;

    // Don't worry about buffer overflow, long strings will be sent as literals
    hrResult = AppendSendAString(piciCommand, szCommandLine, &p,
        sizeof(szCommandLine), lpszSecondArg);
    if (FAILED(hrResult))
        goto error;

    p += wnsprintf(p, ARRAYSIZE(szCommandLine) - (DWORD)(p - szCommandLine), "\r\n"); // Append CRLF
    hrResult = SendCmdLine(piciCommand, sclAPPEND_TO_END, szCommandLine, (DWORD) (p - szCommandLine));
    if (FAILED(hrResult))
        goto error;

    // Transmit command and register with IMAP response parser
    hrResult = SubmitIMAPCommand(piciCommand);

error:
    if (FAILED(hrResult))
        delete piciCommand;

    return hrResult;
} // TwoArgCommand



//***************************************************************************
// Function: RangedCommand
//
// Purpose:
//   This function can construct a command line for any function of the
// form: <tag> <command> <msg range> <string>.
//
// This function constructs the command line, sends it out, and returns the
// result of the send operation. It is the caller's responsiblity to construct
// a string with proper IMAP syntax.
//
// Arguments:
//   LPCSTR lpszCommandVerb [in] - the command verb, eg, "SEARCH".
//   boolean bUIDPrefix [in] - TRUE if the command verb should be prefixed with
//     UID, as in the case of "UID SEARCH".
//   IRangeList *pMsgRange [in] - the message range for this command. The
//     caller can pass NULL for this argument to omit the range, but ONLY
//     if the pMsgRange represents a UID message range.
//   boolean bUIDRangeList [in] - TRUE if pMsgRange represents a UID range,
//     FALSE if pMsgRange represents a message sequence number range. Ignored
//     if pMsgRange is NULL.
//   boolean bAStringCmdArgs [in] - TRUE if lpszCmdArgs should be sent as
//     an ASTRING, FALSE if lpszCmdArgs should be sent
//   LPCSTR lpszCmdArgs [in] - a C string representing the remaining argument
//     for the command. It is the caller's responsibility to ensure that
//     this string is proper IMAP syntax.
//   IMAP_COMMAND icCommandID [in] - the command ID for this command,
//     eg, icSEARCH_COMMAND.
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::RangedCommand(LPCSTR lpszCommandVerb,
                                   boolean bUIDPrefix,
                                   IRangeList *pMsgRange,
                                   boolean bUIDRangeList,
                                   boolean bAStringCmdArgs,
                                   LPSTR lpszCmdArgs,
                                   IMAP_COMMAND icCommandID,
                                   WPARAM wParam, LPARAM lParam,
                                   IIMAPCallback *pCBHandler)
{
    HRESULT hrResult;
    CIMAPCmdInfo *piciCommand;
    char szCommandLine[CMDLINE_BUFSIZE];
    DWORD dwCmdLineLen;
    BOOL fAStringPrependSpace = TRUE;

    // Verify proper server state and set us up as current command
    Assert(m_lRefCount > 0);
    Assert(NULL != lpszCommandVerb);
    Assert(NULL != lpszCmdArgs);
    AssertSz(NULL != pMsgRange || TRUE == bUIDRangeList ||
        icSEARCH_COMMAND == icCommandID, "Only UID cmds or SEARCH can omit msg range");
    Assert(icNO_COMMAND != icCommandID);

    // All ranged commands require selected state
    // Only accept cmds if server is in proper state, OR if we're connecting,
    // and the cmd requires Authenticated state or less (always FALSE in this case)
    if (ssSelected > m_ssServerState) {
        AssertSz(FALSE, "The IMAP server is not in the correct state to accept this command.");
        return IXP_E_IMAP_IMPROPER_SVRSTATE;
    }

    piciCommand = new CIMAPCmdInfo(this, icCommandID, ssSelected,
        wParam, lParam, pCBHandler);
    if (NULL == piciCommand) {
        hrResult = E_OUTOFMEMORY;
        goto error;
    }
    piciCommand->fUIDRangeList = bUIDRangeList;

    // Construct command tag and verb, append to command-line queue
    dwCmdLineLen = wnsprintf(szCommandLine, ARRAYSIZE(szCommandLine),
        bUIDPrefix ? "%s UID %s " : "%s %s ",
        piciCommand->szTag, lpszCommandVerb);

    // Special case: if SEARCH command, UID rangelist requires "UID" in front of range
    if (icSEARCH_COMMAND == icCommandID && NULL != pMsgRange && bUIDRangeList)
        dwCmdLineLen += wnsprintf(szCommandLine + dwCmdLineLen, (ARRAYSIZE(szCommandLine) - dwCmdLineLen), "UID ");

    if (NULL != pMsgRange) {
        Assert(dwCmdLineLen + 1 < sizeof(szCommandLine)); // Check for overflow
        hrResult = SendCmdLine(piciCommand, sclAPPEND_TO_END, szCommandLine, dwCmdLineLen);
        if (FAILED(hrResult))
            goto error;

        // Add message range to command-line queue, if it exists
        hrResult = SendRangelist(piciCommand, pMsgRange, bUIDRangeList);
        if (FAILED(hrResult))
            goto error;

        pMsgRange = NULL; // If we get to this point, MemFree of rangelist will be handled
        fAStringPrependSpace = FALSE; // Rangelist automatically APPENDS space
        dwCmdLineLen = 0;
    }

    // Now append the command-line arguments (remember to append CRLF)
    if (bAStringCmdArgs) {
        LPSTR p;

        p = szCommandLine + dwCmdLineLen;
        // Don't worry about long mailbox name overflow, long mbox names will be sent as literals
        hrResult = AppendSendAString(piciCommand, szCommandLine, &p,
            sizeof(szCommandLine), lpszCmdArgs, fAStringPrependSpace);
        if (FAILED(hrResult))
            goto error;

        p += wnsprintf(p, ARRAYSIZE(szCommandLine) - (DWORD)(p - szCommandLine), "\r\n"); // Append CRLF
        hrResult = SendCmdLine(piciCommand, sclAPPEND_TO_END,
            szCommandLine, (DWORD) (p - szCommandLine));
        if (FAILED(hrResult))
            goto error;
    }
    else {
        if (dwCmdLineLen > 0) {
            hrResult = SendCmdLine(piciCommand, sclAPPEND_TO_END, szCommandLine, dwCmdLineLen);
            if (FAILED(hrResult))
                goto error;
        }

        hrResult = SendCmdLine(piciCommand, sclAPPEND_TO_END | sclAPPEND_CRLF,
            lpszCmdArgs, lstrlen(lpszCmdArgs));
        if (FAILED(hrResult))
            goto error;
    }

    // Transmit command and register with IMAP response parser
    hrResult = SubmitIMAPCommand(piciCommand);

error:
    if (FAILED(hrResult)) {
        if (NULL != piciCommand)
            delete piciCommand;
    }

    return hrResult;
} // RangedCommand



//***************************************************************************
// Function TwoMailboxCommand
//
// Purpose:
//   This function is a wrapper function for TwoArgCommand. This function
// converts the two mailbox names to modified IMAP UTF-7 before submitting
// the two arguments to TwoArgCommand.
//
// Arguments:
//   Same as for TwoArgCommandm except for name/const change:
//   LPSTR lpszFirstMbox [in] - pointer to the first mailbox argument.
//   LPSTR lpszSecondMbox [in] - pointer to the second mailbox argument.
//
// Returns:
//   Same as TwoArgCommand.
//***************************************************************************
HRESULT CImap4Agent::TwoMailboxCommand(LPCSTR lpszCommandVerb,
                                       LPSTR lpszFirstMbox,
                                       LPSTR lpszSecondMbox,
                                       IMAP_COMMAND icCommandID,
                                       SERVERSTATE ssMinimumState,
                                       WPARAM wParam, LPARAM lParam,
                                       IIMAPCallback *pCBHandler)
{
    LPSTR pszUTF7FirstMbox, pszUTF7SecondMbox;
    HRESULT hrResult;

    // Initialize variables
    pszUTF7FirstMbox = NULL;
    pszUTF7SecondMbox = NULL;

    // Convert both mailbox names to UTF-7
    hrResult = _MultiByteToModifiedUTF7(lpszFirstMbox, &pszUTF7FirstMbox);
    if (FAILED(hrResult))
        goto exit;

    hrResult = _MultiByteToModifiedUTF7(lpszSecondMbox, &pszUTF7SecondMbox);
    if (FAILED(hrResult))
        goto exit;

    hrResult = TwoArgCommand(lpszCommandVerb, pszUTF7FirstMbox, pszUTF7SecondMbox,
        icCommandID, ssMinimumState, wParam, lParam, pCBHandler);

exit:
    if (NULL != pszUTF7FirstMbox)
        MemFree(pszUTF7FirstMbox);

    if (NULL != pszUTF7SecondMbox)
        MemFree(pszUTF7SecondMbox);

    return hrResult;
} // TwoMailboxCommand



//***************************************************************************
// Function: parseCapability
//
// Purpose:
//   The CAPABILITY response from the IMAP server consists of a list of
// capbilities, with each capability names separated by a space. This
// function takes a capability name (null-terminated) as its argument.
// If the name is recognized, we set the appropriate flags in
// m_dwCapabilityFlags. Otherwise, we do nothing.
// 
//
// Returns:
//   No return value. This function always succeeds.
//***************************************************************************
void CImap4Agent::parseCapability (LPSTR lpszCapabilityToken)
{
    DWORD dwCapabilityFlag;
    LPSTR p;
    int iResult;

    Assert(m_lRefCount > 0);

    p = lpszCapabilityToken;
    dwCapabilityFlag = 0;
    switch (*lpszCapabilityToken) {
        case 'I':
        case 'i': // Possible IMAP4, IMAP4rev1
            iResult = lstrcmpi(p, "IMAP4");
            if (0 == iResult) {
                dwCapabilityFlag = IMAP_CAPABILITY_IMAP4;
                break;
            }

            iResult = lstrcmpi(p, "IMAP4rev1");
            if (0 == iResult) {
                dwCapabilityFlag = IMAP_CAPABILITY_IMAP4rev1;
                break;
            }

            iResult = lstrcmpi(p, "IDLE");
            if (0 == iResult) {
                dwCapabilityFlag = IMAP_CAPABILITY_IDLE;
                break;
            }

            break; // case 'I' for possible IMAP4, IMAP4rev1, IDLE

        case 'A':
        case 'a': // Possible AUTH
            if (0 == StrCmpNI(p, "AUTH-", 5) ||
                0 == StrCmpNI(p, "AUTH=", 5)) {
                // Parse the authentication mechanism after the '-' or '='
                // I don't recognize any, at the moment
                p += 5;
                AddAuthMechanism(p);
            }

            break; // case 'A' for possible AUTH

        default:
            break; // Do nothing
    } // switch (*lpszCapabilityToken)

    m_dwCapabilityFlags |= dwCapabilityFlag;
} // parseCapability



//***************************************************************************
// Function: AddAuthMechanism
//
// Purpose:
//   This function adds an authentication token from the server (returned via
// CAPABILITY) to our internal list of authentication mechanisms supported
// by the server.
//
// Arguments:
//   LPSTR pszAuthMechanism [in] - a pointer to a null-terminated
//     authentication token from the server returned via CAPABILITY. For
//     instance, "KERBEROS_V4" is an example of an auth token.
//***************************************************************************
void CImap4Agent::AddAuthMechanism(LPSTR pszAuthMechanism)
{
    AssertSz(NULL == m_asAuthStatus.rgpszAuthTokens[m_asAuthStatus.iNumAuthTokens],
        "Memory's a-leaking, and you've just lost an authentication mechanism.");

    if (NULL == pszAuthMechanism || '\0' == *pszAuthMechanism) {
        AssertSz(FALSE, "No authentication mechanism, here!");
        return;
    }

    if (m_asAuthStatus.iNumAuthTokens >= MAX_AUTH_TOKENS) {
        AssertSz(FALSE, "No room in array for more auth tokens!");
        return;
    }

    m_asAuthStatus.rgpszAuthTokens[m_asAuthStatus.iNumAuthTokens] =
        PszDupA(pszAuthMechanism);
    Assert(NULL != m_asAuthStatus.rgpszAuthTokens[m_asAuthStatus.iNumAuthTokens]);

    m_asAuthStatus.iNumAuthTokens += 1;
} // AddAuthMechanism



//***************************************************************************
// Function: Capability
//
// Purpose:
//   The CImap4Agent class always asks for the server's CAPABILITIES after
// a connection is established. The result is saved in a register and
// is available by calling this function.
//
// Arguments:
//   DWORD *pdwCapabilityFlags [out] - a DWORD with bit-flags specifying
//      which capabilities this IMAP server supports is returned here.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Capability (DWORD *pdwCapabilityFlags)
{
    Assert(m_lRefCount > 0);
    Assert(NULL != pdwCapabilityFlags);

    if (m_ssServerState < ssNonAuthenticated) {
        AssertSz(FALSE, "Must be connected before I can return capabilities");
        *pdwCapabilityFlags = 0;
        return IXP_E_IMAP_IMPROPER_SVRSTATE;
    }
    else {
        *pdwCapabilityFlags = m_dwCapabilityFlags;
        return S_OK;
    }
} // Capability



//***************************************************************************
// Function: Select
//
// Purpose:
//   This function issues a SELECT command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//   LPSTR lpszMailboxName - pointer to IMAP-compliant mailbox name
//
// Returns:
//   HRESULT indicating success or failure of send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Select(WPARAM wParam, LPARAM lParam,
                                              IIMAPCallback *pCBHandler,
                                              LPSTR lpszMailboxName)
{
    return OneArgCommand("SELECT", lpszMailboxName, icSELECT_COMMAND,
        wParam, lParam, pCBHandler);
    // Successful SELECT bumps server status to ssSelected
} // Select



//***************************************************************************
// Function: Examine
//
// Purpose:
//   This function issues an EXAMINE command to the IMAP server.
//
// Arguments:
//   Same as for the Select() function.
//
// Returns:
//   Same as for the Select() function.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Examine(WPARAM wParam, LPARAM lParam,
                                               IIMAPCallback *pCBHandler,
                                               LPSTR lpszMailboxName)
{
    return OneArgCommand("EXAMINE", lpszMailboxName, icEXAMINE_COMMAND,
        wParam, lParam, pCBHandler);
    // Successful EXAMINE bumps server status to ssSelected
} // Examine



//***************************************************************************
// Function: Create
//
// Purpose:
//   This function issues a CREATE command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//   LPSTR lpszMailboxName - IMAP-compliant name of the mailbox.
//
// Returns:
//   HRESULT indicating success or failure of send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Create(WPARAM wParam, LPARAM lParam,
                                              IIMAPCallback *pCBHandler,
                                              LPSTR lpszMailboxName)
{
    return OneArgCommand("CREATE", lpszMailboxName, icCREATE_COMMAND,
        wParam, lParam, pCBHandler);
} // Create



//***************************************************************************
// Function: Delete
//
// Purpose:
//   This function issues a DELETE command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//   LPSTR lpszMailboxName - IMAP-compliant name of the mailbox.
//
// Returns:
//   HRESULT indicating success or failure of send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Delete(WPARAM wParam, LPARAM lParam,
                                              IIMAPCallback *pCBHandler,
                                              LPSTR lpszMailboxName)
{
    return OneArgCommand("DELETE", lpszMailboxName, icDELETE_COMMAND,
        wParam, lParam, pCBHandler);
} // Delete



//***************************************************************************
// Function: Rename
//
// Purpose:
//   This function issues a RENAME command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//   LPSTR lpszMailboxName - CURRENT IMAP-compliant name of the mailbox.
//   LPSTR lpszNewMailboxName - NEW IMAP-compliant name of the mailbox.
//
// Returns:
//   HRESULT indicating success or failure of send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Rename(WPARAM wParam, LPARAM lParam,
                                              IIMAPCallback *pCBHandler,
                                              LPSTR lpszMailboxName,
                                              LPSTR lpszNewMailboxName)
{
    return TwoMailboxCommand("RENAME", lpszMailboxName, lpszNewMailboxName,
        icRENAME_COMMAND, ssAuthenticated, wParam, lParam, pCBHandler);
} // Rename



//***************************************************************************
// Function: Subscribe
//
// Purpose:
//   This function issues a SUBSCRIBE command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//   LPSTR lpszMailboxName - IMAP-compliant name of the mailbox.
//
// Returns:
//   HRESULT indicating success or failure of send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Subscribe(WPARAM wParam, LPARAM lParam,
                                                 IIMAPCallback *pCBHandler,
                                                 LPSTR lpszMailboxName)
{
    return OneArgCommand("SUBSCRIBE", lpszMailboxName, icSUBSCRIBE_COMMAND,
        wParam, lParam, pCBHandler);
}  // Subscribe



//***************************************************************************
// Function: Unsubscribe
//
// Purpose:
//   This function issues an UNSUBSCRIBE command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//   LPSTR lpszMailboxName - IMAP-compliant name of the mailbox.
//
// Returns:
//   HRESULT indicating success or failure of send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Unsubscribe(WPARAM wParam, LPARAM lParam,
                                                   IIMAPCallback *pCBHandler,
                                                   LPSTR lpszMailboxName)
{
    return OneArgCommand("UNSUBSCRIBE", lpszMailboxName, icUNSUBSCRIBE_COMMAND,
        wParam, lParam, pCBHandler);
} // Unsubscribe



//***************************************************************************
// Function: List
//
// Purpose:
//   This function issues a LIST command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//   LPSTR lpszMailboxNameReference - IMAP-compliant reference for mbox name
//   LPSTR lpszMailboxNamePattern - IMAP-compliant pattern for mailbox name
//
// Returns:
//   HRESULT indicating success or failure of send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::List(WPARAM wParam, LPARAM lParam,
                                            IIMAPCallback *pCBHandler,
                                            LPSTR lpszMailboxNameReference,
                                            LPSTR lpszMailboxNamePattern)
{
    return TwoMailboxCommand("LIST", lpszMailboxNameReference,
        lpszMailboxNamePattern, icLIST_COMMAND, ssAuthenticated, wParam,
        lParam, pCBHandler);
} // List



//***************************************************************************
// Function: Lsub
//
// Purpose:
//   This function issues a LSUB command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//   LPSTR lpszMailboxNameReference - IMAP-compliant reference for mbox name
//   LPSTR lpszMailboxNamePattern - IMAP-compliant pattern for mailbox name.
//
// Returns:
//   HRESULT indicating success or failure of send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Lsub(WPARAM wParam, LPARAM lParam,
                                            IIMAPCallback *pCBHandler,
                                            LPSTR lpszMailboxNameReference,
                                            LPSTR lpszMailboxNamePattern)
{
    return TwoMailboxCommand("LSUB", lpszMailboxNameReference,
        lpszMailboxNamePattern, icLSUB_COMMAND, ssAuthenticated, wParam,
        lParam, pCBHandler);
} // Lsub



//***************************************************************************
// Function: Append
//
// Purpose:
//   This function issues an APPEND command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//   LPSTR lpszMailboxName - IMAP-compliant mailbox name to append message to.
//   LPSTR lpszMessageFlags - IMAP-compliant list of msg flags to set for msg.
//     Set to NULL to set no message flags. (Avoid passing "()" due to old Cyrus
//     server bug). $REVIEW: This should be changed to IMAP_MSGFLAGS!!!
//   FILETIME ftMessageDateTime - date/time to associate with msg (GMT/UTC)
//   LPSTREAM lpstmMessageToSave - the message to save, in RFC822 format.
//     No need to rewind the stream, this is done by CConnection::SendStream.
//
// Returns:
//   HRESULT indicating success or failure of send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Append(WPARAM wParam, LPARAM lParam,
                                              IIMAPCallback *pCBHandler,
                                              LPSTR lpszMailboxName,
                                              LPSTR lpszMessageFlags,
                                              FILETIME ftMessageDateTime,
                                              LPSTREAM lpstmMessageToSave)
{
    // PARTYTIME!!
    const SYSTEMTIME stDefaultDateTime = {1999, 12, 5, 31, 23, 59, 59, 999};

    HRESULT hrResult;
    FILETIME ftLocalTime;
    SYSTEMTIME stMsgDateTime;
    DWORD dwTimeZoneId;
    LONG lTZBias, lTZHour, lTZMinute;
    TIME_ZONE_INFORMATION tzi;
    ULONG ulMessageSize;
    char szCommandLine[CMDLINE_BUFSIZE];
    CIMAPCmdInfo *piciCommand;
    LPSTR p, pszUTF7MailboxName;

    char cTZSign;
    BOOL bResult;

    // Check arguments
    Assert(m_lRefCount > 0);
    Assert(NULL != lpszMailboxName);
    Assert(NULL != lpstmMessageToSave);

    // Verify proper server state
    // Only accept cmds if server is in proper state, OR if we're connecting,
    // and the cmd requires Authenticated state or less (always TRUE in this case)
    if (ssAuthenticated > m_ssServerState && ssConnecting != m_ssServerState) {
        AssertSz(FALSE, "The IMAP server is not in the correct state to accept this command.");
        return IXP_E_IMAP_IMPROPER_SVRSTATE;
    }

    // Initialize variables
    pszUTF7MailboxName = NULL;
    piciCommand = new CIMAPCmdInfo(this, icAPPEND_COMMAND, ssAuthenticated,
        wParam, lParam, pCBHandler);
    if (piciCommand == NULL) {
        hrResult = E_OUTOFMEMORY;
        goto error;
    }

    // Convert FILETIME to IMAP date/time spec
    bResult = FileTimeToLocalFileTime(&ftMessageDateTime, &ftLocalTime);
    if (bResult)
        bResult = FileTimeToSystemTime(&ftLocalTime, &stMsgDateTime);

    if (FALSE == bResult) {
        Assert(FALSE); // Conversion failed
        // If retail version, just substitute a default system time
        stMsgDateTime = stDefaultDateTime;
    }

    // Figure out time zone (stolen from MsgOut.cpp's HrEmitDateTime)
    dwTimeZoneId = GetTimeZoneInformation (&tzi);
    switch (dwTimeZoneId)
    {
    case TIME_ZONE_ID_STANDARD:
        lTZBias = tzi.Bias + tzi.StandardBias;
        break;

    case TIME_ZONE_ID_DAYLIGHT:
        lTZBias = tzi.Bias + tzi.DaylightBias;
        break;

    case TIME_ZONE_ID_UNKNOWN:
    default:
        lTZBias = 0 ;   // $$BUG:  what's supposed to happen here?
        break;
    }

    lTZHour   = lTZBias / 60;
    lTZMinute = lTZBias % 60;
    cTZSign     = (lTZHour < 0) ? '+' : '-';

    // Get size of message
    hrResult = HrGetStreamSize(lpstmMessageToSave, &ulMessageSize);
    if (FAILED(hrResult))
        goto error;

    // Send command to server
    // Format: tag APPEND mboxName msgFlags "dd-mmm-yyyy hh:mm:ss +/-hhmm" {msgSize}
    p = szCommandLine;
    p += wnsprintf(szCommandLine, ARRAYSIZE(szCommandLine), "%s APPEND", piciCommand->szTag);

    // Convert mailbox name to modified UTF-7
    hrResult = _MultiByteToModifiedUTF7(lpszMailboxName, &pszUTF7MailboxName);
    if (FAILED(hrResult))
        goto error;

    // Don't worry about long mailbox name overflow, long mbox names will be sent as literals
    hrResult = AppendSendAString(piciCommand, szCommandLine, &p, sizeof(szCommandLine),
        pszUTF7MailboxName);
    if (FAILED(hrResult))
        goto error;

    if (NULL != lpszMessageFlags)
        p += wnsprintf(p, ARRAYSIZE(szCommandLine) - (DWORD)(p - szCommandLine), " %.250s", lpszMessageFlags);

    // Limited potential for buffer overflow: mailbox names over 128 bytes are sent as
    // literals, so worst case buffer usage is 11+128+34+flags+literalNum=173+~20=~200
    p += wnsprintf(p, ARRAYSIZE(szCommandLine) - (DWORD)(p - szCommandLine),
        " \"%2d-%.3s-%04d %02d:%02d:%02d %c%02d%02d\" {%lu}\r\n",
        stMsgDateTime.wDay, lpszMonthsOfTheYear[stMsgDateTime.wMonth],
        stMsgDateTime.wYear, stMsgDateTime.wHour, stMsgDateTime.wMinute,
        stMsgDateTime.wSecond,
        cTZSign, abs(lTZHour), abs(lTZMinute),
        ulMessageSize);
    hrResult = SendCmdLine(piciCommand, sclAPPEND_TO_END, szCommandLine, (DWORD) (p - szCommandLine));
    if (FAILED(hrResult))
        goto error;

    // Don't have to wait for response... message body will be queued
    hrResult = SendLiteral(piciCommand, lpstmMessageToSave, ulMessageSize);
    if (FAILED(hrResult))
        goto error;

    // Have to send CRLF to end command line (the literal's CRLF doesn't count)
    hrResult = SendCmdLine(piciCommand, sclAPPEND_TO_END, c_szCRLF, lstrlen(c_szCRLF));
    if (FAILED(hrResult))
        goto error;

    // Transmit command and register with IMAP response parser
    hrResult = SubmitIMAPCommand(piciCommand);

error:
    if (FAILED(hrResult))
        delete piciCommand;

    if (NULL != pszUTF7MailboxName)
        MemFree(pszUTF7MailboxName);

    return hrResult;
} // Append



//***************************************************************************
// Function: Close
//
// Purpose:
//   This function issues a CLOSE command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//
// Returns:
//   HRESULT indicating success or failure of send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Close (WPARAM wParam, LPARAM lParam,
                                              IIMAPCallback *pCBHandler)
{
    return NoArgCommand("CLOSE", icCLOSE_COMMAND, ssSelected,
        wParam, lParam, pCBHandler);
} // Close



//***************************************************************************
// Function: Expunge
//
// Purpose:
//   This function issues an EXPUNGE command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//
// Returns:
//   HRESULT indicating success or failure on send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Expunge (WPARAM wParam, LPARAM lParam,
                                                IIMAPCallback *pCBHandler)
{
    return NoArgCommand("EXPUNGE", icEXPUNGE_COMMAND, ssSelected,
        wParam, lParam, pCBHandler);
} // Expunge



//***************************************************************************
// Function: Search
//
// Purpose:
//   This function issues a SEARCH command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//   LPSTR lpszSearchCriteria - IMAP-compliant list of search criteria
//   boolean bReturnUIDs - if TRUE, we prepend "UID" to command.
//   IRangeList *pMsgRange [in] - range of messages over which to operate
//     the search. This argument should be NULL to exclude the message
//     set from the search criteria.
//   boolean bUIDRangeList [in] - TRUE if pMsgRange refers to a UID range,
//     FALSE if pMsgRange refers to a message sequence number range. If
//     pMsgRange is NULL, this argument is ignored.
//
// Returns:
//   HRESULT indicating success or failure on send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Search(WPARAM wParam, LPARAM lParam,
                                              IIMAPCallback *pCBHandler,
                                              LPSTR lpszSearchCriteria,
                                              boolean bReturnUIDs, IRangeList *pMsgRange,
                                              boolean bUIDRangeList)
{
    return RangedCommand("SEARCH", bReturnUIDs, pMsgRange, bUIDRangeList,
        rcNOT_ASTRING_ARG, lpszSearchCriteria, icSEARCH_COMMAND, wParam,
        lParam, pCBHandler);
} // Search



//***************************************************************************
// Function: Fetch
//
// Purpose:
//   This function issues a FETCH command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//   IRangeList *pMsgRange [in] - range of messages to fetch. The caller
//     should pass NULL if he is using UIDs and he wants to generate his
//     own message set (in lpszFetchArgs). If the caller is using msg
//     seq nums, this argument MUST be specified to allow this class to
//     resequence the msg nums as required.
//   boolean bUIDMsgRange [in] - if TRUE, prepends "UID" to FETCH command and
//     treats pMsgRange as a UID range.
//   LPSTR lpszFetchArgs - arguments to the FETCH command
//   
//
// Returns:
//   HRESULT indicating success or failure of the send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Fetch(WPARAM wParam, LPARAM lParam,
                                             IIMAPCallback *pCBHandler,
                                             IRangeList *pMsgRange,
                                             boolean bUIDMsgRange,
                                             LPSTR lpszFetchArgs)
{
    return RangedCommand("FETCH", bUIDMsgRange, pMsgRange, bUIDMsgRange,
        rcNOT_ASTRING_ARG, lpszFetchArgs, icFETCH_COMMAND, wParam, lParam,
        pCBHandler);
} // Fetch



//***************************************************************************
// Function: Store
//
// Purpose:
//   This function issues a STORE command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//   IRangeList *pMsgRange [in] - range of messages to store. The caller
//     should pass NULL if he is using UIDs and he wants to generate his
//     own message set (in lpszStoreArgs). If the caller is using msg
//     seq nums, this argument MUST be specified to allow this class to
//     resequence the msg nums as required.
//   boolean bUIDRangeList [in] - if TRUE, we prepend "UID" to the STORE command
//   LPSTR lpszStoreArgs - arguments for the STORE command.
//
// Returns:
//   HRESULT indicating success or failure of the send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Store(WPARAM wParam, LPARAM lParam,
                                             IIMAPCallback *pCBHandler,
                                             IRangeList *pMsgRange,
                                             boolean bUIDRangeList,
                                             LPSTR lpszStoreArgs)
{
    return RangedCommand("STORE", bUIDRangeList, pMsgRange, bUIDRangeList,
        rcNOT_ASTRING_ARG, lpszStoreArgs, icSTORE_COMMAND, wParam, lParam,
        pCBHandler);
} // Store



//***************************************************************************
// Function: Copy
//
// Purpose:
//   This function issues a COPY command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//   IRangeList *pMsgRange [in] - the range of messages to copy. This
//     argument must be supplied.
//   boolean bUIDRangeList [in] - if TRUE, prepends "UID" to COPY command
//   LPSTR lpszMailboxName [in] - C String of mailbox name
//
// Returns:
//   HRESULT indicating success or failure of send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Copy(WPARAM wParam, LPARAM lParam,
                                            IIMAPCallback *pCBHandler,
                                            IRangeList *pMsgRange,
                                            boolean bUIDRangeList,
                                            LPSTR lpszMailboxName)
{
    HRESULT hrResult;
    LPSTR pszUTF7MailboxName;
    DWORD dwNumCharsWritten;

    // Initialize variables
    pszUTF7MailboxName = NULL;

    // Convert the mailbox name to modified UTF-7
    hrResult = _MultiByteToModifiedUTF7(lpszMailboxName, &pszUTF7MailboxName);
    if (FAILED(hrResult))
        goto exit;

    hrResult = RangedCommand("COPY", bUIDRangeList, pMsgRange, bUIDRangeList,
        rcASTRING_ARG, pszUTF7MailboxName, icCOPY_COMMAND, wParam, lParam,
        pCBHandler);

exit:
    if (NULL != pszUTF7MailboxName)
        MemFree(pszUTF7MailboxName);

    return hrResult;
} // Copy



//***************************************************************************
// Function: Status
//
// Purpose:
//   This function issues a STATUS command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//   LPSTR pszMailboxName [in] - the mailbox which you want to get the
//     STATUS of.
//   LPSTR pszStatusCmdArgs [in] - the arguments for the STATUS command,
//     eg, "(MESSAGES UNSEEN)".
//
// Returns:
//   HRESULT indicating success or failure of send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Status(WPARAM wParam, LPARAM lParam,
                                              IIMAPCallback *pCBHandler,
                                              LPSTR pszMailboxName,
                                              LPSTR pszStatusCmdArgs)
{
    HRESULT hrResult;
    CIMAPCmdInfo *piciCommand;
    char szCommandLine[CMDLINE_BUFSIZE];
    LPSTR p, pszUTF7MailboxName;

    // Verify proper server state and set us up as current command
    Assert(m_lRefCount > 0);
    Assert(NULL != pszMailboxName);
    Assert(NULL != pszStatusCmdArgs);

    // Initialize variables
    pszUTF7MailboxName = NULL;

    // Verify proper server state
    // Only accept cmds if server is in proper state, OR if we're connecting,
    // and the cmd requires Authenticated state or less (always TRUE in this case)
    if (ssAuthenticated > m_ssServerState && ssConnecting != m_ssServerState) {
        AssertSz(FALSE, "The IMAP server is not in the correct state to accept this command.");
        return IXP_E_IMAP_IMPROPER_SVRSTATE;
    }
    
    piciCommand = new CIMAPCmdInfo(this, icSTATUS_COMMAND, ssAuthenticated,
        wParam, lParam, pCBHandler);
    if (piciCommand == NULL) {
        hrResult = E_OUTOFMEMORY;
        goto error;
    }

    // Send STATUS command to server, wait for response
    p = szCommandLine;
    p += wnsprintf(szCommandLine, ARRAYSIZE(szCommandLine), "%s %s", piciCommand->szTag, "STATUS");

    // Convert the mailbox name to modified UTF-7
    hrResult = _MultiByteToModifiedUTF7(pszMailboxName, &pszUTF7MailboxName);
    if (FAILED(hrResult))
        goto error;

    // Don't worry about long mailbox name overflow, long mbox names will be sent as literals
    hrResult = AppendSendAString(piciCommand, szCommandLine, &p,
        sizeof(szCommandLine), pszUTF7MailboxName);
    if (FAILED(hrResult))
        goto error;

    // Limited overflow risk: since literal threshold is 128, max buffer usage is
    // 11+128+2+args = 141+~20 = 161
    p += wnsprintf(p, ARRAYSIZE(szCommandLine) - (DWORD)(p - szCommandLine), " %.300s\r\n", pszStatusCmdArgs);
    hrResult = SendCmdLine(piciCommand, sclAPPEND_TO_END, szCommandLine, (DWORD) (p - szCommandLine));
    if (FAILED(hrResult))
        goto error;

    // Transmit command and register with IMAP response parser
    hrResult = SubmitIMAPCommand(piciCommand);

error:
    if (NULL != pszUTF7MailboxName)
        MemFree(pszUTF7MailboxName);

    if (FAILED(hrResult))
        delete piciCommand;

    return hrResult;
} // Status



//***************************************************************************
// Function: Noop
//
// Purpose:
//   This function issues a NOOP command to the IMAP server.
//
// Arguments:
//   WPARAM wParam [in] - (see below)
//   LPARAM lParam [in] - the wParam and lParam form a unique ID assigned by
//     the caller to this IMAP command and its responses. Can be anything,
//     but note that the value of 0, 0 is reserved for unsolicited responses.
//   IIMAPCallback *pCBHandler [in] - the CB handler to use to process the
//     responses for this command. If this is NULL, the default CB handler
//     is used.
//
// Returns:
//   HRESULT indicating success or failure of send operation.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::Noop(WPARAM wParam, LPARAM lParam,
                                            IIMAPCallback *pCBHandler)
{
    return NoArgCommand("NOOP", icNOOP_COMMAND, ssNonAuthenticated,
        wParam, lParam, pCBHandler);
} // Noop



//***************************************************************************
// Function: EnterIdleMode
//
// Purpose:
//   This function issues the IDLE command to the server, if the server
// supports this extension. It should be called when no commands are
// currently begin transmitted (or waiting to be transmitted) and no
// commands are expected back from the server. When the next IMAP command is
// issued, the send machine automatically leaves IDLE mode before issuing
// the IMAP command.
//***************************************************************************
void CImap4Agent::EnterIdleMode(void)
{
    CIMAPCmdInfo *piciIdleCmd;
    HRESULT hrResult;
    char sz[NUM_TAG_CHARS + 7 + 1];
    int i;

    // Check if this server supports IDLE
    if (0 == (m_dwCapabilityFlags & IMAP_CAPABILITY_IDLE))
        return; // Nothing to do here

    // Initialize variables
    hrResult = S_OK;
    piciIdleCmd = NULL;

    piciIdleCmd = new CIMAPCmdInfo(this, icIDLE_COMMAND, ssAuthenticated,
        0, 0, NULL);
    if (NULL == piciIdleCmd) {
        hrResult = E_OUTOFMEMORY;
        goto exit;
    }

    i = wnsprintf(sz, ARRAYSIZE(sz), "%.4s IDLE\r\n", piciIdleCmd->szTag);
    Assert(11 == i);
    hrResult = SendCmdLine(piciIdleCmd, sclAPPEND_TO_END, sz, i);
    if (FAILED(hrResult))
        goto exit;

    hrResult = SendPause(piciIdleCmd);
    if (FAILED(hrResult))
        goto exit;

    hrResult = SendCmdLine(piciIdleCmd, sclAPPEND_TO_END, c_szDONE,
        sizeof(c_szDONE) - 1);
    if (FAILED(hrResult))
        goto exit;

    hrResult = SendStop(piciIdleCmd);
    if (FAILED(hrResult))
        goto exit;

    hrResult = SubmitIMAPCommand(piciIdleCmd);

exit:
    if (FAILED(hrResult)) {
        AssertSz(FALSE, "EnterIdleMode failure");
        if (NULL != piciIdleCmd)
            delete piciIdleCmd;
    }
} // EnterIdleMode



//***************************************************************************
// Function: GenerateMsgSet
//
// Purpose:
//   This function takes an array of message ID's (could be UIDs or Msg
// sequence numbers, this function doesn't care) and converts it to an IMAP
// set (see Formal Syntax in RFC1730). If the given array of message ID's is
// SORTED, this function can coalesce a run of numbers into a range. For
// unsorted arrays, it doesn't bother coalescing the numbers.
//
// Arguments:
//   LPSTR lpszDestination [out] - output buffer for IMAP set. NOTE that the
//    output string deposited here has a leading comma which must be 
//   DWORD dwSizeOfDestination [in] - size of output buffer.
//   DWORD *pMsgID [in] - pointer to an array of message ID's (UIDs or Msg
//     sequence numbers)
//   DWORD cMsgID [in] - the number of message ID's passed in the *pMsgID
//     array.
//
// Returns:
//   DWORD indicating the number of characters written. Adding this value
// to the value of lpszDestination will point to the null-terminator at
// the end of the output string.
//***************************************************************************
DWORD CImap4Agent::GenerateMsgSet(LPSTR lpszDestination,
                                  DWORD dwSizeOfDestination,
                                  DWORD *pMsgID,
                                  DWORD cMsgID)
{
    LPSTR p;
    DWORD dwNumMsgsCopied, idStartOfRange, idEndOfRange;
    DWORD dwNumMsgsInRun; // Used to detect if we are in a run of consecutive nums
    boolean bFirstRange; // TRUE if outputting first msg range in set
    
    Assert(m_lRefCount > 0);
    Assert(NULL != lpszDestination);
    Assert(0 != dwSizeOfDestination);
    Assert(NULL != pMsgID);
    Assert(0 != cMsgID);
    
    // Construct the set of messages to copy
    p = lpszDestination;
    DWORD cchSize = dwSizeOfDestination;
    idStartOfRange = *pMsgID;
    dwNumMsgsInRun = 0;
    bFirstRange = TRUE; // Suppress leading comma for first message range in set
    for (dwNumMsgsCopied = 0; dwNumMsgsCopied < cMsgID; dwNumMsgsCopied++ ) {
        if (*pMsgID == idStartOfRange + dwNumMsgsInRun) {
            idEndOfRange = *pMsgID; // Construct a range out of consecutive numbers
            dwNumMsgsInRun += 1;
        }
        else {
            // No more consecutive numbers found, output the range
            cchSize = (DWORD)(dwSizeOfDestination - (p - lpszDestination));
            AppendMsgRange(&p, cchSize, idStartOfRange, idEndOfRange, bFirstRange);
            idStartOfRange = *pMsgID;
            idEndOfRange = *pMsgID;
            dwNumMsgsInRun = 1;
            bFirstRange = FALSE; // Turn on leading comma from this point on
        }
        pMsgID += 1;
    } // for    

    if (dwNumMsgsInRun > 0)
    {
        // Perform append for last msgID
        cchSize = (dwSizeOfDestination - (DWORD)(p - lpszDestination));
        AppendMsgRange(&p, cchSize, idStartOfRange, idEndOfRange, bFirstRange);
    }

    // Check for buffer overflow
    Assert(p < lpszDestination + dwSizeOfDestination);

    return (DWORD) (p - lpszDestination);
} // GenerateMsgSet

    

//***************************************************************************
// Function: AppendMsgRange
//
// Purpose:
//   This function appends a single message range to the given string
// pointer, either in the form ",seq num" or ",seq num:seq num" (NOTE the
// leading comma: this should be suppressed for the first message range in
// the set by setting bSuppressComma to TRUE).
//
// Arguments:
//   LPSTR *ppDest [in/out] - this pointer should always point to the end
//     of the string currently being constructed, although there need not be
//     a null-terminator present. After this function appends its message
//     range to the string, it advances *ppDest by the correct amount.
//     Note that it is the caller's responsibility to perform bounds checking.
//   const DWORD idStartOfRange [in] - the first msg number of the msg range.
//   const DWORD  idEndOfRange [in] - the last msg number of the msg range.
//   const boolean bSuppressComma [in] - TRUE if the leading comma should be
//     suppressed. This is generally TRUE only for the first message range
//     in the set.
//
// Returns:
//   Nothing. Given valid arguments, this function cannot fail.
//***************************************************************************
void CImap4Agent::AppendMsgRange(LPSTR *ppDest, const DWORD cchSizeDest, const DWORD idStartOfRange,
                                 const DWORD idEndOfRange, boolean bSuppressComma)
{
    LPSTR lpszComma;
    int numCharsWritten;

    Assert(m_lRefCount > 0);
    Assert(NULL != ppDest);
    Assert(NULL != *ppDest);
    Assert(0 != idStartOfRange); // MSGIDs are never zero in IMAP-land
    Assert(0 != idEndOfRange);


    if (TRUE == bSuppressComma)
        lpszComma = "";
    else
        lpszComma = ",";

    if (idStartOfRange == idEndOfRange)
        // Single message number
        numCharsWritten = wnsprintf(*ppDest, cchSizeDest, "%s%lu", lpszComma, idStartOfRange);
    else
        // Range of consecutive message numbers
        numCharsWritten = wnsprintf(*ppDest, cchSizeDest, "%s%lu:%lu", lpszComma,
            idStartOfRange, idEndOfRange);

    *ppDest += numCharsWritten;
} // AppendMsgRange



//***************************************************************************
// Function: EnqueueFragment
//
// Purpose:
//   This function takes an IMAP_LINE_FRAGMENT and appends it to the end of
// the given IMAP_LINEFRAG_QUEUE.
//
// Arguments:
//   IMAP_LINE_FRAGMENT *pilfSourceFragment [in] - a pointer to the line
//     fragment to enqueue in the given line fragment queue. This can be
//     a single line fragment (with the pilfNextFragment member set to NULL),
//     or a chain of line fragments.
//   IMAP_LINEFRAG_QUEUE *pilqLineFragQueue [in] - a pointer to the line
//     fragment queue which the given line fragment(s) should be appended to.
//
// Returns:
//   Nothing. Given valid arguments, this function cannot fail.
//***************************************************************************
void CImap4Agent::EnqueueFragment(IMAP_LINE_FRAGMENT *pilfSourceFragment,
                                  IMAP_LINEFRAG_QUEUE *pilqLineFragQueue)
{
    IMAP_LINE_FRAGMENT *pilfLast;

    Assert(m_lRefCount > 0);
    Assert(NULL != pilfSourceFragment);
    Assert(NULL != pilqLineFragQueue);

    // Check for empty queue
    pilfSourceFragment->pilfPrevFragment = pilqLineFragQueue->pilfLastFragment;
    if (NULL == pilqLineFragQueue->pilfLastFragment) {
        Assert(NULL == pilqLineFragQueue->pilfFirstFragment); // True test for emptiness
        pilqLineFragQueue->pilfFirstFragment = pilfSourceFragment;
    }
    else
        pilqLineFragQueue->pilfLastFragment->pilfNextFragment = pilfSourceFragment;
        

    // Find end of queue
    pilfLast = pilfSourceFragment;
    while (NULL != pilfLast->pilfNextFragment)
        pilfLast = pilfLast->pilfNextFragment;

    pilqLineFragQueue->pilfLastFragment = pilfLast;
} // EnqueueFragment



//***************************************************************************
// Function: InsertFragmentBeforePause
//
// Purpose:
//   This function inserts the given IMAP line fragment into the given
// linefrag queue, before the first iltPAUSE element that it finds. If no
// iltPAUSE fragment could be found, the line fragment is added to the end.
//
// Arguments:
//   IMAP_LINE_FRAGMENT *pilfSourceFragment [in] - a pointer to the line
//     fragment to insert before the iltPAUSE element in the given line
//     fragment queue. This can be a single line fragment (with the
//     pilfNextFragment member set to NULL), or a chain of line fragments.
//   IMAP_LINEFRAG_QUEUE *pilqLineFragQueue [in] - a pointer to the line
//     fragment queue which contains the iltPAUSE element.
//***************************************************************************
void CImap4Agent::InsertFragmentBeforePause(IMAP_LINE_FRAGMENT *pilfSourceFragment,
                                            IMAP_LINEFRAG_QUEUE *pilqLineFragQueue)
{
    IMAP_LINE_FRAGMENT *pilfInsertionPt, *pilfPause;

    Assert(m_lRefCount > 0);
    Assert(NULL != pilfSourceFragment);
    Assert(NULL != pilqLineFragQueue);

    // Look for the iltPAUSE fragment in the linefrag queue
    pilfInsertionPt = NULL;
    pilfPause = pilqLineFragQueue->pilfFirstFragment;
    while (NULL != pilfPause && iltPAUSE != pilfPause->iltFragmentType) {
        pilfInsertionPt = pilfPause;
        pilfPause = pilfPause->pilfNextFragment;
    }

    if (NULL == pilfPause) {
        // Didn't find iltPAUSE fragment, insert at tail of queue
        AssertSz(FALSE, "Didn't find iltPAUSE fragment! WHADDUP?");
        EnqueueFragment(pilfSourceFragment, pilqLineFragQueue);
    }
    else {
        IMAP_LINE_FRAGMENT *pilfLast;

        // Find the end of the source fragment
        pilfLast = pilfSourceFragment;
        while (NULL != pilfLast->pilfNextFragment)
            pilfLast = pilfLast->pilfNextFragment;

        // Found an iltPAUSE fragment. Insert the line fragment in front of it
        pilfLast->pilfNextFragment = pilfPause;
        Assert(pilfInsertionPt == pilfPause->pilfPrevFragment);
        pilfPause->pilfPrevFragment = pilfLast;
        if (NULL == pilfInsertionPt) {
            // Insert at the head of the linefrag queue
            Assert(pilfPause == pilqLineFragQueue->pilfFirstFragment);
            pilfSourceFragment->pilfPrevFragment = NULL;
            pilqLineFragQueue->pilfFirstFragment = pilfSourceFragment;
        }
        else {
            // Insert in middle of queue
            Assert(pilfPause == pilfInsertionPt->pilfNextFragment);
            pilfSourceFragment->pilfPrevFragment = pilfInsertionPt;
            pilfInsertionPt->pilfNextFragment = pilfSourceFragment;
        }
    }
} // InsertFragmentBeforePause



//***************************************************************************
// Function: DequeueFragment
//
// Purpose:
//   This function returns the next line fragment from the given line
// fragment queue, removing the returned element from the queue.
//
// Arguments:
//   IMAP_LINEFRAG_QUEUE *pilqLineFragQueue [in] - a pointer to the line
//     fragment queue to dequeue from.
//
// Returns:
//   A pointer to an IMAP_LINE_FRAGMENT. If none are available, NULL is
// returned.
//***************************************************************************
IMAP_LINE_FRAGMENT *CImap4Agent::DequeueFragment(IMAP_LINEFRAG_QUEUE *pilqLineFragQueue)
{
    IMAP_LINE_FRAGMENT *pilfResult;

    // Refcount can be 0 if we're destructing CImap4Agent while a cmd is in progress
    Assert(m_lRefCount >= 0);
    Assert(NULL != pilqLineFragQueue);

    // Return element at head of queue, including NULL if empty queue
    pilfResult = pilqLineFragQueue->pilfFirstFragment;

    if (NULL != pilfResult) {
        // Dequeue the element from list
        pilqLineFragQueue->pilfFirstFragment = pilfResult->pilfNextFragment;
        if (NULL == pilqLineFragQueue->pilfFirstFragment)
            // Queue is now empty, so reset ptr to last fragment
            pilqLineFragQueue->pilfLastFragment = NULL;
        else {
            Assert(pilfResult == pilqLineFragQueue->pilfFirstFragment->pilfPrevFragment);
            pilqLineFragQueue->pilfFirstFragment->pilfPrevFragment = NULL;
        }

        pilfResult->pilfNextFragment = NULL;
        pilfResult->pilfPrevFragment = NULL;
    }
    else {
        AssertSz(FALSE, "Someone just tried to dequeue an element from empty queue");
    }

    return pilfResult;
} // DequeueFragment



//***************************************************************************
// Function: FreeFragment
//
// Purpose:
//   This function frees the given IMAP line fragment and the string or
// stream data associated with it.
//
// Arguments:
//   IMAP_LINE_FRAGMENT **ppilfFragment [in/out] - a pointer to the line
//     fragment to free. The pointer is set to NULL after the fragment
//     is freed.
//
// Returns:
//   Nothing. Given valid arguments, this function cannot fail.
//***************************************************************************
void CImap4Agent::FreeFragment(IMAP_LINE_FRAGMENT **ppilfFragment)
{
    // Refcount can be 0 if we're destructing CImap4Agent while a cmd is in progress
    Assert(m_lRefCount >= 0);
    Assert(NULL != ppilfFragment);
    Assert(NULL != *ppilfFragment);

    if (iltRANGELIST == (*ppilfFragment)->iltFragmentType) {
        (*ppilfFragment)->data.prlRangeList->Release();
    }
    else if (ilsSTREAM == (*ppilfFragment)->ilsLiteralStoreType) {
        Assert(iltLITERAL == (*ppilfFragment)->iltFragmentType);
        (*ppilfFragment)->data.pstmSource->Release();
    }
    else {
        Assert(ilsSTRING == (*ppilfFragment)->ilsLiteralStoreType);
        SafeMemFree((*ppilfFragment)->data.pszSource);
    }

    delete *ppilfFragment;
    *ppilfFragment = NULL;
} // FreeFragment



//***************************************************************************
// Function: SubmitIMAPCommand
//
// Purpose:
//   This function takes a completed CIMAPCmdInfo structure (with completed
// command line) and submits it for transmittal to the IMAP server.
//
// Arguments:
//   CIMAPCmdInfo *piciCommand [in] - this is the completed CIMAPCmdInfo
//     structure to transmit to the IMAP server.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::SubmitIMAPCommand(CIMAPCmdInfo *piciCommand)
{
    Assert(m_lRefCount > 0);
    Assert(NULL != piciCommand);

    // SubmitIMAPCommand is used to send all commands to the IMAP server.
    // This is a good time to clear m_szLastResponseText
    *m_szLastResponseText = '\0';

    // If currently transmitted command is a paused IDLE command, unpause us
    if (m_fIDLE && NULL != m_piciCmdInSending &&
        icIDLE_COMMAND == m_piciCmdInSending->icCommandID &&
        iltPAUSE == m_piciCmdInSending->pilqCmdLineQueue->pilfFirstFragment->iltFragmentType)
        ProcessSendQueue(iseUNPAUSE);

    // Enqueue the command into the send queue
    EnterCriticalSection(&m_csSendQueue);
    if (NULL == m_piciSendQueue)
        // Insert command into empty queue
        m_piciSendQueue = piciCommand;
    else {
        CIMAPCmdInfo *pici;
    
        // Find the end of the send queue
        pici = m_piciSendQueue;
        while (NULL != pici->piciNextCommand)
            pici = pici->piciNextCommand;

        pici->piciNextCommand = piciCommand;
    }
    LeaveCriticalSection(&m_csSendQueue);

    // Command is queued: kickstart its send process
    ProcessSendQueue(iseSEND_COMMAND);

    return S_OK;
} // SubmitIMAPCommand



//***************************************************************************
// Function: DequeueCommand
//
// Purpose:
//   This function removes the command currently being sent from the send
// queue and returns a pointer to it.
//
// Returns:
//   Pointer to CIMAPCmdInfo object if successful, otherwise NULL.
//***************************************************************************
CIMAPCmdInfo *CImap4Agent::DequeueCommand(void)
{
    CIMAPCmdInfo *piciResult;

    Assert(m_lRefCount > 0);

    EnterCriticalSection(&m_csSendQueue);
    piciResult = m_piciCmdInSending;
    m_piciCmdInSending = NULL;
    if (NULL != piciResult) {
        CIMAPCmdInfo *piciCurrent, *piciPrev;

        // Find the command in sending in the send queue
        piciCurrent = m_piciSendQueue;
        piciPrev = NULL;
        while (NULL != piciCurrent) {
            if (piciCurrent == piciResult)
                break; // Found the current command in sending
            
            piciPrev = piciCurrent;
            piciCurrent = piciCurrent->piciNextCommand;
        }

        // Unlink the command from the send queue
        if (NULL == piciPrev)
            // Unlink command from the head of the send queue
            m_piciSendQueue = m_piciSendQueue->piciNextCommand;
        else if (NULL != piciCurrent)
            // Unlink command from the middle/end of the queue
            piciPrev->piciNextCommand = piciCurrent->piciNextCommand;
    }

    LeaveCriticalSection(&m_csSendQueue);
    return piciResult;
} // DequeueCommand



//***************************************************************************
// Function: AddPendingCommand
//
// Purpose:
//   This function adds the given CIMAPCmdInfo object to the list of commands
// pending server responses.
//
// Arguments:
//   CIMAPCmdInfo *piciNewCommand [in] - pointer to command to add to list.
//***************************************************************************
void CImap4Agent::AddPendingCommand(CIMAPCmdInfo *piciNewCommand)
{
    Assert(m_lRefCount > 0);
    
    // Just insert at the head of the list
    EnterCriticalSection(&m_csPendingList);
    piciNewCommand->piciNextCommand = m_piciPendingList;
    m_piciPendingList = piciNewCommand;
    LeaveCriticalSection(&m_csPendingList);
} // AddPendingCommand



//***************************************************************************
// Function: RemovePendingCommand
//
// Purpose:
//   This function looks for a command in the pending command list which
// matches the given tag. If found, it unlinks the CIMAPCmdInfo object from
// the list and returns a pointer to it.
//
// Arguments:
//   LPSTR pszTag [in] - the tag of the command which should be removed.
//
// Returns:
//   Pointer to CIMAPCmdInfo object if successful, otherwise NULL.
//***************************************************************************
CIMAPCmdInfo *CImap4Agent::RemovePendingCommand(LPSTR pszTag)
{
    CIMAPCmdInfo *piciPrev, *piciCurrent;
    boolean bFoundMatch;
    boolean fLeaveBusy = FALSE;

    Assert(m_lRefCount > 0);
    Assert(NULL != pszTag);

    EnterCriticalSection(&m_csPendingList);

    // Look for matching tag in pending command list
    bFoundMatch = FALSE;
    piciPrev = NULL;
    piciCurrent = m_piciPendingList;
    while (NULL != piciCurrent) {
        if (0 == lstrcmp(pszTag, piciCurrent->szTag)) {
            bFoundMatch = TRUE;
            break;
        }

        // Advance ptrs
        piciPrev = piciCurrent;
        piciCurrent = piciCurrent->piciNextCommand;
    }

    if (FALSE == bFoundMatch)
        goto exit;

    // OK, we found the matching command. Unlink it from list
    if (NULL == piciPrev)
        // Unlink first element in pending list
        m_piciPendingList = piciCurrent->piciNextCommand;
    else
        // Unlink element from middle/end of list
        piciPrev->piciNextCommand = piciCurrent->piciNextCommand;

    // If we have removed the last pending command and no commands are being
    // transmitted, it's time to leave the busy section
    if (NULL == m_piciPendingList && NULL == m_piciCmdInSending)
        fLeaveBusy = TRUE;

exit:
    LeaveCriticalSection(&m_csPendingList);

    // Now we're out of &m_csPendingList, call LeaveBusy (needs m_cs). Avoids deadlock.
    if (fLeaveBusy)
        LeaveBusy(); // Typically not needed, anymore

    if (NULL != piciCurrent)
        piciCurrent->piciNextCommand = NULL;

    return piciCurrent;
} // RemovePendingCommand



//***************************************************************************
// Function: GetTransactionID
//
// Purpose:
//   This function maps an IMAP_RESPONSE_ID to a transaction ID. This function
// takes the given IMAP_RESPONSE_ID and compares it with the IMAP command(s)
// currently pending a response. If the given response matches ONE (and only
// one) of the pending IMAP commands, then the transaction ID of that IMAP
// command is returned. If none or more than one match the given response,
// or if the response in general is unsolicited, then a value of 0 is
// returned.
//
// Arguments:
//   WPARAM *pwParam [out] - the wParam for the given response. If conflicts
//     could not be resolved, then a value of 0 is returned.
//   LPARAM *plParam [out] - the lParam for the given response. If conflicts
//     could not be resolved, then a value of 0 is returned.
//   IIMAPCallback **ppCBHandler [out] - the CB Handler for a given response.
//     If conflicts could not be resolved, or if a NULL CB Handler was
//     specified for the associated command, the default CB handler is returned.
//   IMAP_RESPONSE_ID irResponseType [in] - the response type for which the
//     wants a transaction ID.
//***************************************************************************
void CImap4Agent::GetTransactionID(WPARAM *pwParam, LPARAM *plParam,
                                   IIMAPCallback **ppCBHandler,
                                   IMAP_RESPONSE_ID irResponseType)
{
    WPARAM wParam;
    LPARAM lParam;
    IIMAPCallback *pCBHandler;

    Assert(m_lRefCount > 0);
    
    wParam = 0;
    lParam = 0;
    pCBHandler = m_pCBHandler;
    switch (irResponseType) { 
        // The following responses are ALWAYS expected, regardless of cmd
        case irOK_RESPONSE:
        case irNO_RESPONSE:
        case irBAD_RESPONSE:
        case irNONE: // Usually indicates parsing error (reported via ErrorNotification CB)
            FindTransactionID(&wParam, &lParam, &pCBHandler, icALL_COMMANDS);
            break; // Always treat as solicited, so caller can associate with cmd


        // The following responses are always unsolicited, either because
        // they really ARE always unsolicited, or we don't care, or we want
        // to encourage the client to expect a given response at all times
        case irALERT_RESPONSECODE:    // Clearly unsolicited
        case irPARSE_RESPONSECODE:    // Clearly unsolicited
        case irPREAUTH_RESPONSE:      // Clearly unsolicited
        case irEXPUNGE_RESPONSE:      // Client can get this any time, so get used to it
        case irCMD_CONTINUATION:      // No callback involved, don't care
        case irBYE_RESPONSE:          // Can happen at any time
        case irEXISTS_RESPONSE:       // Client can get this any time, so get used to it
        case irRECENT_RESPONSE:       // Client can get this any time, so get used to it
        case irUNSEEN_RESPONSECODE:   // Client can get this any time, so get used to it
        case irSTATUS_RESPONSE:
            break; // Always treated as unsolicited


        // The following response types are considered solicited only for
        // certain commands. Otherwise, they're unsolicited.
        case irFLAGS_RESPONSE:
        case irPERMANENTFLAGS_RESPONSECODE:
        case irREADWRITE_RESPONSECODE:
        case irREADONLY_RESPONSECODE:
        case irUIDVALIDITY_RESPONSECODE:
            FindTransactionID(&wParam, &lParam, &pCBHandler,
                icSELECT_COMMAND, icEXAMINE_COMMAND);
            break; // case irFLAGS_RESPONSE

        case irCAPABILITY_RESPONSE:
            FindTransactionID(&wParam, &lParam, &pCBHandler,
                icCAPABILITY_COMMAND);
            break; // case irCAPABILITY_RESPONSE

        case irLIST_RESPONSE:
            FindTransactionID(&wParam, &lParam, &pCBHandler,
                icLIST_COMMAND);
            break; // case irLIST_RESPONSE

        case irLSUB_RESPONSE:
            FindTransactionID(&wParam, &lParam, &pCBHandler,
                icLSUB_COMMAND);
            break; // case irLSUB_RESPONSE

        case irSEARCH_RESPONSE:
            FindTransactionID(&wParam, &lParam, &pCBHandler,
                icSEARCH_COMMAND);
            break; // case irSEARCH_RESPONSE
        
        case irFETCH_RESPONSE:
            FindTransactionID(&wParam, &lParam, &pCBHandler,
                icFETCH_COMMAND, icSTORE_COMMAND);
            break; // case irFETCH_RESPONSE

        case irTRYCREATE_RESPONSECODE:
            FindTransactionID(&wParam, &lParam, &pCBHandler,
                icAPPEND_COMMAND, icCOPY_COMMAND);
            break; // case irTRYCREATE_RESPONSECODE

            
        default:
            Assert(FALSE);
            break; // default case
    } // switch (irResponseType)

    *pwParam = wParam;
    *plParam = lParam;
    *ppCBHandler = pCBHandler;
} // GetTransactionID



//***************************************************************************
// Function: FindTransactionID
//
// Purpose:
//   This function traverses the pending command list searching for commands
// which match the command types specified in the arguments. If ONE (and only
// one) match is found, then its transaction ID is returne. If none or more
// than one match is found, then a transaction ID of 0 is returned.
//
// Arguments:
//   WPARAM *pwParam [out] - the wParam for the given commands. If conflicts
//     could not be resolved, then a value of 0 is returned. Pass NULL if
//     you are not interested in this value.
//   LPARAM *plParam [out] - the lParam for the given commands. If conflicts
//     could not be resolved, then a value of 0 is returned. Pass NULL if
//     you are not interested in this value.
//   IIMAPCallback **ppCBHandler [out] - the CB Handler for a given response.
//     If conflicts could not be resolved, or if a NULL CB Handler was
//     specified for the associated command, the default CB handler is returned.
//     Pass NULL if you are not interested in this value.
//   IMAP_COMMAND icTarget1 [in] - one of the commands we're looking for in
//     the pending command queue.
//   IMAP_COMMAND icTarget2 [in] - another command we're looking for in
//     the pending command queue.
//
// Returns:
//   0 if no matches were found
//   1 if exactly one match was found
//   2 if two matches was found. Note that there may be MORE than two matches
//     in the pending list. This function gives up after it finds two matches.
//***************************************************************************
WORD CImap4Agent::FindTransactionID (WPARAM *pwParam, LPARAM *plParam,
                                     IIMAPCallback **ppCBHandler,
                                     IMAP_COMMAND icTarget1, IMAP_COMMAND icTarget2)
{
    CIMAPCmdInfo *piciCurrentCmd;
    WPARAM wParam;
    LPARAM lParam;
    IIMAPCallback *pCBHandler;
    WORD wNumberOfMatches;
    boolean bMatchAllCmds;

    Assert(m_lRefCount > 0);

    if (icALL_COMMANDS == icTarget1 ||
        icALL_COMMANDS == icTarget2)
        bMatchAllCmds = TRUE;
    else
        bMatchAllCmds = FALSE;

    wNumberOfMatches = 0;
    wParam = 0;
    lParam = 0;
    pCBHandler = m_pCBHandler;
    EnterCriticalSection(&m_csPendingList);
    piciCurrentCmd = m_piciPendingList;
    while (NULL != piciCurrentCmd) {
        if (bMatchAllCmds ||
            icTarget1 == piciCurrentCmd->icCommandID ||
            icTarget2 == piciCurrentCmd->icCommandID) {
            wParam = piciCurrentCmd->wParam;
            lParam = piciCurrentCmd->lParam;
            pCBHandler = piciCurrentCmd->pCBHandler;

            wNumberOfMatches += 1;
        }

        if (wNumberOfMatches > 1) {
            wParam = 0;
            lParam = 0;
            pCBHandler = m_pCBHandler; // Found more than one match, can't resolve transaction ID
            break;
        }

        piciCurrentCmd = piciCurrentCmd->piciNextCommand;
    }

    LeaveCriticalSection(&m_csPendingList);
    if (NULL != pwParam)
        *pwParam = wParam;
    if (NULL != plParam)
        *plParam = lParam;
    if (NULL != ppCBHandler)
        *ppCBHandler = pCBHandler;

    return wNumberOfMatches;
} // FindTransactionID



//===========================================================================
// Message Sequence Number to UID Conversion Code
//===========================================================================
//***************************************************************************
// Function: NewIRangeList
//
// Purpose:
//   This function returns a pointer to an IRangeList. Its purpose is to
// allow full functionality from an IIMAPTransport pointer without needing
// to resort to CoCreateInstance to get an IRangeList.
//
// Arguments:
//   IRangeList **pprlNewRangeList [out] - if successful, the function
//      returns a pointer to the new IRangeList.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::NewIRangeList(IRangeList **pprlNewRangeList)
{
    if (NULL == pprlNewRangeList)
        return E_INVALIDARG;

    *pprlNewRangeList = (IRangeList *) new CRangeList;
    if (NULL == *pprlNewRangeList)
        return E_OUTOFMEMORY;

    return S_OK;
} // NewIRangeList



//***************************************************************************
// Function: OnIMAPError
//
// Purpose:
//   This function calls ITransportCallback::OnError with the given info.
//
// Arguments:
//   HRESULT hrResult [in] - the error code to use for IXPRESULT::hrResult.
//   LPSTR pszFailureText [in] - a text string describing the failure. This
//     is duplicated for IXPRESULT::pszProblem.
//   BOOL bIncludeLastResponse [in] - if TRUE, this function duplicates
//     the contents of m_szLastResponseText into IXPRESULT::pszResponse.
//     If FALSE, IXPRESULT::pszResponse is left blank. Generally,
//     m_szLastResponseText holds valid information only for errors which
//     occur during the receipt of an IMAP response. Transmit errors should
//     set this argument to FALSE.
//   LPSTR pszDetails [in] - if bIncludeLastResponse is FALSE, the caller
//     may pass a string to place into IXPRESULT::pszResponse here. If none
//     is desired, the user should pass NULL.
//***************************************************************************
void CImap4Agent::OnIMAPError(HRESULT hrResult, LPSTR pszFailureText,
                              BOOL bIncludeLastResponse, LPSTR pszDetails)
{
    IXPRESULT rIxpResult;

    if (NULL == m_pCallback)
        return; // We can't do a damned thing (this can happen due to HandsOffCallback)

	// Save current state
    rIxpResult.hrResult = hrResult;

    if (bIncludeLastResponse) {
        AssertSz(NULL == pszDetails, "Can't have it both ways, buddy!");
        rIxpResult.pszResponse = PszDupA(m_szLastResponseText);        
    }
    else
        rIxpResult.pszResponse = PszDupA(pszDetails);

    rIxpResult.uiServerError = 0;
    rIxpResult.hrServerError = S_OK;
    rIxpResult.dwSocketError = m_pSocket->GetLastError();
    rIxpResult.pszProblem = PszDupA(pszFailureText);

    // Suspend watchdog during callback
    LeaveBusy();

    // Log it
    if (m_pLogFile) {
        int iLengthOfSz;
        char sz[64];
        LPSTR pszErrorText;
        CByteStream bstmErrLog;

        // wnsprintf is limited to an output of 1024 bytes. Use a stream.
        bstmErrLog.Write("ERROR: \"", 8, NULL); // Ignore IStream::Write errors
        bstmErrLog.Write(pszFailureText, lstrlen(pszFailureText), NULL);
        if (bIncludeLastResponse || NULL == pszDetails)
            iLengthOfSz = wnsprintf(sz, ARRAYSIZE(sz), "\", hr=0x%lX", hrResult);
        else {
            bstmErrLog.Write("\" (", 3, NULL);
            bstmErrLog.Write(pszDetails, lstrlen(pszDetails), NULL);
            iLengthOfSz = wnsprintf(sz, ARRAYSIZE(sz), "), hr=0x%lX", hrResult);
        }
        bstmErrLog.Write(sz, iLengthOfSz, NULL);

        if (SUCCEEDED(bstmErrLog.HrAcquireStringA(NULL, &pszErrorText, ACQ_COPY)))
            m_pLogFile->WriteLog(LOGFILE_DB, pszErrorText);
    }

    // Give to callback
    m_pCallback->OnError(m_status, &rIxpResult, THIS_IInternetTransport);

    // Restore the watchdog if required
    if (FALSE == m_fBusy &&
        (NULL != m_piciPendingList || (NULL != m_piciCmdInSending &&
        icIDLE_COMMAND != m_piciCmdInSending->icCommandID))) {
        hrResult = HrEnterBusy();
        Assert(SUCCEEDED(hrResult));
    }

    // Free duplicated strings
    SafeMemFree(rIxpResult.pszResponse);
    SafeMemFree(rIxpResult.pszProblem);
} // OnIMAPError



//***************************************************************************
// Function: HandsOffCallback
//
// Purpose:
//   This function guarantees that the default callback handler will not be
// called from this point on, even if it has commands in the air. The pointer
// to the default CB handler is released and removed from all commands in
// the air and from the default CB handler module variable. NOTE that non-
// default CB handlers are not affected by this call.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::HandsOffCallback(void)
{
    CIMAPCmdInfo *pCurrentCmd;

    // Check current status
    if (NULL == m_pCBHandler) {
        Assert(NULL == m_pCallback);
        return S_OK; // We're already done
    }

    // Remove default CB handler from all cmds in send queue
    // NB: No need to deal with m_piciCmdInSending, since it points into this queue
    pCurrentCmd = m_piciSendQueue;
    while (NULL != pCurrentCmd) {
        if (pCurrentCmd->pCBHandler == m_pCBHandler) {
            pCurrentCmd->pCBHandler->Release();
            pCurrentCmd->pCBHandler = NULL;
        }

        pCurrentCmd = pCurrentCmd->piciNextCommand;
    }

    // Remove default CB handler from all cmds in pending command queue
    pCurrentCmd = m_piciPendingList;
    while (NULL != pCurrentCmd) {
        if (pCurrentCmd->pCBHandler == m_pCBHandler) {
            pCurrentCmd->pCBHandler->Release();
            pCurrentCmd->pCBHandler = NULL;
        }

        pCurrentCmd = pCurrentCmd->piciNextCommand;
    }

    // Remove default CB handler from CImap4Agent and CIxpBase module vars
    m_pCBHandler->Release();
    m_pCBHandler = NULL;

    m_pCallback->Release();
    m_pCallback = NULL;
    return S_OK;
} // HandsOffCallback



//***************************************************************************
// Function: FreeAllData
//
// Purpose:
//   This function deallocates the send and receive queues, the
// MsgSeqNumToUID table, and the authentication mechanism list.
//
// Arguments:
//   HRESULT hrTerminatedCmdResult [in] - if a command is found in the send
//     or pending queue, we must issue a cmd completion notification. This
//     argument tells us what hrResult to return. It must indicate FAILURE.
//***************************************************************************
void CImap4Agent::FreeAllData(HRESULT hrTerminatedCmdResult)
{
    Assert(FAILED(hrTerminatedCmdResult)); // If cmds pending, we FAILED
    char szBuf[MAX_RESOURCESTRING];

    FreeAuthStatus();

    // Clean up the receive queue
    if (NULL != m_ilqRecvQueue.pilfFirstFragment) {
        DWORD dwMsgSeqNum;

        // If receive queue holds a FETCH response, and if the client has stored
        // non-NULL cookies in m_fbpFetchBodyPartInProgress, notify caller that it's over
        if (isFetchResponse(&m_ilqRecvQueue, &dwMsgSeqNum) &&
            (NULL != m_fbpFetchBodyPartInProgress.lpFetchCookie1 ||
             NULL != m_fbpFetchBodyPartInProgress.lpFetchCookie2)) {
            FETCH_CMD_RESULTS_EX fetchResults;
            FETCH_CMD_RESULTS fcrOldFetchStruct;
            IMAP_RESPONSE irIMAPResponse;

            ZeroMemory(&fetchResults, sizeof(fetchResults));
            fetchResults.dwMsgSeqNum = dwMsgSeqNum;
            fetchResults.lpFetchCookie1 = m_fbpFetchBodyPartInProgress.lpFetchCookie1;
            fetchResults.lpFetchCookie2 = m_fbpFetchBodyPartInProgress.lpFetchCookie2;

            irIMAPResponse.wParam = 0;
            irIMAPResponse.lParam = 0;    
            irIMAPResponse.hrResult = hrTerminatedCmdResult;
            irIMAPResponse.lpszResponseText = NULL; // Not relevant

            if (IMAP_FETCHEX_ENABLE & m_dwFetchFlags)
            {
                irIMAPResponse.irtResponseType = irtUPDATE_MSG_EX;
                irIMAPResponse.irdResponseData.pFetchResultsEx = &fetchResults;
            }
            else
            {
                DowngradeFetchResponse(&fcrOldFetchStruct, &fetchResults);
                irIMAPResponse.irtResponseType = irtUPDATE_MSG;
                irIMAPResponse.irdResponseData.pFetchResults = &fcrOldFetchStruct;
            }
            OnIMAPResponse(m_pCBHandler, &irIMAPResponse);
        }

        while (NULL != m_ilqRecvQueue.pilfFirstFragment) {
            IMAP_LINE_FRAGMENT *pilf;

            pilf = DequeueFragment(&m_ilqRecvQueue);
            FreeFragment(&pilf);
        } // while
    } // if (receive queue not empty)

    // To avoid deadlock, whenever we need to enter more than one CS, we must request
    // them in the order specified in the CImap4Agent class definition. Any calls to
    // OnIMAPResponse will require CIxpBase::m_cs, so enter that CS now.
    EnterCriticalSection(&m_cs);

    // Clean up the send queue
    EnterCriticalSection(&m_csSendQueue);
    m_piciCmdInSending = NULL; // No need to delete obj, it points into m_piciSendQueue
    while (NULL != m_piciSendQueue) {
        CIMAPCmdInfo *piciDeletedCmd;

        // Dequeue next command in send queue
        piciDeletedCmd = m_piciSendQueue;
        m_piciSendQueue = piciDeletedCmd->piciNextCommand;

        // Send notification except for non-user-initiated IMAP commands
        if (icIDLE_COMMAND != piciDeletedCmd->icCommandID &&
            icCAPABILITY_COMMAND != piciDeletedCmd->icCommandID &&
            icLOGIN_COMMAND != piciDeletedCmd->icCommandID &&
            icAUTHENTICATE_COMMAND != piciDeletedCmd->icCommandID) {
            IMAP_RESPONSE irIMAPResponse;

            // Notify caller that his command could not be completed
            LoadString(g_hLocRes, idsIMAPCmdNotSent, szBuf, ARRAYSIZE(szBuf));
            irIMAPResponse.wParam = piciDeletedCmd->wParam;
            irIMAPResponse.lParam = piciDeletedCmd->lParam;
            irIMAPResponse.hrResult = hrTerminatedCmdResult;
            irIMAPResponse.lpszResponseText = szBuf;
            irIMAPResponse.irtResponseType = irtCOMMAND_COMPLETION;
            OnIMAPResponse(piciDeletedCmd->pCBHandler, &irIMAPResponse);
        }
        
        delete piciDeletedCmd;
    } // while (NULL != m_piciSendQueue)
    LeaveCriticalSection(&m_csSendQueue);

    // Clean up the pending command queue
    EnterCriticalSection(&m_csPendingList);
    while (NULL != m_piciPendingList) {
        CIMAPCmdInfo *piciDeletedCmd;
        IMAP_RESPONSE irIMAPResponse;

        piciDeletedCmd = m_piciPendingList;
        m_piciPendingList = piciDeletedCmd->piciNextCommand;

        // Send notification except for non-user-initiated IMAP commands
        if (icIDLE_COMMAND != piciDeletedCmd->icCommandID &&
            icCAPABILITY_COMMAND != piciDeletedCmd->icCommandID &&
            icLOGIN_COMMAND != piciDeletedCmd->icCommandID &&
            icAUTHENTICATE_COMMAND != piciDeletedCmd->icCommandID) {
            IMAP_RESPONSE irIMAPResponse;

            // Notify caller that his command could not be completed
            LoadString(g_hLocRes, idsIMAPCmdStillPending, szBuf, ARRAYSIZE(szBuf));
            irIMAPResponse.wParam = piciDeletedCmd->wParam;
            irIMAPResponse.lParam = piciDeletedCmd->lParam;
            irIMAPResponse.hrResult = hrTerminatedCmdResult;
            irIMAPResponse.lpszResponseText = szBuf;
            irIMAPResponse.irtResponseType = irtCOMMAND_COMPLETION;
            OnIMAPResponse(piciDeletedCmd->pCBHandler, &irIMAPResponse);
        }

        delete piciDeletedCmd;
    } // while (NULL != m_piciPendingList)
    LeaveCriticalSection(&m_csPendingList);

    LeaveCriticalSection(&m_cs);

    // Any literals in progress?
    if (NULL != m_pilfLiteralInProgress) {
        m_dwLiteralInProgressBytesLeft = 0;
        FreeFragment(&m_pilfLiteralInProgress);
    }

    // Any fetch body parts in progress?
    if (NULL != m_fbpFetchBodyPartInProgress.pszBodyTag)
        MemFree(m_fbpFetchBodyPartInProgress.pszBodyTag);

    m_fbpFetchBodyPartInProgress = FetchBodyPart_INIT; // So we don't try to free pszBodyTag twice

    // Free MsgSeqNumToUID table
    ResetMsgSeqNumToUID();
} // FreeAllData



//***************************************************************************
// Function: FreeAuthStatus
//
// Purpose:
//   This function frees the data allocated during the course of an
// authentication (all of which is stored in m_asAuthStatus).
//***************************************************************************
void CImap4Agent::FreeAuthStatus(void)
{
    int i;
    
    // Drop the authentication mechanism list
    for (i=0; i < m_asAuthStatus.iNumAuthTokens; i++) {
        if (NULL != m_asAuthStatus.rgpszAuthTokens[i]) {
            MemFree(m_asAuthStatus.rgpszAuthTokens[i]);
            m_asAuthStatus.rgpszAuthTokens[i] = NULL;
        }
    }
    m_asAuthStatus.iNumAuthTokens = 0;

    // Free up Sicily stuff
    SSPIFreeContext(&m_asAuthStatus.rSicInfo);
    if (NULL != m_asAuthStatus.pPackages && 0 != m_asAuthStatus.cPackages)
        SSPIFreePackages(&m_asAuthStatus.pPackages, m_asAuthStatus.cPackages);

    m_asAuthStatus = AuthStatus_INIT;
} // FreeAuthStatus



//===========================================================================
// CIMAPCmdInfo Class
//===========================================================================
// This class contains information about an IMAP command, such as a queue
// of line fragments which constitute the actual command, the tag of the
// command, and the transaction ID used to identify the command to the
// CImap4Agent user.

//***************************************************************************
// Function: CIMAPCmdInfo (Constructor)
//    NOTE that this function deviates from convention in that its public
// module variables are NOT prefixed with a "m_". This was done to make
// access to its public module variables more readable.
//***************************************************************************
CIMAPCmdInfo::CIMAPCmdInfo(CImap4Agent *pImap4Agent,
                           IMAP_COMMAND icCmd, SERVERSTATE ssMinimumStateArg,
                           WPARAM wParamArg, LPARAM lParamArg,
                           IIMAPCallback *pCBHandlerArg)
{
    Assert(NULL != pImap4Agent);
    Assert(icNO_COMMAND != icCmd);

    // Set module (that's right, module) variables
    icCommandID = icCmd;
    ssMinimumState = ssMinimumStateArg;
    wParam = wParamArg;
    lParam = lParamArg;

    // Set ptr to CB Handler - if argument is NULL, substitute default CB handler
    if (NULL != pCBHandlerArg)
        pCBHandler = pCBHandlerArg;
    else
        pCBHandler = pImap4Agent->m_pCBHandler;

    Assert(NULL != pCBHandler)
    if (NULL != pCBHandler)
        pCBHandler->AddRef();

    // No AddRef() necessary, since CImap4Agent is our sole user. When they
    // go, we go, and so does our pointer.
    m_pImap4Agent = pImap4Agent;

    pImap4Agent->GenerateCommandTag(szTag);
    pilqCmdLineQueue = new IMAP_LINEFRAG_QUEUE;
    *pilqCmdLineQueue = ImapLinefragQueue_INIT;

    fUIDRangeList = FALSE;
    piciNextCommand = NULL;
} // CIMAPCmdInfo



//***************************************************************************
// Function: ~CIMAPCmdInfo (Destructor)
//***************************************************************************
CIMAPCmdInfo::~CIMAPCmdInfo(void)
{
    // Flush any unsent items from the command line queue
    while (NULL != pilqCmdLineQueue->pilfFirstFragment) {
        IMAP_LINE_FRAGMENT *pilf;

        pilf = m_pImap4Agent->DequeueFragment(pilqCmdLineQueue);
        m_pImap4Agent->FreeFragment(&pilf);
    }
    delete pilqCmdLineQueue;

    if (NULL != pCBHandler)
        pCBHandler->Release();
} // ~CIMAPCmdInfo



//===========================================================================
// Message Sequence Number to UID Conversion Code
//===========================================================================
//***************************************************************************
// Function: ResizeMsgSeqNumTable
//
// Purpose:
//   This function is called whenever we receive an EXISTS response. It
// resizes the MsgSeqNumToUID table to match the current size of the mailbox.
//
// Arguments:
//   DWORD dwSizeOfMbox [in] - the number returned via the EXISTS response.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::ResizeMsgSeqNumTable(DWORD dwSizeOfMbox)
{
    BOOL bResult;

    Assert(m_lRefCount > 0);

    if (dwSizeOfMbox == m_dwSizeOfMsgSeqNumToUID)
        return S_OK; // Nothing to do, table is already of correct size

    // Check for the case where EXISTS reports new mailbox size before we
    // receive the EXPUNGE cmds to notify us of deletions
    if (dwSizeOfMbox < m_dwHighestMsgSeqNum) {
        // Bad, bad server! (Although not strictly prohibited)
        AssertSz(FALSE, "Received EXISTS before EXPUNGE commands! Check your server.");
        return S_OK; // We only resize after all EXPUNGE responses have been received,
                     // since we don't know who to delete and since the svr expects us to
                     // use OLD msg seq nums until it can update us with EXPUNGE responses
                     // Return S_OK since this is non-fatal.
    }

    // Check for the case where the mailbox has become empty (MemRealloc's not as flex as realloc)
    if (0 == dwSizeOfMbox) {
        ResetMsgSeqNumToUID();
        return S_OK;
    }

    // Resize the table
    bResult = MemRealloc((void **)&m_pdwMsgSeqNumToUID, dwSizeOfMbox * sizeof(DWORD));
    if (FALSE == bResult) {
        char szTemp[MAX_RESOURCESTRING];

        // Report out-of-memory error
        LoadString(g_hLocRes, idsMemory, szTemp, sizeof(szTemp));
        OnIMAPError(E_OUTOFMEMORY, szTemp, DONT_USE_LAST_RESPONSE);
        ResetMsgSeqNumToUID();
        return E_OUTOFMEMORY;
    }
    else {
        LONG lSizeOfUninitMemory;

        // Zero any memory above m_dwHighestMsgSeqNum element to end of array
        lSizeOfUninitMemory = (dwSizeOfMbox - m_dwHighestMsgSeqNum) * sizeof(DWORD);
        if (0 < lSizeOfUninitMemory)
            ZeroMemory(m_pdwMsgSeqNumToUID + m_dwHighestMsgSeqNum, lSizeOfUninitMemory);

        m_dwSizeOfMsgSeqNumToUID = dwSizeOfMbox;
    }

    // Make sure we never shrink the table smaller than highest msg seq num
    Assert(m_dwHighestMsgSeqNum <= m_dwSizeOfMsgSeqNumToUID);
    return S_OK;
} // ResizeMsgSeqNumTable



//***************************************************************************
// Function: UpdateSeqNumToUID
//
// Purpose:
//   This function is called whenever we receive a FETCH response which has
// both a message sequence number and a UID number. It updates the
// MsgSeqNumToUID table so that given msg seq number maps to the given UID.
//
// Arguments:
//   DWORD dwMsgSeqNum [in] - the message sequence number of the FETCH
//     response.
//   DWORD dwUID [in] - the UID of the given message sequence number.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::UpdateSeqNumToUID(DWORD dwMsgSeqNum, DWORD dwUID)
{
    Assert(m_lRefCount > 0);

    // Check args
    if (0 == dwMsgSeqNum || 0 == dwUID) {
        AssertSz(FALSE, "Zero is not an acceptable number for a msg seq num or UID.");
        return E_INVALIDARG;
    }

    // Check if we have a table
    if (NULL == m_pdwMsgSeqNumToUID) {
        // This could mean programmer error, or server never gave us EXISTS
        DOUT("You're trying to update a non-existent MsgSeqNumToUID table.");
    }

    // We cannot check against m_dwHighestMsgSeqNum, because we update that
    // variable at the end of this function! The second-best thing to do is
    // to verify that we lie within m_dwSizeOfMsgSeqNum.
    if (dwMsgSeqNum > m_dwSizeOfMsgSeqNumToUID || NULL == m_pdwMsgSeqNumToUID) {
        HRESULT hrResult;

        DOUT("Msg seq num out of range! Could be server bug, or out of memory.");
        hrResult = ResizeMsgSeqNumTable(dwMsgSeqNum); // Do the robust thing: resize our table
        if(FAILED(hrResult))
            return hrResult;
    }

    // Check for screwups
    // First check if a UID has been changed
    if (0 != m_pdwMsgSeqNumToUID[dwMsgSeqNum-1] &&
        m_pdwMsgSeqNumToUID[dwMsgSeqNum-1] != dwUID) {
        char szTemp[MAX_RESOURCESTRING];
        char szDetails[MAX_RESOURCESTRING];

        wnsprintf(szDetails, ARRAYSIZE(szDetails), "MsgSeqNum %lu: Previous UID: %lu, New UID: %lu.",
            dwMsgSeqNum, m_pdwMsgSeqNumToUID[dwMsgSeqNum-1], dwUID);
        LoadString(g_hLocRes, idsIMAPUIDChanged, szTemp, sizeof(szTemp));
        OnIMAPError(IXP_E_IMAP_CHANGEDUID, szTemp, DONT_USE_LAST_RESPONSE, szDetails);
        // In this case, we'll still return S_OK, but user will know of problem
    }

    // Next, verify that this UID is strictly ascending: this UID should be
    // strictly greater than previous UID, and stricly less than succeeding UID
    // Succeeding UID can be 0 (indicates it's uninitialized)
    if (1 != dwMsgSeqNum && m_pdwMsgSeqNumToUID[dwMsgSeqNum-2] >= dwUID || // Check UID below
        dwMsgSeqNum < m_dwSizeOfMsgSeqNumToUID &&                         // Check UID above
        0 != m_pdwMsgSeqNumToUID[dwMsgSeqNum] &&
        m_pdwMsgSeqNumToUID[dwMsgSeqNum] <= dwUID) {
        char szTemp[MAX_RESOURCESTRING];
        char szDetails[MAX_RESOURCESTRING];

        wnsprintf(szDetails, ARRAYSIZE(szDetails), "MsgSeqNum %lu, New UID %lu. Prev UID: %lu, Next UID: %lu.",
            dwMsgSeqNum, dwUID, 1 == dwMsgSeqNum ? 0 : m_pdwMsgSeqNumToUID[dwMsgSeqNum-2],
            dwMsgSeqNum >= m_dwSizeOfMsgSeqNumToUID ? 0 : m_pdwMsgSeqNumToUID[dwMsgSeqNum]);
        LoadString(g_hLocRes, idsIMAPUIDOrder, szTemp, sizeof(szTemp));
        OnIMAPError(IXP_E_IMAP_UIDORDER, szTemp, DONT_USE_LAST_RESPONSE, szDetails);
        // In this case, we'll still return S_OK, but user will know of problem
    }

    // Record the given UID under the given msg seq number
    m_pdwMsgSeqNumToUID[dwMsgSeqNum-1] = dwUID;
    if (dwMsgSeqNum > m_dwHighestMsgSeqNum)
        m_dwHighestMsgSeqNum = dwMsgSeqNum;

    return S_OK;
} // UpdateSeqNumToUID



//***************************************************************************
// Function: RemoveSequenceNum
//
// Purpose:
//   This function is called whenever we receive an EXPUNGE response. It
// removes the given message sequence number from the MsgSeqNumToUID table,
// and compacts the table so that all message sequence numbers following
// the deleted one are re-sequenced.
//
// Arguments:
//   DWORD dwDeletedMsgSeqNum [in] - message sequence number of deleted msg.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::RemoveSequenceNum(DWORD dwDeletedMsgSeqNum)
{
    DWORD *pdwDest, *pdwSrc;
    LONG lSizeOfBlock;

    Assert(m_lRefCount > 0);

    // Check arguments
    if (dwDeletedMsgSeqNum > m_dwHighestMsgSeqNum || 0 == dwDeletedMsgSeqNum) {
        AssertSz(FALSE, "Msg seq num out of range! Could be server bug, or out of memory.");
        return E_FAIL;
    }

    // Check if we have a table
    if (NULL == m_pdwMsgSeqNumToUID) {
        // This could mean programmer error, or server never gave us EXISTS
        AssertSz(FALSE, "You're trying to update a non-existent MsgSeqNumToUID table.");
        return E_FAIL;
    }

    // Compact the array
    pdwDest = &m_pdwMsgSeqNumToUID[dwDeletedMsgSeqNum-1];
    pdwSrc = pdwDest + 1;
    lSizeOfBlock = (m_dwHighestMsgSeqNum - dwDeletedMsgSeqNum) * sizeof(DWORD);
    if (0 < lSizeOfBlock)
        MoveMemory(pdwDest, pdwSrc, lSizeOfBlock);

    m_dwHighestMsgSeqNum -= 1;

    // Initialize the empty element at top of array to prevent confusion
    ZeroMemory(m_pdwMsgSeqNumToUID + m_dwHighestMsgSeqNum, sizeof(DWORD));
    return S_OK;
} // RemoveSequenceNum



//***************************************************************************
// Function: MsgSeqNumToUID
//
// Purpose:
//   This function takes a message sequence number and converts it to a UID
// based on the MsgSeqNumToUID table.
//
// Arguments:
//   DWORD dwMsgSeqNum [in] - the sequence number for which the caller wants
//     to know the UID.
//   DWORD *pdwUID [out] - the UID associated with the given sequence number
//     is returned here. If none could be found, this function returns 0.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::MsgSeqNumToUID(DWORD dwMsgSeqNum,
                                                      DWORD *pdwUID)
{
    Assert(m_lRefCount > 0);
    Assert(NULL != pdwUID);

    // Check arguments
    if (dwMsgSeqNum > m_dwHighestMsgSeqNum || 0 == dwMsgSeqNum) {
        AssertSz(FALSE, "Msg seq num out of range! Could be server bug, or out of memory.");
        *pdwUID = 0;
        return E_FAIL;
    }

    // Check if we have a table
    if (NULL == m_pdwMsgSeqNumToUID) {
        // This could mean programmer error, or server never gave us EXISTS
        AssertSz(FALSE, "You're trying to update a non-existent MsgSeqNumToUID table.");
        *pdwUID = 0;
        return E_FAIL;
    }

    // IE5 Bug #44956: It's OK for a MsgSeqNumToUID mapping to result in a UID of 0. Sometimes an IMAP
    // server can skip a range of messages. In such cases we will return a failure result.
    *pdwUID = m_pdwMsgSeqNumToUID[dwMsgSeqNum-1];
    if (0 == *pdwUID)
        return OLE_E_BLANK;
    else
        return S_OK;
} // MsgSeqNumToUID



//***************************************************************************
// Function: GetMsgSeqNumToUIDArray
//
// Purpose:
//   This function returns a copy of the MsgSeqNumToUID array. The caller
// will want to do this to delete messages from the cache which no longer
// exist on the server, for example.
//
// Arguments:
//   DWORD **ppdwMsgSeqNumToUIDArray [out] - the function returns a pointer
//     to the copy of the MsgSeqNumToUID array in this argument. Note that
//     it is the caller's responsibility to MemFree the array. If no array
//     is available, or it is empty, the returned pointer value is NULL.
//   DWORD *pdwNumberOfElements [out] - the function returns the size of
//     the MsgSeqNumToUID array.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::GetMsgSeqNumToUIDArray(DWORD **ppdwMsgSeqNumToUIDArray,
                                                              DWORD *pdwNumberOfElements)
{
    BOOL bResult;
    DWORD dwSizeOfArray;

    Assert(m_lRefCount > 0);
    Assert(NULL != ppdwMsgSeqNumToUIDArray);
    Assert(NULL != pdwNumberOfElements);

    // Check if our table is empty. If so, return success, but no array
    if (NULL == m_pdwMsgSeqNumToUID || 0 == m_dwHighestMsgSeqNum) {
        *ppdwMsgSeqNumToUIDArray = NULL;
        *pdwNumberOfElements = 0;
        return S_OK;
    }

    // We have a non-zero-size array to return. Make a copy of our table
    dwSizeOfArray = m_dwHighestMsgSeqNum * sizeof(DWORD);
    bResult = MemAlloc((void **)ppdwMsgSeqNumToUIDArray, dwSizeOfArray);
    if (FALSE == bResult)
        return E_OUTOFMEMORY;

    CopyMemory(*ppdwMsgSeqNumToUIDArray, m_pdwMsgSeqNumToUID, dwSizeOfArray);
    *pdwNumberOfElements = m_dwHighestMsgSeqNum;
    return S_OK;
} // GetMsgSeqNumToUIDArray



//***************************************************************************
// Function: GetHighestMsgSeqNum
//
// Purpose:
//   This function returns the highest message sequence number reported in
// the MsgSeqNumToUID array.
//
// Arguments:
//   DWORD *pdwHighestMSN [out] - the highest message sequence number in the
//     table is returned here.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::GetHighestMsgSeqNum(DWORD *pdwHighestMSN)
{
    Assert(m_lRefCount > 0);
    Assert(NULL != pdwHighestMSN);

    *pdwHighestMSN = m_dwHighestMsgSeqNum;
    return S_OK;
} // GetHighestMsgSeqNum



//***************************************************************************
// Function: ResetMsgSeqNumToUID
//
// Purpose:
//   This function resets the variables used to maintain the MsgSeqNumToUID
// table. This function is called whenever the MsgSeqNumToUID table becomes
// invalid (say, when a new mailbox is selected, or we are disconnected).
//
// Returns:
//   S_OK. This function cannot fail.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::ResetMsgSeqNumToUID(void)
{
    if (NULL != m_pdwMsgSeqNumToUID) {
        MemFree(m_pdwMsgSeqNumToUID);
        m_pdwMsgSeqNumToUID = NULL;
    }

    m_dwSizeOfMsgSeqNumToUID = 0;
    m_dwHighestMsgSeqNum = 0;

    return S_OK;
} // ResetMsgSeqNumToUID



//***************************************************************************
// Function: isPrintableUSASCII
//
// Purpose:
//   This function determines whether the given character is directly
// encodable, or whether the character must be encoded in modified IMAP UTF7,
// as outlined in RFC2060.
//
// Arguments:
//   BOOL fUnicode [in] - TRUE if input string is Unicode, otherwise FALSE.
//   LPCSTR pszIn [in] - pointer to char we want to verify.
//
// Returns:
//   TRUE if the given character may be directly encoded. FALSE if the
// character must be encoded in UTF-7.
//***************************************************************************
inline boolean CImap4Agent::isPrintableUSASCII(BOOL fUnicode, LPCSTR pszIn)
{
    WCHAR wc;

    if (fUnicode)
        wc = *((LPWSTR)pszIn);
    else
        wc = (*pszIn & 0x00FF);

    if (wc >= 0x0020 && wc <= 0x0025 ||
        wc >= 0x0027 && wc <= 0x007e)
        return TRUE;
    else
        return FALSE;
} // isPrintableUSASCII



//***************************************************************************
// Function: isIMAPModifiedBase64
//
// Purpose:
//   This function determines whether the given character is in the modified
// IMAP Base64 set as defined by RFC1521, RFC1642 and RFC2060. This modified
// IMAP Base64 set is used in IMAP-modified UTF-7 encoding of mailbox names.
//
// Arguments:
//   char c [in] - character to be classified.
//
// Returns:
//   TRUE if given character is in the modified IMAP Base64 set, otherwise
// FALSE.
//***************************************************************************
inline boolean CImap4Agent::isIMAPModifiedBase64(const char c)
{
    if (c >= 'A' && c <= 'Z' ||
        c >= 'a' && c <= 'z' ||
        c >= '0' && c <= '9' ||
        '+' == c || ',' == c)
        return TRUE;
    else
        return FALSE;
} // isIMAPModifiedBase64



//***************************************************************************
// Function: isEqualUSASCII
//
// Purpose:
//   This function determines whether the given pointer points to the given
// USASCII character, based on whether we are in Unicode mode or not.
//
// Arguments:
//   BOOL fUnicode [in] - TRUE if input string is Unicode, otherwise FALSE.
//   LPSTR pszIn [in] - pointer to char we want to verify.
//   char c [in] - the USASCII character we want to detect.
//
// Returns:
//   TRUE if given character is the null terminator, otherwise, FALSE.
//***************************************************************************
inline boolean CImap4Agent::isEqualUSASCII(BOOL fUnicode, LPCSTR pszIn, const char c)
{
    if (fUnicode) {
        WCHAR wc = c & 0x00FF;

        if (wc == *((LPWSTR)pszIn))
            return TRUE;
        else
            return FALSE;
    }
    else {
        if (c == *pszIn)
            return TRUE;
        else
            return FALSE;
    }
}



//***************************************************************************
// Function: SetUSASCIIChar
//
// Purpose:
//   This function writes a USASCII character to the given string pointer.
// The purpose of this function is to allow the caller to ignore whether
// he is writing to a Unicode output or not.
//
// Arguments:
//   BOOL fUnicode [in] - TRUE if target is Unicode, else FALSE.
//   LPSTR pszOut [in] - pointer to character's destination. If fUnicode is
//     TRUE, then two bytes will be written to this location.
//   char cUSASCII [in] - the character to be written to pszOut.
//***************************************************************************
inline void CImap4Agent::SetUSASCIIChar(BOOL fUnicode, LPSTR pszOut, char cUSASCII)
{
    Assert(0 == (cUSASCII & 0x80));

    if (fUnicode)
    {
        *((LPWSTR) pszOut) = cUSASCII;
        Assert(0 == (*((LPWSTR) pszOut) & 0xFF80));
    }
    else
        *pszOut = cUSASCII;
} // SetUSASCIIChar



//***************************************************************************
// Function: MultiByteToModifiedUTF7
//
// Purpose:
//   This function takes a MultiByte string and converts it to modified IMAP
// UTF7, which is described in RFC2060.
//
// Arguments:
//   LPCSTR pszSource [in] - pointer to the MultiByte string to convert to UTF7.
//   LPSTR *ppszDestination [out] - a pointer to a string buffer containing
//     the UTF7 equivalent of pszSource is returned here. It is the caller's
//     responsibility to MemFree this string.
//   UINT uiSourceCP [in] - indicates the codepage for pszSource.
//   DWORD dwFlags [in] - Reserved. Leave as 0.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::MultiByteToModifiedUTF7(LPCSTR pszSource,
                                                               LPSTR *ppszDestination,
                                                               UINT uiSourceCP,
                                                               DWORD dwFlags)
{
    int iResult;
    HRESULT hrResult;
    BOOL fPassThrough, fSkipByte;
    LPCSTR pszIn, pszStartOfLastRun;
    CByteStream bstmDestination;
    BOOL fUnicode;

    Assert(m_lRefCount > 0);
    Assert(NULL != pszSource);
    Assert(NULL != ppszDestination);
    Assert(NULL != m_pInternational);

    // Initialize variables
    hrResult = S_OK;
    fPassThrough = TRUE;
    fSkipByte = FALSE;
    pszIn = pszSource;
    pszStartOfLastRun = pszSource;
    fUnicode = (CP_UNICODE == uiSourceCP);

    *ppszDestination = NULL;

    // Loop through the entire input str either in one of two modes:
    // Passthrough, or non-US string collection (where we determine
    // the length of a string which must be encoded in UTF-7).
    while (1) {

        // Skip over the trail bytes
        if (fSkipByte) {
            AssertSz(FALSE == fUnicode, "Unicode has no trail bytes");
            fSkipByte = FALSE;
            if ('\0' != *pszIn)
                pszIn += 1;
            continue;
        }

        if (fPassThrough) {
            if (isEqualUSASCII(fUnicode, pszIn, '&') || isEqualUSASCII(fUnicode, pszIn, '\0') ||
                FALSE == isPrintableUSASCII(fUnicode, pszIn)) {
                // Flush USASCII characters collected until now (if any)
                if (pszIn - pszStartOfLastRun > 0) {
                    LPSTR  pszFreeMe = NULL;
                    LPCSTR pszUSASCII;
                    DWORD dwUSASCIILen = 0;

                    if (fUnicode) {
                        hrResult = UnicodeToUSASCII(&pszFreeMe, (LPCWSTR) pszStartOfLastRun,
                            (DWORD) (pszIn - pszStartOfLastRun), &dwUSASCIILen);
                        if (FAILED(hrResult))
                            goto exit;

                        pszUSASCII = pszFreeMe;
                    }
                    else {
                        pszUSASCII = pszStartOfLastRun;
                        dwUSASCIILen = (DWORD) (pszIn - pszStartOfLastRun);
                    }

                    hrResult = bstmDestination.Write(pszUSASCII, dwUSASCIILen, NULL);
                    if (NULL != pszFreeMe)
                        MemFree(pszFreeMe);

                    if (FAILED(hrResult))
                        goto exit;
                }

                // Special-case the '&' character: it is converted to "&-"
                if (isEqualUSASCII(fUnicode, pszIn, '&')) {
                    // Write "&-" to stream (always in USASCII)
                    hrResult = bstmDestination.Write("&-", sizeof("&-") - 1, NULL);
                    if (FAILED(hrResult))
                        goto exit;

                    // Reset pointers
                    pszStartOfLastRun = pszIn + (fUnicode ? 2 : 1); // Point past "&"
                } // if ('&' == cCurrent)
                else if (FALSE == isEqualUSASCII(fUnicode, pszIn, '\0')) {
                    Assert(FALSE == isPrintableUSASCII(fUnicode, pszIn));

                    // State transition: time for some UTF-7 encoding
                    fPassThrough = FALSE;
                    pszStartOfLastRun = pszIn;
                    if (FALSE == fUnicode && IsDBCSLeadByteEx(uiSourceCP, *pszIn))
                        fSkipByte = TRUE;
                } // else if ('\0' != cCurrent): shortcut calc for non-printable USASCII
            } // if ('&' == cCurrent || '\0' == cCurrent || FALSE == isPrintableUSASCII(cCurrent))

            // Otherwise do nothing, we're collecting a run of USASCII chars

        } // if (fPassThrough)
        else {
            // Non-US String Collection: Keep advancing through input str until
            // we find a char which does not need to be encoded in UTF-7 (incl. NULL)
            if (isPrintableUSASCII(fUnicode, pszIn) || isEqualUSASCII(fUnicode, pszIn, '&') ||
                isEqualUSASCII(fUnicode, pszIn, '\0')) {
                LPSTR pszOut = NULL;
                int iNumCharsWritten;

                // State transition: back to passthrough mode
                fPassThrough = TRUE;
                
                // Convert non-US string to UTF-7
                hrResult = NonUSStringToModifiedUTF7(uiSourceCP, pszStartOfLastRun,
                    (DWORD) (pszIn - pszStartOfLastRun), &pszOut, &iNumCharsWritten);
                if (FAILED(hrResult))
                    goto exit;

                // Write modified UTF-7 string to stream
                hrResult = bstmDestination.Write(pszOut, iNumCharsWritten, NULL);
                MemFree(pszOut);
                if (FAILED(hrResult))
                    goto exit;

                pszStartOfLastRun = pszIn; // Reset for USASCII collection process
                continue; // Do not advance ptr: we want current char to pass through
            }
            else if (FALSE == fUnicode && IsDBCSLeadByteEx(uiSourceCP, *pszIn))
                fSkipByte = TRUE;
        } // else-NOT-fPassThrough

        // Check for end-of-input
        if (isEqualUSASCII(fUnicode, pszIn, '\0'))
            break; // We're done here

        // Advance pointer to next character
        pszIn += (fUnicode ? 2 : 1);
    } // while

exit:
    if (SUCCEEDED(hrResult)) {
        hrResult = bstmDestination.HrAcquireStringA(NULL, ppszDestination,
            ACQ_DISPLACE);
        if (SUCCEEDED(hrResult))
            hrResult = S_OK;
    }

    if (NULL == *ppszDestination && SUCCEEDED(hrResult))
        hrResult = E_OUTOFMEMORY;

    return hrResult;
} // MultiByteToModifiedUTF7



//***************************************************************************
// Function: NonUSStringToModifiedUTF7
//
// Purpose:
//   This function takes a string consisting of non-US-ASCII characters, and
// converts them to modified IMAP UTF-7 (described in RFC2060).
//
// Arguments:
//   UINT uiCurrentACP [in] - codepage used to interpret pszStartOfNonUSASCII
//   LPCSTR pszStartOfNonUSASCII [in] - string to convert to modified IMAP
//     UTF-7.
//   int iLengthOfNonUSASCII [in] - the number of characters in
//     pszStartofNonUSASCII.
//   LPSTR *ppszOut [out] - the destination for the modified IMAP UTF-7 version
//     of pszStartOfNonUSASCII. This function appends a null-terminator. It is
//     the caller's responsibility to call MemFree when finished with the buffer.
//   LPINT piNumCharsWritten [out] - This function returns the number
//     of characters written (excluding null-terminator) to *ppszOut.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::NonUSStringToModifiedUTF7(UINT uiCurrentACP,
                                               LPCSTR pszStartOfNonUSASCII,
                                               int iLengthOfNonUSASCII,
                                               LPSTR *ppszOut,
                                               LPINT piNumCharsWritten)
{
    HRESULT hrResult;
    int iNumCharsWritten, i;
    LPSTR p;
    BOOL fResult;

    Assert(NULL != ppszOut);

    // Initialize return values
    *ppszOut = NULL;
    *piNumCharsWritten = 0;

    // First, convert the non-US string to standard UTF-7 (alloc 1 extra char: leave room for '-')
    iNumCharsWritten = 0; // Tell ConvertString to find proper output buffer size
    hrResult = ConvertString(uiCurrentACP, CP_UTF7, pszStartOfNonUSASCII,
        &iLengthOfNonUSASCII, ppszOut, &iNumCharsWritten, sizeof(char));
    if (FAILED(hrResult))
        goto exit;

    // Now, convert standard UTF-7 to IMAP4 modified UTF-7
    // Replace leading '+' with '&'. Since under IMAP UTF-7 '+' is never
    // encoded, we never expect "+-" as the result. Remember output is always USASCII
    if (iNumCharsWritten > 0 && '+' == **ppszOut)
        **ppszOut = '&';
    else {
        AssertSz(FALSE, "MLANG crapped out on me.");
        hrResult = E_FAIL;
        goto exit;
    }

    // Replace all occurrances of '/' with ','
    p = *ppszOut;
    for (i = 0; i < iNumCharsWritten; i++) {
        if ('/' == *p)
            *p = ',';

        p += 1;
    }

    // p now points to where null-terminator should go.
    // Ensure that the UTF-7 string ends with '-'. Otherwise, put one there
    // (we allocated enough room for one more char plus null-term).
    if ('-' != *(p-1)) {
        *p = '-';
        p += 1;
        iNumCharsWritten += 1;
    }

    // Null-terminate output string, and return values
    *p = '\0';
    *piNumCharsWritten = iNumCharsWritten;

exit:
    if (FAILED(hrResult) && NULL != *ppszOut) {
        MemFree(*ppszOut);
        *ppszOut = NULL;
    }

    return hrResult;
} // NonUSStringToModifiedUTF7



//***************************************************************************
// Function: ModifiedUTF7ToMultiByte
//
// Purpose:
//   This function takes a modified IMAP UTF-7 string (as defined in RFC2060)
// and converts it to a multi-byte string.
//
// Arguments:
//   LPCSTR pszSource [in] - a null-terminated string containing the modified
//     IMAP UTF-7 string to convert to multibyte.
//   LPSTR *ppszDestination [out] - this function returns a pointer to the
//     null-terminated multibyte string (in the system codepage) obtained
//     from pszSource. It is the caller's responsiblity to MemFree this
//     string when it is done with it.
//   UINT uiDestintationCP [in] - indicates the desired codepage for the
//     destination string.
//   DWORD dwFlags [in] - Reserved. Leave as 0.
//
// Returns:
//   HRESULT indicating success or failure. Success result codes include:
//     S_OK - pszSource successfully converted to modified UTF-7
//     IXP_S_IMAP_VERBATIM_MBOX - pszSource could not be converted to multibyte,
//        so ppszDestination contains a duplicate of pszSource. If target CP
//        is Unicode, pszSource is converted to Unicode with the assumption
//        that it is USASCII. IMAP_MBOXXLATE_VERBATIMOK must have been set via
//        SetDefaultCP in order to get this behaviour.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::ModifiedUTF7ToMultiByte(LPCSTR pszSource,
                                                               LPSTR *ppszDestination,
                                                               UINT uiDestinationCP,
                                                               DWORD dwFlags)
{
    HRESULT hrResult;
    BOOL fPassThrough, fTrailByte;
    LPCSTR pszIn, pszStartOfLastRun;
    CByteStream bstmDestination;
    BOOL fUnicode;

    // Initialize variables
    hrResult = S_OK;
    fPassThrough = TRUE;
    fTrailByte = FALSE;
    pszIn = pszSource;
    pszStartOfLastRun = pszSource;
    fUnicode = (CP_UNICODE == uiDestinationCP);

    *ppszDestination = NULL;

    // Loop through the entire input str either in one of two modes:
    // Passthrough, or UTF-7 string collection (where we determine
    // the length of a string which was encoded in UTF-7).
    while (1) {
        char cCurrent;

        cCurrent = *pszIn;
        if (fPassThrough) {
            if ((FALSE == fTrailByte && '&' == cCurrent) || '\0' == cCurrent) {
                // State transition: flush collected non-UTF7
                BOOL    fResult;
                LPSTR   pszFreeMe = NULL;
                LPCSTR  pszNonUTF7;
                int     iNonUTF7Len;
                int     iSrcLen;

                if (fUnicode) {
                    // Convert non-UTF7 to Unicode
                    // Convert system codepage to CP_UNICODE. We KNOW source should be strictly
                    // USASCII, but can't assume it because some IMAP servers don't strictly
                    // prohibit 8-bit mailbox names. SCARY.
                    iSrcLen = (int) (pszIn - pszStartOfLastRun); // Pass in size of input and output buffer
                    iNonUTF7Len = iSrcLen * sizeof(WCHAR) / sizeof(char); // We know max output buffer size
                    hrResult = ConvertString(GetACP(), uiDestinationCP, pszStartOfLastRun,
                        &iSrcLen, &pszFreeMe, &iNonUTF7Len, 0);
                    if (FAILED(hrResult))
                        goto exit;

                    pszNonUTF7 = pszFreeMe;
                }
                else {
                    pszNonUTF7 = pszStartOfLastRun;
                    iNonUTF7Len = (int) (pszIn - pszStartOfLastRun);
                }

                hrResult = bstmDestination.Write(pszNonUTF7, iNonUTF7Len, NULL);
                if (NULL != pszFreeMe)
                    MemFree(pszFreeMe);

                if (FAILED(hrResult))
                    goto exit;

                // Start collecting UTF-7. Loop until we hit '-'
                fPassThrough = FALSE;
                pszStartOfLastRun = pszIn;
            }
            else {
                // Non-UTF7 stuff is copied verbatim to the output: collect it. Assume
                // source is in m_uiDefaultCP codepage. We SHOULD be able to assume
                // source is USASCII only but some svrs are not strict about disallowing 8-bit
                if (FALSE == fTrailByte && IsDBCSLeadByteEx(m_uiDefaultCP, cCurrent))
                    fTrailByte = TRUE;
                else
                    fTrailByte = FALSE;
            }
        }
        else {
            // UTF-7 collection mode: Keep going until we hit non-UTF7 char
            if (FALSE == isIMAPModifiedBase64(cCurrent)) {
                int iLengthOfUTF7, iNumBytesWritten, iOutputBufSize;
                LPSTR pszSrc, pszDest, p;
                BOOL fResult;

                // State transition, time to convert some modified UTF-7
                fPassThrough = TRUE;
                Assert(FALSE == fTrailByte);

                // If current character is '-', absorb it (don't process it)
                if ('-' == cCurrent)
                    pszIn += 1;

                // Check for "&-" or "&(end of buffer/nonBase64)" sequence
                iLengthOfUTF7 = (int) (pszIn - pszStartOfLastRun);
                if (2 == iLengthOfUTF7 && '-' == cCurrent ||
                    1 == iLengthOfUTF7) {
                    LPSTR psz;
                    DWORD dwLen;

                    Assert('&' == *pszStartOfLastRun);

                    if (fUnicode) {
                        psz = (LPSTR) L"&";
                        dwLen = 2;
                    }
                    else {
                        psz = "&";
                        dwLen = 1;
                    }

                    hrResult = bstmDestination.Write(psz, dwLen, NULL);
                    if (FAILED(hrResult))
                        goto exit;

                    pszStartOfLastRun = pszIn; // Set us up for non-UTF7 collection
                    continue; // Process next character normally
                }

                // Copy the UTF-7 sequence to a temp buffer, and
                // convert modified IMAP UTF-7 to standard UTF-7
                // First, duplicate the IMAP UTF-7 string so we can modify it
                fResult = MemAlloc((void **)&pszSrc, iLengthOfUTF7 + 1); // Room for null-term
                if (FALSE == fResult) {
                    hrResult = E_OUTOFMEMORY;
                    goto exit;
                }
                CopyMemory(pszSrc, pszStartOfLastRun, iLengthOfUTF7);
				pszSrc[iLengthOfUTF7] = '\0';

                // Next, replace leading '&' with '+'
                Assert('&' == *pszSrc);
                pszSrc[0] = '+';

                // Next, replace all ',' with '/'
                p = pszSrc + 1;
                for (iNumBytesWritten = 1; iNumBytesWritten < iLengthOfUTF7;
                     iNumBytesWritten++) {
                    if (',' == *p)
                        *p = '/';

                    p += 1;
                }

                // Now convert the UTF-7 to target codepage
                iNumBytesWritten = 0; // Tell ConvertString to find proper output buffer size
                hrResult = ConvertString(CP_UTF7, uiDestinationCP, pszSrc, &iLengthOfUTF7,
                    &pszDest, &iNumBytesWritten, 0);
                MemFree(pszSrc);
                if (FAILED(hrResult))
                    goto exit;

                // Now write the decoded string to the stream
                hrResult = bstmDestination.Write(pszDest, iNumBytesWritten, NULL);
                MemFree(pszDest);
                if (FAILED(hrResult))
                    goto exit;

                pszStartOfLastRun = pszIn; // Set us up for non-UTF7 collection
                continue; // Do not advance pointer, we want to process current char
            } // if end-of-modified-UTF7 run
        } // else

        // Check for end-of-input
        if ('\0' == cCurrent)
            break; // We're done here

        // Advance input pointer to next character
        pszIn += 1;
    } // while

exit:
    if (SUCCEEDED(hrResult)) {
        hrResult = bstmDestination.HrAcquireStringA(NULL, ppszDestination,
            ACQ_DISPLACE);
        if (SUCCEEDED(hrResult))
            hrResult = S_OK;
    }
    else if (IMAP_MBOXXLATE_VERBATIMOK & m_dwTranslateMboxFlags) {
        // Could not convert UTF-7 to multibyte str. Provide verbatim copy of src
        hrResult = HandleFailedTranslation(fUnicode, FALSE, pszSource, ppszDestination);
        if (SUCCEEDED(hrResult))
            hrResult = IXP_S_IMAP_VERBATIM_MBOX;
    }

    if (NULL == *ppszDestination && SUCCEEDED(hrResult))
        hrResult = E_OUTOFMEMORY;

    return hrResult;
} // ModifiedUTF7ToMultiByte



//***************************************************************************
// Function: UnicodeToUSASCII
//
// Purpose:
//   This function converts a Unicode string to USASCII, allocates a buffer
// to hold the result and returns the buffer to the caller.
//
// Arguments:
//   LPSTR *ppszUSASCII [out] - a pointer to a null-terminated USASCII string
//     is returned here if the function is successful. It is the caller's
//     responsibility to MemFree this buffer.
//   LPCWSTR pwszUnicode [in] - a pointer to the Unicode string to convert.
//   DWORD dwSrcLenInBytes [in] - the length of pwszUnicode in BYTES (NOT in
//     wide chars!).
//   LPDWORD pdwUSASCIILen [out] - the length of ppszUSASCII is returned here.
//
// Returns:
//  HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::UnicodeToUSASCII(LPSTR *ppszUSASCII, LPCWSTR pwszUnicode,
                                      DWORD dwSrcLenInBytes, LPDWORD pdwUSASCIILen)
{
    LPSTR   pszOutput = NULL;
    BOOL    fResult;
    HRESULT hrResult = S_OK;
    LPCWSTR pwszIn;
    LPSTR   pszOut;
    int     iOutputBufSize;
    DWORD   dw;

    if (NULL == pwszUnicode || NULL == ppszUSASCII) {
        Assert(FALSE);
        return E_INVALIDARG;
    }

    // Allocate the output buffer
    *ppszUSASCII = NULL;
    if (NULL != pdwUSASCIILen)
        *pdwUSASCIILen = 0;

    iOutputBufSize = (dwSrcLenInBytes/2) + 1;
    fResult = MemAlloc((void **) &pszOutput, iOutputBufSize);
    if (FALSE == fResult) {
        hrResult = E_OUTOFMEMORY;
        goto exit;
    }

    // Convert Unicode to ASCII
    pwszIn = pwszUnicode;
    pszOut = pszOutput;
    for (dw = 0; dw < dwSrcLenInBytes; dw += 2) {
        Assert(0 == (*pwszIn & 0xFF80));
        *pszOut = (*pwszIn & 0x00FF);

        pwszIn += 1;
        pszOut += 1;
    }

    // Null-terminate the output
    *pszOut = '\0';
    Assert(pszOut - pszOutput + 1 == iOutputBufSize);

exit:
    if (SUCCEEDED(hrResult)) {
        *ppszUSASCII = pszOutput;
        if (NULL != pdwUSASCIILen)
            *pdwUSASCIILen = (DWORD) (pszOut - pszOutput);
    }

    return hrResult;
} // UnicodeToUSASCII



//***************************************************************************
// Function: ASCIIToUnicode
//
// Purpose:
//   This function converts an ASCII string to Unicode, allocates a buffer
// to hold the result and returns the buffer to the caller.
//
// Arguments:
//   LPWSTR *ppwszUnicode [out] - a pointer to a null-terminated Unicode string
//     is returned here if the function is successful. It is the caller's
//     responsibility to MemFree this buffer.
//   LPCSTR pszASCII [in] - a pointer to the ASCII string to convert.
//   DWORD dwSrcLen [in] - the length of pszASCII.
//
// Returns:
//  HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::ASCIIToUnicode(LPWSTR *ppwszUnicode, LPCSTR pszASCII,
                                      DWORD dwSrcLen)
{
    LPWSTR  pwszOutput = NULL;
    BOOL    fResult;
    HRESULT hrResult = S_OK;
    LPCSTR  pszIn;
    LPWSTR  pwszOut;
    int     iOutputBufSize;
    DWORD   dw;

    if (NULL == ppwszUnicode || NULL == pszASCII) {
        Assert(FALSE);
        return E_INVALIDARG;
    }

    // Allocate the output buffer
    *ppwszUnicode = NULL;
    iOutputBufSize = (dwSrcLen + 1) * sizeof(WCHAR);
    fResult = MemAlloc((void **) &pwszOutput, iOutputBufSize);
    if (FALSE == fResult) {
        hrResult = E_OUTOFMEMORY;
        goto exit;
    }

    // Convert USASCII to Unicode
    pszIn = pszASCII;
    pwszOut = pwszOutput;
    for (dw = 0; dw < dwSrcLen; dw++) {
        *pwszOut = (WCHAR)*pszIn & 0x00FF;

        pszIn += 1;
        pwszOut += 1;
    }

    // Null-terminate the output
    *pwszOut = L'\0';
    Assert(pwszOut - pwszOutput + (int)sizeof(WCHAR) == iOutputBufSize);

exit:
    if (SUCCEEDED(hrResult))
        *ppwszUnicode = pwszOutput;

    return hrResult;
} // ASCIIToUnicode



//***************************************************************************
// Function: _MultiByteToModifiedUTF7
//
// Purpose:
//   Internal form of MultiByteToModifiedUTF7. Checks m_dwTranslateMboxFlags
// and uses m_uiDefaultCP. All other aspects are identical to
// MultiByteToModifiedUTF7.
//***************************************************************************
HRESULT CImap4Agent::_MultiByteToModifiedUTF7(LPCSTR pszSource, LPSTR *ppszDestination)
{
    HRESULT hrResult;

    // Check if we're doing translations
    if (ISFLAGSET(m_dwTranslateMboxFlags, IMAP_MBOXXLATE_DISABLE) ||
        ISFLAGSET(m_dwTranslateMboxFlags, IMAP_MBOXXLATE_DISABLEIMAP4) &&
            ISFLAGCLEAR(m_dwCapabilityFlags, IMAP_CAPABILITY_IMAP4rev1)) {

        // No translations! Just copy mailbox name VERBATIM
        if (CP_UNICODE == m_uiDefaultCP)
            *ppszDestination = (LPSTR) PszDupW((LPWSTR)pszSource);
        else
            *ppszDestination = PszDupA(pszSource);

        if (NULL == *ppszDestination)
            hrResult = E_OUTOFMEMORY;
        else
            hrResult = S_OK;

        goto exit;
    }

    hrResult = MultiByteToModifiedUTF7(pszSource, ppszDestination, m_uiDefaultCP, 0);

exit:
    return hrResult;
} // _MultiByteToModifiedUTF7


//***************************************************************************
// Function: _ModifiedUTF7ToMultiByte
//
// Purpose:
//   Internal form of ModifiedUTF7ToMultiByte. Checks m_dwTranslateMboxFlags
// and uses m_uiDefaultCP. All other aspects are identical to
// ModifiedUTF7ToMultiByte.
//***************************************************************************
HRESULT CImap4Agent::_ModifiedUTF7ToMultiByte(LPCSTR pszSource, LPSTR *ppszDestination)
{
    HRESULT hrResult = S_OK;

    // Check if we're doing translations
    if (ISFLAGSET(m_dwTranslateMboxFlags, IMAP_MBOXXLATE_DISABLE) ||
        ISFLAGSET(m_dwTranslateMboxFlags, IMAP_MBOXXLATE_DISABLEIMAP4) &&
            ISFLAGCLEAR(m_dwCapabilityFlags, IMAP_CAPABILITY_IMAP4rev1)) {

        // No translations! Just copy mailbox name VERBATIM
        if (CP_UNICODE == m_uiDefaultCP) {
            hrResult = ASCIIToUnicode((LPWSTR *)ppszDestination, pszSource, lstrlenA(pszSource));
            if (FAILED(hrResult))
                goto exit;
        }
        else {
            *ppszDestination = PszDupA(pszSource);
            if (NULL == *ppszDestination) {
                hrResult = E_OUTOFMEMORY;
                goto exit;
            }
        }

        // If we reached this point, we succeeded. Return IXP_S_IMAP_VERBATIM_MBOX for
        // verbatim-capable clients so client can mark mailbox with appropriate attributes
        Assert(S_OK == hrResult); // If not S_OK, old IIMAPTransport clients better be able to deal with it
        if (ISFLAGSET(m_dwTranslateMboxFlags, IMAP_MBOXXLATE_VERBATIMOK))
            hrResult = IXP_S_IMAP_VERBATIM_MBOX;

        goto exit;
    }

    hrResult = ModifiedUTF7ToMultiByte(pszSource, ppszDestination, m_uiDefaultCP, 0);

exit:
    return hrResult;
} // _ModifiedUTF7ToMultiByte



//***************************************************************************
// Function: ConvertString
//
// Purpose:
//   This function allocates a buffer and converts the source string to
// the target codepage, returning the output buffer. This function also
// checks to see if the conversion is round-trippable. If not, then a failure
// result is returned.
//
// Arguments:
//   UINT uiSourceCP [in] - codepage of pszSource.
//   UINT uiDestCP [in] - desired codepage of *ppszDest.
//   LPCSTR pszSource [in] - source string to convert to target codepage.
//   int *piSrcLen [in] - caller passes in length of pszSource.
//   LPSTR *ppszDest [out] - if successful, this function returns a pointer
//     to an output buffer containing pszSource translated to uiDestCP.
//     It is the caller's responsibility to MemFree this buffer.
//   int *piDestLen [in/out] - caller passes in maximum expected size of
//     *ppszDest. If caller passes in 0, this function determines the proper
//     size buffer to allocate. If successful, this function returns the
//     length of the output string (which is not necessarily the size of
//     the output buffer).
//   int iOutputExtra [in] - number of extra bytes to allocate in the output
//     buffer. This is useful if the caller wants to append something to
//     the output string.
//
// Returns:
//   HRESULT indicating success or failure. Success means that the conversion
// was roundtrippable, meaning that if you call this function again with
// *ppszDest as the source, the output will be identical to previous pszSource.
//***************************************************************************
HRESULT CImap4Agent::ConvertString(UINT uiSourceCP, UINT uiDestCP,
                                   LPCSTR pszSource, int *piSrcLen,
                                   LPSTR *ppszDest, int *piDestLen,
                                   int iOutputExtra)
{
    HRESULT hrResult;
    BOOL    fResult;
    int     iOutputLen;
    LPSTR   pszOutput = NULL;

    Assert(NULL != pszSource);
    Assert(NULL != piSrcLen);
    Assert(NULL != ppszDest);
    Assert(NULL != piDestLen);

    // Initialize return values
    *ppszDest = NULL;
    *piDestLen = 0;

    hrResult = m_pInternational->MLANG_ConvertInetReset();
    if (FAILED(hrResult))
        goto exit;

    // Find out how big an output buffer is required, if user doesn't supply a size
    if (*piDestLen == 0) {
        hrResult = m_pInternational->MLANG_ConvertInetString(uiSourceCP, uiDestCP,
            pszSource, piSrcLen, NULL, &iOutputLen);
        if (S_OK != hrResult)
            goto exit;
    }
    else
        iOutputLen = *piDestLen;

    // Allocate the output buffer. Leave room for wide null-term, too
    fResult = MemAlloc((void **)&pszOutput, iOutputLen + iOutputExtra + 2);
    if (FALSE == fResult) {
        hrResult = E_OUTOFMEMORY;
        goto exit;
    }

    // Now perform the conversion
    hrResult = m_pInternational->MLANG_ConvertInetString(uiSourceCP, uiDestCP,
        pszSource, piSrcLen, pszOutput, &iOutputLen);
    if (S_OK != hrResult)
        goto exit;

    // ========================================================*** TAKE OUT after MLANG gets better ***
    // Try the round-trip conversion
    LPSTR pszRoundtrip;
    fResult = MemAlloc((void **)&pszRoundtrip, *piSrcLen + 2);
    if (FALSE == fResult) {
        hrResult = E_OUTOFMEMORY;
        goto exit;
    }

    hrResult = m_pInternational->MLANG_ConvertInetReset();
    if (FAILED(hrResult))
        goto exit;

    int iRoundtripSrc; 
    int iRoundtripDest;

    iRoundtripSrc = iOutputLen;
    iRoundtripDest = *piSrcLen;
    hrResult = m_pInternational->MLANG_ConvertInetString(uiDestCP, uiSourceCP,
        pszOutput, &iRoundtripSrc, pszRoundtrip, &iRoundtripDest);
    if (FAILED(hrResult))
        goto exit;

    if (iRoundtripDest != *piSrcLen) {
        MemFree(pszRoundtrip);
        hrResult = S_FALSE;
        goto exit;
    }

    int iRoundtripResult;
    Assert(iRoundtripDest == *piSrcLen);
    if (CP_UNICODE != uiSourceCP)
        iRoundtripResult = StrCmpNA(pszRoundtrip, pszSource, iRoundtripDest);
    else
        iRoundtripResult = StrCmpNW((LPWSTR)pszRoundtrip, (LPCWSTR)pszSource, iRoundtripDest);

    MemFree(pszRoundtrip);
    if (0 != iRoundtripResult)
        hrResult = S_FALSE;
    else
        Assert(S_OK == hrResult);

    // ========================================================*** TAKE OUT after MLANG gets better ***

exit:
    if (S_OK == hrResult) {
        *ppszDest = pszOutput;
        *piDestLen = iOutputLen;
    }
    else {
        if (SUCCEEDED(hrResult))
            // One or more chars not convertable. We're not round-trippable so we must fail
            hrResult = E_FAIL;

        if (NULL != pszOutput)
            MemFree(pszOutput);
    }

    return hrResult;
} // ConvertString



//***************************************************************************
// Function: HandleFailedTranslation
//
// Purpose:
//   In case we cannot translate a mailbox name from modified UTF-7 to
// the desired codepage (we may not have the codepage, for instance), we
// provide a duplicate of the modified UTF-7 mailbox name. This function
// allows the caller to ignore whether target codepage is Unicode or not.
//
// Arguments:
//   BOOL fUnicode [in] - If fToUTF7 is TRUE, then this argument indicates
//     whether pszSource points to a Unicode string or not. If fToUTF7 is
//     FALSE, this arg indicates whether *ppszDest should be in Unicode or not.
//   BOOL fToUTF7 [in] - TRUE if we are converting to UTF7, FALSE if we are
//     converting from UTF7.
//   LPCSTR pszSource [in] - pointer to source string.
//   LPSTR *ppszDest [in] - if sucessful, this function returns a pointer
//     to an output buffer containing a duplicate of pszSource (converted
//     to/from Unicode where necessary). It is the caller's responsibility
//     to MemFree this buffer.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT CImap4Agent::HandleFailedTranslation(BOOL fUnicode, BOOL fToUTF7,
                                             LPCSTR pszSource, LPSTR *ppszDest)
{
    int     i;
    int     iOutputStep;
    int     iInputStep;
    int     iSourceLen;
    int     iOutputBufSize;
    BOOL    fResult;
    LPSTR   pszOutput = NULL;
    HRESULT hrResult = S_OK;
    LPCSTR  pszIn;
    LPSTR   pszOut;

    Assert(m_lRefCount > 0);
    Assert(ISFLAGSET(m_dwTranslateMboxFlags, IMAP_MBOXXLATE_VERBATIMOK));

    // Calculate length of source, size of output buffer
    if (fToUTF7) {
        // Going to UTF7, so output is USASCII
        if (fUnicode) {
            iInputStep = sizeof(WCHAR);
            iSourceLen = lstrlenW((LPCWSTR)pszSource);
        }
        else {
            iInputStep = sizeof(char);
            iSourceLen = lstrlenA(pszSource);
        }

        iOutputStep = sizeof(char);
        iOutputBufSize = iSourceLen + sizeof(char); // Room for null-term
    }
    else {
        // Coming from UTF7, so input is USASCII
        iSourceLen = lstrlenA(pszSource);
        iInputStep = sizeof(char);
        if (fUnicode) {
            iOutputStep = sizeof(WCHAR);
            iOutputBufSize = (iSourceLen + 1) * sizeof(WCHAR); // Room for wide null-term
        }
        else {
            iOutputStep = sizeof(char);
            iOutputBufSize = iSourceLen + sizeof(char); // Room for null-term
        }
    }

    // Allocate output buffer
    fResult = MemAlloc((void **)&pszOutput, iOutputBufSize);
    if (FALSE == fResult) {
        hrResult = E_OUTOFMEMORY;
        goto exit;
    }

    // Copy input to output
    pszIn = pszSource;
    pszOut = pszOutput;
    for (i = 0; i < iSourceLen; i++) {
        char c;

        // Convert input character to USASCII
        if (FALSE == fUnicode || FALSE == fToUTF7)
            c = *pszIn; // Input is already USASCII
        else
            c = *((LPWSTR)pszIn) & 0x00FF; // Convert Unicode to USASCII (too bad if it isn't)

        // Write character to output
        SetUSASCIIChar(FALSE == fToUTF7 && fUnicode, pszOut, c);

        // Advance pointers
        pszIn += iInputStep;
        pszOut += iOutputStep;
    }

    // Null-terminate the output
    SetUSASCIIChar(FALSE == fToUTF7 && fUnicode, pszOut, '\0');

exit:
    if (SUCCEEDED(hrResult))
        *ppszDest = pszOutput;
    else if (NULL != pszOutput)
        MemFree(pszOutput);

    return hrResult;
} // HandleFailedTranslation



//***************************************************************************
// Function: OnIMAPResponse
//
// Purpose:
//   This function dispatches a IIMAPCallback::OnResponse call. The reason
// to use this function instead of calling directly is watchdog timers: the
// watchdog timers should be disabled before the call in case the callback
// puts up some UI, and the watchdog timers should be restarted if they're
// needed after the callback function returns.
//
// Arguments:
//   IIMAPCallback *pCBHandler [in] - a pointer to the IIMAPCallback
//     interface whose OnResponse we should call.
//   IMAP_RESPONSE *pirIMAPResponse [in] - a pointer to the IMAP_RESPONSE
//     structure to send with the IIMAPCallback::OnResponse call.
//***************************************************************************
void CImap4Agent::OnIMAPResponse(IIMAPCallback *pCBHandler,
                                 IMAP_RESPONSE *pirIMAPResponse)
{
    Assert(NULL != pirIMAPResponse);

    if (NULL == pCBHandler)
        return; // We can't do a damned thing (this can happen due to HandsOffCallback)

    // Suspend watchdog for the duration of this callback
    LeaveBusy();

    pCBHandler->OnResponse(pirIMAPResponse);

    // Re-awaken the watchdog only if we need him
    if (FALSE == m_fBusy &&
        (NULL != m_piciPendingList || (NULL != m_piciCmdInSending &&
        icIDLE_COMMAND != m_piciCmdInSending->icCommandID))) {
        HRESULT hrResult;

        hrResult = HrEnterBusy();
        Assert(SUCCEEDED(hrResult));
    }
} // OnIMAPResponse



//***************************************************************************
// Function: FreeFetchResponse
//
// Purpose:
//   This function frees all the allocated data found in a
// FETCH_CMD_RESULTS_EX structure.
//
// Arguments:
//   FETCH_CMD_RESULTS_EX *pcreFreeMe [in] - pointer to the structure to
//     free.
//***************************************************************************
void CImap4Agent::FreeFetchResponse(FETCH_CMD_RESULTS_EX *pcreFreeMe)
{
    SafeMemFree(pcreFreeMe->pszENVSubject);
    FreeIMAPAddresses(pcreFreeMe->piaENVFrom);
    FreeIMAPAddresses(pcreFreeMe->piaENVSender);
    FreeIMAPAddresses(pcreFreeMe->piaENVReplyTo);
    FreeIMAPAddresses(pcreFreeMe->piaENVTo);
    FreeIMAPAddresses(pcreFreeMe->piaENVCc);
    FreeIMAPAddresses(pcreFreeMe->piaENVBcc);
    SafeMemFree(pcreFreeMe->pszENVInReplyTo);
    SafeMemFree(pcreFreeMe->pszENVMessageID);
} // FreeFetchResponse



//***************************************************************************
// Function: FreeIMAPAddresses
//
// Purpose:
//   This function frees all the allocated data found in a chain of IMAPADDR
// structures.
//
// Arguments:
//   IMAPADDR *piaFreeMe [in] - pointer to the chain of IMAP addresses to free.
//***************************************************************************
void CImap4Agent::FreeIMAPAddresses(IMAPADDR *piaFreeMe)
{
    while (NULL != piaFreeMe)
    {
        IMAPADDR *piaFreeMeToo;

        SafeMemFree(piaFreeMe->pszName);
        SafeMemFree(piaFreeMe->pszADL);
        SafeMemFree(piaFreeMe->pszMailbox);
        SafeMemFree(piaFreeMe->pszHost);

        // Advance pointer, free structure
        piaFreeMeToo = piaFreeMe;
        piaFreeMe = piaFreeMe->pNext;
        MemFree(piaFreeMeToo);
    }
} // FreeIMAPAddresses



//===========================================================================
// IInternetTransport Abstract Functions
//===========================================================================

//***************************************************************************
// Function: GetServerInfo
//
// Purpose:
//   This function copies the module's INETSERVER structure into the given
// output buffer.
//
// Arguments:
//   LPINETSERVER pInetServer [out] - if successful, the function copies
//     the module's INETSERVER structure here.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::GetServerInfo(LPINETSERVER pInetServer)
{
    return CIxpBase::GetServerInfo(pInetServer);
} // GetServerInfo



//***************************************************************************
// Function: GetIXPType
//
// Purpose:
//   This function identifies what type of transport this is.
//
// Returns:
//   IXP_IMAP for this class.
//***************************************************************************
IXPTYPE STDMETHODCALLTYPE CImap4Agent::GetIXPType(void)
{
    return CIxpBase::GetIXPType();
} // GetIXPType



//***************************************************************************
// Function: IsState
//
// Purpose:
//   This function allows a caller to query about the state of the transport
// interface.
//
// Arguments:
//   IXPISSTATE isstate [in] - one of the specified queries defined in
//     imnxport.idl/imnxport.h (eg, IXP_IS_CONNECTED).
//
// Returns:
//   HRESULT indicating success or failure. If successful, this function
// returns S_OK to indicate that the transport is in the specified state,
// and S_FALSE to indicate that the transport is not in the given state.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::IsState(IXPISSTATE isstate)
{
    return CIxpBase::IsState(isstate);
} // IsState



//***************************************************************************
// Function: InetServerFromAccount
//
// Purpose:
//   This function fills the given INETSERVER structure using the given
// IImnAccount interface.
//
// Arguments:
//   IImnAccount *pAccount [in] - pointer to an IImnAccount interface which
//     the user would like to retrieve information for.
//   LPINETSERVER pInetServer [out] - if successful, the function fills the
//     given INETSERVER structure with information from pAccount.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::InetServerFromAccount(IImnAccount *pAccount,
                                                             LPINETSERVER pInetServer)
{
    return CIxpBase::InetServerFromAccount(pAccount, pInetServer);
} // InetServerFromAccount



//***************************************************************************
// Function: GetStatus
//
// Purpose:
//   This function returns the current status of the transport.
//
// Arguments:
//   IXPSTATUS *pCurrentStatus [out] - returns current status of transport.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::GetStatus(IXPSTATUS *pCurrentStatus)
{
    return CIxpBase::GetStatus(pCurrentStatus);
} // GetStatus



//***************************************************************************
// Function: SetDefaultCP
//
// Purpose:
//   This function allows the caller to tell IIMAPTransport what codepage to
// use for IMAP mailbox names. After calling this function, all mailbox names
// submitted to IIMAPTransport will be translated from the default codepage,
// and all mailbox names returned from the server will be translated to
// the default codepage before being returned via IIMAPCallback.
//
// Arguments:
//   DWORD dwTranslateFlags [in] - enables/disables automatic translation to
//     and from default codepage and IMAP-modified UTF-7. If disabled, caller
//     wishes all mailbox names to be passed verbatim to/from IMAP server.
//     Note that by default we translate for IMAP4 servers, even with its
//     round-trippability problems, because this is how we used to do it
//     in the past.
//   UINT uiCodePage [in] - the default codepage to use for translations.
//     By default this value is the CP returned by GetACP().
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::SetDefaultCP(DWORD dwTranslateFlags,
                                                    UINT uiCodePage)
{
    Assert(m_lRefCount > 0);

    if (ISFLAGCLEAR(dwTranslateFlags, IMAP_MBOXXLATE_RETAINCP))
        m_uiDefaultCP = uiCodePage;

    dwTranslateFlags &= ~(IMAP_MBOXXLATE_RETAINCP);
    m_dwTranslateMboxFlags = dwTranslateFlags;

    return S_OK;
} // SetDefaultCP



//***************************************************************************
// Function: SetIdleMode
//
// Purpose:
//   The IMAP IDLE extension allows the server to unilaterally report changes
// to the currently selected mailbox: new email, flag updates, and message
// expunges. IIMAPTransport always enters IDLE mode when no IMAP commands
// are pending, but it turns out that this can result in unnecessary
// entry and exit of IDLE mode when the caller tries to sequence IMAP commands.
// This function allows the caller to disable the use of the IDLE extension.
//
// Arguments:
//   DWORD dwIdleFlags [in] - enables or disables the use of the IDLE extension.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::SetIdleMode(DWORD dwIdleFlags)
{
    Assert(m_lRefCount > 0);
    return E_NOTIMPL;
} // SetIdleMode



//***************************************************************************
// Function: EnableFetchEx
//
// Purpose:
//   IIMAPTransport only understood a subset of FETCH response tags. Notable
// omissions included ENVELOPE and BODYSTRUCTURE. Calling this function
// changes the behaviour of IIMAPTransport::Fetch. Instead of returning
// FETCH responses via IIMAPCallback::OnResponse(irtUPDATE_MESSAGE),
// the FETCH response is returned via OnResponse(irtUPDATE_MESSAGE_EX).
// Other FETCH-related responses remain unaffected (eg, irtFETCH_BODY).
//
// Arguments:
//   DWORD dwFetchExFlags [in] - enables or disables FETCH extensions.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CImap4Agent::EnableFetchEx(DWORD dwFetchExFlags)
{
    Assert(m_lRefCount > 0);

    m_dwFetchFlags = dwFetchExFlags;
    return S_OK;
} // EnableFetchEx



//===========================================================================
// CIxpBase Abstract Functions
//===========================================================================

//***************************************************************************
// Function: OnDisconnected
//
// Purpose:
//   This function calls FreeAllData to deallocate the structures which are
// no longer needed when we are disconnected. It then calls
// CIxpBase::OnDisconnected which updates the user's status.
//***************************************************************************
void CImap4Agent::OnDisconnected(void)
{
    FreeAllData(IXP_E_CONNECTION_DROPPED);
    CIxpBase::OnDisconnected();
} // OnDisconnected



//***************************************************************************
// Function: ResetBase
//
// Purpose:
//   This function resets the class to a non-connected state by deallocating
// the send and receive queues, and the MsgSeqNumToUID table.
//***************************************************************************
void CImap4Agent::ResetBase(void)
{
    FreeAllData(IXP_E_NOT_CONNECTED);
} // ResetBase



//***************************************************************************
// Function: DoQuit
//
// Purpose:
//   This function sends a "LOGOUT" command to the IMAP server.
//***************************************************************************
void CImap4Agent::DoQuit(void)
{
    HRESULT hrResult;

    hrResult = NoArgCommand("LOGOUT", icLOGOUT_COMMAND, ssNonAuthenticated, 0, 0,
        DEFAULT_CBHANDLER);
    Assert(SUCCEEDED(hrResult));
} // DoQuit



//***************************************************************************
// Function: OnEnterBusy
//
// Purpose:
//   This function does nothing at the current time.
//***************************************************************************
void CImap4Agent::OnEnterBusy(void)
{
    // Do nothing
} // OnEnterBusy



//***************************************************************************
// Function: OnLeaveBusy
//
// Purpose:
//   This function does nothing at the current time.
//***************************************************************************
void CImap4Agent::OnLeaveBusy(void)
{
    // Do nothing
} // OnLeaveBusy
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\ixpnntp.h ===
// --------------------------------------------------------------------------------
// Ixpnntp.h
// Copyright (c)1993-1996 Microsoft Corporation, All Rights Reserved
//
// Eric Andrews
// Steve Serdy
// --------------------------------------------------------------------------------

#ifndef __IXPNNTP_H__
#define __IXPNNTP_H__

#include "imnxport.h"
#include "ixpbase.h"
#include "asynconn.h"
#include "sicily.h"

#define MAX_SEC_PKGS           32   // most sec pkgs we will try


// --------------------------------------------------------------------------------
// Sub states that aren't exposed to the user
// --------------------------------------------------------------------------------
typedef enum {
    // These are generic substates that a lot of commands use to differenitate
    // between the response ("200 article follows") and the data (the actual
    // article text).
    NS_RESP,
    NS_DATA,

    // These substates are specific to handling posting
    NS_SEND_ENDPOST,
    NS_ENDPOST_RESP,

    // These substates are specific to connecting or authorizing
    NS_CONNECT_RESP,                    // awaiting the banner that is sent after a connection is made
    NS_MODE_READER_RESP,                // awaiting MODE READER response
    NS_GENERIC_TEST,                    // awaiting AUTHINFO GENERIC response
    NS_GENERIC_PKG_DATA,                // awaiting AUTHINFO_GENERIC data
    NS_TRANSACT_TEST,                   // awaiting AUTHINFO TRANSACT TEST response
    NS_TRANSACT_PACKAGE,                // awaiting AUTHINFO TRANSACT <package> response
    NS_TRANSACT_NEGO,                   // awaiting AUTHINFO TRANSACT <negotiation> response
    NS_TRANSACT_RESP,                   // awaiting AUTHINFO TRANSACT <response> response
    NS_AUTHINFO_USER_RESP,              // awaiting AUTHINFO USER XXXX response
    NS_AUTHINFO_PASS_RESP,              // awaiting AUTHINFO PASS XXXX response
    NS_AUTHINFO_SIMPLE_RESP,            // awaiting AUTHINFO SIMPLE response
    NS_AUTHINFO_SIMPLE_USERPASS_RESP,
    NS_RECONNECTING                     // in the process of doing an internal reconnect

} NNTPSUBSTATE;

typedef enum {
    AUTHINFO_NONE = 0,
    AUTHINFO_GENERIC,
    AUTHINFO_TRANSACT,
} AUTH_TYPE;

typedef enum {
    GETHDR_XOVER,
    GETHDR_XHDR
} GETHDR_TYPE;

enum {
    HDR_SUBJECT = 0,
    HDR_FROM,
    HDR_DATE,
    HDR_MSGID,
    HDR_REFERENCES,
    HDR_LINES,
    HDR_XREF,
    HDR_MAX
};

typedef struct tagMEMORYINFO
    {
    DWORD cPointers;
    LPVOID rgPointers[1];
    } MEMORYINFO, *PMEMORYINFO;

class CNNTPTransport : public INNTPTransport2, public CIxpBase
    {
public:
    // ----------------------------------------------------------------------------
    // Contstruction
    // ----------------------------------------------------------------------------
    CNNTPTransport(void);
    ~CNNTPTransport(void);

    // ----------------------------------------------------------------------------
    // IUnknown methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IAsyncConnCB methods
    // ----------------------------------------------------------------------------
    void OnNotify(ASYNCSTATE asOld, ASYNCSTATE asNew, ASYNCEVENT ae);

    // ----------------------------------------------------------------------------
    // IInternetTransport methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP InitNew(LPSTR pszLogFilePath, INNTPCallback *pCallback);
    STDMETHODIMP InetServerFromAccount(IImnAccount *pAccount, LPINETSERVER pInetServer);
    STDMETHODIMP Connect(LPINETSERVER pInetServer, boolean fAuthenticate, boolean fCommandLogging);
    STDMETHODIMP DropConnection(void);
    STDMETHODIMP Disconnect(void);
    STDMETHODIMP Stop(void);
    STDMETHODIMP IsState(IXPISSTATE isstate);
    STDMETHODIMP GetServerInfo(LPINETSERVER pInetServer);
    STDMETHODIMP_(IXPTYPE) GetIXPType(void);
    STDMETHODIMP HandsOffCallback(void);
    STDMETHODIMP GetStatus(IXPSTATUS *pCurrentStatus);

    // ----------------------------------------------------------------------------
    // INNTPTransport2 methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP SetWindow(void);
    STDMETHODIMP ResetWindow(void);

    // ----------------------------------------------------------------------------
    // CIxpBase methods
    // ----------------------------------------------------------------------------
    virtual void ResetBase(void);
    virtual void DoQuit(void);
    virtual void OnConnected(void);
    virtual void OnDisconnected(void);
    virtual void OnEnterBusy(void);
    virtual void OnLeaveBusy(void);

    // ----------------------------------------------------------------------------
    // INNTPTransport methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP CommandAUTHINFO(LPNNTPAUTHINFO pAuthInfo);
    STDMETHODIMP CommandGROUP(LPSTR pszGroup);
    STDMETHODIMP CommandLAST(void);
    STDMETHODIMP CommandNEXT(void);
    STDMETHODIMP CommandSTAT(LPARTICLEID pArticleId);    
    STDMETHODIMP CommandARTICLE(LPARTICLEID pArticleId);
    STDMETHODIMP CommandHEAD(LPARTICLEID pArticleId);
    STDMETHODIMP CommandBODY(LPARTICLEID pArticleId);
    STDMETHODIMP CommandPOST(LPNNTPMESSAGE pMessage);
    STDMETHODIMP CommandLIST(LPSTR pszArgs);
    STDMETHODIMP CommandLISTGROUP(LPSTR pszGroup);
    STDMETHODIMP CommandNEWGROUPS(SYSTEMTIME *pstLast, LPSTR pszDist);
    STDMETHODIMP CommandDATE(void);
    STDMETHODIMP CommandMODE(LPSTR pszMode);
    STDMETHODIMP CommandXHDR(LPSTR pszHeader, LPRANGE pRange, LPSTR pszMessageId);
    STDMETHODIMP CommandQUIT(void);
    STDMETHODIMP GetHeaders(LPRANGE pRange);
    STDMETHODIMP ReleaseResponse(LPNNTPRESPONSE pResp);
    

private:
    // ----------------------------------------------------------------------------
    // Private Member functions
    // ----------------------------------------------------------------------------
    void OnSocketReceive(void);
    void DispatchResponse(HRESULT hrResult, BOOL fDone=TRUE, LPNNTPRESPONSE pResponse=NULL);
    HRESULT HrGetResponse(void);
    
    void StartLogon(void);
    HRESULT LogonRetry(HRESULT hrLogon);
    HRESULT TryNextSecPkg(void);
    HRESULT MaybeTryAuthinfo(void);

    HRESULT HandleConnectResponse(void);

    HRESULT ProcessGenericTestResponse(void);
    HRESULT ProcessTransactTestResponse(void);
    HRESULT ProcessGroupResponse(void);
    HRESULT ProcessNextResponse(void);
    HRESULT ProcessListData(void);
    HRESULT ProcessListGroupData(void);
    HRESULT ProcessDateResponse(void);
    HRESULT ProcessArticleData(void);
    HRESULT ProcessXoverData(void);
    HRESULT ProcessXhdrData(void);

    HRESULT BuildHeadersFromXhdr(BOOL fFirst);
    LPSTR GetNextField(LPSTR pszField);
    HRESULT SendNextXhdrCommand(void);
    HRESULT ProcessNextXhdrResponse(BOOL* pfDone);

    HRESULT HrPostMessage(void);

    // ----------------------------------------------------------------------------
    // Private member variables
    // ----------------------------------------------------------------------------
    // Various state variables
    NNTPSTATE           m_state;
    NNTPSUBSTATE        m_substate;
    GETHDR_TYPE         m_gethdr;
    DWORD               m_hdrtype;

    // Sicily information
    SSPICONTEXT         m_sicinfo;
    SSPIBUFFER          m_sicmsg;
    int                 m_cSecPkg;                  // number of sec pkgs to try, -1 if not inited
    int                 m_iSecPkg;                  // current sec pkg being tried
    AUTH_TYPE           m_iAuthType;
    LPSTR               m_rgszSecPkg[MAX_SEC_PKGS]; // pointers into m_szSecPkgs
    LPSTR               m_szSecPkgs;                // string returned by "AUTHINFO TRANSACT TEST"
    BOOL                m_fRetryPkg;

    // From the GetHeaders() command in case the XOVER request fails
    RANGE               m_rRange;
    RANGE               m_rRangeCur;
    LPNNTPHEADER        m_rgHeaders;
    DWORD               m_iHeader;
    DWORD               m_cHeaders;
    PMEMORYINFO         m_pMemInfo;

    // Posting
    NNTPMESSAGE         m_rMessage;

    // Flags
    BOOL                m_fSupportsXRef;            // TRUE if this server's XOver records contain the XRef: field
    BOOL                m_fNoXover;                 // TRUE if the server does not support XOVER

    // Connection info
    HRESULT             m_hrPostingAllowed;

    // Authentication
    LPNNTPAUTHINFO      m_pAuthInfo;
    };



#endif // __IXPNNTP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\ixppop3.cpp ===
// --------------------------------------------------------------------------------
// Ixppop3.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "ixppop3.h"
#include "asynconn.h"
#include "ixputil.h"  
#include "strconst.h"
#include <shlwapi.h>
#include <ntverp.h>
#include "demand.h"

// --------------------------------------------------------------------------------
// Usefule C++ pointer casting
// --------------------------------------------------------------------------------
#define POP3THISIXP         ((IPOP3Transport *)(CIxpBase *)this)
#define STR_HOTMAILAUTH     "Outlook Express V" VER_PRODUCTVERSION_STR

// --------------------------------------------------------------------------------
// FreeAuthInfo
// --------------------------------------------------------------------------------
void FreeAuthInfo(LPAUTHINFO pAuth)
{
    for (UINT i=0; i<pAuth->cAuthToken; i++)
    {
        ZeroMemory(pAuth->rgpszAuthTokens[i], sizeof(pAuth->rgpszAuthTokens[i][0]) * lstrlen(pAuth->rgpszAuthTokens[i]));
        SafeMemFree(pAuth->rgpszAuthTokens[i]);
    }
    pAuth->iAuthToken = pAuth->cAuthToken = 0;
    if (pAuth->pPackages && pAuth->cPackages)
    {
        SSPIFreePackages(&pAuth->pPackages, pAuth->cPackages);
        pAuth->pPackages = NULL;
        pAuth->cPackages = 0;
    }
    SSPIFreeContext(&pAuth->rSicInfo);
    ZeroMemory(pAuth, sizeof(*pAuth));
}

// --------------------------------------------------------------------------------
// CPOP3Transport::CPOP3Transport
// --------------------------------------------------------------------------------
CPOP3Transport::CPOP3Transport(void) : CIxpBase(IXP_POP3)
{
	DllAddRef();
    ZeroMemory(&m_rInfo, sizeof(POP3INFO));
    m_rInfo.rAuth.authstate = AUTH_NONE;
    m_command = POP3_NONE;
    m_fHotmail = FALSE;
}

// --------------------------------------------------------------------------------
// CPOP3Transport::~CPOP3Transport
// --------------------------------------------------------------------------------
CPOP3Transport::~CPOP3Transport(void)
{
    ResetBase();
	DllRelease();
}

// --------------------------------------------------------------------------------
// CPOP3Transport::ResetBase
// --------------------------------------------------------------------------------
void CPOP3Transport::ResetBase(void)
{
    EnterCriticalSection(&m_cs);
    FreeAuthInfo(&m_rInfo.rAuth);
    SafeMemFree(m_rInfo.prgMarked);
    ZeroMemory(&m_rInfo, sizeof(m_rInfo));
    m_command = POP3_NONE;
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CPOP3Transport::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // Bad param
    if (ppv == NULL)
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // Init
    *ppv=NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = ((IUnknown *)(IPOP3Transport *)this);

    // IID_IInternetTransport
    else if (IID_IInternetTransport == riid)
        *ppv = ((IInternetTransport *)(CIxpBase *)this);

    // IID_IPOP3Transport
    else if (IID_IPOP3Transport == riid)
        *ppv = (IPOP3Transport *)this;

    // If not null, addref it and return
    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    // No Interface
    hr = TrapError(E_NOINTERFACE);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPOP3Transport::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPOP3Transport::AddRef(void) 
{
	return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CPOP3Transport::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPOP3Transport::Release(void) 
{
	if (0 != --m_cRef)
		return m_cRef;
	delete this;
	return 0;
}

// --------------------------------------------------------------------------------
// CPOP3Transport::InitNew
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::InitNew(LPSTR pszLogFilePath, IPOP3Callback *pCallback)
{
    // Call Base Class
    return CIxpBase::OnInitNew("POP3", pszLogFilePath, FILE_SHARE_READ | FILE_SHARE_WRITE,
        (ITransportCallback *)pCallback);
}

// --------------------------------------------------------------------------------
// CPOP3Transport::HandsOffCallback
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::HandsOffCallback(void)
{
    return CIxpBase::HandsOffCallback();
}

// --------------------------------------------------------------------------------
// CPOP3Transport::GetStatus
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::GetStatus(IXPSTATUS *pCurrentStatus)
{
    return CIxpBase::GetStatus(pCurrentStatus);
}

// --------------------------------------------------------------------------------
// CPOP3Transport::InetServerFromAccount
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::InetServerFromAccount(IImnAccount *pAccount, LPINETSERVER pInetServer)
{
    return CIxpBase::InetServerFromAccount(pAccount, pInetServer);
}

// --------------------------------------------------------------------------------
// CPOP3Transport::Connect
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::Connect(LPINETSERVER pInetServer, boolean fAuthenticate, boolean fCommandLogging)
{
    // Does user want us to always prompt for his password? Prompt him here to avoid
    // inactivity timeouts while the prompt is up, unless a password was supplied
    if (ISFLAGSET(pInetServer->dwFlags, ISF_ALWAYSPROMPTFORPASSWORD) &&
        '\0' == pInetServer->szPassword[0])
    {
        HRESULT hr;

        if (NULL != m_pCallback)
            hr = m_pCallback->OnLogonPrompt(pInetServer, POP3THISIXP);

        if (NULL == m_pCallback || S_OK != hr)
            return IXP_E_USER_CANCEL;
    }

    return CIxpBase::Connect(pInetServer, fAuthenticate, fCommandLogging);
}

// --------------------------------------------------------------------------------
// CPOP3Transport::DropConnection
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::DropConnection(void)
{
    return CIxpBase::DropConnection();
}

// --------------------------------------------------------------------------------
// CPOP3Transport::Disconnect
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::Disconnect(void)
{
    return CIxpBase::Disconnect();
}

// --------------------------------------------------------------------------------
// CPOP3Transport::IsState
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::IsState(IXPISSTATE isstate)
{
    return CIxpBase::IsState(isstate);
}

// --------------------------------------------------------------------------------
// CPOP3Transport::GetServerInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::GetServerInfo(LPINETSERVER pInetServer)
{
    return CIxpBase::GetServerInfo(pInetServer);
}

// --------------------------------------------------------------------------------
// CPOP3Transport::GetIXPType
// --------------------------------------------------------------------------------
STDMETHODIMP_(IXPTYPE) CPOP3Transport::GetIXPType(void)
{
    return CIxpBase::GetIXPType();
}

// --------------------------------------------------------------------------------
// CPOP3Transport::OnEnterBusy
// --------------------------------------------------------------------------------
void CPOP3Transport::OnEnterBusy(void)
{
    IxpAssert(m_command == POP3_NONE);
}

// --------------------------------------------------------------------------------
// CPOP3Transport::OnLeaveBusy
// --------------------------------------------------------------------------------
void CPOP3Transport::OnLeaveBusy(void)
{
    m_command = POP3_NONE;
}

// --------------------------------------------------------------------------------
// CPOP3Transport::OnConnected
// --------------------------------------------------------------------------------
void CPOP3Transport::OnConnected(void)
{
    m_command = POP3_BANNER;
    CIxpBase::OnConnected();
}

// --------------------------------------------------------------------------------
// CPOP3Transport::OnDisconnect
// --------------------------------------------------------------------------------
void CPOP3Transport::OnDisconnected(void)
{
    ResetBase();
    CIxpBase::OnDisconnected();
}

// --------------------------------------------------------------------------------
// CPOP3Transport::OnNotify
// --------------------------------------------------------------------------------
void CPOP3Transport::OnNotify(ASYNCSTATE asOld, ASYNCSTATE asNew, ASYNCEVENT ae)
{
    // Enter Critical Section
    EnterCriticalSection(&m_cs);

    // Handle Event
    switch(ae)
    {
    // --------------------------------------------------------------------------------
    case AE_RECV:
        OnSocketReceive();
        break;

    // --------------------------------------------------------------------------------
    default:
        CIxpBase::OnNotify(asOld, asNew, ae);
        break;
    }

    // Leave Critical Section
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CPOP3Transport::OnSocketReceive
// --------------------------------------------------------------------------------
void CPOP3Transport::OnSocketReceive(void)
{
    // Locals
    HRESULT hr;

    // Enter Critical Section
    EnterCriticalSection(&m_cs);

    // Handle Current pop3 state
    switch(m_command)
    {
    // --------------------------------------------------------------------------------
    case POP3_BANNER:
        // Read Server Response...
        hr = HrGetResponse();
        if (IXP_E_INCOMPLETE == hr)
            goto exit;

        // Detect if the banner had the word hotmail in it
        Assert(m_pszResponse);
        m_fHotmail = (NULL == m_pszResponse || NULL == StrStrIA(m_pszResponse, "hotmail")) ? FALSE : TRUE;

        // Dispatch the response
        DispatchResponse(hr);

        // Authorizing
        if (m_fConnectAuth)
            StartLogon();

        // Ohterwise were connected
        else
        {
            m_command = POP3_CONNECTED;
            DispatchResponse(S_OK);
        }

        // Not yet auth'ed
        m_fAuthenticated = FALSE;
        break;

    // --------------------------------------------------------------------------------
    case POP3_USER:
        // Read Server Response...
        hr = HrGetResponse();
        if (IXP_E_INCOMPLETE == hr)
            goto exit;

        // Dispatch the response
        DispatchResponse(FAILED(hr) ? IXP_E_POP3_INVALID_USER_NAME : S_OK);

        // Authorizing
        if (m_fConnectAuth)
        {
            // Retry logon
            if (FAILED(hr))
                LogonRetry(IXP_E_POP3_INVALID_USER_NAME);

            // otherwise send the password
            else
            {
                hr = CommandPASS(m_rServer.szPassword);
                if (FAILED(hr))
                {
                    OnError(hr);
                    DropConnection();
                }
            }
        }
        break;

    // --------------------------------------------------------------------------------
    case POP3_PASS:
        // Read Server Response...
        hr = HrGetResponse();
        if (IXP_E_INCOMPLETE == hr)
            goto exit;

        // Dispatch the response
        DispatchResponse(FAILED(hr) ? IXP_E_POP3_INVALID_PASSWORD : S_OK);

        // Authorizing
        if (m_fConnectAuth)
        {
            // Retry if failed
            if (FAILED(hr))
                LogonRetry(IXP_E_POP3_INVALID_PASSWORD);

            // Otherwise, we're authorized
            else
            {
                OnStatus(IXP_AUTHORIZED);
                m_fConnectAuth = FALSE;
                m_command = POP3_CONNECTED;
                DispatchResponse(S_OK);
            }
        }
        break;

    // --------------------------------------------------------------------------------
    case POP3_AUTH:
        // If hotmail, then, we've identified ourselves, so lets send the user command
        if (m_fHotmail)
        {
            // Read Server Response...
            hr = HrGetResponse();
            if (IXP_E_INCOMPLETE == hr)
                goto exit;

            // Issue the user command
            hr = CommandUSER(m_rServer.szUserName);
            if (FAILED(hr))
            {
                OnError(hr);
                DropConnection();
            }
        }

        // Otherwise, lets continue DPA auth
        else if (m_rInfo.rAuth.authstate != AUTH_ENUMPACKS_DATA)
        {
            // Read Server Response...
            hr = HrGetResponse();
            if (IXP_E_INCOMPLETE == hr)
                goto exit;

            // Authenticating
            if (m_fConnectAuth)
            {
                ResponseAUTH(hr);
            }
            else
            {
                // Dispatch the response
                DispatchResponse(hr);
            }
        }

        // Otherwise, handle resposne
        else
        {
            // no HrGetResponse() because we are getting list data
            ResponseAUTH(0);
        }
        break;        

    // --------------------------------------------------------------------------------
    case POP3_STAT:
        ResponseSTAT();
        break;

    // --------------------------------------------------------------------------------
    case POP3_NOOP:
        // Read Server Response...
        hr = HrGetResponse();
        if (IXP_E_INCOMPLETE == hr)
            goto exit;

        // Dispatch the response
        DispatchResponse(hr, TRUE);
        break;

    // --------------------------------------------------------------------------------
    case POP3_UIDL:
    case POP3_LIST:
        ResponseGenericList();
        break;

    // --------------------------------------------------------------------------------
    case POP3_DELE:
        ResponseDELE();
        break;

    // --------------------------------------------------------------------------------
    case POP3_RETR:
    case POP3_TOP:
        ResponseGenericRetrieve();
        break;

    // --------------------------------------------------------------------------------
    case POP3_QUIT:
        // Read Server Response...
        hr = HrGetResponse();
        if (IXP_E_INCOMPLETE == hr)
            goto exit;

        // Dispatch the response
        DispatchResponse(hr, FALSE);

        // Drop the socket
        m_pSocket->Close();
        break;
    }

exit:
    // Done
    LeaveCriticalSection(&m_cs);
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::DispatchResponse
// ------------------------------------------------------------------------------------
void CPOP3Transport::DispatchResponse(HRESULT hrResult, BOOL fDone, LPPOP3RESPONSE pResponse)
{
    // Locals
    POP3RESPONSE rResponse;

    // If a response was passed in, use it...
    if (pResponse)
        CopyMemory(&rResponse, pResponse, sizeof(POP3RESPONSE));
    else
        ZeroMemory(&rResponse, sizeof(POP3RESPONSE));

    // Set the HRESULT
    rResponse.command = m_command;
    rResponse.rIxpResult.hrResult = hrResult;
    rResponse.rIxpResult.pszResponse = m_pszResponse;
    rResponse.rIxpResult.uiServerError = m_uiResponse;
    rResponse.rIxpResult.hrServerError = m_hrResponse;
    rResponse.rIxpResult.dwSocketError = m_pSocket->GetLastError();
    rResponse.rIxpResult.pszProblem = NULL;
    rResponse.fDone = fDone;
    rResponse.pTransport = this;

    // If Done...
    if (fDone)
    {
        // No current command
        m_command = POP3_NONE;

        // Leave Busy State
        LeaveBusy();
    }

    // Give the Response to the client
    if (m_pCallback)
        ((IPOP3Callback *)m_pCallback)->OnResponse(&rResponse);

    // Reset Last Response
    SafeMemFree(m_pszResponse);
    m_hrResponse = S_OK;
    m_uiResponse = 0;
}

// --------------------------------------------------------------------------------
// CPOP3Transport::HrGetResponse
// --------------------------------------------------------------------------------
HRESULT CPOP3Transport::HrGetResponse(void)
{
    // Locals
    INT          cbLine;
    BOOL         fComplete;

    // Clear current response
    IxpAssert(m_pszResponse == NULL && m_hrResponse == S_OK);

    // Set m_hrResponse
    m_hrResponse = S_OK;

    // Read Line
    m_hrResponse = HrReadLine(&m_pszResponse, &cbLine, &fComplete);
    if (FAILED(m_hrResponse))
        goto exit;

    // If not complete
    if (!fComplete)
        goto exit;

    // - Response
    if ('+' != m_pszResponse[0])
    {
        m_hrResponse = TrapError(IXP_E_POP3_RESPONSE_ERROR);
        if (m_pCallback && m_fCommandLogging)
            m_pCallback->OnCommand(CMD_RESP, m_pszResponse, m_hrResponse, POP3THISIXP);
        goto exit;
    }

    // Don't log UIDL or LIST response lines...
    else if (m_pCallback && m_fCommandLogging)
        m_pCallback->OnCommand(CMD_RESP, m_pszResponse, S_OK, POP3THISIXP);

exit:
    // Exit
    return m_hrResponse;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::StartLogon
// ------------------------------------------------------------------------------------
void CPOP3Transport::StartLogon(void)
{
    // Locals
    HRESULT     hr;

    // Progress
    OnStatus(IXP_AUTHORIZING);

    // If Not Using Sicily or its not installed, then send USER command
    if (FALSE == m_rServer.fTrySicily || FALSE == FIsSicilyInstalled())
    {
        // If Hotmail, send the AUTH OutlookExpress command
        if (m_fHotmail)
        {
            // Otherwise, send AUTH enumpacks command
            hr = CommandAUTH(STR_HOTMAILAUTH);
            if (FAILED(hr))
            {
                OnError(hr);
                DropConnection();
            }
        }

        // Otherwise
        else
        {
            // Issue the user command
            hr = CommandUSER(m_rServer.szUserName);
            if (FAILED(hr))
            {
                OnError(hr);
                DropConnection();
            }
        }

        // Done
        return;
    }

    // Turn Off HOtmail
    m_fHotmail = FALSE;

    // Otherwise, send AUTH enumpacks command
    hr = CommandAUTH((LPSTR)"");
    if (FAILED(hr))
    {
        OnError(hr);
        DropConnection();
    }

    // Otherwise, set the state
    m_rInfo.rAuth.authstate = AUTH_ENUMPACKS;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::LogonRetry
// ------------------------------------------------------------------------------------
void CPOP3Transport::LogonRetry(HRESULT hrLogon)
{
    // Locals
    HRESULT         hr=S_OK;

    // Give logon failed status
    // OnError(hrLogon);

    // Auth Retry
    OnStatus(IXP_AUTHRETRY);

    // Enter Auth Retry State
    m_pSocket->Close();

    // Logon
    if (NULL == m_pCallback || m_pCallback->OnLogonPrompt(&m_rServer, POP3THISIXP) != S_OK)
    {
        // Go to terminal state, were done.
        OnDisconnected();
        return;
    }

    // Finding Host Progress
    OnStatus(IXP_FINDINGHOST);

    // Connect to server
    hr = m_pSocket->Connect();
    if (FAILED(hr))
    {
        OnError(TrapError(IXP_E_SOCKET_CONNECT_ERROR));
        OnDisconnected();
        return;
    }

    // Start WatchDog
    m_pSocket->StartWatchDog();
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::ResponseAUTH
// ------------------------------------------------------------------------------------
void CPOP3Transport::ResponseAUTH(HRESULT hrResponse)
{
    // Locals
    HRESULT         hr;
    BOOL            fPackageInstalled;
    SSPIBUFFER      Negotiate;
    SSPIBUFFER      Challenge;
    SSPIBUFFER      Response;
    ULONG           i;

    // We better be in sicily
    Assert(FIsSicilyInstalled());

    // If we just started enumerating packages...
    if (m_rInfo.rAuth.authstate == AUTH_ENUMPACKS)
    {
        // Free old tokens
        for (i=0; i<m_rInfo.rAuth.cAuthToken; i++)
        {
            ZeroMemory(m_rInfo.rAuth.rgpszAuthTokens[i], sizeof(m_rInfo.rAuth.rgpszAuthTokens[i][0]) * lstrlen(m_rInfo.rAuth.rgpszAuthTokens[i]));
            SafeMemFree(m_rInfo.rAuth.rgpszAuthTokens[i]);
        }
        m_rInfo.rAuth.iAuthToken = m_rInfo.rAuth.cAuthToken = 0;

        if (SUCCEEDED(hrResponse))
        {
            m_rInfo.rAuth.authstate = AUTH_ENUMPACKS_DATA;
            goto EnumData;
        }

        OnError(IXP_E_SICILY_LOGON_FAILED);
        hr = CommandQUIT();
        if (FAILED(hr))        
            DropConnection();
        return;
    }

    else if (m_rInfo.rAuth.authstate == AUTH_ENUMPACKS_DATA)
    {
EnumData:
        int     cbLine;
        BOOL    fComplete;

        // Clear Response
        SafeMemFree(m_pszResponse);
        m_uiResponse = 0;
        m_hrResponse = S_OK;

        // Read a blob of lines
        while (m_rInfo.rAuth.cAuthToken < MAX_AUTH_TOKENS)
        {
            // Read the line
            hr = HrReadLine(&m_pszResponse, &cbLine, &fComplete);
            if (FAILED(hr))
            {
                OnError(hr);
                DropConnection();
            }

            // If not complete
            if (!fComplete)
                return;

            // Add Detail
            if (m_pCallback && m_fCommandLogging)
                m_pCallback->OnCommand(CMD_RESP, m_pszResponse, S_OK, POP3THISIXP);

            // StripCRLF
            StripCRLF(m_pszResponse, (ULONG *)&cbLine);

            // If its a dot, were done
            if (*m_pszResponse == '.')
                break;

            m_rInfo.rAuth.rgpszAuthTokens[m_rInfo.rAuth.cAuthToken++] = m_pszResponse;            
        }

        if (!m_rInfo.rAuth.cAuthToken)
        {
            OnError(IXP_E_SICILY_LOGON_FAILED);
            hr = CommandQUIT();
            if (FAILED(hr))        
                DropConnection();
            return;
        }

        // Free current packages...
        if (m_rInfo.rAuth.pPackages && m_rInfo.rAuth.cPackages)
        {
            SSPIFreePackages(&m_rInfo.rAuth.pPackages, m_rInfo.rAuth.cPackages);
            m_rInfo.rAuth.pPackages = NULL;
            m_rInfo.rAuth.cPackages = 0;
        }

        // Get installed security packages
        if (FAILED(SSPIGetPackages(&m_rInfo.rAuth.pPackages, &m_rInfo.rAuth.cPackages)))
        {
            OnError(IXP_E_LOAD_SICILY_FAILED);
            hr = CommandQUIT();
            if (FAILED(hr))        
                DropConnection();
            return;
        }
    }

    // Otherwise, we must have just tryed a package
    else if (m_rInfo.rAuth.authstate == AUTH_TRYING_PACKAGE)
    {
        // Stop the WatchDog
        m_pSocket->StopWatchDog();

        // If Success Response
        if (SUCCEEDED(hrResponse))
        {
            // Do Sicily Logon
            Assert(m_rInfo.rAuth.iAuthToken < m_rInfo.rAuth.cAuthToken);

            if (SUCCEEDED(SSPILogon(&m_rInfo.rAuth.rSicInfo, m_rInfo.rAuth.fRetryPackage, SSPI_BASE64, m_rInfo.rAuth.rgpszAuthTokens[m_rInfo.rAuth.iAuthToken], &m_rServer, m_pCallback)))
            {
                if (m_rInfo.rAuth.fRetryPackage)
                {
                    // Don't retry again
                    m_rInfo.rAuth.fRetryPackage = FALSE;
                }

                // Get negotiation string
                if (SUCCEEDED(SSPIGetNegotiate(&m_rInfo.rAuth.rSicInfo, &Negotiate)))
                {
                    // Send AUTH Respons
                    if (SUCCEEDED(HrSendSicilyString(Negotiate.szBuffer)))
                    {
                        m_rInfo.rAuth.authstate = AUTH_NEGO_RESP;
                    }
                }
                else
                {
                    HrCancelAuthInProg();
                }
            }
            else
            {
                HrCancelAuthInProg();
            }

            // Start the WatchDog
            m_pSocket->StartWatchDog();

            // Done
            return;
        }

        // That failed, free sicinfo and go on with life
        SSPIFreeContext(&m_rInfo.rAuth.rSicInfo);

        // Goto Next Package
        m_rInfo.rAuth.iAuthToken++;
    }

    // Otherwise, we got a response from a negotiation string
    else if (m_rInfo.rAuth.authstate == AUTH_NEGO_RESP)
    {
        // Start the WatchDog
        m_pSocket->StopWatchDog();

        // Succeeded Response
        if (SUCCEEDED(hrResponse))
        {
            // Set Chal String - skip over "+ "
            SSPISetBuffer(m_pszResponse + 2, SSPI_STRING, 0, &Challenge);

            // Get response from challenge
            if (SUCCEEDED(SSPIResponseFromChallenge(&m_rInfo.rAuth.rSicInfo, &Challenge, &Response)))
            {
                // Send AUTH Respons
                if (SUCCEEDED(HrSendSicilyString(Response.szBuffer)))
                {
                    // if we need to continue, we keep the state the same
                    // else we transition to the AUTH_RESP_RESP state.
                    if (!Response.fContinue)
                        m_rInfo.rAuth.authstate = AUTH_RESP_RESP;
                }
            }
            else
            {
                HrCancelAuthInProg();
            }
        }
        else
        {
            // retry current package, with prompt
            m_rInfo.rAuth.fRetryPackage = TRUE;

            Assert(m_rInfo.rAuth.iAuthToken < m_rInfo.rAuth.cAuthToken);
            hr = CommandAUTH(m_rInfo.rAuth.rgpszAuthTokens[m_rInfo.rAuth.iAuthToken]);
            if (FAILED(hr))
            {
                OnError(hr);
                DropConnection();
                return;
            }

            // We are in the TRYING_PACKAGE state
            m_rInfo.rAuth.authstate = AUTH_TRYING_PACKAGE;

            SSPIFreeContext(&m_rInfo.rAuth.rSicInfo);
        }

        // Start the WatchDog
        m_pSocket->StartWatchDog();

        // Done
        return;
    }

    // Otherwise, we got a response from a challenge response string
    else if (m_rInfo.rAuth.authstate == AUTH_RESP_RESP)
    {
        // If that succeeded
        if (SUCCEEDED(hrResponse))
        {
            // We will free the context, but keep the credential handle
            SSPIReleaseContext(&m_rInfo.rAuth.rSicInfo);

            // Connected (Authorized) state
            OnStatus(IXP_AUTHORIZED);
            m_fConnectAuth = FALSE;
            m_command = POP3_CONNECTED;
            DispatchResponse(S_OK);

        }
        else
        {
            // retry current package, with prompt
            m_rInfo.rAuth.fRetryPackage = TRUE;

            Assert(m_rInfo.rAuth.iAuthToken < m_rInfo.rAuth.cAuthToken);
            hr = CommandAUTH(m_rInfo.rAuth.rgpszAuthTokens[m_rInfo.rAuth.iAuthToken]);
            if (FAILED(hr))
            {
                OnError(hr);
                DropConnection();
                return;
            }

            // We are in the TRYING_PACKAGE state
            m_rInfo.rAuth.authstate = AUTH_TRYING_PACKAGE;

            SSPIFreeContext(&m_rInfo.rAuth.rSicInfo);
        }
        return;
    }
    else if (m_rInfo.rAuth.authstate == AUTH_CANCELED)
    {
        SSPIFreeContext(&m_rInfo.rAuth.rSicInfo);

        // Goto Next Package
        m_rInfo.rAuth.iAuthToken++;
    }


    // Loop through the auth tokens, and try to authenticate with each one in order
    while(m_rInfo.rAuth.iAuthToken < m_rInfo.rAuth.cAuthToken)
    {
        // We will handle basic authentication
        if (lstrcmpi(m_rInfo.rAuth.rgpszAuthTokens[m_rInfo.rAuth.iAuthToken], "BASIC") != 0)
        {
            // Package not installed ?
            fPackageInstalled=FALSE;
            for (i=0; i<m_rInfo.rAuth.cPackages; i++)
            {
                // Null Package ??
                if (!m_rInfo.rAuth.pPackages[i].pszName)
                    continue;

                // Is this the package I am looking for
                if (lstrcmpi(m_rInfo.rAuth.pPackages[i].pszName, m_rInfo.rAuth.rgpszAuthTokens[m_rInfo.rAuth.iAuthToken]) == 0)
                {
                    fPackageInstalled = TRUE;
                    break;
                }
            }

            // Package not installed ?
            if (fPackageInstalled)
            {
                m_rInfo.rAuth.fRetryPackage = FALSE;

                // If the package has a realm, send digest, otherwise, send normal
                hr = CommandAUTH(m_rInfo.rAuth.rgpszAuthTokens[m_rInfo.rAuth.iAuthToken]);
                if (FAILED(hr))
                {
                    OnError(hr);
                    DropConnection();
                    return;
                }

                // We are in the TRYING_PACKAGE state
                m_rInfo.rAuth.authstate = AUTH_TRYING_PACKAGE;

                // Done
                return;
            }
        }

        // Goto Next Package String
        m_rInfo.rAuth.iAuthToken++;
    }

    // If we make it here, we have exhausted all packages, so it is time 
    // to report an error and drop the connection
    OnError(IXP_E_SICILY_LOGON_FAILED);
    hr = CommandQUIT();
    if (FAILED(hr))        
        DropConnection();
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::HrSendSicilyString
// ------------------------------------------------------------------------------------
HRESULT CPOP3Transport::HrSendSicilyString(LPSTR pszData)
{
    // Locals
    LPSTR           pszLine=NULL;
    HRESULT         hr=S_OK;

    // Check Param
    Assert(pszData);

    // Allocate a line
    DWORD cchSize = (lstrlen(pszData) + 5);
    pszLine = PszAllocA(cchSize * sizeof(pszLine[0]));
    if (NULL == pszLine)
    {
        hr = TrapError(E_OUTOFMEMORY);
        return hr;
    }

    // Make Line
    wnsprintf(pszLine, cchSize, "%s\r\n", pszData);

    // Send the lin
    hr = HrSendLine(pszLine);
    ZeroMemory(pszLine, cchSize * sizeof(pszLine[0]));
    SafeMemFree(pszLine);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::CommandAUTH
// ------------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::CommandAUTH(LPSTR pszAuthType)
{
    // check params
    if (NULL == pszAuthType)
        return TrapError(E_INVALIDARG);

    // Do the command
    HRESULT hr = HrSendCommand((LPSTR)POP3_AUTH_STR, pszAuthType, !m_fConnectAuth);
    if (SUCCEEDED(hr))
        m_command = POP3_AUTH;

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::HrCancelAuthInProg
// ------------------------------------------------------------------------------------
HRESULT CPOP3Transport::HrCancelAuthInProg()
{
    // Locals
    HRESULT         hr;

    // Send *, quit and die if it fails
    hr = HrSendCommand((LPSTR)POP3_AUTH_CANCEL_STR, NULL, FALSE);
    if (FAILED(hr))
    {
        OnError(hr);
        DropConnection();
    }
    else
    {
        // New state
        m_command = POP3_AUTH;
        m_rInfo.rAuth.authstate = AUTH_CANCELED;
    }
    return hr;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::CommandUSER
// ------------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::CommandUSER(LPSTR pszUserName)
{
    // check params
    if (NULL == pszUserName)
        return TrapError(E_INVALIDARG);

    // Do the command
    HRESULT hr = HrSendCommand((LPSTR)POP3_USER_STR, pszUserName);
    if (SUCCEEDED(hr))
        m_command = POP3_USER;

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::CommandPASS
// ------------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::CommandPASS(LPSTR pszPassword)
{
    // check params
    if (NULL == pszPassword)
        return TrapError(E_INVALIDARG);

    // Do the command
    HRESULT hr = HrSendCommand((LPSTR)POP3_PASS_STR, pszPassword);
    if (SUCCEEDED(hr))
        m_command = POP3_PASS;

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::CommandSTAT
// ------------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::CommandSTAT(void)
{
    // Send Command
    HRESULT hr = HrSendCommand((LPSTR)POP3_STAT_STR, NULL);
    if (SUCCEEDED(hr))
        m_command = POP3_STAT;
    return hr;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::DoQuit
// ------------------------------------------------------------------------------------
void CPOP3Transport::DoQuit(void)
{
    CommandQUIT();
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::CommandQUIT
// ------------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::CommandQUIT(void)
{
    // Send Command
    OnStatus(IXP_DISCONNECTING);
    HRESULT hr = HrSendCommand((LPSTR)POP3_QUIT_STR, NULL);
    if (SUCCEEDED(hr))
        m_command = POP3_QUIT;
    return hr;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::CommandRSET
// ------------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::CommandRSET(void)
{
    // Send Command
    HRESULT hr = HrSendCommand((LPSTR)POP3_RSET_STR, NULL);
    if (SUCCEEDED(hr))
        m_command = POP3_RSET;
    return hr;
}


// ------------------------------------------------------------------------------------
// CPOP3Transport::CommandNOOP
// ------------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::CommandNOOP(void)
{
    // Locals
    HRESULT           hr = S_OK;
    SYSTEMTIME        stNow;
    FILETIME          ftNow;
    static FILETIME   ftNext = { 0, 0 };
    LARGE_INTEGER     liNext;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Checks for need for NOOP
    GetSystemTime (&stNow);
    SystemTimeToFileTime (&stNow, &ftNow);
    if (CompareFileTime (&ftNow, &ftNext) < 0)
        goto exit;

    // Sets the next NOOP time (+60 seconds)
    liNext.HighPart = ftNow.dwHighDateTime;
    liNext.LowPart  = ftNow.dwLowDateTime;
    liNext.QuadPart += 600000000i64;
    ftNext.dwHighDateTime = liNext.HighPart;
    ftNext.dwLowDateTime  = liNext.LowPart;

    // Send Command
    hr = HrSendCommand((LPSTR)POP3_NOOP_STR, NULL);
    if (SUCCEEDED(hr))
        m_command = POP3_NOOP;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::CommandLIST
// ------------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::CommandLIST(POP3CMDTYPE cmdtype, DWORD dwPopId)
{
    // Issue complex command
    return HrComplexCommand(POP3_LIST, cmdtype, dwPopId, 0);
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::CommandTOP
// ------------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::CommandTOP (POP3CMDTYPE cmdtype, DWORD dwPopId, DWORD cPreviewLines)
{
    // Issue complex command
    return HrComplexCommand(POP3_TOP, cmdtype, dwPopId, cPreviewLines);
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::CommandUIDL
// ------------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::CommandUIDL(POP3CMDTYPE cmdtype, DWORD dwPopId)
{
    // Issue complex command
    return HrComplexCommand(POP3_UIDL, cmdtype, dwPopId, 0);
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::CommandDELE
// ------------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::CommandDELE(POP3CMDTYPE cmdtype, DWORD dwPopId)
{
    // Issue complex command
    return HrComplexCommand(POP3_DELE, cmdtype, dwPopId, 0);
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::CommandRETR
// ------------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::CommandRETR(POP3CMDTYPE cmdtype, DWORD dwPopId)
{
    // Issue complex command
    return HrComplexCommand(POP3_RETR, cmdtype, dwPopId, 0);
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::MarkItem
// ------------------------------------------------------------------------------------
STDMETHODIMP CPOP3Transport::MarkItem(POP3MARKTYPE marktype, DWORD dwPopId, boolean fMarked)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No stat yet...
    if (FALSE == m_rInfo.fStatDone)
    {
        hr = TrapError(IXP_E_POP3_NEED_STAT);
        goto exit;
    }

    // No Messages...
    if (0 == m_rInfo.cMarked || NULL == m_rInfo.prgMarked)
    {
        hr = TrapError(IXP_E_POP3_NO_MESSAGES);
        goto exit;
    }

    // Bad PopId
    if (0 == dwPopId || dwPopId > m_rInfo.cMarked)
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // Message Index
    i = dwPopId - 1;

    // Handle Mark Type
    switch(marktype)
    {
    // Mark for Top
    case POP3_MARK_FOR_TOP:
        if (fMarked)
            FLAGSET(m_rInfo.prgMarked[i], POP3_MARK_FOR_TOP);
        else
            FLAGCLEAR(m_rInfo.prgMarked[i], POP3_MARK_FOR_TOP);   
        break;

    // Mark for Retrieval
    case POP3_MARK_FOR_RETR:
        if (fMarked)
            FLAGSET(m_rInfo.prgMarked[i], POP3_MARK_FOR_RETR);
        else
            FLAGCLEAR(m_rInfo.prgMarked[i], POP3_MARK_FOR_RETR);   
        break;

    // Mark for Delete
    case POP3_MARK_FOR_DELE:
        if (fMarked)
            FLAGSET(m_rInfo.prgMarked[i], POP3_MARK_FOR_DELE);
        else
            FLAGCLEAR(m_rInfo.prgMarked[i], POP3_MARK_FOR_DELE);   
        break;

    // Mark for UIDL
    case POP3_MARK_FOR_UIDL:
        if (fMarked)
            FLAGSET(m_rInfo.prgMarked[i], POP3_MARK_FOR_UIDL);
        else
            FLAGCLEAR(m_rInfo.prgMarked[i], POP3_MARK_FOR_UIDL);   
        break;

    // Mark for List
    case POP3_MARK_FOR_LIST:
        if (fMarked)
            FLAGSET(m_rInfo.prgMarked[i], POP3_MARK_FOR_LIST);
        else
            FLAGCLEAR(m_rInfo.prgMarked[i], POP3_MARK_FOR_LIST);   
        break;

    // E_INVALIDARG
    default:
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::HrComplexCommand
// ------------------------------------------------------------------------------------
HRESULT CPOP3Transport::HrComplexCommand(POP3COMMAND command, POP3CMDTYPE cmdtype, DWORD dwPopId, ULONG cPreviewLines)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cMarked;
    BOOL            fDone;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // go Busy
    CHECKHR(hr = HrEnterBusy());

    // Save top preview lines
    m_rInfo.cPreviewLines = cPreviewLines;

    // Save command type
    m_rInfo.cmdtype = cmdtype;

    // Locals
    switch(cmdtype)
    {
    // Single command
    case POP3CMD_GET_POPID:

        // Bad PopId
        if (0 == dwPopId)
        {
            hr = TrapError(IXP_E_POP3_POPID_OUT_OF_RANGE);
            goto exit;
        }

        // Have we done a stat command
        if (m_rInfo.fStatDone && dwPopId > m_rInfo.cMarked)
        {
            hr = TrapError(IXP_E_POP3_POPID_OUT_OF_RANGE);
            goto exit;
        }

        // Save as Current
        m_rInfo.dwPopIdCurrent = dwPopId;

        // Do the command
        CHECKHR(hr = HrCommandGetPopId(command, dwPopId));

        // Done
        break;

    // Get marked items
    case POP3CMD_GET_MARKED:

        // No stat yet...
        if (FALSE == m_rInfo.fStatDone)
        {
            hr = TrapError(IXP_E_POP3_NEED_STAT);
            goto exit;
        }

        // No Messages...
        if (0 == m_rInfo.cMarked || NULL == m_rInfo.prgMarked)
        {
            hr = TrapError(IXP_E_POP3_NO_MESSAGES);
            goto exit;
        }

        // Are there any messages mared for this command...
        cMarked = CountMarked(command);
        if (0 == cMarked)
        {
            hr = TrapError(IXP_E_POP3_NO_MARKED_MESSAGES);
            goto exit;
        }

        // Init Marked State
        m_rInfo.dwPopIdCurrent = 0;

        // Do next marked...
        CHECKHR(hr = HrCommandGetNext(command, &fDone));
        IxpAssert(fDone == FALSE);

        // Done
        break;

    // Multiple commands or a list operation
    case POP3CMD_GET_ALL:

        // Do the command
        CHECKHR(hr = HrCommandGetAll(command));

        // done
        break;

    // E_INVALIDARG
    default:
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

exit:
    // Failure
    if (FAILED(hr))
        LeaveBusy();

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::HrCommandGetPopId
// ------------------------------------------------------------------------------------
HRESULT CPOP3Transport::HrCommandGetPopId(POP3COMMAND command, DWORD dwPopId)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        szPopId[30];

    // Handle command type
    IxpAssert(dwPopId == m_rInfo.dwPopIdCurrent);
    switch(command)
    {
    case POP3_DELE:
        wnsprintf(szPopId, ARRAYSIZE(szPopId), "%d", dwPopId);
        CHECKHR(hr = HrSendCommand((LPSTR)POP3_DELE_STR, szPopId, FALSE));
        m_command = POP3_DELE;
        break;

    case POP3_RETR:
        ZeroMemory(&m_rInfo.rFetch, sizeof(FETCHINFO));
        wnsprintf(szPopId, ARRAYSIZE(szPopId), "%d", dwPopId);
        CHECKHR(hr = HrSendCommand((LPSTR)POP3_RETR_STR, szPopId, FALSE));
        m_command = POP3_RETR;
        break;

    case POP3_TOP:
        ZeroMemory(&m_rInfo.rFetch, sizeof(FETCHINFO));
        wnsprintf(szPopId, ARRAYSIZE(szPopId), "%d %d", dwPopId, m_rInfo.cPreviewLines);
        CHECKHR(hr = HrSendCommand((LPSTR)POP3_TOP_STR, szPopId, FALSE));
        m_command = POP3_TOP;
        break;

    case POP3_LIST:
        m_rInfo.cList = 0;
        wnsprintf(szPopId, ARRAYSIZE(szPopId), "%d", dwPopId);
        CHECKHR(hr = HrSendCommand((LPSTR)POP3_LIST_STR, szPopId, FALSE));
        m_command = POP3_LIST;
        break;

    case POP3_UIDL:
        m_rInfo.cList = 0;
        wnsprintf(szPopId, ARRAYSIZE(szPopId), "%d", dwPopId);
        CHECKHR(hr = HrSendCommand((LPSTR)POP3_UIDL_STR, szPopId, FALSE));
        m_command = POP3_UIDL;
        break;

    default:
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::DwGetCommandMarkedFlag
// ------------------------------------------------------------------------------------
DWORD CPOP3Transport::DwGetCommandMarkedFlag(POP3COMMAND command)
{
    DWORD dw;

    switch(command)
    {
    case POP3_LIST:
        dw = POP3_MARK_FOR_LIST;
        break;

    case POP3_DELE:
        dw = POP3_MARK_FOR_DELE;
        break;

    case POP3_RETR:
        dw = POP3_MARK_FOR_RETR;
        break;

    case POP3_TOP:
        dw = POP3_MARK_FOR_TOP;
        break;

    case POP3_UIDL:
        dw = POP3_MARK_FOR_UIDL;
        break;

    default:
        IxpAssert(FALSE);
        dw = 0;
        break;
    }

    return dw;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::CountMarked
// ------------------------------------------------------------------------------------
ULONG CPOP3Transport::CountMarked(POP3COMMAND command)
{
    // Locals
    DWORD       dw = 0;
    ULONG       c=0,
                i;

    // Check some stuff
    IxpAssert(m_rInfo.cMarked && m_rInfo.prgMarked);

    // Handle Command type
    dw = DwGetCommandMarkedFlag(command);
    if (0 == dw)
        return 0;

    // Count
    for (i=0; i<m_rInfo.cMarked; i++)
        if (dw & m_rInfo.prgMarked[i])
            c++;

    // Done
    return c;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::HrCommandGetNext
// ------------------------------------------------------------------------------------
HRESULT CPOP3Transport::HrCommandGetNext(POP3COMMAND command, BOOL *pfDone)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        szPopId[30];
    DWORD       dw;
    ULONG       i;

    // check params
    IxpAssert(pfDone && m_rInfo.dwPopIdCurrent <= m_rInfo.cMarked);

    // Init - Assume were done
    *pfDone = TRUE;

    // Doing all
    if (POP3CMD_GET_ALL == m_rInfo.cmdtype)
    {
        // Done
        IxpAssert(m_rInfo.fStatDone == TRUE);
        if (m_rInfo.dwPopIdCurrent == m_rInfo.cMarked)
            goto exit;

        // Next Message..
        m_rInfo.dwPopIdCurrent++;
        *pfDone = FALSE;
        CHECKHR(hr = HrCommandGetPopId(command, m_rInfo.dwPopIdCurrent));
    }

    // Doing Marked
    else
    {
        // Check Parms
        IxpAssert(POP3CMD_GET_MARKED == m_rInfo.cmdtype);

        // Get marked flag
        dw = DwGetCommandMarkedFlag(command);
        if (0 == dw)
        {
            hr = TrapError(E_INVALIDARG);
            goto exit;
        }

        // Step Over Last Marked Item
        m_rInfo.dwPopIdCurrent++;

        // Start comparing at iCurrent
        for (i=m_rInfo.dwPopIdCurrent-1; i<m_rInfo.cMarked; i++)
        {
            // Is this item marked...
            if (dw & m_rInfo.prgMarked[i])
            {
                // Send Command
                m_rInfo.dwPopIdCurrent = i + 1;
                *pfDone = FALSE;
                CHECKHR(hr = HrCommandGetPopId(command, m_rInfo.dwPopIdCurrent));
                break;
            }
        }
    }

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::HrCommandGetAll
// ------------------------------------------------------------------------------------
HRESULT CPOP3Transport::HrCommandGetAll(POP3COMMAND command)
{
    // Locals
    HRESULT         hr=S_OK;
    CHAR            szPopId[30];
    BOOL            fDone;

    // Init current
    m_rInfo.dwPopIdCurrent = 0;

    // POP3_LIST
    if (POP3_LIST == command)
    {
        m_rInfo.cList = 0;
        CHECKHR(hr = HrSendCommand((LPSTR)POP3_LIST_ALL_STR, NULL, FALSE));
        m_command = POP3_LIST;
    }

    // POP3_UIDL
    else if (POP3_UIDL == command)
    {
        m_rInfo.cList = 0;
        CHECKHR(hr = HrSendCommand((LPSTR)POP3_UIDL_ALL_STR, NULL, FALSE));
        m_command = POP3_UIDL;
    }

    // Otherwise, we better have done the stat command
    else
    {
        // No stat yet...
        if (FALSE == m_rInfo.fStatDone)
        {
            hr = TrapError(IXP_E_POP3_NEED_STAT);
            goto exit;
        }

        // No Messages...
        if (0 == m_rInfo.cMarked || NULL == m_rInfo.prgMarked)
        {
            hr = TrapError(IXP_E_POP3_NO_MESSAGES);
            goto exit;
        }

        // Next Command
        CHECKHR(hr = HrCommandGetNext(command, &fDone));
        IxpAssert(fDone == FALSE);
    }

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::ResponseSTAT
// ------------------------------------------------------------------------------------
void CPOP3Transport::ResponseSTAT(void)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cMessages=0,
                    cbMessages=0;
    LPSTR           pszPart1=NULL,
                    pszPart2=NULL;
    POP3RESPONSE    rResponse;

    // Read Server Response...
    hr = HrGetResponse();
    if (IXP_E_INCOMPLETE == hr)
        return;

    // Init Response
    ZeroMemory(&rResponse, sizeof(POP3RESPONSE));

    // Parse the response
    CHECKHR(hr = HrSplitPop3Response(m_pszResponse, &pszPart1, &pszPart2));

    // Convert
    IxpAssert(pszPart1 && pszPart2);
    cMessages = StrToInt(pszPart1);
    cbMessages = StrToInt(pszPart2);

    // Are there messages
    if (FALSE == m_rInfo.fStatDone && cMessages > 0)
    {
        // Set Number of messages
        IxpAssert(m_rInfo.prgMarked == NULL);
        m_rInfo.cMarked = cMessages;

        // Allocate message array
        CHECKHR(hr = HrAlloc((LPVOID *)&m_rInfo.prgMarked, sizeof(DWORD) * m_rInfo.cMarked));

        // Zero
        ZeroMemory(m_rInfo.prgMarked, sizeof(DWORD) * m_rInfo.cMarked);
    }

    // Success
    m_rInfo.fStatDone = TRUE;

exit:
    // Cleanup
    SafeMemFree(pszPart1);
    SafeMemFree(pszPart2);

    // Build Response
    rResponse.fValidInfo = TRUE;
    rResponse.rStatInfo.cMessages = cMessages;
    rResponse.rStatInfo.cbMessages = cbMessages;
    DispatchResponse(hr, TRUE, &rResponse);

    // Done
    return;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::HrSplitPop3Response
// ------------------------------------------------------------------------------------
HRESULT CPOP3Transport::HrSplitPop3Response(LPSTR pszLine, LPSTR *ppszPart1, LPSTR *ppszPart2)
{
    // Locals
    LPSTR           psz,
                    pszStart;
    CHAR            ch;
    HRESULT         hr=IXP_E_POP3_PARSE_FAILURE;

    // No Response...
    IxpAssert(pszLine && pszLine[0] != '-' && ppszPart1 && ppszPart2);
    if (NULL == pszLine)
        goto exit;

    // Parse: '+OK' 432 1234
    psz = PszSkipWhiteA(pszLine);
    if ('\0' == *psz)
        goto exit;

    // Parse response token
    pszStart = psz;
    if ('+' == *pszLine)
    {
        // Parse: '+OK' 432 1234
        psz = PszScanToWhiteA(psz);
        if ('\0' == *psz)
            goto exit;

#ifdef DEBUG
        IxpAssert(' ' == *psz);
        *psz = '\0';
        IxpAssert(lstrcmpi(pszStart, "+OK") == 0);
        *psz = ' ';
#endif

        // Parse: +OK '432' 1234
        psz = PszSkipWhiteA(psz);
        if ('\0' == *psz)
            goto exit;
    }

    // Parse: +OK '432' 1234
    pszStart = psz;
    psz = PszScanToWhiteA(psz);
    if ('\0' == *psz)
        goto exit;

    // Get Message Count
    *psz = '\0';
    *ppszPart1 = PszDupA(pszStart);
    *psz = ' ';

    // Parse: +OK 432 '1234'
    psz = PszSkipWhiteA(psz);
    if ('\0' == *psz)
    {
        // Raid 28435 - Outlook needs INETCOMM to accept empty UIDL responses
        *ppszPart2 = PszDupA(c_szEmpty);
        hr = S_OK;
        goto exit;
    }

    // Parse: +OK 432 1234
    pszStart = psz;
    psz = PszScanToWhiteA(psz);

    // Get Message Count
    ch = *psz;
    *psz = '\0';
    *ppszPart2 = PszDupA(pszStart);
    *psz = ch;

    // Success
    hr = S_OK;

exit:
    // Done
    return hr;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::ResponseGenericList
// ------------------------------------------------------------------------------------
void CPOP3Transport::ResponseGenericList(void)
{
    // Locals
    HRESULT         hr;
    INT             cbLine;
    BOOL            fDone,
                    fComplete;
    LPSTR           pszPart1=NULL,
                    pszPart2=NULL;
    POP3RESPONSE    rResponse;

    // Same response as single LIST x command, but then get next
    if (POP3CMD_GET_MARKED == m_rInfo.cmdtype || POP3CMD_GET_POPID == m_rInfo.cmdtype)
    {
        // Read Server Response...
        hr = HrGetResponse();
        if (IXP_E_INCOMPLETE == hr)
            goto exit;

        // Otherwise, if failure...
        else if (FAILED(hr))
        {
            DispatchResponse(hr, TRUE);
            goto exit;
        }

        // Get the two parts from the line
        hr = HrSplitPop3Response(m_pszResponse, &pszPart1, &pszPart2);
        if (FAILED(hr))
        {
            DispatchResponse(hr, TRUE);
            goto exit;
        }

        // Init Response
        ZeroMemory(&rResponse, sizeof(POP3RESPONSE));

        // POP3_LIST
        if (POP3_LIST == m_command)
        {
            rResponse.fValidInfo = TRUE;
            rResponse.rListInfo.dwPopId = StrToInt(pszPart1);
            rResponse.rListInfo.cbSize = StrToInt(pszPart2);
            IxpAssert(rResponse.rListInfo.dwPopId == m_rInfo.dwPopIdCurrent);
        }

        // POP3_UIDL
        else
        {
            rResponse.fValidInfo = TRUE;
            rResponse.rUidlInfo.dwPopId = StrToInt(pszPart1);
            rResponse.rUidlInfo.pszUidl = pszPart2;
            IxpAssert(rResponse.rUidlInfo.dwPopId == m_rInfo.dwPopIdCurrent);
        }

        // Do Next
        if (POP3CMD_GET_MARKED == m_rInfo.cmdtype)
        {
            // Give the response
            DispatchResponse(S_OK, FALSE, &rResponse);

            // Do the next marked list item
            hr = HrCommandGetNext(m_command, &fDone);
            if (FAILED(hr))
            {
                DispatchResponse(hr, TRUE);
                goto exit;
            }

            // Done Response
            if (fDone)
                DispatchResponse(S_OK, TRUE);
        }

        // Dispatch Done or single item response
        else
            DispatchResponse(S_OK, TRUE, &rResponse);
    }

    // Full LIST response
    else if (POP3CMD_GET_ALL == m_rInfo.cmdtype)
    {
        // First call...
        if (m_rInfo.dwPopIdCurrent == 0)
        {
            // Read Server Response...
            hr = HrGetResponse();
            if (IXP_E_INCOMPLETE == hr)
                goto exit;

            // Otherwise, if failure...
            else if (FAILED(hr))
            {
                DispatchResponse(hr, TRUE);
                goto exit;
            }

            // Current
            m_rInfo.dwPopIdCurrent = 1;
        }

        // Clear Response
        SafeMemFree(m_pszResponse);
        m_uiResponse = 0;
        m_hrResponse = S_OK;

        // Read a blob of lines
        while(1)
        {
            // Read Line
            hr = HrReadLine(&m_pszResponse, &cbLine, &fComplete);
            if (FAILED(hr))
            {
                DispatchResponse(hr, TRUE);
                goto exit;
            }

            // If not complete
            if (!fComplete)
                goto exit;

            // Add Detail
            if (m_pCallback && m_fCommandLogging)
                m_pCallback->OnCommand(CMD_RESP, m_pszResponse, S_OK, POP3THISIXP);

            // If its a dot, were done
            if (*m_pszResponse == '.')
            {
                // If we haven't done a stat yet, we can use these totals...
                IxpAssert(m_rInfo.fStatDone ? m_rInfo.cList == m_rInfo.cMarked : TRUE);
                if (FALSE == m_rInfo.fStatDone && m_rInfo.cList > 0)
                {
                    // Have I build my internal array of messages yet...
                    IxpAssert(m_rInfo.prgMarked == NULL);
                    m_rInfo.cMarked = m_rInfo.cList;

                    // Allocate message array
                    CHECKHR(hr = HrAlloc((LPVOID *)&m_rInfo.prgMarked, sizeof(DWORD) * m_rInfo.cMarked));

                    // Zero
                    ZeroMemory(m_rInfo.prgMarked, sizeof(DWORD) * m_rInfo.cMarked);
                }

                // Were Done
                DispatchResponse(S_OK, TRUE);

                // Stat Done
                m_rInfo.fStatDone = TRUE;

                // Done
                break;
            }

            // Get the two parts from the line
            hr = HrSplitPop3Response(m_pszResponse, &pszPart1, &pszPart2);
            if (FAILED(hr))
            {
                DispatchResponse(hr, TRUE);
                goto exit;
            }

            // Init Response
            ZeroMemory(&rResponse, sizeof(POP3RESPONSE));

            // POP3_LIST
            if (POP3_LIST == m_command)
            {
                rResponse.fValidInfo = TRUE;
                rResponse.rListInfo.dwPopId = StrToInt(pszPart1);
                rResponse.rListInfo.cbSize = StrToInt(pszPart2);
            }

            // POP3_UIDL
            else
            {
                rResponse.fValidInfo = TRUE;
                rResponse.rUidlInfo.dwPopId = StrToInt(pszPart1);
                rResponse.rUidlInfo.pszUidl = pszPart2;
                IxpAssert(rResponse.rUidlInfo.dwPopId == m_rInfo.dwPopIdCurrent);
            }

            // Count the number of messages
            m_rInfo.cList++;

            // Dispatch the response
            DispatchResponse(S_OK, FALSE, &rResponse);
            m_rInfo.dwPopIdCurrent++;

            // Cleanup
            SafeMemFree(pszPart1);
            SafeMemFree(pszPart2);

            // Clear Response
            SafeMemFree(m_pszResponse);
            m_uiResponse = 0;
            m_hrResponse = S_OK;
        }
    }

    // Otherwise failure...
    else
    {
        IxpAssert(FALSE);
        goto exit;
    }

exit:
    // Cleanup
    SafeMemFree(pszPart1);
    SafeMemFree(pszPart2);

    // Done
    return;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::FEndRetrRecvHeader
// ------------------------------------------------------------------------------------
BOOL CPOP3Transport::FEndRetrRecvHeader(LPSTR pszLines, ULONG cbRead)
{
    // If we see CRLFCRLF
    if (StrStr(pszLines, "\r\n\r\n"))
        return TRUE;

    // Otherwise, did last block end with a CRLF and this block begins with a crlf
    else if (cbRead >= 2                  &&
             m_rInfo.rFetch.fLastLineCRLF &&
             pszLines[0] == '\r'          &&
             pszLines[1] == '\n')
        return TRUE;

    // Header is not done
    return FALSE;
}


// ------------------------------------------------------------------------------------
// CPOP3Transport::ResponseGenericRetrieve
// ------------------------------------------------------------------------------------
void CPOP3Transport::ResponseGenericRetrieve(void)
{
    // Locals
    HRESULT         hr=S_OK;
    LPSTR           pszLines=NULL;
    INT             cbRead,
                    cLines;
    ULONG           cbSubtract;
    BOOL            fDone,
                    fMessageDone;
    POP3RESPONSE    rResponse;

    // First call...
    if (FALSE == m_rInfo.rFetch.fGotResponse)
    {
        // Read Server Response...
        hr = HrGetResponse();
        if (IXP_E_INCOMPLETE == hr)
            goto exit;

        // Otherwise, if failure...
        else if (FAILED(hr))
        {
            FillRetrieveResponse(&rResponse, NULL, 0, &fMessageDone);
            DispatchResponse(hr, TRUE, &rResponse);
            goto exit;
        }

        // Current
        m_rInfo.rFetch.fGotResponse = TRUE;
    }

    // While there are lines to read...
    hr = m_pSocket->ReadLines(&pszLines, &cbRead, &cLines);

    // Incomplete data available...
    if (IXP_E_INCOMPLETE == hr)
        goto exit;

    // Or if we failed...
    else if (FAILED(hr))
    {
        FillRetrieveResponse(&rResponse, NULL, 0, &fMessageDone);
        DispatchResponse(hr, TRUE, &rResponse);
        goto exit;
    }

    // Are we receiving the header...
    if (FALSE == m_rInfo.rFetch.fHeader)
    {
        // Test for end of header found
        if (FEndRetrRecvHeader(pszLines, cbRead))
            m_rInfo.rFetch.fHeader = TRUE;

        // $$BUG$$ Our good buddies on Exchange produced the following message:
        // 
        // To: XXXXXXXXXXXXXXXXXXX
        // From: XXXXXXXXXXXXXXXXX
        // Subject: XXXXXXXXXXXXXX
        // .
        //
        // As you can see there is not CRLFCRLF following the last header line which is very
        // illegal. This message caused us to hange because we never saw the end of the header.
        // So this is why I also test for the end of the body...
        else if (FEndRetrRecvBody(pszLines, cbRead, &cbSubtract))
        {
            cbRead -= cbSubtract;
            m_rInfo.rFetch.fHeader = TRUE;
            m_rInfo.rFetch.fBody = TRUE;
        }

        // Otherwise, did this block end with a crlf
        else if (cbRead >= 2 && pszLines[cbRead - 1] == '\n' && pszLines[cbRead - 2] == '\r')
            m_rInfo.rFetch.fLastLineCRLF = TRUE;
        else
            m_rInfo.rFetch.fLastLineCRLF = FALSE;
    }

    // Also check to see if body was received in same set of lines
    if (TRUE == m_rInfo.rFetch.fHeader)
    {
        // Test for end of header found
        if (FEndRetrRecvBody(pszLines, cbRead, &cbSubtract))
        {
            cbRead -= cbSubtract;
            m_rInfo.rFetch.fBody = TRUE;
        }

        // Otherwise, check for line ending with crlf
        else if (cbRead >= 2 && pszLines[cbRead - 1] == '\n' && pszLines[cbRead - 2] == '\r')
            m_rInfo.rFetch.fLastLineCRLF = TRUE;
        else
            m_rInfo.rFetch.fLastLineCRLF = FALSE;
    }

    // Count bytes downloaded on this fetch
    m_rInfo.rFetch.cbSoFar += cbRead;

    // UnStuff
    UnStuffDotsFromLines(pszLines, &cbRead);

    // Fill the response
    FillRetrieveResponse(&rResponse, pszLines, cbRead, &fMessageDone);

    // Dispatch This Resposne...
    if (POP3CMD_GET_POPID == m_rInfo.cmdtype)
        DispatchResponse(S_OK, fMessageDone, &rResponse);

    // Otherwise
    else
    {
        // Check command type
        IxpAssert(POP3CMD_GET_MARKED == m_rInfo.cmdtype || POP3CMD_GET_ALL == m_rInfo.cmdtype);

        // Dispatch current response
        DispatchResponse(S_OK, FALSE, &rResponse);

        // If done with current message...
        if (fMessageDone)
        {
            // Get Next
            hr = HrCommandGetNext(m_command, &fDone);
            if (FAILED(hr))
            {
                DispatchResponse(hr, TRUE);
                goto exit;
            }

            // If Done
            if (fDone)
                DispatchResponse(S_OK, TRUE);
        }
    }

exit:
    // Cleanup
    SafeMemFree(pszLines);

    // Done
    return;
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::FillRetrieveResponse
// ------------------------------------------------------------------------------------
void CPOP3Transport::FillRetrieveResponse(LPPOP3RESPONSE pResponse, LPSTR pszLines, ULONG cbRead,
    BOOL *pfMessageDone)
{
    // Clear Response
    ZeroMemory(pResponse, sizeof(POP3RESPONSE));

    // POP3_TOP
    if (POP3_TOP == m_command)
    {
        // Build Response
        pResponse->fValidInfo = TRUE;
        pResponse->rTopInfo.dwPopId = m_rInfo.dwPopIdCurrent;
        pResponse->rTopInfo.cPreviewLines = m_rInfo.cPreviewLines;
        pResponse->rTopInfo.cbSoFar = m_rInfo.rFetch.cbSoFar;
        pResponse->rTopInfo.pszLines = pszLines;
        pResponse->rTopInfo.cbLines = cbRead;
        pResponse->rTopInfo.fHeader = m_rInfo.rFetch.fHeader;
        pResponse->rTopInfo.fBody = m_rInfo.rFetch.fBody;
        *pfMessageDone = (m_rInfo.rFetch.fHeader && m_rInfo.rFetch.fBody);
    }

    // POP3_RETR
    else
    {
        IxpAssert(POP3_RETR == m_command);
        pResponse->fValidInfo = TRUE;
        pResponse->rRetrInfo.fHeader = m_rInfo.rFetch.fHeader;
        pResponse->rRetrInfo.fBody = m_rInfo.rFetch.fBody;
        pResponse->rRetrInfo.dwPopId = m_rInfo.dwPopIdCurrent;
        pResponse->rRetrInfo.cbSoFar = m_rInfo.rFetch.cbSoFar;
        pResponse->rRetrInfo.pszLines = pszLines;
        pResponse->rRetrInfo.cbLines = cbRead;
        *pfMessageDone = (m_rInfo.rFetch.fHeader && m_rInfo.rFetch.fBody);
    }
}

// ------------------------------------------------------------------------------------
// CPOP3Transport::ResponseDELE
// ------------------------------------------------------------------------------------
void CPOP3Transport::ResponseDELE(void)
{
    // Locals
    HRESULT         hr=S_OK;
    BOOL            fDone;
    POP3RESPONSE    rResponse;

    // Read Server Response...
    hr = HrGetResponse();
    if (IXP_E_INCOMPLETE == hr)
        goto exit;

    // Otherwise, if failure...
    else if (FAILED(hr))
    {
        DispatchResponse(hr, TRUE);
        goto exit;
    }

    // Clear Response
    ZeroMemory(&rResponse, sizeof(POP3RESPONSE));
    rResponse.fValidInfo = TRUE;
    rResponse.dwPopId = m_rInfo.dwPopIdCurrent;

    // Dispatch This Resposne...
    if (POP3CMD_GET_POPID == m_rInfo.cmdtype)
        DispatchResponse(S_OK, TRUE, &rResponse);

    // Otherwise
    else
    {
        // Check command type
        IxpAssert(POP3CMD_GET_MARKED == m_rInfo.cmdtype || POP3CMD_GET_ALL == m_rInfo.cmdtype);

        // Dispatch current response
        DispatchResponse(S_OK, FALSE, &rResponse);

        // Get Next
        hr = HrCommandGetNext(m_command, &fDone);
        if (FAILED(hr))
        {
            DispatchResponse(hr, TRUE);
            goto exit;
        }

        // If Done
        if (fDone)
            DispatchResponse(S_OK, TRUE);
    }

exit:
    // Done
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\ixphttpm.h ===
// --------------------------------------------------------------------------------
// Ixphttpm.h
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved
// Greg Friedman
// --------------------------------------------------------------------------------
#ifndef __IXPHTTPM_H
#define __IXPHTTPM_H

// --------------------------------------------------------------------------------
// Includes
// --------------------------------------------------------------------------------
#include <stddef.h> // for offsetof

#include "wininet.h"
#include "propfind.h"
#include "xmlparser.h"
#include "davparse.h"

// --------------------------------------------------------------------------------
// constants
// --------------------------------------------------------------------------------
#define ELE_STACK_CAPACITY    7
#define HTTPMAIL_BUFSIZE      4048
#define PCDATA_BUFSIZE        1024

// optional headers added to http requests
#define RH_NOROOT                   0x00000001
#define RH_ALLOWRENAME              0x00000002
#define RH_TRANSLATEFALSE           0x00000004
#define RH_TRANSLATETRUE            0x00000008
#define RH_XMLCONTENTTYPE           0x00000010
#define RH_MESSAGECONTENTTYPE       0x00000020
#define RH_SMTPMESSAGECONTENTTYPE   0x00000040
#define RH_BRIEF                    0x00000080
#define RH_SAVEINSENTTRUE           0x00000100
#define RH_SAVEINSENTFALSE          0x00000200
#define RH_ROOTTIMESTAMP            0x00000400
#define RH_FOLDERTIMESTAMP          0x00000800
#define RH_ADDCHARSET               0x00001000

// --------------------------------------------------------------------------------
// Forward declarations
// --------------------------------------------------------------------------------
class CHTTPMailTransport;

// --------------------------------------------------------------------------------
// root props
// --------------------------------------------------------------------------------
typedef struct tagROOTPROPS
{
    LPSTR   pszAdbar;
    LPSTR   pszContacts;
    LPSTR   pszInbox;
    LPSTR   pszOutbox;
    LPSTR   pszSendMsg;
    LPSTR   pszSentItems;
    LPSTR   pszDeletedItems;
    LPSTR   pszDrafts;
    LPSTR   pszMsgFolderRoot;
    LPSTR   pszSig;
    DWORD   dwMaxPollingInterval;
} ROOTPROPS, *LPROOTPROPS;

// --------------------------------------------------------------------------------
// Schemas used for XML parsing
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// XPCOLUMNDATATYPE
// --------------------------------------------------------------------------------
typedef enum tagXPCOLUMNDATATYPE
{
    XPCDT_STRA,
    XPCDT_DWORD,
    XPCDT_BOOL,
    XPCDT_IXPHRESULT,
    XPCDT_HTTPSPECIALFOLDER,
    XPCDT_HTTPCONTACTTYPE,
    XPCDT_LASTTYPE
} XPCOLUMNDATATYPE;

// --------------------------------------------------------------------------------
// XPCOLUMN FLAGS
// --------------------------------------------------------------------------------
#define XPCF_PFREQUEST                  0x00000001  // include in propfind request
#define XPCF_MSVALIDMSRESPONSECHILD     0x00000002  // during parse - validate that the ele stack is correct for a child of a <response> in a <multistatus> response
#define XPCF_MSVALIDPROP                0x00000004  // during parse - validate that the stack is correct for a propvalue in an ms response
#define XPCF_DONTSETFLAG                0x00000008  // don't set the found flag when parsing

#define XPFC_PROPFINDPROP   (XPCF_PFREQUEST | XPCF_MSVALIDPROP)
#define XPCF_PROPFINDHREF   (XPCF_MSVALIDMSRESPONSECHILD | XPCF_DONTSETFLAG)

// --------------------------------------------------------------------------------
// XPCOLUMN
// --------------------------------------------------------------------------------
typedef struct tagXPCOLUMN
{
    HMELE               ele;
    DWORD               dwFlags;
    XPCOLUMNDATATYPE    cdt;
    DWORD               offset;
} XPCOLUMN, *LPXPCOLUMN;

// --------------------------------------------------------------------------------
// XP_BEGIN_SCHEMA
// --------------------------------------------------------------------------------
#define XP_BEGIN_SCHEMA(opName) \
    static const XPCOLUMN c_rg##opName##Schema[] = {

// --------------------------------------------------------------------------------
// XP_SCHEMA_COL
// --------------------------------------------------------------------------------
#define XP_SCHEMA_COL(ele, dwFlags, cdt, tyStruct, fieldName ) \
    { ele, dwFlags, cdt, offsetof(tyStruct, fieldName) },

// --------------------------------------------------------------------------------
// XP_END_SCHEMA
// --------------------------------------------------------------------------------
#define XP_END_SCHEMA \
    };

// --------------------------------------------------------------------------------
// XP_FREE_STRUCT
// --------------------------------------------------------------------------------
#define XP_FREE_STRUCT(opName, target, flags) \
    _FreeStruct(c_rg##opName##Schema, ARRAYSIZE(c_rg##opName##Schema), target, flags)

// --------------------------------------------------------------------------------
// XP_BIND_TO_STRUCT
// --------------------------------------------------------------------------------
#define XP_BIND_TO_STRUCT(opName, pwcText, ulLen, target, wasBound) \
    _BindToStruct(pwcText, ulLen, c_rg##opName##Schema, ARRAYSIZE(c_rg##opName##Schema), target, wasBound)

// --------------------------------------------------------------------------------
// XP_CREATE_PROPFIND_REQUEST
// --------------------------------------------------------------------------------
#define XP_CREATE_PROPFIND_REQUEST(opName, pRequest) \
    HrAddPropFindSchemaProps(pRequest, c_rg##opName##Schema, ARRAYSIZE(c_rg##opName##Schema))

// --------------------------------------------------------------------------------
// State Machine Funcs
// --------------------------------------------------------------------------------
typedef HRESULT (CHTTPMailTransport::*PFNHTTPMAILOPFUNC)(void);

// --------------------------------------------------------------------------------
// XML Parsing Funcs
// --------------------------------------------------------------------------------
typedef HRESULT (CHTTPMailTransport::*PFNCREATEELEMENT)(CXMLNamespace *pBaseNamespace, const WCHAR *pwcText, ULONG ulLen, ULONG ulNamespaceLen, BOOL fTerminal);
typedef HRESULT (CHTTPMailTransport::*PFNHANDLETEXT)(const WCHAR *pwcText, ULONG ulLen);
typedef HRESULT (CHTTPMailTransport::*PFNENDCHILDREN)(void);

typedef struct tagXMLPARSEFUNCS
{
    PFNCREATEELEMENT    pfnCreateElement;
    PFNHANDLETEXT       pfnHandleText;
    PFNENDCHILDREN      pfnEndChildren;
} XMLPARSEFUNCS, *LPXMLPARSEFUNCS;

// --------------------------------------------------------------------------------
// Utility functions
// --------------------------------------------------------------------------------
HRESULT HrParseHTTPStatus(LPSTR pszStatusStr, DWORD *pdwStatus);
HRESULT HrAddPropFindProps(IPropFindRequest *pRequest, const HMELE *rgEle, DWORD cEle);
HRESULT HrAddPropFindSchemaProps(IPropFindRequest *pRequest, const XPCOLUMN *prgCols, DWORD cCols);
HRESULT _HrGenerateRfc821Stream(LPCSTR pszFrom, LPHTTPTARGETLIST pTargets, IStream **ppRfc821Stream);
HRESULT HrGeneratePostContactXML(LPHTTPCONTACTINFO pciInfo, LPVOID *ppvXML, DWORD *pdwLen);
HRESULT HrCreatePatchContactRequest(LPHTTPCONTACTINFO pciInfo, IPropPatchRequest **ppRequest);
HRESULT HrGenerateSimpleBatchXML(LPCSTR pszRootName, LPHTTPTARGETLIST pTargets, LPVOID *ppvXML, DWORD *pdwLen);
HRESULT HrGenerateMultiDestBatchXML(LPCSTR pszRootName, LPHTTPTARGETLIST pTargets, LPHTTPTARGETLIST pDestinations, LPVOID *ppvXML, DWORD *pdwLen);
HRESULT HrCopyStringList(LPCSTR *rgszInList, LPCSTR **prgszOutList);
void    FreeStringList(LPCSTR *rgszInList);

typedef struct tagHTTPQUEUEDOP
{
    HTTPMAILCOMMAND         command;

    const PFNHTTPMAILOPFUNC *pfnState;
    int                     cState;

    LPSTR                   pszUrl;
    LPSTR                   pszDestination;
    LPCSTR                  pszContentType;
    LPVOID                  pvData;
    ULONG                   cbDataLen;
    DWORD                   dwContext;
    DWORD                   dwDepth;
    DWORD                   dwRHFlags;
    MEMBERINFOFLAGS         dwMIFlags;
    HTTPMAILPROPTYPE        tyProp;
    BOOL                    fBatch;
    LPCSTR                  *rgszAcceptTypes;
    IPropFindRequest        *pPropFindRequest;
    IPropPatchRequest       *pPropPatchRequest;

    IStream                 *pHeaderStream;
    IStream                 *pBodyStream;

    const XMLPARSEFUNCS     *pParseFuncs;

    struct tagHTTPQUEUEDOP  *pNext;

    // Used with Folders PropFind and Inbox PropFind.
    LPSTR                   pszFolderTimeStamp;

    // Used only with Folders PropFind.
    LPSTR                   pszRootTimeStamp;

} HTTPQUEUEDOP, *LPHTTPQUEUEDOP;

typedef struct tagPCDATABUFFER
{
    WCHAR           *pwcText;
    ULONG           ulLen;
    ULONG           ulCapacity;
} PCDATABUFFER, *LPPCDATABUFFER;

typedef struct tagHMELESTACK
{
    HMELE           ele;
    CXMLNamespace   *pBaseNamespace;
    BOOL            fBeganChildren;
    LPPCDATABUFFER  pTextBuffer;
} HMELESTACK, *LPHMELESTACK;


typedef struct tagHTTPMAILOPERATION
{
    const PFNHTTPMAILOPFUNC *pfnState;
    int                     iState;
    int                     cState;

    BOOL                    fLoggedResponse;

    LPSTR                   pszUrl;
    LPSTR                   pszDestination;
    LPCSTR                  pszContentType;
    LPVOID                  pvData;
    ULONG                   cbDataLen;
    DWORD                   dwContext;

    DWORD                   dwHttpStatus;   // http response status

    LPCSTR                  *rgszAcceptTypes;

    HINTERNET               hRequest;
    BOOL                    fAborted;
    DWORD                   dwDepth;
    DWORD                   dwRHFlags;
    MEMBERINFOFLAGS         dwMIFlags;
    HTTPMAILPROPTYPE        tyProp;
    BOOL                    fBatch;
    IPropFindRequest        *pPropFindRequest;
    IPropPatchRequest       *pPropPatchRequest;
    LPPCDATABUFFER          pTextBuffer;

    IStream                 *pHeaderStream;
    IStream                 *pBodyStream;
    
    // xml parsing
    const XMLPARSEFUNCS     *pParseFuncs;
    CXMLNamespace           *pTopNamespace;
    DWORD                   dwStackDepth;
    HMELESTACK              rgEleStack[ELE_STACK_CAPACITY];

    // PropFind Parsing
    BOOL                    fFoundStatus;
    DWORD                   dwStatus;
    DWORD                   dwPropFlags;

    // response
    HTTPMAILRESPONSE        rResponse;

    // Used with Folders PropFind and Inbox PropFind.
    LPSTR                   pszFolderTimeStamp;

    // Used only with Folders PropFind.
    LPSTR                   pszRootTimeStamp;
} HTTPMAILOPERATION, *LPHTTPMAILOPERATION;

class CHTTPMailTransport : public IHTTPMailTransport, public IXMLNodeFactory, public IHTTPMailTransport2
{
private:
    ULONG               m_cRef;                 // Reference Count
    BOOL                m_fHasServer;           // Has been initialized with a server
    BOOL                m_fHasRootProps;        // Root props have been retrieved
    BOOL                m_fTerminating;         // in the terminating state...killing the iothread
    IXPSTATUS           m_status;               // Connection status
    HINTERNET           m_hInternet;            // Root wininet handle
    HINTERNET           m_hConnection;          // Connection handle
    LPSTR               m_pszUserAgent;         // user agent string
    ILogFile            *m_pLogFile;            // Logfile Object
    IHTTPMailCallback   *m_pCallback;           // Transport callback object
    IXMLParser          *m_pParser;             // xml parser
    HWND                m_hwnd;                 // Window used for event synchronization
    HANDLE              m_hevPendingCommand;    // Event object that signals a pending command
    LPHTTPQUEUEDOP      m_opPendingHead;        // Pending operation - head of the queue
    LPHTTPQUEUEDOP      m_opPendingTail;        // Pending operation - tail of the queue
    CRITICAL_SECTION    m_cs;                   // Thread Safety
    HTTPMAILOPERATION   m_op;                   // current operation
    INETSERVER          m_rServer;              // Internet server
    LPSTR               m_pszCurrentHost;       // current server
    INTERNET_PORT       m_nCurrentPort;         // current port
    ROOTPROPS           m_rootProps;
public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CHTTPMailTransport(void);
    virtual ~CHTTPMailTransport(void);

    // ----------------------------------------------------------------------------
    // Unimplemented copy constructor and assignment operator
    // ----------------------------------------------------------------------------
private:
    CHTTPMailTransport(const CHTTPMailTransport& other);            // intentionally unimplemented
    CHTTPMailTransport& operator=(const CHTTPMailTransport& other); // intentionally unimplemented

public:
    // ----------------------------------------------------------------------------
    // IUnknown methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
 
    // ----------------------------------------------------------------------------
    // IInternetTransport methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP Connect(LPINETSERVER pInetServer, boolean fAuthenticate, boolean fCommandLogging);
    STDMETHODIMP DropConnection(void);
    STDMETHODIMP Disconnect(void);
    STDMETHODIMP IsState(IXPISSTATE isstate);
    STDMETHODIMP GetServerInfo(LPINETSERVER pInetServer);
    STDMETHODIMP_(IXPTYPE) GetIXPType(void);
    STDMETHODIMP InetServerFromAccount(IImnAccount *pAccount, LPINETSERVER pInetServer);
    STDMETHODIMP HandsOffCallback(void);
    STDMETHODIMP GetStatus(IXPSTATUS *pCurrentStatus);

    // ----------------------------------------------------------------------------
    // IHTTPMailTransport methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP InitNew(LPCSTR pszUserAgent, LPCSTR pszLogFilePath, IHTTPMailCallback *pCallback); 
    STDMETHODIMP GetProperty(HTTPMAILPROPTYPE proptype, LPSTR *ppszProp);
    STDMETHODIMP GetPropertyDw(HTTPMAILPROPTYPE proptype, LPDWORD lpdwProp);
    STDMETHODIMP CommandGET(LPCSTR pszPath, LPCSTR *rgszAcceptTypes, BOOL fTranslate, DWORD dwContext);
    STDMETHODIMP CommandPUT(LPCSTR pszPath, LPVOID lpvData, ULONG cbData, DWORD dwContext);
    STDMETHODIMP CommandPOST(LPCSTR pszPath, IStream *pStream, LPCSTR pszContentType, DWORD dwContext);
    STDMETHODIMP CommandDELETE(LPCSTR pszPath, DWORD dwContext);
    STDMETHODIMP CommandBDELETE(LPCSTR pszPath, LPHTTPTARGETLIST pBatchTargets, DWORD dwContext);
    STDMETHODIMP CommandPROPFIND(LPCSTR pszUrl, IPropFindRequest *pRequest, DWORD dwDepth, DWORD dwContext);
    STDMETHODIMP CommandPROPPATCH(LPCSTR pszUrl, IPropPatchRequest *pRequest, DWORD dwContext);
    STDMETHODIMP CommandMKCOL(LPCSTR pszUrl, DWORD dwContext);
    STDMETHODIMP CommandCOPY(LPCSTR pszPath, LPCSTR pszDestination, BOOL fAllowRename, DWORD dwContext);
    STDMETHODIMP CommandBCOPY(LPCSTR pszSourceCollection, LPHTTPTARGETLIST pBatchTargets, LPCSTR pszDestCollection, LPHTTPTARGETLIST pBatchDests, BOOL fAllowRename, DWORD dwContext);
    STDMETHODIMP CommandMOVE(LPCSTR pszPath, LPCSTR pszDestination, BOOL fAllowRename, DWORD dwContext);
    STDMETHODIMP CommandBMOVE(LPCSTR pszSourceCollection, LPHTTPTARGETLIST pBatchTargets, LPCSTR pszDestCollection, LPHTTPTARGETLIST pBatchDests, BOOL fAllowRename, DWORD dwContext);
    STDMETHODIMP MemberInfo(LPCSTR pszPath, MEMBERINFOFLAGS flags, DWORD dwDepth, BOOL fIncludeRoot, DWORD dwContext);
    STDMETHODIMP FindFolders(LPCSTR pszPath, DWORD dwContext);
    STDMETHODIMP MarkRead(LPCSTR pszPath, LPHTTPTARGETLIST pTargets, BOOL fMarkRead, DWORD dwContext);
    STDMETHODIMP SendMessage(LPCSTR pszPath, LPCSTR pszFrom, LPHTTPTARGETLIST pTargets, BOOL fSaveInSent, IStream *pMessageStream, DWORD dwContext);
    STDMETHODIMP ListContacts(LPCSTR pszPath, DWORD dwContext);
    STDMETHODIMP ListContactInfos(LPCSTR pszCollectionPath, DWORD dwContext);
    STDMETHODIMP ContactInfo(LPCSTR pszPath, DWORD dwContext);
    STDMETHODIMP PostContact(LPCSTR pszPath, LPHTTPCONTACTINFO pciInfo, DWORD dwContext);
    STDMETHODIMP PatchContact(LPCSTR pszPath, LPHTTPCONTACTINFO pciInfo, DWORD dwContext);

    // ----------------------------------------------------------------------------
    // IXMLNodeFactory methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP NotifyEvent(IXMLNodeSource* pSource, XML_NODEFACTORY_EVENT iEvt);
    STDMETHODIMP BeginChildren(IXMLNodeSource* pSource, XML_NODE_INFO *pNodeInfo);   
    STDMETHODIMP EndChildren(IXMLNodeSource* pSource, BOOL fEmpty, XML_NODE_INFO *pNodeInfo);
    STDMETHODIMP Error(IXMLNodeSource* pSource, HRESULT hrErrorCode, USHORT cNumRecs, XML_NODE_INFO** apNodeInfo);
    STDMETHODIMP CreateNode(
                        IXMLNodeSource* pSource, 
                        PVOID pNodeParent,
                        USHORT cNumRecs,
                        XML_NODE_INFO** apNodeInfo);

    // ----------------------------------------------------------------------------
    // IHTTPMailTransport2 methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP RootMemberInfo( LPCSTR pszPath, MEMBERINFOFLAGS flags, DWORD dwDepth,
                                 BOOL fIncludeRoot, DWORD dwContext, LPSTR pszRootTimeStamp,
                                 LPSTR pszInboxTimeStamp);
        
    STDMETHODIMP FolderMemberInfo( LPCSTR pszPath, MEMBERINFOFLAGS flags, DWORD dwDepth, BOOL fIncludeRoot,
                                        DWORD dwContext, LPSTR pszFolderTimeStamp, LPSTR pszFolderName);


    // ----------------------------------------------------------------------------
    // New API
    // ----------------------------------------------------------------------------
    HRESULT     HrConnectToHost(LPSTR pszHostName, INTERNET_PORT nPort, LPSTR pszUserName, LPSTR pszPassword);
    HRESULT     DoLogonPrompt(void);
    HRESULT     DoGetParentWindow(HWND *phwndParent);

    HINTERNET   GetConnection(void) { return m_hConnection; }
    LPSTR       GetServerName(void) { return m_rServer.szServerName; }
    LPSTR       GetUserName(void) { return ('/0' == m_rServer.szUserName[0]) ? NULL : m_rServer.szUserName; }
    LPSTR       GetPassword(void) { return ('/0' == m_rServer.szPassword[0]) ? NULL : m_rServer.szPassword; }

    IHTTPMailCallback* GetCallback(void) { return m_pCallback; }

    HWND        GetWindow(void) { return m_hwnd; }

    BOOL        GetHasRootProps(void) { return m_fHasRootProps; }
    void        SetHasRootProps(BOOL fHasRootProps) { m_fHasRootProps = fHasRootProps; }

    LPSTR       GetAdbar(void) { return m_rootProps.pszAdbar; }
    void        AdoptAdbar(LPSTR pszAdbar) { SafeMemFree(m_rootProps.pszAdbar); m_rootProps.pszAdbar = pszAdbar; }
    
    LPSTR       GetContacts(void) { return m_rootProps.pszContacts; }
    void        AdoptContacts(LPSTR pszContacts) { SafeMemFree(m_rootProps.pszContacts); m_rootProps.pszContacts = pszContacts; }
    
    LPSTR       GetInbox(void) { return m_rootProps.pszInbox; }
    void        AdoptInbox(LPSTR pszInbox) { SafeMemFree(m_rootProps.pszInbox); m_rootProps.pszInbox = pszInbox; }

    LPSTR       GetOutbox(void) { return m_rootProps.pszOutbox; }
    void        AdoptOutbox(LPSTR pszOutbox) { SafeMemFree(m_rootProps.pszOutbox); m_rootProps.pszOutbox = pszOutbox; }

    LPSTR       GetSendMsg(void) { return m_rootProps.pszSendMsg; }
    void        AdoptSendMsg(LPSTR pszSendMsg) { SafeMemFree(m_rootProps.pszSendMsg); m_rootProps.pszSendMsg = pszSendMsg; }

    LPSTR       GetSentItems(void) { return m_rootProps.pszSentItems; }
    void        AdoptSentItems(LPSTR pszSentItems) { SafeMemFree(m_rootProps.pszSentItems); m_rootProps.pszSentItems = pszSentItems; }
    
    LPSTR       GetDeletedItems(void) { return m_rootProps.pszDeletedItems; }
    void        AdoptDeletedItems(LPSTR pszDeletedItems) { SafeMemFree(m_rootProps.pszDeletedItems); m_rootProps.pszDeletedItems = pszDeletedItems; }
    
    LPSTR       GetDrafts(void) { return m_rootProps.pszDrafts; }
    void        AdoptDrafts(LPSTR pszDrafts) { SafeMemFree(m_rootProps.pszDrafts); m_rootProps.pszDrafts = pszDrafts; }
    
    LPSTR       GetMsgFolderRoot(void) { return m_rootProps.pszMsgFolderRoot; }
    void        AdoptMsgFolderRoot(LPSTR pszMsgFolderRoot) { SafeMemFree(m_rootProps.pszMsgFolderRoot); m_rootProps.pszMsgFolderRoot = pszMsgFolderRoot; }

    LPSTR       GetSig(void) { return m_rootProps.pszSig; }
    void        AdoptSig(LPSTR pszSig) { SafeMemFree(m_rootProps.pszSig); m_rootProps.pszSig = pszSig; }

    BOOL        WasAborted(void) { return m_op.fAborted; }

private:
    // ----------------------------------------------------------------------------
    // CHTTPMailTransport private implementation
    // ----------------------------------------------------------------------------
public:

    // Translate an HTTPCOMMAND constant into a string
    LPSTR CommandToVerb(HTTPMAILCOMMAND command);

private:
    HRESULT UpdateLogonInfo(void);

    HRESULT GetParentWindow(HWND *phwndParent);

    BOOL ReadBytes(LPSTR pszBuffer, DWORD cbBufferSize, DWORD *pcbBytesRead);

    BOOL _GetStatusCode(DWORD *pdw);
    BOOL _GetContentLength(DWORD *pdw);

    HRESULT _GetRequestHeader(LPSTR *ppszHeader, DWORD dwHeader);
    HRESULT _AddRequestHeader(LPCSTR pszHeader);
    HRESULT _MemberInfo2(LPCSTR pszPath, MEMBERINFOFLAGS   flags, DWORD  dwDepth,
                         BOOL   fIncludeRoot, DWORD dwContext, LPHTTPQUEUEDOP  *ppOp);
    HRESULT _HrParseAndCopy(LPCSTR pszToken, LPSTR *ppszDest, LPSTR lpszSrc);
    HRESULT _HrGetTimestampHeader(LPSTR *ppszHeader);


    BOOL _AuthCurrentRequest(DWORD dwStatus, BOOL fRetryAuth);

    void _LogRequest(LPVOID pvData, DWORD cbData);
    void _LogResponse(LPVOID pvData, DWORD cbData);

    HRESULT QueueGetPropOperation(HTTPMAILPROPTYPE type);

    // ----------------------------------------------------------------------------
    // Element Parsing
    // ----------------------------------------------------------------------------
    BOOL StackTop(HMELE hmEle) { return (m_op.dwStackDepth < ELE_STACK_CAPACITY) && (m_op.rgEleStack[m_op.dwStackDepth - 1].ele == hmEle); }
    BOOL ValidStack(const HMELE *prgEle, DWORD cEle);
    BOOL InValidElementChildren(void) { return ((m_op.dwStackDepth > 0) && (m_op.dwStackDepth <= ELE_STACK_CAPACITY) && (m_op.rgEleStack[m_op.dwStackDepth - 1].fBeganChildren)); }
    void PopNamespaces(CXMLNamespace *pBaseNamespace);
    HRESULT PushNamespaces(XML_NODE_INFO** apNodeInfo, USHORT cNumRecs);

    HRESULT StrNToBoolW(const WCHAR *pwcText, ULONG ulLen, BOOL *pb);
    HRESULT StatusStrNToIxpHr(const WCHAR *pwcText, DWORD ulLen, HRESULT *hr);
    HRESULT AllocStrFromStrNW(const WCHAR *pwcText, ULONG ulLen, LPSTR *ppszAlloc);
    HRESULT StrNToDwordW(const WCHAR *pwcText, ULONG ulLen, DWORD *pi);
    HRESULT StrNToSpecialFolderW(const WCHAR *pwcText, ULONG ulLen, HTTPMAILSPECIALFOLDER *ptySpecial);
    HRESULT StrNToContactTypeW(const WCHAR *pwcText, ULONG ulLen, HTTPMAILCONTACTTYPE *ptyContact);

    // ----------------------------------------------------------------------------
    // Misc.
    // ----------------------------------------------------------------------------
    // ----------------------------------------------------------------------------
    // Queue Management
    // ----------------------------------------------------------------------------
    HRESULT AllocQueuedOperation(
                        LPCSTR pszUrl, 
                        LPVOID pvData, 
                        ULONG cbDataLen,
                        LPHTTPQUEUEDOP *ppOp,
                        BOOL fAdoptData = FALSE);
    void QueueOperation(LPHTTPQUEUEDOP pOp);
    BOOL DequeueNextOperation(void);

    void FlushQueue(void);
    void TerminateIOThread(void);

    BOOL IsTerminating(void)
    {
        BOOL fResult;

        EnterCriticalSection(&m_cs);
        fResult = m_fTerminating;
        LeaveCriticalSection(&m_cs);

        return fResult;
    }

    // Thread Entry Proxy
    static DWORD CALLBACK IOThreadFuncProxy(PVOID pv);

    DWORD IOThreadFunc();

    // Window Proc
    static LRESULT CALLBACK WndProc(
                    HWND hwnd, 
                    UINT msg, 
                    WPARAM wParam, 
                    LPARAM lParam);

    HRESULT HrReadCompleted(void);

    // Reset the transport object
    void Reset(void);

    // Create a window handle for messaging between the client and i/o thread
    BOOL CreateWnd(void);

    // WinInet callback (proxies through StatusCallbackProxy)
    void OnStatusCallback(
                    HINTERNET hInternet,
                    DWORD dwInternetStatus,
                    LPVOID pvStatusInformation,
                    DWORD dwStatusInformationLength);

    // thunks the response to the calling thread
    HRESULT _HrThunkConnectionError(void);
    HRESULT _HrThunkConnectionError(DWORD dwStatus);
    HRESULT _HrThunkResponse(BOOL fDone);
    
    HRESULT InvokeResponseCallback(void);

    // Translate a WinInet status message to an IXPSTATUS message.
    // Returns true if the status was translated.
    BOOL TranslateWinInetMsg(DWORD dwInternetStatus, IXPSTATUS *pIxpStatus);
    
    // WinInet callback proxy, which calls through to non-static
    // OnStatusCallback method
    static void StatusCallbackProxy(
                    HINTERNET hInternet, 
                    DWORD dwContext, 
                    DWORD dwInternetStatus, 
                    LPVOID pvStatusInformation,
                    DWORD dwStatusInformationLength);

    // ----------------------------------------------------------------------------
    // Response Management
    // ----------------------------------------------------------------------------
    void FreeMemberInfoList(void);
    void FreeMemberErrorList();
    void FreeContactIdList(void);
    void FreeContactInfoList(void);
    void FreeBCopyMoveList(void);

    // ----------------------------------------------------------------------------
    // State Machine Functions
    // ----------------------------------------------------------------------------
    void DoOperation(void);
    void FreeOperation(void);

    // ----------------------------------------------------------------------------
    // Parser Utils
    // ----------------------------------------------------------------------------
private:
    HRESULT _BindToStruct(const WCHAR *pwcText,
                          ULONG ulLen,
                          const XPCOLUMN *prgCols,
                          DWORD cCols,
                          LPVOID pTarget,
                          BOOL *pfWasBound);

    void _FreeStruct(const XPCOLUMN *prgCols,
                     DWORD cCols,
                     LPVOID pTarget,
                     DWORD *pdwFlags);

    HRESULT _GetTextBuffer(LPPCDATABUFFER *ppTextBuffer)
    {
        if (m_op.pTextBuffer)
        {
            *ppTextBuffer = m_op.pTextBuffer;
            m_op.pTextBuffer = NULL;
            return S_OK;
        }
        else
            return _AllocTextBuffer(ppTextBuffer);
    }

    HRESULT _AppendTextToBuffer(LPPCDATABUFFER pTextBuffer, const WCHAR *pwcText, ULONG ulLen);
    HRESULT _AllocTextBuffer(LPPCDATABUFFER *ppTextBuffer);
    void _ReleaseTextBuffer(LPPCDATABUFFER pTextBuffer)
    {
        IxpAssert(NULL != pTextBuffer);

        // if the buffer capacity is the original byte count, and there is
        // no buffer in the cache, then return this one to the cache
        if (NULL == m_op.pTextBuffer && PCDATA_BUFSIZE == pTextBuffer->ulCapacity)
        {
            pTextBuffer->ulLen = 0;
            m_op.pTextBuffer = pTextBuffer;
        }
        else
            _FreeTextBuffer(pTextBuffer);
    }

    void _FreeTextBuffer(LPPCDATABUFFER pTextBuffer);
    
public:
        // common states
    HRESULT OpenRequest(void);
    HRESULT SendRequest(void);
    HRESULT AddCommonHeaders(void);
    HRESULT RequireMultiStatus(void);
    HRESULT FinalizeRequest(void);
    HRESULT AddCharsetLine(void);

        // GET states
    HRESULT ProcessGetResponse(void);
        
        // POST states
    HRESULT AddContentTypeHeader(void);
    HRESULT SendPostRequest(void);
    HRESULT ProcessPostResponse(void);

        // XML processing
    HRESULT ProcessXMLResponse(void);

        // PROPFIND states
    HRESULT GeneratePropFindXML(void);
    HRESULT AddDepthHeader(void);

        // PROPPATCH states
    HRESULT GeneratePropPatchXML(void);

        // MKCOL states
    HRESULT ProcessCreatedResponse(void);

        // COPY and MOVE states
    HRESULT AddDestinationHeader(void);
    HRESULT ProcessLocationResponse(void);

        // BCOPY and BMOVE states
    HRESULT InitBCopyMove(void);

        // RootProp states
    HRESULT InitRootProps(void);
    HRESULT FinalizeRootProps(void);

        // MemberInfo states
    HRESULT InitMemberInfo(void);

        // MemberError states
    HRESULT InitMemberError(void);

        // ListContacts
    HRESULT InitListContacts(void);

        // ContactInfo
    HRESULT InitContactInfo(void);
        
        // PostContact
    HRESULT ProcessPostContactResponse(void);

        // PatchContact
    HRESULT ProcessPatchContactResponse(void);

    // ----------------------------------------------------------------------------
    // XML Parsing Functions
    // ----------------------------------------------------------------------------
    HRESULT CreateElement(CXMLNamespace *pBaseNamespace, const WCHAR *pwcText, ULONG ulLen, ULONG ulNamespaceLen, BOOL fTerminal);
    HRESULT EndChildren(void);

        // BCOPY and BMOVE
    HRESULT BCopyMove_HandleText(const WCHAR *pwcText, ULONG ulLen);
    HRESULT BCopyMove_EndChildren(void);

        // PropFind
    HRESULT PropFind_HandleText(const WCHAR *pwcText, ULONG ulLen);

        // RootProps
    HRESULT RootProps_HandleText(const WCHAR *pwcText, ULONG ulLen);
    HRESULT RootProps_EndChildren(void);

        // MemberInfo
    HRESULT MemberInfo_HandleText(const WCHAR *pwcText, ULONG ulLen);
    HRESULT MemberInfo_EndChildren(void);

        // MemberError
    HRESULT MemberError_HandleText(const WCHAR *pwcText, ULONG ulLen);
    HRESULT MemberError_EndChildren(void);

        // ListContacts
    HRESULT ListContacts_HandleText(const WCHAR *pwcText, ULONG ulLen);
    HRESULT ListContacts_EndChildren(void);

        // ContactInfo
    HRESULT ContactInfo_HandleText(const WCHAR *pwcText, ULONG ulLen);
    HRESULT ContactInfo_EndChildren(void);

        // PostContact and PatchContact
    HRESULT PostOrPatchContact_HandleText(const WCHAR *pwcText, ULONG ulLen);
    HRESULT PostOrPatchContact_EndChildren(void);

public:
    HRESULT _CreateXMLParser(void);
};

#endif // __IXPHTTPM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\ixppop3.h ===
// --------------------------------------------------------------------------------
// Ixppop3.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __IXPPOP3_H
#define __IXPPOP3_H

// ------------------------------------------------------------------------------------
// Depends
// ------------------------------------------------------------------------------------
#include "ixpbase.h"
#include "asynconn.h"
#include "sicily.h"

// ------------------------------------------------------------------------------------
// AUTHSTATE
// ------------------------------------------------------------------------------------
typedef enum {
    AUTH_NONE,
    AUTH_ENUMPACKS,
    AUTH_ENUMPACKS_DATA,
    AUTH_TRYING_PACKAGE,
    AUTH_NEGO_RESP,
    AUTH_RESP_RESP,
    AUTH_CANCELED,
    AUTH_SMTP_LOGIN,
    AUTH_SMTP_LOGIN_USERNAME,
    AUTH_SMTP_LOGIN_PASSWORD
} AUTHSTATE;

// ------------------------------------------------------------------------------------
// UIDLTYPE
// ------------------------------------------------------------------------------------
typedef enum {
    UIDL_NONE,
    UIDL_BY_UIDL,
    UIDL_BY_TOP
} UIDLTYPE;

// ------------------------------------------------------------------------------------
// FETCHINFO
// ------------------------------------------------------------------------------------
typedef struct tagFETCHINFO {
    DWORD               cbSoFar;        // Number of bytes downloaded so far
    BOOL                fLastLineCRLF;  // Last line ended with a CRLF
    BOOL                fGotResponse;   // First response after issuing the POP3_TOP or POP3_RETR command
    BOOL                fHeader;        // Header has been downloaded
    BOOL                fBody;          // Body has been downloaded
} FETCHINFO, *LPFETCHINFO;

#define MAX_AUTH_TOKENS 32

// ------------------------------------------------------------------------------------
// AUTHINFO
// ------------------------------------------------------------------------------------
typedef struct tagAUTHINFO {
    AUTHSTATE           authstate;      // Sicily Authorization State
    BOOL                fRetryPackage;  // Retry sicily package with differenty isc flags
    SSPICONTEXT         rSicInfo;       // Data used for logging onto a sicily server
    LPSTR               rgpszAuthTokens[MAX_AUTH_TOKENS];  // AUTH security package tokens
    UINT                cAuthToken;     // count of server packages
    UINT                iAuthToken;     // current package being tried
    LPSSPIPACKAGE       pPackages;      // Array of installed security packages
    ULONG               cPackages;      // Number of installed security packages (pPackages)
} AUTHINFO, *LPAUTHINFO;

void FreeAuthInfo(LPAUTHINFO pAuth);

// ------------------------------------------------------------------------------------
// POP3INFO
// ------------------------------------------------------------------------------------
typedef struct tagPOP3INFO {
    BOOL                fStatDone;      // Has the stat command been issued on this session
    DWORD               cList;          // Number of messages listed in the full UIDL or LIST command
    DWORD               cMarked;        // Number of messages in the prgMarked array, set after STAT is issued
    LPDWORD             prgMarked;      // Array of marked messages 
    FETCHINFO           rFetch;         // Information for the POP3_TOP or POP3_RETR command
    AUTHINFO            rAuth;          // Sicily Authorization Information
    POP3CMDTYPE         cmdtype;        // Current command type
    ULONG               cPreviewLines;  // Number of lines to retrieve on the preview command
    DWORD               dwPopIdCurrent; // Current PopId
} POP3INFO, *LPPOP3INFO;

// ------------------------------------------------------------------------------------
// CPOP3Transport
// ------------------------------------------------------------------------------------
class CPOP3Transport : public IPOP3Transport, public CIxpBase
{
private:
    POP3INFO            m_rInfo;         // Structure containing pop3 information
    POP3COMMAND         m_command;       // Current state
    BYTE                m_fHotmail;      // Are we connected to hotmail ?

private:
    // Processes POP3 command responses
    HRESULT HrGetResponse(void);
    void FillRetrieveResponse(LPPOP3RESPONSE pResponse, LPSTR pszLines, ULONG cbRead, BOOL *pfMessageDone);

    // Response Dispatcher for general command
    void DispatchResponse(HRESULT hrResult, BOOL fDone=TRUE, LPPOP3RESPONSE pResponse=NULL);

    // Sends sicily data to the server
    HRESULT HrSendSicilyString(LPSTR pszData);

    // Build parameterized command
    HRESULT HrBuildParams(POP3CMDTYPE cmdtype, DWORD dwp1, DWORD dwp2);

    // Frees the current message array
    void FreeMessageArray(void);

    // Logon retry
    void LogonRetry(HRESULT hrLogon);

    // Socket data receive handler
    void OnSocketReceive(void);

    // Initiates the logon process
    void StartLogon(void);

    // Response Handler
    void ResponseAUTH(HRESULT hrResponse);
    void ResponseSTAT(void); 
    void ResponseGenericList(void);
    void ResponseGenericRetrieve(void);
    void ResponseDELE(void);

    // Issues a parameterized command
    DWORD   DwGetCommandMarkedFlag(POP3COMMAND command);
    ULONG   CountMarked(POP3COMMAND command);
    HRESULT HrCommandGetPopId(POP3COMMAND command, DWORD dwPopId);
    HRESULT HrSplitPop3Response(LPSTR pszLine, LPSTR *ppszPart1, LPSTR *ppszPart2);
    HRESULT HrComplexCommand(POP3COMMAND command, POP3CMDTYPE cmdtype, DWORD dwPopId, ULONG cPreviewLines);
    HRESULT HrCommandGetNext(POP3COMMAND command, BOOL *pfDone);
    HRESULT HrCommandGetAll(POP3COMMAND command);
    BOOL    FEndRetrRecvHeader(LPSTR pszLines, ULONG cbRead);
    HRESULT HrCancelAuthInProg();
    
    // Moved to ixputil.cpp
    // BOOL    FEndRetrRecvBody(LPSTR pszLines, ULONG cbRead, ULONG *pcbSubtract);


public:                          
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CPOP3Transport(void);
    ~CPOP3Transport(void);

    // ----------------------------------------------------------------------------
    // IUnknown methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IAsyncConnCB methods
    // ----------------------------------------------------------------------------
    void OnNotify(ASYNCSTATE asOld, ASYNCSTATE asNew, ASYNCEVENT ae);

    // ----------------------------------------------------------------------------
    // IInternetTransport methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP InitNew(LPSTR pszLogFilePath, IPOP3Callback *pCallback);
    STDMETHODIMP Connect(LPINETSERVER pInetServer, boolean fAuthenticate, boolean fCommandLogging);
    STDMETHODIMP DropConnection(void);
    STDMETHODIMP Disconnect(void);
    STDMETHODIMP IsState(IXPISSTATE isstate);
    STDMETHODIMP GetServerInfo(LPINETSERVER pInetServer);
    STDMETHODIMP_(IXPTYPE) GetIXPType(void);
    STDMETHODIMP InetServerFromAccount(IImnAccount *pAccount, LPINETSERVER pInetServer);
    STDMETHODIMP HandsOffCallback(void);
    STDMETHODIMP GetStatus(IXPSTATUS *pCurrentStatus);

    // ----------------------------------------------------------------------------
    // IPOP3Transport methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP MarkItem(POP3MARKTYPE marktype, DWORD dwPopId, boolean fMarked);
    STDMETHODIMP CommandAUTH(LPSTR pszAuthType);
    STDMETHODIMP CommandUSER(LPSTR pszUserName);
    STDMETHODIMP CommandPASS(LPSTR pszPassword);
    STDMETHODIMP CommandLIST(POP3CMDTYPE cmdtype, DWORD dwPopId);
    STDMETHODIMP CommandTOP (POP3CMDTYPE cmdtype, DWORD dwPopId, DWORD cPreviewLines);
    STDMETHODIMP CommandUIDL(POP3CMDTYPE cmdtype, DWORD dwPopId);
    STDMETHODIMP CommandDELE(POP3CMDTYPE cmdtype, DWORD dwPopId);
    STDMETHODIMP CommandRETR(POP3CMDTYPE cmdtype, DWORD dwPopId);
    STDMETHODIMP CommandRSET(void);
    STDMETHODIMP CommandQUIT(void);
    STDMETHODIMP CommandSTAT(void);
    STDMETHODIMP CommandNOOP(void);

    // ----------------------------------------------------------------------------
    // CIxpBase methods
    // ----------------------------------------------------------------------------
    virtual void ResetBase(void);
    virtual void DoQuit(void);
    virtual void OnConnected(void);
    virtual void OnDisconnected(void);
    virtual void OnEnterBusy(void);
    virtual void OnLeaveBusy(void);
};

#endif // __IXPPOP3_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\ixpnntp.cpp ===
// --------------------------------------------------------------------------------
// Ixpnntp.cpp
// Copyright (c)1993-1996 Microsoft Corporation, All Rights Reserved
//
// Eric Andrews
// Steve Serdy
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include <stdio.h>
#include "ixpnntp.h"
#include "asynconn.h"
#include "ixputil.h"
#include "strconst.h"
#include "resource.h"
#include <shlwapi.h>
#include "demand.h"

// --------------------------------------------------------------------------------
// Some handle macros for simple pointer casting
// --------------------------------------------------------------------------------
#define NNTPTHISIXP         ((INNTPTransport *)(CIxpBase *) this)

#define NUM_HEADERS         100

CNNTPTransport::CNNTPTransport(void) : CIxpBase(IXP_NNTP)
    {
    ZeroMemory(&m_rMessage, sizeof(m_rMessage));
    ZeroMemory(&m_sicinfo, sizeof(SSPICONTEXT));

    DllAddRef();

    m_substate = NS_RESP;
    }

CNNTPTransport::~CNNTPTransport(void)
    {
    SafeRelease(m_rMessage.pstmMsg);
    DllRelease();
    }


// --------------------------------------------------------------------------------
// CNNTPTransport::QueryInterface
// --------------------------------------------------------------------------------
HRESULT CNNTPTransport::QueryInterface(REFIID riid, LPVOID *ppv)
    {
    // Locals
    HRESULT hr=S_OK;

    // Bad param
    if (ppv == NULL)
        {
        hr = TrapError(E_INVALIDARG);
        goto exit;
        }

    // Init
    *ppv=NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = ((IUnknown *)(INNTPTransport *)this);

    // IID_IInternetTransport
    else if (IID_IInternetTransport == riid)
        *ppv = ((IInternetTransport *)(CIxpBase *)this);

    // IID_INNTPTransport
    else if (IID_INNTPTransport == riid)
        *ppv = (INNTPTransport *)this;

    // IID_INNTPTransport2
    else if (IID_INNTPTransport2 == riid)
        *ppv = (INNTPTransport2 *)this;

    // If not null, addref it and return
    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
        }

    // No Interface
    hr = TrapError(E_NOINTERFACE);

exit:
    // Done
    return hr;
    }

// --------------------------------------------------------------------------------
// CNNTPTransport::AddRef
// --------------------------------------------------------------------------------
ULONG CNNTPTransport::AddRef(void) 
    {
    return ++m_cRef;
    }

// --------------------------------------------------------------------------------
// CNNTPTransport::Release
// --------------------------------------------------------------------------------
ULONG CNNTPTransport::Release(void) 
    {
    if (0 != --m_cRef)
        return m_cRef;

    delete this;
    return 0;
    }   

//
//  FUNCTION:   CNNTPTransport::OnNotify()
//
//  PURPOSE:    This function get's called whenever the CAsyncConn class 
//              sends or receives data.
//
//  PARAMETERS:
//      asOld   - State of the connection before this event
//      asNew   - State of the connection after this event
//      ae      - Identifies the event that has occured
//
void CNNTPTransport::OnNotify(ASYNCSTATE asOld, ASYNCSTATE asNew, ASYNCEVENT ae)
    {
    // Enter Critical Section
    EnterCriticalSection(&m_cs);

    // Handle Event
    switch(ae)
        {
        case AE_RECV:
            OnSocketReceive();
            break;

        case AE_SENDDONE:
            if (m_substate == NS_SEND_ENDPOST)
                {
                HrSendCommand((LPSTR) NNTP_ENDPOST, NULL, FALSE);
                m_substate = NS_ENDPOST_RESP;
                }
            break;

        case AE_LOOKUPDONE:
            if (AS_DISCONNECTED == asNew)
            {
                DispatchResponse(IXP_E_CANT_FIND_HOST, TRUE);
                OnDisconnected();
            }
            else
                OnStatus(IXP_CONNECTING);
            break;

        // --------------------------------------------------------------------------------
        case AE_CONNECTDONE:
            if (AS_DISCONNECTED == asNew)
            {
                DispatchResponse(IXP_E_FAILED_TO_CONNECT, TRUE);
                OnDisconnected();
            }
            else if (AS_HANDSHAKING == asNew)
            {
                OnStatus(IXP_SECURING);
            }
            else
                OnConnected();
            break;

        // --------------------------------------------------------------------------------
        case AE_CLOSE:
            if (AS_RECONNECTING != asNew && IXP_AUTHRETRY != m_status)
            {
                if (IXP_DISCONNECTING != m_status && IXP_DISCONNECTED  != m_status)
                {
                    if (AS_HANDSHAKING == asOld)
                        DispatchResponse(IXP_E_SECURE_CONNECT_FAILED, TRUE);
                    else
                        DispatchResponse(IXP_E_CONNECTION_DROPPED, TRUE);
                }
                OnDisconnected();
            }
            break;

        default:
            CIxpBase::OnNotify(asOld, asNew, ae);
            break;
        }

    // Leave Critical Section
    LeaveCriticalSection(&m_cs);
    }


//
//  FUNCTION:   CNNTPTransport::InitNew()
//
//  PURPOSE:    The client calls this to specify a callback interface and a log
//              file path if desired.
//
//  PARAMETERS:
//      pszLogFilePath - Path to the file to write logging info to.
//      pCallback      - Pointer to the callback interface to send results etc
//                       to.
//
//  RETURN VALUE:
//      HRESULT
//
HRESULT CNNTPTransport::InitNew(LPSTR pszLogFilePath, INNTPCallback *pCallback)
    {
    // Let the base class handle the rest
    return (CIxpBase::OnInitNew("NNTP", pszLogFilePath, FILE_SHARE_READ | FILE_SHARE_WRITE,
        (ITransportCallback *) pCallback));
    }

// --------------------------------------------------------------------------------
// CNNTPTransport::HandsOffCallback
// --------------------------------------------------------------------------------
STDMETHODIMP CNNTPTransport::HandsOffCallback(void)
    {
    return CIxpBase::HandsOffCallback();
    }

// --------------------------------------------------------------------------------
// CNNTPTransport::GetStatus
// --------------------------------------------------------------------------------
STDMETHODIMP CNNTPTransport::GetStatus(IXPSTATUS *pCurrentStatus)
    {
    return CIxpBase::GetStatus(pCurrentStatus);
    }

// --------------------------------------------------------------------------------
// CNNTPTransport::InetServerFromAccount
// --------------------------------------------------------------------------------
STDMETHODIMP CNNTPTransport::InetServerFromAccount(IImnAccount *pAccount, LPINETSERVER pInetServer)
    {
    return CIxpBase::InetServerFromAccount(pAccount, pInetServer);
    }

// --------------------------------------------------------------------------------
// CNNTPTransport::Connect
// --------------------------------------------------------------------------------
HRESULT CNNTPTransport::Connect(LPINETSERVER pInetServer, boolean fAuthenticate, 
                                boolean fCommandLogging)
    {
    // Does user want us to always prompt for his password? Prompt him here to avoid
    // inactivity timeouts while the prompt is up, unless a password was supplied
    if (ISFLAGSET(pInetServer->dwFlags, ISF_ALWAYSPROMPTFORPASSWORD) &&
        '\0' == pInetServer->szPassword[0])
        {
        HRESULT hr;

        if (NULL != m_pCallback)
            hr = m_pCallback->OnLogonPrompt(pInetServer, NNTPTHISIXP);

        if (NULL == m_pCallback || S_OK != hr)
            return IXP_E_USER_CANCEL;
        }

    return CIxpBase::Connect(pInetServer, fAuthenticate, fCommandLogging);
    }

// --------------------------------------------------------------------------------
// CNNTPTransport::DropConnection
// --------------------------------------------------------------------------------
HRESULT CNNTPTransport::DropConnection(void)
    {
    return CIxpBase::DropConnection();
    }

// --------------------------------------------------------------------------------
// CNNTPTransport::Disconnect
// --------------------------------------------------------------------------------
HRESULT CNNTPTransport::Disconnect(void)
    {
    HRESULT hr = S_OK;

    if (SUCCEEDED(hr = CIxpBase::Disconnect()))
        {
        m_state = NS_DISCONNECTED;
        m_pSocket->Close();
        }

    return (hr);
    }

// --------------------------------------------------------------------------------
// CNNTPTransport::IsState
// --------------------------------------------------------------------------------
HRESULT CNNTPTransport::IsState(IXPISSTATE isstate)
    {
    return CIxpBase::IsState(isstate);
    }

// --------------------------------------------------------------------------------
// CNNTPTransport::GetServerInfo
// --------------------------------------------------------------------------------
HRESULT CNNTPTransport::GetServerInfo(LPINETSERVER pInetServer)
    {
    return CIxpBase::GetServerInfo(pInetServer);
    }

// --------------------------------------------------------------------------------
// CNNTPTransport::GetIXPType
// --------------------------------------------------------------------------------
IXPTYPE CNNTPTransport::GetIXPType(void)
    {
    return IXP_NNTP;
    }


// --------------------------------------------------------------------------------
// CNNTPTransport::ResetBase
// --------------------------------------------------------------------------------
void CNNTPTransport::ResetBase(void)
    {
    EnterCriticalSection(&m_cs);
    
    if (m_substate != NS_RECONNECTING)
        {
        m_state = NS_DISCONNECTED;
        m_substate = NS_RESP;
        m_fSupportsXRef = FALSE;
        m_rgHeaders = 0;
        m_pMemInfo = 0;

        if (m_sicinfo.pCallback)
            SSPIFreeContext(&m_sicinfo);

        ZeroMemory(&m_sicinfo, sizeof(m_sicinfo));
        m_cSecPkg = -1;                 // number of sec pkgs to try, -1 if not inited
        m_iSecPkg = -1;                 // current sec pkg being tried
        m_iAuthType = AUTHINFO_NONE;
        ZeroMemory(m_rgszSecPkg, sizeof(m_rgszSecPkg)); // array of pointers into m_szSecPkgs
        m_szSecPkgs = NULL;             // string returned by "AUTHINFO TRANSACT TWINKIE"
        m_fRetryPkg = FALSE;
        m_pAuthInfo = NULL;
        m_fNoXover = FALSE;
        }
    
    LeaveCriticalSection(&m_cs);
    }

// ------------------------------------------------------------------------------------
// CNNTPTransport::DoQuit
// ------------------------------------------------------------------------------------
void CNNTPTransport::DoQuit(void)
    {
    CommandQUIT();
    }


// --------------------------------------------------------------------------------
// CNNTPTransport::OnConnected
// --------------------------------------------------------------------------------
void CNNTPTransport::OnConnected(void)
    {
    m_state = NS_CONNECT;
    m_substate = NS_CONNECT_RESP;
    CIxpBase::OnConnected();
    }

// --------------------------------------------------------------------------------
// CNNTPTransport::OnDisconnect
// --------------------------------------------------------------------------------
void CNNTPTransport::OnDisconnected(void)
    {
    ResetBase();
    CIxpBase::OnDisconnected();
    }

// --------------------------------------------------------------------------------
// CNNTPTransport::OnEnterBusy
// --------------------------------------------------------------------------------
void CNNTPTransport::OnEnterBusy(void)
    {
    IxpAssert(m_state == NS_IDLE);
    }

// --------------------------------------------------------------------------------
// CNNTPTransport::OnLeaveBusy
// --------------------------------------------------------------------------------
void CNNTPTransport::OnLeaveBusy(void)
    {
    m_state = NS_IDLE;
    }


//
//  FUNCTION:   CNNTPTransport::OnSocketReceive()
//
//  PURPOSE:    This function reads the data off the socket and parses that 
//              information based on the current state of the transport.
//
void CNNTPTransport::OnSocketReceive(void)
    {
    HRESULT hr;
    UINT    uiResp;

    EnterCriticalSection(&m_cs);

    // Handle the current NNTP State
    switch (m_state)
        {
        case NS_CONNECT:
            {
            HandleConnectResponse();
            break;
            }

        case NS_AUTHINFO:
            {
            HandleConnectResponse();
            break;
            }

        case NS_NEWGROUPS:
            {
            // If we're waiting for the original response line then get it and
            // parse it here
            if (NS_RESP == m_substate)
                {
                if (FAILED(hr = HrGetResponse()))
                    goto exit;
                
                // If the command failed, inform the user and exit
                if (IXP_NNTP_NEWNEWSGROUPS_FOLLOWS != m_uiResponse)
                    {
                    hr = IXP_E_NNTP_NEWGROUPS_FAILED;
                    DispatchResponse(hr, TRUE);
                    break;
                    }

                // Advance the substate to data receive
                m_substate = NS_DATA;
                }

            // Process the returned data
            ProcessListData();
            break;
            }

        case NS_LIST:
            {
            // If we're waiting for the original response line then get it and
            // parse it here.
            if (NS_RESP == m_substate)
                {
                if (FAILED(hr = HrGetResponse()))
                    goto exit;

                // If the command failed, inform the user and exit
                if (IXP_NNTP_LIST_DATA_FOLLOWS != m_uiResponse)
                    {
                    hr = IXP_E_NNTP_LIST_FAILED;
                    DispatchResponse(hr, TRUE);
                    break;
                    }

                // Advance the substate to data recieve
                m_substate = NS_DATA;
                }

            // Start processing the data retrieved from the command
            ProcessListData();
            break;
            }

        case NS_LISTGROUP:
            {
            if (NS_RESP == m_substate)
                {
                if (FAILED(hr = HrGetResponse()))
                    goto exit;

                if (IXP_NNTP_GROUP_SELECTED != m_uiResponse)
                    {
                    hr = IXP_E_NNTP_LISTGROUP_FAILED;
                    DispatchResponse(hr, TRUE);
                    break;
                    }

                m_substate = NS_DATA;
                }

            ProcessListGroupData();
            break;
            }

        case NS_GROUP:
            if (FAILED(hr = HrGetResponse()))
                goto exit;

            ProcessGroupResponse();
            break;

        case NS_ARTICLE:
            {
            if (NS_RESP == m_substate)
                {
                if (FAILED(hr = HrGetResponse()))
                    goto exit;
                
                if (IXP_NNTP_ARTICLE_FOLLOWS != m_uiResponse)
                    {
                    hr = IXP_E_NNTP_ARTICLE_FAILED;
                    DispatchResponse(hr, TRUE);
                    break;
                    }

                m_substate = NS_DATA;
                }

            ProcessArticleData();
            break;
            }

        case NS_HEAD:
            {
            if (NS_RESP == m_substate)
                {
                if (FAILED(hr = HrGetResponse()))
                    goto exit;

                if (IXP_NNTP_HEAD_FOLLOWS != m_uiResponse)
                    {
                    hr = IXP_E_NNTP_HEAD_FAILED;
                    DispatchResponse(hr, TRUE);
                    break;
                    }

                m_substate = NS_DATA;
                }

            ProcessArticleData();
            break;
            }

        case NS_BODY:
            {
            if (NS_RESP == m_substate)
                {
                if (FAILED(hr = HrGetResponse()))
                    goto exit;

                if (IXP_NNTP_BODY_FOLLOWS != m_uiResponse)
                    {
                    hr = IXP_E_NNTP_BODY_FAILED;
                    DispatchResponse(hr, TRUE);
                    break;
                    }

                m_substate = NS_DATA;
                }

            ProcessArticleData();
            break;
            }

        case NS_POST:
            if (NS_RESP == m_substate)
                {
                // Get the response to our post command
                if (FAILED(hr = HrGetResponse()))
                    goto exit;

                // If the response wasn't 340, then we can't post and might
                // as well bail.
                if (IXP_NNTP_SEND_ARTICLE_TO_POST != m_uiResponse)
                    {
                    hr = IXP_E_NNTP_POST_FAILED;
                    // Make sure we free up the stream
                    SafeRelease(m_rMessage.pstmMsg);
                    DispatchResponse(hr, TRUE);
                    break;
                    }

                // Send the message
                if (SUCCEEDED(hr = HrPostMessage()))
                    {
                    HrSendCommand((LPSTR) NNTP_ENDPOST, 0, FALSE);
                    m_substate = NS_ENDPOST_RESP;
                    }
                else if (IXP_E_WOULD_BLOCK == hr)
                    {
                    // We will send the crlf . crlf when we get the AE_SENDDONE
                    // notification.  This is handled in OnNotify().
                    m_substate = NS_SEND_ENDPOST;
                    }
                else
                    {
                    // Some unhandled error occured.
                    hr = IXP_E_NNTP_POST_FAILED;
                    DispatchResponse(hr, TRUE);
                    }
                }
            else if (NS_ENDPOST_RESP == m_substate)
                {
                // Here's the response from the server regarding the post.  Send
                // it off to the user.
                hr = HrGetResponse();

                if (IXP_NNTP_ARTICLE_POSTED_OK != m_uiResponse)
                    hr = IXP_E_NNTP_POST_FAILED;

                DispatchResponse(hr, TRUE);
                }            
            break;

        case NS_IDLE:
            break;

        case NS_DISCONNECTED:
            break;

        case NS_QUIT:
            if (FAILED(hr = HrGetResponse()))
                goto exit;

            DispatchResponse(S_OK, TRUE);

            // Make sure the socket closes if the server doesn't drop the 
            // connection itself.
            m_pSocket->Close();
            break;

        case NS_LAST:
            if (FAILED(hr = HrGetResponse()))
                goto exit;

            ProcessNextResponse();
            break;

        case NS_NEXT:
            if (FAILED(hr = HrGetResponse()))
                goto exit;

            ProcessNextResponse();
            break;

        case NS_STAT:
            if (FAILED(hr = HrGetResponse()))
                goto exit;

            ProcessNextResponse();
            break;

        case NS_MODE:
            // Very little to do with this response other than return it to 
            // the caller.
            if (FAILED(hr = HrGetResponse()))
                goto exit;

            DispatchResponse(S_OK);
            break;

        case NS_DATE:
            if (FAILED(hr = HrGetResponse()))
                goto exit;

            ProcessDateResponse();
            break;

        case NS_HEADERS:
            if (NS_RESP == m_substate)
                {
                // Get the response string from the socket
                if (FAILED(hr = HrGetResponse()))
                    goto exit;

                // There's a couple of things that can happen here.  First, if
                // the response is IXP_NNTP_OVERVIEW_FOLLOWS, then everything is
                // great and we can party on.  If the response is > 500, then
                // XOVER isn't supported on this server and we have to try using
                // XHDR to retrieve the headers.
                if (m_uiResponse >= 500 && m_gethdr == GETHDR_XOVER)
                    {
                    hr = BuildHeadersFromXhdr(TRUE);
                    if (FAILED(hr))
                        DispatchResponse(hr, TRUE);

                    break;
                    }
                else if (2 != (m_uiResponse / 100))
                    {
                    hr = IXP_E_NNTP_HEADERS_FAILED;
                    DispatchResponse(hr, TRUE);
                    break;
                    }

                m_substate = NS_DATA;
                }

            // Parse the returned data strings
            if (m_gethdr == GETHDR_XOVER)
                ProcessXoverData();
            else
                BuildHeadersFromXhdr(FALSE);
            break;

        case NS_XHDR:
            if (NS_RESP == m_substate)
                {
                if (FAILED(hr = HrGetResponse()))
                    goto exit;

                if (2 != (m_uiResponse / 100))
                    {
                    hr = IXP_E_NNTP_XHDR_FAILED;
                    DispatchResponse(hr, TRUE);
                    break;
                    }

                m_substate = NS_DATA;
                }

            ProcessXhdrData();
            break;

        default:
            IxpAssert(FALSE);
            break;
        }

exit:
    LeaveCriticalSection(&m_cs);
    }

HRESULT CNNTPTransport::HandleConnectResponse(void)
    {
    HRESULT hr = E_FAIL;

    IxpAssert(m_substate >= NS_CONNECT_RESP);

    switch (m_substate)
        {
        // Parse the banner and make sure we got a valid response.  If so,
        // then issue a "MODE READER" command to inform the server that we
        // are a client and not another server.
        case NS_CONNECT_RESP:
            if (SUCCEEDED(hr = HrGetResponse()))
                {
                // Make sure we got a valid response from the server
                if (IXP_NNTP_POST_ALLOWED != m_uiResponse && 
                    IXP_NNTP_POST_NOTALLOWED != m_uiResponse)
                    {
                    // If we didn't get a valid response, disconnect and inform
                    // the client that the connect failed.
                    Disconnect();
                    m_state = NS_DISCONNECTED;
                    DispatchResponse(IXP_E_NNTP_RESPONSE_ERROR, TRUE);
                    }
                else
                    {
                    // Stash the response code so if we finally connect we can
                    // return whether or not posting is allowed
                    m_hrPostingAllowed = 
                        (m_uiResponse == IXP_NNTP_POST_ALLOWED) ? S_OK : S_FALSE;

                    // Move to the next state where we issue the "MODE READER"
                    hr = HrSendCommand((LPSTR) NNTP_MODE_READER_CRLF, NULL, FALSE);
                    if (SUCCEEDED(hr))
                        {
                        m_state = NS_CONNECT;
                        m_substate = NS_MODE_READER_RESP;
                        }
                    }
                }
            break;

        // Read the response from the "MODE READER" command off the socket.  If
        // the user wants us to handle authentication, then start that.
        // Otherwise, we're done and can consider this a terminal state.
        case NS_MODE_READER_RESP:
            if (SUCCEEDED(hr = HrGetResponse()))
                {
                if (m_fConnectAuth) 
                    // This is TRUE if the user specified in the Connect() call
                    // that we should automatically logon for them.
                    StartLogon();
                else
                    {
                    // Otherwise consider ourselves ready to accept commands
                    DispatchResponse(m_hrPostingAllowed, TRUE);
                    }
                }
            break;

        // We issued an empty AUTHINFO GENERIC command to get a list of security
        // packages supported by the server.  We parse that list and continue with
        // sicily authentication.
        case NS_GENERIC_TEST:
            if (SUCCEEDED(hr = HrGetResponse()))
                {
                if (m_uiResponse == IXP_NNTP_AUTH_OK)
                    {
                    m_substate = NS_GENERIC_PKG_DATA;
                    hr = ProcessGenericTestResponse();
                    }
                else
                    {
                    // could be an old MSN server, so try AUTHINFO TRANSACT TWINKIE
                    hr = HrSendCommand((LPSTR) NNTP_TRANSACTTEST_CRLF, NULL, FALSE);
                    m_substate = NS_TRANSACT_TEST;
                    }
                }
            break;

        // We issued an empty AUTHINFO GENERIC command to get a list of security
        // packages supported by the server.  We parse that list and continue with
        // sicily authentication.
        case NS_GENERIC_PKG_DATA:
            hr = ProcessGenericTestResponse();
            break;

        // We issued a invalid AUTHINFO TRANSACT command to get a list of security
        // packages supported by the server.  We parse that list and continue with
        // sicily authentication.
        case NS_TRANSACT_TEST:
            if (SUCCEEDED(hr = HrGetResponse()))
                {
                ProcessTransactTestResponse();
                }
            break;

        // We issued a AUTHINFO {TRANSACT|GENERIC} <package name> to the server.  Parse this
        // response to see if the server understands the package.  If so, then send
        // the negotiation information, otherwise try a different security package.
        case NS_TRANSACT_PACKAGE:
            if (SUCCEEDED(hr = HrGetResponse()))
                {
                if (m_uiResponse == IXP_NNTP_PASSWORD_REQUIRED)
                    {
                    Assert(m_iAuthType != AUTHINFO_NONE);
                    if (m_iAuthType == AUTHINFO_GENERIC)
                        HrSendCommand((LPSTR) NNTP_GENERICCMD, m_sicmsg.szBuffer, FALSE);
                    else
                        HrSendCommand((LPSTR) NNTP_TRANSACTCMD, m_sicmsg.szBuffer, FALSE);
                    m_substate = NS_TRANSACT_NEGO;
                    }
                else
                    {
                    TryNextSecPkg();
                    }
                }
            break;

        // We received a response to our negotiation command.  If the response 
        // is 381, then generate a response to the server's challange.  Otherwise,
        // we disconnect and try to reconnect with the next security package.
        case NS_TRANSACT_NEGO:
            if (SUCCEEDED(hr = HrGetResponse()))
                {
                if (m_uiResponse == IXP_NNTP_PASSWORD_REQUIRED)
                    {
                    SSPIBUFFER Challenge, Response;

                    // Skip over the "381 "
                    SSPISetBuffer(m_pszResponse + 4, SSPI_STRING, 0, &Challenge);

                    // Generate a response from the server's challange
                    if (SUCCEEDED(hr = SSPIResponseFromChallenge(&m_sicinfo, &Challenge, &Response)))
                        {
                        Assert(m_iAuthType != AUTHINFO_NONE);
                        if (m_iAuthType == AUTHINFO_GENERIC)
                            HrSendCommand((LPSTR) NNTP_GENERICCMD, Response.szBuffer, FALSE);
                        else
                            HrSendCommand((LPSTR) NNTP_TRANSACTCMD, Response.szBuffer, FALSE);
                        // if a continue is required, stay in this state
                        if (!Response.fContinue)
                            m_substate = NS_TRANSACT_RESP;
                        break;
                        }
                    else
                        {
                        Disconnect();
                        DispatchResponse(IXP_E_SICILY_LOGON_FAILED, TRUE);
                        break;
                        }
                    }
                else
                    m_fRetryPkg = TRUE;

                // We need to reset the connection if we get here
                m_substate = NS_RECONNECTING;
                OnStatus(IXP_AUTHRETRY);
                m_pSocket->Close();
                m_pSocket->Connect();
                }
            break;

        // This is the final response to our sicily negotiation.  This should
        // be either that we succeeded or didn't.  If we succeeded, then we've
        // reached a terminal state and can inform the user that we're ready
        // to accept commands.  Otherwise, we reconnect and try the next
        // security package.
        case NS_TRANSACT_RESP:
            if (SUCCEEDED(hr = HrGetResponse()))
                {
                if (IXP_NNTP_AUTH_OK == m_uiResponse)
                    {
                    OnStatus(IXP_AUTHORIZED);
                    DispatchResponse(m_hrPostingAllowed, TRUE);
                    }
                else
                    {
                    // We need to reset the connection
                    OnStatus(IXP_AUTHRETRY);
                    m_substate = NS_RECONNECTING;
                    m_fRetryPkg = TRUE;
                    m_pSocket->Close();
                    m_pSocket->Connect();
                    }
                }
            break;

        // We issued an AUTHINFO USER <username> and this is the server's 
        // response.  We're expecting either that a password is required or 
        // that we've succeesfully authenticated.
        case NS_AUTHINFO_USER_RESP:
            if (SUCCEEDED(hr = HrGetResponse()))
                {
                // If the server requires a password to go along with the username
                // then send it now.
                if (IXP_NNTP_PASSWORD_REQUIRED == m_uiResponse)
                    {
                    LPSTR pszPassword;

                    // Choose the password based on if we were called from 
                    // Connect() or CommandAUTHINFO().
                    if (m_state == NS_AUTHINFO)
                        pszPassword = m_pAuthInfo->pszPass;
                    else
                        pszPassword = m_rServer.szPassword;

                    HrSendCommand((LPSTR) NNTP_AUTHINFOPASS, pszPassword, FALSE);
                    m_substate = NS_AUTHINFO_PASS_RESP;
                    }

                // Otherwise, consider ourselves connected and in a state to accept
                // commands
                else
                    {
                    OnStatus(IXP_AUTHORIZED);
                    DispatchResponse(m_hrPostingAllowed, TRUE);
                    }
                }
            break;

        // We sent a AUTHINFO PASS <password> command to complement the AUTHINFO 
        // USER command.  This response will tell us whether we're authenticated
        // or not.  Either way this is a terminal state.
        case NS_AUTHINFO_PASS_RESP:
            if (SUCCEEDED(hr = HrGetResponse()))
                {
                // If the password was accepted, consider ourselves connected 
                // and in a state to accept commands.
                if (IXP_NNTP_AUTH_OK >= m_uiResponse)
                    {
                    OnStatus(IXP_AUTHORIZED);
                    DispatchResponse(m_hrPostingAllowed, TRUE);
                    }

                // If the password was rejected, then use the callback to prompt
                // the user for new credentials.
                else
                    {
                    // Need to disconnect and reconnect to make sure we're in a
                    // known, stable state with the server.
                    m_substate = NS_RECONNECTING;

                    if (FAILED(LogonRetry(IXP_E_NNTP_INVALID_USERPASS)))
                        {
                        DispatchResponse(IXP_E_USER_CANCEL, TRUE);
                        }
                    }
                }
            break;

        // We sent a AUTHINFO SIMPLE command to the server to see if the command
        // is supported.  If the server returns 350, then we should send the
        // username and password
        case NS_AUTHINFO_SIMPLE_RESP:
            if (SUCCEEDED(hr = HrGetResponse()))
                {
                // If we got a response to continue, then send the user name and
                // password
                if (IXP_NNTP_CONTINUE_AUTHORIZATION == m_uiResponse)
                    {
                    IxpAssert(m_pAuthInfo);

                    if (SUCCEEDED(hr = HrSendCommand(m_pAuthInfo->pszUser, 
                                                     m_pAuthInfo->pszPass, FALSE)))
                        m_substate = NS_AUTHINFO_SIMPLE_USERPASS_RESP;
                    else
                        DispatchResponse(hr, TRUE);
                    }
                else
                    {
                    // Otherwise fail and inform the user.
                    DispatchResponse(hr, TRUE);
                    }
                }
            break;

        // This is the final response from the AUTHINFO SIMPLE command.  All 
        // we need to do is inform the user.
        case NS_AUTHINFO_SIMPLE_USERPASS_RESP:
            if (SUCCEEDED(hr = HrGetResponse()))
                {
                DispatchResponse(hr, TRUE);
                }
            break;

        }

    return (hr);
    }


//
//  FUNCTION:   CNNTPTransport::DispatchResponse()
//
//  PURPOSE:    Takes the server response string, packages it up into a
//              NNTPRESPONSE structure, and returns it to the callback 
//              interface.
//
//  PARAMETERS:
//      hrResult  - The result code to send to the callback.
//      fDone     - True if the command has completed.
//      pResponse - If the command is returning data, then this should
//                  be filled in with the data to be returned.
//
void CNNTPTransport::DispatchResponse(HRESULT hrResult, BOOL fDone, 
                                      LPNNTPRESPONSE pResponse)
{
    // Locals
    NNTPRESPONSE rResponse;

    // If a response was passed in, use it...
    if (pResponse)
        CopyMemory(&rResponse, pResponse, sizeof(NNTPRESPONSE));
    else
        ZeroMemory(&rResponse, sizeof(NNTPRESPONSE));

    rResponse.fDone = fDone;

    // Set up the return structure
    rResponse.state = m_state;
    rResponse.rIxpResult.hrResult = hrResult;
    rResponse.rIxpResult.pszResponse = PszDupA(m_pszResponse);
    rResponse.rIxpResult.uiServerError = m_uiResponse;
    rResponse.rIxpResult.hrServerError = m_hrResponse;
    rResponse.rIxpResult.dwSocketError = m_pSocket->GetLastError();
    rResponse.rIxpResult.pszProblem = NULL;
    rResponse.pTransport = this;

    // If Done...
    if (fDone)
    {
        // No current command
        m_state = NS_IDLE;
        m_substate = NS_RESP;

        // Reset Last Response
        SafeMemFree(m_pszResponse);
        m_hrResponse = S_OK;
        m_uiResponse = 0;

        // If we have user/pass info cached, free it
        if (m_pAuthInfo)
            {
            SafeMemFree(m_pAuthInfo->pszUser);
            SafeMemFree(m_pAuthInfo->pszPass);
            SafeMemFree(m_pAuthInfo);
            }

        // Leave Busy State
        LeaveBusy();
    }

    // Give the Response to the client
    if (m_pCallback)
        ((INNTPCallback *) m_pCallback)->OnResponse(&rResponse);
    SafeMemFree(rResponse.rIxpResult.pszResponse);
}


//
//  FUNCTION:   CNNTPTransport::HrGetResponse()
//
//  PURPOSE:    Reads the server response string off the socket and stores
//              the response info in local members.
//
//  RETURN VALUE:
//      HRESULT
//
HRESULT CNNTPTransport::HrGetResponse(void)
    {
    HRESULT hr = S_OK;
    int     cbLine;

    // Clear response
    if (m_pszResponse != NULL)
        SafeMemFree(m_pszResponse);

    // Read the line from the socket
    hr = m_pSocket->ReadLine(&m_pszResponse, &cbLine);

    // Handle incomplete lines
    if (hr == IXP_E_INCOMPLETE)
        goto exit;
    
    // Socket error
    if (FAILED(hr))
        {
        hr = TrapError(IXP_E_SOCKET_READ_ERROR);
        goto exit;
        }

    // Strip the trailing CRLF
    StripCRLF(m_pszResponse, (ULONG *) &cbLine);

    // Log it
    if (m_pLogFile)
        m_pLogFile->WriteLog(LOGFILE_RX, m_pszResponse);

    // Get the response code from the beginning of the string
    m_uiResponse = StrToInt(m_pszResponse);

    // Tell the client about the server response
    if (m_pCallback)
        m_pCallback->OnCommand(CMD_RESP, m_pszResponse, hr, NNTPTHISIXP);

exit:
    return (hr);
    }


//
//  FUNCTION:   CNNTPTransport::StartLogon()
//
//  PURPOSE:    Starts the login process with the server based on information
//              provided by the user in Connect().
//
void CNNTPTransport::StartLogon(void)
    {
    HRESULT hr;

    // If not using sicily or it's not installed, try simple USER/PASS authentication
    if (m_rServer.fTrySicily)
        {
        // If sicily is installed
        if (FIsSicilyInstalled())
            {
            // Status
            OnStatus(IXP_AUTHORIZING);

            // If we haven't enumerated the security packages yet, do so
            if (m_cSecPkg == -1)
                {
                hr = HrSendCommand((LPSTR) NNTP_GENERICTEST_CRLF, NULL, FALSE);
                m_substate = NS_GENERIC_TEST;
                }
            else
                {
                // We've reconnected, try the next security package
                TryNextSecPkg();
                }
            }
        else
            {
            Disconnect();
            DispatchResponse(IXP_E_LOAD_SICILY_FAILED, TRUE);
            }
        }
    else
        {
        hr = MaybeTryAuthinfo();
        if (FAILED(hr))
            {
            OnError(hr);
            DropConnection();
            DispatchResponse(hr, TRUE);
            }
        }
    }

HRESULT CNNTPTransport::LogonRetry(HRESULT hrLogon)
    {
    HRESULT hr = S_OK;

    // Let the user know that the logon failed
    OnError(hrLogon);

    // Update the transport status
    OnStatus(IXP_AUTHRETRY);

    // Enter Auth Retry State
    m_pSocket->Close();

    // Turn off the watchdog timer
    m_pSocket->StopWatchDog();

    // Ask the user to provide credetials
    if (NULL == m_pCallback || S_FALSE == m_pCallback->OnLogonPrompt(&m_rServer, NNTPTHISIXP))
        {
        OnDisconnected();
        return (E_FAIL);
        }

    // Finding Host Progress
    OnStatus(IXP_FINDINGHOST);

    // Connect to server
    hr = m_pSocket->Connect();
    if (FAILED(hr))
    {
        OnError(TrapError(IXP_E_SOCKET_CONNECT_ERROR));
        OnDisconnected();
        return hr;
    }

    // Start WatchDog
    m_pSocket->StartWatchDog();
    return (S_OK);
    }

/////////////////////////////////////////////////////////////////////////////
// 
// CNNTPTransport::ProcessGenericTestResponse
//
//   processes AUTHINFO GENERIC response
//
HRESULT CNNTPTransport::ProcessGenericTestResponse()
    {
    HRESULT     hr;
    LPSTR       pszLines = NULL;
    int         iRead, iLines;
      
    m_cSecPkg = 0;
    if (SUCCEEDED(hr = m_pSocket->ReadLines(&pszLines, &iRead, &iLines)))
        {
        LPSTR pszT = pszLines, pszPkg;

        while (*pszT && m_cSecPkg < MAX_SEC_PKGS)
            {
            // check for end of list condition
            if ((pszT[0] == '.') && ((pszT[1] == '\r' && pszT[2] == '\n') || (pszT[1] == '\n')))
                break;
            pszPkg = pszT;
            // look for an LF or CRLF to end the line
            while (*pszT && !(pszT[0] == '\n' || (pszT[0] == '\r' && pszT[1] == '\n')))
                pszT++;
            // strip the LF or CRLF
            while (*pszT == '\r' || *pszT == '\n')
                *pszT++ = 0;
            m_rgszSecPkg[m_cSecPkg++] = PszDupA(pszPkg);
            }

        // we've reached the end of the list, otherwise there is more data expected
        if (pszT[0] == '.')
            {
            Assert(pszT[1] == '\r' && pszT[2] == '\n');
            m_iAuthType = AUTHINFO_GENERIC;
            hr = TryNextSecPkg();
            }

        MemFree(pszLines);
        }
    return hr;
    }

/////////////////////////////////////////////////////////////////////////////
// 
// CNNTPTransport::ProcessTransactTestResponse
//
//   processes AUTHINFO TRANSACT TWINKIE response
//
HRESULT CNNTPTransport::ProcessTransactTestResponse()
    {
    HRESULT hr = NOERROR;

    m_cSecPkg = 0;
    if (m_uiResponse == IXP_NNTP_PROTOCOLS_SUPPORTED)
        {
        LPSTR pszT;

        pszT = m_szSecPkgs = PszDupA(m_pszResponse + 3); // skip over 485
        while (*pszT && IsSpace(pszT))
            pszT++;
        while (*pszT && m_cSecPkg < MAX_SEC_PKGS)
            {
            m_rgszSecPkg[m_cSecPkg++] = pszT;
            while (*pszT && !IsSpace(pszT))
                pszT++;
            while (*pszT && IsSpace(pszT))
                *pszT++ = 0;
            }
        m_iAuthType = AUTHINFO_TRANSACT;
        return TryNextSecPkg();                        
        }
    else
        {
        Disconnect();
        DispatchResponse(IXP_E_SICILY_LOGON_FAILED, TRUE);
        return NOERROR;
        }
    }

/////////////////////////////////////////////////////////////////////////////
// 
// CNNTPTransport::TryNextSecPkg
//
//   tries the next security package, or reverts to basic if necessary
//
HRESULT CNNTPTransport::TryNextSecPkg()
    {
    HRESULT hr;

    Assert(m_cSecPkg != -1);
    Assert(m_iAuthType != AUTHINFO_NONE);    

TryNext:

    if (!m_fRetryPkg)
        m_iSecPkg++;

    if (m_iSecPkg < m_cSecPkg)
        {
        Assert(m_cSecPkg);
        SSPIFreeContext(&m_sicinfo);
        if (!lstrcmpi(m_rgszSecPkg[m_iSecPkg], NNTP_BASIC))
            return MaybeTryAuthinfo();

        // In case the Sicily function brings up UI, we need to turn off the 
        // watchdog so we don't time out waiting for the user
        m_pSocket->StopWatchDog();

        if (SUCCEEDED(hr = SSPILogon(&m_sicinfo, m_fRetryPkg, SSPI_BASE64, m_rgszSecPkg[m_iSecPkg], &m_rServer, m_pCallback)))
            {
            if (m_fRetryPkg)
                {
                m_fRetryPkg = FALSE;
                }
            if (SUCCEEDED(hr = SSPIGetNegotiate(&m_sicinfo, &m_sicmsg)))
                {
                DOUTL(2, "Trying to connect using %s security...", m_rgszSecPkg[m_iSecPkg]);
                if (m_iAuthType == AUTHINFO_GENERIC)
                    hr = HrSendCommand((LPSTR) NNTP_GENERICCMD, m_rgszSecPkg[m_iSecPkg], FALSE);
                else
                    hr = HrSendCommand((LPSTR) NNTP_TRANSACTCMD, m_rgszSecPkg[m_iSecPkg], FALSE);

                // Restart the watchdog timer now that we've issued our next command to the server.
                m_pSocket->StartWatchDog();

                m_substate = NS_TRANSACT_PACKAGE;
                }
            else
                {
                hr = IXP_E_SICILY_LOGON_FAILED;
                goto TryNext;
                }
            }
        else
            {
            m_fRetryPkg = FALSE;
            goto TryNext;
            }
        }
    else
        {
        OnError(IXP_E_SICILY_LOGON_FAILED);

        DropConnection();
        DispatchResponse(IXP_E_SICILY_LOGON_FAILED, TRUE);
        hr = NOERROR;
        }
    return hr;
    }


/////////////////////////////////////////////////////////////////////////////
// 
// CNNTPTransport::MaybeTryAuthinfo
//
//   tries basic authinfo if necessary, else moves to connected state
//
HRESULT CNNTPTransport::MaybeTryAuthinfo()
    {
    HRESULT hr;

    if (*m_rServer.szUserName)
        {
        OnStatus(IXP_AUTHORIZING);
        hr = HrSendCommand((LPSTR) NNTP_AUTHINFOUSER, m_rServer.szUserName, FALSE);
        m_substate = NS_AUTHINFO_USER_RESP;
        }
    else
        {
        // Logon not needed for this news server (or so we'll have to assume)
        OnStatus(IXP_AUTHORIZED);
        DispatchResponse(S_OK, TRUE);
        hr = NOERROR;
        }
    return hr;
    }

#define Whitespace(_ch) (((_ch) == ' ') || ((_ch) == '\t') || ((_ch) == '\n'))

BOOL ScanNum(LPSTR *ppsz, BOOL fEnd, DWORD *pdw)
    {
    DWORD n = 0;
    LPSTR psz;

    Assert(ppsz != NULL);
    Assert(pdw != NULL);

    psz = *ppsz;
    if (*psz == 0 || Whitespace(*psz))
        return(FALSE);

    while (*psz != 0 && !Whitespace(*psz))
        {
        if (*psz >= '0' && *psz <= '9')
            {
            n *= 10;
            n += *psz - '0';
            psz++;
            }
        else
            {
            return(FALSE);
            }
        }

    if (Whitespace(*psz))
        {
        if (fEnd)
            return(FALSE);
        while (*psz != 0 && Whitespace(*psz))
            psz++;
        }
    else
        {
        Assert(*psz == 0);
        if (!fEnd)
            return(FALSE);
        }

    *ppsz = psz;
    *pdw = n;

    return(TRUE);
    }

BOOL ScanWord(LPCSTR psz, LPSTR pszDest)
    {
    Assert(psz != NULL);
    Assert(pszDest != NULL);

    if (*psz == 0 || Whitespace(*psz))
        return(FALSE);

    while (*psz != 0 && !Whitespace(*psz))
        {
        *pszDest = *psz;
        psz++;
        pszDest++;
        }

    *pszDest = 0;

    return(TRUE);
    }

/////////////////////////////////////////////////////////////////////////////
// 
// CNNTPTransport::ProcessGroupResponse
//
//   processes the GROUP response
//
HRESULT CNNTPTransport::ProcessGroupResponse(void)
{
    NNTPGROUP       rGroup;
    DWORD           dwResp;
    NNTPRESPONSE    rResp;
    LPSTR           psz;
    LPSTR           pszGroup = 0;

    ZeroMemory(&rGroup, sizeof(NNTPGROUP));
    ZeroMemory(&rResp, sizeof(NNTPRESPONSE));
    
    if (m_uiResponse == IXP_NNTP_GROUP_SELECTED)
    {
        rResp.fMustRelease = TRUE;
        pszGroup = PszDupA(m_pszResponse);
        psz = m_pszResponse;
        if (!ScanNum(&psz, FALSE, &dwResp) ||
            !ScanNum(&psz, FALSE, &rGroup.dwCount) ||
            !ScanNum(&psz, FALSE, &rGroup.dwFirst) ||
            !ScanNum(&psz, FALSE, &rGroup.dwLast) ||
            !ScanWord(psz, pszGroup))
        {
            m_hrResponse = IXP_E_NNTP_RESPONSE_ERROR;
        }
        else
        {
            if (pszGroup)
            {
                rGroup.pszGroup = PszDupA(pszGroup);
            }
            rResp.rGroup = rGroup;
        }
    }
    else if (m_uiResponse == IXP_NNTP_NO_SUCH_NEWSGROUP)
        m_hrResponse = IXP_E_NNTP_GROUP_NOTFOUND;
    else
        m_hrResponse = IXP_E_NNTP_GROUP_FAILED;

    DispatchResponse(m_hrResponse, TRUE, &rResp);

    SafeMemFree(pszGroup);
    return (m_hrResponse);
}

HRESULT CNNTPTransport::ProcessNextResponse(void)
    {
    LPSTR           psz;
    NNTPNEXT        rNext;
    DWORD           dwResp;
    NNTPRESPONSE    rResp;

    ZeroMemory(&rNext, sizeof(NNTPNEXT));
    ZeroMemory(&rResp, sizeof(NNTPRESPONSE));

    // If success was returned, then parse the response
    if (m_uiResponse == IXP_NNTP_ARTICLE_RETRIEVED)
        {
        rResp.fMustRelease = TRUE;

        // Allocate a buffer for the message id
        rNext.pszMessageId = PszAllocA(lstrlen(m_pszResponse));
        if (NULL != rNext.pszMessageId)
            {
            psz = m_pszResponse;
            if (!ScanNum(&psz, FALSE, &dwResp) ||
                !ScanNum(&psz, FALSE, &rNext.dwArticleNum) ||
                !ScanWord(psz, rNext.pszMessageId))
                {
                m_hrResponse = IXP_E_NNTP_RESPONSE_ERROR;
                }
            else
                {
                m_hrResponse = S_OK;

                // Since this is just a union, a little sleeze and we wouldn't
                // actually need to to this...
                if (m_state == NS_NEXT)
                    rResp.rNext = rNext;
                else if (m_state == NS_LAST)
                    rResp.rLast = rNext;
                else
                    rResp.rStat = rNext;
                }
            }
        else
            {
            m_hrResponse = TrapError(E_OUTOFMEMORY);
            }
        }
    else if ((m_state == NS_NEXT && m_uiResponse == IXP_NNTP_NO_NEXT_ARTICLE) ||
             (m_state == NS_LAST && m_uiResponse == IXP_NNTP_NO_PREV_ARTICLE) ||
             (m_state == NS_STAT && m_uiResponse == IXP_NNTP_NO_SUCH_ARTICLE_NUM))
        {
        m_hrResponse = IXP_E_NNTP_NEXT_FAILED;
        }
    else
        m_hrResponse = S_OK;

    DispatchResponse(m_hrResponse, TRUE, &rResp);
    return (m_hrResponse);
    }


HRESULT CNNTPTransport::ProcessListData(void)
    {
    HRESULT         hr = S_OK;
    LPSTR           pszLines = NULL;
    DWORD           dwRead, dwLines;
    NNTPLIST        rList;
    LPSTR           pszT;
    NNTPRESPONSE    rResponse;

    ZeroMemory(&rList, sizeof(NNTPLIST));
    ZeroMemory(&rResponse, sizeof(NNTPRESPONSE));

    // Get the remaining data off the socket
    if (SUCCEEDED(hr = m_pSocket->ReadLines(&pszLines, (int *)&dwRead, (int *)&dwLines)))
        {
        // Allocate and array to hold the lines
        if (!MemAlloc((LPVOID*) &rList.rgszLines, dwLines * sizeof(LPSTR)))
            {
            OnError(E_OUTOFMEMORY);
            hr = E_OUTOFMEMORY;
            goto error;
            }
        ZeroMemory(rList.rgszLines, sizeof(LPSTR) * dwLines);

        // Parse the buffer returned from the protocol.  We need to find the 
        // end of the list.
        pszT = pszLines;
        while (*pszT)
            {
            // Check for the end of list condition
            if ((pszT[0] == '.') && ((pszT[1] == '\r' && pszT[2] == '\n') || (pszT[1] == '\n')))
                break;

            // Save the line
            rList.rgszLines[rList.cLines++] = pszT;

            // Find the LF or CRLF at the end of the line
            while (*pszT && !(pszT[0] == '\n' || (pszT[0] == '\r' && pszT[1] == '\n')))
                pszT++;

            // Strip off the LF or CRLF and add a terminator
            while (*pszT == '\r' || *pszT == '\n')
                *pszT++ = 0;
            }

        // If we parsed more lines off of the buffer than was returned to us, 
        // then either we have a parsing bug, or the socket class has a counting 
        // bug.
        IxpAssert(rList.cLines <= dwLines);

        // We've readed the end of the list, otherwise there is more data expected
        if (pszT[0] == '.')
            {
            // Double check that this dot is followed by a CRLF
            IxpAssert(pszT[1] == '\r' && pszT[2] == '\n');
            rResponse.fDone = TRUE;
            }

        rResponse.rList = rList;
        rResponse.fMustRelease = TRUE;
        DispatchResponse(S_OK, rResponse.fDone, &rResponse);
        }

    return (hr);

error:
    SafeMemFree(pszLines);
    return (hr);
    }

HRESULT CNNTPTransport::ProcessListGroupData(void)
    {
    HRESULT         hr = S_OK;
    LPSTR           pszLines = NULL;
    LPSTR           pszBeginLine = NULL;
    DWORD           dwRead, dwLines;
    NNTPLISTGROUP   rListGroup;
    LPSTR           pszT;
    NNTPRESPONSE    rResp;

    ZeroMemory(&rListGroup, sizeof(NNTPLIST));
    ZeroMemory(&rResp, sizeof(NNTPRESPONSE));

    // Get the remaining data off the socket
    if (SUCCEEDED(hr = m_pSocket->ReadLines(&pszLines, (int *)&dwRead, (int *)&dwLines)))
        {
        // Allocate and array to hold the lines
        if (!MemAlloc((LPVOID*) &rListGroup.rgArticles, dwLines * sizeof(DWORD)))
            {
            hr = E_OUTOFMEMORY;
            OnError(E_OUTOFMEMORY);
            goto error;
            }

        // Parse the buffer returned from the protocol.  We need to find the 
        // end of the list.
        pszT = pszLines;
        rListGroup.cArticles = 0;
        while (*pszT)
            {
            // Check for the end of list condition
            if ((pszT[0] == '.') && ((pszT[1] == '\r' && pszT[2] == '\n') || (pszT[1] == '\n')))
                break;

            // Save the beginning of the line
            pszBeginLine = pszT;

            // Find the LF or CRLF at the end of the line
            while (*pszT && !(pszT[0] == '\n' || (pszT[0] == '\r' && pszT[1] == '\n')))
                pszT++;

            // Strip off the LF or CRLF and add a terminator
            while (*pszT == '\r' || *pszT == '\n')
                *pszT++ = 0;

            // Convert the line to a number and add it to the array
            rListGroup.rgArticles[rListGroup.cArticles] = StrToInt(pszBeginLine);
            if (rListGroup.rgArticles[rListGroup.cArticles])
                rListGroup.cArticles++;
            }

        // If we parsed more lines off of the buffer than was returned to us, 
        // then either we have a parsing bug, or the socket class has a counting 
        // bug.
        IxpAssert(rListGroup.cArticles <= dwLines);

        // We've readed the end of the list, otherwise there is more data expected
        if (pszT[0] == '.')
            {
            // Double check that this dot is followed by a CRLF
            IxpAssert(pszT[1] == '\r' && pszT[2] == '\n');
            rResp.fDone = TRUE;
            }

        rResp.rListGroup = rListGroup;
        rResp.fMustRelease = TRUE;
        DispatchResponse(S_OK, rResp.fDone, &rResp);
        }

error:
    SafeMemFree(pszLines);
    return (hr);
    }

BOOL CharsToNum(LPCSTR psz, int cch, WORD *pw)
    {
    int i;
    WORD w = 0;

    Assert(psz != NULL);
    Assert(pw != NULL);

    for (i = 0; i < cch; i++)
        {
        if (*psz >= '0' && *psz <= '9')
            {
            w *= 10;
            w += *psz - '0';
            psz++;
            }
        else
            {
            return(FALSE);
            }
        }

    *pw = w;

    return(TRUE);
    }

HRESULT CNNTPTransport::ProcessDateResponse(void)
    {
    HRESULT      hr = S_OK;
    SYSTEMTIME   st;
    NNTPRESPONSE rResp;
    DWORD        dwResp;
    LPSTR        psz;

    ZeroMemory(&rResp, sizeof(NNTPRESPONSE));

    // This information is returned in the format YYYYMMDDhhmmss
    if (m_uiResponse == IXP_NNTP_DATE_RESPONSE)
        {
        ZeroMemory(&st, sizeof(SYSTEMTIME));

        psz = StrChr(m_pszResponse, ' ');
        if (psz == NULL ||
            !CharsToNum(++psz, 4, &st.wYear) ||
            !CharsToNum(&psz[4], 2, &st.wMonth) ||
            !CharsToNum(&psz[6], 2, &st.wDay) ||
            !CharsToNum(&psz[8], 2, &st.wHour) ||
            !CharsToNum(&psz[10], 2, &st.wMinute) ||
            !CharsToNum(&psz[12], 2, &st.wSecond))
            {
            m_hrResponse = IXP_E_NNTP_RESPONSE_ERROR;
            }
        else
            {
            rResp.rDate = st;
            m_hrResponse = S_OK;
            }
        }
    else
        m_hrResponse = IXP_E_NNTP_DATE_FAILED;

    DispatchResponse(m_hrResponse, TRUE, &rResp);
    return (hr);
    }


HRESULT CNNTPTransport::ProcessArticleData(void)
    {
    HRESULT     hr;
    DWORD       dwRead, dwLines;
    LPSTR       psz;
    DWORD       cbSubtract;
    NNTPARTICLE rArticle;
    NNTPRESPONSE rResp;

    ZeroMemory(&rArticle, sizeof(NNTPARTICLE));
    ZeroMemory(&rResp, sizeof(NNTPRESPONSE));

    // Bug #25073 - Get the article number from the response string
    DWORD dwT;
    psz = m_pszResponse;
    ScanNum(&psz, FALSE, &dwT);
    ScanNum(&psz, TRUE, &rArticle.dwArticleNum);

    // Read the waiting data off the socket
    hr = m_pSocket->ReadLines(&rArticle.pszLines, (int*) &dwRead, (int*) &dwLines);
    if (hr == IXP_E_INCOMPLETE)
        return (hr);

    // Check forfailure
    if (FAILED(hr))
        {
        DispatchResponse(hr);
        return (hr);
        }

    // See if this is the end of the response
    if (FEndRetrRecvBodyNews(rArticle.pszLines, dwRead, &cbSubtract))
        {
        // Remove the trailing dot from the buffer
        dwRead -= cbSubtract;
        rArticle.pszLines[dwRead] = 0;
        rResp.fDone = TRUE;
        }

    // Unstuff the dots
    UnStuffDotsFromLines(rArticle.pszLines, (int *)&dwRead);
    rArticle.pszLines[dwRead] ='\0';

    // Fill out the response
    rResp.rArticle = rArticle;
    rResp.rArticle.cbLines = dwRead;
    rResp.rArticle.cLines = dwLines;
    rResp.fMustRelease = TRUE;

    DispatchResponse(hr, rResp.fDone, &rResp);

    return hr;
    }

HRESULT CNNTPTransport::ProcessXoverData(void)
    {
    HRESULT             hr;
    LPSTR               pszLines = NULL;
    LPSTR               pszNextLine = NULL;
    LPSTR               pszField = NULL;
    LPSTR               pszNextField = NULL;
    int                 iRead, iLines;
    NNTPHEADERRESP      rHdrResp;
    NNTPRESPONSE        rResp;
    NNTPHEADER         *rgHdr;
    PMEMORYINFO         pMemInfo = 0;

    ZeroMemory(&rHdrResp, sizeof(NNTPHEADERRESP));
    ZeroMemory(&rResp, sizeof(NNTPRESPONSE));

    // Read the data that is waiting on the socket
    if (SUCCEEDED(hr = m_pSocket->ReadLines(&pszLines, &iRead, &iLines)))
        {
        // Allocate the MEMORYINFO struct we use to stash the pointers
        if (!MemAlloc((LPVOID*) &pMemInfo, sizeof(MEMORYINFO)))
            {
            OnError(E_OUTOFMEMORY);
            hr = E_OUTOFMEMORY;
            goto error;
            }
        pMemInfo->cPointers = 1;
        pMemInfo->rgPointers[0] = pszLines;
        rHdrResp.dwReserved = (DWORD_PTR) pMemInfo;

        // Allocate the array of headers
        Assert(iLines);
        if (!MemAlloc((LPVOID*) &(rHdrResp.rgHeaders), iLines * sizeof(NNTPHEADER)))
            {
            OnError(E_OUTOFMEMORY);
            hr = E_OUTOFMEMORY;
            goto error;
            }
        rgHdr = rHdrResp.rgHeaders;

        // Loop until we either run out of lines or we find a line that begins 
        // with "."
        pszNextLine = pszLines;
        while (*pszNextLine && *pszNextLine != '.')
            {
            pszField = pszNextLine;

            // Look ahead to find the beginning of the next line
            while (*pszNextLine)
                {
                if (*pszNextLine == '\n')
                    {
                    // NULL out a CR followed by a LF
                    if (pszNextLine > pszField && *(pszNextLine - 1) == '\r')
                        *(pszNextLine - 1) = 0;

                    // NULL out and skip over the LF
                    *pszNextLine++ = 0;
                    break;
                    }
                pszNextLine++;
                }

            // At this point, pszField points to the beginning of this XOVER
            // line, and pszNextLine points to the next.

            // Parse the article number field
            if (pszNextField = GetNextField(pszField))
                {
                rgHdr[rHdrResp.cHeaders].dwArticleNum = StrToInt(pszField);
                pszField = pszNextField;
                }
            else
                goto badrecord;

            // Parse the Subject: field
            if (pszNextField = GetNextField(pszField))
                {
                rgHdr[rHdrResp.cHeaders].pszSubject = pszField;
                pszField = pszNextField;
                }
            else
                goto badrecord;

            // Parse the From: field
            if (pszNextField = GetNextField(pszField))
                {
                rgHdr[rHdrResp.cHeaders].pszFrom = pszField;
                pszField = pszNextField;
                }
            else
                goto badrecord;

            // Parse the Date: field
            if (pszNextField = GetNextField(pszField))
                {
                rgHdr[rHdrResp.cHeaders].pszDate = pszField;
                pszField = pszNextField;
                }
            else
                goto badrecord;

            // Parse the Message-ID field
            if (pszNextField = GetNextField(pszField))
                {
                rgHdr[rHdrResp.cHeaders].pszMessageId = pszField;
                pszField = pszNextField;
                }
            else
                goto badrecord;

            rgHdr[rHdrResp.cHeaders].pszReferences = pszField;
            pszField = GetNextField(pszField);

            // Parse the bytes field (we can live without this)
            if (pszField)
                {
                rgHdr[rHdrResp.cHeaders].dwBytes = StrToInt(pszField);
                pszField = GetNextField(pszField);
                }
            else
                {
                rgHdr[rHdrResp.cHeaders].dwBytes = 0;
                }

            // Parse the article size in lines (we can live without this also)
            if (pszField)
                {
                rgHdr[rHdrResp.cHeaders].dwLines = StrToInt(pszField);
                pszField = GetNextField(pszField);
                }
            else
                {
                rgHdr[rHdrResp.cHeaders].dwLines = 0;
                }

            // NOTE: The XRef: field in the XOver record is an optional field 
            // that a server may or may not support.  Also, if the message is  
            // not crossposted, then the XRef: field won't be present either.  
            // Therefore just cause we don't find any XRef: fields doesn't mean
            // it isn't supported.

            // Look for aditional fields that might contain XRef
            rgHdr[rHdrResp.cHeaders].pszXref = 0;
            while (pszField)
                {
                if (!StrCmpNI(pszField, c_szXrefColon, 5))
                    {
                    // We found at least one case where the xref: was supplied.
                    // We now know for sure that this server supports the xref:
                    // field in it's XOver records.
                    m_fSupportsXRef = TRUE;    
                    rgHdr[rHdrResp.cHeaders].pszXref = pszField + 6;
                    break;
                    }

                pszField = GetNextField(pszField);
                }

            rHdrResp.cHeaders++;

            // If we've found a bad record, then we just skip right over it 
            // and move on to the next.
badrecord:
            ;
            }

        // We've reached the end of the list, otherwise there is more data
        // expected.
        rResp.fDone = (*pszNextLine == '.');
        rHdrResp.fSupportsXRef = m_fSupportsXRef;

        // Return what we've retrieved
        rResp.fMustRelease = TRUE;
        rResp.rHeaders = rHdrResp;

        DispatchResponse(hr, rResp.fDone, &rResp);
        return (S_OK);
        }
    return (hr);

error:
    // Free anything we've allocated
    SafeMemFree(rHdrResp.rgHeaders);
    SafeMemFree(pMemInfo);
    SafeMemFree(pszLines);
    DispatchResponse(hr, TRUE);
    return (hr);
    }


// Data comes in the form "<article number> <header>"
HRESULT CNNTPTransport::ProcessXhdrData(void)
    {
    HRESULT hr;
    LPSTR               pszLines = NULL;
    LPSTR               pszNextLine = NULL;
    LPSTR               pszField = NULL;
    LPSTR               pszNextField = NULL;
    int                 iRead, iLines;
    NNTPXHDRRESP        rXhdr;
    NNTPRESPONSE        rResp;
    NNTPXHDR           *rgHdr = 0;
    PMEMORYINFO         pMemInfo = 0;

    ZeroMemory(&rXhdr, sizeof(NNTPXHDRRESP));
    ZeroMemory(&rResp, sizeof(NNTPRESPONSE));

    // Read the data that is waiting on the socket
    if (SUCCEEDED(hr = m_pSocket->ReadLines(&pszLines, &iRead, &iLines)))
        {
        // Allocate the MEMORYINFO struct we use to stash the pointers
        if (!MemAlloc((LPVOID*) &pMemInfo, sizeof(MEMORYINFO)))
            {
            OnError(E_OUTOFMEMORY);
            hr = E_OUTOFMEMORY;
            goto error;
            }
        pMemInfo->cPointers = 1;
        pMemInfo->rgPointers[0] = pszLines;
        rXhdr.dwReserved = (DWORD_PTR) pMemInfo;

        // Allocate the array of XHDRs
        Assert(iLines);
        if (!MemAlloc((LPVOID*) &(rXhdr.rgHeaders), iLines * sizeof(NNTPXHDR)))
            {
            // This is _very_ broken.  We leave a whole bunch of data on the
            // socket.  What should we do?
            OnError(E_OUTOFMEMORY);
            hr = E_OUTOFMEMORY;
            goto error;
            }
        rgHdr = rXhdr.rgHeaders;

        // Loop until we either run out of lines or we find a line that begins 
        // with "."
        pszNextLine = pszLines;
        while (*pszNextLine && *pszNextLine != '.')
            {
            pszField = pszNextLine;

            // Scan ahead and find the end of the line
            while (*pszNextLine)
                {
                if (*pszNextLine == '\n')
                    {
                    // NULL out a CR followed by a LF
                    if (pszNextLine > pszField && *(pszNextLine - 1) == '\r')
                        *(pszNextLine - 1) = 0;

                    // NULL out and skip over the LF
                    *pszNextLine++ = 0;
                    break;
                    }
                pszNextLine++;
                }

            // Parse the article number
            rgHdr[rXhdr.cHeaders].dwArticleNum = StrToInt(pszField);

            // Find the seperating space
            rgHdr[rXhdr.cHeaders].pszHeader = 0;
            while (*pszField && *pszField != ' ')
                pszField++;

            // Make the beginning of the header point to the first character
            // after the space.
            if (*(pszField + 1))
                rgHdr[rXhdr.cHeaders].pszHeader = (pszField + 1);

            if (rgHdr[rXhdr.cHeaders].dwArticleNum && rgHdr[rXhdr.cHeaders].pszHeader)
                rXhdr.cHeaders++;
            }

        // We've reached the end of the list, otherwise there is more data
        // expected.
        rResp.fDone = (*pszNextLine == '.');

        // Return what we've retrieved
        rResp.rXhdr = rXhdr;
        rResp.fMustRelease = TRUE;

        DispatchResponse(hr, rResp.fDone, &rResp);
        return (S_OK);
        }

error:
    SafeMemFree(rgHdr);
    SafeMemFree(pMemInfo);
    SafeMemFree(pszLines);
    return (hr);
    }



LPSTR CNNTPTransport::GetNextField(LPSTR pszField)
    {
    while (*pszField && *pszField != '\t')
        pszField++;

    if (*pszField == '\t')
        {
        *pszField++ = 0;
        return pszField;
        }

    return NULL;
    }

HRESULT CNNTPTransport::CommandAUTHINFO(LPNNTPAUTHINFO pAuthInfo)
    {
    HRESULT     hr;
    
    if (!pAuthInfo)
        return (E_INVALIDARG);

    // Make a copy of this struct so we can use the info during the callback
    // if necessary
    if (pAuthInfo->authtype == AUTHTYPE_USERPASS ||
        pAuthInfo->authtype == AUTHTYPE_SIMPLE)
        {
        if (!MemAlloc((LPVOID*) &m_pAuthInfo, sizeof(NNTPAUTHINFO)))
            {
            OnError(E_OUTOFMEMORY);
            return (E_OUTOFMEMORY);
            }
        ZeroMemory(m_pAuthInfo, sizeof(NNTPAUTHINFO));

        m_pAuthInfo->pszUser = PszDupA(pAuthInfo->pszUser);
        m_pAuthInfo->pszPass = PszDupA(pAuthInfo->pszUser);
        }

    EnterCriticalSection(&m_cs);

    // Issue the command as appropriate
    switch (pAuthInfo->authtype)
        {
        case AUTHTYPE_USERPASS:
            hr = HrSendCommand((LPSTR) NNTP_AUTHINFOUSER, pAuthInfo->pszUser);
            if (SUCCEEDED(hr))
                m_substate = NS_AUTHINFO_USER_RESP;
            break;

        case AUTHTYPE_SIMPLE:
            hr = HrSendCommand((LPSTR) NNTP_AUTHINFOSIMPLE_CRLF, NULL);
            if (SUCCEEDED(hr))
                m_substate = NS_AUTHINFO_SIMPLE_RESP;
            break;

        case AUTHTYPE_SASL:
            // If we haven't enumerated the security packages yet, do so
            if (m_cSecPkg == -1)
                {
                hr = HrSendCommand((LPSTR) NNTP_GENERICTEST_CRLF, NULL, FALSE);
                if (SUCCEEDED(hr))
                    m_substate = NS_GENERIC_TEST;
                }
            else
                {
                // We've reconnected, try the next security package
                TryNextSecPkg();
                }
            break;
        }

    if (SUCCEEDED(hr))
        m_state = NS_AUTHINFO;

    LeaveCriticalSection(&m_cs);
    return (hr);
    }


HRESULT CNNTPTransport::CommandGROUP(LPSTR pszGroup)
    {
    HRESULT hr;

    if (!pszGroup)
        return (E_INVALIDARG);

    EnterCriticalSection(&m_cs);

    hr = HrSendCommand((LPSTR) NNTP_GROUP, pszGroup);
    if (SUCCEEDED(hr))
        m_state = NS_GROUP;

    LeaveCriticalSection(&m_cs);

    return (hr);
    }

HRESULT CNNTPTransport::CommandLAST(void)
    {
    HRESULT hr;

    EnterCriticalSection(&m_cs);

    hr = HrSendCommand((LPSTR) NNTP_LAST_CRLF, NULL);
    if (SUCCEEDED(hr))
        m_state = NS_LAST;

    LeaveCriticalSection(&m_cs);

    return (hr);
    }

HRESULT CNNTPTransport::CommandNEXT(void)
    {
    HRESULT hr;

    EnterCriticalSection(&m_cs);

    hr = HrSendCommand((LPSTR) NNTP_NEXT_CRLF, NULL);
    if (SUCCEEDED(hr))
        m_state = NS_NEXT;

    LeaveCriticalSection(&m_cs);

    return (hr);
    }

HRESULT CNNTPTransport::CommandSTAT(LPARTICLEID pArticleId)    
    {
    HRESULT hr;
    char    szTemp[20];

    EnterCriticalSection(&m_cs);

    // Check to see if the optional article number/id was provided
    if (pArticleId)
        {
        // If we were given a message id, then use that
        if (pArticleId->idType == AID_MSGID)
            hr = HrSendCommand((LPSTR) NNTP_STAT, pArticleId->pszMessageId);
        else
            {
            // Convert the article number to a string and send the command
            wnsprintf(szTemp, ARRAYSIZE(szTemp), "%d", pArticleId->dwArticleNum);
            hr = HrSendCommand((LPSTR) NNTP_STAT, szTemp);
            }
        }
    else
        {
        // No number or id, so just send the command
        hr = HrSendCommand((LPSTR) NNTP_STAT, (LPSTR) c_szCRLF);
        }

    if (SUCCEEDED(hr))
        {
        m_state = NS_STAT;
        }

    LeaveCriticalSection(&m_cs);
    return (hr);
    }

HRESULT CNNTPTransport::CommandARTICLE(LPARTICLEID pArticleId)
    {
    HRESULT hr;
    char    szTemp[20];

    EnterCriticalSection(&m_cs);

    // Check to see if the optional article number/id was provided
    if (pArticleId)
        {
        // Send the command appropriate to what type of article id was given
        if (pArticleId->idType == AID_MSGID)
            hr = HrSendCommand((LPSTR) NNTP_ARTICLE, pArticleId->pszMessageId);
        else
            {
            // convert the article number to a string and send the command
            wnsprintf(szTemp, ARRAYSIZE(szTemp), "%d", pArticleId->dwArticleNum);
            hr = HrSendCommand((LPSTR) NNTP_ARTICLE, szTemp);
            }
        }
    else
        {
        hr = HrSendCommand((LPSTR) NNTP_ARTICLE, (LPSTR) c_szCRLF);
        }

    if (SUCCEEDED(hr))
        {
        m_state = NS_ARTICLE;
        m_substate = NS_RESP;
        }

    LeaveCriticalSection(&m_cs);

    return (hr);
    }

HRESULT CNNTPTransport::CommandHEAD(LPARTICLEID pArticleId)
    {
    HRESULT hr;
    char    szTemp[20];

    EnterCriticalSection(&m_cs);

    // Check to see if the optional article number/id was provided
    if (pArticleId)
        {
        // Send the command appropriate to what type of article id was given
        if (pArticleId->idType == AID_MSGID)
            hr = HrSendCommand((LPSTR) NNTP_HEAD, pArticleId->pszMessageId);
        else
            {
            // convert the article number to a string and send the command
            wnsprintf(szTemp, ARRAYSIZE(szTemp), "%d", pArticleId->dwArticleNum);
            hr = HrSendCommand((LPSTR) NNTP_HEAD, szTemp);
            }
        }
    else
        {
        hr = HrSendCommand((LPSTR) NNTP_HEAD, (LPSTR) c_szCRLF);
        }


    if (SUCCEEDED(hr))
        {
        m_state = NS_HEAD;
        m_substate = NS_RESP;
        }

    LeaveCriticalSection(&m_cs);

    return (hr);
    }

HRESULT CNNTPTransport::CommandBODY(LPARTICLEID pArticleId)
    {
    HRESULT hr;
    char    szTemp[20];

    EnterCriticalSection(&m_cs);

    // Check to see if the optional article number/id was provided
    if (pArticleId)
        {
        // Send the command appropriate to what type of article id was given
        if (pArticleId->idType == AID_MSGID)
            hr = HrSendCommand((LPSTR) NNTP_BODY, pArticleId->pszMessageId);
        else
            {
            // convert the article number to a string and send the command
            wnsprintf(szTemp, ARRAYSIZE(szTemp), "%d", pArticleId->dwArticleNum);
            hr = HrSendCommand((LPSTR) NNTP_BODY, szTemp);
            }
        }
    else
        {
        hr = HrSendCommand((LPSTR) NNTP_BODY, (LPSTR) c_szCRLF);
        }

    if (SUCCEEDED(hr))
        {
        m_state = NS_BODY;
        m_substate = NS_RESP;
        }

    LeaveCriticalSection(&m_cs);

    return (hr);
    }

HRESULT CNNTPTransport::CommandPOST(LPNNTPMESSAGE pMessage)
    {
    HRESULT hr;

    if (!pMessage || (pMessage && !pMessage->pstmMsg))
        return (E_INVALIDARG);    

    EnterCriticalSection(&m_cs);

    // Make a copy of the message struct so we have it when we get
    // an response from the server that it's OK to post
#pragma prefast(suppress:11, "noise")
    m_rMessage.cbSize = pMessage->cbSize;
    SafeRelease(m_rMessage.pstmMsg);
#pragma prefast(suppress:11, "noise")
    m_rMessage.pstmMsg = pMessage->pstmMsg;
    m_rMessage.pstmMsg->AddRef();

    hr = HrSendCommand((LPSTR) NNTP_POST_CRLF, NULL);
    if (SUCCEEDED(hr))
        {
        m_state = NS_POST;
        m_substate = NS_RESP;
        }

    LeaveCriticalSection(&m_cs);

    return (hr);
    }

HRESULT CNNTPTransport::CommandLIST(LPSTR pszArgs)
    {
    HRESULT hr;

    EnterCriticalSection(&m_cs);

    if (pszArgs)
        hr = HrSendCommand((LPSTR) NNTP_LIST, pszArgs);
    else
        hr = HrSendCommand((LPSTR) NNTP_LIST, (LPSTR) c_szCRLF);

    if (SUCCEEDED(hr))
        {
        m_state = NS_LIST;
        m_substate = NS_RESP;
        }

    LeaveCriticalSection(&m_cs);
    return (hr);
    }

HRESULT CNNTPTransport::CommandLISTGROUP(LPSTR pszGroup)
    {
    HRESULT hr;

    EnterCriticalSection(&m_cs);

    if (pszGroup)
        hr = HrSendCommand((LPSTR) NNTP_LISTGROUP, pszGroup);
    else
        hr = HrSendCommand((LPSTR) NNTP_LISTGROUP, (LPSTR) c_szCRLF);

    if (SUCCEEDED(hr))
        {
        m_state = NS_LISTGROUP;
        m_substate = NS_RESP;
        }


    LeaveCriticalSection(&m_cs);
    return (hr);
    }

HRESULT CNNTPTransport::CommandNEWGROUPS(SYSTEMTIME *pstLast, LPSTR pszDist)
    {
    HRESULT hr = S_OK;
    LPSTR   pszCmd = NULL;
    DWORD   cchCmd = 18;

    // Make sure a SYSTEMTIME struct is provided
    if (!pstLast)
        return (E_INVALIDARG);

    // Allocate enough room for the command string "NEWGROUPS YYMMDD HHMMSS <pszDist>"
    if (pszDist)
        cchCmd += lstrlen(pszDist);
    
    if (!MemAlloc((LPVOID*) &pszCmd, cchCmd))
        {
        OnError(E_OUTOFMEMORY);
        return (E_OUTOFMEMORY);
        }

    // Put the command arguments together
    wnsprintf(pszCmd, cchCmd, "%02d%02d%02d %02d%02d%02d ", pstLast->wYear - (100 * (pstLast->wYear / 100)),
             pstLast->wMonth, pstLast->wDay, pstLast->wHour, pstLast->wMinute, 
             pstLast->wSecond);
    if (pszDist)
        StrCatBuff(pszCmd, pszDist, cchCmd);

    // Send the command
    EnterCriticalSection(&m_cs);

    hr = HrSendCommand((LPSTR) NNTP_NEWGROUPS, pszCmd);
    if (SUCCEEDED(hr))
        {
        m_state = NS_NEWGROUPS;
        m_substate = NS_RESP;
        }

    LeaveCriticalSection(&m_cs);    
    SafeMemFree(pszCmd);
    return (hr);
    }

HRESULT CNNTPTransport::CommandDATE(void)
    {
    HRESULT hr;

    EnterCriticalSection(&m_cs);

    hr = HrSendCommand((LPSTR) NNTP_DATE_CRLF, NULL);
    if (SUCCEEDED(hr))
        m_state = NS_DATE;

    LeaveCriticalSection(&m_cs);

    return (hr);
    }

HRESULT CNNTPTransport::CommandMODE(LPSTR pszMode)
    {
    HRESULT hr;

    // Make sure the caller provided a mode command to send
    if (!pszMode || (pszMode && !*pszMode))
        return (E_INVALIDARG);

    EnterCriticalSection(&m_cs);

    hr = HrSendCommand((LPSTR) NNTP_MODE, pszMode);
    if (SUCCEEDED(hr))
        m_state = NS_MODE;

    LeaveCriticalSection(&m_cs);

    return (hr);
    }

HRESULT CNNTPTransport::CommandXHDR(LPSTR pszHeader, LPRANGE pRange, LPSTR pszMessageId)
    {
    HRESULT hr = S_OK;
    LPSTR   pszArgs = 0;
    DWORD   cc = 0; 

    // You can't specify BOTH a range and a message id
    if (pRange && pszMessageId)
        return (E_INVALIDARG);

    if (!pszHeader)
        return (E_INVALIDARG);

    // Make sure the range information is valid
    if (pRange)
        {
        if ((pRange->idType != RT_SINGLE && pRange->idType != RT_RANGE) || 
            pRange->dwFirst == 0 || 
            (pRange->idType == RT_RANGE && pRange->dwLast < pRange->dwFirst))
            return (E_INVALIDARG);
        }

    // Allocate a string for the arguments
    cc = 32 + lstrlen(pszHeader) + (pszMessageId ? lstrlen(pszMessageId) : 0);
    if (!MemAlloc((LPVOID*) &pszArgs, cc))
        {
        OnError(E_OUTOFMEMORY);
        return (E_OUTOFMEMORY);
        }

    EnterCriticalSection(&m_cs);

    // Handle the message-id case first 
    if (pszMessageId)
        {
        wnsprintf(pszArgs, cc, "%s %s", pszHeader, pszMessageId);
        hr = HrSendCommand((LPSTR) NNTP_XHDR, pszArgs);
        }
    else if (pRange)
        {
        // Range case
        if (pRange->idType == RT_SINGLE)
            {
            wnsprintf(pszArgs, cc, "%s %ld", pszHeader, pRange->dwFirst);
            hr = HrSendCommand((LPSTR) NNTP_XHDR, pszArgs);
            }
        else if (pRange->idType == RT_RANGE)
            {
            wnsprintf(pszArgs, cc, "%s %ld-%ld", pszHeader, pRange->dwFirst, pRange->dwLast);
            hr = HrSendCommand((LPSTR) NNTP_XHDR, pszArgs);
            }
        }
    else
        {
        // Current article case
        hr = HrSendCommand((LPSTR) NNTP_XHDR, pszHeader);
        }

    // If we succeeded to send the command to the server, then update our state
    // to receive the response from the XHDR command
    if (SUCCEEDED(hr))
        {
        m_state = NS_XHDR;
        m_substate = NS_RESP;
        }

    LeaveCriticalSection(&m_cs);
    SafeMemFree(pszArgs);

    return (hr);
    }

HRESULT CNNTPTransport::CommandQUIT(void)
    {
    HRESULT hr = IXP_E_NOT_CONNECTED;

    EnterCriticalSection(&m_cs);

    // Make sure we're actually connected to the server
    if (m_state != NS_DISCONNECTED && m_state != NS_CONNECT || (m_state == NS_CONNECT && m_substate != NS_RECONNECTING))
        {
        // Send the QUIT command to the server
        hr = HrSendCommand((LPSTR) NNTP_QUIT_CRLF, NULL);
        if (SUCCEEDED(hr))
            m_state = NS_QUIT;        
        }

    LeaveCriticalSection(&m_cs);

    return (hr);
    }

HRESULT CNNTPTransport::GetHeaders(LPRANGE pRange)
    {
    HRESULT hr;
    char    szRange[32];
    
    // Make sure the range information is valid
    if (!pRange)
        return (E_INVALIDARG);

    if ((pRange->idType != RT_SINGLE && pRange->idType != RT_RANGE) || 
        pRange->dwFirst == 0 || 
        (pRange->idType == RT_RANGE && pRange->dwLast < pRange->dwFirst))
        return (E_INVALIDARG);

    if (pRange->idType == RT_SINGLE)
        pRange->dwLast = pRange->dwFirst;

    // In case XOVER isn't supported on this server, we'll store this range so
    // we can try XHDR instead.
    m_rRange = *pRange;

    // Check to see if we know that XOVER will fail
    if (m_fNoXover)
        {
        return (BuildHeadersFromXhdr(TRUE));
        }

    EnterCriticalSection(&m_cs);

    // If dwLast == 0, then the person is requesting a single record, otherwise
    // the person is requesting a range.  Build the commands appropriately.
    if (RT_RANGE == pRange->idType)
        wnsprintf(szRange, ARRAYSIZE(szRange), "%s %lu-%lu\r\n", NNTP_XOVER, pRange->dwFirst, pRange->dwLast);
    else
        wnsprintf(szRange, ARRAYSIZE(szRange), "%s %lu\r\n", NNTP_XOVER, pRange->dwFirst);

    hr = HrSendCommand(szRange, NULL);
    if (SUCCEEDED(hr))
        {
        m_state = NS_HEADERS;
        m_substate = NS_RESP;
        m_gethdr = GETHDR_XOVER;
        }

    LeaveCriticalSection(&m_cs);
    return (hr);
    }


HRESULT CNNTPTransport::ReleaseResponse(LPNNTPRESPONSE pResp)
    {
    HRESULT hr = S_OK;
    DWORD   i;

    // First double check to see if this even needs to be released
    if (FALSE == pResp->fMustRelease)
        return (S_FALSE);

    switch (pResp->state)
        {
        case NS_GROUP:
            SafeMemFree(pResp->rGroup.pszGroup);
            break;

        case NS_LAST:
            SafeMemFree(pResp->rLast.pszMessageId);
            break;

        case NS_NEXT:
            SafeMemFree(pResp->rNext.pszMessageId);
            break;

        case NS_STAT:
            SafeMemFree(pResp->rStat.pszMessageId);
            break;

        case NS_ARTICLE:
            SafeMemFree(pResp->rArticle.pszMessageId);
            SafeMemFree(pResp->rArticle.pszLines);
            break;

        case NS_HEAD:
            SafeMemFree(pResp->rHead.pszMessageId);
            SafeMemFree(pResp->rHead.pszLines);
            break;

        case NS_BODY:
            SafeMemFree(pResp->rBody.pszMessageId);
            SafeMemFree(pResp->rBody.pszLines);
            break;

        case NS_NEWGROUPS:
            // Since the response here is just one buffer, then we can just
            // free the first line and all the others will be freed as well.
            if (pResp->rNewgroups.rgszLines)
                {
                SafeMemFree(pResp->rNewgroups.rgszLines[0]);
                MemFree(pResp->rNewgroups.rgszLines);
                }
            break;

        case NS_LIST:
            // Since the response here is just one buffer, then we can just
            // free the first line and all the others will be freed as well.
            if (pResp->rList.rgszLines)
                {
                MemFree(pResp->rList.rgszLines[0]);
                MemFree(pResp->rList.rgszLines);
                }
            break;

        case NS_LISTGROUP:
            SafeMemFree(pResp->rListGroup.rgArticles);
            break;

        case NS_HEADERS:
            {
            // This frees the memory that contains all of the
            PMEMORYINFO pMemInfo = (PMEMORYINFO) pResp->rHeaders.dwReserved;

            for (UINT i = 0; i < pMemInfo->cPointers; i++)
                SafeMemFree(pMemInfo->rgPointers[i]);
            SafeMemFree(pMemInfo);

            // This frees the array that pointed to the parsed xhdr responses
            SafeMemFree(pResp->rHeaders.rgHeaders);
            break;
            }

        case NS_XHDR:
            {
            // This frees the memory that contains all of the
            PMEMORYINFO pMemInfo = (PMEMORYINFO) pResp->rXhdr.dwReserved;
            SafeMemFree(pMemInfo->rgPointers[0]);
            SafeMemFree(pMemInfo);

            // This frees the array that pointed to the parsed xhdr responses
            SafeMemFree(pResp->rXhdr.rgHeaders);
            break;
            }

        default:
            // If we get here that means one of two things:
            // (1) the user messed with pResp->fMustRelease flag and is an idiot
            // (2) Somewhere in the transport we set fMustRelease when we didn't
            //     actually return data that needs to be freed.  This is bad and
            //     should be tracked.
            IxpAssert(FALSE);
        }

    return (hr);
    }


HRESULT CNNTPTransport::BuildHeadersFromXhdr(BOOL fFirst)
    {
    HRESULT      hr = S_OK;
    DWORD        cHeaders;
    BOOL         fDone = FALSE;
    
    if (fFirst)
        {
        // Set the header retrieval type
        m_gethdr = GETHDR_XHDR;
        m_fNoXover = TRUE;
        m_cHeaders = 0;

        // Get the first range of headers to retrieve
        m_rRangeCur.dwFirst = m_rRange.dwFirst;
        m_rRangeCur.dwLast = min(m_rRange.dwLast, m_rRangeCur.dwFirst + NUM_HEADERS);

        cHeaders = m_rRangeCur.dwLast - m_rRangeCur.dwFirst + 1;

        // Allocate an array for the headers
        Assert(m_rgHeaders == 0);

        if (!MemAlloc((LPVOID*) &m_rgHeaders, cHeaders * sizeof(NNTPHEADER)))
            {
            SafeMemFree(m_pMemInfo);
            OnError(E_OUTOFMEMORY);
            DispatchResponse(E_OUTOFMEMORY);
            return (E_OUTOFMEMORY);
            }
        ZeroMemory(m_rgHeaders, cHeaders * sizeof(NNTPHEADER));

        // Set the state correctly
        m_hdrtype = HDR_SUBJECT;
        
        // Issue first request
        hr = SendNextXhdrCommand();
        }
    else
        {
        Assert(m_substate == NS_DATA);

        // Parse the data and add it to our array
        hr = ProcessNextXhdrResponse(&fDone);

        // fDone will be TRUE when we've received all the data from the 
        // preceeding request.  
        if (fDone)
            {
            // If there are still headers left to retrieve, then advance the
            // header type state and issue the next command.
            if (m_hdrtype < HDR_XREF)
                {
                m_hdrtype++;

                // issue command
                hr = SendNextXhdrCommand();
                }
            else
                {
                // All done with this batch.  Send the response to the caller.
                NNTPRESPONSE rResp;
                ZeroMemory(&rResp, sizeof(NNTPRESPONSE));
                rResp.rHeaders.cHeaders = m_cHeaders;
                rResp.rHeaders.rgHeaders = m_rgHeaders;
                rResp.rHeaders.fSupportsXRef = TRUE;
                rResp.rHeaders.dwReserved = (DWORD_PTR) m_pMemInfo;
                rResp.fMustRelease = TRUE;

                // It's the caller's responsibility to free this now
                m_rgHeaders = NULL;
                m_cHeaders = 0;
                m_pMemInfo = 0;
                
                // If these are equal, then we've retrieved all of the headers
                // that were requested
                if (m_rRange.dwLast == m_rRangeCur.dwLast)
                    {
                    rResp.fDone = TRUE;
                    DispatchResponse(S_OK, TRUE, &rResp);
                    }
                else
                    {
                    rResp.fDone = FALSE;
                    DispatchResponse(S_OK, FALSE, &rResp);

                    // There are headers we haven't retrieved yet.  Go ahead
                    // and issue the next group of xhdrs.
                    m_rRange.dwFirst = m_rRangeCur.dwLast + 1;
                    Assert(m_rRange.dwFirst <= m_rRange.dwLast);
                    BuildHeadersFromXhdr(TRUE);
                    }
                
                }
            }
        }

    return (hr);
    }


HRESULT CNNTPTransport::SendNextXhdrCommand(void)
    {
    char    szTemp[256];
    HRESULT hr;

    LPCSTR  c_rgHdr[HDR_MAX] = { NNTP_HDR_SUBJECT,   
                                 NNTP_HDR_FROM,      
                                 NNTP_HDR_DATE,      
                                 NNTP_HDR_MESSAGEID, 
                                 NNTP_HDR_REFERENCES,
                                 NNTP_HDR_LINES,   
                                 NNTP_HDR_XREF };

    // Build the command string to send to the server
    wnsprintf(szTemp, ARRAYSIZE(szTemp), "%s %s %ld-%ld\r\n", NNTP_XHDR, c_rgHdr[m_hdrtype],
             m_rRangeCur.dwFirst, m_rRangeCur.dwLast);

    EnterCriticalSection(&m_cs);

    // Send the command to the server
    hr = HrSendCommand(szTemp, NULL, FALSE);
    if (SUCCEEDED(hr))
        {
        m_state = NS_HEADERS;
        m_substate = NS_RESP;
        m_iHeader = 0;
        }

    LeaveCriticalSection(&m_cs);

    return (hr);
    }

HRESULT CNNTPTransport::ProcessNextXhdrResponse(BOOL* pfDone)
    {
    HRESULT             hr;
    LPSTR               pszLines = NULL;
    LPSTR               pszNextLine = NULL;
    LPSTR               pszField = NULL;
    LPSTR               pszNextField = NULL;
    int                 iRead, iLines;
    DWORD               dwTemp;

    // Read the data that is waiting on the socket
    if (SUCCEEDED(hr = m_pSocket->ReadLines(&pszLines, &iRead, &iLines)))
        {
        // Realloc our array of pointers to free and add this pszLines to the end
        if (m_pMemInfo)
            {
            if (MemRealloc((LPVOID*) &m_pMemInfo, sizeof(MEMORYINFO) 
                           + (((m_pMemInfo ? m_pMemInfo->cPointers : 0) + 1) * sizeof(LPVOID))))
                {
                m_pMemInfo->rgPointers[m_pMemInfo->cPointers] = (LPVOID) pszLines;
                m_pMemInfo->cPointers++;            
                }
            }
        else
            {
            if (MemAlloc((LPVOID*) &m_pMemInfo, sizeof(MEMORYINFO)))
                {
                m_pMemInfo->rgPointers[0] = pszLines;
                m_pMemInfo->cPointers = 1;
                }
            }

        // Loop until we either run out of lines or we find a line that begins 
        // with "."
        pszNextLine = pszLines;
        while (*pszNextLine && *pszNextLine != '.')
            {
            pszField = pszNextLine;

            // Scan ahead and find the end of the line
            while (*pszNextLine)
                {
                if (*pszNextLine == '\n')
                    {
                    // NULL out a CR followed by a LF
                    if (pszNextLine > pszField && *(pszNextLine - 1) == '\r')
                        *(pszNextLine - 1) = 0;

                    // NULL out and skip over the LF
                    *pszNextLine++ = 0;
                    break;
                    }
                pszNextLine++;
                }

            // Parse the article number
            if (m_hdrtype == HDR_SUBJECT)
                {
                m_rgHeaders[m_iHeader].dwArticleNum = StrToInt(pszField);
                m_cHeaders++;
                }
            else
                {
                // Make sure this field matches the header that's next in the array
                if (m_rgHeaders[m_iHeader].dwArticleNum != (DWORD) StrToInt(pszField))
                    {
                    dwTemp = m_iHeader;

                    // If the number is less, then we can loop until we find it
                    while (m_iHeader < (m_rRangeCur.dwLast - m_rRangeCur.dwFirst) && 
                           m_rgHeaders[m_iHeader].dwArticleNum < (DWORD) StrToInt(pszField))
                        {
                        m_iHeader++;
                        }

                    // We never found a matching header, so we should consider this record
                    // bogus.
                    if (m_iHeader >= (m_rRangeCur.dwLast - m_rRangeCur.dwFirst + 1))
                        {
                        IxpAssert(0);
                        m_iHeader = dwTemp;
                        goto BadRecord;
                        }
                    }
                }    

            // Find the seperating space
            while (*pszField && *pszField != ' ')
                pszField++;

            // Advance past the space
            if (*pszField)
                pszField++;

            // Parse the actual data field into our header array.  Make 
            // the beginning of the header point to the first character 
            // after the space.
            switch (m_hdrtype)
                {
                case HDR_SUBJECT:
                    m_rgHeaders[m_iHeader].pszSubject = pszField;
                    break;

                case HDR_FROM:
                    m_rgHeaders[m_iHeader].pszFrom = pszField;
                    break;

                case HDR_DATE:
                    m_rgHeaders[m_iHeader].pszDate = pszField;
                    break;

                case HDR_MSGID:
                    m_rgHeaders[m_iHeader].pszMessageId = pszField;
                    break;

                case HDR_REFERENCES:
                    m_rgHeaders[m_iHeader].pszReferences = pszField;
                    break;

                case HDR_LINES:
                    m_rgHeaders[m_iHeader].dwLines = StrToInt(pszField);
                    break;

                case HDR_XREF:
                    m_rgHeaders[m_iHeader].pszXref = pszField;
                    break;

                default:
                    // How the heck do we get here?
                    IxpAssert(0);
                }

            m_iHeader++;

BadRecord:
            ;
            }

        // We've reached the end of the list, otherwise there is more data
        // expected.
        *pfDone = (*pszNextLine == '.');
        return (S_OK);
        }

    return (hr);    
    }


HRESULT CNNTPTransport::HrPostMessage(void)
    {
    HRESULT hr;
    int     cbSent = 0;

    EnterCriticalSection(&m_cs);
    hr = m_pSocket->SendStream(m_rMessage.pstmMsg, &cbSent, TRUE);
    SafeRelease(m_rMessage.pstmMsg);
    LeaveCriticalSection(&m_cs);

    return (hr);
    }

//***************************************************************************
// Function: SetWindow
//
// Purpose:
//   This function creates the current window handle for async winsock process.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
STDMETHODIMP CNNTPTransport::SetWindow(void)
{
	HRESULT hr;
	
    Assert(NULL != m_pSocket);

    if(m_pSocket)
    	hr= m_pSocket->SetWindow();
    else
    	hr= E_UNEXPECTED;
    	
    return hr;
}

//***************************************************************************
// Function: ResetWindow
//
// Purpose:
//   This function closes the current window handle for async winsock process.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
STDMETHODIMP CNNTPTransport::ResetWindow(void)
{
	HRESULT hr;
	
    Assert(NULL != m_pSocket);

	if(m_pSocket)
		hr= m_pSocket->ResetWindow();
	else
		hr= E_UNEXPECTED;
 
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\ixphttpm.cpp ===
// --------------------------------------------------------------------------------
// Ixphttpm.cpp
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved
// Greg Friedman
// --------------------------------------------------------------------------------

#include "pch.hxx"
#include "dllmain.h"
#include "ixphttpm.h"
#include "wininet.h"
#include "ocidl.h"
#include "Vstream.h"
#include "shlwapi.h"
#include "htmlstr.h"
#include "strconst.h"
#include "propfind.h"
#include "davparse.h"
#include "davstrs.h"
#include <ntverp.h>
#include <process.h>
#include "oleutil.h"
#include "ixputil.h"
#include <demand.h>

extern HRESULT HrGetLastError(void);

typedef struct tagHTTPERROR
{
    DWORD   dwHttpError;
    HRESULT ixpResult;
} HTTPERROR, *LPHTTPERROR;

static const HTTPERROR c_rgHttpErrorMap[] =
{
    { HTTP_STATUS_USE_PROXY, IXP_E_HTTP_USE_PROXY },
    { HTTP_STATUS_BAD_REQUEST, IXP_E_HTTP_BAD_REQUEST  },
    { HTTP_STATUS_DENIED, IXP_E_HTTP_UNAUTHORIZED },
    { HTTP_STATUS_FORBIDDEN, IXP_E_HTTP_FORBIDDEN },
    { HTTP_STATUS_NOT_FOUND, IXP_E_HTTP_NOT_FOUND },
    { HTTP_STATUS_BAD_METHOD, IXP_E_HTTP_METHOD_NOT_ALLOW },
    { HTTP_STATUS_NONE_ACCEPTABLE, IXP_E_HTTP_NOT_ACCEPTABLE },
    { HTTP_STATUS_PROXY_AUTH_REQ, IXP_E_HTTP_PROXY_AUTH_REQ },
    { HTTP_STATUS_REQUEST_TIMEOUT, IXP_E_HTTP_REQUEST_TIMEOUT },
    { HTTP_STATUS_CONFLICT, IXP_E_HTTP_CONFLICT },
    { HTTP_STATUS_GONE, IXP_E_HTTP_GONE },
    { HTTP_STATUS_LENGTH_REQUIRED, IXP_E_HTTP_LENGTH_REQUIRED },
    { HTTP_STATUS_PRECOND_FAILED, IXP_E_HTTP_PRECOND_FAILED },
    { HTTP_STATUS_SERVER_ERROR, IXP_E_HTTP_INTERNAL_ERROR },
    { HTTP_STATUS_NOT_SUPPORTED, IXP_E_HTTP_NOT_IMPLEMENTED },
    { HTTP_STATUS_BAD_GATEWAY, IXP_E_HTTP_BAD_GATEWAY },
    { HTTP_STATUS_SERVICE_UNAVAIL, IXP_E_HTTP_SERVICE_UNAVAIL },
    { HTTP_STATUS_GATEWAY_TIMEOUT, IXP_E_HTTP_GATEWAY_TIMEOUT },
    { HTTP_STATUS_VERSION_NOT_SUP, IXP_E_HTTP_VERS_NOT_SUP },
    { 425, IXP_E_HTTP_INSUFFICIENT_STORAGE },   // obsolete out of storage error
    { 507, IXP_E_HTTP_INSUFFICIENT_STORAGE },   // preferred out of storage error
    { ERROR_INTERNET_OUT_OF_HANDLES, E_OUTOFMEMORY },
    { ERROR_INTERNET_TIMEOUT, IXP_E_TIMEOUT },
    { ERROR_INTERNET_NAME_NOT_RESOLVED, IXP_E_CANT_FIND_HOST },
    { ERROR_INTERNET_CANNOT_CONNECT, IXP_E_FAILED_TO_CONNECT },
    { HTTP_STATUS_NOT_MODIFIED, IXP_E_HTTP_NOT_MODIFIED},
};

#define FAIL_ABORT \
    if (WasAborted()) \
    { \
        hr = TrapError(IXP_E_USER_CANCEL); \
        goto exit; \
    } \
    else

#define FAIL_EXIT_STREAM_WRITE(stream, psz) \
    if (FAILED(hr = stream.Write(psz, lstrlen(psz), NULL))) \
        goto exit; \
    else

#define FAIL_EXIT(hr) \
    if (FAILED(hr)) \
        goto exit; \
    else

#define FAIL_CREATEWND \
    if (!m_hwnd && !CreateWnd()) \
    { \
        hr = TrapError(E_OUTOFMEMORY); \
        goto exit;  \
    } \
    else
    
// these arrays describe element stack states, and are used to asses
// the current state of the element stack
static const HMELE c_rgPropFindPropStatStack[] =
{
    HMELE_DAV_MULTISTATUS,
    HMELE_DAV_RESPONSE,
    HMELE_DAV_PROPSTAT    
};

static const HMELE c_rgPropFindPropValueStack[] = 
{
    HMELE_DAV_MULTISTATUS,
    HMELE_DAV_RESPONSE,
    HMELE_DAV_PROPSTAT,
    HMELE_DAV_PROP,
    HMELE_UNKNOWN   // wildcard
};

static const HMELE c_rgPropFindResponseStack[] =
{
    HMELE_DAV_MULTISTATUS,
    HMELE_DAV_RESPONSE
};

static const HMELE c_rgMultiStatusResponseChildStack[] =
{
    HMELE_DAV_MULTISTATUS,
    HMELE_DAV_RESPONSE,
    HMELE_UNKNOWN
};

static const HMELE c_rgPropFindStatusStack[] =
{
    HMELE_DAV_MULTISTATUS,
    HMELE_DAV_RESPONSE,
    HMELE_DAV_PROPSTAT,
    HMELE_DAV_STATUS
}; 
// GET command
static const PFNHTTPMAILOPFUNC c_rgpfGet[] = 
{
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessGetResponse,
    &CHTTPMailTransport::FinalizeRequest
};

// DELETE command
static const PFNHTTPMAILOPFUNC c_rgpfDelete[] = 
{
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::FinalizeRequest
};

// PROPPATCH command
static const PFNHTTPMAILOPFUNC c_rgpfnPropPatch[] =
{
    &CHTTPMailTransport::GeneratePropPatchXML,
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::FinalizeRequest
};

// MKCOL command
static const PFNHTTPMAILOPFUNC c_rgpfnMkCol[] =
{
    &CHTTPMailTransport::OpenRequest,
	&CHTTPMailTransport::AddCharsetLine,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessCreatedResponse,
    &CHTTPMailTransport::ProcessLocationResponse,
    &CHTTPMailTransport::FinalizeRequest
};

// COPY command
static const PFNHTTPMAILOPFUNC c_rgpfnCopy[] =
{
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddDestinationHeader,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessCreatedResponse,
    &CHTTPMailTransport::ProcessLocationResponse,
    &CHTTPMailTransport::FinalizeRequest
};

// MOVE command
static const PFNHTTPMAILOPFUNC c_rgpfnMove[] =
{
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddDestinationHeader,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessCreatedResponse,
    &CHTTPMailTransport::ProcessLocationResponse,
    &CHTTPMailTransport::FinalizeRequest
};

// BMOVE command (data applies to bcopy and bmove)

#define BCOPYMOVE_MAXRESPONSES  10

XP_BEGIN_SCHEMA(HTTPMAILBCOPYMOVE)
    XP_SCHEMA_COL(HMELE_DAV_HREF, XPCF_MSVALIDMSRESPONSECHILD, XPCDT_STRA, HTTPMAILBCOPYMOVE, pszHref)
    XP_SCHEMA_COL(HMELE_DAV_LOCATION, XPCF_MSVALIDMSRESPONSECHILD, XPCDT_STRA, HTTPMAILBCOPYMOVE, pszLocation)
    XP_SCHEMA_COL(HMELE_DAV_STATUS, XPCF_MSVALIDMSRESPONSECHILD, XPCDT_IXPHRESULT, HTTPMAILBCOPYMOVE, hrResult)
XP_END_SCHEMA

static const PFNHTTPMAILOPFUNC c_rgpfnBMove[] =
{
    &CHTTPMailTransport::InitBCopyMove,
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddDestinationHeader,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessXMLResponse,
    &CHTTPMailTransport::FinalizeRequest
};

static const XMLPARSEFUNCS c_rgpfnBCopyMoveParse[] =
{
    &CHTTPMailTransport::CreateElement,
    &CHTTPMailTransport::BCopyMove_HandleText,
    &CHTTPMailTransport::BCopyMove_EndChildren
};

// MemberInfo Data. There are four schemas associated with this command.
// The first three are used to build up the propfind request, and are
// not used to parse responses. The fourth is the combined schema that
// is used for parsing.
//
// THE FOURTH SCHEMA MUST BE KEPT IN SYNC WITH THE FIRST THREE TO
// GUARANTEE THAT RESPONSES WILL BE PARSED CORRECTLY.

#define MEMBERINFO_MAXRESPONSES    10

// common property schema - used only for building the request
XP_BEGIN_SCHEMA(HTTPMEMBERINFO_COMMON)
    // common properties
    XP_SCHEMA_COL(HMELE_DAV_HREF, XPCF_PROPFINDHREF, XPCDT_STRA, HTTPMEMBERINFO, pszHref)
    XP_SCHEMA_COL(HMELE_DAV_ISFOLDER, XPFC_PROPFINDPROP, XPCDT_BOOL, HTTPMEMBERINFO, fIsFolder)
XP_END_SCHEMA

// folder property schema - used only for building the request
XP_BEGIN_SCHEMA(HTTPMEMBERINFO_FOLDER)
    XP_SCHEMA_COL(HMELE_DAV_DISPLAYNAME, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPMEMBERINFO, pszDisplayName)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_SPECIAL, XPFC_PROPFINDPROP, XPCDT_HTTPSPECIALFOLDER, HTTPMEMBERINFO, tySpecial)    
    XP_SCHEMA_COL(HMELE_DAV_HASSUBS, XPFC_PROPFINDPROP, XPCDT_BOOL, HTTPMEMBERINFO, fHasSubs)
    XP_SCHEMA_COL(HMELE_DAV_NOSUBS, XPFC_PROPFINDPROP, XPCDT_BOOL, HTTPMEMBERINFO, fNoSubs)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_UNREADCOUNT, XPFC_PROPFINDPROP, XPCDT_DWORD, HTTPMEMBERINFO, dwUnreadCount)
    XP_SCHEMA_COL(HMELE_DAV_VISIBLECOUNT, XPFC_PROPFINDPROP, XPCDT_DWORD, HTTPMEMBERINFO, dwVisibleCount)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_SPECIAL, XPFC_PROPFINDPROP, XPCDT_HTTPSPECIALFOLDER, HTTPMEMBERINFO, tySpecial)    
XP_END_SCHEMA

// message property schema - used only for building the request
XP_BEGIN_SCHEMA(HTTPMEMBERINFO_MESSAGE)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_READ, XPFC_PROPFINDPROP, XPCDT_BOOL, HTTPMEMBERINFO, fRead)
    XP_SCHEMA_COL(HMELE_MAIL_HASATTACHMENT, XPFC_PROPFINDPROP, XPCDT_BOOL, HTTPMEMBERINFO, fHasAttachment)
    XP_SCHEMA_COL(HMELE_MAIL_TO, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPMEMBERINFO, pszTo)
    XP_SCHEMA_COL(HMELE_MAIL_FROM, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPMEMBERINFO, pszFrom)
    XP_SCHEMA_COL(HMELE_MAIL_SUBJECT, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPMEMBERINFO, pszSubject)
    XP_SCHEMA_COL(HMELE_MAIL_DATE, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPMEMBERINFO, pszDate)
    XP_SCHEMA_COL(HMELE_DAV_GETCONTENTLENGTH, XPFC_PROPFINDPROP, XPCDT_DWORD, HTTPMEMBERINFO, dwContentLength)
XP_END_SCHEMA

// combined schema - used for parsing responses
XP_BEGIN_SCHEMA(HTTPMEMBERINFO)
    // common properties
    XP_SCHEMA_COL(HMELE_DAV_HREF, XPCF_PROPFINDHREF, XPCDT_STRA, HTTPMEMBERINFO, pszHref)
    XP_SCHEMA_COL(HMELE_DAV_ISFOLDER, XPFC_PROPFINDPROP, XPCDT_BOOL, HTTPMEMBERINFO, fIsFolder)

    // folder properties    
    XP_SCHEMA_COL(HMELE_DAV_DISPLAYNAME, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPMEMBERINFO, pszDisplayName)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_SPECIAL, XPFC_PROPFINDPROP, XPCDT_HTTPSPECIALFOLDER, HTTPMEMBERINFO, tySpecial)    
    XP_SCHEMA_COL(HMELE_DAV_HASSUBS, XPFC_PROPFINDPROP, XPCDT_BOOL, HTTPMEMBERINFO, fHasSubs)
    XP_SCHEMA_COL(HMELE_DAV_NOSUBS, XPFC_PROPFINDPROP, XPCDT_BOOL, HTTPMEMBERINFO, fNoSubs)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_UNREADCOUNT, XPFC_PROPFINDPROP, XPCDT_DWORD, HTTPMEMBERINFO, dwUnreadCount)
    XP_SCHEMA_COL(HMELE_DAV_VISIBLECOUNT, XPFC_PROPFINDPROP, XPCDT_DWORD, HTTPMEMBERINFO, dwVisibleCount)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_SPECIAL, XPFC_PROPFINDPROP, XPCDT_HTTPSPECIALFOLDER, HTTPMEMBERINFO, tySpecial)    

    // message properties
    XP_SCHEMA_COL(HMELE_HTTPMAIL_READ, XPFC_PROPFINDPROP, XPCDT_BOOL, HTTPMEMBERINFO, fRead)
    XP_SCHEMA_COL(HMELE_MAIL_HASATTACHMENT, XPFC_PROPFINDPROP, XPCDT_BOOL, HTTPMEMBERINFO, fHasAttachment)
    XP_SCHEMA_COL(HMELE_MAIL_TO, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPMEMBERINFO, pszTo)
    XP_SCHEMA_COL(HMELE_MAIL_FROM, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPMEMBERINFO, pszFrom)
    XP_SCHEMA_COL(HMELE_MAIL_SUBJECT, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPMEMBERINFO, pszSubject)
    XP_SCHEMA_COL(HMELE_MAIL_DATE, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPMEMBERINFO, pszDate)
    XP_SCHEMA_COL(HMELE_DAV_GETCONTENTLENGTH, XPFC_PROPFINDPROP, XPCDT_DWORD, HTTPMEMBERINFO, dwContentLength)
XP_END_SCHEMA

static const XMLPARSEFUNCS c_rgpfnMemberInfoParse[] =
{
    &CHTTPMailTransport::CreateElement,
    &CHTTPMailTransport::MemberInfo_HandleText,
    &CHTTPMailTransport::MemberInfo_EndChildren
};

static const PFNHTTPMAILOPFUNC c_rgpfnMemberInfo[] =
{
    &CHTTPMailTransport::InitMemberInfo,
    &CHTTPMailTransport::GeneratePropFindXML,
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddDepthHeader,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessXMLResponse,
    &CHTTPMailTransport::RequireMultiStatus,
    &CHTTPMailTransport::FinalizeRequest
};
    
// Operations which share MemberError-based responses (MarkRead, BDELETE)


#define MEMBERERROR_MAXRESPONSES    10

XP_BEGIN_SCHEMA(HTTPMEMBERERROR)
    XP_SCHEMA_COL(HMELE_DAV_HREF, XPCF_PROPFINDHREF, XPCDT_STRA, HTTPMEMBERERROR, pszHref)
    XP_SCHEMA_COL(HMELE_DAV_STATUS, XPCF_MSVALIDMSRESPONSECHILD, XPCDT_IXPHRESULT, HTTPMEMBERERROR, hrResult)
XP_END_SCHEMA

static const XMLPARSEFUNCS c_rgpfnMemberErrorParse[] =
{
    &CHTTPMailTransport::CreateElement,
    &CHTTPMailTransport::MemberError_HandleText,
    &CHTTPMailTransport::MemberError_EndChildren
};

static const PFNHTTPMAILOPFUNC c_rgpfnMarkRead[] =
{
    &CHTTPMailTransport::InitMemberError,
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessXMLResponse,
    &CHTTPMailTransport::FinalizeRequest
};

// SendMessage

static const PFNHTTPMAILOPFUNC c_rgpfnSendMessage[] =
{
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddContentTypeHeader,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendPostRequest,
    &CHTTPMailTransport::ProcessPostResponse,
    &CHTTPMailTransport::FinalizeRequest
};

// RootProps

XP_BEGIN_SCHEMA(ROOTPROPS)
    XP_SCHEMA_COL(HMELE_HOTMAIL_ADBAR, XPFC_PROPFINDPROP, XPCDT_STRA, ROOTPROPS, pszAdbar)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_CONTACTS, XPFC_PROPFINDPROP, XPCDT_STRA, ROOTPROPS, pszContacts)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_INBOX, XPFC_PROPFINDPROP, XPCDT_STRA, ROOTPROPS, pszInbox)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_OUTBOX, XPFC_PROPFINDPROP, XPCDT_STRA, ROOTPROPS, pszOutbox)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_SENDMSG, XPFC_PROPFINDPROP, XPCDT_STRA, ROOTPROPS, pszSendMsg)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_SENTITEMS, XPFC_PROPFINDPROP, XPCDT_STRA, ROOTPROPS, pszSentItems)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_DELETEDITEMS, XPFC_PROPFINDPROP, XPCDT_STRA, ROOTPROPS, pszDeletedItems)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_DRAFTS, XPFC_PROPFINDPROP, XPCDT_STRA, ROOTPROPS, pszDrafts)
    XP_SCHEMA_COL(HMELE_HTTPMAIL_MSGFOLDERROOT, XPFC_PROPFINDPROP, XPCDT_STRA, ROOTPROPS, pszMsgFolderRoot)
    XP_SCHEMA_COL(HMELE_HOTMAIL_MAXPOLLINGINTERVAL, XPFC_PROPFINDPROP, XPCDT_DWORD, ROOTPROPS, dwMaxPollingInterval)
    XP_SCHEMA_COL(HMELE_HOTMAIL_SIG, XPFC_PROPFINDPROP, XPCDT_STRA, ROOTPROPS, pszSig)
XP_END_SCHEMA

static const XMLPARSEFUNCS c_rgpfnRootPropsParse[] =
{
    &CHTTPMailTransport::CreateElement,
    &CHTTPMailTransport::RootProps_HandleText,
    &CHTTPMailTransport::RootProps_EndChildren
};

static const PFNHTTPMAILOPFUNC c_rgpfnRootProps[] = 
{
    &CHTTPMailTransport::InitRootProps,
    &CHTTPMailTransport::GeneratePropFindXML,
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddDepthHeader,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessXMLResponse,
    &CHTTPMailTransport::FinalizeRootProps
};

static const PFNHTTPMAILOPFUNC c_rgpfnPost[] =
{
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddContentTypeHeader,
	&CHTTPMailTransport::AddCharsetLine,
    &CHTTPMailTransport::SendPostRequest,
    //&CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessPostResponse,
    &CHTTPMailTransport::FinalizeRequest
};

static const PFNHTTPMAILOPFUNC c_rgpfnPut[] = 
{
    &CHTTPMailTransport::OpenRequest,
	&CHTTPMailTransport::AddCharsetLine,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessPostResponse,
    &CHTTPMailTransport::FinalizeRequest
};

// ListContacts Data

#define LISTCONTACTS_MAXRESPONSES   10

XP_BEGIN_SCHEMA(HTTPCONTACTID)
    XP_SCHEMA_COL(HMELE_DAV_HREF, XPCF_PROPFINDHREF, XPCDT_STRA, HTTPCONTACTID, pszHref)
    XP_SCHEMA_COL(HMELE_DAV_ID, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTID, pszId)    
    XP_SCHEMA_COL(HMELE_CONTACTS_GROUP, XPFC_PROPFINDPROP, XPCDT_HTTPCONTACTTYPE, HTTPCONTACTID, tyContact)
    XP_SCHEMA_COL(HMELE_HOTMAIL_MODIFIED, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTID, pszModified)
XP_END_SCHEMA

static const PFNHTTPMAILOPFUNC c_rgpfnListContacts[] = 
{
    &CHTTPMailTransport::InitListContacts,
    &CHTTPMailTransport::GeneratePropFindXML,
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddDepthHeader,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessXMLResponse,
    &CHTTPMailTransport::RequireMultiStatus,
    &CHTTPMailTransport::FinalizeRequest
};

static const XMLPARSEFUNCS c_rgpfnListContactsParse[] =
{
    &CHTTPMailTransport::CreateElement,
    &CHTTPMailTransport::ListContacts_HandleText,
    &CHTTPMailTransport::ListContacts_EndChildren
};

// ContactInfo Data
#define CONTACTINFO_MAXRESPONSES   10

XP_BEGIN_SCHEMA(HTTPCONTACTINFO)
    XP_SCHEMA_COL(HMELE_DAV_HREF, XPCF_PROPFINDHREF, XPCDT_STRA, HTTPCONTACTINFO, pszHref)
    XP_SCHEMA_COL(HMELE_DAV_ID, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszId)    
    XP_SCHEMA_COL(HMELE_CONTACTS_GROUP, XPFC_PROPFINDPROP, XPCDT_HTTPCONTACTTYPE, HTTPCONTACTINFO, tyContact)
    XP_SCHEMA_COL(HMELE_HOTMAIL_MODIFIED, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszModified)
    XP_SCHEMA_COL(HMELE_CONTACTS_CN, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszDisplayName)
    XP_SCHEMA_COL(HMELE_CONTACTS_GIVENNAME, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszGivenName)
    XP_SCHEMA_COL(HMELE_CONTACTS_SN, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszSurname)
    XP_SCHEMA_COL(HMELE_CONTACTS_NICKNAME, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszNickname)
    XP_SCHEMA_COL(HMELE_CONTACTS_MAIL, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszEmail)
    XP_SCHEMA_COL(HMELE_CONTACTS_HOMESTREET, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszHomeStreet)
    XP_SCHEMA_COL(HMELE_CONTACTS_HOMECITY, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszHomeCity)
    XP_SCHEMA_COL(HMELE_CONTACTS_HOMESTATE, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszHomeState)
    XP_SCHEMA_COL(HMELE_CONTACTS_HOMEPOSTALCODE, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszHomePostalCode)
    XP_SCHEMA_COL(HMELE_CONTACTS_HOMECOUNTRY, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszHomeCountry)
    XP_SCHEMA_COL(HMELE_CONTACTS_O, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszCompany)
    XP_SCHEMA_COL(HMELE_CONTACTS_STREET, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszWorkStreet)
    XP_SCHEMA_COL(HMELE_CONTACTS_L, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszWorkCity)
    XP_SCHEMA_COL(HMELE_CONTACTS_ST, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszWorkState)
    XP_SCHEMA_COL(HMELE_CONTACTS_POSTALCODE, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszWorkPostalCode)
    XP_SCHEMA_COL(HMELE_CONTACTS_FRIENDLYCOUNTRYNAME, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszWorkCountry)
    XP_SCHEMA_COL(HMELE_CONTACTS_HOMEPHONE, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszHomePhone)
    XP_SCHEMA_COL(HMELE_CONTACTS_HOMEFAX, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszHomeFax)
    XP_SCHEMA_COL(HMELE_CONTACTS_TELEPHONENUMBER, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszWorkPhone)
    XP_SCHEMA_COL(HMELE_CONTACTS_FACSIMILETELEPHONENUMBER, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszWorkFax)
    XP_SCHEMA_COL(HMELE_CONTACTS_MOBILE, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszMobilePhone)
    XP_SCHEMA_COL(HMELE_CONTACTS_OTHERTELEPHONE, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszOtherPhone)
    XP_SCHEMA_COL(HMELE_CONTACTS_BDAY, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszBday)
    XP_SCHEMA_COL(HMELE_CONTACTS_PAGER, XPFC_PROPFINDPROP, XPCDT_STRA, HTTPCONTACTINFO, pszPager)
XP_END_SCHEMA

static const XMLPARSEFUNCS c_rgpfnContactInfoParse[] =
{
    &CHTTPMailTransport::CreateElement,
    &CHTTPMailTransport::ContactInfo_HandleText,
    &CHTTPMailTransport::ContactInfo_EndChildren
};

static const PFNHTTPMAILOPFUNC c_rgpfnContactInfo[] =
{
    &CHTTPMailTransport::InitContactInfo,
    &CHTTPMailTransport::GeneratePropFindXML,
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddDepthHeader,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessXMLResponse,
    &CHTTPMailTransport::FinalizeRequest
};

// PostContact Data
static const PFNHTTPMAILOPFUNC c_rgpfnPostContact[] =
{
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessPostContactResponse,
    &CHTTPMailTransport::InitListContacts,
    &CHTTPMailTransport::GeneratePropFindXML,
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddDepthHeader,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessXMLResponse,
    &CHTTPMailTransport::FinalizeRequest
};

static const XMLPARSEFUNCS c_rgpfnPostOrPatchContactParse[] =
{
    &CHTTPMailTransport::CreateElement,
    &CHTTPMailTransport::PostOrPatchContact_HandleText,
    &CHTTPMailTransport::PostOrPatchContact_EndChildren
};

// PatchContact data

static const PFNHTTPMAILOPFUNC c_rgpfnPatchContact[] =
{
    &CHTTPMailTransport::GeneratePropPatchXML,
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessPatchContactResponse,
    &CHTTPMailTransport::InitListContacts,
    &CHTTPMailTransport::GeneratePropFindXML,
    &CHTTPMailTransport::OpenRequest,
    &CHTTPMailTransport::AddDepthHeader,
    &CHTTPMailTransport::AddCommonHeaders,
    &CHTTPMailTransport::SendRequest,
    &CHTTPMailTransport::ProcessXMLResponse,
    &CHTTPMailTransport::FinalizeRequest
};

// special folders
typedef struct tagHTTPSPECIALFOLDER
{
    const WCHAR             *pwcName;
    ULONG                   ulLen;
    HTTPMAILSPECIALFOLDER   tyFolder;
} HTTPSPECIALFOLDER, *LPHTTPSPECIALFOLDER;

static const HTTPSPECIALFOLDER c_rgpfnSpecialFolder[] =
{
    { DAV_STR_LEN(InboxSpecialFolder), HTTPMAIL_SF_INBOX },
    { DAV_STR_LEN(DeletedItemsSpecialFolder), HTTPMAIL_SF_DELETEDITEMS },
    { DAV_STR_LEN(DraftsSpecialFolder), HTTPMAIL_SF_DRAFTS },
    { DAV_STR_LEN(OutboxSpecialFolder), HTTPMAIL_SF_OUTBOX },
    { DAV_STR_LEN(SentItemsSpecialFolder), HTTPMAIL_SF_SENTITEMS },
    { DAV_STR_LEN(ContactsSpecialFolder), HTTPMAIL_SF_CONTACTS },
    { DAV_STR_LEN(CalendarSpecialFolder), HTTPMAIL_SF_CALENDAR },
    { DAV_STR_LEN(MsnPromoSpecialFolder), HTTPMAIL_SF_MSNPROMO },
    { DAV_STR_LEN(BulkMailSpecialFolder), HTTPMAIL_SF_BULKMAIL },
};

#define VALIDSTACK(rg) ValidStack(rg, ARRAYSIZE(rg))

static const char s_szHTTPMailWndClass[] = "HTTPMailWndClass";

// Notification messages used to communicate between the async thread
// and the window proc
#define SPM_HTTPMAIL_STATECHANGED       (WM_USER + 1)
#define SPM_HTTPMAIL_SENDRESPONSE       (WM_USER + 2)
#define SPM_HTTPMAIL_LOGONPROMPT        (WM_USER + 3)
#define SPM_HTTPMAIL_GETPARENTWINDOW    (WM_USER + 4)

// --------------------------------------------------------------------------------
// static functions
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_HrCrackUrl
// --------------------------------------------------------------------------------

HRESULT HrCrackUrl(
                LPSTR pszUrl, 
                LPSTR *ppszHost, 
                LPSTR *ppszPath, 
                INTERNET_PORT *pPort)
{
    URL_COMPONENTS      uc;
    char                szHost[INTERNET_MAX_HOST_NAME_LENGTH];
    char                szPath[INTERNET_MAX_PATH_LENGTH];

    if (NULL == pszUrl)
        return E_INVALIDARG;

    if (ppszHost)
        *ppszHost = NULL;

    if (ppszPath)
        *ppszPath = NULL;

    if (pPort)
        *pPort = INTERNET_INVALID_PORT_NUMBER;

    ZeroMemory(&uc, sizeof(URL_COMPONENTS));
    uc.dwStructSize = sizeof(URL_COMPONENTS);
    uc.lpszHostName = szHost;
    uc.dwHostNameLength = INTERNET_MAX_HOST_NAME_LENGTH;
    uc.lpszUrlPath = szPath;
    uc.dwUrlPathLength = INTERNET_MAX_PATH_LENGTH;
    
    if (!InternetCrackUrl(pszUrl, NULL, 0, &uc))
        return E_INVALIDARG;

    // validate the protocol
    if (INTERNET_SCHEME_HTTP != uc.nScheme && INTERNET_SCHEME_HTTPS != uc.nScheme)
        return E_INVALIDARG;

    // copy the response data
    if (ppszHost)
    {
        *ppszHost = PszDupA(uc.lpszHostName);
        if (!*ppszHost)
            return E_OUTOFMEMORY;
    }

    if (ppszPath)
    {
        *ppszPath = PszDupA(uc.lpszUrlPath);
        if (!*ppszPath)
        {
            SafeMemFree(*ppszHost);
            return E_OUTOFMEMORY;
        }
    }

    if (pPort)
        *pPort = uc.nPort;

    return S_OK;
}

// --------------------------------------------------------------------------------
// Utility functions
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// HttpErrorToIxpResult
// --------------------------------------------------------------------------------
HRESULT HttpErrorToIxpResult(DWORD dwHttpError)
{
    for (DWORD dw = 0; dw < ARRAYSIZE(c_rgHttpErrorMap); dw++)
    {
        if (c_rgHttpErrorMap[dw].dwHttpError == dwHttpError)
            return c_rgHttpErrorMap[dw].ixpResult;
    }

    return E_FAIL;
}

// --------------------------------------------------------------------------------
// HrParseHTTPStatus
// --------------------------------------------------------------------------------
HRESULT HrParseHTTPStatus(LPSTR pszStatusStr, DWORD *pdwStatus)
{
    LPSTR   psz;
    LPSTR   pszEnd;
    char    chSaved;

    if (!pszStatusStr || !pdwStatus)
        return E_INVALIDARG;

    *pdwStatus = 0;

    // status is of the form "HTTP/1.1 200 OK"
    psz = PszSkipWhiteA(pszStatusStr);
    if ('\0' == *psz)
        return E_INVALIDARG;

    psz = PszScanToWhiteA(psz);
    if ('\0' == *psz)
        return E_INVALIDARG;

    psz = PszSkipWhiteA(psz);
    if ('\0' == *psz)
        return E_INVALIDARG;

    // psz now points at the numeric component
    pszEnd = PszScanToWhiteA(psz);
    if ('\0' == *psz)
        return E_INVALIDARG;
    
    // temporarily modify the string in place
    chSaved = *pszEnd;
    *pszEnd = '\0';
    
    *pdwStatus = StrToInt(psz);
    *pszEnd = chSaved;

    return S_OK;
}

// --------------------------------------------------------------------------------
// HrGetStreamSize
// --------------------------------------------------------------------------------
static HRESULT HrGetStreamSize(LPSTREAM pstm, ULONG *pcb)
{
    // Locals
    HRESULT hr=S_OK;
    ULARGE_INTEGER uliPos = {0,0};
    LARGE_INTEGER liOrigin = {0,0};

    // Seek
    hr = pstm->Seek(liOrigin, STREAM_SEEK_END, &uliPos);
    if (FAILED(hr))
        goto error;

    // set size
    *pcb = uliPos.LowPart;

error:
    // Done
    return hr;
}


// --------------------------------------------------------------------------------
// HrAddPropFindProps
// --------------------------------------------------------------------------------
HRESULT HrAddPropFindProps(IPropFindRequest *pRequest, const HMELE *rgEle, DWORD cEle)
{
    HRESULT     hr;
    HMELE       ele;

    for (DWORD i = 0; i < cEle; ++i)
    {
        ele = rgEle[i];
        hr = pRequest->AddProperty(
                        rgHTTPMailDictionary[ele].dwNamespaceID,
                        const_cast<char *>(rgHTTPMailDictionary[ele].pszName));
        if (FAILED(hr))
            goto exit;
    }

exit:

    return hr;
}

// --------------------------------------------------------------------------------
// HrAddPropFindSchemaProps
// --------------------------------------------------------------------------------
HRESULT HrAddPropFindSchemaProps(
                        IPropFindRequest *pRequest, 
                        const XPCOLUMN *prgCols, 
                        DWORD cCols)
{
    HRESULT     hr = S_OK;
    HMELE       ele;

    for (DWORD i = 0; i < cCols; i++)
    {
        if (!!(prgCols[i].dwFlags & XPCF_PFREQUEST))
        {
            hr = pRequest->AddProperty(
                            rgHTTPMailDictionary[prgCols[i].ele].dwNamespaceID,
                            rgHTTPMailDictionary[prgCols[i].ele].pszName);

            if (FAILED(hr))
                goto exit;
        }
    }

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// _HrGenerateRfc821Stream
// --------------------------------------------------------------------------------
HRESULT _HrGenerateRfc821Stream(LPCSTR pszFrom, 
                                LPHTTPTARGETLIST pTargets,
                                IStream **ppRfc821Stream)
{
    HRESULT     hr = S_OK;
    IStream     *pStream = NULL;
    DWORD       dw;
    DWORD       cbCloseTerm;
    DWORD       cbRcptTo;

    IxpAssert(pszFrom);
    IxpAssert(pTargets);
    IxpAssert(ppRfc821Stream);

    *ppRfc821Stream = NULL;

    cbCloseTerm = lstrlen(c_szXMLCloseElementCRLF);
    cbRcptTo = lstrlen(c_szRcptTo);

    pStream = new CVirtualStream();
    if (NULL == pStream)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    // write out 'mail from'
    FAIL_EXIT_STREAM_WRITE((*pStream), c_szMailFrom);
    FAIL_EXIT_STREAM_WRITE((*pStream), pszFrom);
    FAIL_EXIT(hr = pStream->Write(c_szXMLCloseElementCRLF, cbCloseTerm, NULL));

    // write out the 'rcpt to' lines
    for (dw = 0; dw < pTargets->cTarget; ++dw)
    {
        FAIL_EXIT(hr = pStream->Write(c_szRcptTo, cbRcptTo, NULL));
        FAIL_EXIT_STREAM_WRITE((*pStream), pTargets->prgTarget[dw]);
        FAIL_EXIT(hr = pStream->Write(c_szXMLCloseElementCRLF, cbCloseTerm, NULL));
    }

    // append an extra crlf to the end of the stream
    FAIL_EXIT_STREAM_WRITE((*pStream), c_szCRLF);
    
    *ppRfc821Stream = pStream;
    pStream = NULL;

exit:
    SafeRelease(pStream);
    return hr;
}

// --------------------------------------------------------------------------------
// _EscapeString
// --------------------------------------------------------------------------------
LPSTR   _EscapeString(LPSTR pszIn)
{
    CByteStream     stream;
    DWORD           dwLen;
    LPSTR           pszLastNonEsc, pszNext, pszOut;    
    HRESULT         hr;
    
    if (NULL == pszIn)
        return NULL;

    pszLastNonEsc = pszIn;
    pszNext = pszIn;

    while (*pszNext)
    {
        switch (*pszNext)
        {
            case '<':
            case '>':
            case '&':
                if (FAILED(hr = stream.Write(pszLastNonEsc, (ULONG) (pszNext - pszLastNonEsc), NULL)))
                    goto exit;

                if (*pszNext == '<')
                {
                    if (FAILED(hr = stream.Write(c_szEscLessThan, lstrlen(c_szEscLessThan), NULL)))
                        goto exit;
                }
                else if (*pszNext == '>')
                {
                    if (FAILED(hr = stream.Write(c_szEscGreaterThan, lstrlen(c_szEscGreaterThan), NULL)))
                        goto exit;
                }
                else
                {
                    if (FAILED(hr = stream.Write(c_szEscAmp, lstrlen(c_szEscAmp), NULL)))
                        goto exit;
                }
                pszLastNonEsc = CharNextExA(CP_ACP, pszNext, 0);
                break;
        }
        pszNext = CharNextExA(CP_ACP, pszNext, 0);
    }

    if (FAILED(hr = stream.Write(pszLastNonEsc, (ULONG) (pszNext - pszLastNonEsc), NULL)))
        goto exit;

    FAIL_EXIT(hr = stream.HrAcquireStringA(&dwLen, (LPSTR *)&pszOut, ACQ_DISPLACE));
    
    return pszOut;

exit:
    return NULL;
}

const HMELE g_rgContactEle[] = {
    HMELE_UNKNOWN,
    HMELE_UNKNOWN,
    HMELE_UNKNOWN,
    HMELE_UNKNOWN,
    HMELE_UNKNOWN,
    HMELE_CONTACTS_GIVENNAME,
    HMELE_CONTACTS_SN,
    HMELE_CONTACTS_NICKNAME,
    HMELE_CONTACTS_MAIL,
    HMELE_CONTACTS_HOMESTREET,
    HMELE_CONTACTS_HOMECITY,
    HMELE_CONTACTS_HOMESTATE,
    HMELE_CONTACTS_HOMEPOSTALCODE,
    HMELE_CONTACTS_HOMECOUNTRY,
    HMELE_CONTACTS_O,
    HMELE_CONTACTS_STREET,
    HMELE_CONTACTS_L,
    HMELE_CONTACTS_ST,
    HMELE_CONTACTS_POSTALCODE,
    HMELE_CONTACTS_FRIENDLYCOUNTRYNAME,
    HMELE_CONTACTS_HOMEPHONE,
    HMELE_CONTACTS_HOMEFAX,
    HMELE_CONTACTS_TELEPHONENUMBER,
    HMELE_CONTACTS_FACSIMILETELEPHONENUMBER,
    HMELE_CONTACTS_MOBILE,
    HMELE_CONTACTS_OTHERTELEPHONE,
    HMELE_CONTACTS_BDAY,
    HMELE_CONTACTS_PAGER
};

#define CCHMAX_TAGBUFFER    128

HRESULT HrGeneratePostContactXML(LPHTTPCONTACTINFO pciInfo, LPVOID *ppvXML, DWORD *pdwLen)
{
    HRESULT                 hr = S_OK;
    CByteStream             stream;
    CDAVNamespaceArbiterImp dna;
    DWORD                   dwIndex, dwSize = ARRAYSIZE(g_rgContactEle);
    DWORD                   iBufferSize;
    TCHAR                   szTagBuffer[CCHMAX_TAGBUFFER+1];
    LPSTR                  *prgsz = (LPSTR*)pciInfo, pszEsc;
    LPCSTR                  pszPropName;
    *ppvXML = NULL;
    *pdwLen = 0;

    if (NULL == ppvXML)
        return E_INVALIDARG;

    // write the DAV header. we ALWAYS post using the windows-1252 code
    // page for this release.
    if (FAILED(hr = stream.Write(c_szXML1252Head, lstrlen(c_szXML1252Head), NULL)))
        goto exit;

    dna.m_rgbNsUsed[DAVNAMESPACE_CONTACTS] = TRUE;
    dna.m_rgbNsUsed[DAVNAMESPACE_DAV] = TRUE;

    // write out the contacts header
    if (FAILED(hr = stream.Write(c_szContactHead, lstrlen(c_szContactHead), NULL)))
        goto exit;

    if (FAILED(hr = dna.WriteNamespaces(&stream)))
        goto exit;

    if (FAILED(hr = stream.Write(c_szXMLCloseElement, lstrlen(c_szXMLCloseElement), NULL)))
        goto exit;

    // [PaulHi] 3/11/99  Implementing WAB/HM group contact syncing
    // Include the xml group tag if this is a group contact item
    if (pciInfo->tyContact == HTTPMAIL_CT_GROUP)
    {
        if (FAILED(hr = stream.Write(c_szCRLFTab, lstrlen(c_szCRLFTab), NULL)))
            goto exit;
        if (FAILED(hr = stream.Write(c_szGroupSwitch, lstrlen(c_szGroupSwitch), NULL)))
            goto exit;
    }

    for (dwIndex = 0; dwIndex < dwSize; dwIndex ++)
    {
        if (prgsz[dwIndex] && g_rgContactEle[dwIndex] != HMELE_UNKNOWN)
        {
            pszPropName = rgHTTPMailDictionary[g_rgContactEle[dwIndex]].pszName;

            if (FAILED(hr = stream.Write(c_szOpenContactNamespace, lstrlen(c_szOpenContactNamespace), NULL)))
                goto exit;
    
            if (FAILED(hr = stream.Write(pszPropName, lstrlen(pszPropName), NULL)))
                goto exit;

            if (FAILED(hr = stream.Write(c_szXMLCloseElement, lstrlen(c_szXMLCloseElement), NULL)))
                goto exit;

            pszEsc = _EscapeString(prgsz[dwIndex]);

            if (!pszEsc)
                goto exit;

            hr = stream.Write(pszEsc, lstrlen(pszEsc), NULL);

            SafeMemFree(pszEsc);

            if (FAILED(hr))
                goto exit;
            
            if (FAILED(hr = stream.Write(c_szCloseContactNamespace, lstrlen(c_szCloseContactNamespace), NULL)))
                goto exit;
    
            if (FAILED(hr = stream.Write(pszPropName, lstrlen(pszPropName), NULL)))
                goto exit;

            if (FAILED(hr = stream.Write(c_szXMLCloseElement, lstrlen(c_szXMLCloseElement), NULL)))
                goto exit;
        }
    }

    if (FAILED(hr = stream.Write(c_szContactTail, lstrlen(c_szContactTail), NULL)))
        goto exit;

    FAIL_EXIT(hr = stream.HrAcquireStringA(pdwLen, (LPSTR *)ppvXML, ACQ_DISPLACE));

exit:
    return hr;
}

HRESULT HrCreatePatchContactRequest(LPHTTPCONTACTINFO pciInfo, IPropPatchRequest **ppRequest)
{
    HRESULT             hr = S_OK;
    LPSTR              *prgsz = (LPSTR*)pciInfo, pszEsc;
    DWORD               dwIndex, dwSize = ARRAYSIZE(g_rgContactEle);
    CPropPatchRequest  *pRequest = NULL;
    
    *ppRequest = NULL;

    pRequest = new CPropPatchRequest();
    if (NULL == pRequest)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // always specify windows-1252 encoding for this release
    pRequest->SpecifyWindows1252Encoding(TRUE);

    for (dwIndex = 0; dwIndex < dwSize; dwIndex ++)
    {
        if (g_rgContactEle[dwIndex] != HMELE_UNKNOWN)
        {
            if (prgsz[dwIndex])
            {
                // values with content are added.  Empty strings are deleted.  Null values are ignored.
                if (*(prgsz[dwIndex]))
                {
                    pszEsc = _EscapeString(prgsz[dwIndex]);
                    if (!pszEsc)
                        goto exit;

                    hr = pRequest->SetProperty(DAVNAMESPACE_CONTACTS, const_cast<char *>(rgHTTPMailDictionary[g_rgContactEle[dwIndex]].pszName), pszEsc);
                    
                    SafeMemFree(pszEsc);

                    if (FAILED(hr))
                        goto exit;
                                
                }
                else
                {
                    if (FAILED(hr = pRequest->RemoveProperty(DAVNAMESPACE_CONTACTS, const_cast<char *>(rgHTTPMailDictionary[g_rgContactEle[dwIndex]].pszName))))
                        goto exit;
                }
            }
        }
    }
exit:
    if (FAILED(hr))
        SafeRelease(pRequest);
    else
        *ppRequest = pRequest;

    return hr;
}

HRESULT HrGenerateSimpleBatchXML(
                            LPCSTR pszRootName,
                            LPHTTPTARGETLIST pTargets,
                            LPVOID *ppvXML,
                            DWORD *pdwLen)
{
    HRESULT                 hr = S_OK;
    CByteStream             stream;
    DWORD                   dwIndex;
    DWORD                   dwHrefHeadLen, dwHrefTailLen;

    IxpAssert(NULL != pszRootName);
    IxpAssert(NULL != pTargets);
    IxpAssert(pTargets->cTarget >= 1);
    IxpAssert(NULL != pTargets->prgTarget);
    IxpAssert(NULL != ppvXML);
    IxpAssert(NULL != pdwLen);

    dwHrefHeadLen = lstrlen(c_szHrefHead);
    dwHrefTailLen = lstrlen(c_szHrefTail);

    // write the DAV header
    FAIL_EXIT_STREAM_WRITE(stream, c_szXMLHead);

    FAIL_EXIT_STREAM_WRITE(stream, c_szBatchHead1);
    FAIL_EXIT_STREAM_WRITE(stream, pszRootName);
    FAIL_EXIT_STREAM_WRITE(stream, c_szBatchHead2);

    FAIL_EXIT_STREAM_WRITE(stream, c_szTargetHead);

    // write out the targets
    for (dwIndex = 0; dwIndex < pTargets->cTarget; dwIndex++)
    {
        if (FAILED(hr = stream.Write(c_szHrefHead, dwHrefHeadLen, NULL)))
            goto exit;

        FAIL_EXIT_STREAM_WRITE(stream, pTargets->prgTarget[dwIndex]);

        if (FAILED(hr = stream.Write(c_szHrefTail, dwHrefTailLen, NULL)))
            goto exit;
    }

    FAIL_EXIT_STREAM_WRITE(stream, c_szTargetTail);

    FAIL_EXIT_STREAM_WRITE(stream, c_szBatchTail);
    FAIL_EXIT_STREAM_WRITE(stream, pszRootName);
    FAIL_EXIT_STREAM_WRITE(stream, c_szXMLCloseElement);

    // take ownership of the bytestream
    FAIL_EXIT(hr = stream.HrAcquireStringA(pdwLen, (LPSTR *)ppvXML, ACQ_DISPLACE));

exit:
    return hr;
}

HRESULT HrGenerateMultiDestBatchXML(
                        LPCSTR pszRootName,
                        LPHTTPTARGETLIST pTargets, 
                        LPHTTPTARGETLIST pDestinations,
                        LPVOID *ppvXML,
                        DWORD *pdwLen)
{
    HRESULT         hr = S_OK;
    CByteStream     stream;
    DWORD           dwIndex;

    IxpAssert(NULL != pszRootName);
    IxpAssert(NULL != pTargets);
    IxpAssert(NULL != pDestinations);
    IxpAssert(NULL != ppvXML);
    IxpAssert(NULL != pdwLen);

    // source and destination must have same count
    if (pTargets->cTarget != pDestinations->cTarget)
        return E_INVALIDARG;

    *ppvXML = NULL;
    *pdwLen = 0;

    // write the DAV header
    FAIL_EXIT_STREAM_WRITE(stream, c_szXMLHead);

    // write the command header
    FAIL_EXIT_STREAM_WRITE(stream, c_szBatchHead1);
    
    FAIL_EXIT_STREAM_WRITE(stream, pszRootName);
    FAIL_EXIT_STREAM_WRITE(stream, c_szBatchHead2);

    // write out the targets
    for (dwIndex = 0; dwIndex < pTargets->cTarget; dwIndex++)
    {
        IxpAssert(NULL != pTargets->prgTarget[dwIndex]);
        if (NULL != pTargets->prgTarget[dwIndex])
        {
            FAIL_EXIT_STREAM_WRITE(stream, c_szTargetHead);

            FAIL_EXIT_STREAM_WRITE(stream, c_szHrefHead);
            FAIL_EXIT_STREAM_WRITE(stream, pTargets->prgTarget[dwIndex]);
            FAIL_EXIT_STREAM_WRITE(stream, c_szHrefTail);

            if (NULL != pDestinations->prgTarget[dwIndex])
            {
                FAIL_EXIT_STREAM_WRITE(stream, c_szDestHead);
                FAIL_EXIT_STREAM_WRITE(stream, pDestinations->prgTarget[dwIndex]);
                FAIL_EXIT_STREAM_WRITE(stream, c_szDestTail);
            }

            FAIL_EXIT_STREAM_WRITE(stream, c_szTargetTail);
        }
    }

    FAIL_EXIT_STREAM_WRITE(stream, c_szBatchTail);
    FAIL_EXIT_STREAM_WRITE(stream, pszRootName);
    FAIL_EXIT_STREAM_WRITE(stream, c_szXMLCloseElement);

    // take ownership of the byte stream
    hr = stream.HrAcquireStringA(pdwLen, (LPSTR *)ppvXML, ACQ_DISPLACE);

exit:
    return hr;
}

HRESULT HrCopyStringList(LPCSTR *rgszInList, LPCSTR **prgszOutList)
{

    DWORD   cStrings = 0;
    HRESULT hr = S_OK;
    LPCSTR  pszCur;
    DWORD   i = 0;

    IxpAssert(NULL != rgszInList);
    IxpAssert(NULL != prgszOutList);

    *prgszOutList = NULL;

    // count the strings in the list
    while (NULL != rgszInList[i++])
        ++cStrings;

    // allocate the new list
    if (!MemAlloc((void **)prgszOutList, (cStrings + 1) * sizeof(LPCSTR)))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // copy the strings over. if an allocation fails,
    // stay in the loop and null out all of the slots
    // that haven't been filled
    for (i = 0; i <= cStrings; i++)
    {
        if (SUCCEEDED(hr) && NULL != rgszInList[i])
        {
            (*prgszOutList)[i] = PszDupA(rgszInList[i]);
            if (NULL == (*prgszOutList)[i])
                hr = E_OUTOFMEMORY;
        }
        else
            (*prgszOutList)[i] = NULL;
    }
    
    if (FAILED(hr))
    {
        FreeStringList(*prgszOutList);
        *prgszOutList = NULL;
    }

exit:
    return hr;
}

void FreeStringList(LPCSTR *rgszList)
{
    DWORD i = 0;

    IxpAssert(NULL != rgszList);
    
    if (rgszList)
    {
        while (NULL != rgszList[i])
            MemFree((void *)rgszList[i++]);

        MemFree(rgszList);
    }
}

// --------------------------------------------------------------------------------
// class CHTTPMailTransport
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// CHTTPMailTransport::CHTTPMailTransport
// --------------------------------------------------------------------------------
CHTTPMailTransport::CHTTPMailTransport(void) :
    m_cRef(1),
    m_fHasServer(FALSE),
    m_fHasRootProps(FALSE),
    m_fTerminating(FALSE),
    m_status(IXP_DISCONNECTED),
    m_hInternet(NULL),
    m_hConnection(NULL),
    m_pszUserAgent(NULL),
    m_pLogFile(NULL),
    m_pCallback(NULL),
    m_pParser(NULL),
    m_hwnd(NULL),
    m_hevPendingCommand(NULL),
    m_opPendingHead(NULL),
    m_opPendingTail(NULL),
    m_pszCurrentHost(NULL),
    m_nCurrentPort(INTERNET_INVALID_PORT_NUMBER)
{
    DWORD dwTempID;
    HANDLE hThread = NULL;

    InitializeCriticalSection(&m_cs);
    ZeroMemory(&m_rServer, sizeof(INETSERVER));
    ZeroMemory(&m_op, sizeof(HTTPMAILOPERATION));
    ZeroMemory(&m_rootProps, sizeof(ROOTPROPS));

    m_op.rResponse.command = HTTPMAIL_NONE;

    m_hevPendingCommand = CreateEvent(NULL, TRUE, FALSE, NULL);

    // Create the IO thread
    hThread = CreateThread(NULL, 0, IOThreadFuncProxy, (LPVOID)this, 0, &dwTempID);

    // We do not need to manipulate the IO Thread through its handle, so close it
    // This will NOT terminate the thread
    if (NULL != hThread)
    {
        CloseHandle(hThread);
    }

    DllAddRef();
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::~CHTTPMailTransport
// --------------------------------------------------------------------------------
CHTTPMailTransport::~CHTTPMailTransport(void)
{
    IxpAssert(0 == m_cRef);
    
    // Shouldn't be pending commands
    IxpAssert(HTTPMAIL_NONE == m_op.rResponse.command);
    IxpAssert(!m_opPendingHead);
    IxpAssert(!m_opPendingTail);

    IxpAssert(m_fTerminating);


    // Destroy the critical sections
    DeleteCriticalSection(&m_cs);

    // Close the window    
    if ((NULL != m_hwnd) && (FALSE != IsWindow(m_hwnd)))
        ::SendMessage(m_hwnd, WM_CLOSE, 0, 0);

    SafeMemFree(m_pszUserAgent);

    CloseHandle(m_hevPendingCommand);

    SafeMemFree(m_rootProps.pszAdbar);
    SafeMemFree(m_rootProps.pszContacts);
    SafeMemFree(m_rootProps.pszInbox);
    SafeMemFree(m_rootProps.pszOutbox);
    SafeMemFree(m_rootProps.pszSendMsg);
    SafeMemFree(m_rootProps.pszSentItems);
    SafeMemFree(m_rootProps.pszDeletedItems);
    SafeMemFree(m_rootProps.pszDrafts);
    SafeMemFree(m_rootProps.pszMsgFolderRoot);
    SafeMemFree(m_rootProps.pszSig);

    SafeMemFree(m_pszCurrentHost);

    SafeRelease(m_pLogFile);
    SafeRelease(m_pCallback);
    SafeRelease(m_pParser);

    SafeInternetCloseHandle(m_hInternet);

    // BUGBUG: clean up window, thread and event, release buffers, etc
    DllRelease();
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::HrConnectToHost
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::HrConnectToHost(
                                LPSTR pszHostName, 
                                INTERNET_PORT nPort,
                                LPSTR pszUserName,
                                LPSTR pszPassword)
{
    IxpAssert(m_hInternet);

    // if a connection exists, determine if it is to the same host/port
    // that the caller is specifying.
    if (NULL != m_hConnection)
    {
        // if we are already connected to the correct host, return immediately
        if (m_nCurrentPort == nPort && m_pszCurrentHost && (lstrcmp(pszHostName, m_pszCurrentHost) == 0))
            return S_OK;

        // if we are connected to the wrong server, close the existing connection
        SafeInternetCloseHandle(m_hConnection);
        SafeMemFree(m_pszCurrentHost);
        m_nCurrentPort = INTERNET_INVALID_PORT_NUMBER;
    }

    // establish a connection to the specified server
    m_hConnection = InternetConnect(
                        m_hInternet,
                        pszHostName,
                        nPort,
                        NULL,                           // user name
                        NULL,                           // password
                        INTERNET_SERVICE_HTTP,          // service
                        0,                              // flags
                        reinterpret_cast<DWORD_PTR>(this)); // context

    // what can cause this?
    if (NULL == m_hConnection)
        return E_OUTOFMEMORY;

    // save the host name. don't bother checking for failure...we just won't reuse
    // the connection next time through.
    m_pszCurrentHost = PszDupA(pszHostName);
    m_nCurrentPort = nPort;

    return S_OK;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::DoLogonPrompt
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::DoLogonPrompt(void)
{
    HRESULT             hr = S_OK;
    IHTTPMailCallback   *pCallback = NULL;

    EnterCriticalSection(&m_cs);

    if (m_pCallback)
    {
        pCallback = m_pCallback;
        pCallback->AddRef();
    }
    else
        hr = E_FAIL;

    LeaveCriticalSection(&m_cs);

    if (pCallback)
    {
        hr = pCallback->OnLogonPrompt(&m_rServer, this);
        pCallback->Release();
    }

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::DoGetParentWindow
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::DoGetParentWindow(HWND *phwndParent)
{
    HRESULT             hr = S_OK;
    IHTTPMailCallback   *pCallback = NULL;

    EnterCriticalSection(&m_cs);

    if (m_pCallback)
    {
        pCallback = m_pCallback;
        pCallback->AddRef();
    }
    else
        hr = E_FAIL;

    LeaveCriticalSection(&m_cs);

    if (pCallback)
    {
        hr = pCallback->GetParentWindow(phwndParent);
        pCallback->Release();
    }

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::CreateWnd
// --------------------------------------------------------------------------------
BOOL CHTTPMailTransport::CreateWnd()
{
    WNDCLASS wc;

    IxpAssert(!m_hwnd);
    if (m_hwnd)
        return TRUE;

    if (!GetClassInfo(g_hLocRes, s_szHTTPMailWndClass, &wc))
    {
        wc.style                = 0;
        wc.lpfnWndProc         = CHTTPMailTransport::WndProc;
        wc.cbClsExtra           = 0;
        wc.cbWndExtra           = 0;
        wc.hInstance            = g_hLocRes;
        wc.hIcon                = NULL;
        wc.hCursor              = NULL;
        wc.hbrBackground        = NULL;
        wc.lpszMenuName         = NULL;
        wc.lpszClassName        = s_szHTTPMailWndClass;
        RegisterClass(&wc);
    }

    m_hwnd = CreateWindowEx(0,
                        s_szHTTPMailWndClass,
                        s_szHTTPMailWndClass,
                        WS_POPUP,
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        NULL,
                        NULL,
                        g_hLocRes,
                        (LPVOID)this);

    return (NULL != m_hwnd);
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::DequeueNextOperation
// --------------------------------------------------------------------------------
BOOL CHTTPMailTransport::DequeueNextOperation(void)
{
    if (NULL == m_opPendingHead)
        return FALSE;

    IxpAssert(HTTPMAIL_NONE == m_op.rResponse.command);
    IxpAssert(HTTPMAIL_NONE != m_opPendingHead->command);

    m_op.rResponse.command = m_opPendingHead->command;

    m_op.pfnState = m_opPendingHead->pfnState;
    m_op.cState = m_opPendingHead->cState;    
     
    m_op.pszUrl                = m_opPendingHead->pszUrl;
    m_op.pszDestination        = m_opPendingHead->pszDestination;
    m_op.pszContentType        = m_opPendingHead->pszContentType;
    m_op.pvData                = m_opPendingHead->pvData;
    m_op.cbDataLen             = m_opPendingHead->cbDataLen;
    m_op.dwContext             = m_opPendingHead->dwContext;
    m_op.dwDepth               = m_opPendingHead->dwDepth;
    m_op.dwRHFlags             = m_opPendingHead->dwRHFlags;
    m_op.dwMIFlags             = m_opPendingHead->dwMIFlags;
    m_op.tyProp                = m_opPendingHead->tyProp;
    m_op.fBatch                = m_opPendingHead->fBatch;
    m_op.rgszAcceptTypes       = m_opPendingHead->rgszAcceptTypes;
    m_op.pPropFindRequest      = m_opPendingHead->pPropFindRequest;
    m_op.pPropPatchRequest     = m_opPendingHead->pPropPatchRequest;
    m_op.pParseFuncs           = m_opPendingHead->pParseFuncs;
    m_op.pHeaderStream         = m_opPendingHead->pHeaderStream;
    m_op.pBodyStream           = m_opPendingHead->pBodyStream;
    m_op.pszFolderTimeStamp    = m_opPendingHead->pszFolderTimeStamp;
    m_op.pszRootTimeStamp      = m_opPendingHead->pszRootTimeStamp;
    //m_op.pszFolderName         = m_opPendingHead->pszFolderName;

    LPHTTPQUEUEDOP pDelete = m_opPendingHead;

    m_opPendingHead = m_opPendingHead->pNext;
    if (NULL == m_opPendingHead)
        m_opPendingTail = NULL;

    MemFree(pDelete);

    return TRUE;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::FlushQueue
// --------------------------------------------------------------------------------
void CHTTPMailTransport::FlushQueue(void)
{
    // destroy any commands that are pending.
    // REVIEW: these commands need to notify their callers
    LPHTTPQUEUEDOP pOp = m_opPendingHead;
    LPHTTPQUEUEDOP pNext;

    while (pOp)
    {
        pNext = pOp->pNext;

        SafeMemFree(pOp->pszUrl);
        SafeMemFree(pOp->pszDestination);
        if (pOp->pszContentType)
            MemFree((void *)pOp->pszContentType);
        SafeMemFree(pOp->pvData);
        if (pOp->rgszAcceptTypes)
            FreeStringList(pOp->rgszAcceptTypes);
        SafeRelease(pOp->pPropFindRequest);
        SafeRelease(pOp->pPropPatchRequest);

        MemFree(pOp);
        pOp = pNext;
    }

    m_opPendingHead = m_opPendingTail = NULL;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::TerminateIOThread
// --------------------------------------------------------------------------------
void CHTTPMailTransport::TerminateIOThread(void)
{
    EnterCriticalSection(&m_cs);
    // acquire a reference to the transport that will be owned
    // by the io thread. the reference will be release when the
    // io thread exits. this reference is not acquired when the
    // thread is created, because it would prevent the transport
    // from going away.
    AddRef();

    m_fTerminating = TRUE;

    FlushQueue();

    // signal the io thread to wake it.
    SetEvent(m_hevPendingCommand);

    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::IOThreadFunc
// --------------------------------------------------------------------------------

DWORD CALLBACK CHTTPMailTransport::IOThreadFuncProxy(PVOID pv)
{
    CHTTPMailTransport  *pHTTPMail = (CHTTPMailTransport*)pv;
    DWORD               dwResult = S_OK;

    IxpAssert(pHTTPMail);

    // Initialize COM
    if(S_OK == (dwResult = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED)))
    {
        dwResult = pHTTPMail->IOThreadFunc();
        //Bug #101165 -- MSXML needs notification to clean up per thread data.
        CoUninitialize();
    }

    return dwResult;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::IOThreadFunc
// Called by IOThreadProxy to transition into an object method
// --------------------------------------------------------------------------------
DWORD CHTTPMailTransport::IOThreadFunc()
{
    LPSTR       pszVerb = NULL;
    BOOL        bQueueEmpty = FALSE;
    
    // block until a command is pending.
    while (WAIT_OBJECT_0 == WaitForSingleObject(m_hevPendingCommand, INFINITE))
    {
        if (IsTerminating())
            break;

        // Reset the event
        ResetEvent(m_hevPendingCommand);

        // unhook commands from the queue one at a time, and process them until
        // the queue is empty

        while (TRUE)
        {
            // dequeue the next operation

            EnterCriticalSection(&m_cs);
            
            IxpAssert(HTTPMAIL_NONE == m_op.rResponse.command);
            
            bQueueEmpty = !DequeueNextOperation();

            // if no commands left, break out of the loop and block
           
            LeaveCriticalSection(&m_cs);

            if (bQueueEmpty)
                break;
            
            DoOperation();
        }

        if (IsTerminating())
            break;
    }

    IxpAssert(IsTerminating());

    // TerminateIOThread acquired a reference that gets released here
    Release();

    return S_OK;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::WndProc
// --------------------------------------------------------------------------------

LRESULT CALLBACK CHTTPMailTransport::WndProc(HWND hwnd,
                                             UINT msg,
                                             WPARAM wParam,
                                             LPARAM lParam)
{
    CHTTPMailTransport *pThis = (CHTTPMailTransport*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    LRESULT             lr = 0;

    switch (msg)
    {
    case WM_NCCREATE:
        IxpAssert(!pThis);
        pThis = (CHTTPMailTransport*)((LPCREATESTRUCT)lParam)->lpCreateParams;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)pThis);
        lr = DefWindowProc(hwnd, msg, wParam, lParam);       
        break;
    
    case SPM_HTTPMAIL_SENDRESPONSE:
        IxpAssert(pThis);
        pThis->InvokeResponseCallback();
        break;

    case SPM_HTTPMAIL_LOGONPROMPT:
        IxpAssert(pThis);
        lr = pThis->DoLogonPrompt();
        break;

    case SPM_HTTPMAIL_GETPARENTWINDOW:
        IxpAssert(pThis);
        lr = pThis->DoGetParentWindow((HWND *)wParam);
        break;
        
    default:
        lr = DefWindowProc(hwnd, msg, wParam, lParam);
        break;
    }

    return lr;
}


// --------------------------------------------------------------------------------
// CHTTPMailTransport::Reset
// --------------------------------------------------------------------------------
void CHTTPMailTransport::Reset(void)
{
    // REVIEW: this is incomplete. Should we be aborting the current command?
    EnterCriticalSection(&m_cs);

    SafeRelease(m_pLogFile);
    
    SafeInternetCloseHandle(m_hConnection);
    SafeInternetCloseHandle(m_hInternet);

    SafeMemFree(m_pszUserAgent);

    SafeRelease(m_pCallback);
    m_status = IXP_DISCONNECTED;
    m_fHasServer = FALSE;
    ZeroMemory(&m_rServer, sizeof(INETSERVER));
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr = S_OK;

    // Validate params
    if (NULL == ppv)
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // Initialize params
    *ppv = NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = ((IUnknown *)(IHTTPMailTransport *)this);

    // IID_IInternetTransport 
    else if (IID_IInternetTransport == riid)
        *ppv = (IInternetTransport *)this;

    // IID_IHTTPMailTransport
    else if (IID_IHTTPMailTransport == riid)
        *ppv = (IHTTPMailTransport *)this;

    // IID_IXMLNodeFactory
    else if (IID_IXMLNodeFactory == riid)
        *ppv = (IXMLNodeFactory *)this;

    else if (IID_IHTTPMailTransport2 == riid)
        *ppv = (IHTTPMailTransport2 *)this;

    // if not NULL, acquire a reference and return
    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    hr = TrapError(E_NOINTERFACE);

exit:
    // Done
    return hr;
}
// --------------------------------------------------------------------------------
// CHTTPMailTransport::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CHTTPMailTransport::AddRef(void) 
{
    return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CHTTPMailTransport::Release(void) 
{
    if (0 != --m_cRef)
        return m_cRef;

    // our refcount dropped to zero, and we aren't terminating,
    // begin terminating
    if (!IsTerminating())
    {
        TerminateIOThread();
        return 1;
    }
    
    // if we were terminating, and our refCount dropped to zero,
    // then the iothread has been unwound and we can safely exit.
    delete this;
    return 0;
}

// ----------------------------------------------------------------------------
// IInternetTransport methods
// ----------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// CHTTPMailTransport::Connect
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::Connect(LPINETSERVER pInetServer, 
                                        boolean fAuthenticate, 
                                        boolean fCommandLogging)
{
    HRESULT                     hr = S_OK; 

    if (NULL == pInetServer  || FIsEmptyA(pInetServer->szServerName))
        return TrapError(E_INVALIDARG);

    // Thread safety
    EnterCriticalSection(&m_cs);

    // not init
    if (NULL == m_hInternet || NULL == m_pCallback)
    {
        hr = TrapError(IXP_E_NOT_INIT);
        goto exit;
    }

    FAIL_CREATEWND;

    // busy
    if (IXP_DISCONNECTED != m_status || m_fHasServer)
    {
        hr = TrapError(IXP_E_ALREADY_CONNECTED);
        goto exit;
    }

    // copy the server struct
    CopyMemory(&m_rServer, pInetServer, sizeof(INETSERVER));
    m_fHasServer = TRUE;
    m_fHasRootProps = FALSE;
    
exit:
    // ThreadSafety
    LeaveCriticalSection(&m_cs);
    
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::DropConnection
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::DropConnection(void)
{
    // this function is called to stop any current and pending i/o

    // Locals
    HRESULT     hr = S_OK;
    BOOL        fSendResponse;

    EnterCriticalSection(&m_cs);
    
    // flush any pending i/o from the queue
    FlushQueue();
    
    // if a command is being processed, mark it aborted and
    // send a response if necessary. stay in the critical
    // section to prevent the io thread from sending any
    // notifications at the same time.
    if (m_op.rResponse.command != HTTPMAIL_NONE)
    {
        m_op.fAborted = TRUE;
        m_op.rResponse.fDone = TRUE; 
    }

    Disconnect();

    LeaveCriticalSection(&m_cs);

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::Disconnect
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::Disconnect(void)
{
    // Locals
    HRESULT     hr = S_OK;

    // Thread safety
    EnterCriticalSection(&m_cs);

    if (NULL == m_hConnection)
    {
        hr = TrapError(IXP_E_NOT_INIT);
        goto exit;
    }

    // Disconnecting
    if (m_pCallback)
        m_pCallback->OnStatus(IXP_DISCONNECTING, this);

    SafeInternetCloseHandle(m_hConnection);

    m_status = IXP_DISCONNECTED;
    ZeroMemory(&m_rServer, sizeof(INETSERVER));

    if (m_pCallback)
        m_pCallback->OnStatus(IXP_DISCONNECTED, this);

     // Close the window    
    if ((NULL != m_hwnd) && (FALSE != IsWindow(m_hwnd)))
        ::SendMessage(m_hwnd, WM_CLOSE, 0, 0);
    m_hwnd = NULL;
    m_fHasServer = FALSE;

exit:
    // Thread safety
    LeaveCriticalSection(&m_cs);

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::IsState
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::IsState(IXPISSTATE isstate)
{
    // Locals
    HRESULT     hr = S_OK;

    // Thread safety
    EnterCriticalSection(&m_cs);

    switch(isstate)
    {
        // are we connected?
        case IXP_IS_CONNECTED:
            hr = (NULL == m_hConnection) ? S_FALSE : S_OK;
            break;

        // are we busy?
        case IXP_IS_BUSY:
            hr = (HTTPMAIL_NONE != m_op.rResponse.command) ? S_OK : S_FALSE;
            break;

        // are we ready
        case IXP_IS_READY:
            hr = (HTTPMAIL_NONE == m_op.rResponse.command) ? S_OK : S_FALSE;
            break;

        case IXP_IS_AUTHENTICATED:
            // REVIEW
            hr = S_OK;
            break;

        default:
            IxpAssert(FALSE);
            break;
    }

    // Thread safety
    LeaveCriticalSection(&m_cs);

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::GetServerInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::GetServerInfo(LPINETSERVER pInetServer)
{
    // check params
    if (NULL == pInetServer)
        return TrapError(E_INVALIDARG);

    // Thread safety
    EnterCriticalSection(&m_cs);

    // Copy server info
    CopyMemory(pInetServer, &m_rServer, sizeof(INETSERVER));

    // Thread safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::GetIXPType
// --------------------------------------------------------------------------------
STDMETHODIMP_(IXPTYPE) CHTTPMailTransport::GetIXPType(void)
{
    return IXP_HTTPMail;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::InetServerFromAccount
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::InetServerFromAccount(IImnAccount *pAccount, LPINETSERVER pInetServer)
{
    HRESULT     hr = S_OK;
    DWORD       fAlwaysPromptPassword = FALSE;

    // check params
    if (NULL == pAccount || NULL == pInetServer)
        return TrapError(E_INVALIDARG);

    // ZeroInit
    ZeroMemory(pInetServer, sizeof(INETSERVER));

    // Get the account name
    if (FAILED(hr = pAccount->GetPropSz(AP_ACCOUNT_NAME, pInetServer->szAccount, ARRAYSIZE(pInetServer->szAccount))))
    {
        hr = TrapError(IXP_E_INVALID_ACCOUNT);
        goto exit;
    }

    // Get the RAS connectoid
    if (FAILED(pAccount->GetPropSz(AP_RAS_CONNECTOID, pInetServer->szConnectoid, ARRAYSIZE(pInetServer->szConnectoid))))
        *pInetServer->szConnectoid = '\0';

    // Connection Type
    Assert(sizeof(pInetServer->rasconntype) == sizeof(DWORD));
    if (FAILED(pAccount->GetPropDw(AP_RAS_CONNECTION_TYPE, (DWORD *)&pInetServer->rasconntype)))
        pInetServer->rasconntype = RAS_CONNECT_LAN;

           // Get Server Name
    hr = pAccount->GetPropSz(AP_HTTPMAIL_SERVER, pInetServer->szServerName, sizeof(pInetServer->szServerName));
    if (FAILED(hr))
    {
        hr = TrapError(IXP_E_INVALID_ACCOUNT);
        goto exit;
    }

    // Password
    if (FAILED(pAccount->GetPropDw(AP_HTTPMAIL_PROMPT_PASSWORD, &fAlwaysPromptPassword)) || FALSE == fAlwaysPromptPassword)
        pAccount->GetPropSz(AP_HTTPMAIL_PASSWORD, pInetServer->szPassword, sizeof(pInetServer->szPassword));

    if (fAlwaysPromptPassword)
        pInetServer->dwFlags |= ISF_ALWAYSPROMPTFORPASSWORD;

    // Sicily
    Assert(sizeof(pInetServer->fTrySicily) == sizeof(DWORD));
    pAccount->GetPropDw(AP_HTTPMAIL_USE_SICILY, (DWORD *)&pInetServer->fTrySicily);


    // User Name
    pAccount->GetPropSz(AP_HTTPMAIL_USERNAME, pInetServer->szUserName, sizeof(pInetServer->szUserName));

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::HandsOffCallback
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::HandsOffCallback(void)
{
    // Locals
    HRESULT hr = S_OK;

    // Thread safety
    EnterCriticalSection(&m_cs);

    // No current callback
    if (NULL == m_pCallback)
    {
        hr = TrapError(S_FALSE);
        goto exit;
    }

    // Release it
    SafeRelease(m_pCallback);

exit:
    // Thread safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::GetStatus
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::GetStatus(IXPSTATUS *pCurrentStatus)
{
    if (NULL == pCurrentStatus)
        return TrapError(E_INVALIDARG);

    *pCurrentStatus = m_status;
    return S_OK;
}

// ----------------------------------------------------------------------------
// IHTTPMailTransport methods
// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------
// CHTTPMailTransport::GetProperty
// ----------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::GetProperty(
                                        HTTPMAILPROPTYPE type, 
                                        LPSTR *ppszProp)
{
    HRESULT         hr = S_OK;

    if (type <= HTTPMAIL_PROP_INVALID || type >= HTTPMAIL_PROP_LAST)
        return E_INVALIDARG;

    if (ppszProp)
        *ppszProp = NULL;

    if (!m_fHasRootProps || NULL == ppszProp)
    {
        IF_FAILEXIT(hr = QueueGetPropOperation(type));
    }

    switch (type)
    {
    case HTTPMAIL_PROP_ADBAR:
        *ppszProp = PszDupA(m_rootProps.pszAdbar);
        break;

    case HTTPMAIL_PROP_CONTACTS:
        *ppszProp = PszDupA(m_rootProps.pszContacts);
        break;
        
    case HTTPMAIL_PROP_INBOX:
        *ppszProp = PszDupA(m_rootProps.pszInbox);
        break;

    case HTTPMAIL_PROP_OUTBOX:
        *ppszProp = PszDupA(m_rootProps.pszOutbox);
        break;

    case HTTPMAIL_PROP_SENDMSG:
        *ppszProp = PszDupA(m_rootProps.pszSendMsg);
        break;

    case HTTPMAIL_PROP_SENTITEMS:
        *ppszProp = PszDupA(m_rootProps.pszSentItems);
        break;

    case HTTPMAIL_PROP_DELETEDITEMS:
        *ppszProp = PszDupA(m_rootProps.pszDeletedItems);
        break;
    
    case HTTPMAIL_PROP_DRAFTS:
        *ppszProp = PszDupA(m_rootProps.pszDrafts);
        break;
    
    case HTTPMAIL_PROP_MSGFOLDERROOT:
        *ppszProp = PszDupA(m_rootProps.pszMsgFolderRoot);
        break;

    case HTTPMAIL_PROP_SIG:
        *ppszProp = PszDupA(m_rootProps.pszSig);
        break;

    default:
        hr = TrapError(E_INVALIDARG);
        break;
    }

    if (SUCCEEDED(hr) && !*ppszProp)
        hr = IXP_E_HTTP_ROOT_PROP_NOT_FOUND;

exit:
    return hr;
}

HRESULT CHTTPMailTransport::QueueGetPropOperation(HTTPMAILPROPTYPE type)
{
    HRESULT             hr = S_OK;
    LPHTTPQUEUEDOP      pOp;

    if (!m_fHasServer || NULL == m_rServer.szServerName)
    {
        hr = E_FAIL;
        goto exit;
    }

    FAIL_CREATEWND;

    // queue the getprop operation
    if (FAILED(hr = AllocQueuedOperation(m_rServer.szServerName, NULL, 0, &pOp)))
        goto exit;

    pOp->command = HTTPMAIL_GETPROP;
    pOp->tyProp = type;

    pOp->pfnState = c_rgpfnRootProps;
    pOp->cState = ARRAYSIZE(c_rgpfnRootProps);
    pOp->pParseFuncs = c_rgpfnRootPropsParse;
    pOp->dwRHFlags = (RH_XMLCONTENTTYPE | RH_BRIEF);

    QueueOperation(pOp);

    hr = E_PENDING;

exit:
    return hr;
}

// ----------------------------------------------------------------------------
// CHTTPMailTransport::GetPropertyDw
// ----------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::GetPropertyDw(
                                        HTTPMAILPROPTYPE type, 
                                        LPDWORD          lpdwProp)
{
    HRESULT         hr = S_OK;

    if (type <= HTTPMAIL_PROP_INVALID || type >= HTTPMAIL_PROP_LAST)
        IF_FAILEXIT(hr = E_INVALIDARG);

    if (lpdwProp)
        *lpdwProp = 0;

    if (!m_fHasRootProps || NULL == lpdwProp)
    {
        IF_FAILEXIT(hr = QueueGetPropOperation(type));
        
    }

    switch (type)
    {
        case HTTPMAIL_PROP_MAXPOLLINGINTERVAL:
            *lpdwProp = m_rootProps.dwMaxPollingInterval;
            break;

        default:
            hr = TrapError(E_INVALIDARG);
            break;
    }

exit:
    return hr;
}

// ----------------------------------------------------------------------------
// CHTTPMailTransport::CommandGET
// ----------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::CommandGET(LPCSTR pszUrl, 
                                            LPCSTR *rgszAcceptTypes,
                                            BOOL fTranslate,
                                            DWORD dwContext)
{
    HRESULT         hr = S_OK;
    LPHTTPQUEUEDOP  pOp = NULL;
    LPCSTR          *rgszAcceptTypesCopy = NULL;

    if (NULL == pszUrl)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    if (NULL != rgszAcceptTypes)
    {
        hr = HrCopyStringList(rgszAcceptTypes, &rgszAcceptTypesCopy);
        if (FAILED(hr))
            goto exit;
    }

    if (FAILED(hr = AllocQueuedOperation(pszUrl, NULL, 0, &pOp)))
        goto exit;

    pOp->command = HTTPMAIL_GET;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfGet;
    pOp->cState = ARRAYSIZE(c_rgpfGet);
    pOp->rgszAcceptTypes = rgszAcceptTypesCopy;
    if (!fTranslate)
        pOp->dwRHFlags = RH_TRANSLATEFALSE;

    rgszAcceptTypesCopy = NULL;

    QueueOperation(pOp);

exit:        
    if (NULL != rgszAcceptTypesCopy)
        FreeStringList(rgszAcceptTypesCopy);

    return hr;
}

// ----------------------------------------------------------------------------
// CHTTPMailTransport::CommandPUT
// ----------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::CommandPUT(
                                        LPCSTR pszPath, 
                                        LPVOID lpvData,
                                        ULONG cbSize,
                                        DWORD dwContext)
{
    HRESULT         hr = S_OK;
    LPHTTPQUEUEDOP  pOp = NULL;
    LPCSTR          pszLocalContentType = NULL;
    LPVOID          lpvCopy = NULL;

    if (NULL == pszPath || NULL == lpvData || 0 == cbSize)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    if (!MemAlloc(&lpvCopy, cbSize))
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }
    
    CopyMemory(lpvCopy, lpvData, cbSize);

    if (FAILED(hr = AllocQueuedOperation(pszPath, NULL, 0, &pOp)))
        goto exit;

    pOp->command = HTTPMAIL_PUT;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnPut;
    pOp->cState = ARRAYSIZE(c_rgpfnPut);
    pOp->pvData = lpvCopy;
    lpvCopy = NULL;
    pOp->cbDataLen = cbSize;

    QueueOperation(pOp);

exit:
    SafeMemFree(lpvCopy);
    return hr;
}
                                    
// ----------------------------------------------------------------------------
// CHTTPMailTransport::CommandPOST
// ----------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::CommandPOST(
                                    LPCSTR pszPath,
                                    IStream *pStream,
                                    LPCSTR pszContentType,
                                    DWORD dwContext)
{
    HRESULT         hr = S_OK;
    LPHTTPQUEUEDOP  pOp = NULL;
    LPCSTR          pszLocalContentType = NULL;

    if (NULL == pszPath || NULL == pStream)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    if (pszContentType)
    {
        pszLocalContentType = PszDupA(pszContentType);
        if (NULL == pszLocalContentType)
        {
            hr = TrapError(E_OUTOFMEMORY);
            goto exit;
        }
    }

    if (FAILED(hr = AllocQueuedOperation(pszPath, NULL, 0, &pOp)))
        goto exit;

    pOp->command = HTTPMAIL_POST;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnPost;
    pOp->cState = ARRAYSIZE(c_rgpfnPost);
    pOp->pBodyStream = pStream;
    pOp->pBodyStream->AddRef();
    pOp->pszContentType = pszLocalContentType;
    pszLocalContentType = NULL;

    QueueOperation(pOp);

exit:
    if (pszLocalContentType)
        MemFree((void *)pszLocalContentType);

    return hr;
}

// ----------------------------------------------------------------------------
// CHTTPMailTransport::CommandDELETE
// ----------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::CommandDELETE(
                                    LPCSTR pszPath,
                                    DWORD dwContext)
{    
    HRESULT         hr = S_OK;
    LPHTTPQUEUEDOP  pOp = NULL;

    if (NULL == pszPath)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    if (FAILED(hr = AllocQueuedOperation(pszPath, NULL, 0, &pOp)))
        goto exit;
    
    pOp->command = HTTPMAIL_DELETE;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfDelete;
    pOp->cState = ARRAYSIZE(c_rgpfDelete);

    QueueOperation(pOp);

exit:
    return hr;
}

// ----------------------------------------------------------------------------
// CHTTPMailTransport::CommandBDELETE
// ----------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::CommandBDELETE(
                                    LPCSTR pszPath,
                                    LPHTTPTARGETLIST pBatchTargets,
                                    DWORD dwContext)
{    
    HRESULT         hr = S_OK;
    LPHTTPQUEUEDOP  pOp = NULL;
    LPVOID          pvXML = NULL;
    DWORD           dwXMLLen = 0;

    if (NULL == pszPath || NULL == pBatchTargets)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    if (FAILED(hr = HrGenerateSimpleBatchXML(c_szDelete, pBatchTargets, &pvXML, &dwXMLLen)))
        goto exit;

    if (FAILED(hr = AllocQueuedOperation(pszPath, pvXML, dwXMLLen, &pOp, TRUE)))
        goto exit;
    
    pvXML = NULL;

    pOp->command = HTTPMAIL_BDELETE;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfDelete;
    pOp->cState = ARRAYSIZE(c_rgpfDelete);
    pOp->dwRHFlags = RH_XMLCONTENTTYPE;

    QueueOperation(pOp);

exit:
    SafeMemFree(pvXML);

    return hr;
}
// ----------------------------------------------------------------------------
// CHTTPMailTransport::CommandPROPFIND
// ----------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::CommandPROPFIND(
                                    LPCSTR pszPath,
                                    IPropFindRequest *pRequest,
                                    DWORD dwDepth,
                                    DWORD dwContext)
{
    if (NULL == pszPath || NULL == pRequest)
        return TrapError(E_INVALIDARG);

    return E_NOTIMPL;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::CommandPROPPATCH
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::CommandPROPPATCH(
                                        LPCSTR pszUrl, 
                                        IPropPatchRequest *pRequest, 
                                        DWORD dwContext)
{
    if (NULL == pszUrl || NULL == pRequest)
        return TrapError(E_INVALIDARG);

    HRESULT         hr = S_OK;
    LPHTTPQUEUEDOP  pOp = NULL;

    FAIL_CREATEWND;

    if (FAILED(hr = AllocQueuedOperation(pszUrl, NULL, 0, &pOp)))
        goto exit;

    pOp->command = HTTPMAIL_PROPPATCH;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnPropPatch;
    pOp->cState = ARRAYSIZE(c_rgpfnPropPatch);
    pOp->pPropPatchRequest = pRequest;
    pRequest->AddRef();
    pOp->dwRHFlags = RH_XMLCONTENTTYPE;

    QueueOperation(pOp);

exit:
    return hr;
}
    
// --------------------------------------------------------------------------------
// CHTTPMailTransport::CommandMKCOL
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::CommandMKCOL(LPCSTR pszUrl, DWORD dwContext)
{
    HRESULT             hr = S_OK;
    LPHTTPQUEUEDOP      pOp = NULL;

    if (NULL == pszUrl)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    if (FAILED(hr = AllocQueuedOperation(pszUrl, NULL, 0, &pOp)))
        goto exit;

    pOp->command   = HTTPMAIL_MKCOL;
    pOp->dwContext = dwContext;
    pOp->pfnState  = c_rgpfnMkCol;
    pOp->cState    = ARRAYSIZE(c_rgpfnMkCol);
    QueueOperation(pOp);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::CommandCOPY
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::CommandCOPY(
                                    LPCSTR pszPath, 
                                    LPCSTR pszDestination, 
                                    BOOL fAllowRename,
                                    DWORD dwContext)
{
    HRESULT         hr = S_OK;
    LPHTTPQUEUEDOP  pOp;
    LPSTR           pszDupDestination = NULL;

    if (NULL == pszPath || NULL == pszDestination)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    pszDupDestination = PszDupA(pszDestination);
    if (NULL == pszDupDestination)
        return TrapError(E_OUTOFMEMORY);

    if (FAILED(hr = AllocQueuedOperation(pszPath, NULL, 0, &pOp)))
        goto exit;

    pOp->command = HTTPMAIL_COPY;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnCopy;
    pOp->cState = ARRAYSIZE(c_rgpfnCopy);

    pOp->pszDestination = pszDupDestination;
    pszDupDestination = NULL;

    if (fAllowRename)
        pOp->dwRHFlags = RH_ALLOWRENAME;

    QueueOperation(pOp);

exit:
    SafeMemFree(pszDupDestination);

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::CommandBCOPY
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::CommandBCOPY(
                                    LPCSTR pszSourceCollection, 
                                    LPHTTPTARGETLIST pTargets, 
                                    LPCSTR pszDestCollection, 
                                    LPHTTPTARGETLIST pDestinations,
                                    BOOL fAllowRename,
                                    DWORD dwContext)
{
    HRESULT         hr = S_OK;
    LPHTTPQUEUEDOP  pOp = NULL;
    LPVOID          pvXML = NULL;
    DWORD           dwXMLLen = 0;
    LPSTR           pszDupDestination = NULL;

    if (NULL == pszSourceCollection || NULL == pTargets || NULL == pszDestCollection)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    pszDupDestination = PszDupA(pszDestCollection);
    if (NULL == pszDupDestination)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    if (NULL == pDestinations)
        hr = HrGenerateSimpleBatchXML(c_szCopy, pTargets, &pvXML, &dwXMLLen);
    else
        hr = HrGenerateMultiDestBatchXML(c_szCopy, pTargets, pDestinations, &pvXML, &dwXMLLen);

    if (FAILED(hr))
        goto exit;

    if (FAILED(hr = AllocQueuedOperation(pszSourceCollection, pvXML, dwXMLLen, &pOp, TRUE)))
        goto exit;

    pvXML = NULL;

    pOp->command = HTTPMAIL_BCOPY;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnBMove;
    pOp->cState = ARRAYSIZE(c_rgpfnBMove);
    pOp->pParseFuncs = c_rgpfnBCopyMoveParse;

    pOp->pszDestination = pszDupDestination;
    pszDupDestination = NULL;
    
    pOp->dwRHFlags = RH_XMLCONTENTTYPE;
    if (fAllowRename)
        pOp->dwRHFlags |= RH_ALLOWRENAME;

    QueueOperation(pOp);

exit:
    SafeMemFree(pvXML);
    SafeMemFree(pszDupDestination);
    return hr;
}


// --------------------------------------------------------------------------------
// CHTTPMailTransport::CommandMOVE
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::CommandMOVE(
                                    LPCSTR pszPath, 
                                    LPCSTR pszDestination,
                                    BOOL fAllowRename,
                                    DWORD dwContext)
{
    HRESULT         hr = S_OK;
    LPHTTPQUEUEDOP  pOp;
    LPSTR           pszDupDestination = NULL;

    if (NULL == pszPath || NULL == pszDestination)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    pszDupDestination = PszDupA(pszDestination);
    if (NULL == pszDupDestination)
        return TrapError(E_OUTOFMEMORY);

    if (FAILED(hr = AllocQueuedOperation(pszPath, NULL, 0, &pOp)))
        goto exit;

    pOp->command = HTTPMAIL_MOVE;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnMove;
    pOp->cState = ARRAYSIZE(c_rgpfnMove);

    pOp->pszDestination = pszDupDestination;
    pszDupDestination = NULL;
    
    if (fAllowRename)
        pOp->dwRHFlags = RH_ALLOWRENAME;
    
    QueueOperation(pOp);

exit:
    SafeMemFree(pszDupDestination);

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::CommandBMOVE
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::CommandBMOVE(
                                    LPCSTR pszSourceCollection, 
                                    LPHTTPTARGETLIST pTargets, 
                                    LPCSTR pszDestCollection, 
                                    LPHTTPTARGETLIST pDestinations,
                                    BOOL fAllowRename,
                                    DWORD dwContext)
{
    HRESULT         hr = S_OK;
    LPHTTPQUEUEDOP  pOp = NULL;
    LPVOID          pvXML = NULL;
    DWORD           dwXMLLen = 0;
    LPSTR           pszDupDestination = NULL;

    if (NULL == pszSourceCollection || NULL == pTargets || NULL == pszDestCollection)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    pszDupDestination = PszDupA(pszDestCollection);
    if (NULL == pszDupDestination)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    if (NULL == pDestinations)
        hr = HrGenerateSimpleBatchXML(c_szMove, pTargets, &pvXML, &dwXMLLen);
    else
        hr = HrGenerateMultiDestBatchXML(c_szMove, pTargets, pDestinations, &pvXML, &dwXMLLen);

    if (FAILED(hr))
        goto exit;

    if (FAILED(hr = AllocQueuedOperation(pszSourceCollection, pvXML, dwXMLLen, &pOp, TRUE)))
        goto exit;

    pvXML = NULL;

    pOp->command = HTTPMAIL_BMOVE;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnBMove;
    pOp->cState = ARRAYSIZE(c_rgpfnBMove);
    pOp->pParseFuncs = c_rgpfnBCopyMoveParse;

    pOp->pszDestination = pszDupDestination;
    pszDupDestination = NULL;

    pOp->dwRHFlags = RH_XMLCONTENTTYPE;
    if (fAllowRename)
        pOp->dwRHFlags |= RH_ALLOWRENAME;

    QueueOperation(pOp);

exit:
    SafeMemFree(pvXML);
    SafeMemFree(pszDupDestination);
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::MemberInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::MemberInfo(
                                        LPCSTR pszPath, 
                                        MEMBERINFOFLAGS flags, 
                                        DWORD dwDepth,
                                        BOOL fIncludeRoot,
                                        DWORD dwContext)
{
    HRESULT             hr = S_OK;
    LPHTTPQUEUEDOP      pOp = NULL;

    if (NULL == pszPath)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    if (FAILED(hr = AllocQueuedOperation(pszPath, NULL, 0, &pOp)))
        goto exit;

    pOp->command = HTTPMAIL_MEMBERINFO;
    pOp->dwMIFlags = flags;
    pOp->dwDepth = dwDepth;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnMemberInfo;
    pOp->cState = ARRAYSIZE(c_rgpfnMemberInfo);
    pOp->pParseFuncs = c_rgpfnMemberInfoParse;

    pOp->dwRHFlags = (RH_BRIEF | RH_XMLCONTENTTYPE);
    if (!fIncludeRoot)
        pOp->dwRHFlags |= RH_NOROOT;

    QueueOperation(pOp);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::FindFolders
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::FindFolders(LPCSTR pszPath, DWORD dwContext)
{
    return E_NOTIMPL;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::MarkRead
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::MarkRead(
                                LPCSTR                  pszPath,
                                LPHTTPTARGETLIST        pTargets,
                                BOOL                    fMarkRead,
                                DWORD                   dwContext)
{
    HRESULT             hr = S_OK;
    LPHTTPQUEUEDOP      pOp = NULL;
    CPropPatchRequest   *pRequest = NULL;
    LPSTR               pszXML = NULL;

    if (NULL == pszPath)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    pRequest = new CPropPatchRequest();
    if (NULL == pRequest)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }
    
    if (fMarkRead)
        FAIL_EXIT(hr = pRequest->SetProperty(DAVNAMESPACE_HTTPMAIL, "read", "1"));
    else
        FAIL_EXIT(hr = pRequest->SetProperty(DAVNAMESPACE_HTTPMAIL, "read", "0"));
    
    FAIL_EXIT(hr = pRequest->GenerateXML(pTargets, &pszXML));

    FAIL_EXIT(hr = AllocQueuedOperation(pszPath, pszXML, lstrlen(pszXML), &pOp, TRUE));
    pszXML = NULL;
    
    pOp->command = HTTPMAIL_MARKREAD;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnMarkRead;
    pOp->cState = ARRAYSIZE(c_rgpfnMarkRead);
    pOp->pParseFuncs = c_rgpfnMemberErrorParse;

    pOp->dwRHFlags = (RH_BRIEF | RH_XMLCONTENTTYPE);
    if (pTargets && pTargets->cTarget > 0)
        pOp->fBatch = TRUE;

    QueueOperation(pOp);

exit:
    SafeRelease(pRequest);
    SafeMemFree(pszXML);
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::SendMessage
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::SendMessage(LPCSTR pszPath, 
                                        LPCSTR pszFrom, 
                                        LPHTTPTARGETLIST pTargets, 
                                        BOOL fSaveInSent, 
                                        IStream *pMessageStream, 
                                        DWORD dwContext)
{
    HRESULT             hr = S_OK;
    LPHTTPQUEUEDOP      pOp = NULL;
    IStream             *pRfc821Stream = NULL;

    if (NULL == pszPath || 
            NULL == pszFrom || 
            NULL == pTargets || pTargets->cTarget < 1 ||
            NULL == pMessageStream)
        return E_INVALIDARG;

    FAIL_CREATEWND;

    // build the rfc821 stream that will precede the mime message
    FAIL_EXIT(hr = _HrGenerateRfc821Stream(pszFrom, pTargets, &pRfc821Stream));

    FAIL_EXIT(hr = AllocQueuedOperation(pszPath, NULL, 0, &pOp));

    pOp->command = HTTPMAIL_SENDMESSAGE;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnSendMessage;
    pOp->cState = ARRAYSIZE(c_rgpfnSendMessage);
    pOp->pHeaderStream = pRfc821Stream;
    pRfc821Stream = NULL;
    pOp->pBodyStream = pMessageStream;
    if (NULL != pOp->pBodyStream)
        pOp->pBodyStream->AddRef();
    pOp->dwRHFlags = (RH_TRANSLATETRUE | RH_SMTPMESSAGECONTENTTYPE);
    pOp->dwRHFlags |= (fSaveInSent ? RH_SAVEINSENTTRUE : RH_SAVEINSENTFALSE);

    QueueOperation(pOp);

exit:
    SafeRelease(pRfc821Stream);

    return hr;

}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ListContacts
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::ListContacts(LPCSTR pszPath, DWORD dwContext)
{
    HRESULT             hr = S_OK;
    LPHTTPQUEUEDOP      pOp = NULL;

    if (NULL == pszPath)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    if (FAILED(hr = AllocQueuedOperation(pszPath, NULL, 0, &pOp)))
        goto exit;

    pOp->command = HTTPMAIL_LISTCONTACTS;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnListContacts;
    pOp->cState = ARRAYSIZE(c_rgpfnListContacts);
    pOp->pParseFuncs = c_rgpfnListContactsParse;

    pOp->dwDepth = 1;
    pOp->dwRHFlags = (RH_NOROOT | RH_XMLCONTENTTYPE);

    QueueOperation(pOp);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ListContactInfos
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::ListContactInfos(LPCSTR pszCollectionPath, DWORD dwContext)
{
    HRESULT             hr = S_OK;
    LPHTTPQUEUEDOP      pOp = NULL;

    if (NULL == pszCollectionPath)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    if (FAILED(hr = AllocQueuedOperation(pszCollectionPath, NULL, 0, &pOp)))
        goto exit;

    pOp->command = HTTPMAIL_CONTACTINFO;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnContactInfo;
    pOp->cState = ARRAYSIZE(c_rgpfnContactInfo);
    pOp->pParseFuncs = c_rgpfnContactInfoParse;

    pOp->dwDepth = 1;
    pOp->dwRHFlags = (RH_NOROOT | RH_XMLCONTENTTYPE);

    QueueOperation(pOp);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ContactInfo
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::ContactInfo(LPCSTR pszPath, DWORD dwContext)
{
    HRESULT             hr = S_OK;
    LPHTTPQUEUEDOP      pOp = NULL;

    if (NULL == pszPath)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    if (FAILED(hr = AllocQueuedOperation(pszPath, NULL, 0, &pOp)))
        goto exit;

    pOp->command = HTTPMAIL_CONTACTINFO;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnContactInfo;
    pOp->cState = ARRAYSIZE(c_rgpfnContactInfo);
    pOp->pParseFuncs = c_rgpfnContactInfoParse;

    pOp->dwDepth = 0;
    pOp->dwRHFlags = RH_XMLCONTENTTYPE;

    QueueOperation(pOp);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::PostContact
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::PostContact(LPCSTR pszPath, 
                                        LPHTTPCONTACTINFO pciInfo, 
                                        DWORD dwContext)
{
    HRESULT             hr = S_OK;
    LPHTTPQUEUEDOP      pOp = NULL;
    LPVOID              pvXML = NULL;
    DWORD               cb;

    if (NULL == pciInfo)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    if (FAILED(hr = HrGeneratePostContactXML(pciInfo, &pvXML, &cb)))
        goto exit;

    if (FAILED(hr = AllocQueuedOperation(pszPath, NULL, 0, &pOp)))
        goto exit;

    pOp->pvData = pvXML;
    pOp->cbDataLen = cb;
    pvXML = NULL;

    pOp->command = HTTPMAIL_POSTCONTACT;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnPostContact;
    pOp->cState = ARRAYSIZE(c_rgpfnPostContact);

    pOp->dwDepth = 0;
    pOp->dwRHFlags = (RH_XMLCONTENTTYPE | RH_TRANSLATEFALSE);

    QueueOperation(pOp);

exit:
    SafeMemFree(pvXML);

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::PatchContact
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::PatchContact(LPCSTR pszPath, 
                                         LPHTTPCONTACTINFO pciInfo, 
                                         DWORD dwContext)
{
    HRESULT             hr = S_OK;
    LPHTTPQUEUEDOP      pOp = NULL;
    IPropPatchRequest   *pRequest = NULL;

    if (NULL == pciInfo)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

    if (FAILED(hr = HrCreatePatchContactRequest(pciInfo, &pRequest)))
        goto exit;

    if (FAILED(hr = AllocQueuedOperation(pszPath, NULL, 0, &pOp)))
        goto exit;

    pOp->command = HTTPMAIL_PATCHCONTACT;
    pOp->dwContext = dwContext;
    pOp->pfnState = c_rgpfnPatchContact;
    pOp->cState = ARRAYSIZE(c_rgpfnPatchContact);

    pOp->pPropPatchRequest = pRequest;
    pRequest = NULL;

    pOp->dwRHFlags = RH_XMLCONTENTTYPE;

    QueueOperation(pOp);

exit:
    SafeRelease(pRequest);

    return hr;
}

// --------------------------------------------------------------------------------
// INodeFactory Methods
// --------------------------------------------------------------------------------
 
// --------------------------------------------------------------------------------
// CHTTPMailTransport::NotifyEvent
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::NotifyEvent(IXMLNodeSource* pSource, 
                                             XML_NODEFACTORY_EVENT iEvt)
{
    return S_OK;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::BeginChildren
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::BeginChildren(IXMLNodeSource* pSource, XML_NODE_INFO *pNodeInfo)
{
    if (m_op.dwStackDepth <= ELE_STACK_CAPACITY)
        m_op.rgEleStack[m_op.dwStackDepth - 1].fBeganChildren = TRUE;

    return S_OK;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::EndChildren
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::EndChildren(
                                    IXMLNodeSource* pSource, 
                                    BOOL fEmpty, 
                                    XML_NODE_INFO *pNodeInfo)
{
    HRESULT hr = S_OK;

    IxpAssert(HTTPMAIL_NONE != m_op.rResponse.command);
    IxpAssert(NULL != m_op.pParseFuncs);

    if (HTTPMAIL_NONE == m_op.rResponse.command || NULL == m_op.pParseFuncs)
    {
        hr = E_FAIL;
        goto exit;
    }

    if (XML_ELEMENT == pNodeInfo->dwType)
        hr = (this->*(m_op.pParseFuncs->pfnEndChildren))();

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::Error
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::Error(IXMLNodeSource* pSource, 
                                       HRESULT hrErrorCode, 
                                       USHORT cNumRecs, 
                                       XML_NODE_INFO** apNodeInfo)
{
    BSTR  bstr = NULL;

    if (NULL == m_op.rResponse.rIxpResult.pszResponse)
    {
        if (FAILED(pSource->GetErrorInfo(&bstr)))
            goto exit;
    
        HrBSTRToLPSZ(CP_ACP, bstr, &m_op.rResponse.rIxpResult.pszResponse);
    }

exit:
    if (NULL != bstr)
        SysFreeString(bstr);

    return S_OK;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::CreateNode
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::CreateNode(
                        IXMLNodeSource* pSource, 
                        PVOID pNodeParent,
                        USHORT cNumRecs,
                        XML_NODE_INFO** apNodeInfo)
{
    HRESULT         hr = S_OK;
    LPPCDATABUFFER  pTextBuffer = NULL;
    CXMLNamespace   *pBaseNamespace = m_op.pTopNamespace;
    XML_NODE_INFO   *pNodeInfo;

    IxpAssert(HTTPMAIL_NONE != m_op.rResponse.command);
    IxpAssert(NULL != m_op.pParseFuncs);

    if (HTTPMAIL_NONE == m_op.rResponse.command || NULL == m_op.pParseFuncs)
    {
        hr = E_FAIL;
        goto exit;
    }

    if (NULL == apNodeInfo || 0 == cNumRecs)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    pNodeInfo = apNodeInfo[0];

    switch (pNodeInfo->dwType)
    {
        case XML_ELEMENT:
            if (cNumRecs > 1 && FAILED(hr = PushNamespaces(apNodeInfo, cNumRecs)))
                goto exit;
            hr = (this->*(m_op.pParseFuncs->pfnCreateElement))(pBaseNamespace, pNodeInfo->pwcText, pNodeInfo->ulLen, pNodeInfo->ulNsPrefixLen, pNodeInfo->fTerminal);
            break;

        case XML_PCDATA:
            // we only parse element content...we don't care about attributes
            if (InValidElementChildren())
            {
                // get the buffer
                pTextBuffer = m_op.rgEleStack[m_op.dwStackDepth - 1].pTextBuffer;

                // request one if we don't already have one
                if (NULL == pTextBuffer)
                {
                    if (FAILED(hr = _GetTextBuffer(&pTextBuffer)))
                        goto exit;
                    m_op.rgEleStack[m_op.dwStackDepth - 1].pTextBuffer = pTextBuffer;
                }
                
                hr = _AppendTextToBuffer(pTextBuffer, pNodeInfo->pwcText, pNodeInfo->ulLen);
                    goto exit;
            }
            break;
            
        default:
            break;
    }

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_HrThunkConnectionError
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::_HrThunkConnectionError(void)
{
    return _HrThunkConnectionError(m_op.dwHttpStatus);
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_HrThunkConnectionError
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::_HrThunkConnectionError(DWORD dwStatus)
{
    IxpAssert(NULL == m_op.rResponse.rIxpResult.pszResponse);
    IxpAssert(NULL == m_op.rResponse.rIxpResult.pszProblem);

    if (m_pLogFile && !m_op.fLoggedResponse)
        _LogResponse(NULL, 0);

    m_op.rResponse.rIxpResult.hrResult = HttpErrorToIxpResult(dwStatus);
    _GetRequestHeader(&m_op.rResponse.rIxpResult.pszResponse, HTTP_QUERY_STATUS_TEXT);
    m_op.rResponse.rIxpResult.dwSocketError = GetLastError();

    return _HrThunkResponse(TRUE);
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_HrThunkResponse
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::_HrThunkResponse(BOOL fDone)
{
    HRESULT     hr = S_OK;
    BOOL        fSendResponse;

    // Thread safety
    EnterCriticalSection(&m_cs);

    IxpAssert(HTTPMAIL_NONE != m_op.rResponse.command);

    if (m_op.rResponse.fDone)
    {
        fSendResponse = FALSE;
    }
    else
    {
        fSendResponse = TRUE;

        if (!fDone && WasAborted())
        {
            m_op.rResponse.rIxpResult.hrResult = IXP_E_USER_CANCEL;
            m_op.rResponse.fDone = TRUE;
        }
        else
            m_op.rResponse.fDone = fDone;
    }

    LeaveCriticalSection(&m_cs);

    if (fSendResponse)
        hr = (HRESULT) ::SendMessage(m_hwnd, SPM_HTTPMAIL_SENDRESPONSE, 0, NULL);

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::InvokeResponseCallback
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::InvokeResponseCallback(void)
{
    HRESULT             hr = S_OK;
    IHTTPMailCallback   *pCallback = NULL;

    EnterCriticalSection(&m_cs);

    if (m_pCallback)
    {
        pCallback = m_pCallback;
        pCallback->AddRef();
    }

    LeaveCriticalSection(&m_cs);

    if (pCallback)
    {
        hr = pCallback->OnResponse(&m_op.rResponse);
        pCallback->Release();
    }

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::InitNew
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::InitNew(
                    LPCSTR pszUserAgent,
                    LPCSTR pszLogFilePath, 
                    IHTTPMailCallback *pCallback)
{   
    HRESULT hr = S_OK;

    if (NULL == pszUserAgent || NULL == pCallback)
        return TrapError(E_INVALIDARG);

    IxpAssert(NULL == m_hInternet);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    if (IXP_DISCONNECTED != m_status)
    {
        hr = TrapError(IXP_E_ALREADY_CONNECTED);
        goto exit;
    }

    Reset();

    m_pszUserAgent = PszDupA(pszUserAgent);
    if (NULL == m_pszUserAgent)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // open log file
    if (pszLogFilePath)
        CreateLogFile(g_hInst, pszLogFilePath, "HTTPMAIL", DONT_TRUNCATE, &m_pLogFile,
            FILE_SHARE_READ | FILE_SHARE_WRITE);
    
    m_pCallback = pCallback;
    m_pCallback->AddRef();

    m_hInternet = InternetOpen(m_pszUserAgent, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
    if (NULL == m_hInternet)
    {
        hr = TrapError(IXP_E_SOCKET_INIT_ERROR);
        goto exit;
    }
        
    // Install the callback ptr for the internet handle and all of its derived handles
    //InternetSetStatusCallbackA(m_hInternet, StatusCallbackProxy);

exit:
    LeaveCriticalSection(&m_cs);
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::OnStatusCallback
// --------------------------------------------------------------------------------
void CHTTPMailTransport::OnStatusCallback(
                    HINTERNET hInternet,
                    DWORD dwInternetStatus,
                    LPVOID pvStatusInformation,
                    DWORD dwStatusInformationLength)
{
#if 0
    // Locals
    IXPSTATUS           ixps;

    EnterCriticalSection(&m_cs);

    // if the status message is one of the defined IXPSTATUS messages,
    // notify the callback.
    if ((NULL != m_pCallback) && TranslateWinInetMsg(dwInternetStatus, &ixps))
        m_pCallback->OnStatus(ixps, (IHTTPMailTransport *)this);

    // for now, we just handle the request_complete message
    if (INTERNET_STATUS_REQUEST_COMPLETE == dwInternetStatus)
        HrCommandCompleted();

    LeaveCriticalSection(&m_cs);
#endif
}

// ----------------------------------------------------------------------------
// CHTTPMailTransport::AllocQueuedOperation
// ----------------------------------------------------------------------------
HRESULT CHTTPMailTransport::AllocQueuedOperation(
                                    LPCSTR pszUrl, 
                                    LPVOID pvData, 
                                    ULONG cbDataLen,
                                    LPHTTPQUEUEDOP *ppOp,
                                    BOOL fAdoptData)
{
    HRESULT hr = S_OK;
    LPHTTPQUEUEDOP pTempOp = NULL;

    if (!MemAlloc((void **)&pTempOp , sizeof(HTTPQUEUEDOP)))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    ZeroMemory(pTempOp, sizeof(HTTPQUEUEDOP));
    
    if (NULL != pszUrl)
    {
        pTempOp->pszUrl = PszDupA(pszUrl);
        if (NULL == pTempOp->pszUrl)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
    }
    
    // can't have a length if data ptr is null
    IxpAssert(!pvData || cbDataLen);
    if (pvData)
    {
        if (!fAdoptData)
        {
            if (!MemAlloc((LPVOID*)&pTempOp->pvData, cbDataLen + 1))
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            CopyMemory(pTempOp->pvData, pvData, cbDataLen);
            ((char *)pTempOp->pvData)[cbDataLen] = '\0';
        }
        else
            pTempOp->pvData = pvData;

        pTempOp->cbDataLen = cbDataLen;
    }

    *ppOp = pTempOp;
    pTempOp = NULL;

exit:
    if (pTempOp)
    {
        SafeMemFree(pTempOp->pszUrl);
        if (!fAdoptData)
            SafeMemFree(pTempOp->pvData);

        MemFree(pTempOp);
    }

    return hr;
}

// ----------------------------------------------------------------------------
// CHTTPMailTransport::QueueOperation
// ----------------------------------------------------------------------------
void CHTTPMailTransport::QueueOperation(LPHTTPQUEUEDOP pOp)
{
    // Thread safety
    EnterCriticalSection(&m_cs);

    if (m_opPendingTail)
        m_opPendingTail->pNext = pOp;
    else
    {
        // if there is no tail, there shouldn't be a head
        IxpAssert(!m_opPendingHead);
        m_opPendingHead = m_opPendingTail = pOp;
    }

    // signal the io thread
    SetEvent(m_hevPendingCommand);

    // Thread Safety
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::StatusCallbackProxy
// --------------------------------------------------------------------------------
void CHTTPMailTransport::StatusCallbackProxy(
                    HINTERNET hInternet, 
                    DWORD dwContext, 
                    DWORD dwInternetStatus, 
                    LPVOID pvStatusInformation,
                    DWORD dwStatusInformationLength)
{
    // Locals
    CHTTPMailTransport  *pHTTPMail = reinterpret_cast<CHTTPMailTransport *>(IntToPtr(dwContext));

    IxpAssert(NULL != pHTTPMail);
    
    if (NULL != pHTTPMail)
        pHTTPMail->OnStatusCallback(hInternet, dwInternetStatus, pvStatusInformation, dwStatusInformationLength);
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::DoOperation
// --------------------------------------------------------------------------------
void CHTTPMailTransport::DoOperation(void)
{
    HRESULT hr = S_OK;

    while (m_op.iState < m_op.cState)
    {
        hr = (this->*(m_op.pfnState[m_op.iState]))();

        if (FAILED(hr))
            break;

        m_op.iState++;
    }

    if (!m_op.rResponse.fDone && FAILED(hr))
    {
        m_op.rResponse.rIxpResult.hrResult = hr;
        _HrThunkResponse(TRUE);
    }

    FreeOperation();
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::FreeOperation
// --------------------------------------------------------------------------------
void CHTTPMailTransport::FreeOperation(void)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    SafeMemFree(m_op.pszUrl);
    SafeMemFree(m_op.pszDestination);
    if (m_op.pszContentType)
    {
        MemFree((void *)m_op.pszContentType);
        m_op.pszContentType = NULL;

    }
    SafeMemFree(m_op.pvData);
    SafeInternetCloseHandle(m_op.hRequest);
    SafeRelease(m_op.pPropFindRequest);
    SafeRelease(m_op.pPropPatchRequest);
    if (NULL != m_op.rgszAcceptTypes)
        FreeStringList(m_op.rgszAcceptTypes);
    SafeRelease(m_op.pHeaderStream);
    SafeRelease(m_op.pBodyStream);

    if (m_op.pTextBuffer)
        _FreeTextBuffer(m_op.pTextBuffer);

    // Free the response
    SafeMemFree(m_op.rResponse.rIxpResult.pszResponse);
    SafeMemFree(m_op.rResponse.rIxpResult.pszProblem);

    PopNamespaces(NULL);

    // in the case of an error, the element stack can
    // contain text buffers that need to be freed
    for (DWORD i = 0; i < m_op.dwStackDepth; ++i)
    {
        if (NULL != m_op.rgEleStack[i].pTextBuffer)
            _FreeTextBuffer(m_op.rgEleStack[i].pTextBuffer);
    }

    SafeMemFree(m_op.rResponse.rIxpResult.pszResponse);

    switch (m_op.rResponse.command)
    {
        case HTTPMAIL_GET:
            SafeMemFree(m_op.rResponse.rGetInfo.pvBody);
            SafeMemFree(m_op.rResponse.rGetInfo.pszContentType);
            break;

        case HTTPMAIL_POST:
        case HTTPMAIL_SENDMESSAGE:
            SafeMemFree(m_op.rResponse.rPostInfo.pszLocation);
            break;

        case HTTPMAIL_COPY:
        case HTTPMAIL_MOVE:
        case HTTPMAIL_MKCOL:
            SafeMemFree(m_op.rResponse.rCopyMoveInfo.pszLocation);
            break;

        case HTTPMAIL_BCOPY:
        case HTTPMAIL_BMOVE:
            SafeMemFree(m_op.rResponse.rBCopyMoveList.prgBCopyMove);
            break;
        
        case HTTPMAIL_MEMBERINFO:
            FreeMemberInfoList();
            SafeMemFree(m_op.rResponse.rMemberInfoList.prgMemberInfo);
            SafeMemFree(m_op.pszRootTimeStamp);
            SafeMemFree(m_op.pszFolderTimeStamp);
            SafeMemFree(m_op.rResponse.rMemberInfoList.pszRootTimeStamp);
            SafeMemFree(m_op.rResponse.rMemberInfoList.pszFolderTimeStamp);
            break;

        case HTTPMAIL_MARKREAD:
            FreeMemberErrorList();
            SafeMemFree(m_op.rResponse.rMemberErrorList.prgMemberError);
            break;


        case HTTPMAIL_LISTCONTACTS:
            FreeContactIdList();
            SafeMemFree(m_op.rResponse.rContactIdList.prgContactId);
            break;

        case HTTPMAIL_CONTACTINFO:
            FreeContactInfoList();
            SafeMemFree(m_op.rResponse.rContactInfoList.prgContactInfo);
            break;

        case HTTPMAIL_POSTCONTACT:
            XP_FREE_STRUCT(HTTPCONTACTID, &m_op.rResponse.rPostContactInfo, NULL);
            break;
           
        case HTTPMAIL_PATCHCONTACT:
            XP_FREE_STRUCT(HTTPCONTACTID, &m_op.rResponse.rPatchContactInfo, NULL);
            break;

        default:
            break;
    }

    ZeroMemory(&m_op, sizeof(HTTPMAILOPERATION));
    m_op.rResponse.command = HTTPMAIL_NONE;
    
    // Thread Safety
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_BindToStruct
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::_BindToStruct(const WCHAR *pwcText,
                                          ULONG ulLen,
                                          const XPCOLUMN *prgCols,
                                          DWORD cCols,
                                          LPVOID pTarget,
                                          BOOL *pfWasBound)
{
    HRESULT                 hr = S_OK;
    DWORD                   dwColIndex;
    DWORD                   dwColFlags;
    LPSTR                   *ppsz;
    DWORD                   *pdw;
    BOOL                    *pb;
    HTTPMAILSPECIALFOLDER   *ptySpecial;
    HTTPMAILCONTACTTYPE     *ptyContact;
    HMELE                   ele;
    HRESULT                 *phr;

    if (pfWasBound)
        *pfWasBound = FALSE;

    // if the stack is overflowed, we definitely won't do anything with the text
    if (m_op.dwStackDepth >= ELE_STACK_CAPACITY)
        goto exit;

    ele = m_op.rgEleStack[m_op.dwStackDepth - 1].ele;

    for (dwColIndex = 0; dwColIndex < cCols; dwColIndex++)
    {
        if (ele == prgCols[dwColIndex].ele)
            break;
    }

    if (dwColIndex >= cCols)
        goto exit;

    dwColFlags = prgCols[dwColIndex].dwFlags;

    // the column may require validation of the element stack
    if (!!(dwColFlags & XPCF_MSVALIDPROP))
    {
        if (!VALIDSTACK(c_rgPropFindPropValueStack))
            goto exit;
    }
    else if (!!(dwColFlags & XPCF_MSVALIDMSRESPONSECHILD))
    {
        if (!VALIDSTACK(c_rgMultiStatusResponseChildStack))
            goto exit;
    }

    if (dwColIndex < cCols)
    {
        switch (prgCols[dwColIndex].cdt)
        {
            case XPCDT_STRA:
                ppsz = (LPSTR *)(((char *)pTarget) + prgCols[dwColIndex].offset);
                SafeMemFree(*ppsz);
                hr = AllocStrFromStrNW(pwcText, ulLen, ppsz);
                break;

            case XPCDT_DWORD:
                pdw = (DWORD *)(((char *)pTarget) + prgCols[dwColIndex].offset);
                *pdw = 0;
                hr = StrNToDwordW(pwcText, ulLen, pdw);
                break;

            case XPCDT_BOOL:
                pb = (BOOL *)(((char *)pTarget) + prgCols[dwColIndex].offset);
                *pb = FALSE;
                hr = StrNToBoolW(pwcText, ulLen, pb);
                break;

            case XPCDT_IXPHRESULT:
                phr = (HRESULT *)(((char *)pTarget) + prgCols[dwColIndex].offset);
                *phr = S_OK;
                hr = StatusStrNToIxpHr(pwcText, ulLen, phr);
                break;

            case XPCDT_HTTPSPECIALFOLDER:
                ptySpecial = (HTTPMAILSPECIALFOLDER *)(((char *)pTarget) + prgCols[dwColIndex].offset);
                *ptySpecial = HTTPMAIL_SF_NONE;
                hr = StrNToSpecialFolderW(pwcText, ulLen, ptySpecial);
                break;

            case XPCDT_HTTPCONTACTTYPE:
                ptyContact = (HTTPMAILCONTACTTYPE *)(((char *)pTarget) + prgCols[dwColIndex].offset);
                *ptyContact = HTTPMAIL_CT_CONTACT;
                hr = StrNToContactTypeW(pwcText, ulLen, ptyContact);
                break;

            default:
                IxpAssert(FALSE);
                break;
        }

        if (FAILED(hr))
            goto exit;

        // set the bit in the flag word to indicate that this field
        // has been set.
        if (!(dwColFlags & XPCF_DONTSETFLAG))
            m_op.dwPropFlags |= (1 << dwColIndex);

        if (pfWasBound)
            *pfWasBound = TRUE;
    }

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_FreeStruct
// --------------------------------------------------------------------------------
void CHTTPMailTransport::_FreeStruct(const XPCOLUMN *prgCols,
                                     DWORD cCols,
                                     LPVOID pTarget,
                                     DWORD *pdwFlags)
{
    DWORD                   dwFlags;
    DWORD                   dwIndex = 0;
    LPSTR                   *ppsz;
    DWORD                   *pdw;
    BOOL                    *pb;
    HTTPMAILSPECIALFOLDER   *ptySpecial;
    HTTPMAILCONTACTTYPE     *ptyContact;
    HRESULT                 *phr;

    if (NULL != pdwFlags)
    {   
        dwFlags = *pdwFlags;
        *pdwFlags = NOFLAGS;
    }   
    else
        dwFlags = 0xFFFFFFFF;

    while (0 != dwFlags && dwIndex < cCols)
    {
        // test the low bit
        if (!!(dwFlags & 0x00000001))
        {
            switch (prgCols[dwIndex].cdt)
            {
                case XPCDT_STRA:
                    ppsz = (LPSTR *)(((char *)pTarget) + prgCols[dwIndex].offset);
                    SafeMemFree(*ppsz);
                    break;

                case XPCDT_DWORD:
                    pdw = (DWORD *)(((char *)pTarget) + prgCols[dwIndex].offset);
                    *pdw = 0;
                    break;

                case XPCDT_BOOL:
                    pb = (BOOL *)(((char *)pTarget) + prgCols[dwIndex].offset);
                    *pb = FALSE;
                    break;

                case XPCDT_IXPHRESULT:
                    phr = (HRESULT *)(((char *)pTarget) + prgCols[dwIndex].offset);
                    *phr = S_OK;
                    break;

                case XPCDT_HTTPSPECIALFOLDER:
                    ptySpecial = (HTTPMAILSPECIALFOLDER *)(((char *)pTarget) + prgCols[dwIndex].offset);
                    *ptySpecial = HTTPMAIL_SF_NONE;
                    break;

                case XPCDT_HTTPCONTACTTYPE:
                    ptyContact = (HTTPMAILCONTACTTYPE *)(((char *)pTarget) + prgCols[dwIndex].offset);
                    *ptyContact = HTTPMAIL_CT_CONTACT;
                    break;

                default:
                    IxpAssert(FALSE);
                    break;
            }
        }
        
        dwFlags >>= 1;
        dwIndex++;
    }
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_AppendTextToBuffer
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::_AppendTextToBuffer(LPPCDATABUFFER pTextBuffer, 
                                                const WCHAR *pwcText, 
                                                ULONG ulLen)
{
    HRESULT hr = S_OK;
    ULONG ulNewCapacity = pTextBuffer->ulLen + ulLen;

    IxpAssert(ulLen > 0);

    // grow the buffer if necessary, and append the text
    if (pTextBuffer->ulCapacity < ulNewCapacity)
    {
        if (!MemRealloc((void **)&(pTextBuffer->pwcText), sizeof(WCHAR) * ulNewCapacity))
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        pTextBuffer->ulCapacity = ulNewCapacity;
    }

    // copy the new text over. special case the one-byte case to avoid
    // calls to CopyMemory when we see one character entities
    if (1 == ulLen)
    {
        pTextBuffer->pwcText[pTextBuffer->ulLen++] = *pwcText;
    }
    else
    {
        CopyMemory(&pTextBuffer->pwcText[pTextBuffer->ulLen], pwcText, sizeof(WCHAR) * ulLen);
        pTextBuffer->ulLen += ulLen;
    }

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_AllocTextBuffer
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::_AllocTextBuffer(LPPCDATABUFFER *ppTextBuffer)
{
    HRESULT hr = S_OK;

    IxpAssert(NULL != ppTextBuffer);

    *ppTextBuffer = NULL;

    if (!MemAlloc((void **)ppTextBuffer, sizeof(PCDATABUFFER)))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // allocate the buffer
    if (!MemAlloc((void **)(&((*ppTextBuffer)->pwcText)), PCDATA_BUFSIZE * sizeof(WCHAR)))
    {
        MemFree(*ppTextBuffer);
        *ppTextBuffer = NULL;

        hr = E_OUTOFMEMORY;
        goto exit;
    }

    (*ppTextBuffer)->ulLen = 0;
    (*ppTextBuffer)->ulCapacity = PCDATA_BUFSIZE ;

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::FreeTextBuffer
// --------------------------------------------------------------------------------
void CHTTPMailTransport::_FreeTextBuffer(LPPCDATABUFFER pTextBuffer)
{
    if (pTextBuffer)
    {
        if (pTextBuffer->pwcText)
            MemFree(pTextBuffer->pwcText);

        MemFree(pTextBuffer);
    }
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::FreeMemberInfoList
// --------------------------------------------------------------------------------
void CHTTPMailTransport::FreeMemberInfoList(void)
{
    DWORD               cInfo = m_op.rResponse.rMemberInfoList.cMemberInfo;
    LPHTTPMEMBERINFO    rgInfo = m_op.rResponse.rMemberInfoList.prgMemberInfo;

    // free the completed infos
    for (DWORD i = 0; i < cInfo; i++)
        XP_FREE_STRUCT(HTTPMEMBERINFO, &rgInfo[i], NULL);

    // free the partial info
    if (m_op.dwPropFlags)
    {
        IxpAssert(cInfo < MEMBERINFO_MAXRESPONSES);
        XP_FREE_STRUCT(HTTPMEMBERINFO, &rgInfo[cInfo], &m_op.dwPropFlags);
    }

    m_op.rResponse.rMemberInfoList.cMemberInfo= 0;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::FreeMemberErrorList
// --------------------------------------------------------------------------------
void CHTTPMailTransport::FreeMemberErrorList(void)
{
    DWORD               cInfo = m_op.rResponse.rMemberErrorList.cMemberError;
    LPHTTPMEMBERERROR   rgInfo = m_op.rResponse.rMemberErrorList.prgMemberError;

    // free the completed infos
    for (DWORD i = 0; i < cInfo; i++)
        XP_FREE_STRUCT(HTTPMEMBERERROR, &rgInfo[i], NULL);

    // free the partial info
    if (m_op.dwPropFlags)
    {
        IxpAssert(cInfo < MEMBERERROR_MAXRESPONSES);
        XP_FREE_STRUCT(HTTPMEMBERERROR, &rgInfo[cInfo], &m_op.dwPropFlags);
    }

    m_op.rResponse.rMemberErrorList.cMemberError = 0;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::FreeContactIdList
// --------------------------------------------------------------------------------
void CHTTPMailTransport::FreeContactIdList(void)
{
    DWORD cId = m_op.rResponse.rContactIdList.cContactId;
    LPHTTPCONTACTID rgId = m_op.rResponse.rContactIdList.prgContactId;

    // free the completed ids
    for (DWORD i = 0; i < cId; ++i)
        XP_FREE_STRUCT(HTTPCONTACTID, &rgId[i], NULL);

    // free the partial id
    if (m_op.dwPropFlags)
    {
        IxpAssert(cId < LISTCONTACTS_MAXRESPONSES);
        XP_FREE_STRUCT(HTTPCONTACTID, &rgId[cId], &m_op.dwPropFlags);

        m_op.dwPropFlags = NOFLAGS;
    }

    m_op.rResponse.rContactIdList.cContactId = 0;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::FreeContactInfoList
// --------------------------------------------------------------------------------
void CHTTPMailTransport::FreeContactInfoList(void)
{
    DWORD cInfo = m_op.rResponse.rContactInfoList.cContactInfo;
    LPHTTPCONTACTINFO rgInfo = m_op.rResponse.rContactInfoList.prgContactInfo;

    // free the completed ids
    for (DWORD i = 0; i < cInfo; ++i)
        XP_FREE_STRUCT(HTTPCONTACTINFO, &rgInfo[i], NULL);

    // free the partial info
    if (m_op.dwPropFlags)
    {
        IxpAssert(cInfo < CONTACTINFO_MAXRESPONSES);
        XP_FREE_STRUCT(HTTPCONTACTINFO, &rgInfo[cInfo], &m_op.dwPropFlags);
    }

    m_op.rResponse.rContactInfoList.cContactInfo = 0;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::FreeBCopyMoveList
// --------------------------------------------------------------------------------
void CHTTPMailTransport::FreeBCopyMoveList(void)
{
    DWORD cInfo = m_op.rResponse.rBCopyMoveList.cBCopyMove;
    LPHTTPMAILBCOPYMOVE rgInfo = m_op.rResponse.rBCopyMoveList.prgBCopyMove;

    // free the completed records
    for (DWORD i = 0; i < cInfo; ++i)
        XP_FREE_STRUCT(HTTPMAILBCOPYMOVE, &rgInfo[i], NULL);

    // free the partial info
    if (m_op.dwPropFlags)
    {
        IxpAssert(cInfo < BCOPYMOVE_MAXRESPONSES);
        XP_FREE_STRUCT(HTTPMAILBCOPYMOVE, &rgInfo[cInfo], &m_op.dwPropFlags);
    }

    m_op.rResponse.rBCopyMoveList.cBCopyMove = 0;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ValidStack
// --------------------------------------------------------------------------------
BOOL CHTTPMailTransport::ValidStack(const HMELE *prgEle, DWORD cEle)
{
    BOOL bResult = TRUE;
    DWORD dw;

    if (cEle != m_op.dwStackDepth)
    {
        bResult = FALSE;
        goto exit;
    }

    IxpAssert(cEle <= ELE_STACK_CAPACITY);

    for (dw = 0; dw < cEle; ++dw)
    {
        if (prgEle[dw] != HMELE_UNKNOWN && prgEle[dw] != m_op.rgEleStack[dw].ele)
        {
            bResult = FALSE;
            goto exit;
        }
    }

exit:
    return bResult;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::PopNamespaces
// --------------------------------------------------------------------------------
void CHTTPMailTransport::PopNamespaces(CXMLNamespace *pBaseNamespace)
{
    CXMLNamespace *pTemp;

    while (pBaseNamespace != m_op.pTopNamespace)
    {
        IxpAssert(m_op.pTopNamespace);
        pTemp = m_op.pTopNamespace->GetParent();
        m_op.pTopNamespace->Release();
        m_op.pTopNamespace = pTemp;
    }
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::PushNamespaces
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::PushNamespaces(XML_NODE_INFO** apNodeInfo, USHORT cNumRecs)
{
    HRESULT         hr = S_OK;
    CXMLNamespace   *pNamespace = NULL;

    for (USHORT i = 0; i < cNumRecs; ++i)
    {
        if (apNodeInfo[i]->dwType == XML_ATTRIBUTE && apNodeInfo[i]->dwSubType == XML_NS)
        {
            // better have at least one more record
            IxpAssert(i < (cNumRecs - 1));
            if (i < (cNumRecs - 1) && apNodeInfo[i + 1]->dwType == XML_PCDATA)
            {
                pNamespace = new CXMLNamespace();
                if (!pNamespace)
                {
                    hr = E_OUTOFMEMORY;
                    goto exit;
                }

                if (apNodeInfo[i]->ulLen != apNodeInfo[i]->ulNsPrefixLen)
                {
                    if (FAILED(hr = pNamespace->SetPrefix(
                                        &apNodeInfo[i]->pwcText[apNodeInfo[i]->ulNsPrefixLen + 1],
                                        apNodeInfo[i]->ulLen - (apNodeInfo[i]->ulNsPrefixLen + 1))))
                        goto exit;
                }

                if (FAILED(hr = pNamespace->SetNamespace(apNodeInfo[i + 1]->pwcText, apNodeInfo[i + 1]->ulLen)))
                    goto exit;

                pNamespace->SetParent(m_op.pTopNamespace);
                if (m_op.pTopNamespace)
                    m_op.pTopNamespace->Release();
                m_op.pTopNamespace = pNamespace;
                pNamespace = NULL;
            }
        }
    }

exit:
    SafeRelease(pNamespace);
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::AllocStrFromStrW
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::AllocStrFromStrNW(
                                const WCHAR *pwcText, 
                                ULONG ulLen, 
                                LPSTR *ppszAlloc)
{
    HRESULT     hr = S_OK;
    DWORD       iBufferSize;
    DWORD       iConvertedChars;

    IxpAssert(NULL != ppszAlloc);

    if (NULL == ppszAlloc)
        return E_INVALIDARG;

    *ppszAlloc = NULL;

    // if pwcText is NULL, the result is null, but not an error
    if (NULL == pwcText)
        goto exit;

    iBufferSize = WideCharToMultiByte(CP_ACP, 0, pwcText, ulLen, NULL, 0, NULL, NULL);
    if (0 == iBufferSize)
    {
        m_op.rResponse.rIxpResult.uiServerError = GetLastError();
        hr = TrapError(E_FAIL);
        goto exit;
    }

    // allocate the buffer (add 1 to the size to allow for eos)
    if (!MemAlloc((void **)ppszAlloc, iBufferSize + 1))
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // convert the string
    iConvertedChars = WideCharToMultiByte(CP_ACP, 0, pwcText, ulLen, *ppszAlloc, iBufferSize, NULL, NULL);
    if (0 == iConvertedChars)
    {
        m_op.rResponse.rIxpResult.uiServerError = GetLastError();
        hr = TrapError(E_FAIL);
        goto exit;
    }

    IxpAssert(iConvertedChars == iBufferSize);
    // terminate the new string
    (*ppszAlloc)[iConvertedChars] = 0;

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::StrNToDwordW
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::StrNToDwordW(const WCHAR *pwcText, ULONG ulLen, DWORD *pdw)
{
    HRESULT     hr = S_OK;
    int         i;
    WCHAR       wcBuf[32];
    WCHAR       *pwcUseBuf;
    BOOL        fFreeBuf = FALSE;

    IxpAssert(NULL != pdw);
    
    if (NULL == pdw)
        return E_INVALIDARG;

    *pdw = 0;

    if (NULL == pwcText)
        goto exit;

    // decide whether to use a local buffer or an allocated buffer
    if (ulLen < 32)
        pwcUseBuf = wcBuf;
    else
    {
        if (!MemAlloc((void **)&pwcUseBuf, (ulLen + 1) * sizeof(WCHAR)))
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        fFreeBuf = TRUE;
    }

    // copy the string over
    CopyMemory(pwcUseBuf, pwcText, ulLen * sizeof(WCHAR));
    pwcUseBuf[ulLen] = 0;

    *pdw = StrToIntW(pwcUseBuf);

exit:
    if (fFreeBuf)
        MemFree(pwcUseBuf);

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::StrNToSpecialFolderW
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::StrNToSpecialFolderW(const WCHAR *pwcText, 
                                                 ULONG ulLen, 
                                                 HTTPMAILSPECIALFOLDER *ptySpecial)
{
    HRESULT     hr = S_OK;

    if (NULL == ptySpecial)
        return E_INVALIDARG;

    *ptySpecial = HTTPMAIL_SF_UNRECOGNIZED;

    if (NULL != pwcText && ulLen > 0)
    {
        for (DWORD dw = 0; dw < ARRAYSIZE(c_rgpfnSpecialFolder); dw++)
        {
            if (ulLen == c_rgpfnSpecialFolder[dw].ulLen)
            {
                if (0 == StrCmpNW(c_rgpfnSpecialFolder[dw].pwcName, pwcText, ulLen))
                {
                    *ptySpecial = c_rgpfnSpecialFolder[dw].tyFolder;
                    break;
                }
            }
        }
    }

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::StrNToContactTypeW
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::StrNToContactTypeW(const WCHAR *pwcText, 
                                                 ULONG ulLen, 
                                                 HTTPMAILCONTACTTYPE *ptyContact)
{
    HRESULT hr = S_OK;
    BOOL    fGroup = FALSE;

    IxpAssert(NULL != ptyContact);

    if (NULL == ptyContact)
        return E_INVALIDARG;

    // for now, we treat the presence of the <group> element as an indication that
    // the contact is a group
    *ptyContact = HTTPMAIL_CT_GROUP;

#if 0

    // for now, we treat the value as an integer-based bool
    hr = StrNToBoolW(pwcText, ulLen, &fGroup);

    // default is contact
    *ptyContact = fGroup ? HTTPMAIL_CT_GROUP : HTTPMAIL_CT_CONTACT;
#endif

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::StrNToBoolW
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::StrNToBoolW(const WCHAR *pwcText, DWORD ulLen, BOOL *pb)
{
    HRESULT     hr = S_OK;
    DWORD       dw;

    IxpAssert(NULL != pb);

    if (NULL == pb)
        return E_INVALIDARG;

    *pb = FALSE;

    if (NULL == pwcText)
        goto exit;

    if (FAILED(hr = StrNToDwordW(pwcText, ulLen, &dw)))
        goto exit;

    if (dw != 0)
        *pb = TRUE;

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::StatusStrNToIxpHr
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::StatusStrNToIxpHr(const WCHAR *pwcText, DWORD ulLen, HRESULT *phr)
{
    HRESULT     hr = S_OK;
    DWORD       dw;
    LPSTR       pszStatus = NULL;
    DWORD       dwStatus = 0;

    IxpAssert(NULL != phr);

    if (NULL == phr)
        return E_INVALIDARG;

    *phr = S_OK;

    if (NULL == pwcText)
        goto exit;

    if (FAILED(hr = AllocStrFromStrNW(pwcText, ulLen, &pszStatus)) || NULL == pszStatus)
        goto exit;

    HrParseHTTPStatus(pszStatus, &dwStatus);

    if (dwStatus < 200 || dwStatus > 299)
        *phr = HttpErrorToIxpResult(dwStatus);

exit:
    SafeMemFree(pszStatus);
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::CommandToVerb
// --------------------------------------------------------------------------------
LPSTR CHTTPMailTransport::CommandToVerb(HTTPMAILCOMMAND command)
{
    LPSTR pszVerb = NULL;

   // convert the command to a string
    switch (command)
    {
    case HTTPMAIL_GET:
        pszVerb = "GET";
        break;

    case HTTPMAIL_POST:
    case HTTPMAIL_SENDMESSAGE:
        pszVerb = "POST";
        break;

    case HTTPMAIL_PUT:
        pszVerb = "PUT";
        break;

    case HTTPMAIL_GETPROP:
    case HTTPMAIL_PROPFIND:
    case HTTPMAIL_MEMBERINFO:
    case HTTPMAIL_LISTCONTACTS:
    case HTTPMAIL_CONTACTINFO:
        pszVerb = "PROPFIND";
        break;

    case HTTPMAIL_MARKREAD:
        if (m_op.fBatch)
            pszVerb = "BPROPPATCH";
        else
            pszVerb = "PROPPATCH";
        break;

    case HTTPMAIL_MKCOL:
        pszVerb = "MKCOL";
        break;

    case HTTPMAIL_COPY:
        pszVerb = "COPY";
        break;

    case HTTPMAIL_BCOPY:
        pszVerb = "BCOPY";
        break;

    case HTTPMAIL_MOVE:
        pszVerb = "MOVE";
        break;

    case HTTPMAIL_BMOVE:
        pszVerb = "BMOVE";
        break;

    case HTTPMAIL_PROPPATCH:
        pszVerb = "PROPPATCH";
        break;

    case HTTPMAIL_DELETE:
        pszVerb = "DELETE";
        break;

    case HTTPMAIL_BDELETE:
        pszVerb = "BDELETE";
        break;

    case HTTPMAIL_POSTCONTACT:
        // first post the contact, then do a propfind
        if (NULL == m_op.rResponse.rPostContactInfo.pszHref)
            pszVerb = "POST";
        else
            pszVerb = "PROPFIND";
        break;

    case HTTPMAIL_PATCHCONTACT:
        // first patch the contact, then do a propfind
        if (NULL == m_op.rResponse.rPatchContactInfo.pszHref)
            pszVerb = "PROPPATCH";
        else
            pszVerb = "PROPFIND";
        break;


    default:
        pszVerb = "";
        IxpAssert(FALSE);
        break;
    }

    return pszVerb;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::UpdateLogonInfo
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::UpdateLogonInfo(void)
{
    // send the message synchronously
    return (HRESULT) (::SendMessage(m_hwnd, SPM_HTTPMAIL_LOGONPROMPT, NULL, NULL));
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::GetParentWindow
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::GetParentWindow(HWND *phwndParent)
{
    // send the message synchronously
    return (HRESULT) (::SendMessage(m_hwnd, SPM_HTTPMAIL_GETPARENTWINDOW, (WPARAM)phwndParent, NULL));
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ReadBytes
// --------------------------------------------------------------------------------
BOOL CHTTPMailTransport::ReadBytes(LPSTR pszBuffer, DWORD cbBufferSize, DWORD *pcbBytesRead)
{
    return InternetReadFile(m_op.hRequest, pszBuffer, cbBufferSize, pcbBytesRead);
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_GetStatusCode
// --------------------------------------------------------------------------------
BOOL CHTTPMailTransport::_GetStatusCode(DWORD *pdw)
{
    IxpAssert(NULL != pdw);

    DWORD dwStatusSize = sizeof(DWORD);
    *pdw = 0;
    return HttpQueryInfo(m_op.hRequest, HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE, pdw, &dwStatusSize, NULL);
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_GetContentLength
// --------------------------------------------------------------------------------
BOOL CHTTPMailTransport::_GetContentLength(DWORD *pdw)
{
    IxpAssert(NULL != pdw);

    DWORD dwLengthSize = sizeof(DWORD);
    *pdw = 0;
    return HttpQueryInfo(m_op.hRequest, HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_CONTENT_LENGTH, pdw, &dwLengthSize, NULL);
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_GetRequestHeader
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::_GetRequestHeader(LPSTR *ppszHeader, DWORD dwHeader)
{
    HRESULT     hr = S_OK;
    DWORD       dwSize = MAX_PATH;
    LPSTR       pszHeader = NULL;

    Assert(NULL != ppszHeader);
    *ppszHeader = NULL;

retry:
    pszHeader = (LPSTR)ZeroAllocate(dwSize);
    if (!pszHeader)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    if (!HttpQueryInfo(m_op.hRequest, dwHeader, pszHeader, &dwSize, NULL))
    {
        if (ERROR_INSUFFICIENT_BUFFER != GetLastError())
            goto exit;
        
        SafeMemFree(pszHeader);        
        goto retry;
    }

    *ppszHeader = pszHeader;
    pszHeader = NULL;

exit:
    SafeMemFree(pszHeader);
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_AddRequestHeader
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::_AddRequestHeader(LPCSTR pszHeader)
{
    HRESULT     hr = S_OK;

    if (!HttpAddRequestHeaders(m_op.hRequest, pszHeader, lstrlen(pszHeader), HTTP_ADDREQ_FLAG_ADD))
        hr = HrGetLastError();

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_AuthCurrentRequest
// --------------------------------------------------------------------------------
BOOL CHTTPMailTransport::_AuthCurrentRequest(DWORD dwStatus, BOOL fRetryAuth)
{
    BOOL        fResult = FALSE;
    HRESULT     hr;

    // unused code to let wininet do the ui
    #if 0
    if (HTTP_STATUS_PROXY_AUTH_REQ == dwStatus || HTTP_STATUS_DENIED == dwStatus)
    {
        if (!fRequestedParent)
        {
            GetParentWindow(&hwndParent);
            fRequestedParent = TRUE;
        }

        hr = InternetErrorDlg(hwndParent, m_op.hRequest, hr, 
                           FLAGS_ERROR_UI_FILTER_FOR_ERRORS | 
                           FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS |
                           FLAGS_ERROR_UI_FLAGS_GENERATE_DATA,
                           NULL);
        if (ERROR_INTERNET_FORCE_RETRY == hr)
            goto resend;
    }
#endif

        // TODO: should probably let wininet handle proxy auth errors
#if 0
    case HTTP_STATUS_PROXY_AUTH_REQ:    //Proxy Authentication Required
        InternetSetOption(m_op.hRequest, INTERNET_OPTION_PROXY_USERNAME, 
                        GetUserName(), strlen(GetUserName())+1);
        InternetSetOption(m_op.hRequest, INTERNET_OPTION_PROXY_PASSWORD, 
                        GetPassword(), strlen(GetPassword())+1);
        break;
#endif

    if (HTTP_STATUS_DENIED == dwStatus)     //Server Authentication Required
    {
        if (fRetryAuth || (SUCCEEDED(hr = UpdateLogonInfo()) && S_FALSE != hr))
        {
            InternetSetOption(m_op.hRequest, INTERNET_OPTION_USERNAME, 
                        GetUserName(), strlen(GetUserName())+1);
            InternetSetOption(m_op.hRequest, INTERNET_OPTION_PASSWORD, 
                        GetPassword(), strlen(GetPassword())+1);
            fResult = TRUE;
        }
    }

    return fResult;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_LogRequest
// --------------------------------------------------------------------------------
void CHTTPMailTransport::_LogRequest(LPVOID pvData, DWORD cbData)
{
    HRESULT     hr = S_OK;
    CByteStream bs;
    LPSTR       pszCommand = CommandToVerb(m_op.rResponse.command);
    LPSTR       pszLogData = NULL;

    Assert(NULL != m_pLogFile);
    if (NULL == m_pLogFile)
        return;

    FAIL_EXIT_STREAM_WRITE(bs, c_szCRLF);
    FAIL_EXIT_STREAM_WRITE(bs, pszCommand);
    FAIL_EXIT_STREAM_WRITE(bs, c_szSpace);
    FAIL_EXIT_STREAM_WRITE(bs, m_op.pszUrl);

    if (pvData && cbData)
    {
        FAIL_EXIT_STREAM_WRITE(bs, c_szCRLF);
        if (FAILED(hr = bs.Write(pvData, cbData, NULL)))
            goto exit;
    }

    FAIL_EXIT_STREAM_WRITE(bs, c_szCRLF);
    FAIL_EXIT_STREAM_WRITE(bs, c_szCRLF);

    FAIL_EXIT(hr = bs.HrAcquireStringA(NULL, &pszLogData, ACQ_DISPLACE));

    m_pLogFile->WriteLog(LOGFILE_TX, pszLogData);

exit:
    SafeMemFree(pszLogData);

    return;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_LogResponse
// --------------------------------------------------------------------------------
void CHTTPMailTransport::_LogResponse(LPVOID pvData, DWORD cbData)
{
    HRESULT     hr = S_OK;
    CByteStream bs;
    LPSTR       pszHeaders = NULL;
    LPSTR       pszLogData = NULL;

    Assert(NULL != m_pLogFile);
    if (NULL == m_pLogFile || m_op.fLoggedResponse)
        return;
    
    FAIL_EXIT(_GetRequestHeader(&pszHeaders, HTTP_QUERY_RAW_HEADERS_CRLF));

    if (pszHeaders)
    {
        // prefix with a CRLF
        if ('\r' != pszHeaders[0])
            FAIL_EXIT_STREAM_WRITE(bs, c_szCRLF);

        FAIL_EXIT_STREAM_WRITE(bs, pszHeaders);
    }

    if (pvData && cbData)
    {
        if (FAILED(hr = bs.Write(pvData, cbData, NULL)))
            goto exit;
    }

    FAIL_EXIT_STREAM_WRITE(bs, c_szCRLF);
    FAIL_EXIT_STREAM_WRITE(bs, c_szCRLF);

    FAIL_EXIT(hr = bs.HrAcquireStringA(NULL, &pszLogData, ACQ_DISPLACE));

    m_pLogFile->WriteLog(LOGFILE_RX, pszLogData);

exit:
    m_op.fLoggedResponse = TRUE;

    SafeMemFree(pszHeaders);
    SafeMemFree(pszLogData);

    return;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::TranslateWinInetMsg
// --------------------------------------------------------------------------------
BOOL CHTTPMailTransport::TranslateWinInetMsg(
                                DWORD dwInternetStatus,
                                IXPSTATUS *pIxpStatus)
{
    IxpAssert(NULL != pIxpStatus);

    switch (dwInternetStatus)
    {
    case INTERNET_STATUS_RESOLVING_NAME:
        *pIxpStatus = IXP_FINDINGHOST;
        break;

    case  INTERNET_STATUS_CONNECTING_TO_SERVER:
        *pIxpStatus = IXP_CONNECTING;
        break;
    
    case INTERNET_STATUS_CONNECTED_TO_SERVER:
        *pIxpStatus = IXP_CONNECTED;
        break;

    case INTERNET_STATUS_CLOSING_CONNECTION:
        *pIxpStatus = IXP_DISCONNECTING;
        break;

    case INTERNET_STATUS_CONNECTION_CLOSED:
        *pIxpStatus = IXP_DISCONNECTED;
        break;

    case INTERNET_STATUS_REQUEST_COMPLETE:
        *pIxpStatus = IXP_LAST;
        break;

    default:
        // status codes that are not translated:
        //      INTERNET_STATUS_NAME_RESOLVED 
        //      INTERNET_STATUS_SENDING_REQUEST 
        //      INTERNET_STATUS_ REQUEST_SENT
        //      INTERNET_STATUS_RECEIVING_RESPONSE
        //      INTERNET_STATUS_RESPONSE_RECEIVED
        //      INTERNET_STATUS_REDIRECT
        //      INTERNET_STATUS_HANDLE_CREATED
        //      INTERNET_STATUS_HANDLE_CLOSING

        return FALSE;
    }

    return TRUE;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_CreateXMLParser
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::_CreateXMLParser()
{
    HRESULT                 hr = S_OK;
    
    if (NULL == m_pParser)
    {
            // instantiate the xml document
        hr = ::CoCreateInstance(CLSID_XMLParser, 
                                 NULL, 
                                 CLSCTX_INPROC_SERVER, 
                                 IID_IXMLParser, 
                                 reinterpret_cast<void **>(&m_pParser));

        if (FAILED(hr))
            goto exit;


        if (FAILED(hr = m_pParser->SetFlags(XMLFLAG_FLOATINGAMP)))
            goto exit;
    }

    hr = m_pParser->SetFactory(this);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::OpenRequest
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::OpenRequest(void)
{
    LPSTR           pszVerb = NULL;
    HRESULT         hr = S_OK;
    LPSTR           pszHostName = NULL;
    LPSTR           pszUrlPath = NULL;
    INTERNET_PORT   nPort;
    LPSTR           pszUserName = GetUserName();
    LPSTR           pszPassword = GetPassword();

    if (NULL == pszUserName)
        pszUserName = "";

    if (NULL == pszPassword)
        pszPassword = "";

    // crack the url into component parts
    if (FAILED(hr = HrCrackUrl(m_op.pszUrl, &pszHostName, &pszUrlPath, &nPort)))
    {
        TrapError(hr);
        goto exit;
    }

    if (FAILED(hr = HrConnectToHost(pszHostName, nPort, pszUserName, NULL)))
    {
        TrapError(hr);
        goto exit;
    }

    // We have to set the password and username on every connection. If we don't,
    // and and incorrect password or username forces us to prompt the user, the
    // newly entered data won't get used on subsequent requests
    InternetSetOption(GetConnection(), INTERNET_OPTION_USERNAME, pszUserName, lstrlen(pszUserName) + 1);
    InternetSetOption(GetConnection(), INTERNET_OPTION_PASSWORD, pszPassword, lstrlen(pszPassword) + 1);

    FAIL_ABORT;

    // convert the command to a verb string
    pszVerb = CommandToVerb(m_op.rResponse.command);

    // Open the HTTP request
    m_op.hRequest = HttpOpenRequest(
                        GetConnection(), 
                        pszVerb, 
                        pszUrlPath,
                        NULL,
                        NULL,
                        m_op.rgszAcceptTypes,
                        INTERNET_FLAG_EXISTING_CONNECT | 
                        INTERNET_FLAG_RELOAD |
                        INTERNET_FLAG_KEEP_CONNECTION,
                        0);
    
    if (NULL == m_op.hRequest)
    {
        DWORD dwErr = GetLastError();
        hr = E_FAIL;
    }

exit:
    SafeMemFree(pszHostName);
    SafeMemFree(pszUrlPath);

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::SendPostRequest
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::SendPostRequest(void)
{
    HRESULT             hr = S_OK;
    INTERNET_BUFFERS    buffers;
    DWORD               cbData;
    ULONG               cbRead;
    ULONG               cbWritten;
    BOOL                fResult;
    CHAR                localBuffer[HTTPMAIL_BUFSIZE];
    LARGE_INTEGER       liOrigin = {0,0};
    DWORD               dwBufferLength;
    BOOL                fSentData = FALSE;
    BOOL                fWillSend;
    DWORD               dwWinInetErr = 0;
    BOOL                fRetryAuth = FALSE;

    // log the request, but don't log the request body
    if (m_pLogFile)
        _LogRequest(NULL, 0);

    if (m_op.pHeaderStream)
    {
        if (FAILED(hr = HrGetStreamSize(m_op.pHeaderStream, &m_op.rResponse.rPostInfo.cbTotal)))
            goto exit;
    }

    if (m_op.pBodyStream)
    {
        if (FAILED(hr = HrGetStreamSize(m_op.pBodyStream, &cbData)))
            goto exit;

        m_op.rResponse.rPostInfo.cbTotal += cbData;
    }

    buffers.dwStructSize = sizeof(INTERNET_BUFFERSA);
    buffers.Next = NULL;
    buffers.lpcszHeader = NULL;
    buffers.dwHeadersLength = 0;
    buffers.dwHeadersTotal = 0;
    buffers.lpvBuffer = NULL;
    buffers.dwBufferLength = 0;
    buffers.dwBufferTotal = m_op.rResponse.rPostInfo.cbTotal;
    buffers.dwOffsetLow = 0;
    buffers.dwOffsetHigh = 0;

resend:
    if (fSentData)
    {
        m_op.rResponse.rPostInfo.fResend = TRUE;
        m_op.rResponse.rPostInfo.cbCurrent = 0;
        
        _HrThunkResponse(FALSE);

        m_op.rResponse.rPostInfo.fResend = FALSE;

        FAIL_ABORT;
    }

    fResult = HttpSendRequestEx(m_op.hRequest, &buffers, NULL, 0, 0);
    if (!fResult)
    {
        dwWinInetErr = GetLastError();
        if (ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION == dwWinInetErr)
        {
            fRetryAuth = TRUE;
            goto resend;
        }

        _HrThunkConnectionError(dwWinInetErr);
        hr = E_FAIL;
        goto exit;
    }
    
    // with some auth methods (e.g., NTLM), wininet will send a post request
    // with a content length of 0, and will ignore calls to InternetWriteFile
    // until the server sends a 100 (continue) response. wininet will then
    // return ERROR_INTERNET_FORCE_RETRY to force a resend. we detect this
    // case here so that we don't send a bunch of OnResponse progress notifications
    // when no data is actually going out over the wire

    // this constant isn't in the wininet headers as of 10/6/98!!
#ifndef INTERNET_OPTION_DETECT_POST_SEND
#define INTERNET_OPTION_DETECT_POST_SEND        71
#endif

    dwBufferLength = sizeof(fWillSend);
    if (!InternetQueryOption(m_op.hRequest, INTERNET_OPTION_DETECT_POST_SEND, &fWillSend, &dwBufferLength))
        fWillSend = TRUE;
    else
    {
        Assert(dwBufferLength == sizeof(BOOL));
    }

    if (fWillSend)
    {
        fSentData = TRUE;

        if (m_op.pHeaderStream)
        {
            // rewind the stream
            if (FAILED(hr = m_op.pHeaderStream->Seek(liOrigin, STREAM_SEEK_SET, NULL)))
                goto exit;

            while (TRUE)
            {
                if (FAILED(hr = m_op.pHeaderStream->Read(localBuffer, sizeof(localBuffer), &cbRead)))
                    goto exit;

                if (0 == cbRead)
                    break;
            
                fResult = InternetWriteFile(m_op.hRequest, localBuffer, cbRead, &cbWritten);
                IxpAssert(!fResult || (cbRead == cbWritten));
                if (!fResult)
                {
                    _HrThunkConnectionError(GetLastError());
                    hr = E_FAIL;
                    goto exit;
                }
            
                m_op.rResponse.rPostInfo.cbIncrement = cbWritten;
                m_op.rResponse.rPostInfo.cbCurrent += cbWritten;

                _HrThunkResponse(FALSE);

                m_op.rResponse.rPostInfo.cbIncrement = 0;

                FAIL_ABORT;
            }
        }

        if (m_op.pBodyStream)
        {
            // rewind the stream
            if (FAILED(hr = m_op.pBodyStream->Seek(liOrigin, STREAM_SEEK_SET, NULL)))
                goto exit;

            while (TRUE)
            {
                if (FAILED(hr = m_op.pBodyStream->Read(localBuffer, sizeof(localBuffer), &cbRead)))
                    goto exit;

                if (0 == cbRead)
                    break;

                fResult = InternetWriteFile(m_op.hRequest, localBuffer, cbRead, &cbWritten);
                IxpAssert(!fResult || (cbRead == cbWritten));
                if (!fResult)
                {
                    _HrThunkConnectionError(GetLastError());
                    hr = E_FAIL;
                    goto exit;
                }
            
                m_op.rResponse.rPostInfo.cbIncrement = cbWritten;
                m_op.rResponse.rPostInfo.cbCurrent += cbWritten;

                _HrThunkResponse(FALSE);

                m_op.rResponse.rPostInfo.cbIncrement = 0;

                FAIL_ABORT;
 
            }
        }
    }

    fResult = HttpEndRequest(m_op.hRequest, NULL, 0, 0);
    if (!fResult)
    {
        if (ERROR_INTERNET_FORCE_RETRY == GetLastError())
            goto resend;

        _HrThunkConnectionError(GetLastError());
    }

    if (!_GetStatusCode(&m_op.dwHttpStatus))
    {
        _HrThunkConnectionError(GetLastError());
        hr = E_FAIL;
        goto exit;
    }

    if (_AuthCurrentRequest(m_op.dwHttpStatus, fRetryAuth))
    {
        fRetryAuth = FALSE;
        goto resend;
    }

    if (!fResult)
    {
        _HrThunkConnectionError();
        hr = E_FAIL;
        goto exit;
    }

    // status codes not in the 200-299 range indicate an error
    if (200 > m_op.dwHttpStatus || 299 < m_op.dwHttpStatus)
    {
        _HrThunkConnectionError();
        hr = E_FAIL;
    }

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::SendRequest
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::SendRequest(void)
{
    HRESULT     hr = S_OK;
    DWORD       dwError;
    BOOL        bResult;
    HWND        hwndParent = NULL;
    BOOL        fRequestedParent = FALSE;
    DWORD       dwWinInetErr = 0;
    BOOL        fRetryAuth = FALSE;

    // log the request, including the requets body
    if (m_pLogFile)
        _LogRequest(m_op.pvData, m_op.cbDataLen);

resend:
    hr = S_OK;
    bResult = HttpSendRequest(m_op.hRequest, NULL, 0L, m_op.pvData, m_op.cbDataLen);
    if (!bResult)
    {
        dwWinInetErr = GetLastError();
        if (ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION == dwWinInetErr)
        {
            fRetryAuth = TRUE;
            goto resend;
        }

        _HrThunkConnectionError(dwWinInetErr);
        hr = E_FAIL;
        goto exit;
    }

    if (!_GetStatusCode(&m_op.dwHttpStatus))
    {
        _HrThunkConnectionError(GetLastError());
        hr = E_FAIL;
        goto exit;
    }

    if (_AuthCurrentRequest(m_op.dwHttpStatus, fRetryAuth))
    {
        fRetryAuth = FALSE;
        goto resend;
    }

    // status codes not in the 200-299 range indicate an error
    if (200 > m_op.dwHttpStatus|| 299 < m_op.dwHttpStatus)
    {
        _HrThunkConnectionError();
        hr = E_FAIL;
        goto exit;
    }

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::RequireMultiStatus
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::RequireMultiStatus(void)
{
    HRESULT hr = S_OK;

    if (207 != m_op.dwHttpStatus)
    {
        _HrThunkConnectionError(ERROR_INTERNET_CANNOT_CONNECT);
        hr = E_FAIL;
    }

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::FinalizeRequest
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::FinalizeRequest(void)
{
    HRESULT     hr                  = S_OK;
    LPSTR       pszTimestampHeader  = NULL;

    // log the response if it hasn't already been logged
    if (m_pLogFile && !m_op.fLoggedResponse)
        _LogResponse(NULL, 0);

    if (HTTPMAIL_MEMBERINFO == m_op.rResponse.command)
    {
        // Get the headers and copy them. If we don't get timestamp header, its not a big deal. We don't report an error.
        hr = _HrGetTimestampHeader(&pszTimestampHeader);
        if (SUCCEEDED(hr))
        {
            // Get the Active timestamp
            FAIL_EXIT(hr = _HrParseAndCopy(c_szActive, &m_op.rResponse.rMemberInfoList.pszFolderTimeStamp, pszTimestampHeader));
            
            // Get RootTimeStamp which for some strange reason comes as Folders TimeStamp
            // This call might fail for legitimate reasons. For Inbox list headers we do not get a RootTimeStamp. 
            // Hence we do not exit if we can't get root time stamp.
            _HrParseAndCopy(c_szFolders, &m_op.rResponse.rMemberInfoList.pszRootTimeStamp, pszTimestampHeader);

            SafeMemFree(pszTimestampHeader);
             
        }
    }

    hr =  _HrThunkResponse(TRUE);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ProcessGetResponse
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::ProcessGetResponse(void)
{
    HRESULT     hr = S_OK;
    BOOL        bRead;
    DWORD       cbReadBytes = 0;

    // log the respnse, but don't log the response body
    if (m_pLogFile && !m_op.fLoggedResponse)
        _LogResponse(NULL, 0);

    Assert(NULL == m_op.rResponse.rGetInfo.pszContentType);

    // extract the content type header
    FAIL_EXIT(hr  = _GetRequestHeader(&m_op.rResponse.rGetInfo.pszContentType, HTTP_QUERY_CONTENT_TYPE));

    // try to get the content length
    m_op.rResponse.rGetInfo.fTotalKnown = _GetContentLength(&m_op.rResponse.rGetInfo.cbTotal);

    do
    {
        // The buffer is owned by this object, but the client
        // has the option of taking ownership of the buffer
        // whenever a read completes. We reallocate the buffer
        // here if necessary
        FAIL_ABORT;
        
        if (!m_op.rResponse.rGetInfo.pvBody && !MemAlloc((void**)&m_op.rResponse.rGetInfo.pvBody, HTTPMAIL_BUFSIZE + 1))
        {    
            hr = E_OUTOFMEMORY;
            break;
        }


        bRead = ReadBytes((char *)m_op.rResponse.rGetInfo.pvBody, HTTPMAIL_BUFSIZE, &cbReadBytes);
        
        m_op.rResponse.rGetInfo.cbIncrement = cbReadBytes;
        m_op.rResponse.rGetInfo.cbCurrent += cbReadBytes;

        // we guarantee space for the terminating null by allocating
        // a buffer one larger than bufsize
        static_cast<char *>(m_op.rResponse.rGetInfo.pvBody)[cbReadBytes] = '\0';

        // Send a message to the window that lives in the client's thread
        _HrThunkResponse(0 == cbReadBytes);

    } while (0 < cbReadBytes);

exit:
    SafeMemFree(m_op.rResponse.rGetInfo.pvBody);

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ProcessPostResponse
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::ProcessPostResponse(void)
{
    HRESULT     hr = S_OK;

    // log the response
    if (m_pLogFile && !m_op.fLoggedResponse)
        _LogResponse(NULL, 0);

    if (m_op.dwHttpStatus < 200 || m_op.dwHttpStatus > 299)
    {
        _HrThunkConnectionError();
        hr = E_FAIL;
        goto exit;
    }

    hr = _GetRequestHeader(&m_op.rResponse.rPostInfo.pszLocation, HTTP_QUERY_LOCATION);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ProcessXMLResponse
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::ProcessXMLResponse(void)
{
    HRESULT         hr = S_OK;
    BOOL            bRead;
    LPSTR           pszBody = NULL;
    DWORD           cbLength = 0;
    CByteStream     *pLogStream = NULL;
    BOOL            fFoundBytes = FALSE;

    if (m_pLogFile && !m_op.fLoggedResponse)
        pLogStream = new CByteStream();

    // we only parse xml if the response is a 207 (multistatus)
    if (m_op.dwHttpStatus != 207)
        goto exit;

    // create the xml parser
    if (FAILED(hr = _CreateXMLParser()))
        goto exit;

    if (!MemAlloc((void **)&pszBody, HTTPMAIL_BUFSIZE))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    do
    {
        FAIL_ABORT;

        bRead = ReadBytes(pszBody, HTTPMAIL_BUFSIZE, &cbLength);
        if (0 == cbLength)
        {
            if (fFoundBytes)
            {
                // parse any remaining bytes in the parser's buffer
                if (FAILED(hr = m_pParser->PushData(NULL, 0, TRUE)))
                    goto exit;

                if (FAILED(hr = m_pParser->Run(-1)))
                    goto exit;
            }

            break;
        }

        fFoundBytes = TRUE;

        // if logging, write the block into the log stream
        if (pLogStream)
            pLogStream->Write(pszBody, cbLength, NULL);

        if (FAILED(hr = m_pParser->PushData(pszBody, cbLength, FALSE)))
            goto exit;

        if (FAILED(hr = m_pParser->Run(-1)))
        {
            if (hr == E_PENDING)
                hr = S_OK;
            else
                goto exit;
        }

    } while (TRUE);

exit:
    SafeMemFree(pszBody);

    if (pLogStream)
    {
        LPSTR pszLog = NULL;
        DWORD dwLog = 0;
        
        pLogStream->HrAcquireStringA(&dwLog, &pszLog, ACQ_DISPLACE);
    
        _LogResponse(pszLog, dwLog);
        SafeMemFree(pszLog);

        delete pLogStream;
    }

    if (m_pParser)
        m_pParser->Reset();

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::GeneratePropFindXML
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::GeneratePropFindXML(void)
{
    HRESULT hr = S_OK;
    LPSTR   pszXML = NULL;

    IxpAssert(NULL == m_op.pvData && 0 == m_op.cbDataLen);
    IxpAssert(NULL != m_op.pPropFindRequest);

    if (FAILED(hr = m_op.pPropFindRequest->GenerateXML(&pszXML)))
        goto exit;

    m_op.pvData = pszXML;
    m_op.cbDataLen = lstrlen(pszXML);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::AddDepthHeader
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::AddDepthHeader(void)
{
    HRESULT hr = S_OK;
    char szDepthHeader[64];
    
    if (0 != m_op.dwDepth && !!(m_op.dwRHFlags & RH_NOROOT))
    {
        if (DEPTH_INFINITY == m_op.dwDepth)
            StrCpyN(szDepthHeader, c_szDepthInfinityNoRootHeader, ARRAYSIZE(szDepthHeader));
        else
            wnsprintf(szDepthHeader, ARRAYSIZE(szDepthHeader), c_szDepthNoRootHeader, m_op.dwDepth);
    }
    else
    {
        if (DEPTH_INFINITY == m_op.dwDepth)
            StrCpyN(szDepthHeader, c_szDepthInfinityHeader, ARRAYSIZE(szDepthHeader));
        else
            wnsprintf(szDepthHeader, ARRAYSIZE(szDepthHeader), c_szDepthHeader, m_op.dwDepth);
    }
    
    if (!HttpAddRequestHeaders(m_op.hRequest, szDepthHeader, lstrlen(szDepthHeader), HTTP_ADDREQ_FLAG_ADD))
    {
        _HrThunkConnectionError();
        hr = E_FAIL;
    }

    return hr;    
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::GeneratePropPatchXML
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::GeneratePropPatchXML(void)
{
    HRESULT hr = S_OK;
    LPSTR pszXML = NULL;

    IxpAssert(NULL == m_op.pvData && 0 == m_op.cbDataLen);
    IxpAssert(NULL != m_op.pPropPatchRequest);

    if (FAILED(hr = m_op.pPropPatchRequest->GenerateXML(&pszXML)))
        goto exit;

    m_op.pvData = pszXML;
    m_op.cbDataLen = lstrlen(pszXML);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ProcessCreatedResponse
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::ProcessCreatedResponse(void)
{
    HRESULT     hr = S_OK;
    
    if (m_pLogFile && !m_op.fLoggedResponse)
        _LogResponse(NULL, 0);

    if (HTTP_STATUS_CREATED != m_op.dwHttpStatus)
    {
        _HrThunkConnectionError();
        hr = E_FAIL;
    }

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::AddCommonHeaders
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::AddCommonHeaders(void)
{
    HRESULT     hr = S_OK;
    CHAR        szHeader[CCHMAX_RES];

    if (!!(RH_ALLOWRENAME & m_op.dwRHFlags))
    {
        if (FAILED(hr = _AddRequestHeader(c_szAllowRenameHeader)))
            goto exit;
    }

    if (!!(RH_TRANSLATEFALSE & m_op.dwRHFlags))
    {
        if (FAILED(hr = _AddRequestHeader(c_szTranslateFalseHeader)))
            goto exit;
    }

    if (!!(RH_TRANSLATETRUE & m_op.dwRHFlags))
    {
        if (FAILED(hr = _AddRequestHeader(c_szTranslateTrueHeader)))
            goto exit;
    }

    if (!!(RH_XMLCONTENTTYPE & m_op.dwRHFlags))
    {
        IxpAssert(NULL == m_op.pszContentType);
        m_op.pszContentType = PszDupA(c_szXmlContentType);
        if (NULL == m_op.pszContentType)
        {
            hr = TrapError(E_OUTOFMEMORY);
            goto exit;
        }
        if (FAILED(hr = AddContentTypeHeader()))
            goto exit;
    }

    if (!!(RH_MESSAGECONTENTTYPE & m_op.dwRHFlags))
    {
        IxpAssert(NULL == m_op.pszContentType);
        m_op.pszContentType = PszDupA(c_szMailContentType);
        if (NULL == m_op.pszContentType)
        {
            hr = TrapError(E_OUTOFMEMORY);
            goto exit;
        }
        if (FAILED(hr = AddContentTypeHeader()))
            goto exit;
    }

    if (!!(RH_SMTPMESSAGECONTENTTYPE & m_op.dwRHFlags))
    {
        IxpAssert(NULL == m_op.pszContentType);
        m_op.pszContentType = PszDupA(c_szSmtpMessageContentType);
        if (NULL == m_op.pszContentType)
        {
            hr = TrapError(E_OUTOFMEMORY);
            goto exit;
        }
        if (FAILED(hr = AddContentTypeHeader()))
            goto exit;
    }

    if (!!(RH_BRIEF & m_op.dwRHFlags))
    {
        if (FAILED(hr = _AddRequestHeader(c_szBriefHeader)))
            goto exit;
    }

    if (!!(RH_SAVEINSENTTRUE & m_op.dwRHFlags))
    {
        FAIL_EXIT(hr = _AddRequestHeader(c_szSaveInSentTrue));
    }

    if (!!(RH_SAVEINSENTFALSE & m_op.dwRHFlags))
    {
        FAIL_EXIT(hr = _AddRequestHeader(c_szSaveInSentFalse));
    }

    if (!!(RH_ROOTTIMESTAMP & m_op.dwRHFlags))
    {
        wnsprintf(szHeader, ARRAYSIZE(szHeader), c_szRootTimeStampHeader, m_op.pszRootTimeStamp, m_op.pszFolderTimeStamp);

        FAIL_EXIT(hr = _AddRequestHeader(szHeader));
    }

    if (!!(RH_FOLDERTIMESTAMP & m_op.dwRHFlags))
    {
        wnsprintf(szHeader, ARRAYSIZE(szHeader), c_szFolderTimeStampHeader, m_op.pszFolderTimeStamp);

        FAIL_EXIT(hr = _AddRequestHeader(szHeader));

    }


    // Fix for 88820
    if (!!(RH_ADDCHARSET & m_op.dwRHFlags))
    {
        CODEPAGEINFO CodePageInfo;

        MimeOleGetCodePageInfo(CP_ACP, &CodePageInfo);

        *szHeader = 0;
        wnsprintf(szHeader, ARRAYSIZE(szHeader), c_szAcceptCharset, CodePageInfo.szWebCset);

        FAIL_EXIT(hr = _AddRequestHeader(szHeader));
    }
    // end  of fix

exit:
    return hr;
}
// CHTTPMailTransport::AddCharsetLine
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::AddCharsetLine(void)
{
    HRESULT     hr = S_OK;
    CHAR        szHeader[CCHMAX_RES];
	
	CODEPAGEINFO CodePageInfo;
	
	MimeOleGetCodePageInfo(CP_ACP, &CodePageInfo);
	
	*szHeader = 0;
	wnsprintf(szHeader, ARRAYSIZE(szHeader), c_szAcceptCharset, CodePageInfo.szWebCset);
	
	hr = _AddRequestHeader(szHeader);

    return hr;
}
// --------------------------------------------------------------------------------
// CHTTPMailTransport::AddDestinationHeader
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::AddDestinationHeader(void)
{
    HRESULT hr = S_OK;
    ULONG   cchSize = (lstrlen(c_szDestinationHeader) + lstrlen(m_op.pszDestination) + 1);
    LPSTR   pszDestHeader = NULL;

    if (!MemAlloc((void **)&pszDestHeader, cchSize * sizeof(pszDestHeader[0])))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    wnsprintf(pszDestHeader, cchSize, "%s%s", c_szDestinationHeader, m_op.pszDestination);
    hr = _AddRequestHeader(pszDestHeader);

exit:
    SafeMemFree(pszDestHeader);
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::AddContentTypeHeader
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::AddContentTypeHeader(void)
{
    HRESULT     hr = S_OK;
    ULONG       cchSize;
    LPSTR       pszContentTypeHeader = NULL;

    if (NULL == m_op.pszContentType)
        goto exit;

    cchSize = lstrlen(c_szContentTypeHeader) + lstrlen(m_op.pszContentType) + 1;
    if (!MemAlloc((void **)&pszContentTypeHeader, cchSize * sizeof(pszContentTypeHeader[0])))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    wnsprintf(pszContentTypeHeader, cchSize, "%s%s", c_szContentTypeHeader, m_op.pszContentType);
    hr = _AddRequestHeader(pszContentTypeHeader);

exit:
    SafeMemFree(pszContentTypeHeader);
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ProcessLocationResponse
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::ProcessLocationResponse(void)
{
    _GetRequestHeader(&m_op.rResponse.rCopyMoveInfo.pszLocation, HTTP_QUERY_LOCATION);
    return S_OK;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::InitBCopyMove
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::InitBCopyMove(void)
{
    HRESULT     hr = S_OK;

    // allocate a buffer to contain the response list
    if (!MemAlloc((void **)&m_op.rResponse.rBCopyMoveList.prgBCopyMove, 
        BCOPYMOVE_MAXRESPONSES * sizeof(HTTPMAILBCOPYMOVE)))
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    ZeroMemory(m_op.rResponse.rBCopyMoveList.prgBCopyMove, BCOPYMOVE_MAXRESPONSES * sizeof(HTTPMAILBCOPYMOVE));

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::InitRootProps
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::InitRootProps(void)
{
    HRESULT     hr = S_OK;

    // it is possible to end up here, and have the root props
    // if the caller either forced the request to go async,
    // or queued up multiple requests for root props.
    if (GetHasRootProps())
    {
        // finalize the root props, and return an error.
        // this will generate the response to the caller,
        // and fall out of the fsm.
        FinalizeRootProps();
        hr = E_FAIL;
    }
    else
    {
        IxpAssert(NULL == m_op.pPropFindRequest);

        m_op.pPropFindRequest = new CPropFindRequest();
        if (NULL == m_op.pPropFindRequest)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        hr = XP_CREATE_PROPFIND_REQUEST(ROOTPROPS, m_op.pPropFindRequest);
    }

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::FinalizeRootProps
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::FinalizeRootProps(void)
{
    HRESULT     hr = S_OK;

    m_fHasRootProps = TRUE;

    m_op.rResponse.rGetPropInfo.type = m_op.tyProp;

    if (m_op.tyProp != HTTPMAIL_PROP_MAXPOLLINGINTERVAL)
    {
        m_op.rResponse.rIxpResult.hrResult = GetProperty(m_op.tyProp, &m_op.rResponse.rGetPropInfo.pszProp);
    }
    else
    {
        m_op.rResponse.rIxpResult.hrResult = GetPropertyDw(m_op.tyProp, &m_op.rResponse.rGetPropInfo.dwProp);
    }

    hr = _HrThunkResponse(TRUE);
    SafeMemFree(m_op.rResponse.rGetPropInfo.pszProp);

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::InitMemberInfo
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::InitMemberInfo(void)
{
    HRESULT     hr = S_OK;

    IxpAssert(NULL == m_op.pPropFindRequest);

    // create the propfind request
    m_op.pPropFindRequest = new CPropFindRequest();
    if (NULL == m_op.pPropFindRequest)
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }

    // always add the common properties
    FAIL_EXIT(hr = XP_CREATE_PROPFIND_REQUEST(HTTPMEMBERINFO_COMMON, m_op.pPropFindRequest));

    // if the client requested folder props, add that schema
    if (!!(m_op.dwMIFlags & HTTP_MEMBERINFO_FOLDERPROPS))
        FAIL_EXIT(hr = XP_CREATE_PROPFIND_REQUEST(HTTPMEMBERINFO_FOLDER, m_op.pPropFindRequest));

    // if the client requested message props, add that schema
    if (!!(m_op.dwMIFlags & HTTP_MEMBERINFO_MESSAGEPROPS))
        FAIL_EXIT(hr = XP_CREATE_PROPFIND_REQUEST(HTTPMEMBERINFO_MESSAGE, m_op.pPropFindRequest));

    // allocate a buffer to contain the response list
    if (!MemAlloc((void **)&m_op.rResponse.rMemberInfoList.prgMemberInfo,
        MEMBERINFO_MAXRESPONSES * sizeof(HTTPMEMBERINFO)))
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }
    
    ZeroMemory(m_op.rResponse.rMemberInfoList.prgMemberInfo, MEMBERINFO_MAXRESPONSES * sizeof(HTTPMEMBERINFO));

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::InitMemberError
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::InitMemberError(void)
{
    HRESULT     hr = S_OK;

    // allocate a buffer to contain the response list
    if (!MemAlloc((void **)&m_op.rResponse.rMemberErrorList.prgMemberError,
        MEMBERERROR_MAXRESPONSES * sizeof(HTTPMEMBERERROR)))
    {
        hr = TrapError(E_OUTOFMEMORY);
        goto exit;
    }
    
    ZeroMemory(m_op.rResponse.rMemberErrorList.prgMemberError, MEMBERERROR_MAXRESPONSES * sizeof(HTTPMEMBERERROR));

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// InitListContacts
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::InitListContacts(void)
{
    HRESULT     hr = S_OK;

    IxpAssert(NULL == m_op.pPropFindRequest);

    m_op.pPropFindRequest = new CPropFindRequest();
    if (NULL == m_op.pPropFindRequest)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    hr = XP_CREATE_PROPFIND_REQUEST(HTTPCONTACTID, m_op.pPropFindRequest);
    if (FAILED(hr))
        goto exit;

    // allocate a buffer to contain the response list
    if (!MemAlloc((void **)&m_op.rResponse.rContactIdList.prgContactId,
        LISTCONTACTS_MAXRESPONSES * sizeof(HTTPCONTACTID)))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    ZeroMemory(m_op.rResponse.rContactIdList.prgContactId, LISTCONTACTS_MAXRESPONSES * sizeof(HTTPCONTACTID));

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::InitContactInfo
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::InitContactInfo(void)
{
    HRESULT     hr = S_OK;

    IxpAssert(NULL == m_op.pPropFindRequest);

    m_op.pPropFindRequest = new CPropFindRequest();
    if (NULL == m_op.pPropFindRequest)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    hr = XP_CREATE_PROPFIND_REQUEST(HTTPCONTACTINFO, m_op.pPropFindRequest);
    if (FAILED(hr))
        goto exit;

    // allocate a buffer to contain the response list
    if (!MemAlloc((void **)&m_op.rResponse.rContactInfoList.prgContactInfo,
        CONTACTINFO_MAXRESPONSES * sizeof(HTTPCONTACTINFO)))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    ZeroMemory(m_op.rResponse.rContactInfoList.prgContactInfo, CONTACTINFO_MAXRESPONSES * sizeof(HTTPCONTACTINFO));

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ProcessPostContactResponse
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::ProcessPostContactResponse(void)
{
    HRESULT                 hr = S_OK;
    DWORD                   dwSize = MAX_PATH;
    LPSTR                   pszLocation = NULL;
    DWORD                   dwContext;
    int                     iState;

    if (m_pLogFile && !m_op.fLoggedResponse)
        _LogResponse(NULL, 0);

    if (HTTP_STATUS_CREATED != m_op.dwHttpStatus)
    {
        _HrThunkConnectionError();
        hr = E_FAIL;
        goto exit;
    }

    if (FAILED(hr = _GetRequestHeader(&pszLocation, HTTP_QUERY_LOCATION)))
        goto exit;

    // Prepare for the next phase

    // save the context and the state
    dwContext = m_op.dwContext;
    iState = m_op.iState;

    FreeOperation();

    // restore context, state, parsing funcs, etc.

    m_op.rResponse.command = HTTPMAIL_POSTCONTACT;
    m_op.pszUrl = pszLocation;
    pszLocation = NULL;
    m_op.dwContext = dwContext;

    m_op.pfnState = c_rgpfnPostContact;
    m_op.cState = ARRAYSIZE(c_rgpfnPostContact);
    m_op.iState = iState;
    m_op.pParseFuncs = c_rgpfnPostOrPatchContactParse;

    m_op.dwDepth = 0;
    m_op.dwRHFlags = (RH_XMLCONTENTTYPE | RH_BRIEF);

    m_op.rResponse.rPostContactInfo.pszHref = PszDupA(m_op.pszUrl);
    if (NULL == m_op.rResponse.rPostContactInfo.pszHref)
        hr = E_OUTOFMEMORY;

exit:
    SafeMemFree(pszLocation);
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ProcessPatchContactResponse
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::ProcessPatchContactResponse(void)
{
    HRESULT             hr = S_OK;
    LPSTR               pszUrl = NULL;
    DWORD               dwContext;
    int                 iState;
    IHTTPMailCallback   *pCallback = NULL;

    // REVIEW: we should be handling multistatus responses
    if (200 > m_op.dwHttpStatus || 300 < m_op.dwHttpStatus)
    {
        _HrThunkConnectionError();
        hr = E_FAIL;
        goto exit;
    }

    // prepare for the next phase
    
    // save the context and the state
    pszUrl = m_op.pszUrl;
    m_op.pszUrl = NULL;
    dwContext = m_op.dwContext;
    iState = m_op.iState;

    FreeOperation();

    // restore context, etc.
    m_op.rResponse.command = HTTPMAIL_PATCHCONTACT;
    m_op.pszUrl = pszUrl;
    m_op.dwContext = dwContext;
    m_op.pfnState = c_rgpfnPatchContact;
    m_op.cState = ARRAYSIZE(c_rgpfnPatchContact);
    m_op.iState = iState;
    m_op.pParseFuncs = c_rgpfnPostOrPatchContactParse; // share the post contact parse funcs

    m_op.dwDepth = 0;
    m_op.rResponse.rPatchContactInfo.pszHref = PszDupA(m_op.pszUrl);

    m_op.dwRHFlags = (RH_BRIEF | RH_XMLCONTENTTYPE);

    pszUrl = NULL;

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// XML Parsing Callbacks
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// CHTTPMailTransport::CreateElement
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::CreateElement(
                                        CXMLNamespace *pBaseNamespace,
                                        const WCHAR *pwcText, 
                                        ULONG ulLen, 
                                        ULONG ulNamespaceLen,
                                        BOOL fTerminal)
{
    // increment the stack pointer and, if there is room on the stack,
    // push the element type
    if (!fTerminal)
    {
        if (m_op.dwStackDepth < ELE_STACK_CAPACITY)
        {
            m_op.rgEleStack[m_op.dwStackDepth].ele = XMLElementToID(pwcText, ulLen, ulNamespaceLen, m_op.pTopNamespace);
            m_op.rgEleStack[m_op.dwStackDepth].pBaseNamespace = pBaseNamespace;
            m_op.rgEleStack[m_op.dwStackDepth].fBeganChildren = FALSE;
            m_op.rgEleStack[m_op.dwStackDepth].pTextBuffer = NULL;
        }

        ++m_op.dwStackDepth;
    }
    
    return S_OK;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::EndChildren
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::EndChildren(void)
{
    HRESULT hr = S_OK;

    // decrement the stack pointer
    if (m_op.dwStackDepth <= ELE_STACK_CAPACITY)
    {
        LPPCDATABUFFER pTextBuffer = m_op.rgEleStack[m_op.dwStackDepth - 1].pTextBuffer;

        if (pTextBuffer)
        {
            hr = (this->*(m_op.pParseFuncs->pfnHandleText))(pTextBuffer->pwcText, pTextBuffer->ulLen);
            _ReleaseTextBuffer(pTextBuffer);
        }
        else
            hr = (this->*(m_op.pParseFuncs->pfnHandleText))(NULL, 0);

        // unroll the namespace
        PopNamespaces(m_op.rgEleStack[m_op.dwStackDepth - 1].pBaseNamespace);
    }

    --m_op.dwStackDepth;

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::BCopyMove_HandleText
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::BCopyMove_HandleText(const WCHAR *pwcText, ULONG ulLen)
{
    HRESULT                 hr = S_OK;
    LPHTTPMAILBCOPYMOVE     pInfo = &m_op.rResponse.rBCopyMoveList.prgBCopyMove[m_op.rResponse.rBCopyMoveList.cBCopyMove];
    
    return XP_BIND_TO_STRUCT(HTTPMAILBCOPYMOVE, pwcText, ulLen, pInfo, NULL);
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::BCopyMove_EndChildren
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::BCopyMove_EndChildren(void)
{
    HRESULT     hr = S_OK;

    if (StackTop(HMELE_DAV_RESPONSE) && VALIDSTACK(c_rgPropFindResponseStack))
    {
        // clear the prop flags, since we are about to increment the count
        m_op.dwPropFlags = NOFLAGS;

        // increment the list count and, if we've hit the max, send the notification
        if (BCOPYMOVE_MAXRESPONSES == ++m_op.rResponse.rBCopyMoveList.cBCopyMove)
        {
            if (FAILED(hr = _HrThunkResponse(FALSE)))
                goto exit;
            FreeBCopyMoveList();
        }
    }

    hr = EndChildren();

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::PropFind_HandleText
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::PropFind_HandleText(const WCHAR *pwcText, ULONG ulLen)
{
    HRESULT         hr = S_OK;
    LPSTR           pszStatus = NULL;

    // the only element that is handled here is <status>
    if (StackTop(HMELE_DAV_STATUS) && VALIDSTACK(c_rgPropFindStatusStack))
    {
        m_op.fFoundStatus = TRUE;
        m_op.dwStatus = 0;

        if (SUCCEEDED(hr = AllocStrFromStrNW(pwcText, ulLen, &pszStatus)) && NULL != pszStatus)
        {        
            // ignore errors parsing the status...we treat malformed status
            // as status 0, which is an error
            HrParseHTTPStatus(pszStatus, &m_op.dwStatus);
        }
    }

    SafeMemFree(pszStatus);
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::RootProps_HandleText
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::RootProps_HandleText(const WCHAR *pwcText, ULONG ulLen)
{
    HRESULT hr = S_OK;
    BOOL    fWasBound = FALSE;

    hr = XP_BIND_TO_STRUCT(ROOTPROPS, pwcText, ulLen, &m_rootProps, &fWasBound);
    if (FAILED(hr))
        goto exit;

    if (!fWasBound)
        hr = PropFind_HandleText(pwcText, ulLen);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::RootProps_EndChildren
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::RootProps_EndChildren(void)
{
    // if we are popping a prop node with a bad status code,
    // free any data associated with the node
    if (StackTop(HMELE_DAV_PROPSTAT) && VALIDSTACK(c_rgPropFindPropStatStack))
    {
        if (!m_op.fFoundStatus || m_op.dwStatus != 200)
            XP_FREE_STRUCT(ROOTPROPS, &m_rootProps, &m_op.dwPropFlags);

        m_op.fFoundStatus = FALSE;
        m_op.dwPropFlags = NOFLAGS;
    }

    return EndChildren();
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::MemberInfo_HandleText
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::MemberInfo_HandleText(const WCHAR *pwcText, ULONG ulLen)
{
    HRESULT             hr = S_OK;
    LPHTTPMEMBERINFO    pInfo = &m_op.rResponse.rMemberInfoList.prgMemberInfo[m_op.rResponse.rMemberInfoList.cMemberInfo];
    BOOL                fWasBound = FALSE;

    FAIL_EXIT(hr = XP_BIND_TO_STRUCT(HTTPMEMBERINFO, pwcText, ulLen, pInfo, &fWasBound));

    if (!fWasBound)
        hr = PropFind_HandleText(pwcText, ulLen);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::MemberInfo_EndChildren
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::MemberInfo_EndChildren(void)
{
    HRESULT     hr = S_OK;

    // if we are popping a propstat node with a bad status code,
    // free any data associated with the node
    if (StackTop(HMELE_DAV_PROPSTAT) && VALIDSTACK(c_rgPropFindPropStatStack))
    {
        // grab a pointer to the folder info we are accumulating
        LPHTTPMEMBERINFO pInfo = 
                &m_op.rResponse.rMemberInfoList.prgMemberInfo[m_op.rResponse.rMemberInfoList.cMemberInfo];

        if (!m_op.fFoundStatus || m_op.dwStatus != 200)
            XP_FREE_STRUCT(HTTPMEMBERINFO, pInfo, &m_op.dwPropFlags);

        m_op.fFoundStatus = FALSE;
        m_op.dwPropFlags = NOFLAGS;
    }
    else if (StackTop(HMELE_DAV_RESPONSE) && VALIDSTACK(c_rgPropFindResponseStack))
    {
        // increment the list count and, if we've hit the max, send the notification
        if (MEMBERINFO_MAXRESPONSES == ++m_op.rResponse.rMemberInfoList.cMemberInfo)
        {
            if (FAILED(hr = _HrThunkResponse(FALSE)))
                goto exit;
            FreeMemberInfoList();
        }
    }

    hr = EndChildren();

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::MemberError_HandleText
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::MemberError_HandleText(const WCHAR *pwcText, ULONG ulLen)
{
    HRESULT             hr = S_OK;
    LPHTTPMEMBERERROR   pInfo = &m_op.rResponse.rMemberErrorList.prgMemberError[m_op.rResponse.rMemberErrorList.cMemberError];
    BOOL                fWasBound = FALSE;

    FAIL_EXIT(hr = XP_BIND_TO_STRUCT(HTTPMEMBERERROR, pwcText, ulLen, pInfo, &fWasBound));

    if (!fWasBound)
        hr = PropFind_HandleText(pwcText, ulLen);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::MemberError_EndChildren
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::MemberError_EndChildren(void)
{
    HRESULT     hr = S_OK;

    // if we are popping a propstat node with a bad status code,
    // free any data associated with the node
    if (StackTop(HMELE_DAV_PROPSTAT) && VALIDSTACK(c_rgPropFindPropStatStack))
    {
        // grab a pointer to the folder info we are accumulating
        LPHTTPMEMBERERROR pInfo = 
                &m_op.rResponse.rMemberErrorList.prgMemberError[m_op.rResponse.rMemberErrorList.cMemberError];

        if (!m_op.fFoundStatus || m_op.dwStatus != 200)
            XP_FREE_STRUCT(HTTPMEMBERERROR, pInfo, &m_op.dwPropFlags);

        m_op.fFoundStatus = FALSE;
        m_op.dwPropFlags = NOFLAGS;
    }
    else if (StackTop(HMELE_DAV_RESPONSE) && VALIDSTACK(c_rgPropFindResponseStack))
    {
        // increment the list count and, if we've hit the max, send the notification
        if (MEMBERERROR_MAXRESPONSES == ++m_op.rResponse.rMemberErrorList.cMemberError)
        {
            if (FAILED(hr = _HrThunkResponse(FALSE)))
                goto exit;
            FreeMemberErrorList();
        }
    }

    hr = EndChildren();

exit:
    return hr;
}


// --------------------------------------------------------------------------------
// CHTTPMailTransport::ListContacts_HandleText
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::ListContacts_HandleText(const WCHAR *pwcText, ULONG ulLen)
{
    HRESULT         hr = S_OK;
    LPHTTPCONTACTID pId = &m_op.rResponse.rContactIdList.prgContactId[m_op.rResponse.rContactIdList.cContactId];
    BOOL            fWasBound = FALSE;

    hr = XP_BIND_TO_STRUCT(HTTPCONTACTID, pwcText, ulLen, pId, &fWasBound);
    if (FAILED(hr))
        goto exit;

    if (!fWasBound)
        hr = PropFind_HandleText(pwcText, ulLen);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ListContacts_EndChildren
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::ListContacts_EndChildren(void)
{
    HRESULT hr = S_OK;

    // if we are popping a propstat node with a bad status code,
    // free any data associated with the node
    if (StackTop(HMELE_DAV_PROPSTAT) && VALIDSTACK(c_rgPropFindPropStatStack))
    {
        // grab a pointer to the contact id we are accumulating
        LPHTTPCONTACTID pId = &m_op.rResponse.rContactIdList.prgContactId[m_op.rResponse.rContactIdList.cContactId];

        if (!m_op.fFoundStatus || m_op.dwStatus != 200)
            XP_FREE_STRUCT(HTTPCONTACTID, pId, &m_op.dwPropFlags);

        m_op.fFoundStatus = FALSE;
        m_op.dwPropFlags = NOFLAGS;
    }
    else if (StackTop(HMELE_DAV_RESPONSE) && VALIDSTACK(c_rgPropFindResponseStack))
    {
        // increment the list count and, if we've hit the max, send the notification
        if (LISTCONTACTS_MAXRESPONSES == ++m_op.rResponse.rContactIdList.cContactId)
        {
            if (FAILED(hr = _HrThunkResponse(FALSE)))
                goto exit;
            FreeContactIdList();
        }
    }

    hr = EndChildren();

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ContactInfo_HandleText
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::ContactInfo_HandleText(const WCHAR *pwcText, ULONG ulLen)
{
    HRESULT             hr = S_OK;
    LPHTTPCONTACTINFO   pInfo = &m_op.rResponse.rContactInfoList.prgContactInfo[m_op.rResponse.rContactInfoList.cContactInfo];
    BOOL                fWasBound = FALSE;

    hr = XP_BIND_TO_STRUCT(HTTPCONTACTINFO, pwcText, ulLen, pInfo, &fWasBound);
    if (FAILED(hr))
        goto exit;

    if (!fWasBound)
        hr = PropFind_HandleText(pwcText, ulLen);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::ContactInfo_EndChildren
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::ContactInfo_EndChildren()
{
    HRESULT hr = S_OK;

    // if we are popping a propstat node with a bad status code,
    // free any data associated with the node
    if (StackTop(HMELE_DAV_PROPSTAT) && VALIDSTACK(c_rgPropFindPropStatStack))
    {
        // grab a pointer to the contact id we are accumulating
        LPHTTPCONTACTINFO pInfo = &m_op.rResponse.rContactInfoList.prgContactInfo[m_op.rResponse.rContactInfoList.cContactInfo];

        if (!m_op.fFoundStatus || m_op.dwStatus != 200)
            XP_FREE_STRUCT(HTTPCONTACTINFO, pInfo, &m_op.dwPropFlags);
 
        m_op.fFoundStatus = FALSE;
        m_op.dwPropFlags = NOFLAGS;
    }
    else if (StackTop(HMELE_DAV_RESPONSE) && VALIDSTACK(c_rgPropFindResponseStack))
    {
        // increment the list count and, if we've hit the max, send the notification
        if (CONTACTINFO_MAXRESPONSES == ++m_op.rResponse.rContactInfoList.cContactInfo)
        {
            if (FAILED(hr = _HrThunkResponse(FALSE)))
                goto exit;
            FreeContactInfoList();
        }
    }

    hr = EndChildren();

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::PostOrPatchContact_HandleText
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::PostOrPatchContact_HandleText(const WCHAR *pwcText, ULONG ulLen)
{
    HRESULT         hr = S_OK;
    LPHTTPCONTACTID pId = NULL;
    BOOL            fWasBound = FALSE;

    if (HTTPMAIL_POSTCONTACT == m_op.rResponse.command)
        pId = &m_op.rResponse.rPostContactInfo;
    else if (HTTPMAIL_PATCHCONTACT == m_op.rResponse.command)
        pId = &m_op.rResponse.rPatchContactInfo;

    IxpAssert(pId);

    hr = XP_BIND_TO_STRUCT(HTTPCONTACTID, pwcText, ulLen, pId, &fWasBound);
    if (FAILED(hr))
        goto exit;

    if (!fWasBound)
        hr = PropFind_HandleText(pwcText, ulLen);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::PostOrPatchContact_EndChildren
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::PostOrPatchContact_EndChildren(void)
{
    HRESULT hr = S_OK;

    // if we are popping a propstat node with a bad status code,
    // free any data associated with the node
    if (StackTop(HMELE_DAV_PROPSTAT) && VALIDSTACK(c_rgPropFindPropStatStack))
    {
        // grab a pointer to the contact id we are accumulating
        LPHTTPCONTACTID pId = NULL;
        
        if (HTTPMAIL_POSTCONTACT == m_op.rResponse.command)
            pId = &m_op.rResponse.rPostContactInfo;
        else if (HTTPMAIL_PATCHCONTACT == m_op.rResponse.command)
            pId = &m_op.rResponse.rPatchContactInfo;

        IxpAssert(pId);

        if (!m_op.fFoundStatus || m_op.dwStatus != 200)
            XP_FREE_STRUCT(HTTPCONTACTID, pId, &m_op.dwPropFlags);

        m_op.fFoundStatus = FALSE;
        m_op.dwPropFlags = NOFLAGS;
    }

    hr = EndChildren();

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_MemberInfo2
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::_MemberInfo2(LPCSTR            pszPath, 
                                         MEMBERINFOFLAGS   flags, 
                                         DWORD             dwDepth,
                                         BOOL              fIncludeRoot,
                                         DWORD             dwContext,
                                         LPHTTPQUEUEDOP    *ppOp)
{
    HRESULT             hr = S_OK;
    LPHTTPQUEUEDOP      pOp = NULL;

    if (!ppOp)
    {
        IF_FAILEXIT(hr = E_INVALIDARG);
    }

    if (NULL == pszPath)
        return TrapError(E_INVALIDARG);

    FAIL_CREATEWND;

#pragma prefast(suppress:11, "noise")
    *ppOp = NULL;

    if (FAILED(hr = AllocQueuedOperation(pszPath, NULL, 0, &pOp)))
        goto exit;

    pOp->command        = HTTPMAIL_MEMBERINFO;
    pOp->dwMIFlags      = flags;
    pOp->dwDepth        = dwDepth;
    pOp->dwContext      = dwContext;
    pOp->pfnState       = c_rgpfnMemberInfo;
    pOp->cState         = ARRAYSIZE(c_rgpfnMemberInfo);
    pOp->pParseFuncs    = c_rgpfnMemberInfoParse;

    pOp->dwRHFlags = (RH_BRIEF | RH_XMLCONTENTTYPE);
    if (!fIncludeRoot)
        pOp->dwRHFlags |= RH_NOROOT;


exit:
    if (SUCCEEDED(hr))
    {
#pragma prefast(suppress:11, "noise")
        *ppOp = pOp;
    }

    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::RootMemberInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::RootMemberInfo(LPCSTR                  pszPath,
                                                MEMBERINFOFLAGS         flags,
                                                DWORD                   dwDepth,
                                                BOOL                    fIncludeRoot,
                                                DWORD                   dwContext,
                                                LPSTR                   pszRootTimeStamp,
                                                LPSTR                   pszInboxTimeStamp)                  
{
    HRESULT             hr = S_OK;
    LPHTTPQUEUEDOP      pOp;

    IF_FAILEXIT(hr = _MemberInfo2(pszPath, flags, dwDepth, fIncludeRoot, dwContext, &pOp));

    pOp->dwRHFlags |= RH_ROOTTIMESTAMP | RH_ADDCHARSET;
    pOp->pszRootTimeStamp   = PszDupA(pszRootTimeStamp);
    pOp->pszFolderTimeStamp = PszDupA(pszInboxTimeStamp);

    QueueOperation(pOp);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::FolderMemberInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CHTTPMailTransport::FolderMemberInfo(LPCSTR                  pszPath,
                                                  MEMBERINFOFLAGS         flags,
                                                  DWORD                   dwDepth,
                                                  BOOL                    fIncludeRoot,
                                                  DWORD                   dwContext,
                                                  LPSTR                   pszFolderTimeStamp,
                                                  LPSTR                   pszFolderName)
{
    HRESULT             hr = S_OK;
    LPHTTPQUEUEDOP      pOp;

    IF_FAILEXIT(hr = _MemberInfo2(pszPath, flags, dwDepth, fIncludeRoot, dwContext, &pOp));

    pOp->dwRHFlags              |= RH_FOLDERTIMESTAMP | RH_ADDCHARSET;
    pOp->pszFolderTimeStamp      = PszDupA(pszFolderTimeStamp);

    // To be used when we do timestamping on every folder. Right now the default is inbox
    //pOp->pszFolderName           = PszDupA(pszFolderName);

    QueueOperation(pOp);

exit:
    return hr;
}

HRESULT CHTTPMailTransport::_HrParseAndCopy(LPCSTR pszToken, LPSTR *ppszDest, LPSTR lpszSrc)
{
    LPSTR   lpszBeginning = lpszSrc;
    LPSTR   lpszEnd;
    DWORD   dwCount = 0;
    HRESULT hr = E_FAIL;    
    int cchSize;

    lpszBeginning = StrStr(lpszSrc, pszToken);
    if (!lpszBeginning)
        goto exit;

    lpszBeginning = StrChr(lpszBeginning, '=');
    if (!lpszBeginning)
        goto exit;

    // Skip the equal sign
    ++lpszBeginning;

    SkipWhitespace(lpszBeginning, &dwCount);
    lpszBeginning += dwCount;

    lpszEnd = StrChr(lpszBeginning, ',');

    if (!lpszEnd)
    {
        //Its possible that this token is at the end. So use the remaining string.
        //Lets take a look at the length and make sure that it doesn't fall off the deep end.
        lpszEnd = lpszBeginning + strlen(lpszBeginning);
    }

    AssertSz(((lpszEnd - lpszBeginning + 1) < 20), "This number looks awfully long, please make sure that this is correct")

    cchSize = (int)(lpszEnd - lpszBeginning + 2);
    if (!MemAlloc((void**)ppszDest, cchSize))
        goto exit;

    cchSize = (int)(lpszEnd - lpszBeginning + 1);
    StrCpyN(*ppszDest, lpszBeginning, cchSize);

    // Null terminate it
    *(*ppszDest + (lpszEnd - lpszBeginning + 1)) = 0;

    hr = S_OK;

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CHTTPMailTransport::_GetTimestampHeader
// --------------------------------------------------------------------------------
HRESULT CHTTPMailTransport::_HrGetTimestampHeader(LPSTR *ppszHeader)
{
    HRESULT     hr        = S_OK;
    DWORD       dwSize    = MAX_PATH;
    LPSTR       pszHeader = NULL;

    Assert(NULL != ppszHeader);
    *ppszHeader = NULL;

retry:
    if (!MemAlloc((void **)&pszHeader, dwSize))
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    StrCpyN(pszHeader, c_szXTimestamp, dwSize);

    if (!HttpQueryInfo(m_op.hRequest, HTTP_QUERY_RAW_HEADERS | HTTP_QUERY_CUSTOM, pszHeader, &dwSize, NULL))
    {
        if (ERROR_INSUFFICIENT_BUFFER != GetLastError())
        {
            hr = E_FAIL;
            goto exit;
        }

        SafeMemFree(pszHeader);        
        goto retry;
    }

    *ppszHeader = pszHeader;
    pszHeader   = NULL;

exit:
    SafeMemFree(pszHeader);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\ixpras.cpp ===
// --------------------------------------------------------------------------------
// Ixpras.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "ixpras.h"
#include "strconst.h"
#include "resource.h"
#include "demand.h"
#include "shlwapi.h"

// --------------------------------------------------------------------------------
// RAS API Typedefs
// --------------------------------------------------------------------------------
typedef DWORD (APIENTRY *RASDIALPROC)(LPRASDIALEXTENSIONS, LPTSTR, LPRASDIALPARAMS, DWORD, LPVOID, LPHRASCONN);
typedef DWORD (APIENTRY *RASENUMCONNECTIONSPROC)(LPRASCONN, LPDWORD, LPDWORD);
typedef DWORD (APIENTRY *RASENUMENTRIESPROC)(LPTSTR, LPTSTR, LPRASENTRYNAME, LPDWORD, LPDWORD);
typedef DWORD (APIENTRY *RASGETCONNECTSTATUSPROC)(HRASCONN, LPRASCONNSTATUS);
typedef DWORD (APIENTRY *RASGETERRORSTRINGPROC)(UINT, LPTSTR, DWORD);
typedef DWORD (APIENTRY *RASHANGUPPROC)(HRASCONN);
typedef DWORD (APIENTRY *RASSETENTRYDIALPARAMSPROC)(LPTSTR, LPRASDIALPARAMS, BOOL);
typedef DWORD (APIENTRY *RASGETENTRYDIALPARAMSPROC)(LPTSTR, LPRASDIALPARAMS, BOOL*);
typedef DWORD (APIENTRY *RASCREATEPHONEBOOKENTRYPROC)(HWND, LPTSTR);
typedef DWORD (APIENTRY *RASEDITPHONEBOOKENTRYPROC)(HWND, LPTSTR, LPTSTR);                                                    

// --------------------------------------------------------------------------------
// RAS Function Pointers
// --------------------------------------------------------------------------------
static RASDIALPROC                 g_pRasDial=NULL;
static RASENUMCONNECTIONSPROC      g_pRasEnumConnections=NULL;
static RASENUMENTRIESPROC          g_pRasEnumEntries=NULL;
static RASGETCONNECTSTATUSPROC     g_pRasGetConnectStatus=NULL;
static RASGETERRORSTRINGPROC       g_pRasGetErrorString=NULL;
static RASHANGUPPROC               g_pRasHangup=NULL;
static RASSETENTRYDIALPARAMSPROC   g_pRasSetEntryDialParams=NULL;
static RASGETENTRYDIALPARAMSPROC   g_pRasGetEntryDialParams=NULL;
static RASCREATEPHONEBOOKENTRYPROC g_pRasCreatePhonebookEntry=NULL;
static RASEDITPHONEBOOKENTRYPROC   g_pRasEditPhonebookEntry=NULL;

#define DEF_HANGUP_WAIT            10 // Seconds

// --------------------------------------------------------------------------------
// Make our code look prettier
// --------------------------------------------------------------------------------
#undef RasDial
#undef RasEnumConnections
#undef RasEnumEntries
#undef RasGetConnectStatus
#undef RasGetErrorString
#undef RasHangup
#undef RasSetEntryDialParams
#undef RasGetEntryDialParams
#undef RasCreatePhonebookEntry
#undef RasEditPhonebookEntry

#define RasDial                    (*g_pRasDial)
#define RasEnumConnections         (*g_pRasEnumConnections)
#define RasEnumEntries             (*g_pRasEnumEntries)
#define RasGetConnectStatus        (*g_pRasGetConnectStatus)
#define RasGetErrorString          (*g_pRasGetErrorString)
#define RasHangup                  (*g_pRasHangup)
#define RasSetEntryDialParams      (*g_pRasSetEntryDialParams)
#define RasGetEntryDialParams      (*g_pRasGetEntryDialParams)
#define RasCreatePhonebookEntry    (*g_pRasCreatePhonebookEntry)
#define RasEditPhonebookEntry      (*g_pRasEditPhonebookEntry)

// --------------------------------------------------------------------------------
// HrLoadRAS
// --------------------------------------------------------------------------------
HRESULT HrLoadRAS(void)
{
    // Locals
    HRESULT     hr=S_OK;
    UINT        uOldErrorMode;

    // Thread Safety
    EnterCriticalSection(&g_csRAS);

    // If dll is loaded, lets verify all of my function pointers
    if (g_hinstRAS)
        goto exit;

    // Bug #20573 - Let's do a little voodoo here.  On NT, it appears that they
    //              have a key in the registry to show which protocols are 
    //              supported by RAS service.  AKA - if this key doesn't exist,
    //              then RAS isn't installed.  This may enable us to avoid some
    //              special bugs when RAS get's uninstalled on NT.
    OSVERSIONINFO os;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&os);

    if (os.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
        HKEY hKey;
        const TCHAR c_szRegKeyRAS[] = TEXT("SOFTWARE\\Microsoft\\RAS");

        if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyRAS, 0, KEY_READ, &hKey))
            {
            hr = TrapError(IXP_E_RAS_NOT_INSTALLED);
            goto exit;
            }

        RegCloseKey(hKey);
        }

    // Try loading RAS
    uOldErrorMode = SetErrorMode(SEM_NOOPENFILEERRORBOX);
    g_hinstRAS = LoadLibraryA("RASAPI32.DLL");
    SetErrorMode(uOldErrorMode);

    // Failure ?
    if (NULL == g_hinstRAS)
    {
        hr = TrapError(IXP_E_RAS_NOT_INSTALLED);
        goto exit;
    }

    // Did we load it
    g_pRasDial                  = (RASDIALPROC)GetProcAddress(g_hinstRAS, c_szRasDial);
    g_pRasEnumConnections       = (RASENUMCONNECTIONSPROC)GetProcAddress(g_hinstRAS, c_szRasEnumConnections);                    
    g_pRasEnumEntries           = (RASENUMENTRIESPROC)GetProcAddress(g_hinstRAS, c_szRasEnumEntries);                    
    g_pRasGetConnectStatus      = (RASGETCONNECTSTATUSPROC)GetProcAddress(g_hinstRAS, c_szRasGetConnectStatus);                    
    g_pRasGetErrorString        = (RASGETERRORSTRINGPROC)GetProcAddress(g_hinstRAS, c_szRasGetErrorString);                    
    g_pRasHangup                = (RASHANGUPPROC)GetProcAddress(g_hinstRAS, c_szRasHangup);                    
    g_pRasSetEntryDialParams    = (RASSETENTRYDIALPARAMSPROC)GetProcAddress(g_hinstRAS, c_szRasSetEntryDialParams);                    
    g_pRasGetEntryDialParams    = (RASGETENTRYDIALPARAMSPROC)GetProcAddress(g_hinstRAS, c_szRasGetEntryDialParams);
    g_pRasCreatePhonebookEntry  = (RASCREATEPHONEBOOKENTRYPROC)GetProcAddress(g_hinstRAS, c_szRasCreatePhonebookEntry);    
    g_pRasEditPhonebookEntry    = (RASEDITPHONEBOOKENTRYPROC)GetProcAddress(g_hinstRAS, c_szRasEditPhonebookEntry);    

    // Make sure all functions have been loaded
    if (g_pRasDial                      &&
        g_pRasEnumConnections           &&
        g_pRasEnumEntries               &&
        g_pRasGetConnectStatus          &&
        g_pRasGetErrorString            &&
        g_pRasHangup                    &&
        g_pRasSetEntryDialParams        &&
        g_pRasGetEntryDialParams        &&
        g_pRasCreatePhonebookEntry      &&
        g_pRasEditPhonebookEntry)
        goto exit;

    // Failure...
    hr = TrapError(IXP_E_RAS_PROCS_NOT_FOUND);

exit:
    // Thread Safety
    LeaveCriticalSection(&g_csRAS);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CRASTransport::CRASTransport
// --------------------------------------------------------------------------------
CRASTransport::CRASTransport(void)
{
    DllAddRef();
    m_cRef = 1;
    m_pCallback = NULL;
    *m_szConnectoid = '\0';
    m_hConn = NULL;
    m_fConnOwner = FALSE;
    m_hwndRAS = NULL;
    m_uRASMsg = 0;
    ZeroMemory(&m_rServer, sizeof(INETSERVER));
    ZeroMemory(&m_rDialParams, sizeof(RASDIALPARAMS));
    InitializeCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CRASTransport::~CRASTransport
// --------------------------------------------------------------------------------
CRASTransport::~CRASTransport(void)
{
    EnterCriticalSection(&m_cs);
    ZeroMemory(&m_rServer, sizeof(INETSERVER));
    SafeRelease(m_pCallback);
    *m_szConnectoid = '\0';
    m_hConn = NULL;
    if (m_hwndRAS)
        DestroyWindow(m_hwndRAS);
    LeaveCriticalSection(&m_cs);
    DeleteCriticalSection(&m_cs);
    DllRelease();
}

// --------------------------------------------------------------------------------
// CRASTransport::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CRASTransport::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // Bad param
    if (ppv == NULL)
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // Init
    *ppv=NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = ((IUnknown *)this);

    // IID_IInternetTransport
    else if (IID_IInternetTransport == riid)
        *ppv = ((IInternetTransport *)this);

    // IID_IRASTransport
    else if (IID_IRASTransport == riid)
        *ppv = (IRASTransport *)this;

    // If not null, addref it and return
    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    // No Interface
    hr = TrapError(E_NOINTERFACE);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CRASTransport::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRASTransport::AddRef(void)
{
    return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CRASTransport::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CRASTransport::Release(void)
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

// --------------------------------------------------------------------------------
// CRASTransport::HandsOffCallback
// --------------------------------------------------------------------------------
STDMETHODIMP CRASTransport::HandsOffCallback(void)
{
    // Locals
    HRESULT     hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // No current callback
    if (NULL == m_pCallback)
    {
        hr = TrapError(S_FALSE);
        goto exit;
    }

    // Release it
    SafeRelease(m_pCallback);

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CRASTransport::InitNew
// --------------------------------------------------------------------------------
STDMETHODIMP CRASTransport::InitNew(IRASCallback *pCallback)
{
    // Locals
    HRESULT         hr=S_OK;

    // check params
    if (NULL == pCallback)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Release current callback
    SafeRelease(m_pCallback);

    // Assume new callback
    m_pCallback = pCallback;
    m_pCallback->AddRef();

    // Have I Create my modeless window for RAS connections yet?
    if (NULL == m_hwndRAS)
    {
        // Create Modeless Window
        m_hwndRAS = CreateDialogParam(g_hLocRes, MAKEINTRESOURCE(IDD_RASCONNECT), NULL, RASConnectDlgProc, (LPARAM)this);
        if (NULL == m_hwndRAS)
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }

        // Get registered RAS event message id
        m_uRASMsg = RegisterWindowMessageA(RASDIALEVENT);
        if (m_uRASMsg == 0)
            m_uRASMsg = WM_RASDIALEVENT;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CRASTransport::GetCurrentConnectoid
// --------------------------------------------------------------------------------
STDMETHODIMP CRASTransport::GetCurrentConnectoid(LPSTR pszConnectoid, ULONG cchMax)
{
    // Locals
    HRESULT     hr=S_OK;
    LPRASCONN   prgConnection=NULL;
    DWORD       cConnection;

    // Invalid Arg
    if (NULL == pszConnectoid || cchMax < CCHMAX_CONNECTOID)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Get Current RAS Connection
    if (FEnumerateConnections(&prgConnection, &cConnection) == 0 || 0 == cConnection)
    {
        hr = IXP_E_NOT_CONNECTED;
        goto exit;
    }

    // Is there at l
    StrCpyN(pszConnectoid, prgConnection[0].szEntryName, cchMax);

exit:
    // Cleanup
    SafeMemFree(prgConnection);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CRASTransport::Connect
// --------------------------------------------------------------------------------
STDMETHODIMP CRASTransport::Connect(LPINETSERVER pInetServer, boolean fAuthenticate, boolean fCommandLogging)
{
    // Locals
    HRESULT         hr=S_OK;
    LPRASCONN       prgConn=NULL;
    DWORD           cConn,
                    dwError;

    // check params
    if (NULL == pInetServer)
        return TrapError(E_INVALIDARG);

    // RAS_CONNECT_RAS ?
    if (RAS_CONNECT_RAS != pInetServer->rasconntype)
        return IXP_S_RAS_NOT_NEEDED;

    // Empty Connectoid
    if (FIsEmptyA(pInetServer->szConnectoid))
        return TrapError(IXP_E_RAS_INVALID_CONNECTOID);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Initialized
    if (NULL == m_pCallback)
    {
        hr = TrapError(IXP_E_NOT_INIT);
        goto exit;
    }

    // LoadRAS
    CHECKHR(hr = HrLoadRAS());

    // Save pInetServer
    CopyMemory(&m_rServer, pInetServer, sizeof(INETSERVER));

    // No Current Known Connection
    if (NULL == m_hConn)
    {
        // Get Current RAS Connection
        if (FEnumerateConnections(&prgConn, &cConn) && cConn > 0)
        {
            m_fConnOwner = FALSE;
            m_hConn = prgConn[0].hrasconn;
            StrCpyN(m_szConnectoid, prgConn[0].szEntryName, ARRAYSIZE(m_szConnectoid));
        }
    }

    // Otherwise, verify the connection status
    else
    {
        // Locals
        RASCONNSTATUS   rcs;

        // Get Connection Status
        rcs.dwSize = sizeof(RASCONNSTATUS);
        dwError = RasGetConnectStatus(m_hConn, &rcs);
        if (dwError || rcs.dwError || RASCS_Disconnected == rcs.rasconnstate)
        {
            m_fConnOwner = FALSE;
            m_hConn = NULL;
            *m_szConnectoid = '\0';
        }
    }

    // If RAS Connection present, is it equal to suggested
    if (m_hConn)
    {
        // Better have a connectoid
        Assert(*m_szConnectoid);

        // Current connection is what I want ?
        if (lstrcmpi(m_szConnectoid, m_rServer.szConnectoid) == 0)
        {
            m_pCallback->OnRasDialStatus(RASCS_Connected, 0, this);
            hr = IXP_S_RAS_USING_CURRENT;
            goto exit;
        }

        // Otherwise, if we didn't start the RAS connection...
        else if (FALSE == m_fConnOwner)
        {
            // Prompt to Close un-owner current connection...
            hr = m_pCallback->OnReconnect(m_szConnectoid, m_rServer.szConnectoid, this);

            // Cancel ?
            if (IXP_E_USER_CANCEL == hr)
                goto exit;

            // Use Current Connection...
            else if (S_FALSE == hr)
            {
                hr = IXP_S_RAS_USING_CURRENT;
                goto exit;
            }

            // Close Current ?
            else
            {
                FRasHangupAndWait(DEF_HANGUP_WAIT);
            }
        }

        // Otherwise, I started the connection, so close it
        else if (m_fConnOwner == TRUE)
        {
            FRasHangupAndWait(DEF_HANGUP_WAIT);
        }
    }

    // We probably shouldn't have a connection handle at this point
    Assert(m_hConn == NULL);

    // Dial the connection
    CHECKHR(hr = HrStartRasDial());

    // If Synchronous -- Woo - hoo were connected and we started the connection
    m_fConnOwner = TRUE;
    StrCpyN(m_szConnectoid, m_rServer.szConnectoid, ARRAYSIZE(m_szConnectoid));

exit:
    // Cleanup
    SafeMemFree(prgConn);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CRASTransport::HrStartRasDial
// --------------------------------------------------------------------------------
HRESULT CRASTransport::HrStartRasDial(void)
{
    // Locals
    HRESULT         hr=S_OK;
    BOOL            fRetry=FALSE;
    DWORD           dwError;

    // Prompt for while
    while(1)
    {
        // Logon first ?
        hr = HrLogon(fRetry);
        if (FAILED(hr))
            goto exit;

        // If Succeeded
#ifndef WIN16
        dwError = RasDial(NULL, NULL, &m_rDialParams, 0xFFFFFFFF, m_hwndRAS, &m_hConn);
#else
        dwError = RasDial(NULL, NULL, &m_rDialParams, 0xFFFFFFFF, (LPVOID)m_hwndRAS, &m_hConn);
#endif
        if (dwError == 0)
            break;

        // Lets feed the user the error
        m_pCallback->OnRasDialStatus(RASCS_Disconnected, dwError, this);

        // Retry Logon
        fRetry = TRUE;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CRASTransport::RASConnectDlgProc
// --------------------------------------------------------------------------------
INT_PTR CALLBACK CRASTransport::RASConnectDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Locals
    CRASTransport  *pTransport=(CRASTransport *)GetWndThisPtr(hwnd);
    
    switch (uMsg)
    {
    case WM_INITDIALOG:
        pTransport = (CRASTransport *)lParam;
        Assert(pTransport);
        SetWndThisPtr(hwnd, pTransport);
        return 0;

    case WM_DESTROY:
        SetWndThisPtr(hwnd, NULL);
        break;

    default:
        if (NULL != pTransport)
        {
            // Thread Safety
            EnterCriticalSection(&pTransport->m_cs);

            // Our Message
            if (NULL != pTransport->m_pCallback && uMsg == pTransport->m_uRASMsg)
            {
                // Handle Error
                if (lParam)
                {
                    // Hangup
                    if (pTransport->m_hConn)
                        pTransport->FRasHangupAndWait(DEF_HANGUP_WAIT);
                }

                // Give to callback
                pTransport->m_pCallback->OnRasDialStatus((RASCONNSTATE)wParam, (DWORD) lParam, pTransport);
            }

            // thread Safety
            LeaveCriticalSection(&pTransport->m_cs);
        }
    }

    // Done
    return 0;
}

// --------------------------------------------------------------------------------
// CRASTransport::HrLogon
// --------------------------------------------------------------------------------
HRESULT CRASTransport::HrLogon(BOOL fForcePrompt)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           dwRasError;
    BOOL            fSavePassword;

    // Do we need to prompt for logon information first ?
    ZeroMemory(&m_rDialParams, sizeof(RASDIALPARAMS));
    m_rDialParams.dwSize = sizeof(RASDIALPARAMS);
    Assert(sizeof(m_rDialParams.szEntryName) >= sizeof(m_rServer.szConnectoid));
    StrCpyN(m_rDialParams.szEntryName, m_rServer.szConnectoid, sizeof(m_rDialParams.szEntryName));

    // Get params
    dwRasError = RasGetEntryDialParams(NULL, &m_rDialParams, &fSavePassword);
    if (dwRasError)
    {
        hr = TrapError(IXP_E_RAS_GET_DIAL_PARAMS);
        goto exit;
    }

    // Do we need to get password / account information
    if (fForcePrompt   || 
        !fSavePassword || 
        FIsEmpty(m_rDialParams.szUserName) || 
        FIsEmpty(m_rDialParams.szPassword))
    {
        // Locals
        IXPRASLOGON rLogon;

        // Init
        ZeroMemory(&rLogon, sizeof(IXPRASLOGON));

        // Fill Logon Data...
        StrCpyN(rLogon.szConnectoid, m_rDialParams.szEntryName, ARRAYSIZE(rLogon.szConnectoid));
        StrCpyN(rLogon.szUserName, m_rDialParams.szUserName, ARRAYSIZE(rLogon.szUserName));
        StrCpyN(rLogon.szPassword, m_rDialParams.szPassword, ARRAYSIZE(rLogon.szPassword));
        StrCpyN(rLogon.szDomain, m_rDialParams.szDomain, ARRAYSIZE(rLogon.szDomain));
        StrCpyN(rLogon.szPhoneNumber, m_rDialParams.szPhoneNumber, ARRAYSIZE(rLogon.szPhoneNumber));
        rLogon.fSavePassword = fSavePassword;

        // Prompt
        hr = m_pCallback->OnLogonPrompt(&rLogon, this);

        // If OK, lets save the settings
        if (S_OK == hr)
        {
            // Copy parameters back
            StrCpyN(m_rDialParams.szUserName, rLogon.szUserName, ARRAYSIZE(m_rDialParams.szUserName));
            StrCpyN(m_rDialParams.szPassword, rLogon.szPassword, ARRAYSIZE(m_rDialParams.szPassword));
            StrCpyN(m_rDialParams.szDomain, rLogon.szDomain, ARRAYSIZE(m_rDialParams.szDomain));
            StrCpyN(m_rDialParams.szPhoneNumber, rLogon.szPhoneNumber, ARRAYSIZE(m_rDialParams.szPhoneNumber));

            // Save the dial params
            if (RasSetEntryDialParams(NULL, &m_rDialParams, !rLogon.fSavePassword))
            {
                Assert(FALSE);
                TrapError(E_FAIL);
            }
        }

        // RAID-26845 - RAS Transport: Canceling RAS Logon doesn't cancel
        else
        {
            hr = TrapError(IXP_E_USER_CANCEL);
            goto exit;
        }
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CRASTransport::DropConnection
// --------------------------------------------------------------------------------
STDMETHODIMP CRASTransport::DropConnection(void)
{
    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Hangup
    if (m_hConn)
        FRasHangupAndWait(DEF_HANGUP_WAIT);

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CRASTransport::Disconnect
// --------------------------------------------------------------------------------
STDMETHODIMP CRASTransport::Disconnect(void)
{
    // Locals
    HRESULT         hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // If not using RAS, who give a crap
    if (RAS_CONNECT_RAS != m_rServer.rasconntype)
    {
        Assert(m_hConn == NULL);
        Assert(m_fConnOwner == FALSE);
        goto exit;
    }

    // Do we have a RAS connection
    if (m_hConn)
    {
        if (m_pCallback->OnDisconnect(m_szConnectoid, (boolean) !!m_fConnOwner, this) == S_OK)
            FRasHangupAndWait(DEF_HANGUP_WAIT);
    }

    // Pretend the connection is owned by the user
    m_hConn = NULL;
    m_fConnOwner = FALSE;

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CRASTransport::IsState
// --------------------------------------------------------------------------------
STDMETHODIMP CRASTransport::IsState(IXPISSTATE isstate)
{
    // Locals
    HRESULT         hr=S_FALSE;

    // Thread Safety
	EnterCriticalSection(&m_cs);

    // Initialized
    if (NULL == m_pCallback)
    {
        hr = TrapError(IXP_E_NOT_INIT);
        goto exit;
    }                               

    // Lets validate m_hConn first
    if (NULL != m_hConn)
    {
        // Get Connection Status
        RASCONNSTATUS rcs;
        DWORD dwError;

        // Setup Structure Size
        rcs.dwSize = sizeof(RASCONNSTATUS);

        // Get Ras Connection Status
        dwError = RasGetConnectStatus(m_hConn, &rcs);
        
        // Failure or not connected
        if (dwError || rcs.dwError || RASCS_Disconnected == rcs.rasconnstate)
        {
            m_fConnOwner = FALSE;
            m_hConn = NULL;
            *m_szConnectoid = '\0';
        }
    }

    // Handle IsType
    switch(isstate)
    {
    // Are we connected
    case IXP_IS_CONNECTED:
        hr = (m_hConn) ? S_OK : S_FALSE;
        break;

    // Are we busy
    case IXP_IS_BUSY:
        if (NULL == m_hConn)
            hr = IXP_E_NOT_CONNECTED;
        else
            hr = S_FALSE;
        break;

    // Are we busy
    case IXP_IS_READY:
        if (NULL == m_hConn)
            hr = IXP_E_NOT_CONNECTED;
        else
            hr = S_OK;
        break;

    // Have we been authenticated yet
    case IXP_IS_AUTHENTICATED:
        if (NULL == m_hConn)
            hr = IXP_E_NOT_CONNECTED;
        else
            hr = S_OK;
        break;

    // Unhandled ixpistype
    default:
        IxpAssert(FALSE);
        break;
    }

exit:
    // Thread Safety
	LeaveCriticalSection(&m_cs);

    // Done
	return hr;
}

// --------------------------------------------------------------------------------
// CRASTransport::GetServerInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CRASTransport::GetServerInfo(LPINETSERVER pInetServer)
{
    // check params
    if (NULL == pInetServer)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Copy Server information
    CopyMemory(pInetServer, &m_rServer, sizeof(INETSERVER));

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CRASTransport::GetIXPType
// --------------------------------------------------------------------------------
STDMETHODIMP_(IXPTYPE) CRASTransport::GetIXPType(void)
{
    return IXP_RAS;
}

// --------------------------------------------------------------------------------
// CRASTransport::InetServerFromAccount
// --------------------------------------------------------------------------------
STDMETHODIMP CRASTransport::InetServerFromAccount(IImnAccount *pAccount, LPINETSERVER pInetServer)
{
    return E_NOTIMPL;
}

// --------------------------------------------------------------------------------
// CRASTransport::FEnumerateConnections
// --------------------------------------------------------------------------------
BOOL CRASTransport::FEnumerateConnections(LPRASCONN *pprgConn, ULONG *pcConn)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       dw, 
                dwSize;
    BOOL        fResult=FALSE;

    // Check Params
    Assert(pprgConn && pcConn);

    // Init
    *pprgConn = NULL;
    *pcConn = 0;

    // Sizeof my buffer
    dwSize = sizeof(RASCONN);

    // Allocate enough for 1 ras connection info object
    CHECKHR(hr = HrAlloc((LPVOID *)pprgConn, dwSize));

    // Buffer size
    (*pprgConn)->dwSize = dwSize;

    // Enumerate ras connections
    dw = RasEnumConnections(*pprgConn, &dwSize, pcConn);

    // Not enough memory ?
    if (dw == ERROR_BUFFER_TOO_SMALL)
    {
        // Reallocate
        CHECKHR(hr = HrRealloc((LPVOID *)pprgConn, dwSize));
        *pcConn = 0;
        (*pprgConn)->dwSize = sizeof(RASCONN);
        dw = RasEnumConnections(*pprgConn, &dwSize, pcConn);
    }

    // If still failed
    if (dw)
    {
        AssertSz(FALSE, "RasEnumConnections failed");
        goto exit;
    }

    // Success
    fResult = TRUE;

exit:
    // Done
    return fResult;
}

// --------------------------------------------------------------------------------
// CRASTransport::FFindConnection
// --------------------------------------------------------------------------------
BOOL CRASTransport::FFindConnection(LPSTR pszConnectoid, LPHRASCONN phConn)
{
    // Locals
    ULONG       cConn,
                i;
    LPRASCONN   prgConn=NULL;
    BOOL        fResult=FALSE;

    // Check Params
    Assert(pszConnectoid && phConn);

    // Init
    *phConn = NULL;

    // Enumerate Connections
    if (!FEnumerateConnections(&prgConn, &cConn))
        goto exit;

    // If still failed
    for (i=0; i<cConn; i++)
    {
        if (lstrcmpi(prgConn[i].szEntryName, pszConnectoid) == 0)
        {
            *phConn = prgConn[i].hrasconn;
            fResult = TRUE;
            goto exit;
        }
    }

exit:
    // Cleanup
    SafeMemFree(prgConn);

    // Done
    return fResult;
}

// --------------------------------------------------------------------------------
// CRASTransport::FRasHangupAndWait
// --------------------------------------------------------------------------------
BOOL CRASTransport::FRasHangupAndWait(DWORD dwMaxWaitSeconds)
{
    // Locals
    RASCONNSTATUS   rcs;
    DWORD           dwTicks=GetTickCount();

    // Check Params
    Assert(m_hConn);
    if (NULL == m_hConn || RasHangup(m_hConn))
    {
        m_hConn = NULL;
        m_fConnOwner = FALSE;
        *m_szConnectoid = '\0';
        return FALSE;
    }

    // Wait for connection to really close
    ZeroMemory(&rcs, sizeof(RASCONNSTATUS));
    rcs.dwSize = sizeof(RASCONNSTATUS);
    while (RasGetConnectStatus(m_hConn, &rcs) == 0 && rcs.rasconnstate != RASCS_Disconnected)
    {
        // Wait timeout
        if (GetTickCount() - dwTicks >= dwMaxWaitSeconds * 1000)
            break;

        // Sleep and yields
        Sleep(0);
    }

    // Wait 2 seconds for modem to reset
    Sleep(2000);

    // Reset
    m_hConn = NULL;
    m_fConnOwner = FALSE;
    *m_szConnectoid = '\0';

    // Done
    return TRUE;
}

// --------------------------------------------------------------------------------
// CRASTransport::FillConnectoidCombo
// --------------------------------------------------------------------------------
STDMETHODIMP CRASTransport::FillConnectoidCombo(HWND hwndComboBox, boolean fUpdateOnly, DWORD *pdwRASResult)
{
    // Locals
    HRESULT hr=S_OK;

    // check params
    if (NULL == hwndComboBox || FALSE == IsWindow(hwndComboBox))
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Call global function
    CHECKHR(hr = HrFillRasCombo(hwndComboBox, fUpdateOnly, pdwRASResult));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CRASTransport::EditConnectoid
// --------------------------------------------------------------------------------
STDMETHODIMP CRASTransport::EditConnectoid(HWND hwndParent, LPSTR pszConnectoid, DWORD *pdwRASResult)
{
    // Locals
    HRESULT         hr=S_OK;

    // check params
    if (NULL == pszConnectoid)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Call general function
    CHECKHR(hr = HrEditPhonebookEntry(hwndParent, pszConnectoid, pdwRASResult));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CRASTransport::GetRasErrorString
// --------------------------------------------------------------------------------
STDMETHODIMP CRASTransport::GetRasErrorString(UINT uRasErrorValue, LPSTR pszErrorString, ULONG cchMax, DWORD *pdwRASResult)
{
    // Locals
    HRESULT         hr=S_OK;

    // check params
    if (NULL == pdwRASResult || 0 == uRasErrorValue || NULL == pszErrorString || cchMax <= 1)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Make Sure RAS is Loaded
    CHECKHR(hr = HrLoadRAS());

    // Call RAS Function
    *pdwRASResult = RasGetErrorString(uRasErrorValue, pszErrorString, cchMax);
    if (*pdwRASResult)
    {
        hr = TrapError(IXP_E_RAS_ERROR);
        goto exit;
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CRASTransport::CreateConnectoid
// --------------------------------------------------------------------------------
STDMETHODIMP CRASTransport::CreateConnectoid(HWND hwndParent, DWORD *pdwRASResult)
{
    // Locals
    HRESULT         hr=S_OK;

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Call General Function
    CHECKHR(hr = HrCreatePhonebookEntry(hwndParent, pdwRASResult));

exit:
    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\ixpsmtp.h ===
// --------------------------------------------------------------------------------
// Ixpsmtp.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __IXPSMTP_H
#define __IXPSMTP_H

// ------------------------------------------------------------------------------------
// Depends
// ------------------------------------------------------------------------------------
#include "ixpbase.h"
#include "ixppop3.h"

// --------------------------------------------------------------------------------
// CSMTPTransport
// --------------------------------------------------------------------------------
class CSMTPTransport : public CIxpBase, public ISMTPTransport2
{
private:
    AUTHINFO            m_rAuth;            // Authorization Information
    SMTPCOMMAND         m_command;          // Current command being processed
    SMTPMESSAGE2        m_rMessage;         // Current Message
    ULONG               m_iAddress;         // Current RCPT/MAIL address in rAdressList::prgAddress
    ULONG               m_cRecipients;      // Number of recipients for current message
    DWORD               m_cbSent;           // SendDataStream current Number of bytes sent
    DWORD               m_cbTotal;          // SendDataStream total bytes
    BOOL                m_fSendMessage;     // Are we in the process of a ::SendMessage
    BOOL                m_fReset;           // Is a reset needed on next ::SendMessage Call
    CHAR                m_szEmail[255];     // The last sent email address using MAIL or RCPT
    BOOL                m_fSTARTTLSAvail;   // Is the STARTTLS command available on this server?
    BOOL                m_fTLSNegotiation;  // Are we in TLS negotiation?
    BOOL                m_fSecured;         // Is the connection secured?
    BOOL                m_fDSNAvail;        // Does the server support DSNs?

private:
    void OnSocketReceive(void);
    void SendMessage_DATA(void);
    void SendMessage_MAIL(void);
    void SendMessage_RCPT(void);
    void SendMessage_DONE(HRESULT hrResult, LPSTR pszProblem=NULL);
    HRESULT HrGetResponse(void);
    void DispatchResponse(HRESULT hrResult, BOOL fDone, LPSTR pszProblem=NULL);
    void SendStreamResponse(BOOL fDone, HRESULT hrResult, DWORD cbIncrement);
    HRESULT _HrFormatAddressString(LPCSTR pszEmail, LPCSTR pszExtra, LPSTR *ppszAddress);
    void OnEHLOResponse(LPCSTR pszResponse);
    void ResponseAUTH(HRESULT hrResponse);
    BOOL FSendSicilyString(LPSTR pszData);
    void CancelAuthInProg(void);
    void StartLogon(void);
    void LogonRetry(void);
    void TryNextAuthPackage(void);
    void DoLoginAuth(HRESULT hrResponse);
    void DoPackageAuth(HRESULT hrResponse);
    void DoAuthNegoResponse(HRESULT hrResponse);
    void OnAuthorized(void);
    void RetryPackage(void);
    void DoAuthRespResponse(HRESULT hrResponse);
    HRESULT _HrHELO_Or_EHLO(LPCSTR pszCommand, SMTPCOMMAND eNewCommand);
    LPSTR _PszGetCurrentAddress(void);
    HRESULT CommandSTARTTLS(void);
    void StartTLS(void);
    void TryNextSecurityPkg(void);

public:                          
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CSMTPTransport(void);
    ~CSMTPTransport(void);

    // ----------------------------------------------------------------------------
    // IUnknown methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IAsyncConnCB methods
    // ----------------------------------------------------------------------------
    void OnNotify(ASYNCSTATE asOld, ASYNCSTATE asNew, ASYNCEVENT ae);

    // ----------------------------------------------------------------------------
    // IInternetTransport methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP Connect(LPINETSERVER pInetServer, boolean fAuthenticate, boolean fCommandLogging);
    STDMETHODIMP DropConnection(void);
    STDMETHODIMP Disconnect(void);
    STDMETHODIMP IsState(IXPISSTATE isstate);
    STDMETHODIMP GetServerInfo(LPINETSERVER pInetServer);
    STDMETHODIMP_(IXPTYPE) GetIXPType(void);
    STDMETHODIMP InetServerFromAccount(IImnAccount *pAccount, LPINETSERVER pInetServer);
    STDMETHODIMP HandsOffCallback(void);
    STDMETHODIMP GetStatus(IXPSTATUS *pCurrentStatus);

    // ----------------------------------------------------------------------------
    // ISMTPTransport methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP InitNew(LPSTR pszLogFilePath, ISMTPCallback *pCallback);
    STDMETHODIMP SendMessage(LPSMTPMESSAGE pMessage);
    STDMETHODIMP FreeInetAddrList(LPINETADDRLIST pAddressList);
    STDMETHODIMP CommandAUTH(LPSTR pszAuthType);
    STDMETHODIMP CommandMAIL(LPSTR pszEmailFrom);
    STDMETHODIMP CommandRCPT(LPSTR pszEmailTo);
    STDMETHODIMP CommandEHLO(void);
    STDMETHODIMP CommandHELO(void);
    STDMETHODIMP CommandQUIT(void);
    STDMETHODIMP CommandRSET(void);
    STDMETHODIMP CommandDATA(void);
    STDMETHODIMP CommandDOT(void);
    STDMETHODIMP SendDataStream(IStream *pStream, ULONG cbSize);

    // ----------------------------------------------------------------------------
    // ISMTPTransport2 methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP SendMessage2(LPSMTPMESSAGE2 pMessage);
    STDMETHODIMP CommandRCPT2(LPSTR pszEmailTo, INETADDRTYPE atDSN);
    STDMETHODIMP SetWindow(void);
    STDMETHODIMP ResetWindow(void);

    // ----------------------------------------------------------------------------
    // CIxpBase methods
    // ----------------------------------------------------------------------------
    virtual void ResetBase(void);
    virtual void DoQuit(void);
    virtual void OnConnected(void);
    virtual void OnDisconnected(void);
    virtual void OnEnterBusy(void);
    virtual void OnLeaveBusy(void);
};

#endif // __IXPSMTP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\ixpras.h ===
// --------------------------------------------------------------------------------
// Ixpras.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __IXPRAS_H
#define __IXPRAS_H

// --------------------------------------------------------------------------------
// Dependencies
// --------------------------------------------------------------------------------
#include "imnxport.h"

// --------------------------------------------------------------------------------
// CRASTransport
// --------------------------------------------------------------------------------
class CRASTransport : public IRASTransport
{
private:
    ULONG               m_cRef;         // Reference counting
    CHAR                m_szConnectoid[CCHMAX_CONNECTOID]; // Current connectoid
    HRASCONN            m_hConn;        // Handle to current RAS Connection
    BOOL                m_fConnOwner;   // We own the current RAS connection
    IRASCallback       *m_pCallback;    // RAS callback interface
    INETSERVER          m_rServer;      // Server Information
    RASDIALPARAMS       m_rDialParams;  // Dialing information
    UINT                m_uRASMsg;      // RAS Message
    HWND                m_hwndRAS;      // RAS callback window
    CRITICAL_SECTION    m_cs;           // Thread Safety

private:
    BOOL    FRasHangupAndWait(DWORD dwMaxWaitSeconds);
    BOOL    FEnumerateConnections(LPRASCONN *pprgConn, ULONG *pcConn);
    BOOL    FFindConnection(LPSTR pszConnectoid, LPHRASCONN phConn);
    HRESULT HrLogon(BOOL fForcePrompt);
    HRESULT HrStartRasDial(void);

    static INT_PTR CALLBACK RASConnectDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CRASTransport(void);
    ~CRASTransport(void);

    // ----------------------------------------------------------------------------
    // IUnknown Methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IInternetTransport methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP Connect(LPINETSERVER pInetServer, boolean fAuthenticate, boolean fCommandLogging);
    STDMETHODIMP DropConnection(void);
    STDMETHODIMP Disconnect(void);
    STDMETHODIMP IsState(IXPISSTATE isstate);
    STDMETHODIMP GetServerInfo(LPINETSERVER pInetServer);
    STDMETHODIMP_(IXPTYPE) GetIXPType(void);
    STDMETHODIMP InetServerFromAccount(IImnAccount *pAccount, LPINETSERVER pInetServer);
    STDMETHODIMP HandsOffCallback(void);
    STDMETHODIMP GetStatus(IXPSTATUS *pCurrentStatus) {return E_NOTIMPL;};

    // ----------------------------------------------------------------------------
    // IRASTransport methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP InitNew(IRASCallback *pCallback);
    STDMETHODIMP GetRasErrorString(UINT uRasErrorValue, LPSTR pszErrorString, ULONG cchMax, DWORD *pdwRASResult);
    STDMETHODIMP FillConnectoidCombo(HWND hwndComboBox, boolean fUpdateOnly, DWORD *pdwRASResult);
    STDMETHODIMP EditConnectoid(HWND hwndParent, LPSTR pszConnectoid, DWORD *pdwRASResult);
    STDMETHODIMP CreateConnectoid(HWND hwndParent, DWORD *pdwRASResult);
    STDMETHODIMP GetCurrentConnectoid(LPSTR pszConnectoid, ULONG cchMax);
};

#endif // __IXPRAS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\ixpsmtp.cpp ===
// --------------------------------------------------------------------------------
// Ixpsmtp.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "asynconn.h"
#include "ixpsmtp.h"
#include "ixputil.h"  
#include "strconst.h"
#include <shlwapi.h>
#include <demand.h>

// --------------------------------------------------------------------------------
// Useful C++ pointer casting
// --------------------------------------------------------------------------------
#define SMTPTHISIXP         ((ISMTPTransport *)(CIxpBase *)this)

// --------------------------------------------------------------------------------
// Some string constants
// --------------------------------------------------------------------------------

// These constants are from the draft spec for SMTP authenication
// draft-myers-smtp-auth-11.txt
static const char   g_szSMTPAUTH11[]    = "AUTH ";
static const int    g_cchSMTPAUTH11     = sizeof(g_szSMTPAUTH11) - 1;

// These constants are from the draft spec for SMTP authenication
// draft-myers-smtp-auth-10.txt
static const char   g_szSMTPAUTH10[]    = "AUTH=";
static const int    g_cchSMTPAUTH10     = sizeof(g_szSMTPAUTH10) - 1;

// These constants are from the draft spec for Secure SMTP over TLS
// draft-hoffman-smtp-ssl-08.txt
static const char   g_szSMTPSTARTTLS08[]    = "STARTTLS";
static const int    g_cchSMTPSTARTTLS08     = sizeof(g_szSMTPSTARTTLS08) - 1;

// These constants are from the draft spec for Secure SMTP over TLS
// draft-hoffman-smtp-ssl-06.txt
static const char   g_szSMTPSTARTTLS06[]    = "TLS";
static const int    g_cchSMTPSTARTTLS06     = sizeof(g_szSMTPSTARTTLS06) - 1;

// These constants are from RFC1891 for DSN support
static const char   g_szSMTPDSN[]  = "DSN";
static const int    g_cchSMTPDSN   = sizeof(g_szSMTPDSN) - 1;

static const char g_szDSNENVID[]   = "ENVID=";

static const char g_szDSNRET[]     = "RET=";

static const char g_szDSNHDRS[]    = "HDRS";
static const char g_szDSNFULL[]    = "FULL";

static const char g_szDSNNOTIFY[]  = "NOTIFY=";

static const char g_szDSNNEVER[]   = "NEVER";
static const char g_szDSNSUCCESS[] = "SUCCESS";
static const char g_szDSNFAILURE[] = "FAILURE";
static const char g_szDSNDELAY[]   = "DELAY";


// --------------------------------------------------------------------------------
// CSMTPTransport::CSMTPTransport
// --------------------------------------------------------------------------------
CSMTPTransport::CSMTPTransport(void) : CIxpBase(IXP_SMTP)
{
    DllAddRef();
    m_command = SMTP_NONE;
    m_iAddress = 0;
    m_cRecipients = 0;
    m_cbSent = 0;
    m_cbTotal = 0;
    m_fReset = FALSE;
    m_fSendMessage = FALSE;
    m_fSTARTTLSAvail = FALSE;
    m_fTLSNegotiation = FALSE;
    m_fSecured = FALSE;
    *m_szEmail = '\0';
    m_pszResponse = NULL;
    ZeroMemory(&m_rAuth, sizeof(m_rAuth));
    ZeroMemory(&m_rMessage, sizeof(SMTPMESSAGE2));
    m_fDSNAvail= FALSE;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::~CSMTPTransport
// --------------------------------------------------------------------------------
CSMTPTransport::~CSMTPTransport(void)
{
    ResetBase();
    DllRelease();
}

// --------------------------------------------------------------------------------
// CSMTPTransport::ResetBase
// --------------------------------------------------------------------------------
void CSMTPTransport::ResetBase(void)
{
    EnterCriticalSection(&m_cs);
    FreeAuthInfo(&m_rAuth);
    m_command = SMTP_NONE;
    m_fSendMessage = FALSE;
    m_iAddress = 0;
    m_cRecipients = 0;
    m_cbSent = 0;
    m_fSTARTTLSAvail = FALSE;
    m_fTLSNegotiation = FALSE;
    m_fSecured = FALSE;
    SafeRelease(m_rMessage.smtpMsg.pstmMsg);
    SafeMemFree(m_rMessage.smtpMsg.rAddressList.prgAddress);
    SafeMemFree(m_rMessage.pszDSNENVID);
    ZeroMemory(&m_rMessage, sizeof(SMTPMESSAGE2));
    m_fDSNAvail= FALSE;
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CSMTPTransport::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // Bad param
    if (ppv == NULL)
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // Init
    *ppv=NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = ((IUnknown *)(ISMTPTransport2 *)this);

    // IID_IInternetTransport
    else if (IID_IInternetTransport == riid)
        *ppv = ((IInternetTransport *)(CIxpBase *)this);

    // IID_ISMTPTransport
    else if (IID_ISMTPTransport == riid)
        *ppv = (ISMTPTransport *)this;

    // IID_ISMTPTransport2
    else if (IID_ISMTPTransport2 == riid)
        *ppv = (ISMTPTransport2 *)this;

    // If not null, addref it and return
    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    // No Interface
    hr = TrapError(E_NOINTERFACE);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSMTPTransport::AddRef(void) 
{
	return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSMTPTransport::Release(void) 
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::HandsOffCallback
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::HandsOffCallback(void)
{
    return CIxpBase::HandsOffCallback();
}

// --------------------------------------------------------------------------------
// CSMTPTransport::GetStatus
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::GetStatus(IXPSTATUS *pCurrentStatus)
{
    return CIxpBase::GetStatus(pCurrentStatus);
}

// --------------------------------------------------------------------------------
// CSMTPTransport::InitNew
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::InitNew(LPSTR pszLogFilePath, ISMTPCallback *pCallback)
{
    return CIxpBase::OnInitNew("SMTP", pszLogFilePath, FILE_SHARE_READ | FILE_SHARE_WRITE,
        (ITransportCallback *)pCallback);
}

// --------------------------------------------------------------------------------
// CSMTPTransport::InetServerFromAccount
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::InetServerFromAccount(IImnAccount *pAccount, LPINETSERVER pInetServer)
{
    return CIxpBase::InetServerFromAccount(pAccount, pInetServer);
}

// --------------------------------------------------------------------------------
// CSMTPTransport::Connect
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::Connect(LPINETSERVER pInetServer, boolean fAuthenticate, boolean fCommandLogging)
{
    // Check if user wants us to always prompt for password. Prompt before we connect
    // to avoid inactivity disconnections
    if (ISFLAGSET(pInetServer->dwFlags, ISF_ALWAYSPROMPTFORPASSWORD))
    {
        HRESULT hr;

        if (NULL != m_pCallback)
            hr = m_pCallback->OnLogonPrompt(pInetServer, SMTPTHISIXP);

        if (NULL == m_pCallback || S_OK != hr)
            return IXP_E_USER_CANCEL;
    }

    return CIxpBase::Connect(pInetServer, fAuthenticate, fCommandLogging);
}

// --------------------------------------------------------------------------------
// CSMTPTransport::DropConnection
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::DropConnection(void)
{
    return CIxpBase::DropConnection();
}

// --------------------------------------------------------------------------------
// CSMTPTransport::Disconnect
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::Disconnect(void)
{
    return CIxpBase::Disconnect();
}

// --------------------------------------------------------------------------------
// CSMTPTransport::IsState
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::IsState(IXPISSTATE isstate)
{
    return CIxpBase::IsState(isstate);
}

// --------------------------------------------------------------------------------
// CSMTPTransport::GetServerInfo
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::GetServerInfo(LPINETSERVER pInetServer)
{
    return CIxpBase::GetServerInfo(pInetServer);
}

// --------------------------------------------------------------------------------
// CSMTPTransport::GetIXPType
// --------------------------------------------------------------------------------
STDMETHODIMP_(IXPTYPE) CSMTPTransport::GetIXPType(void)
{
    return CIxpBase::GetIXPType();
}

// --------------------------------------------------------------------------------
// CSMTPTransport::SendMessage
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::SendMessage(LPSMTPMESSAGE pMessage)
{
	SMTPMESSAGE2 pMessage2= {0};

	pMessage2.smtpMsg= *pMessage;
	return SendMessage2(&pMessage2);
}

// --------------------------------------------------------------------------------
// CSMTPTransport::SendMessage2
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::SendMessage2(LPSMTPMESSAGE2 pMessage)
{
    // Locals
    HRESULT         hr=S_OK;
    BOOL            fDSNAvail= FALSE;

    // check params
    if (NULL == pMessage || NULL == pMessage->smtpMsg.pstmMsg)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

	// Enter Busy
    CHECKHR(hr = HrEnterBusy());

    // Zero Init Current State
    fDSNAvail = m_fDSNAvail; // save DSN state!
    ResetBase();
    m_fDSNAvail = fDSNAvail;

    // Special State in this transport
    m_fSendMessage = TRUE;

    // Copy Mesage
    m_rMessage.smtpMsg.pstmMsg = pMessage->smtpMsg.pstmMsg;
    m_rMessage.smtpMsg.pstmMsg->AddRef();

    // Copy the Address List
    m_rMessage.smtpMsg.rAddressList.cAddress = pMessage->smtpMsg.rAddressList.cAddress;
    CHECKHR(hr = HrAlloc((LPVOID *)&m_rMessage.smtpMsg.rAddressList.prgAddress, sizeof(INETADDR) *  m_rMessage.smtpMsg.rAddressList.cAddress));
    CopyMemory(m_rMessage.smtpMsg.rAddressList.prgAddress, pMessage->smtpMsg.rAddressList.prgAddress, sizeof(INETADDR) *  m_rMessage.smtpMsg.rAddressList.cAddress);

    // Copy the message Size
    m_rMessage.smtpMsg.cbSize = pMessage->smtpMsg.cbSize;

    // Copy DSN data
    if(pMessage->pszDSNENVID)
    {
    	// ENVID max length is 100 characters
    	ULONG cbAlloc= max(lstrlen(pMessage->pszDSNENVID) + 1, 101);
    	CHECKALLOC(m_rMessage.pszDSNENVID = (LPSTR)g_pMalloc->Alloc(cbAlloc));
        StrCpyN(m_rMessage.pszDSNENVID, pMessage->pszDSNENVID, cbAlloc);
    }
    m_rMessage.dsnRet = pMessage->dsnRet;

    // Send RSET command (this initiates a send)
    if (m_fReset)
    {
        // Send the RSET command
        CHECKHR(hr = CommandRSET());
    }

    // Otherwise, start sending this message
    else
    {
        // Start sending this message
        SendMessage_MAIL();

        // A reset will be needed
        m_fReset = TRUE;
    }

    // return warning if client requested DSN but it isn't available
    if((m_rServer.dwFlags & ISF_QUERYDSNSUPPORT) && !m_fDSNAvail)
    	hr= IXP_S_SMTP_NO_DSN_SUPPORT;

exit:
    // Failure
    if (FAILED(hr))
    {
        ResetBase();
        LeaveBusy();
    }

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}


// --------------------------------------------------------------------------------
// CSMTPTransport::OnNotify
// --------------------------------------------------------------------------------
void CSMTPTransport::OnNotify(ASYNCSTATE asOld, ASYNCSTATE asNew, ASYNCEVENT ae)
{
    // Enter Critical Section
    EnterCriticalSection(&m_cs);

    switch(ae)
    {
    // --------------------------------------------------------------------------------
    case AE_RECV:
        OnSocketReceive();
        break;

    // --------------------------------------------------------------------------------
    case AE_SENDDONE:
        if (SMTP_SEND_STREAM == m_command)
        {
            // Leave Busy State
            LeaveBusy();

            // Send Dot Command
            HRESULT hr = CommandDOT();

            // Failure Causes Send Stream Response to finish
            if (FAILED(hr))
                SendStreamResponse(TRUE, hr, 0);
        }
        break;

    // --------------------------------------------------------------------------------
    case AE_WRITE:
        if (SMTP_DOT == m_command || SMTP_SEND_STREAM == m_command)
            SendStreamResponse(FALSE, S_OK, m_pSocket->UlGetSendByteCount());
        break;

    // --------------------------------------------------------------------------------
    default:
        CIxpBase::OnNotify(asOld, asNew, ae);
        break;
    }

    // Leave Critical Section
    LeaveCriticalSection(&m_cs);
}

// --------------------------------------------------------------------------------
// CSMTPTransport::OnEnterBusy
// --------------------------------------------------------------------------------
void CSMTPTransport::OnEnterBusy(void)
{
    IxpAssert(m_command == SMTP_NONE);
}

// --------------------------------------------------------------------------------
// CSMTPTransport::OnLeaveBusy
// --------------------------------------------------------------------------------
void CSMTPTransport::OnLeaveBusy(void)
{
    m_command = SMTP_NONE;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::OnConnected
// --------------------------------------------------------------------------------
void CSMTPTransport::OnConnected(void)
{
    if (FALSE == m_fTLSNegotiation)
    {
        m_command = SMTP_BANNER;
        CIxpBase::OnConnected();
    }
    else
    {
        HRESULT hr = S_OK;
        
        CIxpBase::OnConnected();
        
        // Clear out the TLS state
        m_fSecured = TRUE;

        // Clear out info from the banner
        m_fSTARTTLSAvail = FALSE;
        FreeAuthInfo(&m_rAuth);
        
        // Performing auth
        if (m_fConnectAuth)
        {
            // If we aren't doing sicily authenication or querying DSN
            // then just send a HELO message
            if ((FALSE == m_rServer.fTrySicily) && 
                        (0 == (m_rServer.dwFlags & ISF_QUERYAUTHSUPPORT)) &&
                        (0 == (m_rServer.dwFlags & ISF_QUERYDSNSUPPORT)))
            {
                // Issue HELO
                hr = CommandHELO();
                if (FAILED(hr))
                {
                    OnError(hr);
                    DropConnection();
                }
            }

            else
            {
                // Issue EHLO
                hr = CommandEHLO();
                if (FAILED(hr))
                {
                    OnError(hr);
                    DropConnection();
                }
            }

            // We've finished doing negotiation
            m_fTLSNegotiation = FALSE;
        }

        // Otherwise, were connected, user can send HELO command
        else
        {
            m_command = SMTP_CONNECTED;
            DispatchResponse(S_OK, TRUE);
        }

        // Were not authenticated yet
        m_fAuthenticated = FALSE;
    }
    
    return;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::OnDisconnect
// --------------------------------------------------------------------------------
void CSMTPTransport::OnDisconnected(void)
{
    ResetBase();
    m_fReset = FALSE;
    CIxpBase::OnDisconnected();
}

// --------------------------------------------------------------------------------
// CSMTPTransport::OnSocketReceive
// --------------------------------------------------------------------------------
void CSMTPTransport::OnSocketReceive(void)
{
    // Locals
    HRESULT hr=S_OK;

    // Enter Critical Section
    EnterCriticalSection(&m_cs);

    // Read Server Response...
    hr = HrGetResponse();
    if (IXP_E_INCOMPLETE == hr)
        goto exit;

    // Handle smtp state
    switch(m_command)
    {
    // --------------------------------------------------------------------------------
    case SMTP_BANNER:
        // Dispatch the Response
        DispatchResponse(hr, TRUE);

        // Failure, were done
        if (SUCCEEDED(hr))
        {
            // Performing auth
            if (m_fConnectAuth)
            {
                // If we aren't doing sicily authenication or
                // SSL security via STARTTLS or querying for DSN then just send a HELO message
                if ((FALSE == m_rServer.fTrySicily) && 
                            (0 == (m_rServer.dwFlags & ISF_QUERYAUTHSUPPORT)) &&
                            (FALSE == m_fConnectTLS) &&
                            (0 == (m_rServer.dwFlags & ISF_QUERYDSNSUPPORT)))
                {
                    // Issue HELO
                    hr = CommandHELO();
                    if (FAILED(hr))
                    {
                        OnError(hr);
                        DropConnection();
                    }
                }

                else
                {
                    // Issue EHLO
                    hr = CommandEHLO();
                    if (FAILED(hr))
                    {
                        OnError(hr);
                        DropConnection();
                    }
                }
            }

            // Otherwise, were connected, user can send HELO command
            else
            {
                m_command = SMTP_CONNECTED;
                DispatchResponse(S_OK, TRUE);
            }

            // Were not authenticated yet
            m_fAuthenticated = FALSE;
        }

        // Done
        break;

    // --------------------------------------------------------------------------------
    case SMTP_HELO:
        // Dispatch the Response
        DispatchResponse(hr, TRUE);

        // Failure, were done
        if (SUCCEEDED(hr))
        {
            // Were performing AUTH
            if (m_fConnectAuth)
            {
                // Were authenticated
                m_fAuthenticated = TRUE;

                // Authorized
                OnAuthorized();
            }
        }
        break;

    // --------------------------------------------------------------------------------
    case SMTP_EHLO:
        // Are we just trying to negotiate a SSL connection
        
        // EHLO Response
        if (FALSE == m_fTLSNegotiation)
        {
            OnEHLOResponse(m_pszResponse);
        }

        // Failure, were done
        if (m_fConnectAuth)
        {
            // Do we need to do STARTTLS?
            if ((FALSE != m_fConnectTLS) && (FALSE == m_fSecured))
            {
                if (SUCCEEDED(hr))
                {
                    if (FALSE == m_fTLSNegotiation)
                    {
                        // Start TLS negotiation
                        StartTLS();
                    }
                    else
                    {
                        TryNextSecurityPkg();
                    }
                }
                else
                {
                    OnError(hr);
                    DropConnection();
                }
            }
            else
            {
                // Dispatch Response, always success...
                DispatchResponse(S_OK, TRUE);

                // Success ?
                if (SUCCEEDED(hr))
                {
                    // No Auth Tokens, just try normal authentication
                    if (m_rAuth.cAuthToken <= 0)
                    {
                        // Were authenticated
                        m_fAuthenticated = TRUE;

                        // Authorized
                        OnAuthorized();
                    }

                    // Otherwise, start sasl
                    else
                    {
                        // StartLogon
                        StartLogon();
                    }
                }

                // Otherwise, just try the HELO command
                else
                {
                    // Issue HELO
                    hr = CommandHELO();
                    if (FAILED(hr))
                    {
                        OnError(hr);
                        DropConnection();
                    }
                }
            }
        }
        // Otherwise, just dispatch the Response           
        else
            DispatchResponse(hr, TRUE);
        break;

    // --------------------------------------------------------------------------------
    case SMTP_AUTH:
        Assert(m_rAuth.authstate != AUTH_ENUMPACKS_DATA)

        // Authenticating
        if (m_fConnectAuth)
            ResponseAUTH(hr);
        else
            DispatchResponse(hr, TRUE);
        break;        

    // --------------------------------------------------------------------------------
    case SMTP_RSET:
        // Dispatch the Response
        if (FALSE == m_fConnectAuth)
            DispatchResponse(hr, TRUE);

        // Failure, were done
        if (SUCCEEDED(hr))
        {
            // If sending message, start it...
            if (m_fSendMessage)
                SendMessage_MAIL();
        }
        break;

    // --------------------------------------------------------------------------------
    case SMTP_MAIL:
        // Dispatch the Response
        DispatchResponse(hr, TRUE);
        if (SUCCEEDED(hr))
        {
            // Doing a Send Message..
            if (m_fSendMessage)
                SendMessage_RCPT();
        }
        break;

    // --------------------------------------------------------------------------------
    case SMTP_RCPT:
        // Dispatch the Response
        DispatchResponse(hr, TRUE);
        if (SUCCEEDED(hr))
        {
            // Doing a Send Message..
            if (m_fSendMessage)
                SendMessage_RCPT();
        }
        break;

    // --------------------------------------------------------------------------------
    case SMTP_DATA:
        // Dispatch the Response
        DispatchResponse(hr, TRUE);
        if (SUCCEEDED(hr))
        {
            // Doing a Send Message..
            if (m_fSendMessage)
            {
                // Send the data stream
                hr = SendDataStream(m_rMessage.smtpMsg.pstmMsg, m_rMessage.smtpMsg.cbSize);
                if (FAILED(hr))
                {
                    SendMessage_DONE(hr);
                }
            }
        }
        break;

    // --------------------------------------------------------------------------------
    case SMTP_DOT:
        // Dispatch the response
        DispatchResponse(hr, TRUE);
        if (SUCCEEDED(hr))
        {
            // If doing a send message
            if (m_fSendMessage)
                SendMessage_DONE(S_OK);
        }
        break;        

    // --------------------------------------------------------------------------------
    case SMTP_QUIT:
        // Doing a Send Message..were not done until disconnected.
        DispatchResponse(hr, FALSE);
        m_pSocket->Close();
        break;
    }

exit:
    // Enter Critical Section
    LeaveCriticalSection(&m_cs);
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::SendMessage_DONE
// ------------------------------------------------------------------------------------
void CSMTPTransport::SendMessage_DONE(HRESULT hrResult, LPSTR pszProblem)
{
    m_command = SMTP_SEND_MESSAGE;
    m_fSendMessage = FALSE;
    m_fReset = TRUE;
    SafeRelease(m_rMessage.smtpMsg.pstmMsg);
    DispatchResponse(hrResult, TRUE, pszProblem);
    SafeMemFree(m_rMessage.smtpMsg.rAddressList.prgAddress);
    SafeMemFree(m_rMessage.pszDSNENVID);
    ZeroMemory(&m_rMessage, sizeof(m_rMessage));
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::OnEHLOResponse
// ------------------------------------------------------------------------------------
void CSMTPTransport::OnEHLOResponse(LPCSTR pszResponse)
{
    // Do we have anything to do?
    if (NULL == pszResponse || FALSE != m_fTLSNegotiation)
        goto exit;

    // DSN support?
    if (m_rServer.dwFlags & ISF_QUERYDSNSUPPORT)
    {
        if (0 == StrCmpNI(pszResponse + 4, g_szSMTPDSN, g_cchSMTPDSN))
        {
            m_fDSNAvail = TRUE;
        }

    }

    // Searching for: 250 STARTTLS
    if (TRUE == m_fConnectTLS)
    {
        if (0 == StrCmpNI(pszResponse + 4, g_szSMTPSTARTTLS08, g_cchSMTPSTARTTLS08))
        {
            m_fSTARTTLSAvail = TRUE;
        }
    }

    // Searching for: 250 AUTH=LOGIN NTLM or 250 AUTH LOGIN NTLM
    if ((FALSE != m_rServer.fTrySicily) || (0 != (m_rServer.dwFlags & ISF_QUERYAUTHSUPPORT)))
    {
        if ((0 == StrCmpNI(pszResponse + 4, g_szSMTPAUTH11, g_cchSMTPAUTH11)) || 
                (0 == StrCmpNI(pszResponse + 4, g_szSMTPAUTH10, g_cchSMTPAUTH10)))
        {
            // If we haven't read the tokens yet...
            if (0 == m_rAuth.cAuthToken)
            {
                // Locals
                CStringParser cString;
                CHAR chToken;

                // State Check
                Assert(m_rAuth.cAuthToken == 0);

                // Set the Members
                cString.Init(pszResponse + 9, lstrlen(pszResponse + 9), PSF_NOTRAILWS | PSF_NOFRONTWS);

                // Parse tokens
                while(1)
                {
                    // Set Parse Tokens
                    chToken = cString.ChParse(" ");
                    if (0 == cString.CchValue())
                        break;
                
                    // Can't take any more
                    if (m_rAuth.cAuthToken == MAX_AUTH_TOKENS)
                    {
                        Assert(FALSE);
                        break;
                    }

                    // Store the auth type
                    m_rAuth.rgpszAuthTokens[m_rAuth.cAuthToken] = PszDupA(cString.PszValue());
                    if (m_rAuth.rgpszAuthTokens[m_rAuth.cAuthToken])
                        m_rAuth.cAuthToken++;
                }
            }
        }
    }

exit:
    return;
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::_PszGetCurrentAddress
// ------------------------------------------------------------------------------------
LPSTR CSMTPTransport::_PszGetCurrentAddress(void)
{
    return (*m_szEmail == '\0') ? NULL : m_szEmail;
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::DispatchResponse
// ------------------------------------------------------------------------------------
void CSMTPTransport::DispatchResponse(HRESULT hrResult, BOOL fDone, LPSTR pszProblem)
{
    // Locals
    SMTPRESPONSE rResponse;

    // If not in SendMessage
    if (FALSE == m_fSendMessage)
    {
        // Clear the Response
        ZeroMemory(&rResponse, sizeof(SMTPRESPONSE));

        // Set the HRESULT
        rResponse.command = m_command;
        rResponse.fDone = fDone;
        rResponse.rIxpResult.pszResponse = m_pszResponse;
        rResponse.rIxpResult.hrResult = hrResult;
        rResponse.rIxpResult.uiServerError = m_uiResponse;
        rResponse.rIxpResult.hrServerError = m_hrResponse;
        rResponse.rIxpResult.dwSocketError = m_pSocket->GetLastError();
        rResponse.rIxpResult.pszProblem = NULL;
        rResponse.pTransport = this;

        // Map HRESULT and set problem...
        if (FAILED(hrResult))
        {
            // Handle Rejected Sender
            if (SMTP_MAIL == m_command)
            {
                rResponse.rIxpResult.hrResult = IXP_E_SMTP_REJECTED_SENDER;
                rResponse.rIxpResult.pszProblem = _PszGetCurrentAddress();
            }

            // Handle Rejected Recipient
            else if (SMTP_RCPT == m_command)
            {
                rResponse.rIxpResult.hrResult = IXP_E_SMTP_REJECTED_RECIPIENTS;
                rResponse.rIxpResult.pszProblem = _PszGetCurrentAddress();
            }
        }

        // Finished...
        if (fDone)
        {
            // No current command
            m_command = SMTP_NONE;

            // Leave Busy State
            LeaveBusy();
        }

        // Give the Response to the client
        if (m_pCallback)
            ((ISMTPCallback *)m_pCallback)->OnResponse(&rResponse);

        // Reset Last Response
        SafeMemFree(m_pszResponse);
        m_hrResponse = S_OK;
        m_uiResponse = 0;
    }

    // Otherwise, if FAILED
    else if (FAILED(hrResult))
    {
        // Handle Rejected Sender
        if (SMTP_MAIL == m_command)
            SendMessage_DONE(IXP_E_SMTP_REJECTED_SENDER, _PszGetCurrentAddress());

        // Handle Rejected Recipient
        else if (SMTP_RCPT == m_command)
            SendMessage_DONE(IXP_E_SMTP_REJECTED_RECIPIENTS, _PszGetCurrentAddress());

        // General Failure
        else
            SendMessage_DONE(hrResult);
    }
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::HrGetResponse
// ------------------------------------------------------------------------------------
HRESULT CSMTPTransport::HrGetResponse(void)
{
    // Locals
    HRESULT     hr = S_OK;
    INT         cbLine = 0;
    BOOL        fKnownResponse = TRUE;
    BOOL        fComplete = FALSE;
    BOOL        fMoreLinesNeeded = FALSE;

    // Clear current response
    IxpAssert(m_pszResponse == NULL && m_hrResponse == S_OK);

    // We received a line from the host $$ERROR$$ - How do I know if there are more lines
    while(1)
    {
        // Read the line
        IxpAssert(m_pszResponse == NULL);
        hr = HrReadLine(&m_pszResponse, &cbLine, &fComplete);
        if (FAILED(hr))
        {
            hr = TRAPHR(IXP_E_SOCKET_READ_ERROR);
            goto exit;
        }

        // Not complete
        if (!fComplete)
        {
            if (FALSE != fMoreLinesNeeded)
            {
                hr = IXP_E_INCOMPLETE;
            }
            
            goto exit;
        }

        // Parse the response code
        if ((cbLine < 3) || (m_pszResponse == NULL) ||
            (m_pszResponse[0] < '0' || m_pszResponse[0] > '9') ||
            (m_pszResponse[1] < '0' || m_pszResponse[1] > '9') ||
            (m_pszResponse[2] < '0' || m_pszResponse[2] > '9'))
        {
            hr = TrapError(IXP_E_SMTP_RESPONSE_ERROR);
            if (m_pCallback && m_fCommandLogging)
                m_pCallback->OnCommand(CMD_RESP, m_pszResponse, hr, SMTPTHISIXP);
            goto exit;
        }

        // Ignores continuation lines for now
        if ((cbLine >= 4) && (m_pszResponse[3] == '-'))
        {
            // Locals
            SMTPRESPONSE rResponse;

            // General command
            if (m_pCallback && m_fCommandLogging)
                m_pCallback->OnCommand(CMD_RESP, m_pszResponse, IXP_S_SMTP_CONTINUE, SMTPTHISIXP);

            // Clear the Response
            ZeroMemory(&rResponse, sizeof(SMTPRESPONSE));

            // Set the HRESULT
            rResponse.command = m_command;
            rResponse.fDone = FALSE;
            rResponse.rIxpResult.pszResponse = m_pszResponse;
            rResponse.rIxpResult.hrResult = IXP_S_SMTP_CONTINUE;
            rResponse.rIxpResult.uiServerError = 0;
            rResponse.rIxpResult.hrServerError = S_OK;
            rResponse.rIxpResult.dwSocketError = 0;
            rResponse.rIxpResult.pszProblem = NULL;
            rResponse.pTransport = this;

            // Give the Response to the client
            if (m_pCallback)
                ((ISMTPCallback *)m_pCallback)->OnResponse(&rResponse);

            // EHLO Response
            if (SMTP_EHLO == m_command)
                OnEHLOResponse(m_pszResponse);

            // Reset Last Response
            SafeMemFree(m_pszResponse);
            m_hrResponse = S_OK;
            m_uiResponse = 0;

            // We still need to get more lines from the server
            fMoreLinesNeeded = TRUE;
            
            // Continue
            continue;
        }

        // Not a valid SMTP response line.
        if ((cbLine >= 4) && (m_pszResponse[3] != ' '))
        {
            hr = TrapError(IXP_E_SMTP_RESPONSE_ERROR);
            if (m_pCallback && m_fCommandLogging)
                m_pCallback->OnCommand(CMD_RESP, m_pszResponse, hr, SMTPTHISIXP);
            goto exit;
        }

        // Done
        break;
    }

    // Compute Actual Response code
    m_uiResponse = (m_pszResponse[0] - '0') * 100 +
                   (m_pszResponse[1] - '0') * 10  +
                   (m_pszResponse[2] - '0');

    // Assume it is not recognized
    switch(m_uiResponse)
    {
    case 500: hr = IXP_E_SMTP_500_SYNTAX_ERROR;             break;
    case 501: hr = IXP_E_SMTP_501_PARAM_SYNTAX;             break;
    case 502: hr = IXP_E_SMTP_502_COMMAND_NOTIMPL;          break;
    case 503: hr = IXP_E_SMTP_503_COMMAND_SEQ;              break;
    case 504: hr = IXP_E_SMTP_504_COMMAND_PARAM_NOTIMPL;    break;
    case 421: hr = IXP_E_SMTP_421_NOT_AVAILABLE;            break;
    case 450: hr = IXP_E_SMTP_450_MAILBOX_BUSY;             break;
    case 550: hr = IXP_E_SMTP_550_MAILBOX_NOT_FOUND;        break;
    case 451: hr = IXP_E_SMTP_451_ERROR_PROCESSING;         break;
    case 551: hr = IXP_E_SMTP_551_USER_NOT_LOCAL;           break;
    case 452: hr = IXP_E_SMTP_452_NO_SYSTEM_STORAGE;        break;
    case 552: hr = IXP_E_SMTP_552_STORAGE_OVERFLOW;         break;
    case 553: hr = IXP_E_SMTP_553_MAILBOX_NAME_SYNTAX;      break;
    case 554: hr = IXP_E_SMTP_554_TRANSACT_FAILED;          break;
    case 211: hr = IXP_S_SMTP_211_SYSTEM_STATUS;            break;
    case 214: hr = IXP_S_SMTP_214_HELP_MESSAGE;             break;
    case 220: hr = IXP_S_SMTP_220_READY;                    break;
    case 221: hr = IXP_S_SMTP_221_CLOSING;                  break;
    case 250: hr = IXP_S_SMTP_250_MAIL_ACTION_OKAY;         break;
    case 251: hr = IXP_S_SMTP_251_FORWARDING_MAIL;          break;
    case 354: hr = IXP_S_SMTP_354_START_MAIL_INPUT;         break;
    case 334: hr = IXP_S_SMTP_334_AUTH_READY_RESPONSE;      break;
    case 235: hr = IXP_S_SMTP_245_AUTH_SUCCESS;             break;
    case 454: hr = IXP_E_SMTP_454_STARTTLS_FAILED;          break;
    case 530: hr = IXP_E_SMTP_530_STARTTLS_REQUIRED;        break;
    default: 
        hr = IXP_E_SMTP_UNKNOWN_RESPONSE_CODE;
        fKnownResponse = FALSE;
        break;
    }

    // Set hr
    m_hrResponse = hr;

    // Give to callback
    if (m_pCallback && m_fCommandLogging)
        m_pCallback->OnCommand(CMD_RESP, m_pszResponse, hr, SMTPTHISIXP);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::_HrFormatAddressString
// --------------------------------------------------------------------------------
HRESULT CSMTPTransport::_HrFormatAddressString(LPCSTR pszEmail, LPCSTR pszExtra, LPSTR *ppszAddress)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cchAlloc;

    // Invalid Arg
    Assert(pszEmail && ppszAddress);

    cchAlloc= lstrlen(pszEmail) + 3; // length of pszEmail plus <> and a null term
    if(pszExtra && pszExtra[0])
        cchAlloc += lstrlen(pszExtra) + 1; // length of pszExtra plus a space

    // Allocate string
    CHECKALLOC(*ppszAddress = (LPSTR)g_pMalloc->Alloc(cchAlloc * sizeof((*ppszAddress)[0])));

    // Format the String
    wnsprintf(*ppszAddress, cchAlloc, "<%s>", pszEmail);
    if(pszExtra && pszExtra[0])
    {
        StrCatBuff(*ppszAddress, " ", cchAlloc);
        StrCatBuff(*ppszAddress, pszExtra, cchAlloc);
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::CommandMAIL
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::CommandMAIL(LPSTR pszEmailFrom)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTR       pszAddress=NULL;
    CHAR        szDSNData[128];

    szDSNData[0]= '\0';

    // Check params
    if (NULL == pszEmailFrom)
        return TrapError(E_INVALIDARG);

	// build DSN parameters if necessary
	if(m_fDSNAvail)
	{
		if(DSNRET_DEFAULT != m_rMessage.dsnRet)
		{
            StrCatBuff(szDSNData, g_szDSNRET, ARRAYSIZE(szDSNData));

			if(m_rMessage.dsnRet == DSNRET_HDRS)
                StrCatBuff(szDSNData, g_szDSNHDRS, ARRAYSIZE(szDSNData));
			else if(DSNRET_FULL == m_rMessage.dsnRet)
                StrCatBuff(szDSNData, g_szDSNFULL, ARRAYSIZE(szDSNData));

		}

		if(m_rMessage.pszDSNENVID)
		{
            if(szDSNData[0])
                StrCatBuff(szDSNData, " ", ARRAYSIZE(szDSNData));

            StrCatBuff(szDSNData, g_szDSNENVID, ARRAYSIZE(szDSNData));
            StrCatBuff(szDSNData, m_rMessage.pszDSNENVID, ARRAYSIZE(szDSNData));
		}
	}
	
    // Put pszEmailFrom into <pszEmailFrom>
    CHECKHR(hr = _HrFormatAddressString(pszEmailFrom, szDSNData, &pszAddress));

    // Send Command
    hr = HrSendCommand((LPSTR)SMTP_MAIL_STR, pszAddress, !m_fSendMessage);
    if (SUCCEEDED(hr))
    {
        StrCpyN(m_szEmail, pszEmailFrom, ARRAYSIZE(m_szEmail));
        m_command = SMTP_MAIL;
    }

exit:
    // Cleanup
    SafeMemFree(pszAddress);

    // Done
    return hr;
}


// --------------------------------------------------------------------------------
// CSMTPTransport::CommandRCPT
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::CommandRCPT(LPSTR pszEmailTo)
{
	return CommandRCPT2(pszEmailTo, (INETADDRTYPE)0);
}

// --------------------------------------------------------------------------------
// CSMTPTransport::CommandRCPT2
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::CommandRCPT2(LPSTR pszEmailTo, INETADDRTYPE atDSN)
{
    // Locals
    HRESULT     hr=S_OK;
    LPSTR       pszAddress=NULL;
    CHAR        szDSNData[32];
    int iatDSN= atDSN;

    szDSNData[0]= '\0';

    // Check params
    if (NULL == pszEmailTo)
        return TrapError(E_INVALIDARG);
    if ((atDSN & ~ADDR_DSN_MASK) ||
    	  ((atDSN & ADDR_DSN_NEVER) &&
   		  (atDSN & ~ADDR_DSN_NEVER)))
    	return TrapError(E_INVALIDARG);

	// build DSN parameters if necessary
    if(m_fDSNAvail && atDSN)
    {
        StrCatBuff(szDSNData, g_szDSNNOTIFY, ARRAYSIZE(szDSNData));

		if(atDSN & ADDR_DSN_NEVER)
            StrCatBuff(szDSNData, g_szDSNNEVER, ARRAYSIZE(szDSNData));
		else
		{
			bool fPrev= false;
			
			if(atDSN & ADDR_DSN_SUCCESS)
			{
                StrCatBuff(szDSNData, g_szDSNSUCCESS, ARRAYSIZE(szDSNData));
				fPrev= true;
			}
			if(atDSN & ADDR_DSN_FAILURE)
			{
				if(fPrev)
                    StrCatBuff(szDSNData, ",", ARRAYSIZE(szDSNData));
                StrCatBuff(szDSNData, g_szDSNFAILURE, ARRAYSIZE(szDSNData));
				fPrev= true;
			}
			if(atDSN & ADDR_DSN_DELAY)
			{
				if(fPrev)
                    StrCatBuff(szDSNData, ",", ARRAYSIZE(szDSNData));
                StrCatBuff(szDSNData, g_szDSNDELAY, ARRAYSIZE(szDSNData));
			}
		}
    }

    // Put pszEmailFrom into <pszEmailFrom>
    CHECKHR(hr = _HrFormatAddressString(pszEmailTo, szDSNData, &pszAddress));

    // Send Command
    hr = HrSendCommand((LPSTR)SMTP_RCPT_STR, pszAddress, !m_fSendMessage);
    if (SUCCEEDED(hr))
    {
        StrCpyN(m_szEmail, pszEmailTo, ARRAYSIZE(m_szEmail));
        m_command = SMTP_RCPT;
    }

exit:
    // Cleanup
    SafeMemFree(pszAddress);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::CommandEHLO
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::CommandEHLO(void)
{
    return _HrHELO_Or_EHLO(SMTP_EHLO_STR, SMTP_EHLO);
}

// --------------------------------------------------------------------------------
// CSMTPTransport::CommandHELO
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::CommandHELO(void)
{
    return _HrHELO_Or_EHLO(SMTP_HELO_STR, SMTP_HELO);
}

// --------------------------------------------------------------------------------
// CSMTPTransport::_HrHELO_Or_EHLO
// --------------------------------------------------------------------------------
HRESULT CSMTPTransport::_HrHELO_Or_EHLO(LPCSTR pszCommand, SMTPCOMMAND eNewCommand)
{
    // Locals
    HRESULT hr=S_OK;

    // Use an IP address
    if (ISFLAGSET(m_rServer.dwFlags, ISF_SMTP_USEIPFORHELO))
    {
        // Locals
        LPHOSTENT   pHost=NULL;
        SOCKADDR_IN sa;

        // Get Host by name
        pHost = gethostbyname(SzGetLocalHostName());

        // Cast ip
        sa.sin_addr.s_addr = (ULONG)(*(DWORD *)pHost->h_addr);

        // Send HELO, quit and die if it fails
        hr = HrSendCommand((LPSTR)pszCommand, inet_ntoa(sa.sin_addr), !m_fSendMessage && !m_fTLSNegotiation);
        if (SUCCEEDED(hr))
            m_command = eNewCommand;
    }

    // Otherwise, this code uses a host name to do the ehlo or helo command
    else    
    {
        // Locals
        CHAR    szLocalHost[255];
        LPSTR   pszHost=SzGetLocalHostName();

        // Get legal local host name
#ifdef DEBUG
        StripIllegalHostChars("GTE/Athena", szLocalHost, ARRAYSIZE(szLocalHost));
        StripIllegalHostChars("foobar.", szLocalHost, ARRAYSIZE(szLocalHost));
        StripIllegalHostChars("127.256.34.23", szLocalHost, ARRAYSIZE(szLocalHost));
        StripIllegalHostChars("56foo1", szLocalHost, ARRAYSIZE(szLocalHost));
#endif
        // Get legal local host name
        StripIllegalHostChars(pszHost, szLocalHost, ARRAYSIZE(szLocalHost));

        // Send HELO, quit and die if it fails
        hr = HrSendCommand((LPSTR)pszCommand, szLocalHost, !m_fSendMessage && !m_fTLSNegotiation);
        if (SUCCEEDED(hr))
            m_command = eNewCommand;
    }

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::DoQuit
// --------------------------------------------------------------------------------
void CSMTPTransport::DoQuit(void)
{
    CommandQUIT();
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::CommandAUTH
// ------------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::CommandAUTH(LPSTR pszAuthType)
{
    // check params
    if (NULL == pszAuthType)
        return TrapError(E_INVALIDARG);

    // Do the command
    HRESULT hr = HrSendCommand((LPSTR)SMTP_AUTH_STR, pszAuthType, !m_fConnectAuth);
    if (SUCCEEDED(hr))
        m_command = SMTP_AUTH;

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::CommandQUIT
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::CommandQUIT(void)
{            
    // Send QUIT
    OnStatus(IXP_DISCONNECTING);
    HRESULT hr = HrSendCommand((LPSTR)SMTP_QUIT_STR, NULL, !m_fSendMessage);
    if (SUCCEEDED(hr))
        m_command = SMTP_QUIT;
    return hr;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::CommandRSET
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::CommandRSET(void)
{
    // Send Command
    HRESULT hr = HrSendCommand((LPSTR)SMTP_RSET_STR, NULL, !m_fSendMessage);
    if (SUCCEEDED(hr))
        m_command = SMTP_RSET;
    return hr;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::CommandDATA
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::CommandDATA(void)
{
    // Send Command
    HRESULT hr = HrSendCommand((LPSTR)SMTP_DATA_STR, NULL, !m_fSendMessage);
    if (SUCCEEDED(hr))
        m_command = SMTP_DATA;
    return hr;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::CommandDOT
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::CommandDOT(void)
{
    // Send Command
    HRESULT hr = HrSendCommand((LPSTR)SMTP_END_DATA_STR, NULL, !m_fSendMessage);
    if (SUCCEEDED(hr))
        m_command = SMTP_DOT;
    return hr;
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::CommandSTARTTLS
// ------------------------------------------------------------------------------------
HRESULT CSMTPTransport::CommandSTARTTLS(void)
{
    // Locals
    HRESULT         hr=S_OK;
    
    // Is StartTLS supported?
    if(FALSE == m_fSTARTTLSAvail)
    {
        hr= IXP_E_SMTP_NO_STARTTLS_SUPPORT;
        goto exit;
    }

    // Do the command
    hr = HrSendCommand((LPSTR)SMTP_STARTTLS_STR, NULL, !m_fConnectAuth);
    if (SUCCEEDED(hr))
        m_fTLSNegotiation = TRUE;

    // Done
exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::SendDataStream
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPTransport::SendDataStream(IStream *pStream, ULONG cbSize)
{
    // Locals
    HRESULT         hr=S_OK;
    INT             cb;

    // check params
    if (NULL == pStream)
        return TrapError(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&m_cs);

    // Busy...
    if (m_fSendMessage == FALSE)
    {
        CHECKHR(hr = HrEnterBusy());
    }

    // Save Total Size
    m_cbSent = 0;
    m_cbTotal = cbSize;

    // Send the stream, if it fails, move the the next message
    hr = m_pSocket->SendStream(pStream, &cb, TRUE);
    if (FAILED(hr))
    {
        // If this is a blocking situation, enter SMTP_SEND_STREAM_RESP
        if (hr == IXP_E_WOULD_BLOCK)
        {
            m_command = SMTP_SEND_STREAM;
            SendStreamResponse(FALSE, S_OK, cb);
            hr =S_OK;
            goto exit;
        }

        // Otherwise, someother error
        else
        {
            hr = TrapError(IXP_E_SOCKET_WRITE_ERROR);
            goto exit;
        }
    }

    // Give send stream response
    SendStreamResponse(TRUE, S_OK, cb);

    // Not Busy
    if (FALSE == m_fSendMessage)
        LeaveBusy();

    // Send DOT
    CHECKHR(hr = CommandDOT());

exit:
    // Failure
    if (FALSE == m_fSendMessage && FAILED(hr))
        LeaveBusy();

    // Thread Safety
    LeaveCriticalSection(&m_cs);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSMTPTransport::SendStreamResponse
// --------------------------------------------------------------------------------
void CSMTPTransport::SendStreamResponse(BOOL fDone, HRESULT hrResult, DWORD cbIncrement)
{
    // Locals
    SMTPRESPONSE rResponse;

    // Increment Current
    m_cbSent += cbIncrement;

    // Set the HRESULT
    rResponse.command = SMTP_SEND_STREAM;
    rResponse.fDone = fDone;
    rResponse.rIxpResult.pszResponse = NULL;
    rResponse.rIxpResult.hrResult = hrResult;
    rResponse.rIxpResult.uiServerError = 0;
    rResponse.rIxpResult.hrServerError = S_OK;
    rResponse.rIxpResult.dwSocketError = m_pSocket->GetLastError();
    rResponse.rIxpResult.pszProblem = NULL;
    rResponse.pTransport = this;
    rResponse.rStreamInfo.cbIncrement = cbIncrement;
    rResponse.rStreamInfo.cbCurrent = m_cbSent;
    rResponse.rStreamInfo.cbTotal = m_cbTotal;

    // Finished...
    if (fDone)
    {
        // No current command
        m_command = SMTP_NONE;

        // Leave Busy State
        LeaveBusy();
    }

    // Give the Response to the client
    if (m_pCallback)
        ((ISMTPCallback *)m_pCallback)->OnResponse(&rResponse);
}

// --------------------------------------------------------------------------------
// CSMTPTransport::SendMAIL
// --------------------------------------------------------------------------------
void CSMTPTransport::SendMessage_MAIL(void)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i;
    LPINETADDR      pInetAddress;

    // Loop address list
    for (i=0; i<m_rMessage.smtpMsg.rAddressList.cAddress; i++)
    {
        // Readability
        pInetAddress = &m_rMessage.smtpMsg.rAddressList.prgAddress[i];

        // From...
        if (ADDR_FROM == (pInetAddress->addrtype & ADDR_TOFROM_MASK))
        {
			// Save index of sender
			m_iAddress = 0;

            // Send Command
            hr = CommandMAIL(pInetAddress->szEmail);
            if (FAILED(hr))
                SendMessage_DONE(hr);

            // Done
            return;
        }
    }

    // No Sender
    SendMessage_DONE(TrapError(IXP_E_SMTP_NO_SENDER));
}

// --------------------------------------------------------------------------------
// CSMTPTransport::SendMessage_RCPT
// --------------------------------------------------------------------------------
void CSMTPTransport::SendMessage_RCPT(void)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           i;
    LPINETADDR      pInetAddress;

    // Find next ADDR_TO, starting with m_rCurrent.iRcptAddrList
    IxpAssert(m_iAddress <= m_rMessage.smtpMsg.rAddressList.cAddress);
    for(i=m_iAddress; i<m_rMessage.smtpMsg.rAddressList.cAddress; i++)
    {
        // Readability
        pInetAddress = &m_rMessage.smtpMsg.rAddressList.prgAddress[i];

        // Recipient
        if (ADDR_TO == (pInetAddress->addrtype & ADDR_TOFROM_MASK))
        {
            // Count recipients
            m_cRecipients++;

            // Send Command
            hr = CommandRCPT2(pInetAddress->szEmail, (INETADDRTYPE)(pInetAddress->addrtype & ADDR_DSN_MASK));
            if (FAILED(hr))
                SendMessage_DONE(hr);
            else
            {
                m_iAddress = i + 1;
                m_cRecipients++;
            }

            // Done
            return;
        }
    }

    // If no recipients
    if (0 == m_cRecipients)
        SendMessage_DONE(TrapError(IXP_E_SMTP_NO_RECIPIENTS));

    // Otherwise, were done with rcpt, lets send the message
    else
    {
        hr = CommandDATA();
        if (FAILED(hr))
            SendMessage_DONE(hr);
    }
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::StartLogon
// ------------------------------------------------------------------------------------
void CSMTPTransport::StartLogon(void)
{
    // Locals
    HRESULT hr;

    // Progress
    OnStatus(IXP_AUTHORIZING);

    // Free current packages...
    if (NULL == m_rAuth.pPackages)
    {
        // If Not Using Sicily or its not installed, then send USER command
        SSPIGetPackages(&m_rAuth.pPackages, &m_rAuth.cPackages);
    }

    // ResponseAUTH
    TryNextAuthPackage();

    // Done
    return;
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::LogonRetry
// ------------------------------------------------------------------------------------
void CSMTPTransport::LogonRetry(void)
{
    // Locals
    HRESULT         hr=S_OK;

    // Auth Retry
    OnStatus(IXP_AUTHRETRY);

    // Enter Auth Retry State
    m_pSocket->Close();

    // Logon
    if (NULL == m_pCallback || m_pCallback->OnLogonPrompt(&m_rServer, SMTPTHISIXP) != S_OK)
    {
        // Go to terminal state, were done.
        OnDisconnected();
        return;
    }

    // Finding Host Progress
    OnStatus(IXP_FINDINGHOST);

    // Connect to server
    hr = m_pSocket->Connect();
    if (FAILED(hr))
    {
        OnError(TrapError(IXP_E_SOCKET_CONNECT_ERROR));
        OnDisconnected();
        return;
    }

    // Reset the secured state
    m_fSecured = FALSE;

    // Start WatchDog
    m_pSocket->StartWatchDog();
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::TryNextAuthPackage
// ------------------------------------------------------------------------------------
void CSMTPTransport::TryNextAuthPackage(void)
{
    // Locals
    HRESULT hr=S_OK;
    BOOL    fPackageInstalled;
    BOOL    fLoginMethod=FALSE;
    ULONG   i;

    // Set auth state
    m_rAuth.authstate = AUTH_NONE;

    // Loop through the auth tokens, and try to authenticate with each one in order
    for (;m_rAuth.iAuthToken < m_rAuth.cAuthToken; m_rAuth.iAuthToken++)
    {
        // Assume package is not installed
        fPackageInstalled = FALSE;

        // "LOGIN"
        if (lstrcmpi(m_rAuth.rgpszAuthTokens[m_rAuth.iAuthToken], "LOGIN") == 0)
        {
            fLoginMethod = TRUE;
            fPackageInstalled = TRUE;
        }

        // Loop through installed packages
        else
        {
            for (i=0; i<m_rAuth.cPackages; i++)
            {
                // Null Package ??
                if (!m_rAuth.pPackages[i].pszName)
                    continue;

                // Is this the package I am looking for
                if (lstrcmpi(m_rAuth.pPackages[i].pszName, m_rAuth.rgpszAuthTokens[m_rAuth.iAuthToken]) == 0)
                {
                    fPackageInstalled = TRUE;
                    break;
                }
            }
        }

        // Package not installed ?
        if (!fPackageInstalled)
            continue;

        // We are not retrying the current package
        m_rAuth.fRetryPackage = FALSE;

        // Otherwise, send AUTH enumpacks command
        hr = CommandAUTH(m_rAuth.rgpszAuthTokens[m_rAuth.iAuthToken]);
        if (FAILED(hr))
        {
            OnError(hr);
            DropConnection();
            return;
        }

        // We are in the TRYING_PACKAGE state
        m_rAuth.authstate = fLoginMethod ? AUTH_SMTP_LOGIN : AUTH_TRYING_PACKAGE;

        // Done
        break;
    }

    // If auth state is none, try HELO command
    if (AUTH_NONE == m_rAuth.authstate)
    {
        // Were authenticated
        m_fAuthenticated = TRUE;

        // Authorized
        OnAuthorized();
    }
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::ResponseAUTH
// ------------------------------------------------------------------------------------
void CSMTPTransport::ResponseAUTH(HRESULT hrResponse)
{
    // Stop the WatchDog
    m_pSocket->StopWatchDog();

    // I know how to do this
    if (lstrcmpi(m_rAuth.rgpszAuthTokens[m_rAuth.iAuthToken], "LOGIN") == 0)
    {
        // DoLogonAuth
        DoLoginAuth(hrResponse);
    }

    // Otherwise, we must have just tryed a package
    else if (m_rAuth.authstate == AUTH_TRYING_PACKAGE)
    {
        // DoPackageAuth
        DoPackageAuth(hrResponse);
    }

    // Otherwise, we got a response from a negotiation string
    else if (m_rAuth.authstate == AUTH_NEGO_RESP)
    {
        // DoAuthNegoResponse
        DoAuthNegoResponse(hrResponse);
    }

    // Otherwise, we got a response from a challenge response string
    else if (m_rAuth.authstate == AUTH_RESP_RESP)
    {
        // DoAuthRespResp
        DoAuthRespResponse(hrResponse);
    }

    // Auth was cancelled, try next package
    else if (m_rAuth.authstate == AUTH_CANCELED)
    {
        // Free Current Context
        SSPIFreeContext(&m_rAuth.rSicInfo);

        // Goto next package
        m_rAuth.iAuthToken++;

        // Try the next package
        TryNextAuthPackage();
    }

    // Free Current Response
    SafeMemFree(m_pszResponse);
    m_hrResponse = S_OK;

    // Start the WatchDog
    m_pSocket->StartWatchDog();
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::DoLoginAuth
// ------------------------------------------------------------------------------------
void CSMTPTransport::DoLoginAuth(HRESULT hrResponse)
{
    // Locals
    SSPIBUFFER Buffer;

    // Failure, retry login
    if (FAILED(hrResponse))
    {
        // I just issued the AUTH LOGIN command, this should not happen
        if (AUTH_SMTP_LOGIN == m_rAuth.authstate)
        {
            // Free Current Context
            SSPIFreeContext(&m_rAuth.rSicInfo);

            // Goto next package
            m_rAuth.iAuthToken++;

            // Try the next package
            TryNextAuthPackage();
        }

        // Otherwise, I just issued the AUTH LOGIN USERNAME
        else if (AUTH_SMTP_LOGIN_USERNAME == m_rAuth.authstate || AUTH_SMTP_LOGIN_PASSWORD == m_rAuth.authstate)
        {
            // Retry the Logon
            LogonRetry();
        }
        else
            Assert(FALSE);

        // Done
        goto exit;
    }

    // Should have a response
    Assert(m_pszResponse);

    // 334
    if ((334 == m_uiResponse) && m_pszResponse)
    {
        // Set the Length
        SSPISetBuffer(m_pszResponse + 4, SSPI_STRING, 0, &Buffer);

        // Base64 Decode
        if (FAILED(SSPIDecodeBuffer(TRUE, &Buffer)))
        {
            OnError(E_FAIL);
            DropConnection();
            goto exit;
        }

        // If the user name is empty, lets retry the login...
        if (FIsEmptyA(m_rServer.szUserName))
        {
            // LogonRetry
            LogonRetry();

            // Done
            goto exit;
        }

        // Handle Next STep
        if (StrCmpNI(Buffer.szBuffer, "username:", lstrlen("username:")) == 0)
        {
            // Set the Buffer 
            SSPISetBuffer(m_rServer.szUserName, SSPI_STRING, 0, &Buffer);

            // Encode the User Name
            if (FAILED(SSPIEncodeBuffer(TRUE, &Buffer)))
            {
                OnError(E_FAIL);
                DropConnection();
                goto exit;
            }

            // Send the user name
            if (FSendSicilyString(Buffer.szBuffer))
                m_rAuth.authstate = AUTH_SMTP_LOGIN_USERNAME;
        }

        // Password
        else if (StrCmpNI(Buffer.szBuffer, "password:", lstrlen("password:")) == 0)
        {
            // Set the Buffer 
            SSPISetBuffer(m_rServer.szPassword, SSPI_STRING, 0, &Buffer);

            // Encode the password
            if (FAILED(SSPIEncodeBuffer(TRUE, &Buffer)))
            {
                OnError(E_FAIL);
                DropConnection();
                goto exit;
            }

            // Send the password
            if (FSendSicilyString(Buffer.szBuffer))
                m_rAuth.authstate = AUTH_SMTP_LOGIN_PASSWORD;
        }

        // Bad response from the server
        else
        {
            OnError(E_FAIL);
            DropConnection();
            goto exit;
        }
    }

    // Connected
    else if (235 == m_uiResponse)
    {
        // OnAuthorizied
        OnAuthorized();
    }

    // Error Response ?
    else
    {
        OnError(E_FAIL);
        DropConnection();
        goto exit;
    }

exit:
    return;
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::DoPackageAuth
// ------------------------------------------------------------------------------------
void CSMTPTransport::DoPackageAuth(HRESULT hrResponse)
{
    // Locals
    SSPIBUFFER Negotiate;

    // Failure, retry login
    if (FAILED(hrResponse))
    {
        // Free Current Context
        SSPIFreeContext(&m_rAuth.rSicInfo);

        // Goto next package
        m_rAuth.iAuthToken++;

        // Try the next package
        TryNextAuthPackage();

        // Done
        goto exit;
    }

    // Invalid Arg
    Assert(m_rAuth.iAuthToken < m_rAuth.cAuthToken);

    // Do Sicily Logon
    if (FAILED(SSPILogon(&m_rAuth.rSicInfo, m_rAuth.fRetryPackage, SSPI_BASE64, m_rAuth.rgpszAuthTokens[m_rAuth.iAuthToken], &m_rServer, m_pCallback)))
    {
        // Cancel Authentication
        CancelAuthInProg();

        // Done
        goto exit;
    }

    // Retrying current package
    if (m_rAuth.fRetryPackage)
    {
        // Don't retry again
        m_rAuth.fRetryPackage = FALSE;
    }

    // Get negotiation string
    if (FAILED(SSPIGetNegotiate(&m_rAuth.rSicInfo, &Negotiate)))
    {
        // Cancel Authentication
        CancelAuthInProg();

        // Done
        goto exit;
    }

    // Send AUTH Respons
    if (FSendSicilyString(Negotiate.szBuffer))
        m_rAuth.authstate = AUTH_NEGO_RESP;

exit:
    // Done
    return;
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::DoAuthNegoResponse
// ------------------------------------------------------------------------------------
void CSMTPTransport::DoAuthNegoResponse(HRESULT hrResponse)
{
    // Locals
    HRESULT     hr=S_OK;
    SSPIBUFFER  Challenge;
    SSPIBUFFER  Response;

    if (!m_pszResponse)
    {
        Assert(m_pszResponse);
        return;
    }

    // Invalid Arg
    Assert(m_rAuth.iAuthToken < m_rAuth.cAuthToken);

    // Failure, retry login
    if (FAILED(hrResponse) || (lstrlen(m_pszResponse) < 4))
    {
        // RetryPackage
        RetryPackage();

        // Done
        goto exit;
    }

    // Set Chal String - skip over "+ "
    SSPISetBuffer(m_pszResponse + 4, SSPI_STRING, 0, &Challenge);

    // Get response from challenge
    if (FAILED(SSPIResponseFromChallenge(&m_rAuth.rSicInfo, &Challenge, &Response)))
    {
        // Cancel Authentication
        CancelAuthInProg();

        // Done
        goto exit;
    }

    // Send AUTH Respons
    if (FSendSicilyString(Response.szBuffer))
    {
        // if we need to continue, we keep the state the same
        // else we transition to the AUTH_RESP_RESP state.
        if (!Response.fContinue)
            m_rAuth.authstate = AUTH_RESP_RESP;
    }

exit:
    // Done
    return;
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::DoAuthRespResponse
// ------------------------------------------------------------------------------------
void CSMTPTransport::DoAuthRespResponse(HRESULT hrResponse)
{
    // Failure
    if (FAILED(hrResponse))
    {
        // RetryPackage
        RetryPackage();

        // Done
        goto exit;
    }

    // We will free the context, but keep the credential handle
    SSPIReleaseContext(&m_rAuth.rSicInfo);

    // OnAuthorized
    OnAuthorized();

exit:
    // Done
    return;
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::OnAuthorized
// ------------------------------------------------------------------------------------
void CSMTPTransport::OnAuthorized(void)
{
    // Connected (Authorized) state
    OnStatus(IXP_AUTHORIZED);

    // No more authorization
    m_fConnectAuth = FALSE;

    // Send command
    m_command = SMTP_CONNECTED;

    // Dispatch response
    DispatchResponse(S_OK, TRUE);
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::RetryPackage
// ------------------------------------------------------------------------------------
void CSMTPTransport::RetryPackage(void)
{
    // retry current package, with prompt
    m_rAuth.fRetryPackage = TRUE;

    // Send the auth command again
    HRESULT hr = CommandAUTH(m_rAuth.rgpszAuthTokens[m_rAuth.iAuthToken]);
    if (FAILED(hr))
    {
        OnError(hr);
        DropConnection();
        goto exit;
    }

    // New State
    m_rAuth.authstate = AUTH_TRYING_PACKAGE;

    // Free current information
    SSPIFreeContext(&m_rAuth.rSicInfo);

exit:
    // Done
    return;
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::FSendSicilyString
// ------------------------------------------------------------------------------------
BOOL CSMTPTransport::FSendSicilyString(LPSTR pszData)
{
    // Locals
    LPSTR           pszLine=NULL;
    HRESULT         hr=S_OK;

    // Check Param
    Assert(pszData);

    // Allocate a line
    DWORD cchSize = (lstrlen(pszData) + 5);
    pszLine = PszAllocA(cchSize * sizeof(pszLine[0]));
    if (NULL == pszLine)
    {
        OnError(E_OUTOFMEMORY);
        DropConnection();
        return FALSE;
    }

    // Make Line
    wnsprintf(pszLine, cchSize, "%s\r\n", pszData);

    // Send the lin
    hr = HrSendLine(pszLine);
    SafeMemFree(pszLine);

    // Failure
    if (FAILED(hr))
    {
        OnError(hr);
        DropConnection();
        return FALSE;
    }

    // Success
    return TRUE;
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::CancelAuthInProg
// ------------------------------------------------------------------------------------
void CSMTPTransport::CancelAuthInProg(void)
{
    // Locals
    HRESULT         hr;

    // Send *, quit and die if it fails
    hr = HrSendCommand((LPSTR)SMTP_AUTH_CANCEL_STR, NULL, FALSE);
    if (FAILED(hr))
    {
        OnError(hr);
        DropConnection();
    }
    else
    {
        // New state
        m_command = SMTP_AUTH;
        m_rAuth.authstate = AUTH_CANCELED;
    }
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::StartTLS
// ------------------------------------------------------------------------------------
void CSMTPTransport::StartTLS(void)
{
    // Locals
    HRESULT hr;

    // Progress
    OnStatus(IXP_SECURING);

    hr = CommandSTARTTLS();
    if (FAILED(hr))
    {
        OnError(hr);
        DropConnection();
    }
    
    return;
}

// ------------------------------------------------------------------------------------
// CSMTPTransport::TryNextSecurityPkg
// ------------------------------------------------------------------------------------
void CSMTPTransport::TryNextSecurityPkg(void)
{
    if (FALSE != FIsSecurityEnabled())
    {
        m_pSocket->TryNextSecurityPkg();
    }
    else
    {
        OnError(E_FAIL);
        DropConnection();
    }
        
    return;
}

//***************************************************************************
// Function: SetWindow
//
// Purpose:
//   This function creates the current window handle for async winsock process.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
STDMETHODIMP CSMTPTransport::SetWindow(void)
{
	HRESULT hr;
	
    Assert(NULL != m_pSocket);

    if(m_pSocket)
    	hr= m_pSocket->SetWindow();
    else
    	hr= E_UNEXPECTED;
    	
    return hr;
}

//***************************************************************************
// Function: ResetWindow
//
// Purpose:
//   This function closes the current window handle for async winsock process.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
STDMETHODIMP CSMTPTransport::ResetWindow(void)
{
	HRESULT hr;
	
    Assert(NULL != m_pSocket);

	if(m_pSocket)
		hr= m_pSocket->ResetWindow();
	else
		hr= E_UNEXPECTED;
 
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\ixputil.cpp ===
// --------------------------------------------------------------------------------
// Utility.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "imnxport.h"
#include "dllmain.h"
#include "ixputil.h"
#include <demand.h>
#include <shlwapi.h>

// --------------------------------------------------------------------------------
// HrInitializeWinsock
// --------------------------------------------------------------------------------
HRESULT HrInitializeWinsock(void)
{
    // Locals
    HRESULT     hr=S_OK;
    int         err;
    WSADATA     wsaData;

    // Thread Safety
    EnterCriticalSection(&g_csDllMain);

    // If Already Initialized...
    if (g_fWinsockInit)
        goto exit;

    // Do Startup
    err = WSAStartup(MAKEWORD(1,1), &wsaData);

    // Start up Windows Sockets DLL
    if (!err)
    {
        // Check WinSock version
        if ((LOBYTE(wsaData.wVersion) == 1) && (HIBYTE(wsaData.wVersion) == 1))
        {
            g_fWinsockInit = TRUE;
            goto exit;
        }
        else
        {
            DebugTrace("Winsock version %d.%d not supported", LOBYTE(wsaData.wVersion), HIBYTE(wsaData.wVersion));
            hr = TrapError(IXP_E_WINSOCK_WSAVERNOTSUPPORTED);
            goto exit;
        }
    }

    // Otherwise, map the error
    else
    {
        DebugTrace("WSAStartup failed: %d\n", err);
        switch(err)
        {
        case WSASYSNOTREADY:
            hr = TrapError(IXP_E_WINSOCK_WSASYSNOTREADY);
            break;

        case WSAVERNOTSUPPORTED:
            hr = TrapError(IXP_E_WINSOCK_WSAVERNOTSUPPORTED);
            break;

        case WSAEINPROGRESS:
            hr = TrapError(IXP_E_WINSOCK_WSAEINPROGRESS);
            break;

        case WSAEPROCLIM:
            hr = TrapError(IXP_E_WINSOCK_WSAEPROCLIM);
            break;

        case WSAEFAULT:
            hr = TrapError(IXP_E_WINSOCK_WSAEFAULT);
            break;

        default:
            hr = TrapError(IXP_E_WINSOCK_FAILED_WSASTARTUP);
            break;
        }
    }

exit:
    // Thread Safety
    LeaveCriticalSection(&g_csDllMain);

    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// UnInitializeWinsock
// --------------------------------------------------------------------------------
void UnInitializeWinsock(void)
{
    // Locals
    int err;

    // Thread Safety
    EnterCriticalSection(&g_csDllMain);

    // Has been initialized ?
    if (g_fWinsockInit)
    {
        // Shutdown Winsock
        err = WSACleanup();
        if (err)
            DebugTrace("WSACleanup failed: %d\n", WSAGetLastError());

        // Not initialized
        else
            g_fWinsockInit = FALSE;
    }

    // Thread Safety
    LeaveCriticalSection(&g_csDllMain);

    // Done
    return;
}

// --------------------------------------------------------------------------------
// PszGetDomainName
// --------------------------------------------------------------------------------
LPSTR PszGetDomainName(void)
{
    // pszHost
    LPSTR pszHost = SzGetLocalHostNameForID();

    // Set pszDomain
    LPSTR pszDomain = pszHost;

    // Strip Off Host Name?
    while (*pszHost)
    {
        // Skip DBCS Characters
        if (IsDBCSLeadByte(*pszHost))
        {
            // Skip DBCS Char
            pszHost+=2;

            // Goto next
            continue;
        }

        // Otherwise, test for @ sign
        else if (*pszHost == '.' && *(pszHost + 1) != '\0')
        {
            // Set pszDomain
            pszDomain = pszHost + 1;

            // We are Done
            break;
        }

        // Increment
        pszHost++;
    }

    // Return pszDomain
    return pszDomain;
}

// --------------------------------------------------------------------------------
// SzGetLocalHostNameForID
// --------------------------------------------------------------------------------
LPSTR SzGetLocalHostNameForID(void)
{
    // Locals
    static char s_szLocalHostId[255] = {0};

    // Gets local host name from socket library
    if (*s_szLocalHostId == 0)
    {
        // Locals
        LPHOSTENT       pHost;
        LPSTR           pszLocalHost;

        // Use gethostbyname
        pHost = gethostbyname(SzGetLocalHostName());

        // Failure ?
        if (pHost && pHost->h_name)
            pszLocalHost = pHost->h_name;
        else
            pszLocalHost = SzGetLocalHostName();

        // Strip illegals
        StripIllegalHostChars(pszLocalHost, s_szLocalHostId, ARRAYSIZE(s_szLocalHostId));

        // if we stripped out everything, then just copy in something
        if (*s_szLocalHostId == 0)
            StrCpyNA(s_szLocalHostId, "LocalHost", ARRAYSIZE(s_szLocalHostId));
    }

    // Done
    return s_szLocalHostId;
}


// --------------------------------------------------------------------------------
// SzGetLocalPackedIP
// --------------------------------------------------------------------------------
LPSTR SzGetLocalPackedIP(void)
{
    // Locals
    static CHAR s_szLocalPackedIP[255] = "";

    // Init WinSock...
    HrInitializeWinsock();

    // Gets local host name from socket library
    if (*s_szLocalPackedIP == '\0')
    {
        LPHOSTENT hp = NULL;

        hp = gethostbyname(SzGetLocalHostName());
        if (hp != NULL)
            wnsprintf(s_szLocalPackedIP, ARRAYSIZE(s_szLocalPackedIP), "%08x", *(long *)hp->h_addr);
        else
        {
            // $REVIEW - What should i do if this fails ???
            Assert (FALSE);
            DebugTrace("gethostbyname failed: WSAGetLastError: %ld\n", WSAGetLastError());
            StrCpyNA(s_szLocalPackedIP, "LocalHost", ARRAYSIZE(s_szLocalPackedIP));
        }
    }

    // Done
    return s_szLocalPackedIP;
}

// --------------------------------------------------------------------------------
// SzGetLocalHostName
// --------------------------------------------------------------------------------
LPSTR SzGetLocalHostName(void)
{
    // Locals
    static char s_szLocalHost[255] = {0};

    // Init WinSock...
    HrInitializeWinsock();

    // Gets local host name from socket library
    if (*s_szLocalHost == 0)
    {
        if (gethostname (s_szLocalHost, sizeof (s_szLocalHost)) == SOCKET_ERROR)
        {
            // $REVIEW - What should i do if this fails ???
            Assert (FALSE);
            DebugTrace ("gethostname failed: WSAGetLastError: %ld\n", WSAGetLastError ());
            StrCpyNA(s_szLocalHost, "LocalHost", ARRAYSIZE(s_szLocalHost));
        }
    }

    // Done
    return s_szLocalHost;
}

// --------------------------------------------------------------------------------
// StripIllegalHostChars
// --------------------------------------------------------------------------------
void StripIllegalHostChars(LPSTR pszSrc, LPSTR pszDst, DWORD cchSize)
{
    // Locals
    LPSTR       pszT;
    CHAR        ch;
    ULONG       cchDst=0;

    if (cchSize == 0)
        return;

    // Setup pszT
    pszT = pszDst;

    // Loop through the Source
    while('\0' != *pszSrc)
    {
        // Set ch
        ch = *pszSrc++;

        // A-Z, a-z, 0-9, no trailing dots
        if (cchSize > 0)
        {
            if ('.' == ch || (ch >= 'A' && ch <= 'Z') || (ch >= 'a' && ch <= 'z') || (ch >= '0' && ch <= '9'))
            {
                // Store the Character
                *pszT++ = ch;
	            cchSize--;

                // Increment Size
                cchDst++;
            }
        }
    }

    // Null terminate pszT
    if (cchSize == 0)
    {
        //have to truncate, caller didn't give us enough room
    	pszT--;
    }
    *pszT = '\0';

    // Strip Trailing dots...
    while (cchDst > 0)
    {
        // Last char is a dot
        if ('.' != pszDst[cchDst - 1])
            break;

        // Strip It
        pszDst[cchDst - 1] = '\0';

        // Decrement cchDst
        cchDst--;
    }

    // Nothing Left ?
    if (0 == cchDst)
        StrCpyNA(pszDst, "LocalHost", cchSize);
}

// ------------------------------------------------------------------------------------
// FEndRetrRecvBody
// ------------------------------------------------------------------------------------
BOOL FEndRetrRecvBody(LPSTR pszLines, ULONG cbRead, ULONG *pcbSubtract)
{
    // Loop the data until we hit the end of the data (i.e. '.') or there is no more data
    if (cbRead >= 5                  &&
        pszLines[cbRead - 1] == '\n' &&
        pszLines[cbRead - 2] == '\r' &&
        pszLines[cbRead - 3] == '.'  &&
        pszLines[cbRead - 4] == '\n' &&
        pszLines[cbRead - 5] == '\r')
    {
        *pcbSubtract = 5;
        return TRUE;
    }

    // If Last Line Ended with a CRLF, then lets just check for a .CRLF
    else if (cbRead >= 3                   &&
             // m_rInfo.rFetch.fLastLineCRLF  &&
             pszLines[0] == '.'            &&
             pszLines[1] == '\r'           &&
             pszLines[2] == '\n')
    {
        *pcbSubtract = 3;
        return TRUE;
    }

    // Not done yet
    return FALSE;
}

BOOL FEndRetrRecvBodyNews(LPSTR pszLines, ULONG cbRead, ULONG *pcbSubtract)
{
    DWORD       dwIndex = 0;
    BOOL        fRet    = FALSE;

    // If we have at least 5 characters...
    if (cbRead >= 5)
    {    
        //[shaheedp] Bug# 85807
        for (dwIndex = 0; dwIndex <= (cbRead - 5); dwIndex++)
        {
            if ((pszLines[dwIndex] == '\r') &&
                (pszLines[dwIndex + 1] == '\n') &&
                (pszLines[dwIndex + 2] == '.')  &&
                (pszLines[dwIndex + 3] == '\r') &&
                (pszLines[dwIndex + 4] == '\n'))
            {
                *pcbSubtract = (cbRead - dwIndex);
                fRet = TRUE;
                break;
            }
        }
    }

    //If we didn't find CRLF.CRLF, then lets find .CRLF at the beginning of the line.
    if (!fRet)
    {
        if ((cbRead >= 3) &&
            (pszLines[0] == '.') &&
            (pszLines[1] == '\r') &&
            (pszLines[2] == '\n'))
        {
            *pcbSubtract = cbRead;
            fRet = TRUE;
        }
    }
    return fRet;
}

// ------------------------------------------------------------------------------------
// UnStuffDotsFromLines
// ------------------------------------------------------------------------------------
void UnStuffDotsFromLines(LPSTR pszBuffer, INT *pcchBuffer)
{
    // Locals
    ULONG   iIn=0;
    ULONG   iOut=0;
    CHAR    chPrev='\0';
    CHAR    chNext;
    CHAR    chT;
    ULONG   cchBuffer=(*pcchBuffer);

    // Invalid Args
    Assert(pszBuffer && pcchBuffer);

    // Loop
    while(iIn < cchBuffer)
    {
        // Get Current Char
        chT = pszBuffer[iIn++];

        // Validate
        Assert(chT);

        // Leading dot
        if ('.' == chT && ('\0' == chPrev || '\n' == chPrev || '\r' == chPrev) && iIn < cchBuffer)
        {
            // Compute chNext
            chNext = pszBuffer[iIn];

            // Valid to strip ?
            if ('\r' != chNext && '\n' != chNext)
            {
                // Next Character
                chT = pszBuffer[iIn++];

                // Set chPrev
                chPrev = '.';
            }

            // Save Previous
            else
                chPrev = chT;
        }

        // Save Previous
        else
            chPrev = chT;

        // Set the character
        pszBuffer[iOut++] = chT;
    }

    // Reset pcchBuffer
    *pcchBuffer = iOut;

    // Done
    return;
}

// =============================================================================================
// SkipWhitespace
// Assumes piString points to character boundary
// =============================================================================================
void SkipWhitespace (LPCTSTR lpcsz, ULONG *pi)
{
    if (!lpcsz || !pi)
    {
        Assert (FALSE);
        return;
    }

#ifdef DEBUG
    Assert (*pi <= (ULONG)lstrlen (lpcsz)+1);
#endif

    LPTSTR lpsz = (LPTSTR)(lpcsz + *pi);
    while (*lpsz != '\0')
    {
        if (!IsSpace(lpsz))
            break;

            lpsz++;
            (*pi)+=1;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\ixputil.h ===
// --------------------------------------------------------------------------------
// Ixputil.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef __IXPUTIL_H
#define __IXPUTIL_H

// --------------------------------------------------------------------------------
// Host Name Utilities
// --------------------------------------------------------------------------------
void    StripIllegalHostChars(LPSTR pszSrc, LPSTR pszDst, DWORD cchSize);
HRESULT HrInitializeWinsock(void);
void    UnInitializeWinsock(void);
LPSTR   SzGetLocalPackedIP(void);
LPSTR   SzGetLocalHostNameForID(void);
LPSTR   SzGetLocalHostName(void);
BOOL    FEndRetrRecvBody(LPTSTR pszLines, ULONG cbRead, ULONG *pcbSubtract);
LPSTR   PszGetDomainName(void);
void    UnStuffDotsFromLines(LPSTR pszBuffer, INT *pcchBuffer);
BOOL    FEndRetrRecvBodyNews(LPSTR pszLines, ULONG cbRead, ULONG *pcbSubtract);
void    SkipWhitespace (LPCTSTR lpcsz, ULONG *pi);
#endif // __IXPUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\lookup.h ===
/*
 *    lookup.h
 *    
 *    Purpose:
 *        hostname lookup
 *    
 *    Owner:
 *        EricAn
 *
 *    History:
 *      Jun 97: Created.
 *    
 *    Copyright (C) Microsoft Corp. 1997
 */

#ifndef __LOOKUP_H__
#define __LOOKUP_H__

void InitLookupCache(void);
void DeInitLookupCache(void);

HRESULT LookupHostName(LPTSTR pszHostName, HWND hwndNotify, ULONG *pulAddr, LPBOOL pfCached, BOOL fForce);
HRESULT CancelLookup(LPTSTR pszHostName, HWND hwndNotify);

#define SPM_WSA_GETHOSTBYNAME   (WM_USER + 2)

#endif // __LOOKUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\lookup.cpp ===
/*
 *    lookup.cpp
 *    
 *    Purpose:
 *        hostname lookup
 *    
 *    Owner:
 *        EricAn
 *
 *    History:
 *      Jun 97: Created.
 *    
 *    Copyright (C) Microsoft Corp. 1997
 */

#include <pch.hxx>
#include <process.h>
#include <demand.h>
#include "lookup.h"

ASSERTDATA

#define HWND_ALLOC_NUM      4
#define LOOKUP_ALLOC_NUM    16
#define MAX_CACHED_ADDRS    16

struct LOOKUPINFO {
    LPTSTR  pszHostName;
    ULONG   rgAddr[MAX_CACHED_ADDRS];
    ULONG   cAddr;
    HTHREAD hThreadLookup;
    HWND   *rgHwndNotify;
    ULONG   cHwnd;
    ULONG   cHwndAlloc;
};

static LOOKUPINFO *s_rgLookUp = NULL;
static ULONG       s_cLookUp = 0;
static ULONG       s_cLookUpAlloc = 0;

static CRITICAL_SECTION s_csLookup;

HRESULT AddHwnd(LOOKUPINFO *pLI, HWND hwnd)
{
    HRESULT hr = S_OK;

    if (pLI->cHwnd == pLI->cHwndAlloc)
        {
        if (FAILED(HrRealloc((LPVOID*)&pLI->rgHwndNotify, (pLI->cHwndAlloc + HWND_ALLOC_NUM) * sizeof(HWND))))
            return E_OUTOFMEMORY;
        pLI->cHwndAlloc += HWND_ALLOC_NUM;
        }

    pLI->rgHwndNotify[pLI->cHwnd++] = hwnd;
    return S_OK;    
}

unsigned int __stdcall LookupThreadProc(LPVOID pv)
{
    LOOKUPINFO *pLI;
    LPHOSTENT   pHostEnt;
    LPTSTR      pszHostName;
    int         iLastError = 0;
    ULONG       ulAddr = (ULONG)-1, i;

    EnterCriticalSection(&s_csLookup);
    pszHostName = s_rgLookUp[(ULONG_PTR)pv].pszHostName;            
    LeaveCriticalSection(&s_csLookup);

    // do the actual lookup
    pHostEnt = gethostbyname(pszHostName);
    if (NULL == pHostEnt)
    iLastError = WSAGetLastError();

    EnterCriticalSection(&s_csLookup);
    pLI = &s_rgLookUp[(ULONG_PTR)pv];
    if (pHostEnt)
        {
        // copy the returned addresses into our buffer    
        while (pLI->cAddr < MAX_CACHED_ADDRS && pHostEnt->h_addr_list[pLI->cAddr])
            {
            pLI->rgAddr[pLI->cAddr] = *(ULONG *)(pHostEnt->h_addr_list[pLI->cAddr]);
            pLI->cAddr++;
            }
        ulAddr = pLI->rgAddr[0];
        }
    else
        {
        Assert(0 == pLI->cAddr);
        }
    // notify the registered windows that the lookup is complete
    for (i = 0; i < pLI->cHwnd; i++)
        if (IsWindow(pLI->rgHwndNotify[i]))
            PostMessage(pLI->rgHwndNotify[i], SPM_WSA_GETHOSTBYNAME, (WPARAM)iLastError, (LPARAM)ulAddr);
    pLI->cHwnd = 0;
    CloseHandle(pLI->hThreadLookup);
    pLI->hThreadLookup = NULL;
    LeaveCriticalSection(&s_csLookup);

    return 0;
}

void InitLookupCache(void)
{
    InitializeCriticalSection(&s_csLookup);
}

void DeInitLookupCache(void)
{
    ULONG       i;
    LOOKUPINFO *pLI;
    HANDLE      hThread;

    EnterCriticalSection(&s_csLookup);
    for (i = 0, pLI = s_rgLookUp; i < s_cLookUp; i++, pLI++)
        {
        if (pLI->hThreadLookup)
            {
            pLI->cHwnd = 0;
            // Raid 42360: WSACleanup() faults on Win95 if we still have a 
            //  lookup thread running.  WaitForSingleObject() on a thread 
            //  doesn't seem to work at DLL_PROCESS_DETACH time. 
            //  TerminateThread() seems to be the only reliable solution - 
            //  gross but it works.
            TerminateThread(pLI->hThreadLookup, 0);
            CloseHandle(pLI->hThreadLookup);
            }
        SafeMemFree(pLI->pszHostName);
        SafeMemFree(pLI->rgHwndNotify);
        }
    SafeMemFree(s_rgLookUp);
    s_cLookUp = s_cLookUpAlloc = 0;
    LeaveCriticalSection(&s_csLookup);
    DeleteCriticalSection(&s_csLookup);
}

HRESULT LookupHostName(LPTSTR pszHostName, HWND hwndNotify, ULONG *pulAddr, LPBOOL pfCached, BOOL fForce)
{
    ULONG       i;
    LOOKUPINFO *pLI;
    HRESULT     hr;
    DWORD       uiThreadId;

    *pfCached = FALSE;

    EnterCriticalSection(&s_csLookup);

    for (i = 0, pLI = s_rgLookUp; i < s_cLookUp; i++, pLI++)
        {
        Assert(pLI->pszHostName);
        if (!lstrcmpi(pLI->pszHostName, pszHostName))
            {
            if (pLI->hThreadLookup)
                {
                // there's a lookup in progress, so just append
                hr = AddHwnd(pLI, hwndNotify);
                goto exit;
                }
            else if (fForce || !pLI->cAddr)
                {
                // a previous connect or lookup failed, so try again
                pLI->cAddr = 0;
                goto startlookup;
                }
            else
                {
                // we've got the address cached
                *pulAddr = pLI->rgAddr[0];
                *pfCached = TRUE;
                hr = S_OK;
                goto exit;
                }
            }
        }

    // we didn't find it, so add it
    if (s_cLookUp == s_cLookUpAlloc)
        {
        if (FAILED(hr = HrRealloc((LPVOID*)&s_rgLookUp, (s_cLookUpAlloc + LOOKUP_ALLOC_NUM) * sizeof(LOOKUPINFO))))
            goto exit;
        s_cLookUpAlloc += LOOKUP_ALLOC_NUM;
        ZeroMemory(&s_rgLookUp[s_cLookUp], LOOKUP_ALLOC_NUM * sizeof(LOOKUPINFO));
        pLI = &s_rgLookUp[s_cLookUp];
        }

    pLI->pszHostName = PszDup(pszHostName);
    if (NULL == pLI->pszHostName)
        {
        hr = E_OUTOFMEMORY;
        goto exit;
        }

    s_cLookUp++;

startlookup:
    Assert(pLI->cAddr == 0);

    hr = AddHwnd(pLI, hwndNotify);
    if (FAILED(hr))
        goto exit;

    Assert(pLI->cHwnd == 1);

    // pLI->hThreadLookup = (HANDLE)_beginthreadex(NULL, 0, LookupThreadProc, (LPVOID)i, 0, &uiThreadId);
    pLI->hThreadLookup = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)LookupThreadProc, (LPVOID)IntToPtr(i), 0, &uiThreadId);
    if (NULL == pLI->hThreadLookup)
        {
        hr = E_FAIL;
        pLI->cHwnd = 0;
        }

exit:
    LeaveCriticalSection(&s_csLookup);
    return hr;
}

HRESULT CancelLookup(LPTSTR pszHostName, HWND hwndNotify)
{
    ULONG       i, j, cMove;
    LOOKUPINFO *pLI;
    HRESULT     hr = E_INVALIDARG;

    EnterCriticalSection(&s_csLookup);

    for (i = 0, pLI = s_rgLookUp; i < s_cLookUp; i++, pLI++)
        {
        Assert(pLI->pszHostName);
        if (!lstrcmpi(pLI->pszHostName, pszHostName))
            {
            for (j = 0; j < pLI->cHwnd; j++)
                {
                if (pLI->rgHwndNotify[j] == hwndNotify)
                    {
                    while (j + 1 < pLI->cHwnd)
                        {
                        pLI->rgHwndNotify[j] = pLI->rgHwndNotify[j+1];
                        j++;
                        }
                    pLI->cHwnd--;
                    hr = S_OK;
                    break;
                    }
                }
            break;
            }
        }

    LeaveCriticalSection(&s_csLookup);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\propfind.cpp ===
// --------------------------------------------------------------------------------
// propfind.cpp
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved
// Greg Friedman
// --------------------------------------------------------------------------------

#include <pch.hxx>
#include "propfind.h"
#include "strconst.h"
#include "davstrs.h"
#include <shlwapi.h>

#define FAIL_EXIT_STREAM_WRITE(stream, psz) \
    if (FAILED(hr = stream.Write(psz, lstrlen(psz), NULL))) \
        goto exit; \
    else

#define FAIL_EXIT(hr) \
    if (FAILED(hr)) \
        goto exit; \
    else

const ULONG c_ulGrowSize = 4;

static const char *g_rgszNamespaces[] =
{
    c_szDAVDavNamespace,
    c_szDAVHotMailNamespace,
    c_szDAVHTTPMailNamespace,
    c_szDAVMailNamespace,
    c_szDAVContactsNamespace
};

// predefine the first 10 namespace prefixes. if custom namespaces
// exceed the predefined set, additional prefixes are generated on
// the fly.

static const char *g_rgszNamespacePrefixes[] =
{
    c_szDavNamespacePrefix,
    c_szHotMailNamespacePrefix,
    c_szHTTPMailNamespacePrefix,
    c_szMailNamespacePrefix,
    c_szContactsNamespacePrefix,
    "_5",
    "_6",
    "_7",
    "_8",
    "_9"
};

const DWORD c_dwMaxDefinedNamespacePrefix = 10;

CStringArray::CStringArray(void) :
    m_rgpszValues(NULL),
    m_ulLength(0),
    m_ulCapacity(0)
{
}


CStringArray::~CStringArray(void)
{
    for (ULONG i = 0; i < m_ulLength; ++i)
    {
        if (NULL != m_rgpszValues[i])
            MemFree((void *)m_rgpszValues[i]);
    }

    SafeMemFree(m_rgpszValues);
}

HRESULT CStringArray::Add(LPCSTR psz)
{
    if (NULL == psz)
        return E_INVALIDARG;

    if (m_ulLength == m_ulCapacity && !Expand())
        return E_OUTOFMEMORY;

    m_rgpszValues[m_ulLength] = PszDupA(psz);
    if (NULL == m_rgpszValues)
        return E_OUTOFMEMORY;

    ++m_ulLength;
    return S_OK;
}

HRESULT CStringArray::Adopt(LPCSTR psz)
{
    if (NULL == psz)
        return E_INVALIDARG;

    if (m_ulLength == m_ulCapacity && !Expand())
        return E_OUTOFMEMORY;

    m_rgpszValues[m_ulLength] = psz;
    ++m_ulLength;
    return S_OK;
}

LPCSTR CStringArray::GetByIndex(ULONG ulIndex)
{
    if (0 == m_ulLength || (ulIndex > m_ulLength - 1))
        return NULL;

    return m_rgpszValues[ulIndex];
}

// --------------------------------------------------------------------------------
// CStringArray::RemoveByIndex
// --------------------------------------------------------------------------------
HRESULT CStringArray::RemoveByIndex(ULONG ulIndex)
{
    if (ulIndex > m_ulLength - 1)
        return E_INVALIDARG;

    if (NULL != m_rgpszValues[ulIndex])
    {
        MemFree(const_cast<char *>(m_rgpszValues[ulIndex]));
        m_rgpszValues[ulIndex] = NULL;
    }

    // shift down
    CopyMemory(&m_rgpszValues[ulIndex], m_rgpszValues[ulIndex + 1], (m_ulLength - ulIndex) * sizeof(LPSTR));
    --m_ulLength;

    return S_OK;
}

// --------------------------------------------------------------------------------
// CStringArray::Expand
// --------------------------------------------------------------------------------
BOOL CStringArray::Expand(void)
{
    LPCSTR *rgpszNewValues = NULL;
    if (!MemAlloc((void **)&rgpszNewValues, sizeof(LPSTR) * (m_ulCapacity + c_ulGrowSize)))
        return FALSE;

    // clear the new slots
    ZeroMemory(rgpszNewValues,sizeof(LPSTR) * (m_ulCapacity + c_ulGrowSize));

    // copy the old values over and swap in the new buffer
    CopyMemory(rgpszNewValues, m_rgpszValues, sizeof(LPSTR) * m_ulCapacity); 
    SafeMemFree(m_rgpszValues);
    
    m_rgpszValues = rgpszNewValues;
    m_ulCapacity += c_ulGrowSize;

    return TRUE;
}

// --------------------------------------------------------------------------------
// CStringHash::~CStringHash
// --------------------------------------------------------------------------------
CStringHash::~CStringHash(void)
{
    PHASHENTRY phe;

    // data stored in the hash table
    // are strings that can need to 
    // be deallocated.
    for (DWORD dw = 0; dw < m_cBins; dw++)
    {
        SafeMemFree(m_rgBins[dw].pv);

        phe = m_rgBins[dw].pheNext;
        while (phe)
        {
            SafeMemFree(phe->pv);
            phe = phe->pheNext;
        }
    }
}

// --------------------------------------------------------------------------------
// CDAVNamespaceArbiterImp::CDAVNamespaceArbiterImp
// --------------------------------------------------------------------------------
CDAVNamespaceArbiterImp::CDAVNamespaceArbiterImp(void)
{
    for (ULONG i = 0; i <= c_dwMaxNamespaceID; ++i)
        m_rgbNsUsed[i] = FALSE;

    // the DAV namespace is always included
    m_rgbNsUsed[DAVNAMESPACE_DAV] = TRUE;
}

// --------------------------------------------------------------------------------
// CDAVNamespaceArbiterImp::~CDAVNamespaceArbiterImp
// --------------------------------------------------------------------------------
CDAVNamespaceArbiterImp::~CDAVNamespaceArbiterImp(void)
{
    // nothing to do
}

// --------------------------------------------------------------------------------
// CDAVNamespaceArbiterImp::AddNamespace
// --------------------------------------------------------------------------------
HRESULT CDAVNamespaceArbiterImp::AddNamespace(LPCSTR pszNamespace, DWORD *pdwNamespaceID)
{
    HRESULT hr = S_OK;

    if (NULL == pszNamespace || NULL == pdwNamespaceID)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    if (FAILED(hr = m_saNamespaces.Add(pszNamespace)))
        goto exit;
    
    *pdwNamespaceID = m_saNamespaces.Length() + c_dwMaxNamespaceID;

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CDAVNamespaceArbiterImp::GetNamespaceID
// --------------------------------------------------------------------------------
HRESULT CDAVNamespaceArbiterImp::GetNamespaceID(LPCSTR pszNamespace, DWORD *pdwNamespaceID)
{
    DWORD dwIndex;
    DWORD dwEntries;

    if (NULL == pszNamespace || NULL == pdwNamespaceID)
        return E_INVALIDARG;

    // look for a predefined namespace
    for (dwIndex = 0; dwIndex < c_dwMaxNamespaceID; ++dwIndex)
    {
        if (!lstrcmp(pszNamespace, g_rgszNamespaces[dwIndex]))
        {
            *pdwNamespaceID = dwIndex;
            return S_OK;
        }
    }

    // look for a user-defined prefix
    dwEntries = m_saNamespaces.Length();
    for (dwIndex = 0; dwIndex < dwEntries; ++dwIndex)
    {
        if (!lstrcmp(pszNamespace, m_saNamespaces.GetByIndex(dwIndex)))
        {
            *pdwNamespaceID = (dwIndex + (c_dwMaxNamespaceID + 1));
            return S_OK;
        }
    }
    
    // if it wasn't found, the namespace doesn't exist
    return E_INVALIDARG;
}

// --------------------------------------------------------------------------------
// CDAVNamespaceArbiterImp::GetNamespacePrefix
// --------------------------------------------------------------------------------
HRESULT CDAVNamespaceArbiterImp::GetNamespacePrefix(DWORD dwNamespaceID, LPSTR *ppszNamespacePrefix)
{
    HRESULT hr = S_OK;
    LPSTR   pszTemp = NULL;

    if (NULL == ppszNamespacePrefix)
        return E_INVALIDARG;

    if (dwNamespaceID <= c_dwMaxDefinedNamespacePrefix)
        *ppszNamespacePrefix = PszDupA(g_rgszNamespacePrefixes[dwNamespaceID]);
    else
    {
        char szBuffer[12];
        wnsprintf(szBuffer, ARRAYSIZE(szBuffer), "_%d", dwNamespaceID);
        *ppszNamespacePrefix = PszDupA(szBuffer);
    }
    
    if (NULL == *ppszNamespacePrefix)
        hr = E_OUTOFMEMORY;

    return hr;
}

// --------------------------------------------------------------------------------
// CDAVNamespaceArbiterImp::AllocExpandedName
// --------------------------------------------------------------------------------
LPSTR CDAVNamespaceArbiterImp::AllocExpandedName(DWORD dwNamespaceID, LPCSTR pszPropertyName)
{
    LPSTR       pszPrefixedName = NULL;
    const DWORD c_dwMaxIntLength = 10;

    if (dwNamespaceID < c_dwMaxDefinedNamespacePrefix)
    {
        // allocate a buffer to hold the prefixed name.
        DWORD cchSize = (lstrlen(pszPropertyName) + lstrlen(g_rgszNamespacePrefixes[dwNamespaceID]) + 2);
        if (!MemAlloc((void **)&pszPrefixedName, cchSize * sizeof(pszPrefixedName[0])))
            return NULL;

        // generate the prefixed name
        wnsprintf(pszPrefixedName, cchSize, "%s:%s", g_rgszNamespacePrefixes[dwNamespaceID], pszPropertyName);
    }
    else
    {
        // allocate a buffer to hold the prefixed name. the "2" is for the prefix char '_" , the delimiting
        // colon and the eos.    

        DWORD cchSize = (lstrlen(pszPropertyName) + c_dwMaxIntLength + 3);
        if (!MemAlloc((void **)&pszPrefixedName, cchSize * sizeof(pszPrefixedName[0])))
            return NULL;


        // generate the prefixed name. use an underscore as the first char, because
        // DAV explicitly disallows digits for the first char.
        wnsprintf(pszPrefixedName, cchSize, "_%d:%s", dwNamespaceID, pszPropertyName);
    }

    return pszPrefixedName;
}

// --------------------------------------------------------------------------------
// CDAVNamespaceArbiterImp::WriteNamespaces
// --------------------------------------------------------------------------------
HRESULT CDAVNamespaceArbiterImp::WriteNamespaces(IStream *pStream)
{
    HRESULT         hr = S_OK;
    ULONG           i;
    ULONG           cEntries;
    BOOL            fNeedSpacePrefix = FALSE;

    // write out the intrinsic namespaces
    for (i = 0; i <= c_dwMaxNamespaceID; ++i)
    {
        if (m_rgbNsUsed[i])
        {
            if (FAILED(hr = _AppendXMLNamespace(pStream, g_rgszNamespaces[i], i, fNeedSpacePrefix)))
                goto exit;
            fNeedSpacePrefix = TRUE;
        }
    }

    // write out the installed namespaces
    cEntries = m_saNamespaces.Length();
    for (i = 0; i < cEntries; ++i)
    {
        if (FAILED(hr = _AppendXMLNamespace(pStream, m_saNamespaces.GetByIndex(i), i + i + c_dwMaxNamespaceID + 1, fNeedSpacePrefix)))
            goto exit;

        fNeedSpacePrefix = TRUE;
    }

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CDAVNamespaceArbiterImp::_AppendXMLNamespace
// --------------------------------------------------------------------------------
HRESULT CDAVNamespaceArbiterImp::_AppendXMLNamespace(IStream *pStream, 
                                                     LPCSTR pszNamespace, 
                                                     DWORD dwNamespaceID,
                                                     BOOL fWhitespacePrefix)
{
    HRESULT hr = S_OK;
    TCHAR   szPrefix[12];

    if (fWhitespacePrefix)
    {
        IxpAssert(1 == lstrlen(c_szEqual));
        if (FAILED(hr = pStream->Write(g_szSpace, 1, NULL)))
            goto exit;
    }

    if (FAILED(hr = pStream->Write(c_szXMLNsColon, lstrlen(c_szXMLNsColon), NULL)))
        goto exit;

    if (dwNamespaceID < c_dwMaxDefinedNamespacePrefix)
    {
        if (FAILED(hr = pStream->Write(g_rgszNamespacePrefixes[dwNamespaceID], lstrlen(g_rgszNamespacePrefixes[dwNamespaceID]), NULL)))
            goto exit;
    }
    else
    {
        wnsprintf(szPrefix, ARRAYSIZE(szPrefix), "_%d", dwNamespaceID);

        if (FAILED(hr = pStream->Write(szPrefix, lstrlen(szPrefix), NULL)))
            goto exit;
    }

    IxpAssert(1 == lstrlen(c_szEqual));
    IxpAssert(1 == lstrlen(c_szDoubleQuote));

    if (FAILED(hr = pStream->Write(c_szEqual, 1, NULL)))
        goto exit;

    if (FAILED(hr = pStream->Write(c_szDoubleQuote, 1, NULL)))
        goto exit;

    if (FAILED(hr = pStream->Write(pszNamespace, lstrlen(pszNamespace), NULL)))
        goto exit;

    hr = pStream->Write(c_szDoubleQuote, 1, NULL);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CPropPatchRequest::CPropPatchRequest
// --------------------------------------------------------------------------------
CPropPatchRequest::CPropPatchRequest(void) :
    m_fSpecify1252(FALSE),
    m_cRef(1)
{
    // nothing to do
}

// --------------------------------------------------------------------------------
// IUnknown Methods
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// CPropPatchRequest::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CPropPatchRequest::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr = S_OK;

    // Validate params
    if (NULL == ppv)
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // Initialize params
    *ppv = NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = ((IUnknown *)(IPropFindRequest *)this);
    else if (IID_IPropPatchRequest == riid)
        *ppv = ((IPropPatchRequest *)this);

    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    hr = TrapError(E_NOINTERFACE);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPropPatchRequest::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropPatchRequest::AddRef(void) 
{
	return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CPropPatchRequest::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropPatchRequest::Release(void) 
{
	if (0 != --m_cRef)
		return m_cRef;
	delete this;
	return 0;
}

// ----------------------------------------------------------------------------
// IDAVNamespaceArbiter methods
// ----------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// CPropPatchRequest::CPropPatchRequest::AddNamespace
// --------------------------------------------------------------------------------
STDMETHODIMP CPropPatchRequest::AddNamespace(LPCSTR pszNamespace, DWORD *pdwNamespaceID)
{
    return m_dna.AddNamespace(pszNamespace, pdwNamespaceID);    
}

// --------------------------------------------------------------------------------
// CPropPatchRequest::GetNamespaceID
// --------------------------------------------------------------------------------
STDMETHODIMP CPropPatchRequest::GetNamespaceID(LPCSTR pszNamespace, DWORD *pdwNamespaceID)
{
    return m_dna.GetNamespaceID(pszNamespace, pdwNamespaceID);
}

// --------------------------------------------------------------------------------
// CPropPatchRequest::GetNamespacePrefix
// --------------------------------------------------------------------------------
STDMETHODIMP CPropPatchRequest::GetNamespacePrefix(DWORD dwNamespaceID, LPSTR *ppszNamespacePrefix)
{
    return m_dna.GetNamespacePrefix(dwNamespaceID, ppszNamespacePrefix);
}

// --------------------------------------------------------------------------------
// IPropPatchRequest Methods
// --------------------------------------------------------------------------------
// --------------------------------------------------------------------------------
// CPropPatchRequest::SetProperty
// --------------------------------------------------------------------------------
STDMETHODIMP CPropPatchRequest::SetProperty(
                                    DWORD dwNamespaceID, 
                                    LPCSTR pszPropertyName, 
                                    LPCSTR pszNewValue)
{
    LPSTR pszPrefixedName = NULL;
    HRESULT hr = S_OK;

    // Validate params
    if (NULL == pszPropertyName || NULL == pszNewValue || dwNamespaceID > c_dwMaxNamespaceID + m_dna.m_saNamespaces.Length())
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    pszPrefixedName = m_dna.AllocExpandedName(dwNamespaceID, pszPropertyName);
    if (NULL == pszPrefixedName)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // if the namespace is one of the known namespaces, mark it in
    // the array so that we can include the namespace directive in
    // the generated xml
    if (dwNamespaceID <= c_dwMaxNamespaceID)
        m_dna.m_rgbNsUsed[dwNamespaceID] = TRUE;

    if (FAILED(hr = m_saPropValues.Add(pszNewValue)))
        goto exit;

    if (FAILED(hr = m_saPropNames.Adopt(pszPrefixedName)))
    {
        MemFree(pszPrefixedName);
        m_saPropValues.RemoveByIndex(m_saPropValues.Length() - 1);
    }

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CPropPatchRequest::RemoveProperty
// --------------------------------------------------------------------------------
STDMETHODIMP CPropPatchRequest::RemoveProperty(
                                    DWORD dwNamespaceID, 
                                    LPCSTR pszPropertyName)
{
    LPSTR pszPrefixedName = NULL;
    HRESULT hr = S_OK;

    if (NULL == pszPropertyName || dwNamespaceID > c_dwMaxNamespaceID + m_dna.m_saNamespaces.Length())
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    pszPrefixedName = m_dna.AllocExpandedName(dwNamespaceID, pszPropertyName);
    if (NULL == pszPrefixedName)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    
    // if the namespace is one of the known namespaces, mark it in
    // the array so that we can include the namespace directive in the
    // generated xml
    if (dwNamespaceID <= c_dwMaxNamespaceID)
        m_dna.m_rgbNsUsed[dwNamespaceID] = TRUE;

    hr = m_saRemovePropNames.Adopt(pszPrefixedName);

exit:
    return hr;    
}

// --------------------------------------------------------------------------------
// CPropPatchRequest::GenerateXML
// --------------------------------------------------------------------------------
STDMETHODIMP CPropPatchRequest::GenerateXML(LPSTR *ppszXML)
{
    return GenerateXML(NULL, ppszXML);
}

// --------------------------------------------------------------------------------
// CPropPatchRequest::GenerateXML
// --------------------------------------------------------------------------------
STDMETHODIMP CPropPatchRequest::GenerateXML(LPHTTPTARGETLIST pTargets, LPSTR *ppszXML)
{
    const DWORD c_dwLocalBufferSize = 256;

    HRESULT         hr = S_OK;
    CByteStream     stream;
    ULONG           cEntries;
    LPCSTR          pszName = NULL;
    LPCSTR          pszValue = NULL;
    ULONG           i;
    DWORD           dwIndex;
    DWORD           cbStr1, cbStr2;

    if (NULL == ppszXML)
        return E_INVALIDARG;

    *ppszXML= NULL;

    // write the DAV header
    if (m_fSpecify1252)
        FAIL_EXIT_STREAM_WRITE(stream, c_szXML1252Head);
    else
        FAIL_EXIT_STREAM_WRITE(stream, c_szXMLHead);

    // write out the proppatch header
    FAIL_EXIT_STREAM_WRITE(stream, c_szPropPatchHead);

	// write out namespace directives using the new form
    FAIL_EXIT(hr = m_dna.WriteNamespaces(&stream));

    FAIL_EXIT_STREAM_WRITE(stream, c_szXMLCloseElement);
    
    // write out the targets
    if (NULL != pTargets && pTargets->cTarget > 0)
    {
        cbStr1 = lstrlen(c_szHrefHead);
        cbStr2 = lstrlen(c_szHrefTail);

        FAIL_EXIT_STREAM_WRITE(stream, c_szTargetHead);
        
        // write out the targets
        for (dwIndex = 0; dwIndex < pTargets->cTarget; dwIndex++)
        {
            FAIL_EXIT(hr = stream.Write(c_szHrefHead, cbStr1, NULL));

            FAIL_EXIT_STREAM_WRITE(stream, pTargets->prgTarget[dwIndex]);

            FAIL_EXIT(hr = stream.Write(c_szHrefTail, cbStr2, NULL));
        }
        FAIL_EXIT_STREAM_WRITE(stream, c_szTargetTail);
    }

    // write out the "set" properties
    cEntries = m_saPropNames.Length();
    if (cEntries > 0)
    {
        // write the set header
        FAIL_EXIT_STREAM_WRITE(stream, c_szPropPatchSetHead);

        for (i = 0; i < cEntries; ++i)
        {
            FAIL_EXIT_STREAM_WRITE(stream, c_szCRLFTabTabTabOpenElement);

            pszName = m_saPropNames.GetByIndex(i);
            if (NULL == pszName)
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            FAIL_EXIT_STREAM_WRITE(stream, pszName);

            FAIL_EXIT_STREAM_WRITE(stream, c_szXMLCloseElement);

            pszValue = m_saPropValues.GetByIndex(i);
            if (NULL == pszValue)
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            FAIL_EXIT_STREAM_WRITE(stream, pszValue);

            FAIL_EXIT_STREAM_WRITE(stream, c_szXMLOpenTermElement);
            FAIL_EXIT_STREAM_WRITE(stream, pszName);

            FAIL_EXIT_STREAM_WRITE(stream, c_szXMLCloseElement);
        }

        FAIL_EXIT_STREAM_WRITE(stream, c_szPropPatchSetTail);
    }

    // write out the remove properties
    cEntries = m_saRemovePropNames.Length();
    if (cEntries > 0)
    {
        // write the remove header
        FAIL_EXIT_STREAM_WRITE(stream, c_szPropPatchRemoveHead);

        for (i = 0; i < cEntries; ++i)
        {
            FAIL_EXIT_STREAM_WRITE(stream, c_szCRLFTabTabTabOpenElement);

            pszName = m_saRemovePropNames.GetByIndex(i);
            if (NULL == pszName)
            {
                hr = E_OUTOFMEMORY;
                goto exit;
            }

            FAIL_EXIT_STREAM_WRITE(stream, pszName);

            FAIL_EXIT_STREAM_WRITE(stream, c_szXMLCloseTermElement);
        }

        FAIL_EXIT_STREAM_WRITE(stream, c_szPropPatchRemoveTail);
    }

    FAIL_EXIT_STREAM_WRITE(stream, c_szPropPatchTailCRLF);

    hr = stream.HrAcquireStringA(NULL, ppszXML, ACQ_DISPLACE);

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// CPropFindRequest::CPropFindRequest
// --------------------------------------------------------------------------------
CPropFindRequest::CPropFindRequest(void) :
    m_cRef(1)
{
}

// --------------------------------------------------------------------------------
// IUnknown Methods
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// CPropFindRequest::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CPropFindRequest::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr = S_OK;

    // Validate params
    if (NULL == ppv)
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // Initialize params
    *ppv = NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = ((IUnknown *)(IPropFindRequest *)this);
    else if (IID_IPropFindRequest == riid)
        *ppv = ((IPropFindRequest *)this);

    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    hr = TrapError(E_NOINTERFACE);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPropFindRequest::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropFindRequest::AddRef(void) 
{
	return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CPropFindRequest::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropFindRequest::Release(void) 
{
	if (0 != --m_cRef)
		return m_cRef;
	delete this;
	return 0;
}

// ----------------------------------------------------------------------------
// IDAVNamespaceArbiter methods
// ----------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// CPropFindRequest::CPropPatchRequest::AddNamespace
// --------------------------------------------------------------------------------
STDMETHODIMP CPropFindRequest::AddNamespace(LPCSTR pszNamespace, DWORD *pdwNamespaceID)
{
    return m_dna.AddNamespace(pszNamespace, pdwNamespaceID);    
}

// --------------------------------------------------------------------------------
// CPropFindRequest::GetNamespaceID
// --------------------------------------------------------------------------------
STDMETHODIMP CPropFindRequest::GetNamespaceID(LPCSTR pszNamespace, DWORD *pdwNamespaceID)
{
    return m_dna.GetNamespaceID(pszNamespace, pdwNamespaceID);
}

// --------------------------------------------------------------------------------
// CPropFindRequest::GetNamespacePrefix
// --------------------------------------------------------------------------------
STDMETHODIMP CPropFindRequest::GetNamespacePrefix(DWORD dwNamespaceID, LPSTR *ppszNamespacePrefix)
{
    return m_dna.GetNamespacePrefix(dwNamespaceID, ppszNamespacePrefix);
}

// --------------------------------------------------------------------------------
// IPropFindRequest Methods
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// CPropFindRequest::AddProperty
// --------------------------------------------------------------------------------
STDMETHODIMP CPropFindRequest::AddProperty(DWORD dwNamespaceID, LPCSTR pszPropertyName)
{
    const DWORD c_dwMaxIntLength = 10;
    LPSTR pszPrefixedName = NULL;

    // Validate Params
    if (NULL == pszPropertyName || dwNamespaceID > c_dwMaxNamespaceID + m_dna.m_saNamespaces.Length())
        return E_INVALIDARG;

    pszPrefixedName = m_dna.AllocExpandedName(dwNamespaceID, pszPropertyName);
    if (NULL == pszPrefixedName)
        return E_OUTOFMEMORY;

    // if the namespace is one of the known namespaces, mark
    // the array so that we can include the namespace directive
    // in the generated xml.
    if (dwNamespaceID <= c_dwMaxNamespaceID)
        m_dna.m_rgbNsUsed[dwNamespaceID] = TRUE;

    m_saProperties.Adopt(pszPrefixedName);

    return S_OK;
}

// --------------------------------------------------------------------------------
// CPropFindRequest::GenerateXML
// --------------------------------------------------------------------------------
STDMETHODIMP CPropFindRequest::GenerateXML(LPSTR *ppszXML)
{
    const DWORD c_dwLocalBufferSize = 256;

    HRESULT         hr = S_OK;
    CByteStream     stream;
    ULONG           cbLength = 0;
    ULONG           cEntries;
    ULONG           i;
    LPCSTR          pszProperty;

    if (NULL == ppszXML)
        return E_INVALIDARG;

    *ppszXML = NULL;

    // write the DAV header
    if (FAILED(hr = stream.Write(c_szXMLHead, lstrlen(c_szXMLHead), NULL)))
        goto exit;

    // write out the propfind header
    if (FAILED(hr = stream.Write(c_szPropFindHead1, lstrlen(c_szPropFindHead1), NULL)))
        goto exit;

	// write out namespaces using the new form
	if (FAILED(hr = m_dna.WriteNamespaces(&stream)))
		goto exit;

    if (FAILED(hr = stream.Write(c_szPropFindHead2, lstrlen(c_szPropFindHead2), NULL)))
        goto exit;
    
    // write out the properties
    cEntries = m_saProperties.Length();
    for (i = 0; i < cEntries; ++i)
    {
        if (FAILED(hr = stream.Write(c_szCRLFTabTabOpenElement, lstrlen(c_szCRLFTabTabOpenElement), NULL)))
            goto exit;

        // properties are prefixed when they are added to the collection
        pszProperty = m_saProperties.GetByIndex(i);
        if (!pszProperty)
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        if (FAILED(hr = stream.Write(pszProperty, lstrlen(pszProperty), NULL)))
            goto exit;

        if (FAILED(hr = stream.Write(c_szXMLCloseTermElement, lstrlen(c_szXMLCloseTermElement), NULL)))
            goto exit;
    }
    
    if (FAILED(hr = stream.Write(c_szPropFindTail, lstrlen(c_szPropFindTail), NULL)))
        goto exit;
    
    hr = stream.HrAcquireStringA(NULL, ppszXML, ACQ_DISPLACE);

exit:
    return hr;
}


// --------------------------------------------------------------------------------
// class CPropFindMultiResponse
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// CPropFindMultiResponse::CPropFindMultiResponse
// --------------------------------------------------------------------------------
CPropFindMultiResponse::CPropFindMultiResponse(void) :
    m_cRef(1),
    m_bDone(FALSE),
    m_ulResponseCapacity(0),
    m_ulResponseLength(0),
    m_rgResponses(NULL)
{
}

// --------------------------------------------------------------------------------
// CPropFindMultiResponse::~CPropFindMultiResponse
// --------------------------------------------------------------------------------
CPropFindMultiResponse::~CPropFindMultiResponse(void)
{
    for (ULONG i = 0; i < m_ulResponseLength; i++)
        SafeRelease(m_rgResponses[i]);

    SafeMemFree(m_rgResponses);
}

// --------------------------------------------------------------------------------
// CPropFindMultiResponse::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CPropFindMultiResponse::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr = S_OK;

    // Validate params
    if (NULL == ppv)
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // Initialize params
    *ppv = NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = ((IUnknown *)(IPropFindRequest *)this);
    else if (IID_IPropFindMultiResponse == riid)
        *ppv = ((IPropFindMultiResponse *)this);

    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    hr = TrapError(E_NOINTERFACE);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPropFindMultiResponse::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropFindMultiResponse::AddRef(void) 
{
	return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CPropFindMultiResponse::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropFindMultiResponse::Release(void) 
{
	if (0 != --m_cRef)
		return m_cRef;
	delete this;
	return 0;
}

// --------------------------------------------------------------------------------
// CPropFindMultiResponse::IsComplete
// --------------------------------------------------------------------------------
STDMETHODIMP_(BOOL) CPropFindMultiResponse::IsComplete(void)
{
    return m_bDone;
}

// --------------------------------------------------------------------------------
// CPropFindMultiResponse::GetLength
// --------------------------------------------------------------------------------
STDMETHODIMP CPropFindMultiResponse::GetLength(ULONG *pulLength)
{
    if (NULL == pulLength)
        return E_INVALIDARG;

    *pulLength = m_ulResponseLength;

    return S_OK;
}

// --------------------------------------------------------------------------------
// CPropFindMultiResponse::GetResponse
// --------------------------------------------------------------------------------
STDMETHODIMP CPropFindMultiResponse::GetResponse(ULONG ulIndex, 
                                                 IPropFindResponse **ppResponse)
{
    if (ulIndex >= m_ulResponseLength || !ppResponse)
        return E_INVALIDARG;

    *ppResponse = m_rgResponses[ulIndex];
    (*ppResponse)->AddRef();

    return S_OK;
}

// --------------------------------------------------------------------------------
// CPropFindMultiResponse::HrAddResponse
// --------------------------------------------------------------------------------
HRESULT CPropFindMultiResponse::HrAddResponse(IPropFindResponse *pResponse)
{
    const ULONG c_dwInitialCapacity = 4;

    HRESULT hr = S_OK;
    IPropFindResponse **ppNewResponses = NULL;
    DWORD dwNewCapacity;

    if (!pResponse)
        return E_INVALIDARG;
    

    if (m_ulResponseLength == m_ulResponseCapacity)
    {
        dwNewCapacity = !m_ulResponseCapacity ? c_dwInitialCapacity : (m_ulResponseCapacity * 2);

        if (!MemAlloc((void **)&ppNewResponses, dwNewCapacity * sizeof(IPropFindResponse *)))
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }
        
        ZeroMemory(ppNewResponses, dwNewCapacity * sizeof(IPropFindResponse *));
        
        // copy the old values over
        if (m_ulResponseCapacity)
            CopyMemory(ppNewResponses, m_rgResponses, min(dwNewCapacity, m_ulResponseCapacity) * sizeof(IPropFindResponse *));

        // free the old buffer
        SafeMemFree(m_rgResponses);

        m_rgResponses = ppNewResponses;
        m_ulResponseCapacity = dwNewCapacity;
    }

    m_rgResponses[m_ulResponseLength++] = pResponse;
    pResponse->AddRef();

exit:
    return hr;
}

// --------------------------------------------------------------------------------
// Class CPropFindResponse
// --------------------------------------------------------------------------------

// --------------------------------------------------------------------------------
// CPropFindResponse::CPropFindResponse
// --------------------------------------------------------------------------------
CPropFindResponse::CPropFindResponse(void) :
    m_cRef(1),
    m_bDone(FALSE),
    m_pszHref(NULL),
    m_pRequest(NULL),
    m_shProperties(),
    m_dwCachedNamespaceID(0),
    m_pszCachedNamespacePrefix(NULL)
{

}

// --------------------------------------------------------------------------------
// CPropFindResponse::~CPropFindResponse
// --------------------------------------------------------------------------------
CPropFindResponse::~CPropFindResponse(void)
{
    if (NULL != m_pszHref)
        MemFree(const_cast<char*>(m_pszHref));
    SafeRelease(m_pRequest);
    SafeMemFree(m_pszCachedNamespacePrefix);
}

// --------------------------------------------------------------------------------
// CPropFindResponse::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CPropFindResponse::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr = S_OK;

    // Validate params
    if (NULL == ppv)
    {
        hr = TrapError(E_INVALIDARG);
        goto exit;
    }

    // Initialize params
    *ppv = NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = ((IUnknown *)(IPropFindResponse *)this);
    else if (IID_IPropFindResponse == riid)
        *ppv = ((IPropFindResponse *)this);

    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    hr = TrapError(E_NOINTERFACE);

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CPropFindResponse::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropFindResponse::AddRef(void) 
{
	return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CPropFindResponse::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPropFindResponse::Release(void) 
{
	if (0 != --m_cRef)
		return m_cRef;
	delete this;
	return 0;
}

// --------------------------------------------------------------------------------
// CPropFindResponse::IsComplete
// --------------------------------------------------------------------------------
STDMETHODIMP_(BOOL) CPropFindResponse::IsComplete(void)
{
    return m_bDone;
}

// --------------------------------------------------------------------------------
// CPropFindResponse::GetHref
// --------------------------------------------------------------------------------
STDMETHODIMP CPropFindResponse::GetHref(LPSTR *pszHref)
{
    if (NULL == pszHref)
        return E_INVALIDARG;

    *pszHref = NULL;

    if (NULL == m_pszHref)
        return E_FAIL;

    *pszHref = PszDupA(m_pszHref);
    if (!*pszHref)
        return E_OUTOFMEMORY;

    return S_OK;
}

// --------------------------------------------------------------------------------
// CPropFindResponse::GetProperty
// --------------------------------------------------------------------------------
STDMETHODIMP CPropFindResponse::GetProperty(
                                    DWORD dwNamespaceID, 
                                    LPSTR pszPropertyName, 
                                    LPSTR *ppszPropertyValue)
{
    char    szLocalPropBuffer[256];
    LPSTR   pszPropBuffer = NULL;
    BOOL    bFreePropBuffer = FALSE;
    LPSTR   pszPrefix = NULL;
    HRESULT hr = S_OK;
    ULONG   ulPrefixLength;
    ULONG   ulPropertyLength;
    LPSTR   pszFoundValue = NULL;

    if (!pszPropertyName)
        return E_INVALIDARG;

    *ppszPropertyValue = NULL;

    // first convert the namespace id into a prefix.
    // to facilitate fast lookups, we cache the most recently
    // seen custom namespace

    if (dwNamespaceID < c_dwMaxDefinedNamespacePrefix)
        pszPrefix = const_cast<char *>(g_rgszNamespacePrefixes[dwNamespaceID]);
    else if (dwNamespaceID == m_dwCachedNamespaceID)
        pszPrefix = m_pszCachedNamespacePrefix;
    else if (m_pRequest)
    {
        if (FAILED(hr = m_pRequest->GetNamespacePrefix(dwNamespaceID, &pszPrefix)))
            goto exit;

        // free the one-deep cache and store the new
        // prefix and ID.
        SafeMemFree(m_pszCachedNamespacePrefix);
        m_dwCachedNamespaceID = dwNamespaceID;
        m_pszCachedNamespacePrefix = pszPrefix;
    }

    ulPrefixLength = lstrlen(pszPrefix);
    ulPropertyLength = lstrlen(pszPropertyName);

    DWORD cchSize = ARRAYSIZE(szLocalPropBuffer);
    if ((ulPrefixLength + ulPropertyLength + (2 * sizeof(TCHAR))) < 256)
    {
        // the combined length is small enough to use
        // the stack-based buffer
        pszPropBuffer = szLocalPropBuffer;
    }
    else
    {
        cchSize = (ulPrefixLength + ulPropertyLength + 2);
        if (!MemAlloc((void **)&pszPropBuffer, cchSize * sizeof(pszPropBuffer[0])))
        {
            hr = E_OUTOFMEMORY;
            goto exit;
        }

        bFreePropBuffer = TRUE;
    }
    
    wnsprintf(pszPropBuffer, cchSize, "%s:%s", pszPrefix, pszPropertyName);

    // XML parser uppercases everything
    CharUpper(pszPropBuffer);

    // now that the property name has been created, look for the
    // value in the property hash table
    if (FAILED(hr = m_shProperties.Find(pszPropBuffer, FALSE, (void **)&pszFoundValue)))
        goto exit;
    
    *ppszPropertyValue = PszDupA(pszFoundValue);
    if (NULL == *ppszPropertyValue)
        hr = E_OUTOFMEMORY;

exit:
    if (bFreePropBuffer)
        SafeMemFree(pszPropBuffer);

    return hr;
}

// --------------------------------------------------------------------------------
// CPropFindResponse::HrInitPropFindResponse
// --------------------------------------------------------------------------------
HRESULT CPropFindResponse::HrInitPropFindResponse(IPropFindRequest *pRequest)
{
    if (NULL == pRequest)
        return E_INVALIDARG;
    
    IxpAssert(!m_pRequest);
    
    HRESULT hr = S_OK;

    m_pRequest = pRequest;
    m_pRequest->AddRef();

    hr = m_shProperties.Init(17, TRUE);

    return hr;
}

// --------------------------------------------------------------------------------
// CPropFindResponse::HrAdoptHref
// --------------------------------------------------------------------------------
HRESULT CPropFindResponse::HrAdoptHref(LPCSTR pszHref)
{
    if (NULL == pszHref)
        return E_INVALIDARG;

    IxpAssert(!m_pszHref);
    m_pszHref = pszHref;

    return S_OK;
}

// --------------------------------------------------------------------------------
// CPropFindResponse::HrAdoptProperty
// --------------------------------------------------------------------------------
HRESULT CPropFindResponse::HrAdoptProperty(LPCSTR pszKey, LPCSTR pszValue)
{
    if (!pszKey || !pszValue)
        return E_INVALIDARG;

    return m_shProperties.Insert(const_cast<char *>(pszKey), const_cast<char *>(pszValue), NOFLAGS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\range.cpp ===
//
// RANGE.CPP
//
// 2-20-96: (EricAn)
//          Hacked from the Route66 source tree, eliminated stuff we don't use.
//          Original copyright below - where did this thing come from?
//

// -*- C -*-
//
//  Copyright 1992 Software Innovations, Inc.
//
//  $Source: D:\CLASS\SOURCE\range.c-v $
//  $Author: martin $
//  $Date: 92/07/15 05:09:24 $
//  $Revision: 1.1 $
//
//

#include "pch.hxx"
#include "range.h"
#include "dllmain.h"
#include <shlwapi.h>

// QUANTUM defines the number of m_rangeTable cells to be allocated at
//   one time.  Whenever the m_rangeTable becomes full, it is expanded
//   by QUANTUM range cells.  m_rangeTable's never shrink.
const int QUANTUM = 64;


inline int inRange(RangeType r, ULONG x) { return ((x>=r.low) && (x<=r.high)); };

CRangeList::CRangeList()
{
    DllAddRef();
    m_numRanges = 0;
    m_rangeTableSize = 0;
    m_rangeTable = NULL;
    m_lRefCount = 1;
}

CRangeList::~CRangeList()
{
    Assert(0 == m_lRefCount);

    if (m_rangeTable)
        MemFree(m_rangeTable);

    DllRelease();
}


HRESULT STDMETHODCALLTYPE CRangeList::QueryInterface(REFIID iid, void **ppvObject)
{
    HRESULT hrResult;

    Assert(m_lRefCount > 0);
    Assert(NULL != ppvObject);

    // Init variables, check the arguments
    hrResult = E_NOINTERFACE;
    if (NULL == ppvObject)
        goto exit;

    *ppvObject = NULL;

    // Find a ptr to the interface
    if (IID_IUnknown == iid)
        *ppvObject = (IUnknown *) this;

    if (IID_IRangeList == iid)
        *ppvObject = (IRangeList *) this;

    // If we returned an interface, AddRef it
    if (NULL != *ppvObject) {
        ((IUnknown *)*ppvObject)->AddRef();
        hrResult = S_OK;
    }

exit:
    return hrResult;
} // QueryInterface



//***************************************************************************
// Function: AddRef
//
// Purpose:
//   This function should be called whenever someone makes a copy of a
// pointer to this object. It bumps the reference count so that we know
// there is one more pointer to this object, and thus we need one more
// release before we delete ourselves.
//
// Returns:
//   A ULONG representing the current reference count. Although technically
// our reference count is signed, we should never return a negative number,
// anyways.
//***************************************************************************
ULONG STDMETHODCALLTYPE CRangeList::AddRef(void)
{
    Assert(m_lRefCount > 0);

    m_lRefCount += 1;

    DOUT ("CRangeList::AddRef, returned Ref Count=%ld", m_lRefCount);
    return m_lRefCount;
} // AddRef



//***************************************************************************
// Function: Release
//
// Purpose:
//   This function should be called when a pointer to this object is to
// go out of commission. It knocks the reference count down by one, and
// automatically deletes the object if we see that nobody has a pointer
// to this object.
//
// Returns:
//   A ULONG representing the current reference count. Although technically
// our reference count is signed, we should never return a negative number,
// anyways.
//***************************************************************************
ULONG STDMETHODCALLTYPE CRangeList::Release(void)
{
    Assert(m_lRefCount > 0);
    
    m_lRefCount -= 1;
    DOUT("CRangeList::Release, returned Ref Count = %ld", m_lRefCount);

    if (0 == m_lRefCount) {
        delete this;
        return 0;
    }
    else
        return m_lRefCount;
} // Release




HRESULT STDMETHODCALLTYPE CRangeList::IsInRange(const ULONG value)
{
    Assert(m_lRefCount > 0);
    
    for (int i=0; i<m_numRanges; i++)
        if (inRange(m_rangeTable[i], value))
            return S_OK;
    return S_FALSE;
}

HRESULT STDMETHODCALLTYPE CRangeList::MinOfRange(const ULONG value,
                                                 ULONG *pulMinOfRange)
{
    Assert(m_lRefCount > 0);
    Assert(NULL != pulMinOfRange);

    *pulMinOfRange = RL_RANGE_ERROR;
    if (RL_RANGE_ERROR == value)
        return S_OK; // No need to loop through the ranges

    for (register int i=0; i<m_numRanges; i++) {
        if (inRange(m_rangeTable[i], value)) {
            *pulMinOfRange = m_rangeTable[i].low;
            break;
        } // if
    } // for

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRangeList::MaxOfRange(const ULONG value,
                                                 ULONG *pulMaxOfRange)
{
    Assert(m_lRefCount > 0);
    Assert(NULL != pulMaxOfRange);

    *pulMaxOfRange = RL_RANGE_ERROR;
    if (RL_RANGE_ERROR == value)
        return S_OK; // No need to loop through the ranges

    for (register int i=0; i<m_numRanges; i++) {
        if (inRange(m_rangeTable[i], value)) {
            *pulMaxOfRange = m_rangeTable[i].high;
            break;
        } // if
    } // for

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRangeList::Max(ULONG *pulMax)
{
    Assert(m_lRefCount > 0);
    Assert(NULL != pulMax);
    
    if (m_numRanges==0)
        *pulMax = RL_RANGE_ERROR;
    else
        *pulMax = m_rangeTable[m_numRanges-1].high;

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRangeList::Min(ULONG *pulMin)
{
    Assert(m_lRefCount > 0);
    Assert(NULL != pulMin);
    
    if (m_numRanges==0)
        *pulMin = RL_RANGE_ERROR;
    else
        *pulMin = m_rangeTable[0].low;

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRangeList::Save(LPBYTE *ppb, ULONG *pcb)
{
    Assert(m_lRefCount > 0);
    Assert(ppb);
    Assert(pcb);

    *pcb = m_numRanges * sizeof(RangeType);
    if (*pcb)
        {
        if (!MemAlloc((LPVOID*)ppb, *pcb))
            return E_OUTOFMEMORY;
        CopyMemory(*ppb, m_rangeTable, *pcb);
        }
    else
        *ppb = NULL;

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRangeList::Load(LPBYTE pb, const ULONG cb)
{
    Assert(m_lRefCount > 0);
    
    m_numRanges = m_rangeTableSize = cb / sizeof(RangeType);
    if (m_rangeTable)
        MemFree(m_rangeTable);
    m_rangeTable = (RangeType *)pb;

    return S_OK;
}


HRESULT STDMETHODCALLTYPE CRangeList::AddSingleValue(const ULONG value)
{
    Assert(m_lRefCount > 0);
    
    RangeType r = { value, value };
    return AddRangeType(r);
}

HRESULT STDMETHODCALLTYPE CRangeList::AddRange(const ULONG low, const ULONG high)
{
    Assert(m_lRefCount > 0);
    
    RangeType r = { low, high };
    return AddRangeType(r);
}

HRESULT STDMETHODCALLTYPE CRangeList::AddRangeList(const IRangeList *prl)
{
    Assert(m_lRefCount > 0);
    AssertSz(FALSE, "Not implemented, probably never will be");
    return E_NOTIMPL;
}


HRESULT CRangeList::AddRangeType(const RangeType range)
{
    int  possibleLoc;
    int  insertPosition;

    Assert(m_lRefCount > 0);
    
    if (range.low > range.high)
        {
        DOUTL(2, "Empty range passed to AddRange()");
        return E_INVALIDARG;
        }

    if (m_numRanges==0) 
        {
        if (m_rangeTableSize == 0)
            if (!Expand())
                return E_OUTOFMEMORY;
        m_numRanges = 1;
        CopyMemory(&m_rangeTable[0], &range, sizeof(RangeType));
        } 
    else 
        {
        possibleLoc = BinarySearch(range.low);
        if (!((possibleLoc > -1) &&
              (inRange(m_rangeTable[possibleLoc], range.low)) &&
              (inRange(m_rangeTable[possibleLoc], range.high)))) 
            {
            insertPosition = possibleLoc + 1;
            if (m_numRanges == m_rangeTableSize)
                if (!Expand())
                    return E_OUTOFMEMORY;
            ShiftRight(insertPosition, 1);
            CopyMemory(&m_rangeTable[insertPosition], &range, sizeof(RangeType));
            if (insertPosition > 0)
                SubsumeDown(insertPosition);
            if (insertPosition < m_numRanges)
                SubsumeUpwards(insertPosition);
            }
        }
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CRangeList::DeleteSingleValue(const ULONG value)
{
    Assert(m_lRefCount > 0);
    
    RangeType r = { value, value };
    return DeleteRangeType(r);
}

HRESULT STDMETHODCALLTYPE CRangeList::DeleteRange(const ULONG low, const ULONG high)
{
    Assert(m_lRefCount > 0);
    
    RangeType r = { low, high };
    return DeleteRangeType(r);
}

HRESULT STDMETHODCALLTYPE CRangeList::DeleteRangeList(const IRangeList *prl)
{
    Assert(m_lRefCount > 0);
    
    AssertSz(FALSE, "Not implemented, probably never will be");
    return E_NOTIMPL;
}

HRESULT CRangeList::DeleteRangeType(const RangeType range)
{
    int lowEndChange;
    int highEndChange;

    Assert(m_lRefCount > 0);
    
    if (range.low > range.high)
        {
        DOUTL(2, "Empty range passed to DeleteRange()");
        return E_INVALIDARG;
        }

    lowEndChange = BinarySearch(range.low);
    highEndChange = BinarySearch(range.high);

    if ((lowEndChange != -1) && (highEndChange == lowEndChange))  
        {
        if (inRange(m_rangeTable[lowEndChange], range.low)) 
            {
            if (inRange(m_rangeTable[lowEndChange], range.high)) 
                {
                if ((m_rangeTable[lowEndChange].low == range.low) &&
                    (m_rangeTable[lowEndChange].high == range.high)) 
                    {
                    if (lowEndChange == (m_numRanges-1))  
                        {
                        m_numRanges--;
                        } 
                    else 
                        {
                        ShiftLeft(lowEndChange + 1, 1);
                        }
                    } 
                else 
                    {
                    if (m_rangeTable[lowEndChange].low == range.low)  
                        {
                        m_rangeTable[lowEndChange].low = range.high + 1;
                        } 
                    else 
                        {
                        if (m_rangeTable[lowEndChange].high == range.high) 
                            {
                            Assert(range.low > 0);
                            m_rangeTable[lowEndChange].high = range.low - 1;
                            } 
                        else 
                            {
                            // the range to be deleted is properly contained in 
                            //  m_rangeTable[lowEndChange]
                            if (m_numRanges == m_rangeTableSize)
                                if (!Expand())
                                    return E_OUTOFMEMORY;
                            ShiftRight(lowEndChange + 1, 1);
                            m_rangeTable[lowEndChange + 1].low = range.high + 1;
                            m_rangeTable[lowEndChange + 1].high = m_rangeTable[lowEndChange].high;
                            Assert(range.low > 0);    
                            m_rangeTable[lowEndChange].high = range.low - 1;
                            }
                        }
                    }
                } 
            else 
                {
                // range.low is in m_rangeTable[lowEndChange], but range.high
                //  is not
                if (m_rangeTable[lowEndChange].low == range.low) 
                    {
                    ShiftLeft(lowEndChange + 1, 1);
                    } 
                else 
                    {
                    Assert(range.low > 0);
                    m_rangeTable[lowEndChange].high = range.low - 1;
                    }
                }
            }  // of the cases where range.low actually in m_rangeTable[lowEndChange]
        } 
    else 
        { // of the cases where highEndChange == lowEndChange
        if (lowEndChange != -1)  
            {
            if (inRange(m_rangeTable[lowEndChange], range.low))  
                {
                if (range.low == m_rangeTable[lowEndChange].low) 
                    {
                    lowEndChange = lowEndChange - 1;
                    } 
                else 
                    {
                    Assert(range.low > 0);
                    m_rangeTable[lowEndChange].high = range.low - 1;
                    }
                }
            }
        if (highEndChange != -1)  
            {
            if (inRange(m_rangeTable[highEndChange], range.high))  
                {
                if (range.high == m_rangeTable[highEndChange].high)  
                    {
                    highEndChange = highEndChange + 1;
                    } 
                else 
                    {
                    m_rangeTable[highEndChange].low = range.high + 1;
                    }
                } 
            else 
                {
                highEndChange++;
                }
            }
        if (!(lowEndChange > highEndChange)) 
            {
            // (0 <= lowEndChange < m_numRanges => m_rangeTable[lowEndChange] has received
            //                 any requisite adjustments and is to be kept)
            //  and (0 <= highEndChange < m_numRanges => m_rangeTable[highEndChange]
            //                 has received any requistie adjs. and is a keeper)
            //  and "forall" i [ lowEndChange < i < highEndChange => 
            //                   m_rangeTable[i] is to be overwritten]
            if (highEndChange >= m_numRanges)  
                {
                m_numRanges = lowEndChange + 1;
                } 
            else 
                {
                if ((highEndChange - lowEndChange - 1) > 0)  
                    {
                    ShiftLeft(highEndChange, (highEndChange-lowEndChange-1));
                    }
                }
            } //  else there's a problem with this code...
        }
    return S_OK;
}


HRESULT STDMETHODCALLTYPE CRangeList::Next(const ULONG current, ULONG *pulNext)
{
    int loc;

    Assert(m_lRefCount > 0);
    Assert(NULL != pulNext);
    
    if (m_numRanges == 0)
        {
        *pulNext = RL_RANGE_ERROR;
        return S_OK;
        }

    if ((loc = BinarySearch(current)) == -1)
        {
        *pulNext = m_rangeTable[0].low;
        return S_OK;
        }
    else if (loc == (m_numRanges-1))
        {
        if (inRange(m_rangeTable[m_numRanges-1], current))
            {
            if (inRange(m_rangeTable[m_numRanges-1], current + 1))
                {
                *pulNext = current + 1;
                return S_OK;
                }
            else
                {
                *pulNext = RL_RANGE_ERROR;
                return S_OK;
                }
            }
        else
            {
            *pulNext = RL_RANGE_ERROR;
            return S_OK;
            }
        }
    else // case where loc == m_numRanges-1
        {
        // 1 <= loc < m_numRanges
        if (inRange(m_rangeTable[loc], current))
            {
            if (inRange(m_rangeTable[loc], current + 1))
                {
                *pulNext = current + 1;
                return S_OK;
                }
            else
                {
                *pulNext = m_rangeTable[loc + 1].low;
                return S_OK;
                }
            }
        else
            {
            *pulNext = m_rangeTable[loc + 1].low;
            return S_OK;
            }
        }
}

HRESULT STDMETHODCALLTYPE CRangeList::Prev(const ULONG current, ULONG *pulPrev)
{
    int loc;

    Assert(m_lRefCount > 0);
    Assert(NULL != pulPrev);
    
    if (m_numRanges == 0)
        {
        *pulPrev = RL_RANGE_ERROR;
        return S_OK;
        }

    if ((loc = BinarySearch(current)) == -1) 
        {
        *pulPrev = RL_RANGE_ERROR;
        return S_OK;
        } 
    else if (loc == 0)
        {
        if (inRange(m_rangeTable[0], current))
            {
            if (current > 0 && inRange(m_rangeTable[0], current - 1))
                {
                *pulPrev = current - 1;
                return S_OK;
                }
            else
                {
                *pulPrev = RL_RANGE_ERROR;
                return S_OK;
                }
            }
        else
            {
            *pulPrev = m_rangeTable[0].high;
            return S_OK;
            }
        }
    else
        {
        // 1 < loc <= m_numRanges
        if (inRange(m_rangeTable[loc], current))
            {
            if (current > 0 && inRange(m_rangeTable[loc], current - 1))
                {
                *pulPrev = current - 1;
                return S_OK;
                }
            else
                {
                *pulPrev = m_rangeTable[loc-1].high;
                return S_OK;
                }
            }
        else
            {
            *pulPrev = m_rangeTable[loc].high;
            return S_OK;
            }
        }
}

HRESULT STDMETHODCALLTYPE CRangeList::Cardinality(ULONG *pulCardinality)
{
    ULONG card = 0;

    Assert(m_lRefCount > 0);
    Assert(NULL != pulCardinality);
    
    for (int i=0 ; i<m_numRanges ; i++)
        card += (m_rangeTable[i].high - m_rangeTable[i].low + 1);

    *pulCardinality = card;
    return S_OK;
}



HRESULT STDMETHODCALLTYPE CRangeList::CardinalityFrom(const ULONG ulStartPoint,
                                                      ULONG *pulCardinalityFrom)
{
    ULONG ulNumMsgsInRange;
    int i;

    Assert(m_lRefCount > 0);
    Assert(NULL != pulCardinalityFrom);
    
    // Initialize variables
    ulNumMsgsInRange = 0;
    *pulCardinalityFrom = 0;

    // Find the range where ulStartPoint lives
    i = BinarySearch(ulStartPoint + 1);
    if (-1 == i || ulStartPoint > m_rangeTable[i].high)
        return S_OK; // ulStartPoint + 1 is not in the range

    // If ulStartPoint is at start or middle of range, add incomplete range to total
    if (ulStartPoint >= m_rangeTable[i].low &&
        ulStartPoint <= m_rangeTable[i].high) {
        // Add incomplete range to total - Don't include ulStartPoint!
        ulNumMsgsInRange += m_rangeTable[i].high - ulStartPoint;
        i += 1;
    }

    // Add the remaining WHOLE ranges
    for (; i < m_numRanges; i++)
        ulNumMsgsInRange += m_rangeTable[i].high - m_rangeTable[i].low + 1;

    *pulCardinalityFrom = ulNumMsgsInRange;
    return S_OK;
} // Cardinality (with start point arg)



int CRangeList::BinarySearch(const ULONG value) const
{
//  We are looking for `value' in the m_rangeTable.  If value is in the
//  set of valid ranges, we return the array subscript of the range
//  containing `value'.  If `value' is not contained in any of the 
//  ranges then return `loc' where
//        (0 <= loc < m_numRanges =>
//                 (m_rangeTable[loc].low < rangeNum)
//           "and" (m_rangeTable[loc + 1].low > rangeNum))
//    "and" (loc = m_numRanges => rangeNum > m_rangeTable[m_numRanges].low)
//    "and" (loc = -1 =>     m_numRanges = 0
//                     "or" rangeNum < m_rangeTable[0].low) }
    long low, high, mid;
    int loc = -1;

    Assert(m_lRefCount > 0);

    if (m_numRanges == 0)
        return -1;

    if (value < m_rangeTable[0].low)
        return -1;

    low = 0;
    high = m_numRanges - 1;
    while (low <= high) {
        // inv: low < high - 1, and if rngNum is any where in m_rangeTable, it is in
        //      the range from m_rangeTable[low] to m_rangeTable[high]
        mid = (low + high) / 2;
        if ((value >= m_rangeTable[mid].low) && 
            ((mid == (m_numRanges-1)) || (value < m_rangeTable[mid + 1].low))) 
            {
            loc = mid;
            high = low - 1;
            } 
        else 
            {
            if (value > m_rangeTable[mid].low)
                low = mid + 1;
            else
                high = mid - 1;
            }
    }
    return loc;
}

// Expand() will grow the m_rangeTable by QUANTUM range cells.
BOOL CRangeList::Expand()
{
    RangeType *newRangeTable;

    Assert(m_lRefCount > 0);
    
    if (!MemAlloc((LPVOID*)&newRangeTable, (m_rangeTableSize + QUANTUM) * sizeof(RangeType)))
        return FALSE;

    m_rangeTableSize += QUANTUM;
    if (m_rangeTable) 
        {
        if (m_numRanges > 0)
            CopyMemory(newRangeTable, m_rangeTable, m_numRanges * sizeof(RangeType));
        MemFree(m_rangeTable);
        }
    m_rangeTable = newRangeTable;
    return TRUE;
}

void CRangeList::ShiftLeft(int low, int distance)
{
    Assert(m_lRefCount > 0);
    
    if (m_numRanges - low)
        MoveMemory(&m_rangeTable[low-distance], &m_rangeTable[low], (m_numRanges-low)*sizeof(RangeType));
    m_numRanges -= distance;
}

void CRangeList::ShiftRight(int low, int distance)
{
    Assert(m_lRefCount > 0);
    
    if (m_numRanges - low)
        MoveMemory(&m_rangeTable[low+distance], &m_rangeTable[low], (m_numRanges-low)*sizeof(RangeType));
    m_numRanges += distance;
}

// pre: (m_rangeTable[anchorPosition] has probably just been added to m_rangeTable.)
//          1 <= anchorPosition <= m_numRanges
//      and (   anchorPosition = 1
//           or (m_rangeTable[anchorPosition].low >
//                 m_rangeTable[anchorPosition - 1].high) )
// post: No overlapping or contiguous ranges from 1 to m_numRanges. }
void CRangeList::SubsumeUpwards(const int anchor)
{
    int posOfLargerLow;
    int copyDownDistance;
    int copyPos;

    Assert(m_lRefCount > 0);
    
    posOfLargerLow = anchor + 1;
    while ((posOfLargerLow < m_numRanges) && 
           (m_rangeTable[posOfLargerLow].low <= m_rangeTable[anchor].high + 1))
        posOfLargerLow++;

    if (posOfLargerLow == m_numRanges) 
        {
        if (m_rangeTable[m_numRanges-1].high > m_rangeTable[anchor].high)
            m_rangeTable[anchor].high = m_rangeTable[m_numRanges-1].high;
        m_numRanges = anchor + 1;
        } 
    else 
        {
        // posOfLargerLow now indexes the first element of m_rangeTable, looking from
        // m_rangeTable[anchor], with .low > m_rangeTable[anchor].high + 1
        if (posOfLargerLow > (anchor + 1)) 
            {
            if (m_rangeTable[posOfLargerLow - 1].high > m_rangeTable[anchor].high) 
                m_rangeTable[anchor].high = m_rangeTable[posOfLargerLow - 1].high;
            copyDownDistance = posOfLargerLow - anchor - 1;
            copyPos = posOfLargerLow;
            while (copyPos < m_numRanges) 
                {
                m_rangeTable[copyPos - copyDownDistance] = m_rangeTable[copyPos];
                copyPos = copyPos + 1;
                }
            m_numRanges -= copyDownDistance;
            }
        }
}

void CRangeList::SubsumeDown(int& anchor)
{
    int posOfSmallerHigh;
    int copyDownDistance;
    int copyPos;

    Assert(m_lRefCount > 0);
    
    posOfSmallerHigh = anchor - 1;
    while ((posOfSmallerHigh >= 0) &&
           (m_rangeTable[posOfSmallerHigh].high + 1 >= m_rangeTable[anchor].low)) 
        {
        posOfSmallerHigh--;
        }

    if (posOfSmallerHigh < 0) 
        {
        if (m_rangeTable[0].low < m_rangeTable[anchor].low)
            m_rangeTable[anchor].low = m_rangeTable[0].low;
        }

    // posOfSmallerHigh either has value 0 or subscripts the first element of
    //  m_rangeTable, looking down from anchor, with a .high that is
    //  less than m_rangeTable[anchor].low - 1.
    if (m_rangeTable[posOfSmallerHigh + 1].low < m_rangeTable[anchor].low)
        m_rangeTable[anchor].low = m_rangeTable[posOfSmallerHigh + 1].low;
    copyDownDistance = anchor - posOfSmallerHigh - 1;
    if (copyDownDistance > 0) 
        {
        copyPos = anchor;
        while (copyPos < m_numRanges) 
            {
            m_rangeTable[copyPos - copyDownDistance] = m_rangeTable[copyPos];
            copyPos++;
            }
        m_numRanges -= copyDownDistance;
        anchor -= copyDownDistance;
        }
}



//***************************************************************************
// Function: RangeToIMAPString
//
// Purpose:
//   This function outputs the rangelist as an IMAP message set, suitable
// for use in IMAP commands.
//
// Arguments:
//   LPSTR *ppszDestination [out] - an IMAP message set string is
//     returned here. It is the responsibility of the caller to CoTaskMemFree
//     this buffer when he is done with it. Pass in NULL if not interested.
//   LPDWORD pdwLengthOfDestination [out] - if successful, this function
//     returns the length of the IMAP msg set returned via pszDestination.
//     Pass in NULL if not interested.
//
// Returns:
//   HRESULT indicating success or failure.
//***************************************************************************
HRESULT STDMETHODCALLTYPE CRangeList::RangeToIMAPString(LPSTR *ppszDestination,
                                                        LPDWORD pdwLengthOfDestination)
{
    int i;
    BOOL bFirstRange;
    CByteStream bstmIMAPString;
    HRESULT hrResult;

    Assert(m_lRefCount > 0);

    // Initialize return values
    if (ppszDestination)
        *ppszDestination = NULL;
    if (pdwLengthOfDestination)
        *pdwLengthOfDestination = 0;

    hrResult = S_OK;
    bFirstRange = TRUE; // Suppress leading comma for first range
    for (i = 0; i < m_numRanges; i += 1) {
        char szTemp[128];
        int iLengthOfTemp;

        // Convert current range to string form
        if (m_rangeTable[i].low == m_rangeTable[i].high)
            iLengthOfTemp = wnsprintf(szTemp + 1, ARRAYSIZE(szTemp) - 1, "%lu", m_rangeTable[i].low);
        else
            iLengthOfTemp = wnsprintf(szTemp + 1, ARRAYSIZE(szTemp) - 1, "%lu:%lu", m_rangeTable[i].low, m_rangeTable[i].high);

        if (FALSE == bFirstRange) {
            szTemp[0] = ','; // Prepend a comma
            iLengthOfTemp += 1; // Include leading comma
        }

        // Append new range to destination buffer (with or without leading comma)
        hrResult = bstmIMAPString.Write(bFirstRange ? szTemp + 1 : szTemp,
            iLengthOfTemp, NULL);
        if (FAILED(hrResult))
            break;

        bFirstRange = FALSE;
    } // for

    if (SUCCEEDED(hrResult))
        hrResult = bstmIMAPString.HrAcquireStringA(pdwLengthOfDestination,
            ppszDestination, ACQ_DISPLACE);

    return hrResult;
} // RangeToIMAPString
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\propfind.h ===
// --------------------------------------------------------------------------------
// propfind.h
// Copyright (c)1998 Microsoft Corporation, All Rights Reserved
// Greg Friedman
// --------------------------------------------------------------------------------

#ifndef __PROPFIND_H
#define __PROPFIND_H

#include "mimeole.h" // for base IHashTable interface
#include "hash.h"

class CByteStream;

const DWORD c_dwMaxNamespaceID = DAVNAMESPACE_CONTACTS;

// --------------------------------------------------------------------------------
// class CStringArray
// Description : CStringArray is a simple utility class that maintains
// an list of strings that are retrievable by index.
// --------------------------------------------------------------------------------
class CStringArray
{
public:
    CStringArray(void);
    ~CStringArray(void);

private:
    CStringArray(const CStringArray& other);
    CStringArray& operator=(const CStringArray& other);

public:
    ULONG   Length(void) { return m_ulLength; }

    HRESULT Add(LPCSTR psz);
    HRESULT Adopt(LPCSTR psz);
    LPCSTR  GetByIndex(ULONG ulIndex);

    HRESULT RemoveByIndex(ULONG ulIndex);

private:
    BOOL    Expand(void);

private:
    LPCSTR  *m_rgpszValues;
    ULONG   m_ulLength;
    ULONG   m_ulCapacity;
};

// wrap a CHash to provide a destructor that deallocates
// string data.
class CStringHash : public CHash
{
public:
    virtual ~CStringHash();
};

class CDAVNamespaceArbiterImp
{
public:
    CDAVNamespaceArbiterImp(void);
    ~CDAVNamespaceArbiterImp(void);

    HRESULT AddNamespace(LPCSTR pszNamespace, DWORD *pdwNamespaceID);
    HRESULT GetNamespaceID(LPCSTR pszNamespace, DWORD *pdwNamespaceID);
    HRESULT GetNamespacePrefix(DWORD dwNamespaceID, LPSTR *ppszNamespacePrefix);

    LPSTR AllocExpandedName(DWORD dwNamespaceID, LPCSTR pszPropertyName);

    HRESULT WriteNamespaces(IStream *pStream);

    BOOL                m_rgbNsUsed[c_dwMaxNamespaceID + 1];    // flags indicating whether the
                                                                // known namespaces are used
    CStringArray        m_saNamespaces;                         // string array of namespaces

private:
    HRESULT _AppendXMLNamespace(IStream *pStream, LPCSTR pszNamespace, DWORD dwNamespaceID, BOOL fWhitespacePrefix);
};

class CPropPatchRequest : public IPropPatchRequest
{
public:
    // ----------------------------------------------------------------------------
    // Construction/Destruction
    // ----------------------------------------------------------------------------
    CPropPatchRequest(void);

    // ----------------------------------------------------------------------------
    // IUnknown methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IDAVNamespaceArbiter methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP AddNamespace(LPCSTR pszNamespace, DWORD *pdwNamespaceID);
    STDMETHODIMP GetNamespaceID(LPCSTR pszNamespace, DWORD *pdwNamespaceID);
    STDMETHODIMP GetNamespacePrefix(DWORD dwNamespaceID, LPSTR *ppszNamespacePrefix);

    // ----------------------------------------------------------------------------
    // IPropPatchRequest methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP SetProperty(DWORD dwNamespaceID, LPCSTR pszPropertyName, LPCSTR pszNewValue);
    STDMETHODIMP RemoveProperty(DWORD dwNamespaceID, LPCSTR pszPropertyName);
    STDMETHODIMP GenerateXML(LPSTR *ppszXML);

    // ----------------------------------------------------------------------------
    // Internal Methods
    // ----------------------------------------------------------------------------
    void         SpecifyWindows1252Encoding(BOOL fSpecify1252) { m_fSpecify1252 = fSpecify1252; }
    STDMETHODIMP GenerateXML(LPHTTPTARGETLIST pTargets, LPSTR *ppszXML);

private:
    BOOL                    m_fSpecify1252;
    CDAVNamespaceArbiterImp m_dna;
    ULONG                   m_cRef;             // Reference Count
    CStringArray            m_saPropNames;      // string array of property names
    CStringArray            m_saPropValues;     // string array of property values
    CStringArray            m_saRemovePropNames;// string array of properties to remove
};

class CPropFindRequest : public IPropFindRequest
{
public:
    // ----------------------------------------------------------------------------
    // Construction/Destruction
    // ----------------------------------------------------------------------------
    CPropFindRequest(void);

    // ----------------------------------------------------------------------------
    // IUnknown methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IDAVNamespaceArbiter methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP AddNamespace(LPCSTR pszNamespace, DWORD *pdwNamespaceID);
    STDMETHODIMP GetNamespaceID(LPCSTR pszNamespace, DWORD *pdwNamespaceID);
    STDMETHODIMP GetNamespacePrefix(DWORD dwNamespaceID, LPSTR *ppszNamespacePrefix);

    // ----------------------------------------------------------------------------
    // IPropFindRequest methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP AddProperty(DWORD dwNamespaceID, LPCSTR pszPropertyName);
    STDMETHODIMP GenerateXML(LPSTR *ppszXML);

private:
    HRESULT AppendXMLNamespace(CByteStream& bs, LPCSTR pszNamespace, DWORD dwNamespaceID);

private:
    CDAVNamespaceArbiterImp m_dna;
    ULONG                   m_cRef;            // Reference Count
    CStringArray            m_saProperties;    // string array of properties
};

class CPropFindMultiResponse : public IPropFindMultiResponse
{
public:
    CPropFindMultiResponse(void);
    ~CPropFindMultiResponse(void);

    // ----------------------------------------------------------------------------
    // IUnknown methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IPropFindMultiStatus methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP_(BOOL) IsComplete(void);
    STDMETHODIMP GetLength(ULONG *pulLength);
    STDMETHODIMP GetResponse(ULONG ulIndex, IPropFindResponse **ppResponse);

    // ----------------------------------------------------------------------------
    // CPropFindMultiStatus methods
    // ----------------------------------------------------------------------------
    BOOL GetDone(void) { return m_bDone; }
    void SetDone(BOOL bDone) { m_bDone = bDone; }

    HRESULT HrAddResponse(IPropFindResponse *pResponse);
    
private:
    ULONG               m_cRef;
    BOOL                m_bDone;
    ULONG               m_ulResponseCapacity;
    ULONG               m_ulResponseLength;
    IPropFindResponse   **m_rgResponses;
};

class CPropFindResponse : public IPropFindResponse
{
public:
    CPropFindResponse(void);
    ~CPropFindResponse(void);

    // ----------------------------------------------------------------------------
    // IUnknown methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // IPropFindResponse methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP_(BOOL) IsComplete(void);
    STDMETHODIMP GetHref(LPSTR *ppszHref);
    STDMETHODIMP GetProperty(DWORD dwNamespaceID, LPSTR pszPropertyName, LPSTR *ppszPropertyValue);

public:
    // ----------------------------------------------------------------------------
    // CPropFindResponse methods
    // ----------------------------------------------------------------------------
    HRESULT HrInitPropFindResponse(IPropFindRequest *pRequest);
    HRESULT HrAdoptHref(LPCSTR pszHref);
    HRESULT HrAdoptProperty(LPCSTR pszKey, LPCSTR pszValue);

private:
    ULONG               m_cRef;
    BOOL                m_bDone;
    LPCSTR              m_pszHref;
    IPropFindRequest    *m_pRequest;
    CStringHash         m_shProperties;
    DWORD               m_dwCachedNamespaceID;
    LPSTR               m_pszCachedNamespacePrefix;
};

#endif // __PROPFIND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\inc\empty.cxx ===
#include <pch.hxx>
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\sicily.cpp ===
//--------------------------------------------------------------------------
// Sicily.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "imnxport.h"
#include "sicily.h"
#include "dllmain.h"
#include "resource.h"
#include "imnxport.h"
#include "strconst.h"
#include <shlwapi.h>
#include "demand.h"

//--------------------------------------------------------------------------
// NTLMSSP_SIGNATURE
//--------------------------------------------------------------------------
#define NTLMSSP_SIGNATURE "NTLMSSP"

//--------------------------------------------------------------------------
// NegotiateFlags
//--------------------------------------------------------------------------
#define NTLMSSP_NEGOTIATE_UNICODE       0x0001  // Text strings are in unicode

//--------------------------------------------------------------------------
// Security Buffer Counts
//--------------------------------------------------------------------------
#define SEC_BUFFER_NUM_NORMAL_BUFFERS       1

//--------------------------------------------------------------------------
// Security Buffer Indexes
//--------------------------------------------------------------------------
#define SEC_BUFFER_CHALLENGE_INDEX          0
#define SEC_BUFFER_USERNAME_INDEX           1
#define SEC_BUFFER_PASSWORD_INDEX           2
#define SEC_BUFFER_NUM_EXTENDED_BUFFERS     3

//--------------------------------------------------------------------------
// NTLM_MESSAGE_TYPE
//--------------------------------------------------------------------------
typedef enum {
    NtLmNegotiate = 1,
    NtLmChallenge,
    NtLmAuthenticate,
    NtLmUnknown
} NTLM_MESSAGE_TYPE;

//--------------------------------------------------------------------------
// STRING
//--------------------------------------------------------------------------
typedef struct _STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWCHAR Buffer;
} STRING, *PSTRING;

//--------------------------------------------------------------------------
// AUTHENTICATE_MESSAGE
//--------------------------------------------------------------------------
typedef struct _AUTHENTICATE_MESSAGE {
    UCHAR Signature[sizeof(NTLMSSP_SIGNATURE)];
    NTLM_MESSAGE_TYPE MessageType;
    STRING LmChallengeResponse;
    STRING NtChallengeResponse;
    STRING DomainName;
    STRING UserName;
    STRING Workstation;
    STRING SessionKey;
    ULONG NegotiateFlags;
} AUTHENTICATE_MESSAGE, *PAUTHENTICATE_MESSAGE;

//--------------------------------------------------------------------------
// Constants
//--------------------------------------------------------------------------
#define CCHMAX_NTLM_DOMAIN      255
#define LOGON_OK		        10000

//--------------------------------------------------------------------------
// String Constants
//--------------------------------------------------------------------------
static const CHAR c_szSecurityDLL[] = "security.dll";
static const CHAR c_szSecur32DLL[]  = "secur32.dll";

//--------------------------------------------------------------------------
// MSN/DPA CleareCredentialsCache Function Prototype
//--------------------------------------------------------------------------
typedef BOOL (WINAPI * PFNCLEANUPCREDENTIALCACHE)(void);

//--------------------------------------------------------------------------
// CREDENTIAL
//--------------------------------------------------------------------------
typedef struct tagCREDENTIAL *LPCREDENTIAL;
typedef struct tagCREDENTIAL {
    CHAR            szServer[CCHMAX_SERVER_NAME];
    CHAR            szUserName[CCHMAX_USERNAME];
    CHAR            szPassword[CCHMAX_PASSWORD];
    CHAR            szDomain[CCHMAX_NTLM_DOMAIN];
    DWORD           cRetry;
    LPCREDENTIAL    pNext;
} CREDENTIAL; 

//--------------------------------------------------------------------------
// SSPIPROMPTINFO
//--------------------------------------------------------------------------
typedef struct tagSSPIPROMPTINFO {
    HRESULT         hrResult;
    LPSSPICONTEXT   pContext;
    ULONG           fContextAttrib;
    PSecBufferDesc  pInDescript;
    PSecBufferDesc  pOutDescript;
    TimeStamp       tsExpireTime;
    PCtxtHandle     phCtxCurrent;
    DWORD           dwFlags;
} SSPIPROMPTINFO, *LPSSPIPROMPTINFO;

//--------------------------------------------------------------------------
// SSPILOGON
//--------------------------------------------------------------------------
typedef struct tagSSPILOGON {
    LPCREDENTIAL    pCredential;
    LPSSPICONTEXT   pContext;
} SSPILOGON, *LPSSPILOGON;

//--------------------------------------------------------------------------
// SSPILOGONFLAGS
//--------------------------------------------------------------------------
typedef DWORD SSPILOGONFLAGS;
#define SSPI_LOGON_RETRY            0x00000001
#define SSPI_LOGON_FLUSH            0x00000002

//--------------------------------------------------------------------------
// Globals
//--------------------------------------------------------------------------
static PSecurityFunctionTable	    g_pFunctions = NULL;
static HINSTANCE                    g_hInstSSPI = NULL;
static LPCREDENTIAL                 g_pCredentialHead=NULL;
static LPSSPIPACKAGE                g_prgPackage=NULL;
static DWORD                        g_cPackages=0;

//--------------------------------------------------------------------------
// base642six
//--------------------------------------------------------------------------
static const int base642six[256] = {
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

//--------------------------------------------------------------------------
// six2base64
//--------------------------------------------------------------------------
static const char six2base64[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

//--------------------------------------------------------------------------
// uu2six
//--------------------------------------------------------------------------
const int uu2six[256] = {
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,
    16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,
    40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
     0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};
     
//--------------------------------------------------------------------------
// six2uu
//--------------------------------------------------------------------------
static const char six2uu[64] = {
    '`','!','"','#','$','%','&','\'','(',')','*','+',',',
    '-','.','/','0','1','2','3','4','5','6','7','8','9',
    ':',';','<','=','>','?','@','A','B','C','D','E','F',
    'G','H','I','J','K','L','M','N','O','P','Q','R','S',
    'T','U','V','W','X','Y','Z','[','\\',']','^','_'
};

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
HRESULT SSPIFlushMSNCredentialCache(void);

//--------------------------------------------------------------------------
// SSPISetBuffer
//--------------------------------------------------------------------------
HRESULT SSPISetBuffer(LPCSTR pszString, SSPIBUFFERTYPE tyBuffer, 
    DWORD cbBuffer, LPSSPIBUFFER pBuffer) 
{
    // Trace
    TraceCall("SSPISetBuffer");

    // No Length Passed In ?
    if (SSPI_STRING == tyBuffer)
    {
        // Get the Length
        pBuffer->cbBuffer = lstrlen(pszString) + 1;

        // Too Long
        if (pBuffer->cbBuffer > CBMAX_SSPI_BUFFER)
            pBuffer->cbBuffer = CBMAX_SSPI_BUFFER;

        // Copy the data
        CopyMemory(pBuffer->szBuffer, pszString, pBuffer->cbBuffer);

        // Stuff a Null
        pBuffer->szBuffer[pBuffer->cbBuffer - 1] = '\0';

        // Loop
        while (pBuffer->cbBuffer >= 2)
        {
            // Not a CRLF
            if ('\r' != pBuffer->szBuffer[pBuffer->cbBuffer - 2] && '\n' != pBuffer->szBuffer[pBuffer->cbBuffer - 2])
                break;

            // Decrement Length
            pBuffer->cbBuffer--;

            // Null Terminate
            pBuffer->szBuffer[pBuffer->cbBuffer - 1] = '\0';
        }
    }

    // Otherwise, set cbBuffer
    else
    {
        // Set cbBuffer
        pBuffer->cbBuffer = min(cbBuffer + 1, CBMAX_SSPI_BUFFER);

        // Null Terminate
        pBuffer->szBuffer[pBuffer->cbBuffer - 1] = '\0';

        // Copy the data
        CopyMemory(pBuffer->szBuffer, pszString, pBuffer->cbBuffer);
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// GetCredentialDlgProc
//--------------------------------------------------------------------------
INT_PTR CALLBACK GetCredentialDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Locals
    LPSSPILOGON     pLogon=(LPSSPILOGON)GetWndThisPtr(hwnd);
    CHAR            szRes[CCHMAX_RES];
    CHAR            szTitle[CCHMAX_RES + CCHMAX_SERVER_NAME];

    // Trace
    TraceCall("GetCredentialDlgProc");
    
    // Handle Message
    switch (uMsg)
    {
    case WM_INITDIALOG:
        // Get the pointer
        pLogon = (LPSSPILOGON)lParam;
        Assert(pLogon);

        // Set pContext hwndLogon
        pLogon->pContext->hwndLogon = hwnd;

        // Set myself to the foreground
        SetForegroundWindow(hwnd);

        // Center remember location
        CenterDialog(hwnd);

	    // Limit Text
        Edit_LimitText(GetDlgItem(hwnd, IDE_USERNAME), CCHMAX_USERNAME - 1);
        Edit_LimitText(GetDlgItem(hwnd, IDE_PASSWORD), CCHMAX_PASSWORD - 1);
        Edit_LimitText(GetDlgItem(hwnd, IDE_DOMAIN), CCHMAX_NTLM_DOMAIN - 1);

        // Set Window Title
        GetWindowText(hwnd, szRes, ARRAYSIZE(szRes));
        wnsprintf(szTitle, ARRAYSIZE(szTitle), "%s - %s", szRes, pLogon->pCredential->szServer);
        SetWindowText(hwnd, szTitle);

        // Set User Name
        Edit_SetText(GetDlgItem(hwnd, IDE_USERNAME), pLogon->pCredential->szUserName);
        Edit_SetText(GetDlgItem(hwnd, IDE_PASSWORD), pLogon->pCredential->szPassword);
        Edit_SetText(GetDlgItem(hwnd, IDE_DOMAIN), pLogon->pCredential->szDomain);

        // Focus
        if (pLogon->pCredential->szUserName[0] == '\0')
            SetFocus(GetDlgItem(hwnd, IDE_USERNAME));
        else 
            SetFocus(GetDlgItem(hwnd, IDE_PASSWORD));

        // Save the pointer
        SetWndThisPtr(hwnd, pLogon);

        // Done
        return(FALSE);

    case WM_COMMAND:
        switch(GET_WM_COMMAND_ID(wParam,lParam))
        {
        case IDCANCEL:
            if (pLogon)
                pLogon->pContext->hwndLogon = NULL;
            EndDialog(hwnd, IDCANCEL);
            return(TRUE);

        case IDOK:
            Assert(pLogon);
            if (pLogon)
            {
                Edit_GetText(GetDlgItem(hwnd, IDE_USERNAME), pLogon->pCredential->szUserName, CCHMAX_USERNAME);
                Edit_GetText(GetDlgItem(hwnd, IDE_PASSWORD), pLogon->pCredential->szPassword, CCHMAX_PASSWORD);
                Edit_GetText(GetDlgItem(hwnd, IDE_DOMAIN),   pLogon->pCredential->szDomain,   CCHMAX_NTLM_DOMAIN);
                pLogon->pContext->hwndLogon = NULL;
            }
            EndDialog(hwnd, LOGON_OK);
            return(TRUE);
        }
        break;

    case WM_DESTROY:
        // This is here because when OE shuts down and this dialog is displayed, a WM_QUIT is posted to the thread
        // that this dialog lives on. WM_QUIT causes a WM_DESTROY dialog to get sent to this dialog, but the parent
        // doesn't seem to get re-enabled
        EnableWindow(GetParent(hwnd), TRUE);

        // Null out the this pointer
        SetWndThisPtr(hwnd, NULL);

        // Set pContext hwndLogon
        if (pLogon)
            pLogon->pContext->hwndLogon = NULL;

        // Done
        return(FALSE);
    }

    // Done
    return(FALSE);
}

//--------------------------------------------------------------------------
// SSPIFillAuth
//--------------------------------------------------------------------------
HRESULT SSPIFillAuth(LPCSTR pszUserName, LPCSTR pszPassword, LPCSTR pszDomain,
    SEC_WINNT_AUTH_IDENTITY *pAuth)
{
    // Set Flags
    pAuth->Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

    // Fill It
    pAuth->User = (unsigned char *)(pszUserName ? pszUserName : c_szEmpty);
    pAuth->UserLength = lstrlen((LPSTR)pAuth->User);
    pAuth->Domain = (unsigned char *)(pszDomain ? pszDomain : c_szEmpty);
    pAuth->DomainLength = lstrlen((LPSTR)pAuth->Domain);
    pAuth->Password = (unsigned char *)(pszPassword ? pszPassword : c_szEmpty);
    pAuth->PasswordLength = lstrlen((LPSTR)pAuth->Password);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// SSPIAuthFromCredential
//--------------------------------------------------------------------------
HRESULT SSPIAuthFromCredential(LPCREDENTIAL pCredential, SEC_WINNT_AUTH_IDENTITY *pAuth)
{
    // Fill It
    SSPIFillAuth(pCredential->szUserName, pCredential->szPassword, pCredential->szDomain, pAuth);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// SSPIFindCredential
//--------------------------------------------------------------------------
HRESULT SSPIFindCredential(LPSSPICONTEXT pContext, ITransportCallback *pCallback)
{
    // Locals
    HRESULT                     hr=S_OK;
    LPCREDENTIAL                pCurrent;
    LPCREDENTIAL                pPrevious=NULL;
    LPCREDENTIAL                pNew=NULL;
    SSPILOGON                   Logon;
    HWND                        hwndParent=NULL;
    ITransportCallbackService  *pService=NULL;

    // Trace
    TraceCall("SSPIFindCredential");

    // Invalid Arg
    Assert(pContext->pszServer && pCallback);

    // No Callback
    if (NULL == pCallback)
        return TraceResult(E_INVALIDARG);

    // Thread Safety
    EnterCriticalSection(&g_csDllMain);

    // Search the list for cached credentials...
    for (pCurrent=g_pCredentialHead; pCurrent!=NULL; pCurrent=pCurrent->pNext)
    {
        // Is this It ?
        if (lstrcmpi(pContext->pszServer, pCurrent->szServer) == 0)
            break;

        // Save Previous
        pPrevious = pCurrent;
    }

    // If we found one and there are no retries...
    if (pCurrent)
    {
        // If no retries, then use this
        if (0 == pCurrent->cRetry)
        {
            // Reset pContext ?
            SafeMemFree(pContext->pszUserName);
            SafeMemFree(pContext->pszPassword);
            SafeMemFree(pContext->pszDomain);

            // Duplicate the good stuff
            IF_NULLEXIT(pContext->pszUserName = PszDupA((LPSTR)pCurrent->szUserName));
            IF_NULLEXIT(pContext->pszDomain = PszDupA((LPSTR)pCurrent->szDomain));
            IF_NULLEXIT(pContext->pszPassword = PszDupA((LPSTR)pCurrent->szPassword));

            // Increment retry count
            pCurrent->cRetry++;

            // Thread Safety
            LeaveCriticalSection(&g_csDllMain);

            // Done
            goto exit;
        }

        // Unlink pCurrent from the list
        if (pPrevious)
        {
            Assert(pPrevious->pNext == pCurrent);
            pPrevious->pNext = pCurrent->pNext;
        }
        else
        {
            Assert(g_pCredentialHead == pCurrent);
            g_pCredentialHead = pCurrent->pNext;
        }
    }

    // Thread Safety
    LeaveCriticalSection(&g_csDllMain);

    // Didn't find anything...allocate one
    if (NULL == pCurrent)
    {
        // Allocate
        IF_NULLEXIT(pNew = (LPCREDENTIAL)g_pMalloc->Alloc(sizeof(CREDENTIAL)));

        // Zero
        ZeroMemory(pNew, sizeof(CREDENTIAL));

        // Set pCurrent
        pCurrent = pNew;

        // Store the Server Name
        StrCpyN(pCurrent->szServer, pContext->pszServer, ARRAYSIZE(pCurrent->szServer));
    }

    // No pNext
    pCurrent->pNext = NULL;

    // QI pTransport for ITransportCallbackService
    hr = pCallback->QueryInterface(IID_ITransportCallbackService, (LPVOID *)&pService);
    if (FAILED(hr))
    {
        // Raid-69382 (2/5/99): CDO: loop in ISMTPTransport/INNTPTransport when Sicily authentication fails
        // Clients who don't support this interface, I will treat them as a cancel.
        pContext->fPromptCancel = TRUE;
        TraceResult(hr);
        goto exit;
    }

    // Get a Window Handle
    hr = pService->GetParentWindow(0, &hwndParent);
    if (FAILED(hr))
    {
        // Raid-69382 (2/5/99): CDO: loop in ISMTPTransport/INNTPTransport when Sicily authentication fails
        // Clients who don't support this interface, I will treat them as a cancel.
        pContext->fPromptCancel = TRUE;
        TraceResult(hr);
        goto exit;
    }

    // No Parent...
    if (NULL == hwndParent || FALSE == IsWindow(hwndParent))
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Bring to the foreground
	ShowWindow(hwndParent, SW_SHOW);
    SetForegroundWindow(hwndParent);

	// Clear the password
	*pCurrent->szPassword = '\0';

    // Initialize Current...
    if (pContext->pszUserName)
        StrCpyN(pCurrent->szUserName, pContext->pszUserName, ARRAYSIZE(pCurrent->szUserName));
    if (pContext->pszDomain)
        StrCpyN(pCurrent->szDomain, pContext->pszDomain, ARRAYSIZE(pCurrent->szDomain));

    // Set Logon
    Logon.pCredential = pCurrent;
    Logon.pContext = pContext;

    // Do the Dialog Box
    if (LOGON_OK != DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(IDD_NTLMPROMPT), hwndParent, GetCredentialDlgProc, (LPARAM)&Logon))
    {
        pContext->fPromptCancel = TRUE;
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Not cancel
    pContext->fPromptCancel = FALSE;

    // Reset pContext ?
    SafeMemFree(pContext->pszUserName);
    SafeMemFree(pContext->pszPassword);
    SafeMemFree(pContext->pszDomain);

    // Duplicate the good stuff
    IF_NULLEXIT(pContext->pszUserName = PszDupA((LPSTR)pCurrent->szUserName));
    IF_NULLEXIT(pContext->pszDomain = PszDupA((LPSTR)pCurrent->szDomain));
    IF_NULLEXIT(pContext->pszPassword = PszDupA((LPSTR)pCurrent->szPassword));

    // Set Next
    pCurrent->pNext = g_pCredentialHead;

    // Reset Head
    g_pCredentialHead = pCurrent;

    // Set Retry Count
    pCurrent->cRetry++;

    // Don't Free It
    pNew = NULL;

exit:
    // Cleanup
    SafeMemFree(pNew);
    SafeRelease(pService);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// SSPIFreeCredentialList
//--------------------------------------------------------------------------
HRESULT SSPIFreeCredentialList(void)
{
    // Locals
    LPCREDENTIAL pCurrent;
    LPCREDENTIAL pNext;

    // Trace
    TraceCall("SSPIFreeCredentialList");

    // Thread Safety
    EnterCriticalSection(&g_csDllMain);

    // Set pCurrent
    pCurrent = g_pCredentialHead;

    // While we have a node
    while (pCurrent)
    {
        // Save pNext
        pNext = pCurrent->pNext;

        // Free pCurrent
        g_pMalloc->Free(pCurrent);

        // Goto Next
        pCurrent = pNext;
    }

    // Clear the header
    g_pCredentialHead = NULL;

    // Thread Safety
    LeaveCriticalSection(&g_csDllMain);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// SSPIUninitialize
//--------------------------------------------------------------------------
HRESULT SSPIUninitialize(void)
{
    // Trace
    TraceCall("SSPIUninitialize");

    // If we have loaded the dll...
    if (g_hInstSSPI)
    {
        // Free the Lib
        FreeLibrary(g_hInstSSPI);
    }

    // Free Credential List
    SSPIFreeCredentialList();

    // Free Packages
    if (g_prgPackage)
    {
        // Loop through Packages
        for (DWORD i = 0; i < g_cPackages; i++)
        {
            // Free pszName
            SafeMemFree(g_prgPackage[i].pszName);

            // Free pszComment
            SafeMemFree(g_prgPackage[i].pszComment);
        }

        // Free packages
        SafeMemFree(g_prgPackage);

        // No Packages
        g_cPackages = 0;
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// SSPIIsInstalled
//--------------------------------------------------------------------------
HRESULT SSPIIsInstalled(void)
{
    // Locals
    HRESULT                     hr=S_FALSE;
    INIT_SECURITY_INTERFACE	    addrProcISI = NULL;

    // Trace
    TraceCall("SSPIIsInstalled");

    // Thread Safety
    EnterCriticalSection(&g_csDllMain);

    // Already Loaded ?
    if (g_hInstSSPI)
    {
        hr = S_OK;
        goto exit;
    }

    // Load Security DLL
    if (S_OK == IsPlatformWinNT())
        g_hInstSSPI = LoadLibrary(c_szSecurityDLL);
    else
        g_hInstSSPI = LoadLibrary(c_szSecur32DLL);

    // Could not be loaded
    if (NULL == g_hInstSSPI)
    {
        TraceInfo("SSPI: LoadLibrary failed.");
        goto exit;
    }

    // Load the function table
    addrProcISI = (INIT_SECURITY_INTERFACE)GetProcAddress(g_hInstSSPI, SECURITY_ENTRYPOINT);       
    if (NULL == addrProcISI)
    {
        TraceInfo("SSPI: GetProcAddress failed failed.");
        goto exit;
    }

    // Get the SSPI function table
    g_pFunctions = (*addrProcISI)();

    // If the didn't work
    if (NULL == g_pFunctions)
    {
        // Free the library
        FreeLibrary(g_hInstSSPI);

        // Null the handle
        g_hInstSSPI = NULL;

        // Failed to get the function table
        TraceInfo("SSPI: Load Function Table failed.");

        // Done
        goto exit;
    }

    // Woo-hoo
    hr = S_OK;

exit:
    // Thread Safety
    LeaveCriticalSection(&g_csDllMain);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// SSPIGetPackages
//--------------------------------------------------------------------------
HRESULT SSPIGetPackages(LPSSPIPACKAGE *pprgPackage, LPDWORD pcPackages)
{
    // Locals
    SECURITY_STATUS hr=SEC_E_OK;
    PSecPkgInfo     prgPackage=NULL;
    ULONG           i;

    // Trace
    TraceCall("SSPIGetPackages");

    // Check Params
    if (NULL == pprgPackage || NULL == pcPackages)
        return TraceResult(E_INVALIDARG);

    // Not Initialized
    if (NULL == g_hInstSSPI || NULL == g_pFunctions)
        return TraceResult(E_UNEXPECTED);

    // Init
    *pprgPackage = NULL;
    *pcPackages = 0;

    // Already have packages ?
    EnterCriticalSection(&g_csDllMain);

    // Do I already have the packages ?
    if (NULL == g_prgPackage)
    {
        // Enumerate security packages
        IF_FAILEXIT(hr = (*(g_pFunctions->EnumerateSecurityPackages))(&g_cPackages, &prgPackage));

        // RAID - 29645 - EnumerateSecurityPackages seems to return cSec = Rand and pSec == NULL, so, I need to return at this point if cSec == 0 or pSec == NULL
        if (0 == g_cPackages || NULL == prgPackage)
        {
            hr = TraceResult(E_FAIL);
            goto exit;
        }

        // Allocate pprgPackage
        IF_NULLEXIT(g_prgPackage = (LPSSPIPACKAGE)ZeroAllocate(g_cPackages * sizeof(SSPIPACKAGE)));

        // Copy data into ppPackages
        for (i = 0; i < g_cPackages; i++)
        {
            g_prgPackage[i].ulCapabilities = prgPackage[i].fCapabilities;
            g_prgPackage[i].wVersion = prgPackage[i].wVersion;
            g_prgPackage[i].cbMaxToken = prgPackage[i].cbMaxToken;
            g_prgPackage[i].pszName = PszDupA(prgPackage[i].Name);
            g_prgPackage[i].pszComment = PszDupA(prgPackage[i].Comment);
        }
    }

    // Return Global
    *pprgPackage = g_prgPackage;
    *pcPackages = g_cPackages;

exit:
    // Already have packages ?
    LeaveCriticalSection(&g_csDllMain);

    // Free the package
    if (prgPackage)
    {
        // Free the Array
        (*(g_pFunctions->FreeContextBuffer))(prgPackage);
    }

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// SSPILogon
//--------------------------------------------------------------------------
HRESULT SSPILogon(LPSSPICONTEXT pContext, BOOL fRetry, BOOL fBase64, 
    LPCSTR pszPackage, LPINETSERVER pServer, ITransportCallback *pCallback)
{
    // Locals
    SECURITY_STATUS           hr = SEC_E_OK;
    TimeStamp                 tsLifeTime;
    SEC_WINNT_AUTH_IDENTITY  *pAuth = NULL;
    SEC_WINNT_AUTH_IDENTITY   Auth={0};

    // Trace
    TraceCall("SSPILogon");

    // Validate
    Assert(pCallback);

    // Invalid Args
    if (NULL == pContext || NULL == pszPackage || NULL == pCallback)
        return TraceResult(E_INVALIDARG);

    // Not Initialized
    if (NULL == g_hInstSSPI || NULL == g_pFunctions)
        return TraceResult(E_UNEXPECTED);

    // Already have credential
    if (pContext->fCredential && SSPI_STATE_USE_CACHED == pContext->tyState)
        goto exit;

    // Installed ?
    if (S_FALSE == SSPIIsInstalled())
    {
        hr = TraceResult(IXP_E_LOAD_SICILY_FAILED);
        goto exit;
    }

    // Reset fPropmtCancel
    pContext->fPromptCancel = FALSE;

    // No retry
    if (NULL == pContext->pCallback)
    {
        // Locals
        ITransportCallbackService *pService;

        // Validate
        Assert(!pContext->pszPackage && !pContext->pszServer && !pContext->pCallback && !pContext->pszUserName && !pContext->pszPassword);

        // Save fBase64
        pContext->fBase64 = fBase64;

        // Copy Some Strings
        IF_NULLEXIT(pContext->pszPackage = PszDupA(pszPackage));
        IF_NULLEXIT(pContext->pszServer = PszDupA(pServer->szServerName));
        IF_NULLEXIT(pContext->pszUserName = PszDupA(pServer->szUserName));

        // Empty Password
        if (FALSE == FIsEmptyA(pServer->szPassword))
        {
            // Copy It
            IF_NULLEXIT(pContext->pszPassword = PszDupA(pServer->szPassword));
        }

        // Assume Callback
        pContext->pCallback = pCallback;
        pContext->pCallback->AddRef();

        // Supports Callback Service
        if (SUCCEEDED(pContext->pCallback->QueryInterface(IID_ITransportCallbackService, (LPVOID *)&pService)))
        {
            // This object supports the Service
            pContext->fService = TRUE;

            // Release
            pService->Release();
        }

        // Otherwise
        else
            pContext->fService = FALSE;
    }

    // Clear current credential
    if (pContext->fCredential)
    {
        // Free Credential Handle
        (*(g_pFunctions->FreeCredentialHandle))(&pContext->hCredential);

        // No Credential
        pContext->fCredential = FALSE;
    }

    // Use Cached
    if (SSPI_STATE_USE_CACHED == pContext->tyState)
    {
        // If not a retry...
        if (FALSE == fRetry)
        {
            // No Retries
            pContext->cRetries = 0;

            // Thread Safety
            EnterCriticalSection(&g_csDllMain);

            // Search the list for cached credentials...
            for (LPCREDENTIAL pCurrent=g_pCredentialHead; pCurrent!=NULL; pCurrent=pCurrent->pNext)
            {
                // Is this It ?
                if (lstrcmpi(pContext->pszServer, pCurrent->szServer) == 0)
                {
                    pCurrent->cRetry = 0;
                    break;
                }
            }

            // Thread Safety
            LeaveCriticalSection(&g_csDllMain);
        }

		// Otherwise, assume we will need to force a prompt...
		else
        {
            // Increment Retry Count
            pContext->cRetries++;

            // Valid Retry States...
            Assert(SSPI_STATE_USE_CACHED == pContext->tyRetryState || SSPI_STATE_PROMPT_USE_PACKAGE == pContext->tyRetryState);

            // The next phase may be to tell the package to prompt...
			pContext->tyState = pContext->tyRetryState;
        }
    }

    // Use Supplied
    else if (SSPI_STATE_USE_SUPPLIED == pContext->tyState)
    {
        // Locals
        CredHandle hCredential;

        // Next State...
        pContext->tyState = SSPI_STATE_USE_CACHED;

        // Fill It
        SSPIFillAuth(NULL, NULL, NULL, &Auth);

        // Do some security stuff
        if (SUCCEEDED((*(g_pFunctions->AcquireCredentialsHandle))(NULL, (LPSTR)pContext->pszPackage, SECPKG_CRED_OUTBOUND, NULL, &Auth, NULL, NULL, &hCredential, &tsLifeTime)))
        {
            // Free the Handle
            (*(g_pFunctions->FreeCredentialHandle))(&hCredential);
        }

        // Use Supplied Credentials...
        SSPIFillAuth(pContext->pszUserName, pContext->pszPassword, pContext->pszDomain, &Auth);

        // Set pAuth
        pAuth = &Auth;
    }

    // Otherwise, try to get cached credentials
    else if (SSPI_STATE_PROMPT_USE_OWN == pContext->tyState)
    {
        // Next State...
        pContext->tyState = SSPI_STATE_USE_CACHED;

        // Failure
        IF_FAILEXIT(hr = SSPIFindCredential(pContext, pCallback));

        // Fill and return credentials
        SSPIFillAuth(pContext->pszUserName, pContext->pszPassword, pContext->pszDomain, &Auth);

        // Set Auth Information
        pAuth = &Auth;
    }

    // Do some security stuff
    IF_FAILEXIT(hr = (*(g_pFunctions->AcquireCredentialsHandle))(NULL, (LPSTR)pContext->pszPackage, SECPKG_CRED_OUTBOUND, NULL, pAuth, NULL, NULL, &pContext->hCredential, &tsLifeTime));

    // We have a credential
    pContext->fCredential = TRUE;

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// SSPIGetNegotiate
//--------------------------------------------------------------------------
HRESULT SSPIGetNegotiate(LPSSPICONTEXT pContext, LPSSPIBUFFER pNegotiate)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("SSPIGetNegotiate");

    // Invalid Args
    if (NULL == pContext || NULL == pNegotiate)
        return TraceResult(E_INVALIDARG);

    // Not Initialized
    if (NULL == g_hInstSSPI || NULL == g_pFunctions)
        return TraceResult(E_UNEXPECTED);

    // If the context is currently initialized
    if (pContext->fContext)
    {
        // Delete this context
        (*(g_pFunctions->DeleteSecurityContext))(&pContext->hContext);

        // No Context
        pContext->fContext = FALSE;
    }

    // Reset this state.
    pContext->fUsedSuppliedCreds = FALSE;

    // Build Negotiation String
    IF_FAILEXIT(hr = SSPIMakeOutboundMessage(pContext, 0, pNegotiate, NULL));

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// SSPIResponseFromChallenge
//--------------------------------------------------------------------------
HRESULT SSPIResponseFromChallenge(LPSSPICONTEXT pContext, LPSSPIBUFFER pChallenge, 
    LPSSPIBUFFER pResponse)
{
    // Locals
    HRESULT          hr=S_OK;
    DWORD            nBytesReceived;
    DWORD            dwFlags=0;
    SecBufferDesc    Descript;
    SecBuffer        Buffer[SEC_BUFFER_NUM_EXTENDED_BUFFERS];

    // Trace
    TraceCall("SSPIResponseFromChallenge");

    // Invalid Args
    if (NULL == pContext || NULL == pChallenge || NULL == pResponse)
        return TraceResult(E_INVALIDARG);

    // Not Initialized
    if (NULL == g_hInstSSPI || NULL == g_pFunctions)
        return TraceResult(E_UNEXPECTED);

    // More Unexpected Stuff
    if (FALSE == pContext->fContext || FALSE == pContext->fCredential)
        return TraceResult(E_UNEXPECTED);

	// Decode the Challenge Buffer
    IF_FAILEXIT(hr == SSPIDecodeBuffer(pContext->fBase64, pChallenge));

    // Fill SecBufferDesc
    Descript.ulVersion = 0;
    Descript.pBuffers = Buffer;
    Descript.cBuffers = 1;

    // Setup the challenge input buffer always (0th buffer)
    Buffer[SEC_BUFFER_CHALLENGE_INDEX].pvBuffer = pChallenge->szBuffer;
    Buffer[SEC_BUFFER_CHALLENGE_INDEX].cbBuffer = pChallenge->cbBuffer - 1;
    Buffer[SEC_BUFFER_CHALLENGE_INDEX].BufferType = SECBUFFER_TOKEN;

    // If Digest
    if (FALSE == pContext->fUsedSuppliedCreds && lstrcmpi(pContext->pszPackage, "digest") == 0)
    {
        // If we have a user, setup the user buffer (1st buffer)
        Buffer[SEC_BUFFER_USERNAME_INDEX].pvBuffer = pContext->pszUserName ? pContext->pszUserName : NULL;
        Buffer[SEC_BUFFER_USERNAME_INDEX].cbBuffer = pContext->pszUserName ? lstrlen(pContext->pszUserName) : NULL;
        Buffer[SEC_BUFFER_USERNAME_INDEX].BufferType = SECBUFFER_TOKEN;
    
        // If we have a password, setup the password buffer (2nd buffer for
        // a total of 3 buffers passed in (challenge + user + pass)
        Buffer[SEC_BUFFER_PASSWORD_INDEX].pvBuffer = pContext->pszPassword ? pContext->pszPassword : NULL;
        Buffer[SEC_BUFFER_PASSWORD_INDEX].cbBuffer = pContext->pszPassword ? lstrlen(pContext->pszPassword) : NULL;
        Buffer[SEC_BUFFER_PASSWORD_INDEX].BufferType = SECBUFFER_TOKEN;

        // If either or both user and pass passed in, set num input buffers to 3 // (SEC_BUFFER_NUM_EXTENDED_BUFFERS)
        if (pContext->pszUserName || pContext->pszPassword)
            Descript.cBuffers = SEC_BUFFER_NUM_EXTENDED_BUFFERS;

        // else we're just passing in the one challenge buffer (0th buffer as usual)
        else
            Descript.cBuffers = SEC_BUFFER_NUM_NORMAL_BUFFERS;

        // We are supplying creds
        pContext->fUsedSuppliedCreds = TRUE;

        // Set dwFlags
        dwFlags = ISC_REQ_USE_SUPPLIED_CREDS;
    }

    // Prepare for OutMsg
    IF_FAILEXIT(hr = SSPIMakeOutboundMessage(pContext, dwFlags, pResponse, &Descript));

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// SSPIReleaseContext
//--------------------------------------------------------------------------
HRESULT SSPIReleaseContext(LPSSPICONTEXT pContext)
{
    // Was Context Initialized
    if (pContext->fContext)
    {
        // Delete the Security Context
        (*(g_pFunctions->DeleteSecurityContext))(&pContext->hContext);

        // No context
        pContext->fContext = FALSE;
    }

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// SSPIFreeContext
//--------------------------------------------------------------------------
HRESULT SSPIFreeContext(LPSSPICONTEXT pContext)
{
    // Locals
    SSPICONTEXTSTATE tyState;
    SSPICONTEXTSTATE tyRetryState;
    DWORD            cRetries;

    // Trace
    TraceCall("SSPIFreeContext");

    // Is the context initialized
    if (pContext->fContext)
    {
        // Delete It
        (*(g_pFunctions->DeleteSecurityContext))(&pContext->hContext);

        // No Context
        pContext->fContext = FALSE;
    }

    // Credential Handle Initialized
    if (pContext->fCredential)
    {
        // Free Credential Handle
        (*(g_pFunctions->FreeCredentialHandle))(&pContext->hCredential);

        // No Context
        pContext->fCredential = FALSE;
    }

    // Free Package, Server and Callback
    SafeMemFree(pContext->pszPackage);
    SafeMemFree(pContext->pszUserName);
    SafeMemFree(pContext->pszPassword);
    SafeMemFree(pContext->pszServer);
    SafeRelease(pContext->pCallback);

    // Close hMutexUI
    if (pContext->hwndLogon)
    {
        // Nuke the Window
        DestroyWindow(pContext->hwndLogon);

        // Null
        pContext->hwndLogon = NULL;
    }

    // Save It
    tyState = (SSPICONTEXTSTATE)pContext->tyState;
    tyRetryState = (SSPICONTEXTSTATE)pContext->tyRetryState;
    cRetries = pContext->cRetries;

    // Zero It Out
    ZeroMemory(pContext, sizeof(SSPICONTEXT));

    // Do Prompt
    pContext->tyState = tyState;
    pContext->tyRetryState = tyRetryState;
    pContext->cRetries = cRetries;

    // Done
    return(S_OK);
}

// --------------------------------------------------------------------------------
// SSPIPromptThreadEntry
// --------------------------------------------------------------------------------
DWORD SSPIPromptThreadEntry(LPDWORD pdwParam) 
{  
    // Locals
    HRESULT          hr=S_OK;
    LPSSPIPROMPTINFO pPrompt=(LPSSPIPROMPTINFO)pdwParam;

    // Trace
    TraceCall("SSPIPromptThreadEntry");

    // Validate
    Assert(pPrompt && pPrompt->pContext);

    // Fixup pInDescript
    if (pPrompt->pInDescript && pPrompt->pInDescript->cBuffers >= 3 && lstrcmpi(pPrompt->pContext->pszPackage, "digest") == 0)
    {
        // Raid-66013: Make sure the password is empty or digest will crash
        pPrompt->pInDescript->pBuffers[SEC_BUFFER_PASSWORD_INDEX].pvBuffer = NULL;
        pPrompt->pInDescript->pBuffers[SEC_BUFFER_PASSWORD_INDEX].cbBuffer = 0;
        //pPrompt->pInDescript->cBuffers = 2;
    }

    // Try to get the package to prompt for credentials...
    pPrompt->hrResult = (*(g_pFunctions->InitializeSecurityContext))(
        &pPrompt->pContext->hCredential, 
        pPrompt->phCtxCurrent, 
        pPrompt->pContext->pszServer, 
        pPrompt->dwFlags | ISC_REQ_PROMPT_FOR_CREDS, 
        0, 
        SECURITY_NATIVE_DREP, 
        pPrompt->pInDescript, 
        0, 
        &pPrompt->pContext->hContext, 
        pPrompt->pOutDescript, 
        &pPrompt->fContextAttrib, 
        &pPrompt->tsExpireTime);

    // Trace
    TraceResultSz(pPrompt->hrResult, "SSPIPromptThreadEntry");

    // Done
    return(0);
}

//--------------------------------------------------------------------------
// SSPISetAccountUserName
//--------------------------------------------------------------------------
HRESULT SSPISetAccountUserName(LPCSTR pszName, LPSSPICONTEXT pContext)
{
    // Locals
    HRESULT                     hr=S_OK;
    DWORD                       dwServerType;
    IImnAccount                *pAccount=NULL;
    ITransportCallbackService  *pService=NULL;

    // Trace
    TraceCall("SSPISetAccountUserName");

    // Validate Args
    Assert(pszName);
    Assert(pContext);
    Assert(pContext->pCallback);

    // Get ITransportCallbackService
    IF_FAILEXIT(hr = pContext->pCallback->QueryInterface(IID_ITransportCallbackService, (LPVOID *)&pService));

    // Get the Account
    IF_FAILEXIT(hr = pService->GetAccount(&dwServerType, &pAccount));

    // SRV_POP3
    if (ISFLAGSET(dwServerType, SRV_POP3))
    {
        // Set the UserName
        IF_FAILEXIT(hr = pAccount->SetPropSz(AP_POP3_USERNAME, (LPSTR)pszName));
    }

    // SRV_SMTP
    else if (ISFLAGSET(dwServerType, SRV_SMTP))
    {
        // Set the UserName
        IF_FAILEXIT(hr = pAccount->SetPropSz(AP_SMTP_USERNAME, (LPSTR)pszName));
    }

    // SRV_IMAP
    else if (ISFLAGSET(dwServerType, SRV_IMAP))
    {
        // Set the UserName
        IF_FAILEXIT(hr = pAccount->SetPropSz(AP_IMAP_USERNAME, (LPSTR)pszName));
    }

    // SRV_NNTP
    else if (ISFLAGSET(dwServerType, SRV_NNTP))
    {
        // Set the UserName
        IF_FAILEXIT(hr = pAccount->SetPropSz(AP_NNTP_USERNAME, (LPSTR)pszName));
    }

    // Save Changes
    pAccount->SaveChanges();

exit:
    // Cleanup
    SafeRelease(pService);
    SafeRelease(pAccount);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// SSPIMakeOutboundMessage
//--------------------------------------------------------------------------
HRESULT SSPIMakeOutboundMessage(LPSSPICONTEXT pContext, DWORD dwFlags, 
    LPSSPIBUFFER pBuffer, PSecBufferDesc pInDescript)
{
    // Locals
    SECURITY_STATUS         hr=S_OK;
    SSPIPROMPTINFO          Prompt={0};
    SecBuffer               OutBuffer;
    SecBufferDesc           OutDescript;
    ULONG                   fContextAttrib;
    TimeStamp               tsExpireTime;
    HANDLE                  hPromptThread;
    DWORD                   dwThreadId;
    DWORD                   dwWait;
    MSG                     msg;
    PCtxtHandle             phCtxCurrent=NULL;
    PAUTHENTICATE_MESSAGE   pAuthMsg;
    LPSTR                   pszName=NULL;

    // Invalid Args
    if (NULL == pContext || NULL == pBuffer)
        return TraceResult(E_INVALIDARG);

    // Bad Context
    if (NULL == pContext->pszPackage)
        return TraceResult(E_INVALIDARG);

    // Bad Context
    if (NULL == pContext->pszServer)
        return TraceResult(E_INVALIDARG);

    // Bad Context
    if (NULL == pContext->pCallback)
        return TraceResult(E_INVALIDARG);

    // Not Initialized
    if (NULL == g_hInstSSPI || NULL == g_pFunctions)
        return TraceResult(E_UNEXPECTED);

    // Bad State
    if (FALSE == pContext->fCredential)
        return TraceResult(E_UNEXPECTED);

    // Validate
    Assert(pInDescript == NULL ? FALSE == pContext->fContext : TRUE);

    // Initialize Out Descriptor
    OutDescript.ulVersion = 0;
    OutDescript.cBuffers = 1;
    OutDescript.pBuffers = &OutBuffer;

    // Initialize Output Buffer
    OutBuffer.cbBuffer = CBMAX_SSPI_BUFFER - 1;
    OutBuffer.BufferType = SECBUFFER_TOKEN;
    OutBuffer.pvBuffer = pBuffer->szBuffer;

    // phCtxCurrent
    if (pInDescript)
    {
        // Set Current Context
        phCtxCurrent = &pContext->hContext;
    }

    // First Retry ?
    if (SSPI_STATE_PROMPT_USE_PACKAGE == pContext->tyState && (0 != lstrcmpi(pContext->pszPackage, "digest") || pInDescript))
    {
        // Force failure to do the prompt
        hr = SEC_E_NO_CREDENTIALS;
    }

    // Otherwise, do the next security context
    else
    {
        // Generate a negotiate/authenticate message to be sent to the server.        
        hr = (*(g_pFunctions->InitializeSecurityContext))(&pContext->hCredential, phCtxCurrent, pContext->pszServer, dwFlags, 0, SECURITY_NATIVE_DREP, pInDescript, 0, &pContext->hContext, &OutDescript, &fContextAttrib, &tsExpireTime);
    }

    // Set Retry State...
    pContext->tyRetryState = SSPI_STATE_PROMPT_USE_PACKAGE;

    // Failure
    if (FAILED(hr))
    {
        // Trace
        TraceResult(hr);

        // No credentials ? lets do it again and get some credentials
        if (SEC_E_NO_CREDENTIALS != hr)
            goto exit;

        // If no retries yet...
        if (TRUE == pContext->fService && 0 == lstrcmpi(pContext->pszPackage, "MSN") && 0 == pContext->cRetries)
        {
            // Don't retry again...
            pContext->tyState = SSPI_STATE_USE_SUPPLIED;

            // Do the logon Now...
            hr = SSPILogon(pContext, FALSE, pContext->fBase64, pContext->pszPackage, NULL, pContext->pCallback);

            // Cancel ?
            Assert(FALSE == pContext->fPromptCancel);

            // Success
            if (SUCCEEDED(hr))
            {
                // Try Again
                hr = (*(g_pFunctions->InitializeSecurityContext))(&pContext->hCredential, NULL, pContext->pszServer, 0, 0, SECURITY_NATIVE_DREP, NULL, 0, &pContext->hContext, &OutDescript, &fContextAttrib, &tsExpireTime);
            }
        }

        // Still Failed ?
        if (FAILED(hr))
        {
            // Fill up the prompt info...
            Assert(dwFlags == 0 || dwFlags == ISC_REQ_USE_SUPPLIED_CREDS);
            Prompt.pContext = pContext;
            Prompt.pInDescript = pInDescript;
            Prompt.pOutDescript = &OutDescript;
            Prompt.phCtxCurrent = phCtxCurrent;
            Prompt.dwFlags = dwFlags;

            // Create the Thread
            IF_NULLEXIT(hPromptThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)SSPIPromptThreadEntry, &Prompt, 0, &dwThreadId));

            // Wait for the thread to finish
            WaitForSingleObject(hPromptThread, INFINITE);

            // This is what I tried to do so that the spooler window would paint, but it caused all sorts of voodo
#if 0
            // Wait for the thread to finish
            while (1)
            {
                // Wait
                dwWait = MsgWaitForMultipleObjects(1, &hPromptThread, FALSE, INFINITE, QS_PAINT);

                // Done ?
                if (dwWait != WAIT_OBJECT_0 + 1)
                    break;

                // Pump Messages
                while (PeekMessage(&msg, NULL, WM_PAINT, WM_PAINT, PM_REMOVE))
                {
                    // Translate the Message
                    TranslateMessage(&msg);

                    // Dispatch the Message
                    DispatchMessage(&msg);
                }
            }
#endif

            // Close the Thread
            CloseHandle(hPromptThread);

            // Set hr
            hr = Prompt.hrResult;

            // If that failed
            if (FAILED(hr))
            {
                // Decide when its no longer needed to continue...
                if (SEC_E_NO_CREDENTIALS == hr)
                    goto exit;

                // Only do this if on negotiate phase otherwise NTLM prompt comes up twice
                if (NULL == pInDescript)
                {
                    // Do Prompt
                    pContext->tyState = SSPI_STATE_PROMPT_USE_OWN;

                    // Do the logon Now...
                    hr = SSPILogon(pContext, TRUE, pContext->fBase64, pContext->pszPackage, NULL, pContext->pCallback);

                    // Cancel ?
                    if (pContext->fPromptCancel)
                    {
                        hr = TraceResult(E_FAIL);
                        goto exit;
                    }

                    // Success
                    if (SUCCEEDED(hr))
                    {
                        // Try Again
                        hr = (*(g_pFunctions->InitializeSecurityContext))(&pContext->hCredential, phCtxCurrent, pContext->pszServer, 0, 0, SECURITY_NATIVE_DREP, pInDescript, 0, &pContext->hContext, &OutDescript, &fContextAttrib, &tsExpireTime);
                    }
                }
            }
        }
    }

    // Success
    if (SUCCEEDED(hr))
    {
        // We have a context
        pContext->fContext = TRUE;

        // If MSN or NTLM...
        if (TRUE == pContext->fService && 0 == lstrcmpi(pContext->pszPackage, "MSN"))
        {
            // Look at the buffer...
            pAuthMsg = (PAUTHENTICATE_MESSAGE)pBuffer->szBuffer;

            // Validate Signature
            Assert(0 == StrCmpNI((LPCSTR)pAuthMsg->Signature, NTLMSSP_SIGNATURE, sizeof(NTLMSSP_SIGNATURE)));

            // Right Phase ?
            if (NtLmAuthenticate == pAuthMsg->MessageType)
            {
                // Allocate
                IF_NULLEXIT(pszName = (LPSTR)g_pMalloc->Alloc(pAuthMsg->UserName.Length + sizeof(CHAR)));

                // Copy the name
                CopyMemory(pszName, (LPBYTE)pBuffer->szBuffer + PtrToUlong(pAuthMsg->UserName.Buffer), pAuthMsg->UserName.Length);

                // Stuff a Null....
                pszName[pAuthMsg->UserName.Length] = '\0';

                // If Context UserName is empty, lets store pszName into the account
                if ('\0' == *pContext->pszUserName)
                {
                    // Put pszName as the username for this account
                    if (SUCCEEDED(SSPISetAccountUserName(pszName, pContext)))
                    {
                        // Reset the UserName
                        SafeMemFree(pContext->pszUserName);

                        // Copy the new username 
                        IF_NULLEXIT(pContext->pszUserName = PszDupA(pszName));
                    }
                }

                // Name Change
                if (lstrcmpi(pszName, pContext->pszUserName) != 0)
                {
                    // Don't retry again...
                    pContext->tyState = SSPI_STATE_USE_SUPPLIED;

                    // Set Retry State...
                    pContext->tyRetryState = SSPI_STATE_USE_CACHED;

                    // Do the logon Now...
                    hr = SSPILogon(pContext, FALSE, pContext->fBase64, pContext->pszPackage, NULL, pContext->pCallback);

                    // Cancel ?
                    Assert(FALSE == pContext->fPromptCancel);

                    // Success
                    if (SUCCEEDED(hr))
                    {
                        // Try Again
                        hr = (*(g_pFunctions->InitializeSecurityContext))(&pContext->hCredential, NULL, pContext->pszServer, 0, 0, SECURITY_NATIVE_DREP, NULL, 0, &pContext->hContext, &OutDescript, &fContextAttrib, &tsExpireTime);
                    }

                    // Fail, but continue...
                    if (FAILED(hr))
                    {
                        // We are going to need to prompt...
                        pContext->tyState = SSPI_STATE_PROMPT_USE_PACKAGE;

                        // Trace
                        TraceResult(hr);

                        // Always Succeed, but cause authentication to fail...
                        hr = S_OK;

                        // Reset Length
                        OutBuffer.cbBuffer = 0;
                    }
                }
            }
        }
    }

    // Otherwise...
    else
    {
        // Trace
        TraceResult(hr);

        // Always Succeed, but cause authentication to fail...
        hr = S_OK;

        // Reset Length
        OutBuffer.cbBuffer = 0;
    }

    // Continue required
    pBuffer->fContinue = (SEC_I_CONTINUE_NEEDED == hr) ? TRUE : FALSE;

    // Set cbBuffer
    pBuffer->cbBuffer = OutBuffer.cbBuffer + 1;

    // Null Terminate
    pBuffer->szBuffer[pBuffer->cbBuffer - 1] = '\0';

	// need to encode the blob before send out
    IF_FAILEXIT(hr == SSPIEncodeBuffer(pContext->fBase64, pBuffer));

    // All Good
    hr = S_OK;

exit:
    // Cleanup
    SafeMemFree(pszName);

    // Done
    return(hr);
}

//-------------------------------------------------------------------------------------------
// SSPIEncodeBuffer
//-------------------------------------------------------------------------------------------
HRESULT SSPIEncodeBuffer(BOOL fBase64, LPSSPIBUFFER pBuffer)
{
    // Locals
    LPBYTE          pbIn=(LPBYTE)pBuffer->szBuffer;
    DWORD           cbIn=pBuffer->cbBuffer - 1;
    BYTE            rgbOut[CBMAX_SSPI_BUFFER - 1];
    LPBYTE          pbOut=rgbOut;
    DWORD           i;

    // Trace
    TraceCall("SSPIEncodeBuffer");

    // Validate
    Assert(pBuffer->szBuffer[pBuffer->cbBuffer - 1] == '\0');

    // Set the lookup table to use to encode
    LPCSTR rgchDict = (fBase64 ? six2base64 : six2uu);

    // Loop
    for (i = 0; i < cbIn; i += 3) 
    {
        // Encode
        *(pbOut++) = rgchDict[*pbIn >> 2];
        *(pbOut++) = rgchDict[((*pbIn << 4) & 060) | ((pbIn[1] >> 4) & 017)];
        *(pbOut++) = rgchDict[((pbIn[1] << 2) & 074) | ((pbIn[2] >> 6) & 03)];
        *(pbOut++) = rgchDict[pbIn[2] & 077];

        // Increment pbIn
        pbIn += 3;
    }

    // If nbytes was not a multiple of 3, then we have encoded too many characters.  Adjust appropriately.
    if (i == cbIn + 1) 
    {
        // There were only 2 bytes in that last group
        pbOut[-1] = '=';
    }

    // There was only 1 byte in that last group
    else if (i == cbIn + 2) 
    {
        pbOut[-1] = '=';
        pbOut[-2] = '=';
    }

    // Null Terminate
    *pbOut = '\0';

    // Copy Back into pBuffer
    SSPISetBuffer((LPCSTR)rgbOut, SSPI_STRING, 0, pBuffer);

    // Done
    return(S_OK);
}

//-------------------------------------------------------------------------------------------
// SSPIDecodeBuffer
//-------------------------------------------------------------------------------------------
HRESULT SSPIDecodeBuffer(BOOL fBase64, LPSSPIBUFFER pBuffer)
{
    // Locals
    LPSTR           pszStart=pBuffer->szBuffer;
    LPBYTE          pbIn=(LPBYTE)pBuffer->szBuffer;
    DWORD           cbIn=pBuffer->cbBuffer - 1;         
    BYTE            rgbOut[CBMAX_SSPI_BUFFER - 1];
    LPBYTE          pbOut=rgbOut;
    DWORD           cbOutLeft = ARRAYSIZE(rgbOut)-1;
    long            cbDecode;
    DWORD           cbOut=0;

    // Trace
    TraceCall("SSPIDecodeBuffer"); 

    // Validate
    Assert(pBuffer->szBuffer[pBuffer->cbBuffer - 1] == '\0');

    // Set the lookup table to use to encode
    const int *rgiDict = (fBase64 ? base642six : uu2six);

    // Strip leading whitespace
    while (*pszStart == ' ' || *pszStart == '\t')
        pszStart++;

    // Set pbIn
    pbIn = (LPBYTE)pszStart;

    // Hmmm, I don't know what this does
    while (rgiDict[*(pbIn++)] <= 63)
        {};

    // Actual Number of bytes to encode
    cbDecode = (long) ((LPBYTE)pbIn - (LPBYTE)pszStart) - 1;

    // Computed length of outbound buffer
    cbOut = ((cbDecode + 3) / 4) * 3;

    // Reset pbIn
    pbIn = (LPBYTE)pszStart;

    // Decode
    while ((cbDecode > 0) && (3 <= cbOutLeft))
    {
        // Decode
        *(pbOut++) = (unsigned char) (rgiDict[*pbIn] << 2 | rgiDict[pbIn[1]] >> 4);
        *(pbOut++) = (unsigned char) (rgiDict[pbIn[1]] << 4 | rgiDict[pbIn[2]] >> 2);
        *(pbOut++) = (unsigned char) (rgiDict[pbIn[2]] << 6 | rgiDict[pbIn[3]]);
        cbOutLeft -= 3;
        Assert((cbDecode <= 0) || (3 <= cbOutLeft));    // If this happens, then cbDecode was calculated incorrectly and we will overflow the buffer.

        // Increment pbIn
        pbIn += 4;

        // Decrement cbDecode
        cbDecode -= 4;
    }

    // Special termination case
    if (cbDecode & 03) 
    {
        if (rgiDict[pbIn[-2]] > 63)
            cbOut -= 2;
        else
            cbOut -= 1;
    }

    // Set the Outbuffer
    SSPISetBuffer((LPCSTR)rgbOut, SSPI_BLOB, cbOut, pBuffer);

    // Done
    return(S_OK);
}

//-------------------------------------------------------------------------------------------
// SSPIFlushMSNCredentialCache - This code was given to us by kingra/MSN (see csager)
//-------------------------------------------------------------------------------------------
HRESULT SSPIFlushMSNCredentialCache(void)
{
    // Locals
    HRESULT                     hr=S_OK;
    HKEY                        hKey=NULL;
    DWORD                       dwType;
    CHAR                        szDllName[MAX_PATH];
    CHAR                        szProviders[1024];
    DWORD                       cb=ARRAYSIZE(szProviders);
    HINSTANCE                   hInstDll=NULL;
    PFNCLEANUPCREDENTIALCACHE   pfnCleanupCredentialCache;

    // Open the HKLM Reg Entry
    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Control\\SecurityProviders", 0, KEY_READ, &hKey))
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Read the Providers
    if (ERROR_SUCCESS != RegQueryValueEx(hKey, "SecurityProviders", NULL, &dwType, (LPBYTE)szProviders, &cb))
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Upper Case the Providers
    CharUpperBuff(szProviders, (DWORD)min(cb,ARRAYSIZE(szProviders)));

    // Map to something...
    if (StrStrA(szProviders, "MSAPSSPS.DLL"))
        StrCpyN(szDllName, "MSAPSSPS.DLL", ARRAYSIZE(szDllName));
    else if (StrStrA(szProviders, "MSAPSSPC.DLL"))
        StrCpyN(szDllName, "MSAPSSPC.DLL", ARRAYSIZE(szDllName));
    else
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Load the DLL
    hInstDll = LoadLibrary(szDllName);

    // Failed to Load
    if (NULL == hInstDll)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Get the ProcAddress
    pfnCleanupCredentialCache = (PFNCLEANUPCREDENTIALCACHE)GetProcAddress(hInstDll, "CleanupCredentialCache");

    // Failure ?
    if (NULL == pfnCleanupCredentialCache)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // Call the function that clears the cache
    if (!pfnCleanupCredentialCache())
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }
    
exit:
    // Cleanup
    if (hKey)
        RegCloseKey(hKey);
    if (hInstDll)
        FreeLibrary(hInstDll);

    // Done
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\sicily.h ===
//--------------------------------------------------------------------------
// S I C I L Y . H
//--------------------------------------------------------------------------
#pragma once 

//--------------------------------------------------------------------------
// Depends
//--------------------------------------------------------------------------
#ifndef SECURITY_WIN32
#define SECURITY_WIN32  1
#endif
#include <sspi.h>
#include <spseal.h>
#include <rpcdce.h>
#include <issperr.h>
#include <imnxport.h>

//--------------------------------------------------------------------------
// Forward Decls
//--------------------------------------------------------------------------
interface ITransportCallback;

//--------------------------------------------------------------------------
// Constants
//--------------------------------------------------------------------------
#define SSP_SSPS_DLL            "msnsspc.dll"
#define CBMAX_SSPI_BUFFER       1042
#define SSPI_BASE64             TRUE
#define SSPI_UUENCODE           FALSE

//--------------------------------------------------------------------------
// SSPIBUFFERTYPE
//--------------------------------------------------------------------------
typedef enum tagSSPIBUFFERTYPE {
    SSPI_STRING,
    SSPI_BLOB
} SSPIBUFFERTYPE;

//--------------------------------------------------------------------------
// SSPICONTEXTSTATE
//--------------------------------------------------------------------------
typedef enum tagSSPICONTEXTSTATE {
    SSPI_STATE_USE_CACHED,
    SSPI_STATE_USE_SUPPLIED,
    SSPI_STATE_PROMPT_USE_PACKAGE,
    SSPI_STATE_PROMPT_USE_OWN,
} SSPICONTEXTSTATE;

//--------------------------------------------------------------------------
// SSPICONTEXT
//--------------------------------------------------------------------------
typedef struct tagSSPICONTEXT {
    DWORD               tyState;
    DWORD               tyRetry;
    DWORD               tyRetryState;
    DWORD               cRetries;
    BYTE                fPromptCancel;
    HWND                hwndLogon;
    BYTE                fCredential;
    CredHandle          hCredential;
    BYTE                fContext;
    CtxtHandle          hContext;
    BOOL                fBase64;
    LPSTR               pszServer;
    LPSTR               pszPackage;
    LPSTR               pszUserName;
    LPSTR               pszPassword;
    LPSTR               pszDomain;
    BOOL                fService;
    BOOL                fUsedSuppliedCreds;
    ITransportCallback *pCallback;
} SSPICONTEXT, *LPSSPICONTEXT;

//--------------------------------------------------------------------------
// SSPIBUFFER
//--------------------------------------------------------------------------
typedef struct tagSSPIBUFFER {
    CHAR            szBuffer[CBMAX_SSPI_BUFFER];
    DWORD           cbBuffer;
    BOOL            fContinue;
} SSPIBUFFER, *LPSSPIBUFFER;

//--------------------------------------------------------------------------
// SSPIPACKAGE
//--------------------------------------------------------------------------
typedef struct tagSSPIPACKAGE {
    ULONG           ulCapabilities;
    WORD            wVersion;
    ULONG           cbMaxToken;
    LPSTR           pszName;
    LPSTR           pszComment;
} SSPIPACKAGE, *LPSSPIPACKAGE;

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
HRESULT SSPIIsInstalled(void);
HRESULT SSPIGetPackages(LPSSPIPACKAGE *pprgPackage, ULONG *pcPackages);
HRESULT SSPILogon(LPSSPICONTEXT pContext, BOOL fRetry, BOOL fBase64, LPCSTR szPackage, LPINETSERVER pServer, ITransportCallback *pCallback);
HRESULT SSPIGetNegotiate(LPSSPICONTEXT pContext, LPSSPIBUFFER pNegotiate);
HRESULT SSPIResponseFromChallenge(LPSSPICONTEXT pContext, LPSSPIBUFFER pChallenge, LPSSPIBUFFER pResponse);
HRESULT SSPIUninitialize(void);
HRESULT SSPIFreeContext(LPSSPICONTEXT pContext);
HRESULT SSPIReleaseContext(LPSSPICONTEXT pContext);
HRESULT SSPIMakeOutboundMessage(LPSSPICONTEXT pContext, DWORD dwFlags, LPSSPIBUFFER pBuffer, PSecBufferDesc pInDescript);
HRESULT SSPIEncodeBuffer(BOOL fBase64, LPSSPIBUFFER pBuffer);
HRESULT SSPIDecodeBuffer(BOOL fBase64, LPSSPIBUFFER pBuffer);
HRESULT SSPISetBuffer(LPCSTR pszString, SSPIBUFFERTYPE tyBuffer, DWORD cbBytes, LPSSPIBUFFER pBuffer);
HRESULT SSPIFindCredential(LPSSPICONTEXT pContext, SEC_WINNT_AUTH_IDENTITY *pAuth, ITransportCallback *pCallback);

//--------------------------------------------------------------------------
// FIsSicilyInstalled
//--------------------------------------------------------------------------
inline HRESULT SSPIFreePackages(LPSSPIPACKAGE *pprgPackage, ULONG cPackages) { return(S_OK); }
inline BOOL FIsSicilyInstalled(void) { 
    return (S_OK == SSPIIsInstalled()) ? TRUE : FALSE; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\range.h ===
//
// RANGE.H
//
// 2-20-96: (EricAn)
//          Hacked from the Route66 source tree, eliminated stuff we don't use.
//          Original copyright below - where did this thing come from?
// 8-96:    Functions added to facilitate finding of "anti" lists 
//

// -*- C -*-
//--------------------------------------------------------------------------------------
//
// Module:       range.h
//
// Description:  Definition of a class to manipulate range lists
//               (e.g. 1-6,7,10-11,19,24,33-40 ...)
//
// Copyright Microsoft Corporation 1995, All Rights Reserved
//
//--------------------------------------------------------------------------------------

#include "imnxport.h"

#ifndef _RANGE_H
#define _RANGE_H
//
//  Copyright 1992 Software Innovations, Inc
//      All Rights Reserved
//
//  $Source: D:\CLASS\INCLUDE\range.h-v $
//  $Author: martin $
//  $Date: 92/07/15 04:56:38 $
//  $Revision: 1.1 $
//


//  a CRangeList is a dynamic array of these...
typedef struct {
    ULONG low;
    ULONG high;
} RangeType;

class CRangeList : public IRangeList
{
public:
    CRangeList();
    ~CRangeList();

    // IUnknown Methods
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void **ppvObject);
    ULONG STDMETHODCALLTYPE AddRef(void);
    ULONG STDMETHODCALLTYPE Release(void);

    // IRangeList Methods
    HRESULT STDMETHODCALLTYPE Clear(void) { m_numRanges = 0; return S_OK; };
    HRESULT STDMETHODCALLTYPE IsInRange(const ULONG value);    // is `value' in one of the ranges
                                                               // in this CRangeList?

    HRESULT STDMETHODCALLTYPE Min(ULONG *pulMin);    // return the minimum in-range value
    HRESULT STDMETHODCALLTYPE Max(ULONG *pulMax);    // return the maximum in-range value

    HRESULT STDMETHODCALLTYPE Save(LPBYTE *ppbDestination, ULONG *pulSizeOfDestination);
    HRESULT STDMETHODCALLTYPE Load(LPBYTE pbSource, const ULONG ulSizeOfSource);

    // void AddRange(const char *);
                                     // a string in the form "low-high,..."
                                     //  or just "value,..."
    HRESULT STDMETHODCALLTYPE AddRange(const ULONG low, const ULONG high);
    HRESULT STDMETHODCALLTYPE AddSingleValue(const ULONG value);
    HRESULT STDMETHODCALLTYPE AddRangeList(const IRangeList *prl);

    HRESULT STDMETHODCALLTYPE DeleteRange(const ULONG low, const ULONG high);
    HRESULT STDMETHODCALLTYPE DeleteSingleValue(const ULONG value);
    HRESULT STDMETHODCALLTYPE DeleteRangeList(const IRangeList *prl);

    // finds the range "value" is in and returns the min/max of that
    HRESULT STDMETHODCALLTYPE MinOfRange(const ULONG value, ULONG *pulMinOfRange);
    HRESULT STDMETHODCALLTYPE MaxOfRange(const ULONG value, ULONG *pulMaxOfRange);

    // Outputs the rangelist to an IMAP message set string
    HRESULT STDMETHODCALLTYPE RangeToIMAPString(LPSTR *ppszDestination,
        LPDWORD pdwLengthOfDestination);

    // next() returns the smallest in-range value greater than `current', or -1
    HRESULT STDMETHODCALLTYPE Next(const ULONG current, ULONG *pulNext);
    // prev() returns the largest in-range value less than `current', or -1
    HRESULT STDMETHODCALLTYPE Prev(const ULONG current, ULONG *pulPrev);

    HRESULT STDMETHODCALLTYPE Cardinality(ULONG *pulCardinality);  // return the cardinality of the set of
                                                                   // in-range values
    HRESULT STDMETHODCALLTYPE CardinalityFrom(const ULONG ulStartPoint,
                                              ULONG *pulCardinalityFrom); // Return the cardinality of the set of
                                                                          // in-range values starting after ulStartPoint

private:
    BOOL Expand();
    int  BinarySearch(const ULONG value) const;
    void ShiftLeft(int low, int distance);
    void ShiftRight(int low, int distance);
    void SubsumeDown(int&);
    void SubsumeUpwards(const int);

    HRESULT AddRangeType(const RangeType range);
    HRESULT DeleteRangeType(const RangeType range);

    signed long m_lRefCount;

protected:
    int        m_numRanges;         // number of ranges in the rangeTable
    int        m_rangeTableSize;    // range table has room for this many ranges
    RangeType *m_rangeTable;        // the array of ranges
};

#endif // _RANGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\thorsspi.h ===
#ifndef _THORSSPI_H
#define _THORSSPI_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef WIN16
#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif
#endif //!WIN16
#include <schnlsp.h>
#include <sspi.h>
#include <issperr.h>
#include <spseal.h>

typedef PSecurityFunctionTable  (APIENTRY *INITSECURITYINTERFACE) (VOID);

extern  PSecurityFunctionTable  g_pSecFuncTable;

#define g_EnumerateSecurityPackages \
        (*(g_pSecFuncTable->EnumerateSecurityPackagesA))
#define g_AcquireCredentialsHandle  \
        (*(g_pSecFuncTable->AcquireCredentialsHandleA))
#define g_FreeCredentialsHandle     \
        (*(g_pSecFuncTable->FreeCredentialHandle))
#define g_InitializeSecurityContext \
        (*(g_pSecFuncTable->InitializeSecurityContextA))
#define g_DeleteSecurityContext     \
        (*(g_pSecFuncTable->DeleteSecurityContext))
#define g_QueryContextAttributes    \
        (*(g_pSecFuncTable->QueryContextAttributesA))
#define g_FreeContextBuffer         \
        (*(g_pSecFuncTable->FreeContextBuffer))
#define g_SealMessage               \
        (*((SEAL_MESSAGE_FN)g_pSecFuncTable->Reserved3))
#define g_UnsealMessage             \
        (*((UNSEAL_MESSAGE_FN)g_pSecFuncTable->Reserved4))

//
//  Encryption Capabilities
//
#define ENC_CAPS_NOT_INSTALLED     0x80000000       // No keys installed
#define ENC_CAPS_DISABLED          0x40000000       // Disabled due to locale
#define ENC_CAPS_SSL               0x00000001       // SSL active
#define ENC_CAPS_PCT               0x00000002       // PCT active

//
//  Encryption type (SSL/PCT etc) portion of encryption flag dword
//  PCT & SSL are both supported
//
#define ENC_CAPS_TYPE_MASK         (ENC_CAPS_SSL | ENC_CAPS_PCT)
#define ENC_CAPS_DEFAULT           ENC_CAPS_TYPE_MASK

#define INVALID_CRED_VALUE         {0xFFFFFFFF, 0xFFFFFFFF}

typedef struct _SEC_PROVIDER
{
    CHAR        *pszName;          // security pkg name
    CredHandle   hCreds;           // credential handle
    DWORD        dwFlags;          // encryption capabilities
    BOOL         fEnabled;         // enable flag indicator
} SEC_PROVIDER, *PSEC_PROVIDER;

extern SEC_PROVIDER s_SecProviders[];
extern int g_cSSLProviders;

//
// prototypes
//
VOID  SecurityInitialize(VOID);
DWORD LoadSecurity(VOID);
BOOL  FIsSecurityEnabled();
VOID  UnloadSecurity(VOID);
SECURITY_STATUS InitiateSecConnection(LPSTR pszServer, BOOL fForceSSL2ClientHello, LPINT piPkg,
                                      PCtxtHandle phContext, PSecBuffer  pOutBuffers);
SECURITY_STATUS ContinueHandshake(int iPkg, PCtxtHandle phContext, LPSTR pszBuf, int cbBuf,
                                  LPINT pcbEaten, PSecBuffer pOutBuffers);
DWORD DecryptData(PCtxtHandle phContext, LPSTR pszBufIn, int cbBufIn,
                  LPINT pcbBufOut, LPINT pcbEaten);
DWORD EncryptData(PCtxtHandle phContext, LPVOID pBufIn, int cbBufIn,
                  LPVOID *ppBufOut, int *pcbBufOut);
HRESULT ChkCertificateTrust(IN PCtxtHandle phContext, IN LPSTR pszHostName);

#ifdef __cplusplus
}
#endif

#endif // _THORSSPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\imnxport\thorsspi.cpp ===
/*
 *    thorsspi.cpp
 *    
 *    Purpose:
 *        implementation of SSL/PCT security
 *    
 *    Owner:
 *        EricAn
 *
 *    History:
 *      Jun 96: Created.  Major portions glommed from WININET.
 *    
 *    Copyright (C) Microsoft Corp. 1996
 */

#include <pch.hxx>
#include "imnxport.h"
#include "thorsspi.h"
#include "strconst.h"
#include <wincrypt.h>
#include <wintrust.h>
#include <cryptdlg.h>
#include "demand.h"
#include <shlwapi.h>

#ifdef WIN16
#ifndef GetLastError
// From win16x.h
#define GetLastError() ((DWORD) -1)
#endif
#endif // WIN16


//
// s_csInitializationSecLock - protects against multiple threads loading security.dll
// (secur32.dll) and entry points
//
static CRITICAL_SECTION s_csInitializationSecLock = {0};

//
// hSecurity - NULL when security.dll/secur32.dll  is not loaded
//
static HINSTANCE s_hSecurity = NULL;

//
// g_pSecFuncTable - Pointer to Global Structure of Pointers that are used 
//  for storing the entry points into the SCHANNEL.dll
// 
PSecurityFunctionTable g_pSecFuncTable = NULL;

//
//
//  List of encryption packages:  PCT, SSL, etc
//
//
// BUGBUG [arthurbi] The SSL and PCT package names
//  are hard coded into the stucture below.  We need
//  to be more flexible in case someone write a FOO security
//  package.
//
SEC_PROVIDER s_SecProviders[] =
{
    UNISP_NAME,  INVALID_CRED_VALUE , ENC_CAPS_PCT | ENC_CAPS_SSL, FALSE,
    PCT1SP_NAME, INVALID_CRED_VALUE , ENC_CAPS_PCT,                FALSE,
    SSL3SP_NAME, INVALID_CRED_VALUE , ENC_CAPS_SSL,                FALSE,
    SSL2SP_NAME, INVALID_CRED_VALUE , ENC_CAPS_SSL,                FALSE,
};

int g_cSSLProviders = ARRAYSIZE(s_SecProviders);

DWORD s_dwEncFlags = 0;

#define LOCK_SECURITY()   EnterCriticalSection(&s_csInitializationSecLock)
#define UNLOCK_SECURITY() LeaveCriticalSection(&s_csInitializationSecLock)

BOOL SecurityPkgInitialize(VOID);
DWORD VerifyServerCertificate(PCCERT_CONTEXT pServerCert, LPSTR pszServerName, DWORD dwCertFlags, BOOL fCheckRevocation);

/////////////////////////////////////////////////////////////////////////////
// 
// The following code through SslRecordSize() was stolen from MSN.

typedef struct _Ssl_Record_Header {
    UCHAR   Byte0;
    UCHAR   Byte1;
} Ssl_Record_Header, * PSsl_Record_Header;

#define SIZEOFSSLMSG(pMessage)  (SslRecordSize((PSsl_Record_Header) pMessage ) )
#define COMBINEBYTES(Msb, Lsb)  ((DWORD) (((DWORD) (Msb) << 8) | (DWORD) (Lsb)))

/////////////////////////////////////////////////////////////////////////////
// 
// SslRecordSize()
//
//    This function calculates the expected size of an SSL packet to work
//      around a bug in some security packages.
//
DWORD
SslRecordSize(
    PSsl_Record_Header  pHeader)
{
    DWORD   Size;

    if (pHeader->Byte0 & 0x80)
    {
        Size = COMBINEBYTES(pHeader->Byte0, pHeader->Byte1) & 0x7FFF;
    }
    else
    {
        Size = COMBINEBYTES(pHeader->Byte0, pHeader->Byte1) & 0x3FFF;
    }
    return( Size + sizeof(Ssl_Record_Header) );
}

/////////////////////////////////////////////////////////////////////////////
// 
// SecurityInitialize()
//
//    This function initializes the global lock required for the security
//    pkgs.
//
VOID SecurityInitialize(VOID)
{
    InitializeCriticalSection( &s_csInitializationSecLock );
}

/////////////////////////////////////////////////////////////////////////////
// 
// UnloadSecurity()
//
//    This function terminates the global data required for the security
//    pkgs and dynamically unloads security APIs from security.dll (NT)
//    or secur32.dll (WIN95).
//
VOID UnloadSecurity(VOID)
{
    DWORD i;

    LOCK_SECURITY();

    //
    //  free all security pkg credential handles
    //
    for (i = 0; i < ARRAYSIZE(s_SecProviders); i++)
        {
        if (s_SecProviders[i].fEnabled) 
            {
            g_FreeCredentialsHandle(&s_SecProviders[i].hCreds);
            }
        }

    //
    //  unload dll
    //
    if (s_hSecurity != NULL) 
        {
        FreeLibrary(s_hSecurity);
        s_hSecurity = NULL;
        }

    UNLOCK_SECURITY();

    DeleteCriticalSection(&s_csInitializationSecLock);
}


/////////////////////////////////////////////////////////////////////////////
// 
// LoadSecurity()
//
//    This function dynamically loads security APIs from security.dll (NT)
//    or secur32.dll (WIN95).
//
DWORD LoadSecurity(VOID)
{
    DWORD dwErr = ERROR_SUCCESS;
    INITSECURITYINTERFACE pfInitSecurityInterface = NULL;

    LOCK_SECURITY();

    if (s_hSecurity != NULL) 
        {
        goto quit;
        }

    //
    // load dll.
    //

#ifdef LOAD_SECURE32
    if (GlobalUseSchannelDirectly)
        {
#endif
        //
        // This is better for performance. Rather than call through
        //    SSPI, we go right to the DLL doing the work.
        //

#ifndef WIN16
        s_hSecurity = LoadLibrary("schannel");
#else
        s_hSecurity = LoadLibrary("schnl16.dll");
#endif // !WIN16
#ifdef LOAD_SECURE32
        }
    else
        {
#ifndef WIN16
        if (IsPlatformWinNT() == S_OK) 
            {
            s_hSecurity = LoadLibrary("security");
            }
        else 
            {
            s_hSecurity = LoadLibrary("secur32");
            }
#else
        s_hSecurity = LoadLibrary("secur16.dll");
#endif // !WIN16
        }
#endif

    if (s_hSecurity == NULL) 
        {
        dwErr = GetLastError();
        goto quit;
        }

    //
    // get function addresses.
    //

    pfInitSecurityInterface = (INITSECURITYINTERFACE)GetProcAddress(s_hSecurity, SECURITY_ENTRYPOINT);

    if (pfInitSecurityInterface == NULL)
        {
        dwErr = GetLastError();
        goto quit;
        }

#ifdef USE_CLIENT_AUTH
    //
    // Get SslCrackCertificate func pointer,
    //  utility function declared in SCHANNEL that 
    //  is used for parsing X509 certificates.
    //

    pSslCrackCertificate =
        (SSL_CRACK_CERTIFICATE_FN)GetProcAddress(s_hSecurity, SSL_CRACK_CERTIFICATE_NAME);

    if (pSslCrackCertificate == NULL)
        {
        dwErr = GetLastError();
        goto quit;
        }

    pSslFreeCertificate =
        (SSL_FREE_CERTIFICATE_FN)GetProcAddress(s_hSecurity, SSL_FREE_CERTIFICATE_NAME);

    if (pSslFreeCertificate == NULL)
        {
        dwErr = GetLastError();
        goto quit;
        }
#endif // USE_CLIENT_AUTH

    g_pSecFuncTable = (SecurityFunctionTable*)((*pfInitSecurityInterface)());

    if (g_pSecFuncTable == NULL) 
        {
        dwErr = GetLastError(); // BUGBUG does this work?
        goto quit;
        }

    if (!SecurityPkgInitialize()) 
        {
        dwErr = GetLastError();
        }


quit:

    if (dwErr != ERROR_SUCCESS)
        {        
        FreeLibrary(s_hSecurity);
        s_hSecurity = NULL;
        }

    UNLOCK_SECURITY();

    return dwErr;
}

/////////////////////////////////////////////////////////////////////////////
// 
// SecurityPkgInitialize()
//
// Description:
//    This function finds a list of security packages that are supported
//    on the client's machine, checks if pct or ssl is supported, and
//    creates a credential handle for each supported pkg.
//
// Return:
//    TRUE if at least one security pkg is found; otherwise FALSE
//
BOOL SecurityPkgInitialize(VOID)
{
    TimeStamp         tsExpiry;
    SECURITY_STATUS   scRet;
    PSecPkgInfo       pPackageInfo = NULL;
    ULONG             cPackages = 0;
    ULONG             fCapabilities;
    ULONG             i;
    ULONG             j;
    DWORD             cProviders = 0;
    VOID *            pvCreds = NULL;
    SCHANNEL_CRED     schnlCreds = {0};

    //
    //  check if this routine has been called.  if yes, return TRUE
    //  if we've found a supported pkg; otherwise FALSE
    //
    if (s_dwEncFlags == ENC_CAPS_NOT_INSTALLED)
        return FALSE;
    else if (s_dwEncFlags & ENC_CAPS_TYPE_MASK)
        return TRUE;

    //
    //  Initialize s_dwEncFlags
    //
    s_dwEncFlags = ENC_CAPS_NOT_INSTALLED;

    //
    //  Check if at least one security package is supported
    //
    scRet = g_EnumerateSecurityPackages(&cPackages, &pPackageInfo);
    if (scRet != SEC_E_OK)
        {
        DOUTL(2, "EnumerateSecurityPackages failed, error %lx", scRet);
        SetLastError(scRet); //$REVIEW - is this cool? (EricAn)
        return FALSE;
        }

    // Sometimes EnumerateSecurityPackages() returns SEC_E_OK with 
    // cPackages > 0 and pPackageInfo == NULL !!! This is clearly a bug 
    // in the security subsystem, but let's not crash because of it.  (EricAn)
    if (!cPackages || !pPackageInfo)
        return FALSE;

    for (i = 0; i < cPackages; i++)
        {
        //
        //  Use only if the package name is the PCT/SSL package
        //
        fCapabilities = pPackageInfo[i].fCapabilities;

        if (fCapabilities & SECPKG_FLAG_STREAM)
            {
            //
            //  Check if the package supports server side authentication
            //  and all recv/sent messages are tamper proof
            //
            if ((fCapabilities & SECPKG_FLAG_CLIENT_ONLY) ||
                !(fCapabilities & SECPKG_FLAG_PRIVACY))
                {
                continue;
                }

            //
            //  Check if the pkg matches one of our known packages
            //
            for (j = 0; j < ARRAYSIZE(s_SecProviders); j++)
                {
                if (!lstrcmpi(pPackageInfo[i].Name, s_SecProviders[j].pszName))
                    {
                    // RAID - 9611
                    // This is an ugly hack for NT 5 only
                    //
                    // For NT5, the universal security protocol provider will try
                    // to do automatic authenication of the certificate unless
                    // we pass in these flags.
                    if (0 == lstrcmpi(s_SecProviders[j].pszName, UNISP_NAME))
                        {
                        OSVERSIONINFO   osinfo = {0};

                        osinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
                        if ((FALSE != GetVersionEx(&osinfo)) &&
                                    (VER_PLATFORM_WIN32_NT == osinfo.dwPlatformId) && (5 == osinfo.dwMajorVersion))
                            {
                            schnlCreds.dwVersion = SCHANNEL_CRED_VERSION;
                            schnlCreds.dwFlags = SCH_CRED_MANUAL_CRED_VALIDATION | SCH_CRED_NO_DEFAULT_CREDS;

                            pvCreds = (VOID *) &schnlCreds;
                            }
                        }
                        
                    //
                    //  Create a credential handle for each supported pkg
                    //
                    scRet = g_AcquireCredentialsHandle(NULL,
                                                       s_SecProviders[j].pszName,
                                                       SECPKG_CRED_OUTBOUND,
                                                       NULL, 
                                                       pvCreds, 
                                                       NULL, 
                                                       NULL,
                                                       &(s_SecProviders[j].hCreds),
                                                       &tsExpiry);

                    if (scRet != SEC_E_OK)
                        {
                        DOUTL(2, "AcquireCredentialHandle failed, error %lx", scRet);
                        }
                    else 
                        {
                        DOUTL(2, 
                              "AcquireCredentialHandle() supports %s, acquires %x:%x",
                              s_SecProviders[j].pszName,
                              s_SecProviders[j].hCreds.dwUpper,
                              s_SecProviders[j].hCreds.dwLower);
                        s_SecProviders[j].fEnabled = TRUE;
                        cProviders++;
                        s_dwEncFlags |= s_SecProviders[j].dwFlags;
                        }
                    break;
                    }
                }
            }
        }

    if (!cProviders)
        {
        //
        //  No security packages were found, return FALSE to caller
        //
        DOUTL(2, "No security packages were found.");
        Assert(pPackageInfo);
        g_FreeContextBuffer(pPackageInfo);
        SetLastError((DWORD)SEC_E_SECPKG_NOT_FOUND); //$REVIEW - is this cool? (EricAn)
        return FALSE;
        }

    //
    //  Successfully found a security package(s)
    //
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// 
// FIsSecurityEnabled()
//
// Description:
//    Checks if security is initialized, if so returns TRUE, otherwise tries
//    to initialize it.
//
// Return:
//    TRUE if at least one security pkg is enabled; otherwise FALSE
//
BOOL FIsSecurityEnabled()
{
    if (s_dwEncFlags == ENC_CAPS_NOT_INSTALLED)
        return FALSE;
    else if (s_dwEncFlags == 0) 
        {
        //
        //  first time thru, do the load.
        //
        DOUTL(2, "Loading security dll.");
        if (ERROR_SUCCESS != LoadSecurity())
            return FALSE;
        }
    // at least one security package should be active
    Assert(s_dwEncFlags & ENC_CAPS_TYPE_MASK);
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// 
// InitiateSecConnection()
//
// Description:
//    Initiates a secure connection using SSL/PCT.
//
// Parameters:
//    pszServer             - server name
//    fForceSSL2ClientHello - hack for IIS 1.0 servers that fail SSL3 HELLOs
//    piPkg                 - on input, first package to try.
//                            on output, package being used.
//    phContext             - returned security context handle
//    pOutBuffers           - returned buffer
//
// Return:
//    SECURITY_STATUS - SEC_I_CONTINUE_NEEDED expected
//
SECURITY_STATUS
      InitiateSecConnection(IN      LPSTR       pszServer,              // server name
                            IN      BOOL        fForceSSL2ClientHello,  // SSL2 hack?
                            IN OUT  LPINT       piPkg,                  // index of package to try
                            OUT     PCtxtHandle phContext,              // returned context handle
                            OUT     PSecBuffer  pOutBuffers)            // negotiation buffer to send
{
    TimeStamp            tsExpiry;
    DWORD                ContextAttr;
    SECURITY_STATUS      scRet;
    SecBufferDesc        InBuffer;
    SecBufferDesc        *pInBuffer;
    SecBufferDesc        OutBuffer;
    SecBuffer            InBuffers[2];
    DWORD                i;
    CredHandle           hCreds;
    DWORD                dwSSL2Code;

    Assert(piPkg);
    Assert(*piPkg >= 0 && *piPkg < ARRAYSIZE(s_SecProviders));
    Assert(pszServer);
    Assert(phContext);

    scRet = SEC_E_SECPKG_NOT_FOUND; //default error if we run out of packages

    //
    //  set OutBuffer for InitializeSecurityContext call
    //
    OutBuffer.cBuffers = 1;
    OutBuffer.pBuffers = pOutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    //
    // SSL2 hack for IIS Servers.  The caller asked
    //  for us to send a SSL2 Client Hello usually in
    //  response to a failure of send a SSL3 Client Hello.
    //
    if (fForceSSL2ClientHello)
        {
        dwSSL2Code = 0x2;

        InBuffers[0].pvBuffer   = (VOID *) &dwSSL2Code;
        InBuffers[0].cbBuffer   = sizeof(DWORD);
        InBuffers[0].BufferType = SECBUFFER_PKG_PARAMS;

        InBuffers[1].pvBuffer   = NULL;
        InBuffers[1].cbBuffer   = 0;
        InBuffers[1].BufferType = SECBUFFER_EMPTY;

        InBuffer.cBuffers   = 2;
        InBuffer.pBuffers   = InBuffers;
        InBuffer.ulVersion  = SECBUFFER_VERSION;

        pInBuffer = &InBuffer;
        }
    else
        pInBuffer = NULL; // default, don't do hack.

    for (i = *piPkg; i < ARRAYSIZE(s_SecProviders); i++)
        {
        if (!s_SecProviders[i].fEnabled)
            continue;

        DOUTL(2, "Starting handshake protocol with pkg %d - %s", i, s_SecProviders[i].pszName);

        hCreds = s_SecProviders[i].hCreds;

        //
        //  1. initiate a client HELLO message and generate a token
        //
        pOutBuffers->pvBuffer = NULL;
        pOutBuffers->BufferType = SECBUFFER_TOKEN;

        scRet = g_InitializeSecurityContext(&hCreds,
                                            NULL,
                                            pszServer,
                                            ISC_REQ_SEQUENCE_DETECT | ISC_REQ_REPLAY_DETECT |
                                                ISC_REQ_CONFIDENTIALITY | ISC_REQ_ALLOCATE_MEMORY | ISC_REQ_USE_SUPPLIED_CREDS,
                                            0,
                                            SECURITY_NATIVE_DREP,
                                            pInBuffer,
                                            0,
                                            phContext,
                                            &OutBuffer,         // address where output data go
                                            &ContextAttr,
                                            &tsExpiry);

        DOUTL(2, "1. InitializeSecurityContext returned [%x]", scRet);

        if (scRet == SEC_I_CONTINUE_NEEDED)
            {
            DOUTL(2, "2. OutBuffer is <%x, %d, %x>", pOutBuffers->pvBuffer, pOutBuffers->cbBuffer, pOutBuffers->BufferType);
            *piPkg = i;
            return scRet;
            }
        else if (scRet == SEC_E_INVALID_HANDLE)
            {
            //
            //  First call to InitializeSecurityContext should not return
            //  SEC_E_INVALID_HANDLE ; if this is the returned error,
            //  we should disable this pkg
            //
            s_SecProviders[i].fEnabled = FALSE;
            }
        
        if (pOutBuffers->pvBuffer)
            g_FreeContextBuffer(pOutBuffers->pvBuffer);
        // loop and try the next provider
        }

    // if we get here we ran out of providers
    return SEC_E_SECPKG_NOT_FOUND;    
}

/////////////////////////////////////////////////////////////////////////////
// 
// ContinueHandshake()
//
// Description:
//    Continues a secure handshake using SSL/PCT.
//
// Parameters:
//    iPkg          - security package being used
//    phContext     - security context handle returned from InitiateSecConnection
//    pszBuf        - recv'd buffer
//    cbBuf         - size of recv'd buffer
//    pcbEaten      - number of bytes of pszBuf actually used
//    pOutBuffers   - buffer to be sent
//
// Return:
//    SECURITY_STATUS - expected values:
//      SEC_E_OK                    - secure connection established
//      SEC_I_CONTINUE_NEEDED       - more handshaking required
//      SEC_E_INCOMPLETE_MESSAGE    - need more recv data before continuing
//
SECURITY_STATUS ContinueHandshake(IN    int         iPkg,
                                  IN    PCtxtHandle phContext,
                                  IN    LPSTR       pszBuf,
                                  IN    int         cbBuf,
                                  OUT   LPINT       pcbEaten,
                                  OUT   PSecBuffer  pOutBuffers)
{
    TimeStamp            tsExpiry;
    DWORD                ContextAttr;
    SECURITY_STATUS      scRet;
    SecBufferDesc        InBuffer;
    SecBufferDesc        OutBuffer;
    SecBuffer            InBuffers[2];
    CredHandle           hCreds;
    int                  cbEaten = 0;

#if 0
    //
    // BUGBUG: work around bug in NT's SSLSSPI.DLL shipped with IIS 1.0
    // The DLL does not check the expected size of message properly and
    // as result we need to do the check ourselves and fail appropriately
    //
    if (pszBuf && cbBuf)
        {
        if (cbBuf == 1 || cbBuf < SIZEOFSSLMSG(pszBuf))
            {
            DOUTL(2, "incomplete handshake msg received: %d, expected: %d", cbBuf, SIZEOFSSLMSG(pszBuf));
            pOutBuffers->pvBuffer = 0;
            pOutBuffers->cbBuffer = 0;
            *pcbEaten = 0;
            return SEC_E_INCOMPLETE_MESSAGE;
            }
        }
#endif

    Assert(iPkg >= 0 && iPkg < ARRAYSIZE(s_SecProviders) && s_SecProviders[iPkg].fEnabled);
    hCreds = s_SecProviders[iPkg].hCreds;

    //
    // InBuffers[1] is for getting extra data that
    //  SSPI/SCHANNEL doesn't proccess on this
    //  run around the loop.
    //
    InBuffers[0].pvBuffer   = pszBuf;
    InBuffers[0].cbBuffer   = cbBuf;
    InBuffers[0].BufferType = SECBUFFER_TOKEN;

    InBuffers[1].pvBuffer   = NULL;
    InBuffers[1].cbBuffer   = 0;
    InBuffers[1].BufferType = SECBUFFER_EMPTY;

    InBuffer.cBuffers       = 2;
    InBuffer.pBuffers       = InBuffers;
    InBuffer.ulVersion      = SECBUFFER_VERSION;

    //
    //  set OutBuffer for InitializeSecurityContext call
    //
    OutBuffer.cBuffers = 1;
    OutBuffer.pBuffers = pOutBuffers;
    OutBuffer.ulVersion = SECBUFFER_VERSION;

    //
    // Initialize these so if we fail, pvBuffer contains NULL,
    // so we don't try to free random garbage at the quit
    //
    pOutBuffers->pvBuffer   = NULL;
    pOutBuffers->BufferType = SECBUFFER_TOKEN;
    pOutBuffers->cbBuffer   = 0;

    scRet = g_InitializeSecurityContext(&hCreds,
                                        phContext,
                                        NULL,
                                        ISC_REQ_SEQUENCE_DETECT | ISC_REQ_REPLAY_DETECT | ISC_REQ_CONFIDENTIALITY |
                                            ISC_REQ_ALLOCATE_MEMORY | ISC_RET_EXTENDED_ERROR,
                                        0,
                                        SECURITY_NATIVE_DREP,
                                        &InBuffer,
                                        0,
                                        NULL,
                                        &OutBuffer,
                                        &ContextAttr,
                                        &tsExpiry);

    DOUTL(2, "InitializeSecurityContext returned [%x]", scRet);

    if (scRet == SEC_E_OK || scRet == SEC_I_CONTINUE_NEEDED || scRet == SEC_E_INCOMPLETE_MESSAGE)
        {
        // got one of the expected returns
        if (scRet == SEC_E_INCOMPLETE_MESSAGE)
            {
            // make sure we don't send anything in this case
            if (pOutBuffers->pvBuffer)
                {
                g_FreeContextBuffer(pOutBuffers->pvBuffer);
                pOutBuffers->pvBuffer = 0;
                pOutBuffers->cbBuffer = 0;
                }
            }
        else
            {
            // there was extra data left over
            if (InBuffers[1].BufferType == SECBUFFER_EXTRA)
                cbEaten = (cbBuf - InBuffers[1].cbBuffer);
            else
                cbEaten = cbBuf;
            }
        }
    else
        {
        // handle an unexpected return
        if (!(ContextAttr & ISC_RET_EXTENDED_ERROR))
            {
            // only send an error packet if there is one
            if (pOutBuffers->pvBuffer)
                {
                g_FreeContextBuffer(pOutBuffers->pvBuffer);
                pOutBuffers->pvBuffer = 0;
                pOutBuffers->cbBuffer = 0;
                }
            }
        }

    *pcbEaten = cbEaten;
    return scRet;
}

/////////////////////////////////////////////////////////////////////////////
// 
// EncryptData()
//
// Description:
//    Encrypts a packet to be sent using SSL/PCT by calling SealMessage().
//
// Parameters:
//    phContext     - security context handle returned from InitiateSecConnection
//    pBufIn        - buffer to be encrypted
//    cbBufIn       - length of buffer to be encrypted
//    ppBufOut      - allocated encrypted buffer, to be freed by caller
//    pcbBufOut     - length of encrypted buffer
//
// Return:
//    SECURITY_STATUS
//
DWORD EncryptData(IN  PCtxtHandle phContext,
                  IN  LPVOID      pBufIn,
                  IN  int         cbBufIn,
                  OUT LPVOID     *ppBufOut,
                  OUT int        *pcbBufOut)
{
    SECURITY_STATUS           scRet = ERROR_SUCCESS;
    SecBufferDesc             Buffer;
    SecBuffer                 Buffers[3];
    SecPkgContext_StreamSizes Sizes;

    Assert(pBufIn);
    Assert(cbBufIn);
    Assert(ppBufOut);
    Assert(pcbBufOut);
    
    *pcbBufOut = 0;

    //
    //  find the header and trailer sizes
    //

    scRet = g_QueryContextAttributes(phContext,
                                     SECPKG_ATTR_STREAM_SIZES,
                                     &Sizes );

    if (scRet != ERROR_SUCCESS)
        {
        DOUTL(2, "QueryContextAttributes returned [%x]", scRet);
        return scRet;
        }
    else 
        {
        DOUTL(128, "QueryContextAttributes returned header=%d trailer=%d", Sizes.cbHeader, Sizes.cbTrailer);
        }

    if (!MemAlloc(ppBufOut, cbBufIn + Sizes.cbHeader + Sizes.cbTrailer))
        return ERROR_NOT_ENOUGH_MEMORY;

    //
    // prepare data for SecBuffer
    //
    Buffers[0].pvBuffer = *ppBufOut;
    Buffers[0].cbBuffer = Sizes.cbHeader;
    Buffers[0].BufferType = SECBUFFER_TOKEN;

    Buffers[1].pvBuffer = (LPBYTE)*ppBufOut + Sizes.cbHeader;
    CopyMemory(Buffers[1].pvBuffer,
               pBufIn,
               cbBufIn);
    Buffers[1].cbBuffer = cbBufIn;
    Buffers[1].BufferType = SECBUFFER_DATA;

    //
    // check if security pkg supports trailer: PCT does
    //
    if (Sizes.cbTrailer) 
        {
        Buffers[2].pvBuffer = (LPBYTE)*ppBufOut + Sizes.cbHeader + cbBufIn;
        Buffers[2].cbBuffer = Sizes.cbTrailer;
        Buffers[2].BufferType = SECBUFFER_TOKEN;
        }
    else 
        {
        Buffers[2].pvBuffer = NULL;
        Buffers[2].cbBuffer = 0;
        Buffers[2].BufferType = SECBUFFER_EMPTY;
        }

    Buffer.cBuffers = 3;
    Buffer.pBuffers = Buffers;
    Buffer.ulVersion = SECBUFFER_VERSION;

    scRet = g_SealMessage(phContext, 0, &Buffer, 0);

    DOUTL(128, "SealMessage returned [%x]", scRet);

    if (scRet != ERROR_SUCCESS)
        {
        //
        // Map the SSPI error.
        //
        DOUTL(2, "SealMessage failed with [%x]", scRet);
        SafeMemFree(*ppBufOut);
        return scRet;
        }

    // Bug# 80814 June 1999 5.01
    // [shaheedp] Starting with NT4 SP4 the sizes of headers and trailers are not constant. 
    // The function SealMessage calculates the sizes correctly. 
    // Hence the sizes returned by SealMessage should be used to determine the actual size of the packet.

    *pcbBufOut = Buffers[0].cbBuffer + Buffers[1].cbBuffer + Buffers[2].cbBuffer;

    DOUTL(128, "SealMessage returned Buffer = %x, EncryptBytes = %d, UnencryptBytes = %d",
          *ppBufOut, *pcbBufOut, cbBufIn);
    return scRet;
}

/////////////////////////////////////////////////////////////////////////////
// 
// DecryptData()
//
// Description:
//    Decrypts a buffer received using SSL/PCT by calling UnsealMessage().
//
// Parameters:
//    phContext     - security context handle returned from InitiateSecConnection
//    pszBufIn      - buffer to be decrypted
//    cbBufIn       - length of buffer to be decrypted
//    pcbBufOut     - length of decrypted data, stored at beginning of pszBufIn
//    pcbEaten      - number of bytes of pszBufIn that were decrypted, 
//                      (cbBufIn - *pcbEaten) is the number of extra bytes located
//                      at (pszBufIn + *pcbEaten) that need to be saved until more
//                      data is received
//
// Return:
//    SECURITY_STATUS
//      ERROR_SUCCESS               - some data was decrypted, there may be extra
//      SEC_E_INCOMPLETE_MESSAGE    - not enough data to decrypt
//
DWORD DecryptData(IN    PCtxtHandle phContext,
                  IN    LPSTR       pszBufIn,
                  IN    int         cbBufIn,
                  OUT   LPINT       pcbBufOut,
                  OUT   LPINT       pcbEaten)
{
    SecBufferDesc   Buffer;
    SecBuffer       Buffers[4];  // the 4 buffers are: header, data, trailer, extra
    DWORD           scRet = ERROR_SUCCESS;
    int             cbEaten = 0, cbOut = 0;
    LPSTR           pszBufOut = NULL;

    while (cbEaten < cbBufIn && scRet == ERROR_SUCCESS)
        {
        //
        // prepare data the SecBuffer for a call to SSL/PCT decryption code.
        //
        Buffers[0].pvBuffer   = pszBufIn + cbEaten;
        Buffers[0].cbBuffer   = cbBufIn - cbEaten;
        Buffers[0].BufferType = SECBUFFER_DATA;

        for (int i = 1; i < 4; i++)
            {
            //
            // clear other 3 buffers for receving result from SSPI package
            //
            Buffers[i].pvBuffer   = NULL;
            Buffers[i].cbBuffer   = 0;
            Buffers[i].BufferType = SECBUFFER_EMPTY;
            }

        Buffer.cBuffers = 4; // the 4 buffers are: header, data, trailer, extra
        Buffer.pBuffers = Buffers;
        Buffer.ulVersion = SECBUFFER_VERSION;

        //
        // Decrypt the DATA !!!
        //
        scRet = g_UnsealMessage(phContext, &Buffer, 0, NULL);
        DOUTL(128, "UnsealMessage returned [%x]", scRet);
        if (scRet != ERROR_SUCCESS)
            {
            DOUTL(2, "UnsealMessage failed with [%x]", scRet);
            Assert(scRet != SEC_E_MESSAGE_ALTERED);
            if (scRet == SEC_E_INCOMPLETE_MESSAGE)
                DOUTL(2, "UnsealMessage short of %d bytes.", Buffers[1].cbBuffer);
            break;
            }
    
        //
        // Success we decrypted a block
        //
        if (Buffers[1].cbBuffer)
            {
            MoveMemory(pszBufIn + cbOut, Buffers[1].pvBuffer, (min(cbBufIn-cbOut,(int)Buffers[1].cbBuffer)));
            cbOut += Buffers[1].cbBuffer;
            Assert(cbOut <= cbBufIn);
            }
        else
            AssertSz(0, "UnsealMessage returned success with 0 bytes!");

        //
        // BUGBUG [arthurbi] this is hack to work with the OLD SSLSSPI.DLL .
        //  They return extra on the second buffer instead of the third.
        //
        if (Buffers[2].BufferType == SECBUFFER_EXTRA)
            {
            cbEaten = cbBufIn - Buffers[2].cbBuffer;
            }
        else if (Buffers[3].BufferType == SECBUFFER_EXTRA)
            {
            cbEaten = cbBufIn - Buffers[3].cbBuffer;
            }
        else
            {
            cbEaten = cbBufIn;
            }
        }

    // if we decrypted something, return success
    if (scRet == SEC_E_INCOMPLETE_MESSAGE && cbOut)
        scRet = ERROR_SUCCESS;

    *pcbBufOut = cbOut;
    *pcbEaten = cbEaten;
    return scRet;
}

/////////////////////////////////////////////////////////////////////////////
//
// ChkCertificateTrust()
//
// Description:
//  This function checks the server certificate stored in an active SSPI Context
//  Handle and verifies that it and the certificate chain is valid.
//  
// Parameters:
//  phContext   - security context handle returned from InitiateSecConnection
//  pszHostName - passed in hostname to validate against
//
HRESULT ChkCertificateTrust(IN PCtxtHandle phContext, IN LPSTR pszHostName)
{
    PCCERT_CONTEXT  pCertContext = NULL;
    DWORD           dwErr;
    HKEY            hkey;
    DWORD           dwCertFlags = 0;
    BOOL            fCheckRevocation = FALSE;
    HRESULT         hr = NOERROR;

    dwErr = g_QueryContextAttributes(phContext,
                                     SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                                     (PVOID)&pCertContext);
    if (dwErr != ERROR_SUCCESS)
        {
        DOUTL(2, "QueryContextAttributes failed to retrieve remote cert, returned %#x", dwErr);
        hr = E_FAIL;
        goto quit;
        }

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegFlat, 0, KEY_READ, &hkey))
    {
        DWORD dwVal, cb;

        cb = sizeof(dwVal);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szCertCheckRevocation, 0, NULL, (LPBYTE)&dwVal, &cb))
        {
            // if set then we want to perform revocation checking of the cert chain
            if (dwVal == 1)
                fCheckRevocation = TRUE;
        }
        cb = sizeof(dwVal);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szCertIgnoredErr, 0, NULL, (LPBYTE)&dwVal, &cb))
        {
            // if set then set the certification checking errors to ignore
            dwCertFlags = dwVal;
        }

        RegCloseKey(hkey);
    }

    hr = VerifyServerCertificate(pCertContext, pszHostName, dwCertFlags, fCheckRevocation);

quit:
    if (pCertContext)
        CertFreeCertificateContext(pCertContext);

    return hr;
}

DWORD
VerifyServerCertificate(
    PCCERT_CONTEXT  pServerCert,
    LPSTR           pszServerName,
    DWORD           dwCertFlags,
    BOOL            fCheckRevocation)
{
    HTTPSPolicyCallbackData  polHttps;
    CERT_CHAIN_POLICY_PARA   PolicyPara;
    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    CERT_CHAIN_PARA          ChainPara;
    PCCERT_CHAIN_CONTEXT     pChainContext = NULL;

    DWORD   Status;
    LPWSTR  pwszServerName;
    DWORD   cchServerName;

    if (pServerCert == NULL)
        return SEC_E_WRONG_PRINCIPAL;

    //
    // Convert server name to unicode.
    //
    if (pszServerName == NULL || strlen(pszServerName) == 0)
        return SEC_E_WRONG_PRINCIPAL;

    pwszServerName = PszToUnicode(CP_ACP, pszServerName);
    if (pwszServerName == NULL)
        return SEC_E_INSUFFICIENT_MEMORY;

    //
    // Build certificate chain.
    //
    ZeroMemory(&ChainPara, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);

    if(!CertGetCertificateChain(
                            NULL,
                            pServerCert,
                            NULL,
                            pServerCert->hCertStore,
                            &ChainPara,
                            (fCheckRevocation?CERT_CHAIN_REVOCATION_CHECK_CHAIN:0),
                            NULL,
                            &pChainContext))
    {
        Status = GetLastError();
        DOUTL(2, "Error 0x%x returned by CertGetCertificateChain!\n", Status);
        goto cleanup;
    }

    //
    // Validate certificate chain.
    // 
    ZeroMemory(&polHttps, sizeof(HTTPSPolicyCallbackData));
    polHttps.cbStruct           = sizeof(HTTPSPolicyCallbackData);
    polHttps.dwAuthType         = AUTHTYPE_SERVER;
    polHttps.fdwChecks          = dwCertFlags;
    polHttps.pwszServerName     = pwszServerName;

    ZeroMemory(&PolicyPara, sizeof(PolicyPara));
    PolicyPara.cbSize            = sizeof(PolicyPara);
    PolicyPara.pvExtraPolicyPara = &polHttps;

    ZeroMemory(&PolicyStatus, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);

    if(!CertVerifyCertificateChainPolicy(
                            CERT_CHAIN_POLICY_SSL,
                            pChainContext,
                            &PolicyPara,
                            &PolicyStatus))
    {
        Status = GetLastError();
        DOUTL(2, "Error 0x%x returned by CertVerifyCertificateChainPolicy!\n", Status);
        goto cleanup;
    }

    if(PolicyStatus.dwError)
    {
        Status = PolicyStatus.dwError;
        goto cleanup;
    }

    Status = SEC_E_OK;

cleanup:
    if(pChainContext)
        CertFreeCertificateChain(pChainContext);

    SafeMemFree(pwszServerName);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\inc\icdebug.h ===
// --------------------------------------------------------------------------------
// ICDEBUG.H
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __ICDEBUG_H
#define __ICDEBUG_H

#define APP_DOUTL         0x00000008

#endif // __ICDEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\inc\exrwlck.h ===
#ifndef	_CEXRWLCK_H
#define	_CEXRWLCK_H
                        
#include	<limits.h>


#ifndef WIN16


//
// This class contains the meat - does actual locking etc...
//
class	CExShareLock {
private : 
    long	cReadLock ;			// Number of Readers who have passed through the lock OR 
                                // the number of readers waiting for the lock (will be negative).
                                // A value of 0 means nobody in the lock
    long	cOutRdrs ;			// The number of readers remainin in the lock if 
                                // there is a writer waiting.  This can become temporarily negative
    CRITICAL_SECTION	critWriters ; 	// Critical section to allow only one writer into the lock at a time
    HANDLE	hWaitingWriters ;	// Semaphore for waiting writers to block on (Only 1 ever, others will 
                                // be queued on critWriters)
    HANDLE	hWaitingReaders ;	// Semaphore for waiting readers to block on 
public : 
    CExShareLock( ) ;
    ~CExShareLock( ) ;

    void	ShareLock( ) ;
    void	ShareUnlock( ) ;
    void	ExclusiveLock( ) ;
    void	ExclusiveUnlock( ) ;

    BOOL	SharedToExclusive( ) ;	// returns TRUE if successful
} ;



//
// This class implements a wrapper class around CExShareLock class so that
// it alows the nested hold on Exclusive lock if a thread
// has an exclusive lock and calls for holding exclusive lock or Share lock
// again
//
class    CExShareLockWithNestAllowed 
{
private : 
    CExShareLock  m_lock;                 // class around which the wrapper is formed
    DWORD         m_dwThreadID;           // The thread id of the thred currently holding
                                          //  the exclusive lock
    DWORD         m_dwNestCount;          // The count of number of nested calls to lock by the thread holding the
                                          // exclusive lock less 1

public : 
    
    CExShareLockWithNestAllowed( ) : m_dwThreadID(0xffffffff), m_dwNestCount(0)
    {
        // nothing
    };
    ~CExShareLockWithNestAllowed( )
    {
        Assert( (m_dwThreadID == 0xffffffff ) && ( m_dwNestCount == 0 ) );
    } 

    void    ShareLock( )
    {
        if(! nest() ) 
        {
            m_lock.ShareLock();
        }
    }

    void    ShareUnlock( )
    {
        if (! unnest() ) 
        {
            m_lock.ShareUnlock();
        }
    }

    void    ExclusiveLock( )
    {
        if(! nest() ) 
        {
            m_lock.ExclusiveLock();
            Assert( m_dwNestCount == 0 );
            Assert( m_dwThreadID == 0xffffffff );
            m_dwThreadID = GetCurrentThreadId();
        }
    }

    void    ExclusiveUnlock( )
    {
        if (! unnest() ) 
        {
            m_dwThreadID = 0xffffffff;
            m_lock.ExclusiveUnlock();
        }
    }

protected :
    BOOL nest() 
    {
        if( m_dwThreadID != GetCurrentThreadId() )
            return ( FALSE );
        m_dwNestCount++;
        return( TRUE );
    }
    
    BOOL unnest()
    {
        if ( ! m_dwNestCount ) 
            return ( FALSE );
        Assert( m_dwThreadID == GetCurrentThreadId() );
        m_dwNestCount--;
        return( TRUE);
    }
};



#else


class CExShareLock {
    public:
        CExShareLock() {
            InitializeCriticalSection(&m_cs);
        };
        ~CExShareLock() {
            DeleteCriticalSection(&m_cs);
        };
        void ShareLock(){
            EnterCriticalSection(&m_cs);
        };
        void ShareUnlock() {
            LeaveCriticalSection(&m_cs);
        };
        void ExclusiveLock(){
            EnterCriticalSection(&m_cs);
        };
        void ExclusiveUnlock() {
            LeaveCriticalSection(&m_cs);
        };
        BOOL SharedToExclusive() {
            return (TRUE);
        };
    private:
        CRITICAL_SECTION	m_cs;


};

class CExShareLockWithNestAllowed {
    public:
        CExShareLockWithNestAllowed() {
            InitializeCriticalSection(&m_cs);
        };
        ~CExShareLockWithNestAllowed() {
            DeleteCriticalSection(&m_cs);
        };
        void ShareLock(){
            EnterCriticalSection(&m_cs);
        };
        void ShareUnlock() {
            LeaveCriticalSection(&m_cs);
        };
        void ExclusiveLock(){
            EnterCriticalSection(&m_cs);
        };
        void ExclusiveUnlock() {
            LeaveCriticalSection(&m_cs);
        };
        
    private:
        CRITICAL_SECTION	m_cs;


};


#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\inc\icoint.h ===
// --------------------------------------------------------------------------------
// Icoint.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __ICOINT_H
#define __ICOINT_H

// --------------------------------------------------------------------------------
// Some Basic Function Definitions
// --------------------------------------------------------------------------------
typedef HRESULT (APIENTRY *PFDLLREGSERVER)(void);
typedef HRESULT (APIENTRY *PFNGETCLASSOBJECT) (REFCLSID, REFIID, LPVOID *);

// --------------------------------------------------------------------------------
// Int64 Macros
// --------------------------------------------------------------------------------
#ifdef MAC
#define ULISET32(_pint64, _value)              ULISet32((* _pint64), (_value))
#define LISET32(_pint64, _value)               LISet32((* _pint64), (_value))
#define INT64SET(_pint64, _value)              ULISet32((* _pint64), (_value))
#define INT64INC(_pint64, _value)              BuildBreak
#define INT64DEC(_pint64, _value)              BuildBreak
#define INT64GET(_pint64)                      BuildBreak
#else   // !MAC
#define ULISET32(_pint64, _value)              ((_pint64)->QuadPart =  _value)
#define LISET32(_pint64, _value)               ((_pint64)->QuadPart =  _value)
#define INT64SET(_pint64, _value)              ((_pint64)->QuadPart =  _value)
#define INT64INC(_pint64, _value)              ((_pint64)->QuadPart += _value)
#define INT64DEC(_pint64, _value)              ((_pint64)->QuadPart -= _value)
#define INT64GET(_pint64)                      ((_pint64)->QuadPart)
#endif  // MAC

#endif // __ICOINT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\inc\icutil.h ===
#pragma once

/* ---------------------------------------------------------------------------
   ICUTILS.H
   ---------------------------------------------------------------------------
   Copyright (c) 1999 Microsoft Corporation
 
   Miscellaneous functions shared between inetcomm libs.
   --------------------------------------------------------------------------- 
*/

BOOL GetTextExtentPoint32AthW(HDC hdc, LPCWSTR lpwString, int cchString, LPSIZE lpSize, DWORD dwFlags);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mepad\defguid.cpp ===
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
#include "pch.hxx"
#define INITGUID
#include <initguid.h>
#include <ole2.h>
#include "mimeole.h"
#ifdef WIN16
#include <olectlid.h>           // IID_IPersistStreamInit
#endif // WIN16
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\inc\resource.h ===
// --------------------------------------------------------------------------------
// Resource.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#ifndef _RESOURCE_H
#define _RESOURCE_H


/////////////////////////////////////////////////////////////////////////////
//
//  * * * RESOURCE NAMING CONVENTIONS * * *
//
/////////////////////////////////////////////////////////////////////////////
//
//  Resource Type       Prefix      Comments
//  -------------       ------      --------
//
//  String              ids         menu help strings should end in MH
//  Menu command        idm
//  Menu resource       idmr
//  Bitmap              idb
//  Icon                idi
//  Animation           idan
//  Dialog              idd
//  Dialog control      idc
//  Cursor              idcur
//  Raw RCDATA          idr
//  Accelerator         idac
//  Window              idw
//
/////////////////////////////////////////////////////////////////////////////

// --------------------------------------------------------------------------------
// Types
// --------------------------------------------------------------------------------
#define RT_FILE                         2110

/////////////////////////////////////////////////////////////////////////////
//
// BEGIN String Resource IDs
//
#define IDS_FIRST                       100

#define IDS_APPNAME                     (IDS_FIRST + 1)
#define IDS_MULTIPARTPROLOG             (IDS_FIRST + 2)
#define IDS_FROM                        (IDS_FIRST + 3)
#define IDS_TO                          (IDS_FIRST + 4)
#define IDS_CC                          (IDS_FIRST + 5)
#define IDS_SUBJECT                     (IDS_FIRST + 6)
#define IDS_DATE                        (IDS_FIRST + 7)
#define IDS_UNKNOWN_ALG                 (IDS_FIRST + 8)

// IMNXPORT Errors
#define idsHostNotFoundFmt              (IDS_FIRST + 1000)
#define idsFailedToConnect              (IDS_FIRST + 1001)
#define idsFailedToConnectSecurely      (IDS_FIRST + 1002)
#define idsUnexpectedTermination        (IDS_FIRST + 1003)
#define idsNlogIConnect                 (IDS_FIRST + 1004)
#define idsNegotiatingSSL               (IDS_FIRST + 1005)
#define idsErrConnLookup                (IDS_FIRST + 1006)
#define idsErrConnSelect                (IDS_FIRST + 1007)
#define idsNlogErrConnError             (IDS_FIRST + 1008)
#define idsNlogErrConnClosed            (IDS_FIRST + 1009)
#define idsNotConnected                 (IDS_FIRST + 1010)
#define idsReconnecting                 (IDS_FIRST + 1011)
#define idsFindingHost                  (IDS_FIRST + 1012)
#define idsFoundHost                    (IDS_FIRST + 1013)
#define idsConnecting                   (IDS_FIRST + 1014)
#define idsConnected                    (IDS_FIRST + 1015)
#define idsSecuring                     (IDS_FIRST + 1016)
#define idsInvalidCertCN                (IDS_FIRST + 1017)
#define idsInvalidCertDate              (IDS_FIRST + 1018)
#define idsInvalidCert                  (IDS_FIRST + 1019)
#define idsSecurityErr                  (IDS_FIRST + 1020)
#define idsIgnoreSecureErr              (IDS_FIRST + 1021)
#define idsErrPeerClosed                (IDS_FIRST + 1022)
#define idsSvrRefusesConnection         (IDS_FIRST + 1023)
#define idsUnknownIMAPGreeting          (IDS_FIRST + 1024)
#define idsFailedIMAPCmdSend            (IDS_FIRST + 1025)
#define idsIMAPFailedCapability         (IDS_FIRST + 1026)
#define idsConnectError                 (IDS_FIRST + 1027)
#define idsIMAPSicilyInitFail           (IDS_FIRST + 1029)
#define idsIMAPSicilyPkgFailure         (IDS_FIRST + 1030)
#define idsIMAPAuthNotPossible          (IDS_FIRST + 1031) 
#define idsIMAPOutOfAuthMethods         (IDS_FIRST + 1032)
#define idsIMAPAbortAuth                (IDS_FIRST + 1033)
#define idsGeneral                      (IDS_FIRST + 1034)
#define idsMemory                       (IDS_FIRST + 1035)
#define idsFailedLogin                  (IDS_FIRST + 1036)
#define idsIMAPAuthFailedFmt            (IDS_FIRST + 1037)
#define idsIMAPSocketReadError          (IDS_FIRST + 1038)
#define idsIMAPUnsolicitedBYE           (IDS_FIRST + 1039)
#define idsIMAPCmdNotSent               (IDS_FIRST + 1040)
#define idsIMAPCmdStillPending          (IDS_FIRST + 1041)
#define idsIMAPUIDChanged               (IDS_FIRST + 1042)
#define idsIMAPUIDOrder                 (IDS_FIRST + 1043)
#define idsAppName                      (IDS_FIRST + 1044)
#define idsSaveModifiedObject           (IDS_FIRST + 1045)
#define idsUserTypeApp                  (IDS_FIRST + 1046)
#define idsUserTypeShort                (IDS_FIRST + 1047)
#define idsUserTypeFull                 (IDS_FIRST + 1048)
#define idsInlineImagePlaceHolder       (IDS_FIRST + 1049)
#define idsInlineImageHeader            (IDS_FIRST + 1050)
#define idsPrintHeader                  (IDS_FIRST + 1051)
#define idsPrintFooter                  (IDS_FIRST + 1052)
#define idsFromField                    (IDS_FIRST + 1060)
#define idsNewsgroupsField              (IDS_FIRST + 1061)
#define idsToField                      (IDS_FIRST + 1062)
#define idsCcField                      (IDS_FIRST + 1063)
#define idsDateField                    (IDS_FIRST + 1064)
#define idsSubjectField                 (IDS_FIRST + 1065)
#define idsReplySep                     (IDS_FIRST + 1066)
#define idsReplyTextPrefix              (IDS_FIRST + 1067)
#define idsReplyFont                    (IDS_FIRST + 1068)
#define idsAddToFavorites               (IDS_FIRST + 1069)
#define idsAddToWAB                     (IDS_FIRST + 1070)
#define idsSaveAttachmentAs             (IDS_FIRST + 1071)
#define idsFilterAttSave                (IDS_FIRST + 1072)
#define idsAttachTitleBegin             (IDS_FIRST + 1073)
#define idsImagesOnly                   (IDS_FIRST + 1074)
// Options Spelling dialog strings
#define idsSpellClose                   (IDS_FIRST + 1104)
#define idsSpellCaption                 (IDS_FIRST + 1105)
#define idsSpellRepeatWord              (IDS_FIRST + 1106)
#define idsSpellWordNeedsCap            (IDS_FIRST + 1107)
#define idsSpellWordNotFound            (IDS_FIRST + 1108)
#define idsSpellNoSuggestions           (IDS_FIRST + 1109)
#define idsSpellDelete                  (IDS_FIRST + 1110)
#define idsSpellDeleteAll               (IDS_FIRST + 1111)
#define idsSpellChange                  (IDS_FIRST + 1112)
#define idsSpellChangeAll               (IDS_FIRST + 1113)
#define idsSpellMsgDone                 (IDS_FIRST + 1114)
#define idsSpellMsgContinue             (IDS_FIRST + 1115)
#define idsSpellMsgConfirm              (IDS_FIRST + 1116)
#define idsSpellMsgSendOK               (IDS_FIRST + 1117)
#define idsErrSpellGenericSpell         (IDS_FIRST + 1118)
#define idsErrSpellGenericLoad          (IDS_FIRST + 1119)
#define idsErrSpellMainDictLoad         (IDS_FIRST + 1120)
#define idsErrSpellVersion              (IDS_FIRST + 1121)
#define idsErrSpellUserDictLoad         (IDS_FIRST + 1122)
#define idsErrSpellUserDictOpenRO       (IDS_FIRST + 1123)
#define idsErrSpellCacheWordLen         (IDS_FIRST + 1124)
#define idsPrefixReply                  (IDS_FIRST + 1125)
#define idsPrefixForward                (IDS_FIRST + 1126)
#define idsErrCannotOpenMailMsg         (IDS_FIRST + 1127)
#define idsErrSpellLangChanged          (IDS_FIRST + 1129)
#define idsErrSpellWarnDictionary       (IDS_FIRST + 1130)

#define idsTTFormattingFont             (IDS_FIRST + 1137)
#define idsTTFormattingSize             (IDS_FIRST + 1138)

#define idsFontSize0                    (IDS_FIRST + 1140)
#define idsFontSize1                    (IDS_FIRST + 1141)
#define idsFontSize2                    (IDS_FIRST + 1142)
#define idsFontSize3                    (IDS_FIRST + 1143)
#define idsFontSize4                    (IDS_FIRST + 1144)
#define idsFontSize5                    (IDS_FIRST + 1145)
#define idsFontSize6                    (IDS_FIRST + 1146)
#define idsFontCacheError               (IDS_FIRST + 1147)

#define idsAutoColor                    (IDS_FIRST + 1150)
#define idsColor1                       (IDS_FIRST + 1151)
#define idsColor2                       (IDS_FIRST + 1152)
#define idsColor3                       (IDS_FIRST + 1153)
#define idsColor4                       (IDS_FIRST + 1154)
#define idsColor5                       (IDS_FIRST + 1155)
#define idsColor6                       (IDS_FIRST + 1156)
#define idsColor7                       (IDS_FIRST + 1157)
#define idsColor8                       (IDS_FIRST + 1158)
#define idsColor9                       (IDS_FIRST + 1159)
#define idsColor10                      (IDS_FIRST + 1160)
#define idsColor11                      (IDS_FIRST + 1161)
#define idsColor12                      (IDS_FIRST + 1162)
#define idsColor13                      (IDS_FIRST + 1163)
#define idsColor14                      (IDS_FIRST + 1164)
#define idsColor15                      (IDS_FIRST + 1165)
#define idsColor16                      (IDS_FIRST + 1166)
#define idsTextOrHtmlFileFilter         (IDS_FIRST + 1167)
#define idsTextFileFilter               (IDS_FIRST + 1168)
#define idsDefTextExt                   (IDS_FIRST + 1169)
#define idsInsertTextTitle              (IDS_FIRST + 1170)
#define idsSaveAsStationery             (IDS_FIRST + 1171)
#define idsHtmlFileFilter               (IDS_FIRST + 1172)
#define idsWarnFileExist                (IDS_FIRST + 1173)
#define idsWarnBoringStationery         (IDS_FIRST + 1174)
#define idsOpenAttachControl            (IDS_FIRST + 1175)
#define idsSaveAttachControl            (IDS_FIRST + 1176)
#define idsBtnBarTTList                 (IDS_FIRST + 1177)
#define idsErrFolderInvalid             (IDS_FIRST + 1178)
#define idsSaveAttachments              (IDS_FIRST + 1179)
#define idsErrOneOrMoreAttachSaveFailed (IDS_FIRST + 1180)
#define idsFileExistWarning             (IDS_FIRST + 1181)
#define idsPickAtachDir                 (IDS_FIRST + 1182)
#define idsSaveAllAttach                (IDS_FIRST + 1183)
#define idsSaveAllAttachMH              (IDS_FIRST + 1184)
#define idsBgSound                      (IDS_FIRST + 1185)
#define idsErrBgSoundFileBad            (IDS_FIRST + 1186)
#define idsFilterAudio                  (IDS_FIRST + 1187)
#define idsPickBGSound                  (IDS_FIRST + 1188)
#define idsErrBgSoundLoopRange          (IDS_FIRST + 1189)
#define idsEditTab                      (IDS_FIRST + 1190)      // reorder and die
#define idsHTMLTab                      (IDS_FIRST + 1191)      // reorder and die
#define idsPreviewTab                   (IDS_FIRST + 1192)      // reorder and die
#define idsSearchHLink                  (IDS_FIRST + 1193)
#define idsSearchHLinkPC                (IDS_FIRST + 1194)
#define idsErrInsertFileHasFrames       (IDS_FIRST + 1195)
#define idsAttachField                  (IDS_FIRST + 1196)
#define idsPrintTable_UserName          (IDS_FIRST + 1197)
#define idsPrintTable_Header            (IDS_FIRST + 1198)
#define idsPrintTable_HeaderRow         (IDS_FIRST + 1199)
#define idsReplyHeader_Html_SepBlock    (IDS_FIRST + 1200)
#define idsReplyHeader_SepBlock         (IDS_FIRST + 1201)
#define idsColorSourcePC                (IDS_FIRST + 1202)

#define TT_BASE                         (IDM_LAST + 1)

//
// END String Resource IDs
//
/////////////////////////////////////////////////////////////////////////////



/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Menu Resource IDs
//

#define idmrCtxtEditMode                1
#define idmrCtxtBrowseMode              2
#define idmrCtxtSpellSuggest            3
#define idmrCtxtViewSrc                 4

//
// END Menu Resource IDs
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Command IDs
//

#define IDM_FIRST               100

#define idmCut                  (IDM_FIRST +  1)
#define idmCopy                 (IDM_FIRST +  2)
#define idmPaste                (IDM_FIRST +  3)
#define idmSelectAll            (IDM_FIRST +  5)
#define idmUndo                 (IDM_FIRST +  6)
#define idmRedo                 (IDM_FIRST +  7)
#define idmFindText             (IDM_FIRST +  8)
#define idmTab                  (IDM_FIRST +  9)

#define idmProperties           (IDM_FIRST + 20)
#define idmSavePicture          (IDM_FIRST + 21)
#define idmSaveBackground       (IDM_FIRST + 22)
#define idmPopupFmtAlign        (IDM_FIRST + 23)
#define idmAddToFavorites       (IDM_FIRST + 24)
#define idmAddToWAB             (IDM_FIRST + 25)

#define idmFmtFontDlg           (IDM_FIRST + 30)
#define idmFmtLeft              (IDM_FIRST + 31)
#define idmFmtCenter            (IDM_FIRST + 32)
#define idmFmtRight             (IDM_FIRST + 33)
#define idmFmtJustify           (IDM_FIRST + 34)
#define idmFmtNumbers           (IDM_FIRST + 35)
#define idmFmtBullets           (IDM_FIRST + 36)
#define idmFmtIncreaseIndent    (IDM_FIRST + 37)
#define idmFmtDecreaseIndent    (IDM_FIRST + 38)
#define idmFmtBlockDirLTR       (IDM_FIRST + 39)
#define idmFmtBlockDirRTL       (IDM_FIRST + 40)
#define idmFmtBulletsNone       (IDM_FIRST + 41)
#define idmFmtParagraphDlg      (IDM_FIRST + 42)

// formatbar
#define idmFmtFont              (IDM_FIRST + 70)
#define idmFmtSize              (IDM_FIRST + 71)
#define idmFmtColor             (IDM_FIRST + 72)
#define idmFmtColorAuto         (IDM_FIRST + 73)
#define idmFmtColor1            (IDM_FIRST + 74)
#define idmFmtColor2            (IDM_FIRST + 75)
#define idmFmtColor3            (IDM_FIRST + 76)
#define idmFmtColor4            (IDM_FIRST + 77)
#define idmFmtColor5            (IDM_FIRST + 78)
#define idmFmtColor6            (IDM_FIRST + 79)
#define idmFmtColor7            (IDM_FIRST + 80)
#define idmFmtColor8            (IDM_FIRST + 81)
#define idmFmtColor9            (IDM_FIRST + 82)
#define idmFmtColor10           (IDM_FIRST + 83)
#define idmFmtColor11           (IDM_FIRST + 84)
#define idmFmtColor12           (IDM_FIRST + 85)
#define idmFmtColor13           (IDM_FIRST + 86)
#define idmFmtColor14           (IDM_FIRST + 87)
#define idmFmtColor15           (IDM_FIRST + 88)
#define idmFmtColor16           (IDM_FIRST + 89)
#define idmFmtBold              (IDM_FIRST + 90)
#define idmFmtItalic            (IDM_FIRST + 91)
#define idmFmtUnderline         (IDM_FIRST + 92)
#define idmFmtInsertHLine       (IDM_FIRST + 94)
#define idmFmtBkgroundImage     (IDM_FIRST + 95)
#define idmFmtTag               (IDM_FIRST + 96)
#define idmEditLink             (IDM_FIRST + 97)
#define idmInsertImage          (IDM_FIRST + 98)
#define idmUnInsertLink         (IDM_FIRST + 99)

#define idmAccelIncreaseIndent  (IDM_FIRST + 100)
#define idmAccelDecreaseIndent  (IDM_FIRST + 101)
#define idmAccelBullets         (IDM_FIRST + 102)
#define idmAccelLeft            (IDM_FIRST + 103)
#define idmAccelCenter          (IDM_FIRST + 104)
#define idmAccelRight           (IDM_FIRST + 105)
#define idmAccelJustify         (IDM_FIRST + 106)
#define idmBkColorAuto          (IDM_FIRST + 107)
#define idmPaneBadSigning       (IDM_FIRST + 108)
#define idmPaneBadEncryption    (IDM_FIRST + 109)
#define idmPaneSigning          (IDM_FIRST + 110)
#define idmPaneEncryption       (IDM_FIRST + 111)
#define idmPanePaperclip        (IDM_FIRST + 112)
#define idmPaneVCard            (IDM_FIRST + 113)
#define idmSaveAllAttach        (IDM_FIRST + 114)

#define idmSuggest0             (IDM_FIRST + 115)
#define idmSuggest1             (IDM_FIRST + 116)
#define idmSuggest2             (IDM_FIRST + 117)
#define idmSuggest3             (IDM_FIRST + 118)
#define idmSuggest4             (IDM_FIRST + 119)

#define idmIgnore               (IDM_FIRST + 120)
#define idmIgnoreAll            (IDM_FIRST + 121)
#define idmAdd                  (IDM_FIRST + 122)
#define idmCopyShortcut         (IDM_FIRST + 123)
#define idmSaveTargetAs         (IDM_FIRST + 124)
#define idmOpenLink             (IDM_FIRST + 125)

#define IDM_LAST                (IDM_FIRST + 5000)

// reserve 50 id's for format bar style menu
#define idmFmtTagFirst          (IDM_LAST + 1)
#define idmFmtTagLast           (idmFmtTagFirst + 50)


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Dialog Templates
//

#define IDD_RASCONNECT                  100
#define iddMsgSource                    101
#define iddSafeOpen                     102
#define iddSpelling                     103
#define iddSaveAttachments              104
#define IDD_NTLMPROMPT                  105
#define iddBackSound                    106
#define iddFormatPara                   107
#define iddCSFormatPara                 108

//
// END Dialog Templates
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Control ID's
//

// iddMsgSource
#define idcTxtSource            100

// Tools.Spelling dialog
#define IDC_STATIC                  -1
#define PSB_Spell_Ignore            101
#define PSB_Spell_IgnoreAll         102
#define PSB_Spell_Change            103
#define PSB_Spell_ChangeAll         104
#define PSB_Spell_Add               105
#define PSB_Spell_Suggest           106
#define PSB_Spell_UndoLast          107
#define EDT_Spell_WrongWord         108
#define TXT_Spell_Error             109
#define PSB_Spell_Options           110
#define TXT_Spell_Suggest           111
#define LBX_Spell_Suggest           112
#define EDT_Spell_ChangeTo          113
#define TXT_Spell_ChangeTo          114
#define CHK_AlwaysSuggest           202
#define CHK_CheckSpellingOnSend     203
#define CHK_IgnoreUppercase         204
#define CHK_IgnoreNumbers           205
#define CHK_IgnoreDBCS              206
#define CHK_IgnoreOriginalMessage   207
#define CHK_IgnoreURL               208
#define idcSpellLanguages           209
#define idcViewDictionary           210
#define GRP_SpellOptions            511
#define GRP_SpellIgnore             512
#define idcFmtBar                   600
#define idcBtnBar                   601
#define idcSelectAllAttBtn          700
#define idcAttachList               701
#define idcPathEdit                 702
#define idcBrowseBtn                703
#define IDE_USERNAME                705
#define IDE_PASSWORD                706
#define IDE_DOMAIN                  707
#define IDC_SPIN1                   708
#define IDC_STATIC1                 750
#define IDC_STATIC2                 751
#define IDC_STATIC3                 752
#define IDC_STATIC4                 753

// iddNext

// iddBackgroundSound

#define ideSoundLoc                 800
#define idbtnBrowseSound            801
#define idrbPlayNTimes              802
#define idePlayCount                803
#define idrbPlayInfinite            804

//
// END Control ID's
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Bitmap ID's
//

#define idbFormatBar                    1
#define idbFormatBarFont                2
#define idbPaneBar32                    3
#define idbPaneBar32Hot                 4
#define idbFormatBarHot                 5

//
// END Bitmap ID's
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Bitmap indicies
//
enum {    
    itbEncryption,
    itbSigning,
    itbBadEnc,
    itbBadSign,
    itbPaperclip,
    itbVCard,
    };

//
// END Bitmap indicies
//
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// BEGIN Icon ID's

#define idiDefaultAtt                   1
#define idiSound                        2

//
// END Icon ID's
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// BEGIN ACCEL ID's

#define idacSrcView                   1

//
// END ACCEL ID's
//
/////////////////////////////////////////////////////////////////////////////



#endif //RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mepad\demand.cpp ===
#pragma warning(disable: 4201)  // nameless struct/union
#pragma warning(disable: 4514)  // unreferenced inline function removed

// --------------------------------------------------------------------------------
// Includes
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "shlwapi.h"
//#include "shared.h"
#define IMPLEMENT_LOADER_FUNCTIONS
#include "demand.h"

// --------------------------------------------------------------------------------
// CRIT_GET_PROC_ADDR
// --------------------------------------------------------------------------------
#define CRIT_GET_PROC_ADDR(h, fn, temp)             \
    temp = (TYP_##fn) GetProcAddress(h, #fn);   \
    if (temp)                                   \
        VAR_##fn = temp;                        \
    else                                        \
        {                                       \
        goto error;                             \
        }

// --------------------------------------------------------------------------------
// RESET
// --------------------------------------------------------------------------------
#define RESET(fn) VAR_##fn = LOADER_##fn;

// --------------------------------------------------------------------------------
// GET_PROC_ADDR
// --------------------------------------------------------------------------------
#define GET_PROC_ADDR(h, fn) \
    VAR_##fn = (TYP_##fn) GetProcAddress(h, #fn);

// --------------------------------------------------------------------------------
// GET_PROC_ADDR_ORDINAL
// --------------------------------------------------------------------------------
#define GET_PROC_ADDR_ORDINAL(h, fn, ord) \
    VAR_##fn = (TYP_##fn) GetProcAddress(h, MAKEINTRESOURCE(ord));  \
    Assert(VAR_##fn != NULL);

// --------------------------------------------------------------------------------
// GET_PROC_ADDR3
// --------------------------------------------------------------------------------
#define GET_PROC_ADDR3(h, fn, varname) \
    VAR_##varname = (TYP_##varname) GetProcAddress(h, #fn);  \
    Assert(VAR_##varname != NULL);

// --------------------------------------------------------------------------------
// Static Globals
// --------------------------------------------------------------------------------
HMODULE s_hINetComm = 0;

// --------------------------------------------------------------------------------
// FreeDemandLoadedLibs
// --------------------------------------------------------------------------------
void FreeDemandLoadedLibs(void)
{
    if (s_hINetComm)
        {
        FreeLibrary(s_hINetComm);
        s_hINetComm=NULL;
        }
}


// --------------------------------------------------------------------------------
// SmartLoadLibrary
// --------------------------------------------------------------------------------
HINSTANCE SmartLoadLibrary(HKEY hKeyRoot, LPCSTR pszRegRoot, LPCSTR pszRegValue,
    LPCSTR pszDllName)
{
    // Locals
    BOOL            fProblem=FALSE;
    HINSTANCE       hInst=NULL;
    HKEY            hKey=NULL, hKey2 = NULL;
    CHAR            szPath[MAX_PATH];
    DWORD           cb=MAX_PATH;
    DWORD           dwT;
    LPSTR           pszPath=szPath;
    CHAR            szT[MAX_PATH];

    // Try to open the regkey
    if (ERROR_SUCCESS != RegOpenKeyEx(hKeyRoot, pszRegRoot, 0, KEY_QUERY_VALUE, &hKey))
        goto exit;

    // Query the Value
    if (ERROR_SUCCESS != RegQueryValueEx(hKey, pszRegValue, 0, &dwT, (LPBYTE)szPath, &cb))
        goto exit;

    // Remove the file name from the path
    PathRemoveFileSpecA(szPath);
    PathAppendA(szPath, pszDllName);

    // Expand Sz ?
    if (REG_EXPAND_SZ == dwT)
    {
        // Expand It
        cb = ExpandEnvironmentStrings(szPath, szT, MAX_PATH);

        // Failure
        if (cb == 0 || cb > MAX_PATH)
        {
            goto exit;
        }

        // Change pszPath
        pszPath = szT;
    }

    // Try to Load Library the Dll
    hInst = LoadLibrary(pszPath);

    // Failure ?
    if (NULL == hInst)
    {
        // If we are not going to try the GetModuleFName, just try the dll name
        hInst = LoadLibrary(pszDllName);

        // We really failed
        if (NULL == hInst)
        {
            goto exit;
        }
    }

exit:
    // Cleanup
    if (hKey)
        RegCloseKey(hKey);

    // Done
    return hInst;
}

// --------------------------------------------------------------------------------
// DemandLoadINETCOMM
// --------------------------------------------------------------------------------
BOOL DemandLoadINETCOMM(void)
{
    BOOL                fRet = TRUE;

    if (0 == s_hINetComm)
        {
 
        s_hINetComm = SmartLoadLibrary(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Outlook Express\\Inetcomm", "DllPath", "INETCOMM.DLL");

        if (0 == s_hINetComm)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hINetComm, MimeEditViewSource);
            GET_PROC_ADDR(s_hINetComm, MimeEditCreateMimeDocument);
            }
        }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\inc\htmlstr.h ===
/*
 * htmlstr.h
 *
 * HTML string constants
 *
 */

#ifndef _HTMLSTR_H
#define _HTMLSTR_H

#if !defined( WIN16 ) || !defined( __WATCOMC__ )

#ifdef DEFINE_STRING_CONSTANTS
#define MAKEBSTR(name, count, strdata) \
    extern "C" CDECL const WORD DATA_##name [] = {(count * sizeof(OLECHAR)), 0x00, L##strdata}; \
    extern "C" CDECL BSTR name = (BSTR)& DATA_##name[2];


#define STR_GLOBAL(x,y)         extern "C" CDECL const TCHAR x[] = TEXT(y)
#define STR_GLOBAL_ANSI(x,y)    extern "C" CDECL const char x[] = y
#define STR_GLOBAL_WIDE(x,y)    extern "C" CDECL const WCHAR x[] = L##y

#else
#define MAKEBSTR(name, count, strdata) extern "C" CDECL LPCWSTR name

#define STR_GLOBAL(x,y)         extern "C" CDECL const TCHAR x[]
#define STR_GLOBAL_ANSI(x,y)    extern "C" CDECL const char x[]
#define STR_GLOBAL_WIDE(x,y)    extern "C" CDECL const WCHAR x[]
#endif

#else // !WIN16 || !__WATCOMC__

#ifdef DEFINE_STRING_CONSTANTS
#define MAKEBSTR(name, count, strdata) \
    extern "C" const char CDECL DATA_##name [] = {(count * sizeof(OLECHAR)), 0x00, strdata}; \
    extern "C" BSTR  CDECL name = (BSTR)& DATA_##name[2];


#define STR_GLOBAL(x,y)         extern "C" const TCHAR CDECL x[] = TEXT(y)
#define STR_GLOBAL_ANSI(x,y)    extern "C" const char CDECL x[] = y
#define STR_GLOBAL_WIDE(x,y)    extern "C" const WCHAR CDECL x[] = y

#else
#define MAKEBSTR(name, count, strdata) extern "C" LPCWSTR CDECL name

#define STR_GLOBAL(x,y)         extern "C" const TCHAR CDECL x[]
#define STR_GLOBAL_ANSI(x,y)    extern "C" const char CDECL x[]
#define STR_GLOBAL_WIDE(x,y)    extern "C" const WCHAR CDECL x[]
#endif

#endif // !WIN16 || !__WATCOMC__




STR_GLOBAL(c_szHtml_DivOpen, "<DIV>");
STR_GLOBAL(c_szHtml_DivClose, "</DIV>");

STR_GLOBAL_WIDE(c_wszHtml_DivOpen, "<DIV>");
STR_GLOBAL_WIDE(c_wszHtml_DivClose, "</DIV>");

//STR_GLOBAL(c_szHtml_FontOpen, "<FONT>");
STR_GLOBAL(c_szHtml_FontClose, "</FONT>");

STR_GLOBAL(c_szHtml_BoldOpen, "<B>");
STR_GLOBAL(c_szHtml_BoldClose, "</B>");

//STR_GLOBAL(c_szHtml_UnderlineOpen, "<U>");
//STR_GLOBAL(c_szHtml_UnderlineClose, "</U>");

//STR_GLOBAL(c_szHtml_ItallicOpen, "<I>");
//STR_GLOBAL(c_szHtml_ItallicClose, "</I>");

STR_GLOBAL(c_szHtml_Break, "<BR>");

//fSTR_GLOBAL(c_szHtml_MetaTagf, "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html;charset=%s\">\r\n");

STR_GLOBAL(c_szHtml_HtmlOpenCR,     "<HTML>\r\n");
STR_GLOBAL(c_szHtml_HtmlCloseCR,    "</HTML>\r\n");
STR_GLOBAL(c_szHtml_HeadOpenCR,     "<HEAD>\r\n<STYLE>\r\n");
STR_GLOBAL(c_szHtml_HeadCloseCR,    "</STYLE>\r\n</HEAD>\r\n");
STR_GLOBAL(c_szHtml_BodyOpenNbspCR, "<BODY>\r\n&nbsp;");
STR_GLOBAL(c_szHtml_BodyOpenBgCR,   "<BODY BACKGROUND=\"%s\">\r\n&nbsp;\r\n");
STR_GLOBAL(c_szHtml_BodyCloseCR,    "</BODY>\r\n");

MAKEBSTR(c_bstr_AfterBegin,     10, "AfterBegin");
MAKEBSTR(c_bstr_BeforeEnd,      9,  "BeforeEnd");
MAKEBSTR(c_bstr_TabChar,        4,  "\xA0\xA0\xA0\x20");
MAKEBSTR(c_bstr_SRC,            3,  "src");
//MAKEBSTR(c_bstr_HREF,           4,  "HREF");
MAKEBSTR(c_bstr_IMG,            3,  "IMG");
MAKEBSTR(c_bstr_BASE,           4,  "BASE");
MAKEBSTR(c_bstr_OBJECT,         6,  "OBJECT");
MAKEBSTR(c_bstr_STYLE,          5,  "STYLE");
MAKEBSTR(c_bstr_ANCHOR,         1,  "A");
MAKEBSTR(c_bstr_LEFTMARGIN,    10,  "leftmargin");
MAKEBSTR(c_bstr_TOPMARGIN,      9,  "topmargin");

MAKEBSTR(c_bstr_Word,           4,  "Word");
MAKEBSTR(c_bstr_Character,      9,  "Character");
MAKEBSTR(c_bstr_StartToEnd,     10, "StartToEnd");
MAKEBSTR(c_bstr_EndToEnd,       8,  "EndToEnd");
MAKEBSTR(c_bstr_StartToStart,   12, "StartToStart");
MAKEBSTR(c_bstr_EndToStart,     10, "EndToStart");
//MAKEBSTR(c_bstr_ANCHOR,         1,  "A");
MAKEBSTR(c_bstr_BLOCKQUOTE,     10, "BLOCKQUOTE");
MAKEBSTR(c_bstr_1,              1,  "1");
MAKEBSTR(c_bstr_NOSEND,         6,  "NOSEND");
MAKEBSTR(c_bstr_BGSOUND,        7,  "BGSOUND");
MAKEBSTR(c_bstr_BGSOUND_TAG,    9,  "<BGSOUND>");
MAKEBSTR(c_bstr_MonoSpace,      9, "monospace");

#endif //_HTMLSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mepad\dochost.h ===
/*
 *    d o c h o s t . h
 *    
 *    Purpose:
 *        basic implementation of a docobject host. Used by the body class to
 *        host Trident and/or MSHTML
 *
 *  History
 *      August '96: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _DOCHOST_H
#define _DOCHOST_H

#include <docobj.h>

// DocHost border sytles
enum
{
    dhbNone     =0x0,   // no border
    dhbHost     =0x01,  // dochost paints border
    dhbObject   =0x02   // docobj paints border
};

class CDocHost:
    public IOleInPlaceUIWindow,
    public IOleInPlaceSite,
    public IOleClientSite,
    public IOleControlSite,
    public IAdviseSink,
    public IOleDocumentSite,
    public IOleCommandTarget,
    public IServiceProvider
{
public:
    // *** IUnknown methods ***
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // *** IOleWindow methods ***
    virtual HRESULT STDMETHODCALLTYPE GetWindow(HWND *);
    virtual HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL);

    // *** IOleInPlaceUIWindow methods ***
    virtual HRESULT STDMETHODCALLTYPE GetBorder(LPRECT);
    virtual HRESULT STDMETHODCALLTYPE RequestBorderSpace(LPCBORDERWIDTHS);
    virtual HRESULT STDMETHODCALLTYPE SetBorderSpace(LPCBORDERWIDTHS);
    virtual HRESULT STDMETHODCALLTYPE SetActiveObject(IOleInPlaceActiveObject *, LPCOLESTR); 
    
    // IOleInPlaceSite methods.
    virtual HRESULT STDMETHODCALLTYPE CanInPlaceActivate();
    virtual HRESULT STDMETHODCALLTYPE OnInPlaceActivate();
    virtual HRESULT STDMETHODCALLTYPE OnUIActivate();
    virtual HRESULT STDMETHODCALLTYPE GetWindowContext(LPOLEINPLACEFRAME *, LPOLEINPLACEUIWINDOW *, LPRECT, LPRECT, LPOLEINPLACEFRAMEINFO);
    virtual HRESULT STDMETHODCALLTYPE Scroll(SIZE);
    virtual HRESULT STDMETHODCALLTYPE OnUIDeactivate(BOOL);
    virtual HRESULT STDMETHODCALLTYPE OnInPlaceDeactivate();
    virtual HRESULT STDMETHODCALLTYPE DiscardUndoState();
    virtual HRESULT STDMETHODCALLTYPE DeactivateAndUndo();
    virtual HRESULT STDMETHODCALLTYPE OnPosRectChange(LPCRECT);

    // IOleClientSite methods.
    virtual HRESULT STDMETHODCALLTYPE SaveObject();
    virtual HRESULT STDMETHODCALLTYPE GetMoniker(DWORD, DWORD, LPMONIKER *);
    virtual HRESULT STDMETHODCALLTYPE GetContainer(LPOLECONTAINER *);
    virtual HRESULT STDMETHODCALLTYPE ShowObject();
    virtual HRESULT STDMETHODCALLTYPE OnShowWindow(BOOL);
    virtual HRESULT STDMETHODCALLTYPE RequestNewObjectLayout();

    // IOleControlSite
    virtual HRESULT STDMETHODCALLTYPE OnControlInfoChanged();
    virtual HRESULT STDMETHODCALLTYPE LockInPlaceActive(BOOL fLock);
    virtual HRESULT STDMETHODCALLTYPE GetExtendedControl(LPDISPATCH *ppDisp);
    virtual HRESULT STDMETHODCALLTYPE TransformCoords(POINTL *pPtlHimetric, POINTF *pPtfContainer,DWORD dwFlags);
    virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator(MSG *lpMsg,DWORD grfModifiers);
    virtual HRESULT STDMETHODCALLTYPE OnFocus(BOOL fGotFocus);
    virtual HRESULT STDMETHODCALLTYPE ShowPropertyFrame(void);

    // IAdviseSink methods
    virtual void STDMETHODCALLTYPE OnDataChange(FORMATETC *, STGMEDIUM *);
    virtual void STDMETHODCALLTYPE OnViewChange(DWORD, LONG);
    virtual void STDMETHODCALLTYPE OnRename(LPMONIKER);
    virtual void STDMETHODCALLTYPE OnSave();
    virtual void STDMETHODCALLTYPE OnClose();

    // IOleDocumentSite
    virtual HRESULT STDMETHODCALLTYPE ActivateMe(LPOLEDOCUMENTVIEW);

    // IOleCommandTarget
    virtual HRESULT STDMETHODCALLTYPE QueryStatus(const GUID *, ULONG, OLECMD [], OLECMDTEXT *);
    virtual HRESULT STDMETHODCALLTYPE Exec(const GUID *, DWORD, DWORD, VARIANTARG *, VARIANTARG *);

    // IServiceProvider
    virtual HRESULT STDMETHODCALLTYPE QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject);


    CDocHost();
    virtual ~CDocHost();
    
    // statics
    static LRESULT CALLBACK ExtWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    // overridble virtuals
    virtual LRESULT WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    
    // derrived class notifications
    virtual HRESULT HrSubWMCreate();
    virtual void OnWMSize(LPRECT prc){};
    virtual void OnUpdateCommands(){};
    virtual HRESULT HrGetDocObjSize(LPRECT prc)
        {return E_NOTIMPL;};

    HRESULT HrCreateDocObj(LPCLSID pCLSID);
    HRESULT HrCloseDocObj();

    HRESULT HrInit(HWND hwndParent, int idDlgItem, DWORD dhbBorder);

protected:
    HWND                        m_hwnd,
                                m_hwndDocObj;
    LPOLEOBJECT                 m_lpOleObj;
    LPOLEDOCUMENTVIEW           m_pDocView;
    LPOLECOMMANDTARGET          m_pCmdTarget;
    BOOL                        m_fDownloading,
                                m_fFocus,
                                m_fUIActive,
                                m_fCycleFocus;
    LPOLEINPLACEACTIVEOBJECT    m_pInPlaceActiveObj;
	LPOLEINPLACEFRAME			m_pInPlaceFrame;

    void WMSize(int x, int y);
    HRESULT HrShow();

private:
    ULONG               m_cRef,
                        m_ulAdviseConnection;
    DWORD               m_dwFrameWidth,
                        m_dwFrameHeight,
                        m_dhbBorder;

        

    HRESULT HrCreateDocView();

    BOOL WMCreate(HWND hwnd);
    void WMNCDestroy();

};

typedef CDocHost DOCHOST;
typedef DOCHOST *LPDOCHOST;

#endif //_DOCHOST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\inc\strconst.h ===
// --------------------------------------------------------------------------------
// Strconst.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#ifndef __STRCONST_H
#define __STRCONST_H

#include "mimeole.h"

#define STR_REG_PATH_FLAT          "Software\\Microsoft\\Outlook Express"
#define STR_REG_PATH_ROOT          "Software\\Microsoft\\Outlook Express\\5.0"

#define wchCR   L'\r'   
#define wchLF   L'\n'
#define chCR    '\r'   
#define chLF    '\n'

// --------------------------------------------------------------------------------
// Common String Constants
// --------------------------------------------------------------------------------
STRCONSTA(c_szCRLFCRLF,             "\r\n\r\n");
STRCONSTA(c_szCRLF,                 "\r\n");
STRCONSTA(c_szCRLFTab,              "\r\n\t");
STRCONSTA(c_szRegRoot,              STR_REG_PATH_ROOT);
STRCONSTA(c_szRegFlat,              STR_REG_PATH_FLAT);

// --------------------------------------------------------------------------------
// IMNACCT String Constants
// --------------------------------------------------------------------------------
STRCONSTA(g_szSpace,               " ");
//STRCONSTA(g_szTab,                 "\t");
STRCONSTA(g_szNewline,             "\n");
//STRCONSTA(g_szCR,                  "\r");
STRCONSTA(g_szCRLF,                "\r\n");
//STRCONSTA(szRasDll,                "RASAPI32.DLL");
//STRCONSTA(c_szInetcfgDll,          "inetcfg.dll");
STRCONSTA(c_szMLANGDLL,            "mlang.dll");
STRCONSTA(c_szDllRegisterServer,   "DllRegisterServer");
//STRCONSTA(c_szCreateAcct,          "InetCreateMailNewsAccount");
//STRCONSTA(c_szCreateDirServ,       "InetCreateDirectoryService");
//STRCONSTA(c_szCtxHelpFile,         "inetcomm.hlp");
//STRCONSTA(c_szRegRootNew,          "Software\\Microsoft\\Internet Account Manager");

STRCONSTA(c_szCtxHelpFile,         "msoe.hlp");

// --------------------------------------------------------------------------------
// WebPage String Constants
// --------------------------------------------------------------------------------
STRCONSTA(STR_METATAG_PREFIX,      "<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html;charset=");
STRCONSTA(STR_METATAG_POSTFIX,     "\">\r\n");
STRCONSTA(STR_SEGMENT_SPLIT,       "<P><HR></P>");
STRCONSTA(STR_INLINE_IMAGE1,       "<P>\n\r<CENTER><IMG SRC=\"CID:");
STRCONSTA(STR_INLINE_IMAGE2,       "\"></CENTER>");
STRCONSTA(STR_ATTACH_TITLE_END,    "<UL>");
STRCONSTA(STR_ATTACH_BEGIN,        "<LI><A href=\"CID:");
STRCONSTA(STR_ATTACH_MIDDLE,       "\">");
STRCONSTA(STR_ATTACH_END,          "</A></LI>\r\n");
STRCONSTW(STR_SLIDEIMG_BEGIN,      "g_ImageTable[g_imax++] = new Array (\"cid:");
STRCONSTW(STR_QUOTECOMMASPACEQUOTE,"\", \"");
STRCONSTW(STR_QUOTEPARASEMI,       "\");\r\n");

// --------------------------------------------------------------------------------
// MIMEOLE String Constants
// --------------------------------------------------------------------------------
STRCONSTW(STR_XRICH,               "<x-rich>");
STRCONSTA(c_szXRich,               "<x-rich>");
STRCONSTA(STR_ISO88591,            "ISO-8859-1");
STRCONSTW(STR_TEXTHTML,            "text/html");
STRCONSTA(c_szAddressDelims,        "\",<(");
STRCONSTA(c_szMHTMLColon,           "mhtml:");
STRCONSTA(c_szMHTMLExt,             ".mhtml");
STRCONSTA(c_szFileUrl,              "file://");
//STRCONSTA(c_szMHTMLColonWackWack,   "mhtml://");
STRCONSTA(c_szCID,                  "CID:");
//STRCONSTA(c_szNo,                   "No");
//STRCONSTA(c_szYes,                  "Yes");
STRCONSTA(c_szISO2022JP,            "iso-2022-jp");
STRCONSTA(c_szISO2022JPControl,     "JP_ISO_SIO_Control");
STRCONSTA(c_szISO88591,             "iso-8859-1");
STRCONSTA(STR_HDR_XMIMEOLE,         "X-MimeOLE");
STRCONSTA(STR_HDR_UNKNOWN,          "Unknown");
STRCONSTA(STR_PRI_HIGHEST,          "Highest");
STRCONSTA(STR_PRI_LOWEST,           "Lowest");
STRCONSTA(c_szDescription,          "Description");
//STRCONSTA(c_szStoreInetProps,       "Store Internet Properties");
//STRCONSTA(c_szType,                 "Type");
//STRCONSTA(c_szFlags,                "Flags");
STRCONSTA(c_szMimeVersion,          "1.0");
STRCONSTA(c_szDoubleDash,           "--");
//STRCONSTA(c_szRegMimeOLE,           "Software\\Microsoft\\MimeOLE Engine");
//STRCONSTA(c_szRegInetProps,         "Software\\Microsoft\\MimeOLE Engine\\Internet Properties");
STRCONSTA(c_szCommaSpace,           ", ");
STRCONSTW(c_wszCommaSpace,          ", ");
STRCONSTA(c_szCommaSpaceDash,       ", -");
STRCONSTA(c_szAddressFold,          ",\r\n\t");
STRCONSTW(c_wszAddressFold,         ",\r\n\t");
STRCONSTA(c_szParamFold,            ";\r\n\t");
//STRCONSTA(c_szAddressSep,           ", ");
STRCONSTA(c_szEmpty,                "");
STRCONSTW(c_szEmptyW,               "");
//STRCONSTA(c_szSemiColon,            ";");
STRCONSTA(c_szSemiColonSpace,       "; ");
STRCONSTW(c_wszSemiColonSpace,      "; ");
STRCONSTA(c_szEmailSpaceStart,      " <");
STRCONSTW(c_wszEmailSpaceStart,     " <");
STRCONSTA(c_szEmailStart,           "<");
STRCONSTW(c_wszEmailStart,          "<");
STRCONSTA(c_szEmailEnd,             ">");
STRCONSTW(c_wszEmailEnd,            ">");
STRCONSTA(c_szColonSpace,           ": ");
//STRCONSTA(c_szFoldCRLF,             "\r\n ");
//STRCONSTA(c_szPeriod,               ".");
STRCONSTA(c_szForwardSlash,         "/");
STRCONSTA(c_szEqual,                "=");
STRCONSTA(c_szDoubleQuote,          "\"");
STRCONSTW(c_wszDoubleQuote,         "\"");
STRCONSTA(c_szMDBContentType,       "MIME\\Database\\Content Type");
//STRCONSTA(c_szMDBCodePage,          "MIME\\Database\\CodePage");
//STRCONSTA(c_szMDBCharset,           "MIME\\Database\\Charset");
STRCONSTA(c_szExtension,            "Extension");
STRCONSTA(c_szCLSID,                "CLSID");
//STRCONSTA(c_szFixedWidthFont,       "FixedWidthFont");
//STRCONSTA(c_szProportionalFont,     "ProportionalFont");
//STRCONSTA(c_szBodyCharset,          "BodyCharset");
//STRCONSTA(c_szWebCharset,           "WebCharset");
//STRCONSTA(c_szHeaderCharset,        "HeaderCharset");
//STRCONSTA(c_szAliasCharset,         "AliasForCharset");
//STRCONSTA(c_szCodePage,             "CodePage");
//STRCONSTA(c_szInternetEncoding,     "InternetEncoding");
//STRCONSTA(c_szMailMimeEncoding,     "MailMIMEEncoding");
//STRCONSTA(c_szNewsMimeEncoding,     "NewsMIMEEncoding");
//STRCONSTA(c_szFamily,               "Family");
STRCONSTA(c_szCharset,              "charset");
STRCONSTA(c_szBoundary,             "boundary");
STRCONSTA(c_szFileName,             "filename");
STRCONSTA(c_szID,                   "id");
STRCONSTA(c_szName,                 "name");
STRCONSTA(c_szUUENCODE_END,         "end\r\n");
STRCONSTA(c_szUUENCODE_BEGIN,       "begin ");
STRCONSTA(c_szUUENCODE_DAT,         "uuencode.uue");
STRCONSTA(c_szUUENCODE_666,         "666 ");
STRCONSTA(c_szContentType,          "Content Type");
STRCONSTW(c_szContentTypeW,         "Content Type");
STRCONSTA(c_szDefaultAttach,        "attach.dat");
STRCONSTW(c_wszDefaultAttach,       "attach.dat");
STRCONSTA(c_szDotDat,               ".dat");
STRCONSTW(c_wszDotDat,              ".dat");
STRCONSTA(c_szDotTxt,               ".txt");
STRCONSTW(c_wszDotTxt,              ".txt");
//STRCONSTA(c_szDotUUE,               ".uue");
STRCONSTA(c_szDotEml,               ".eml");
STRCONSTW(c_wszDotEml,              ".eml");
STRCONSTA(c_szDotNws,               ".nws");
STRCONSTW(c_wszDotNws,              ".nws");
STRCONSTA(c_szWinmailDotDat,        "winmail.dat");
STRCONSTA(c_szUUEncodeZeroLength,   "`\r\n");
STRCONSTA(c_szRfc822MustQuote,      "()<>,;:\\\"[] ");
STRCONSTA(c_szXrefColon,            "xref:");
STRCONSTW(REG_BC_ATHENAMESSAGE,             "__MimeOle__IMimeMessage");
STRCONSTW(REG_BC_BINDSTATUSCALLBACK,        "_BSCB_Holder_");
STRCONSTA(REG_Y2K_THRESHOLD,                "Control Panel\\International\\Calendars\\TwoDigitYearMax");

// --------------------------------------------------------------------------------
// SMTP command strings
// --------------------------------------------------------------------------------
STRCONSTA(SMTP_AUTH_CANCEL_STR, "*\r\n");
STRCONSTA(SMTP_AUTH_STR,       "AUTH");
STRCONSTA(SMTP_HELO_STR,       "HELO");
STRCONSTA(SMTP_EHLO_STR,       "EHLO");
STRCONSTA(SMTP_STARTTLS_STR,   "STARTTLS\r\n");
STRCONSTA(SMTP_MAIL_STR,       "MAIL FROM:");
STRCONSTA(SMTP_RCPT_STR,       "RCPT TO:");
STRCONSTA(SMTP_RSET_STR,       "RSET\r\n");
//STRCONSTA(SMTP_SEND_STR,       "SEND FROM");
//STRCONSTA(SMTP_SOML_STR,       "SOML FROM");
//STRCONSTA(SMTP_SAML_STR,       "SAML FROM");
//STRCONSTA(SMTP_VRFY_STR,       "VRFY");
//STRCONSTA(SMTP_EXPN_STR,       "EXPN");
//STRCONSTA(SMTP_HELP_STR,       "HELP");
//STRCONSTA(SMTP_NOOP_STR,       "NOOP");
STRCONSTA(SMTP_QUIT_STR,       "QUIT\r\n");
//STRCONSTA(SMTP_TURN_STR,       "TURN");
STRCONSTA(SMTP_DATA_STR,       "DATA\r\n");
STRCONSTA(SMTP_END_DATA_STR,   "\r\n.\r\n");

// --------------------------------------------------------------------------------
// POP3 command strings
// --------------------------------------------------------------------------------
STRCONSTA(POP3_USER_STR,       "USER");
STRCONSTA(POP3_PASS_STR,       "PASS");
STRCONSTA(POP3_STAT_STR,       "STAT\r\n");
STRCONSTA(POP3_LIST_STR,       "LIST");
STRCONSTA(POP3_LIST_ALL_STR,   "LIST\r\n");
STRCONSTA(POP3_RETR_STR,       "RETR");
STRCONSTA(POP3_DELE_STR,       "DELE");
STRCONSTA(POP3_NOOP_STR,       "NOOP\r\n");
//STRCONSTA(POP3_LAST_STR,       "LAST");
STRCONSTA(POP3_RSET_STR,       "RSET");
STRCONSTA(POP3_QUIT_STR,       "QUIT\r\n");
//STRCONSTA(POP3_APOP_STR,       "APOP");
STRCONSTA(POP3_TOP_STR,        "TOP");
STRCONSTA(POP3_UIDL_ALL_STR,   "UIDL\r\n");
STRCONSTA(POP3_UIDL_STR,       "UIDL");
STRCONSTA(POP3_AUTH_STR,       "AUTH");
STRCONSTA(POP3_AUTH_CANCEL_STR, "*\r\n");
//STRCONSTA(POP3_END_DATA_STR,   ".");

// --------------------------------------------------------------------------------
// NNTP command strings
// --------------------------------------------------------------------------------
STRCONSTA(NNTP_AUTHINFOUSER,          "AUTHINFO USER");
STRCONSTA(NNTP_AUTHINFOPASS,          "AUTHINFO PASS");
STRCONSTA(NNTP_TRANSACTTEST_CRLF,     "AUTHINFO TRANSACT TWINKIE\r\n");
STRCONSTA(NNTP_TRANSACTCMD,           "AUTHINFO TRANSACT");
STRCONSTA(NNTP_AUTHINFOSIMPLE_CRLF,   "AUTHINFO SIMPLE\r\n");
STRCONSTA(NNTP_GENERICTEST_CRLF,      "AUTHINFO GENERIC\r\n");
STRCONSTA(NNTP_GENERICCMD,            "AUTHINFO GENERIC");
STRCONSTA(NNTP_GROUP,                 "GROUP");
STRCONSTA(NNTP_LAST_CRLF,             "LAST\r\n");
STRCONSTA(NNTP_NEXT_CRLF,             "NEXT\r\n");
STRCONSTA(NNTP_STAT,                  "STAT");
STRCONSTA(NNTP_ARTICLE,               "ARTICLE");
STRCONSTA(NNTP_HEAD,                  "HEAD");
STRCONSTA(NNTP_BODY,                  "BODY");
STRCONSTA(NNTP_POST_CRLF,             "POST\r\n");
STRCONSTA(NNTP_LIST,                  "LIST");
STRCONSTA(NNTP_LISTGROUP,             "LISTGROUP");
STRCONSTA(NNTP_NEWGROUPS,             "NEWGROUPS");
STRCONSTA(NNTP_DATE_CRLF,             "DATE\r\n");
STRCONSTA(NNTP_MODE,                  "MODE");
STRCONSTA(NNTP_MODE_READER_CRLF,      "MODE READER\r\n");
STRCONSTA(NNTP_QUIT_CRLF,             "QUIT\r\n");
STRCONSTA(NNTP_XOVER,                 "XOVER");
//STRCONSTA(NNTP_CRLF_DOT_CRLF,         "\r\n.\r\n");
STRCONSTA(NNTP_BASIC,                 "BASIC");
STRCONSTA(NNTP_XHDR,                  "XHDR");
//STRCONSTA(NNTP_RANGE,                 "%lu-%lu");
//STRCONSTA(NNTP_RANGE_OPEN,            "%lu-");
STRCONSTA(NNTP_ENDPOST,               "\r\n.\r\n");

// --------------------------------------------------------------------------------
// NNTP Header strings
// --------------------------------------------------------------------------------
STRCONSTA(NNTP_HDR_SUBJECT,           "subject");
STRCONSTA(NNTP_HDR_FROM,              "from");
STRCONSTA(NNTP_HDR_DATE,              "date");
STRCONSTA(NNTP_HDR_MESSAGEID,         "message-id");
STRCONSTA(NNTP_HDR_REFERENCES,        "references");
//STRCONSTA(NNTP_HDR_BYTES,             "bytes");
STRCONSTA(NNTP_HDR_LINES,             "lines");
STRCONSTA(NNTP_HDR_XREF,              "xref");

// --------------------------------------------------------------------------------
// HTTPMAIL command strings
// --------------------------------------------------------------------------------
STRCONSTA(c_szXMLOpenElement,               "<");
STRCONSTA(c_szXMLCloseElement,              ">");
STRCONSTA(c_szXMLCloseElementCRLF,          ">\r\n");
STRCONSTA(c_szTabTabOpenElement,            "\t\t<");
STRCONSTA(c_szCRLFTabTabOpenElement,        "\r\n\t\t<");
STRCONSTA(c_szCRLFTabTabTabOpenElement,     "\r\n\t\t\t<");
STRCONSTA(c_szXMLOpenTermElement,           "</");
STRCONSTA(c_szXMLCloseTermElement,          "/>");

STRCONSTA(c_szDavNamespacePrefix,           "D");
STRCONSTA(c_szHotMailNamespacePrefix,       "h");
STRCONSTA(c_szHTTPMailNamespacePrefix,      "hm");
STRCONSTA(c_szMailNamespacePrefix,          "m");
STRCONSTA(c_szContactsNamespacePrefix,      "c"); 

STRCONSTA(c_szXMLHead,                      "<?xml version=\"1.0\"?>");
STRCONSTA(c_szXML1252Head,                  "<?xml version=\"1.0\" encoding=\"windows-1252\"?>");

STRCONSTA(c_szXMLNsColon,                   "xmlns:");

STRCONSTA(c_szPropFindHead1,				"\r\n<D:propfind ");
STRCONSTA(c_szPropFindHead2,			    ">\r\n\t<D:prop>");
STRCONSTA(c_szPropFindTail,                 "\r\n\t</D:prop>\r\n</D:propfind>");

STRCONSTA(c_szPropPatchHead,				"\r\n<D:propertyupdate ");
STRCONSTA(c_szPropPatchTailCRLF,            "\r\n</D:propertyupdate>");

STRCONSTA(c_szPropPatchSetHead,             "\r\n\t<D:set>\r\n\t\t<D:prop>");
STRCONSTA(c_szPropPatchSetTail,             "\r\n\t\t</D:prop>\r\n\t</D:set>");

STRCONSTA(c_szPropPatchRemoveHead,          "\r\n\t<D:remove>\r\n\t\t<D:prop>");
STRCONSTA(c_szPropPatchRemoveTail,          "\r\n\t\t</D:prop>\r\n\t</D:remove>");

STRCONSTA(c_szOpenContactNamespace,         "\r\n\t<c:");
STRCONSTA(c_szCloseContactNamespace,        "</c:");
STRCONSTA(c_szContactHead,                  "<c:contact ");
STRCONSTA(c_szContactTail,                  "\r\n</c:contact>");
STRCONSTA(c_szGroupSwitch,                  "<c:group/>");

STRCONSTA(c_szEscLessThan,                  "&lt;");
STRCONSTA(c_szEscGreaterThan,               "&gt;");
STRCONSTA(c_szEscAmp,                       "&amp;");


STRCONSTA(c_szDestinationHeader,            "Destination: ");
STRCONSTA(c_szTranslateFalseHeader,         "Translate: f");
STRCONSTA(c_szTranslateTrueHeader,          "Translate: t");
STRCONSTA(c_szAllowRenameHeader,            "Allow-Rename: t");
STRCONSTA(c_szContentTypeHeader,            "Content-Type: ");
STRCONSTA(c_szBriefHeader,                  "Brief: t");
STRCONSTA(c_szDepthHeader,                  "Depth: %d");
STRCONSTA(c_szDepthNoRootHeader,            "Depth: %d,noroot");
STRCONSTA(c_szDepthInfinityHeader,          "Depth: infinity");
STRCONSTA(c_szDepthInfinityNoRootHeader,    "Depth: infinity,noroot");

STRCONSTA(c_szMailContentType,              "message/rfc822");
STRCONSTA(c_szXmlContentType,               "text/xml");
STRCONSTA(c_szSmtpMessageContentType,       "message/rfc821");

STRCONSTA(c_szRootTimeStampHeader,          "X-Timestamp: folders=%s,ACTIVE=%s");
STRCONSTA(c_szFolders,                      "folders");
STRCONSTA(c_szFolderTimeStampHeader,        "X-Timestamp: ACTIVE=%s");
STRCONSTA(c_szActive,                       "ACTIVE");
STRCONSTA(c_szXTimestamp,                   "X-Timestamp");
STRCONSTA(c_szAcceptCharset,                "Accept-CharSet:%s");

// strings used to build batch command xml
STRCONSTA(c_szBatchHead1,                   "\r\n<D:");
STRCONSTA(c_szBatchHead2,                   " xmlns:D=\"DAV:\">");
STRCONSTA(c_szBatchTail,                    "\r\n</D:");

STRCONSTA(c_szTargetHead,                   "\r\n\t<D:target>");
STRCONSTA(c_szTargetTail,                   "\r\n\t</D:target>");

STRCONSTA(c_szHrefHead,                     "\r\n\t\t<D:href>");
STRCONSTA(c_szHrefTail,                     "</D:href>");
STRCONSTA(c_szDestHead,                     "\r\n\t\t<D:dest>");
STRCONSTA(c_szDestTail,                     "</D:dest>");

STRCONSTA(c_szDelete,                       "delete");
STRCONSTA(c_szCopy,                         "copy");
STRCONSTA(c_szMove,                         "move");

// strings used to build rfc821 streams
STRCONSTA(c_szMailFrom,                     "MAIL FROM:<");
STRCONSTA(c_szRcptTo,                       "RCPT TO:<");
STRCONSTA(c_szSaveInSentTrue,               "SAVEINSENT: t");
STRCONSTA(c_szSaveInSentFalse,              "SAVEINSENT: f");

// --------------------------------------------------------------------------------
// RAS function strings
// --------------------------------------------------------------------------------
STRCONSTA(c_szRasDial,                     "RasDialA");    
STRCONSTA(c_szRasEnumConnections,          "RasEnumConnectionsA");
STRCONSTA(c_szRasEnumEntries,              "RasEnumEntriesA");
STRCONSTA(c_szRasGetConnectStatus,         "RasGetConnectStatusA");
STRCONSTA(c_szRasGetErrorString,           "RasGetErrorStringA");
STRCONSTA(c_szRasHangup,                   "RasHangUpA");
STRCONSTA(c_szRasSetEntryDialParams,       "RasSetEntryDialParamsA");
STRCONSTA(c_szRasGetEntryDialParams,       "RasGetEntryDialParamsA");
//STRCONSTA(c_szRasGetEntryProperties,       "RasGetEntryPropertiesA");
//STRCONSTA(c_szRasSetEntryProperties,       "RasSetEntryPropertiesA");
STRCONSTA(c_szRasCreatePhonebookEntry,     "RasCreatePhonebookEntryA");
STRCONSTA(c_szRasEditPhonebookEntry,       "RasEditPhonebookEntryA");
// ********************************************************************************
// MIMEEDIT String Constants
// ********************************************************************************
STRCONSTA(c_szBmpExt,              ".bmp");
STRCONSTA(c_szJpgExt,              ".jpg");
STRCONSTA(c_szJpegExt,             ".jpeg");
STRCONSTA(c_szGifExt,              ".gif");
STRCONSTA(c_szIcoExt,              ".ico");
STRCONSTA(c_szWmfExt,              ".wmf");
STRCONSTA(c_szPngExt,              ".png");
STRCONSTA(c_szEmfExt,              ".emf");
STRCONSTA(c_szArtExt,              ".art");
STRCONSTA(c_szXbmExt,              ".xbm");
STRCONSTW(c_szExeExt,              ".exe");
STRCONSTW(c_wszDocHostWndClass,    "##MimeEdit_Server");

//STRCONSTA(c_szLnkExt,              ".lnk");
STRCONSTA(c_szSpace,               " ");
STRCONSTA(c_szIexploreExe,         "iexplore.exe");
//STRCONSTA(c_szPathFileFmt,         "%s\\%s");
//STRCONSTA(c_szEllipsis,            "...");
//STRCONSTA(c_szAppPaths,            "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths");
STRCONSTA(c_szExplorerRegPath,     "Software\\Microsoft\\Internet Explorer");
//STRCONSTA(c_szRegPath,             "Path");

//STRCONSTA(c_szRegSpellLangID,      	"SpellLangID");
STRCONSTA(c_szRegShellFoldersKey,  		"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");
STRCONSTA(c_szValueAppData,             "AppData");
STRCONSTA(c_szRegSpellKeyDef,      		"Spelling\\%s\\Normal");
STRCONSTA(c_szRegSpellKeyDefRoot,  		"SOFTWARE\\Microsoft\\Shared Tools\\Proofing Tools\\Spelling");
STRCONSTA(c_szRegSpellKeyCustom,   		"Custom Dictionaries");
STRCONSTA(c_szRegSpellProfile,     		"SOFTWARE\\Microsoft\\Shared Tools\\Proofing Tools\\");
STRCONSTA(c_szRegSharedTools,      		"SOFTWARE\\Microsoft\\Shared Tools\\");
STRCONSTA(c_szRegSharedToolsPath,  		"SharedFilesDir");
STRCONSTA(c_szSpellCSAPI3T1Path,   		"Proof\\CSAPI3T1.DLL");
STRCONSTA(c_szCSAPI3T1,                 "CSAPI3T1.DLL");
STRCONSTA(c_szSpellOffice9ProofPath,	"Microsoft\\Proof\\");
STRCONSTA(c_szRegSpellPath,        		"Engine");
STRCONSTA(c_szRegSpellPathLex,     		"Dictionary");
STRCONSTA(c_szRegSpellPathDict,    		"1");
STRCONSTA(c_szRegDefCustomDict,    		"custom.dic");
STRCONSTA(c_szRegDICHandlerKEY,    		".DIC");
STRCONSTA(c_szRegDICHandlerDefault,		"txtfile");
STRCONSTA(c_szInstallRoot,              "InstallRoot");

#ifdef SMIME_V3
// Security Policy strings.
STRCONSTA(c_szDefaultPolicyOid,			"default");
STRCONSTA(c_szSecLabelPoliciesRegKey,	"Software\\Microsoft\\Cryptography\\OID\\EncodingType 1\\SMIMESecurityLabel");
STRCONSTA(c_szSecurityPolicyDllPath,	"DllPath");
STRCONSTA(c_szSecurityPolicyFuncName,	"FuncName");

STRCONSTA(c_szSecLabelAdminRegKey,		"Software\\Microsoft\\Cryptography\\OID\\EncodingType 0\\SMIMESecurityLabel");
STRCONSTA(c_szHideMsgWithDifferentLabels,"HideMsgWithDifferentLabels");
STRCONSTA(c_szCertErrorWithLabel,		"CertErrorWithLabel");
#endif // SMIME_V3

// --------------------------------------------------------------------------------
// Registry value strings
// --------------------------------------------------------------------------------
STRCONSTA(c_szCertCheckRevocation,      "Check Cert Revocation");
STRCONSTA(c_szCertIgnoredErr,           "Ignored Cert Errors");

#endif // __STRCONST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mepad\demand.h ===
/*
**	d e m a n d . h
**	
**	Purpose: create an intelligent method of defer loading functions
**
**	Copyright (C) Microsoft Corp. 1997
*/

#define USE_CRITSEC

#ifdef IMPLEMENT_LOADER_FUNCTIONS
#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)  \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   \
        ret WINAPI LOADER_##name args1                  \
        {                                               \
           DemandLoad##dll();                           \
           if (VAR_##name == LOADER_##name) return err; \
           return VAR_##name args2;                     \
        }                                               \
        TYP_##name VAR_##name = LOADER_##name;

#else  // !IMPLEMENT_LOADER_FUNCTIONS
#define LOADER_FUNCTION(ret, name, args1, args2, err, dll)   \
        typedef ret (WINAPI * TYP_##name) args1;        \
        extern TYP_##name VAR_##name;                   
#endif // IMPLEMENT_LOADER_FUNCTIONS

extern HMODULE s_hINetComm;

void InitDemandLoadedLibs();
void FreeDemandLoadedLibs();

/////////////////////////////////////
// INETCOMM.DLL

BOOL DemandLoadINETCOMM(void);

interface IHTMLDocument2;
interface IMimeMessage;

LOADER_FUNCTION( HRESULT, MimeEditViewSource,
    (HWND hwnd, IMimeMessage *pMsg),
    (hwnd, pMsg),
    E_FAIL, INETCOMM)
#define MimeEditViewSource VAR_MimeEditViewSource

LOADER_FUNCTION( HRESULT, MimeEditCreateMimeDocument,
    (IHTMLDocument2 *pDoc, IMimeMessage *pMsgSrc, DWORD dwFlags, IMimeMessage **ppMsg),
    (pDoc, pMsgSrc, dwFlags, ppMsg),
    E_FAIL, INETCOMM)
#define MimeEditCreateMimeDocument VAR_MimeEditCreateMimeDocument
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mepad\dochost.cpp ===
/*
 *    d o c h o s t . c p p
 *    
 *    Purpose:
 *        basic implementation of a docobject host. Used by the body class to
 *        host Trident and/or MSHTML
 *
 *  History
 *      August '96: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include "pch.hxx"
#include <resource.h>
#include "globals.h"
#include "dochost.h"




/*
 *  m a c r o s
 */

/*
 *  c o n s t a n t s
 */

static CHAR c_szDocHostWndClass[] = "MEPAD_DocHost";
/*
 *  t y p e d e f s
 */

/*
 *  g l o b a l s 
 */

/*
 *  f u n c t i o n   p r o t y p e s
 */

/*
 *  f u n c t i o n s
 */

HRESULT HrInitNew(LPUNKNOWN pUnk)
{
    LPPERSISTSTREAMINIT ppsi=0;
    HRESULT hr;

    if (!pUnk)
        return E_INVALIDARG;

    hr=pUnk->QueryInterface(IID_IPersistStreamInit, (LPVOID *)&ppsi);
    if (FAILED(hr))
        goto error;

    hr = ppsi->InitNew();

error:
    ReleaseObj(ppsi);
    return hr;
}


CDocHost::CDocHost()
{
/*
    Not initialised
    Member:                 Initialised In:
    --------------------+---------------------------
*/
    m_cRef=1;
    m_hwnd=0;
    m_pDocView=0;
    m_lpOleObj=0;
    m_pCmdTarget=0;
    m_ulAdviseConnection=0;
    m_hwndDocObj=NULL;
    m_fUIActive=FALSE;
    m_fFocus=FALSE;
    m_fDownloading=FALSE;
    m_dhbBorder=dhbNone;
    m_fCycleFocus=FALSE;
    m_pInPlaceActiveObj = NULL;
    m_dwFrameWidth = 0;
    m_dwFrameHeight = 0;
	m_pInPlaceFrame =0;
}

CDocHost::~CDocHost()
{
    SafeRelease(m_pInPlaceFrame);
	SafeRelease(m_pCmdTarget);
    SafeRelease(m_lpOleObj);
    SafeRelease(m_pDocView);
    SafeRelease(m_pInPlaceActiveObj);
    HrCloseDocObj();
}

ULONG CDocHost::AddRef()
{
    return ++m_cRef;
}

ULONG CDocHost::Release()
{
    if (--m_cRef==0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}


HRESULT CDocHost::QueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;   // set to NULL, in case we fail.

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(LPUNKNOWN)(LPOLEINPLACEFRAME)this;

    else if (IsEqualIID(riid, IID_IOleInPlaceSite))
        *lplpObj = (LPVOID)(LPOLEINPLACESITE)this;

    else if (IsEqualIID(riid, IID_IOleClientSite))
        *lplpObj = (LPVOID)(LPOLECLIENTSITE)this;

    else if (IsEqualIID(riid, IID_IOleControlSite))
        *lplpObj = (LPVOID)(IOleControlSite *)this;

    else if (IsEqualIID(riid, IID_IAdviseSink))
        *lplpObj = (LPVOID)(LPADVISESINK)this;

    else if (IsEqualIID(riid, IID_IOleDocumentSite))
        *lplpObj = (LPVOID)(LPOLEDOCUMENTSITE)this;

    // BUG BUGB
    // I don't think we need to provide this, here for debugging for now
    // brettm
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *lplpObj = (LPVOID)(LPOLECOMMANDTARGET)this;

    else if (IsEqualIID(riid, IID_IServiceProvider))
        *lplpObj = (LPVOID)(LPSERVICEPROVIDER)this;

    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}



LRESULT CALLBACK CDocHost::ExtWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LPDOCHOST pDocHost;

    if(msg==WM_CREATE)
        {
        pDocHost=(CDocHost *)((LPMDICREATESTRUCT)((LPCREATESTRUCT)lParam)->lpCreateParams)->lParam;
        if(!pDocHost)
            return -1;

        if(!pDocHost->WMCreate(hwnd))
            return -1;
        }
    
    pDocHost = (LPDOCHOST)GetWndThisPtr(hwnd);
    if(pDocHost)
        return pDocHost->WndProc(hwnd, msg, wParam, lParam);
    else
        return DefMDIChildProc(hwnd, msg, wParam, lParam);
}

LRESULT CDocHost::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
        {
        case WM_MDIACTIVATE:
			// if lParam is our HWND we're being activated, else deactivated
			if (m_pInPlaceActiveObj)
				m_pInPlaceActiveObj->OnDocWindowActivate((HWND)lParam == m_hwnd);
			break;

		case WM_DESTROY:
            HrCloseDocObj();
            break;

        case WM_SETFOCUS:
            if(m_pDocView)
                m_pDocView->UIActivate(TRUE);
            break;

        case WM_SIZE:
            WMSize(LOWORD(lParam), HIWORD(lParam));
            return 0;

        case WM_NCDESTROY:
            WMNCDestroy();
            break;

        }
    return DefMDIChildProc(hwnd, msg, wParam, lParam);
}

void CDocHost::WMNCDestroy()
{
    SetWindowLong(m_hwnd, GWL_USERDATA, NULL);
    m_hwnd = NULL;
    Release();
}


BOOL CDocHost::WMCreate(HWND hwnd)
{
    m_hwnd = hwnd;
    SetWindowLong(hwnd, GWL_USERDATA, (LPARAM)this);
    AddRef();

    return SUCCEEDED(HrSubWMCreate())?TRUE:FALSE;
}


HRESULT CDocHost::HrCreateDocObj(LPCLSID pCLSID)
{
    HRESULT             hr=NOERROR;

    if(!pCLSID)
        return E_INVALIDARG;


    hr = CoCreateInstance(*pCLSID, NULL, CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER,
                                        IID_IOleObject, (LPVOID *)&m_lpOleObj);

    if (FAILED(hr))
        {
        MessageBox(m_hwnd, "MEPAD", "Failed to create DocObj", MB_OK);
        goto error;
        }

    hr = m_lpOleObj->SetClientSite((LPOLECLIENTSITE)this);
    if (FAILED(hr))
        goto error;

    hr = m_lpOleObj->Advise((LPADVISESINK)this, &m_ulAdviseConnection);
    if (FAILED(hr))
        goto error;

    hr = m_lpOleObj->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&m_pCmdTarget);
    if (FAILED(hr))  
        goto error;  

    hr = HrInitNew(m_lpOleObj);
    if (FAILED(hr))  
        goto error;  

error:
    return hr;
}


HRESULT CDocHost::HrShow()
{
    RECT                rc;
    HRESULT             hr;

    GetClientRect(m_hwnd, &rc);
    HrGetDocObjSize(&rc);
  
    hr=m_lpOleObj->DoVerb(OLEIVERB_SHOW, NULL, (LPOLECLIENTSITE)this, 0, m_hwnd, &rc);
    if(FAILED(hr))
        goto error;

	ShowWindow(m_hwnd, SW_SHOW);

error:
    return hr;
}



HRESULT CDocHost::HrCloseDocObj()
{
    LPOLEINPLACEOBJECT  pInPlaceObj=0;

    SafeRelease(m_pInPlaceFrame);
	SafeRelease(m_pCmdTarget);
    SafeRelease(m_pInPlaceActiveObj);

    if(m_pDocView)
        {
        m_pDocView->UIActivate(FALSE);
        m_pDocView->CloseView(0);
        m_pDocView->SetInPlaceSite(NULL);
        SafeRelease(m_pDocView);
        }

    if (m_lpOleObj)
        {
        if (m_ulAdviseConnection)
            {
            m_lpOleObj->Unadvise(m_ulAdviseConnection);
            m_ulAdviseConnection=NULL;
            }

        // deactivate the docobj. mshtml seems more sensitive to this than Trident.
        if (!FAILED(m_lpOleObj->QueryInterface(IID_IOleInPlaceObject, (LPVOID*)&pInPlaceObj)))
            {
            pInPlaceObj->InPlaceDeactivate();
            pInPlaceObj->Release();
            }
        
        // close the ole object, but blow off changes as we have either extracted 
        // them ourselves or don't care.
        m_lpOleObj->Close(OLECLOSE_NOSAVE);
#ifdef DEBUG
        ULONG   uRef;
        uRef=
#endif
        m_lpOleObj->Release();
        m_lpOleObj=NULL;
        }

    m_fDownloading=FALSE;
    m_fFocus=FALSE;
    m_fUIActive=FALSE;
    return NOERROR;
}

 
HRESULT CDocHost::HrInit(HWND hwndParent, int idDlgItem, DWORD dhbBorder)
{
    HRESULT hr=S_OK;
    HWND    hwnd;
    WNDCLASS    wc={0};

    if(!IsWindow(hwndParent))
        return E_INVALIDARG;

    m_dhbBorder=dhbBorder;

    if (!GetClassInfo(g_hInst, c_szDocHostWndClass, &wc))
        {
        wc.lpfnWndProc   = CDocHost::ExtWndProc;
        wc.hInstance     = g_hInst;
        wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wc.lpszClassName = c_szDocHostWndClass;
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
		wc.hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(idiApp));
        wc.style = CS_DBLCLKS;

        if(!RegisterClass(&wc))
            return E_OUTOFMEMORY;

        }

    hwnd = CreateMDIWindow(
                c_szDocHostWndClass, 
                "MimeEdit Host", 
                MDIS_ALLCHILDSTYLES|
                WS_CHILD|WS_CLIPCHILDREN|WS_CLIPSIBLINGS|WS_MAXIMIZEBOX|WS_CAPTION|WS_SYSMENU|WS_THICKFRAME,
                CW_USEDEFAULT, CW_USEDEFAULT,
                CW_USEDEFAULT, CW_USEDEFAULT,
                hwndParent,
                g_hInst,
                (LONG)this);

    if(!hwnd)
        {
        hr=E_OUTOFMEMORY;
        goto error;
        }

error:
    return hr;
}




// *** IOleWindow methods ***
HRESULT CDocHost::GetWindow(HWND *phwnd)
{
    *phwnd=m_hwnd;
    return NOERROR;
}

HRESULT CDocHost::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}

// *** IOleInPlaceUIWindow methods ***
HRESULT CDocHost::GetBorder(LPRECT lprectBorder)
{
    return E_NOTIMPL;
}

HRESULT CDocHost::RequestBorderSpace(LPCBORDERWIDTHS pborderwidths)
{
    return NOERROR;
}

HRESULT CDocHost::SetBorderSpace(LPCBORDERWIDTHS lpborderwidths)
{
    return NOERROR;
}

HRESULT CDocHost::SetActiveObject(IOleInPlaceActiveObject * pActiveObject, LPCOLESTR lpszObjName)
{
    
    SafeRelease(m_pInPlaceActiveObj);
    m_pInPlaceActiveObj=pActiveObject;
    if(m_pInPlaceActiveObj)
        m_pInPlaceActiveObj->AddRef();
    return NOERROR;
}

// **** IOleInPlaceSite methods ****
HRESULT CDocHost::CanInPlaceActivate()
{
    return NOERROR;
}

HRESULT CDocHost::OnInPlaceActivate()
{
    LPOLEINPLACEACTIVEOBJECT    pInPlaceActive=0;


    m_lpOleObj->QueryInterface(IID_IOleInPlaceActiveObject, (LPVOID *)&pInPlaceActive);
    if(pInPlaceActive)
        {
        pInPlaceActive->GetWindow(&m_hwndDocObj);
        ReleaseObj(pInPlaceActive);
        }
    return NOERROR;
}

HRESULT CDocHost::OnUIActivate()
{
    m_fUIActive=TRUE;
    return NOERROR;
}

HRESULT CDocHost::GetWindowContext(IOleInPlaceFrame **ppFrame,
                                 IOleInPlaceUIWindow **ppDoc,
                                 LPRECT lprcPosRect, 
                                 LPRECT lprcClipRect,
                                 LPOLEINPLACEFRAMEINFO lpFrameInfo)
{

	*ppFrame = (LPOLEINPLACEFRAME)m_pInPlaceFrame;
	m_pInPlaceFrame->AddRef();

    *ppDoc = (IOleInPlaceUIWindow *)this;
	AddRef();

    GetClientRect(m_hwnd, lprcClipRect);
    GetClientRect(m_hwnd, lprcPosRect);
    HrGetDocObjSize(lprcClipRect);
    HrGetDocObjSize(lprcPosRect);
    lpFrameInfo->fMDIApp = FALSE;

    lpFrameInfo->hwndFrame=m_hwnd;
    lpFrameInfo->haccel = NULL;
    lpFrameInfo->cAccelEntries = 0;
    return NOERROR;
}

HRESULT CDocHost::Scroll(SIZE scrollExtent)
{
    // the docobject consumes the entireview, so scroll requests
    // are meaningless. Return NOERROR to indicate that they're scolled
    // into view.
    return NOERROR;
}

HRESULT CDocHost::OnUIDeactivate(BOOL fUndoable)
{
    m_fUIActive=FALSE;
    return S_OK;
}

HRESULT CDocHost::OnInPlaceDeactivate()
{
    return S_OK;
}

HRESULT CDocHost::DiscardUndoState()
{
    return E_NOTIMPL;
}

HRESULT CDocHost::DeactivateAndUndo()
{
    return E_NOTIMPL;
}

HRESULT CDocHost::OnPosRectChange(LPCRECT lprcPosRect)
{
    return E_NOTIMPL;
}


// IOleClientSite methods.
HRESULT CDocHost::SaveObject()
{
    return E_NOTIMPL;
}

HRESULT CDocHost::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER *ppmnk)
{
    return E_NOTIMPL;
}

HRESULT CDocHost::GetContainer(LPOLECONTAINER *ppCont)
{
    if(ppCont)
        *ppCont=NULL;
    return E_NOINTERFACE;
}


HRESULT CDocHost::ShowObject()
{
    // always shown. 
    // $TODO: do we need to restore the browser here if it is
    // minimised?
    return NOERROR;
}

HRESULT CDocHost::OnShowWindow(BOOL fShow)
{
    return E_NOTIMPL;
}

HRESULT CDocHost::RequestNewObjectLayout()
{
    return E_NOTIMPL;
}


// IAdviseSink methods
void CDocHost::OnDataChange(FORMATETC *pfetc, STGMEDIUM *pstgmed)
{
}

void CDocHost::OnViewChange(DWORD dwAspect, LONG lIndex)
{
}

void CDocHost::OnRename(LPMONIKER pmk)
{
}

void CDocHost::OnSave()
{
}

void CDocHost::OnClose()
{
}


// IOleDocumentSite
HRESULT CDocHost::ActivateMe(LPOLEDOCUMENTVIEW pViewToActivate)
{

    return HrCreateDocView();
}


HRESULT CDocHost::HrCreateDocView()
{
    HRESULT         hr;
    LPOLEDOCUMENT   pOleDoc=NULL;

    hr=OleRun(m_lpOleObj);
    if(FAILED(hr))
        goto error;
    
    hr=m_lpOleObj->QueryInterface(IID_IOleDocument, (LPVOID*)&pOleDoc);
    if(FAILED(hr))
        goto error;

    hr=pOleDoc->CreateView(this, NULL,0,&m_pDocView);
    if(FAILED(hr))
        goto error;

    hr=m_pDocView->SetInPlaceSite(this);
    if(FAILED(hr))
        goto error;

    hr=m_pDocView->Show(TRUE);
    if(FAILED(hr))
        goto error;

error:
    ReleaseObj(pOleDoc);
    return hr;
}


HRESULT CDocHost::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pCmdText)
{
    ULONG ul;

    // BUGBUG: Check IsEqualGUID(*pguidCmdGroup, CGID_ShellDocView) as well

    if (!rgCmds)
        return E_INVALIDARG;

    if (pguidCmdGroup == NULL)
        {
        for (ul=0;ul<cCmds; ul++)
            {
            switch (rgCmds[ul].cmdID)
                {
                case OLECMDID_OPEN:
                case OLECMDID_SAVE:
                case OLECMDID_PRINT:
                    rgCmds[ul].cmdf = MSOCMDF_ENABLED;
                    break;

                default:
                    rgCmds[ul].cmdf = 0;
                    break;
                }
            }

        /* for now we deal only with status text*/
        if (pCmdText)
            {
            if (!(pCmdText->cmdtextf & OLECMDTEXTF_STATUS))
                {
                pCmdText->cmdtextf = OLECMDTEXTF_NONE;// is this needed?
                pCmdText->cwActual = 0;
                return NOERROR;
                }
            }
        return NOERROR;
        }

    return OLECMDERR_E_UNKNOWNGROUP;
}

HRESULT CDocHost::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn,	VARIANTARG *pvaOut)
{
    if (pguidCmdGroup == NULL)
        {
        switch(nCmdID)
            {
             case OLECMDID_SETDOWNLOADSTATE:
                if(pvaIn->vt==VT_I4)
                    {
                    m_fDownloading=pvaIn->lVal;
                    return S_OK;
                    }
                break;

            case OLECMDID_UPDATECOMMANDS:
                OnUpdateCommands();
                break;

            case OLECMDID_SETPROGRESSPOS:
                // when done downloading trident now hits us with a 
                // setprogresspos == -1 to indicate we should remove the "Done"
                if (pvaIn->lVal == -1)
                    m_pInPlaceFrame->SetStatusText(NULL);
                return S_OK;

            case OLECMDID_SETPROGRESSTEXT:
                if(pvaIn->vt == (VT_BSTR))
                    m_pInPlaceFrame->SetStatusText((LPCOLESTR)pvaIn->bstrVal);
                return S_OK;
            }
        }
    return OLECMDERR_E_UNKNOWNGROUP;
}

void CDocHost::WMSize(int cxBody, int cyBody)
{
    RECT rc={0};

    if(m_pDocView)
        {
        rc.bottom=cyBody;
        rc.right=cxBody;

        // give the subclass a chance to override the size of the
        // docobj
        HrGetDocObjSize(&rc);
        m_pDocView->SetRect(&rc);
        }

    // notify the subclass of a wmsize
    OnWMSize(&rc);
} 



HRESULT CDocHost::QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject)
{
    return E_UNEXPECTED;
}



HRESULT CDocHost::HrSubWMCreate()
{
    return NOERROR;
}


HRESULT CDocHost::OnControlInfoChanged()
{
    return E_NOTIMPL;
}

HRESULT CDocHost::LockInPlaceActive(BOOL fLock)
{
    return E_NOTIMPL;
}


HRESULT CDocHost::GetExtendedControl(LPDISPATCH *ppDisp)
{
    if (ppDisp)
        *ppDisp=NULL;

    return E_NOTIMPL;
}

HRESULT CDocHost::TransformCoords(POINTL *pPtlHimetric, POINTF *pPtfContainer,DWORD dwFlags)
{
    return E_NOTIMPL;
}

/*
 * this is a little trippy, so bear with me. When we get a tab, and trident is UIActive we always pass it off to them
 * if it tabs off the end of its internal tab order (a list of urls for instance) then we get hit with a VK_TAB in our
 * IOleControlSite::TranslateAccel. If so then we set m_fCycleFocus to TRUE and return S_OK to indicate we took the tab
 * tridents IOIPAO::TranslateAccel returns S_OK to indicate it snagged the TAB, we then detect if we set cyclefocus to true
 * there and if so, we return S_FALSE from CBody::HrTranslateAccel to indicate to the browser that we didn't take it and it
 * move the focus on
 *
 */
HRESULT CDocHost::TranslateAccelerator(LPMSG lpMsg, DWORD grfModifiers)
{
    if (lpMsg->message == WM_KEYDOWN && lpMsg->wParam == VK_TAB)
        {
        m_fCycleFocus=TRUE;
        return S_OK;
        }

    return E_NOTIMPL;
}

HRESULT CDocHost::OnFocus(BOOL fGotFocus)
{
    m_fFocus = fGotFocus;
    return S_OK;
}

HRESULT CDocHost::ShowPropertyFrame(void)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mepad\mehost.h ===
#ifndef _MEHOST_H
#define _MEHOST_H

#include "dochost.h"
#include "mimeole.h"

class CMeHost :
    public CDocHost
{

public:
    CMeHost();
    virtual ~CMeHost();
    virtual ULONG   STDMETHODCALLTYPE AddRef();
    virtual ULONG   STDMETHODCALLTYPE Release();

    HRESULT HrInit(HWND hwndMDIClient, IOleInPlaceFrame *pFrame);
    HRESULT HrLoadFile(LPSTR pszFile);

    HRESULT OnCommand(HWND hwnd, int id, WORD wCmd);
    LRESULT OnInitMenuPopup(HWND hwnd, HMENU hmenuPopup, UINT uPos);

    // IOleCommandTarget 
    virtual HRESULT STDMETHODCALLTYPE QueryStatus(const GUID *, ULONG, OLECMD [], OLECMDTEXT *);
    virtual HRESULT STDMETHODCALLTYPE Exec(const GUID *, DWORD, DWORD, VARIANTARG *, VARIANTARG *);
    static BOOL CALLBACK ExtFmtDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK ExtLangDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    virtual LRESULT WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

private:
    BOOL                m_fEditMode,
                        m_fHTMLMode;
    char                m_szFmt[256];
    WCHAR               m_szFileW[MAX_PATH];
    IMimeMessage        *m_pMsg;
    IMimeInternational  *m_pIntl;

    HRESULT HrOpen(HWND hwnd);

    BOOL FmtDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    BOOL LangDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    HRESULT Save();
    HRESULT SaveAs();
    HRESULT SaveAsStationery();
    HRESULT SaveToFile(LPWSTR pszW);
    HRESULT SaveAsMhtmlTest();
    HCHARSET GetCharset();
    HRESULT BackRed();
    HRESULT ForeRed();
    HRESULT BackgroundPicture();
};

typedef CMeHost *LPMEHOST;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mepad\globals.h ===
#ifndef _GLOBALS_H
#define _GLOBALS_H

extern  HINSTANCE g_hInst;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mepad\mepadrt.h ===
#ifndef _MEPADRT_H
#define _MEPADRT_H

 // -------------------------------------------------------------------------
 // ReplaceInterface - Replaces a member interface with a new interface
 // -------------------------------------------------------------------------

 #define ReplaceInterface(_pUnk, _pUnkNew)  \
     { \
     if (_pUnk)  \
         _pUnk->Release();   \
     if (_pUnk = _pUnkNew)   \
         _pUnk->AddRef();    \
     }

#define ReleaseObj(_object)   (_object) ? (_object)->Release() : 0

#define SafeRelease(_object) \
    if (_object) { \
        (_object)->Release(); \
        (_object) = NULL; \
    } else

#define GetWndThisPtr(hwnd) \
    GetWindowLong(hwnd, GWL_USERDATA)


#endif // _MEPADRT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mepad\frame.h ===
#ifndef _FRAME_H
#define _FRAME_H

class CMDIFrame :
    public IOleInPlaceFrame
{
public:
    CMDIFrame();
    virtual ~CMDIFrame();

    // *** IUnknown methods ***
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // *** IOleWindow methods ***
    virtual HRESULT STDMETHODCALLTYPE GetWindow(HWND *);
    virtual HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL);

    // *** IOleInPlaceUIWindow methods ***
    virtual HRESULT STDMETHODCALLTYPE GetBorder(LPRECT);
    virtual HRESULT STDMETHODCALLTYPE RequestBorderSpace(LPCBORDERWIDTHS);
    virtual HRESULT STDMETHODCALLTYPE SetBorderSpace(LPCBORDERWIDTHS);
    virtual HRESULT STDMETHODCALLTYPE SetActiveObject(IOleInPlaceActiveObject *, LPCOLESTR); 

    // *** IOleInPlaceFrame methods ***
    virtual HRESULT STDMETHODCALLTYPE InsertMenus(HMENU, LPOLEMENUGROUPWIDTHS);
    virtual HRESULT STDMETHODCALLTYPE SetMenu(HMENU, HOLEMENU, HWND);
    virtual HRESULT STDMETHODCALLTYPE RemoveMenus(HMENU);
    virtual HRESULT STDMETHODCALLTYPE SetStatusText(LPCOLESTR);    
    virtual HRESULT STDMETHODCALLTYPE EnableModeless(BOOL);
    virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator(LPMSG, WORD);


    static LRESULT CALLBACK ExtWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK ExtOptDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    LRESULT WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    BOOL OptDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    HRESULT HrInit(LPSTR pszCmdLine);
    HRESULT TranslateAcclerator(LPMSG);

private:
    HWND                m_hwnd,
                        m_hToolbar,
                        m_hStatusbar,
                        m_hwndClient,
                        m_hwndFocus;
    BOOL                m_fToolbar;
    BOOL                m_fStatusbar;
    ULONG               m_cRef;
	IOleInPlaceActiveObject	*m_pInPlaceActiveObj;

    BOOL WMCreate(HWND hwnd);
    void WMDestroy();
    HRESULT HrWMCommand(HWND hwnd, int id, WORD wCmd);
    void WMNotify(WPARAM wParam, NMHDR* pnmhdr);
    void WMPaint();
    void WMSize();
    void SetToolbar();
    void SetStatusbar();
    void DoOptions();
    LRESULT WMInitMenuPopup(HWND hwnd, HMENU hmenuPopup, UINT uPos);
    HRESULT OpenDoc(LPSTR pszFileName);
};

typedef CMDIFrame *LPMDIFRAME;

#endif //_FRAME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mepad\frame.cpp ===
#include "pch.hxx"
#include "globals.h"
#include "resource.h"
#include "util.h"
#include "frame.h"
#include "mehost.h"

void SaveFocus(BOOL fActive, HWND *phwnd);

CMDIFrame::CMDIFrame()
{
    m_hwnd = 0;
    m_hToolbar = 0;
    m_hStatusbar = 0;
    m_fToolbar = TRUE;
    m_fStatusbar = TRUE;
    m_cRef = 1;
	m_pInPlaceActiveObj=0;
    m_hwndFocus=0;
}


CMDIFrame::~CMDIFrame()
{
	SafeRelease(m_pInPlaceActiveObj);
}


ULONG CMDIFrame::AddRef()
{
    return ++m_cRef;
}

ULONG CMDIFrame::Release()
{
    if (--m_cRef==0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}

HRESULT CMDIFrame::QueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;   // set to NULL, in case we fail.

    if (IsEqualIID(riid, IID_IOleInPlaceFrame))
        *lplpObj = (LPVOID)(LPOLEINPLACEFRAME)this;
    else if (IsEqualIID(riid, IID_IOleInPlaceUIWindow))
        *lplpObj = (LPVOID)(IOleInPlaceUIWindow *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}


HRESULT CMDIFrame::HrInit(LPSTR pszCmdLine)
{
    static char szAppName[] = "Mepad";
    HWND        hwnd = NULL;
    WNDCLASSEX  wndclass;
    HRESULT     hr=E_FAIL;

    wndclass.cbSize        = sizeof(wndclass);
    wndclass.style         = 0;
    wndclass.lpfnWndProc   = CMDIFrame::ExtWndProc;
    wndclass.cbClsExtra    = 0;
    wndclass.cbWndExtra    = 0;
    wndclass.hInstance     = g_hInst;
    wndclass.hIcon         = LoadIcon(g_hInst, MAKEINTRESOURCE(idiApp));
    wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName  = MAKEINTRESOURCE(idmrMainMenu);
    wndclass.lpszClassName = szAppName;
    wndclass.hIconSm       = LoadIcon(g_hInst, MAKEINTRESOURCE(idiApp));

    RegisterClassEx(&wndclass);

    hwnd = CreateWindowEx(WS_EX_WINDOWEDGE|WS_EX_CONTROLPARENT,
                    szAppName,
                    "Mepad",
                    WS_OVERLAPPEDWINDOW|WS_CLIPCHILDREN,
                    CW_USEDEFAULT, CW_USEDEFAULT,
                    CW_USEDEFAULT, CW_USEDEFAULT,
                    NULL, NULL, g_hInst, (LPVOID)this);

    if(!hwnd)
        goto error;

    ShowWindow(hwnd, SW_SHOWNORMAL);
    UpdateWindow(hwnd);
    hr = NOERROR;

    if (pszCmdLine)
        hr = OpenDoc(pszCmdLine);

error:
    return hr;
}


LRESULT CALLBACK CMDIFrame::ExtWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CMDIFrame *pFrame=0;

    if(msg==WM_CREATE)
    {
        pFrame=(CMDIFrame *)((LPCREATESTRUCT)lParam)->lpCreateParams;
        if(pFrame && pFrame->WMCreate(hwnd))
            return 0;
        else
            return -1;
    }

    pFrame = (CMDIFrame *)GetWindowLong(hwnd, GWL_USERDATA);
    if(pFrame)
        return pFrame->WndProc(hwnd, msg, wParam, lParam);
    else
        return DefWindowProc(hwnd, msg, wParam, lParam);
}

enum 
{
    itbNew,
    itbOpen,
    itbSave,
    itbBack,
    itbForward,
    itbPrint,
    itbAbout,
    itbEditDoc,
    ctbToolbar
};

#define cxButtonSep 8
#define dxToolbar           16
#define dxStatusbar         14

static TBBUTTON rgtbbutton[] =
{
    { itbNew, idmNew,
            TBSTATE_ENABLED, TBSTYLE_BUTTON, {0}, 0L, -1 },
    { itbOpen, idmOpen,
            TBSTATE_ENABLED, TBSTYLE_BUTTON, {0}, 0L, -1 },
    { itbSave, idmSave,
            TBSTATE_ENABLED, TBSTYLE_BUTTON, {0}, 0L, -1 },
    { itbEditDoc, idmEditDocument,
            TBSTATE_ENABLED, TBSTYLE_BUTTON|TBSTYLE_CHECK, {0}, 0L, -1 }

};

#define ctbbutton           (sizeof(rgtbbutton) / sizeof(TBBUTTON))

BOOL CMDIFrame::WMCreate(HWND hwnd)
{
    HMENU           hMenu;
    MENUITEMINFO    mii;
    
    hMenu = GetMenu(hwnd);

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_ID | MIIM_SUBMENU;
    GetMenuItemInfo(hMenu, idmPopupWindow, FALSE, &mii);

    SetWindowLong(hwnd, GWL_USERDATA, (LONG)this);
    AddRef();
    m_hwnd=hwnd;

    // toolbar
    m_hToolbar = CreateToolbarEx(
        hwnd,
        WS_CLIPCHILDREN|WS_CHILD|TBSTYLE_TOOLTIPS|WS_VISIBLE|WS_BORDER,
        0, 
        ctbToolbar,
        g_hInst,
        idbToolbar,
        rgtbbutton, ctbbutton, 
        dxToolbar, dxToolbar, dxToolbar, dxToolbar,
        sizeof(TBBUTTON));

    m_hStatusbar = CreateWindowEx(
        0,
        STATUSCLASSNAME,
        "",
        WS_CHILD|WS_VISIBLE|WS_BORDER|SBS_SIZEGRIP,
        0,0,0,0,
        hwnd,
        0,
        g_hInst,
        NULL);

    CLIENTCREATESTRUCT  ccs;

    ccs.hWindowMenu = (HMENU)mii.hSubMenu;
    ccs.idFirstChild = 100;

    m_hwndClient = CreateWindowEx(
        0,
        "MDICLIENT",
        "",
        WS_CHILD|WS_CLIPCHILDREN|WS_VISIBLE,
        0,0,0,0,
        hwnd,
        0,
        g_hInst,
        (LPVOID)&ccs);


    SendMessage(m_hwndClient, WM_MDISETMENU, (WPARAM)hMenu, (LPARAM)mii.hSubMenu);

    SetToolbar();
    SetStatusbar();
    return TRUE;
}


void CMDIFrame::WMDestroy()
{
    PostQuitMessage(0);
    SetWindowLong(m_hwnd, GWL_USERDATA, 0);
    Release();
}


LRESULT CMDIFrame::WndProc (HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    LONG lRet;

    switch (iMsg)
    {
		case WM_CLOSE:
            HWND    hwndKid;

            hwndKid = ::GetWindow(m_hwndClient, GW_CHILD);
            while (hwndKid)
                {
                if (SendMessage(hwndKid, WM_CLOSE, 0, 0))
                    return 1;
                hwndKid = ::GetWindow(hwndKid, GW_HWNDNEXT);
                }
            break;

        case WM_ACTIVATE:
			if (m_pInPlaceActiveObj)
				m_pInPlaceActiveObj->OnFrameWindowActivate(LOWORD(wParam) != WA_INACTIVE);
			break;

        case WM_SIZE:
            WMSize();
            return 0;

        case WM_COMMAND:
            if(HrWMCommand(GET_WM_COMMAND_HWND(wParam, lParam),
                         GET_WM_COMMAND_ID(wParam, lParam),
                         GET_WM_COMMAND_CMD(wParam, lParam))==S_OK)
                return 0;
            break;

        case WM_NOTIFY:
            WMNotify(wParam, (NMHDR*)lParam);
            return 0;

        case WM_INITMENUPOPUP:
            return WMInitMenuPopup(hwnd, (HMENU)wParam, (UINT)LOWORD(lParam));

        case WM_MENUSELECT:
            if(m_hStatusbar)
                HandleMenuSelect(m_hStatusbar, wParam, lParam);
            return 0;

        case WM_DESTROY :
            WMDestroy();
            return 0 ;
    }
    lRet = DefFrameProc(hwnd, m_hwndClient, iMsg, wParam, lParam);

    if(iMsg==WM_ACTIVATE)
        {
        // post-process wm_activates to set focus back to
        // controls
        SaveFocus((BOOL)(LOWORD(wParam)), &m_hwndFocus);
        }

    return lRet;
}


void CMDIFrame::WMNotify(WPARAM wParam, NMHDR* pnmhdr)
{
    switch(pnmhdr->code)
    {
        case TTN_NEEDTEXT:
            ProcessTooltips((LPTOOLTIPTEXT) pnmhdr);
            break;

    }
}

HRESULT CMDIFrame::HrWMCommand(HWND hwnd, int id, WORD wCmd)
{
    HWND    hwndChild;
    CMeHost *pHost;

    HRESULT hr = S_FALSE;

    switch(id)
        {
        case idmOptions:
            DoOptions();
            break;

        case idmToggleToolbar:
            m_fToolbar = !m_fToolbar;
            SetToolbar();
            break;

        case idmToggleStatusbar:
            m_fStatusbar = !m_fStatusbar;
            SetStatusbar();
            break;

        case idmPopupFile:
            break;

        case idmTile:
            SendMessage(m_hwndClient, WM_MDITILE, MDITILE_HORIZONTAL, 0);
            break;

        case idmCascade:
            SendMessage(m_hwndClient, WM_MDICASCADE, 0, 0);
            break;

        case idmNew:
            pHost = new CMeHost();
            if (pHost)
                {
                hr = pHost->HrInit(m_hwndClient, (IOleInPlaceFrame *)this);
				pHost->Release();
                }
            if (FAILED(hr))
                MessageBox(hwnd, "Failed", "Mepad", MB_OK);
            break;

        case idmClose:
            PostMessage(m_hwnd, WM_CLOSE, 0, 0);
            return 0;

        case idmPageSetup:
        case idmPopupGo  :
        case idmPopupHelp:
            MessageBox(hwnd, "Not Implemented yet", "Mepad", MB_OK);
            hr = NOERROR;
            break;

        case idmAbout:
            MessageBox(hwnd, "MimeEdit Pad\nA test container for MimeEdit.\n(c) brettm", "Mepad", MB_OK);
            break;
        }

    // delegate the the active MDI child window
    hwndChild = (HWND)SendMessage(m_hwndClient, WM_MDIGETACTIVE, 0, 0);
    if (hwndChild)
        {
        pHost = (CMeHost *)GetWindowLong(hwndChild, GWL_USERDATA);
        if (pHost)
            pHost->OnCommand(hwnd, id, wCmd);
        }

    return hr;

}


void CMDIFrame::WMSize()
{
    RECT            rcToolbar,
                    rc,
                    rcStatus;
    int                 cy;

    SetWindowPos(m_hToolbar, NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOZORDER);
    SetWindowPos(m_hStatusbar, NULL, 0, 0, 0, 0, SWP_NOACTIVATE|SWP_NOZORDER);

    GetClientRect(m_hToolbar, &rcToolbar);
    GetClientRect(m_hToolbar, &rcStatus);

    GetClientRect(m_hwnd, &rc);
    cy = rc.bottom - rcToolbar.bottom - rcStatus.bottom + 3;
    SetWindowPos(m_hwndClient, NULL, 0, rcToolbar.bottom, rc.right-rc.left, cy, SWP_NOACTIVATE|SWP_NOZORDER);
}



void CMDIFrame::SetToolbar()
{
    ShowWindow(m_hToolbar, m_fToolbar?SW_SHOW:SW_HIDE);
    WMSize();
    InvalidateRect(m_hwnd, NULL, TRUE);
}

void CMDIFrame::SetStatusbar()
{
    ShowWindow(m_hStatusbar, m_fStatusbar?SW_SHOW:SW_HIDE);
    WMSize();
    InvalidateRect(m_hwnd, NULL, TRUE);
}


LRESULT CMDIFrame::WMInitMenuPopup(HWND hwnd, HMENU hmenuPopup, UINT uPos)
{
    MENUITEMINFO    mii;
    HMENU           hmenuMain;
    UINT            ustate;
    HWND            hwndChild;
    CMeHost         *pHost;

    hmenuMain = GetMenu(hwnd);
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_ID | MIIM_SUBMENU;
    GetMenuItemInfo(hmenuMain, uPos, TRUE, &mii);

    // grey all the commands handled by the children, then can reenable them
    EnableMenuItem(hmenuPopup, idmOpen, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmEditDocument, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmCut, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmCopy, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmPaste, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmUndo, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmRedo, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmSelectAll, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmPrint, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmSaveAs, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmFind, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmRot13, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmNoHeader, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmPreview, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmMiniHeader, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmFormatBar, MF_BYCOMMAND|MF_GRAYED);
    EnableMenuItem(hmenuPopup, idmFmtPreview, MF_BYCOMMAND|MF_GRAYED);

    switch (mii.wID)
    {
        case idmPopupView:
            ustate = (m_fToolbar?MF_CHECKED:MF_UNCHECKED) | MF_BYCOMMAND;
            CheckMenuItem(hmenuPopup, idmToggleToolbar, ustate);
            ustate = (m_fStatusbar?MF_CHECKED:MF_UNCHECKED) | MF_BYCOMMAND;
            CheckMenuItem(hmenuPopup, idmToggleStatusbar, ustate);
            break;
    }

    // delegate to the active MDI child window
    hwndChild = (HWND)SendMessage(m_hwndClient, WM_MDIGETACTIVE, 0, 0);
    if (hwndChild)
        {
        pHost = (CMeHost *)GetWindowLong(hwndChild, GWL_USERDATA);
        if (pHost)
            pHost->OnInitMenuPopup(hwnd, hmenuPopup, uPos);
        }

    return 0;
}


static HACCEL   hAccel=0;

HRESULT CMDIFrame::TranslateAcclerator(LPMSG lpmsg)
{
    HWND    hwndChild;

    if (!hAccel)
        hAccel = LoadAccelerators(g_hInst, MAKEINTRESOURCE(idacMeHost));

    if(::TranslateAccelerator(m_hwnd, hAccel, lpmsg))
        return S_OK;

    hwndChild = (HWND)SendMessage(m_hwndClient, WM_MDIGETACTIVE, 0, 0);
    
    if(hwndChild && 
        ::TranslateAccelerator(hwndChild, hAccel, lpmsg))
        return S_OK;

    if (TranslateMDISysAccel(m_hwndClient, lpmsg))
        return S_OK;

	if (m_pInPlaceActiveObj)
		return m_pInPlaceActiveObj->TranslateAccelerator(lpmsg);

    return S_FALSE;
}


// *** IOleInPlaceFrame methods ***
HRESULT CMDIFrame::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths)
{

    return NOERROR;
}

HRESULT CMDIFrame::SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
{
    return NOERROR;
}

HRESULT CMDIFrame::RemoveMenus(HMENU hmenuShared)
{
    return NOERROR;
}

HRESULT CMDIFrame::SetStatusText(LPCOLESTR pszStatusText)
{
    if (pszStatusText)
        {
        TCHAR   rgch[MAX_PATH];

        WideCharToMultiByte(CP_ACP, 0, pszStatusText, -1, rgch, MAX_PATH, NULL, NULL);
        SendMessage(m_hStatusbar, SB_SIMPLE, (WPARAM)TRUE, 0);
        SendMessage(m_hStatusbar, SB_SETTEXT, SBT_NOBORDERS|255, (LPARAM) rgch);
        }
    else
        {
        SendMessage(m_hStatusbar, SB_SIMPLE, (WPARAM)FALSE, 0);
        }

    return S_OK;
}

HRESULT CMDIFrame::EnableModeless(BOOL fEnable)
{
    return E_NOTIMPL;
}

HRESULT CMDIFrame::TranslateAccelerator(LPMSG lpMsg, WORD wID)
{
    return E_NOTIMPL;
}


HRESULT CMDIFrame::GetWindow(HWND *phwnd)
{
	*phwnd = m_hwnd;
	return S_OK;
}

HRESULT CMDIFrame::ContextSensitiveHelp(BOOL)
{
	return E_NOTIMPL;
}


    // *** IOleInPlaceUIWindow methods ***
HRESULT CMDIFrame::GetBorder(LPRECT)
{
	return E_NOTIMPL;

}

HRESULT CMDIFrame::RequestBorderSpace(LPCBORDERWIDTHS)
{
	return E_NOTIMPL;

}

HRESULT CMDIFrame::SetBorderSpace(LPCBORDERWIDTHS)
{
	return E_NOTIMPL;

}

HRESULT CMDIFrame::SetActiveObject(IOleInPlaceActiveObject *pInPlaceActiveObj, LPCOLESTR)
{
	ReplaceInterface(m_pInPlaceActiveObj, pInPlaceActiveObj);
	return S_OK;
}


void CMDIFrame::DoOptions()
{
    DialogBoxParam(g_hInst, MAKEINTRESOURCE(iddOptions), m_hwnd, ExtOptDlgProc, (LPARAM)this);
}


INT_PTR CALLBACK CMDIFrame::ExtOptDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CMDIFrame *pFrame=(CMDIFrame *)GetWindowLong(hwnd, DWL_USER);

    if (msg==WM_INITDIALOG)
        {
        pFrame = (CMDIFrame *)lParam;
        SetWindowLong(hwnd, DWL_USER, lParam);
        }

    return pFrame?pFrame->OptDlgProc(hwnd, msg, wParam, lParam):FALSE;
}


BOOL    g_fHTML         =TRUE,
        g_fIncludeMsg   =TRUE,
        g_fQuote        =FALSE,
        g_fSlideShow    =FALSE,
        g_fAutoInline   =TRUE,
        g_fSendImages   =TRUE,
        g_fComposeFont  =TRUE,
        g_fBlockQuote   =TRUE,
        g_fAutoSig      =FALSE,
        g_fSigHtml      =FALSE;
        
CHAR    g_chQuote       ='>';
CHAR    g_szComposeFont[MAX_PATH] = "0,1,0,2,0.0.128,,Verdana";
LONG    g_lHeaderType   = 0;
CHAR    g_szSig[MAX_PATH]         = "<your signature goes here>";

INT_PTR CALLBACK CMDIFrame::OptDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    char sz[5];
    int i;

    switch (msg)
        { 
        case WM_COMMAND:
            switch (LOWORD(wParam))
                {
                case IDOK:
                    g_fHTML = IsDlgButtonChecked(hwnd, idcHTML);
                    g_fIncludeMsg = IsDlgButtonChecked(hwnd, idcInclude);
                    g_fQuote = IsDlgButtonChecked(hwnd, idcQuote);
                    g_fSlideShow = IsDlgButtonChecked(hwnd, idcSlide);
                    g_fAutoInline = IsDlgButtonChecked(hwnd, idcAuto);
                    g_fSendImages = IsDlgButtonChecked(hwnd, idcSendImages);
                    g_fComposeFont = IsDlgButtonChecked(hwnd, idcComposeFont);
                    g_fAutoSig = IsDlgButtonChecked(hwnd, idcSig);
                    g_fSigHtml = IsDlgButtonChecked(hwnd, idcSigHtml);

                    GetWindowText(GetDlgItem(hwnd, ideComposeFont), g_szComposeFont, MAX_PATH);
                    GetWindowText(GetDlgItem(hwnd, ideSig), g_szSig, MAX_PATH);

                    GetWindowText(GetDlgItem(hwnd, ideQuote), sz, 1);
                    g_chQuote = sz[0];

                    g_fBlockQuote = IsDlgButtonChecked(hwnd, idcBlockQuote);
                    for (i=0; i<4; i++)
                        if (IsDlgButtonChecked(hwnd, idrbNone+i))
                            g_lHeaderType = i;

                    // fall tro'
                case IDCANCEL:
                    EndDialog(hwnd, LOWORD(wParam));
                    return TRUE;
                }
            break;

        case WM_INITDIALOG:
            CheckDlgButton(hwnd, idcHTML, g_fHTML ? BST_CHECKED:BST_UNCHECKED);
            CheckDlgButton(hwnd, idcInclude, g_fIncludeMsg ? BST_CHECKED:BST_UNCHECKED);
            CheckDlgButton(hwnd, idcQuote, g_fQuote ? BST_CHECKED:BST_UNCHECKED);
            CheckDlgButton(hwnd, idcSlide, g_fSlideShow ? BST_CHECKED:BST_UNCHECKED);
            CheckDlgButton(hwnd, idcAuto, g_fAutoInline ? BST_CHECKED:BST_UNCHECKED);
            CheckDlgButton(hwnd, idcSendImages, g_fSendImages ? BST_CHECKED:BST_UNCHECKED);
            CheckDlgButton(hwnd, idcComposeFont, g_fComposeFont ? BST_CHECKED:BST_UNCHECKED);
            CheckDlgButton(hwnd, idcSig, g_fAutoSig ? BST_CHECKED:BST_UNCHECKED);
            CheckDlgButton(hwnd, idcSigHtml, g_fSigHtml ? BST_CHECKED:BST_UNCHECKED);

            sz[0] = g_chQuote;
            sz[1] = 0;
            SetWindowText(GetDlgItem(hwnd, ideQuote), sz);
            SetWindowText(GetDlgItem(hwnd, ideComposeFont), g_szComposeFont);
            SetWindowText(GetDlgItem(hwnd, ideSig), g_szSig);

            CheckRadioButton(hwnd, idrbNone, idrbPrint, idrbNone+g_lHeaderType);
            CheckDlgButton(hwnd, idcBlockQuote, g_fBlockQuote ? BST_CHECKED:BST_UNCHECKED);
            break;
        }

    return FALSE;
}


void SaveFocus(BOOL fActive, HWND *phwnd)
{
    if(fActive&&IsWindow(*phwnd))
        SetFocus(*phwnd);
    else
        *phwnd=GetFocus();
}


HRESULT CMDIFrame::OpenDoc(LPSTR pszFileName)
{
    CMeHost *pHost;
    HRESULT hr;

    if (pszFileName && *pszFileName)
        {
        pHost = new CMeHost();
        if (pHost)
            {
            hr = pHost->HrInit(m_hwndClient, (IOleInPlaceFrame *)this);
            if (!FAILED(hr))
                hr = pHost->HrLoadFile(pszFileName);
		    pHost->Release();
            }

        if (FAILED(hr))
            MessageBox(m_hwnd, "Failed to open file", "Mepad", MB_OK);
        }    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mepad\mepad.cpp ===
#include "pch.hxx"
#include "globals.h"
#include "resource.h"
#include "util.h"
#include "frame.h"

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;
HINSTANCE           g_hInst=NULL;

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
    CMDIFrame *pFrame=0;
    MSG         msg;

    g_hInst = hInstance;

    OleInitialize(NULL);

    pFrame = new CMDIFrame();
    if(pFrame)
    {
        pFrame->HrInit(szCmdLine);
        while(GetMessage(&msg, NULL, 0, 0))
        {
             if (pFrame->TranslateAcclerator(&msg)==S_OK)
                continue;

             TranslateMessage(&msg) ;
             DispatchMessage(&msg) ;
        }
        ReleaseObj(pFrame);
		OleUninitialize();
        return msg.wParam ;
    }

	OleUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mepad\mehost.cpp ===
#include "pch.hxx"
#include "globals.h"
#include "resource.h"
#include "util.h"
#include "mehost.h"
#include "demand.h"

#define SetMenuItem(_hmenu, _id, _fOn)     EnableMenuItem(_hmenu, _id, (_fOn)?MF_ENABLED:MF_DISABLED|MF_GRAYED)

extern BOOL    
        g_fHTML,
        g_fIncludeMsg,
        g_fQuote,
        g_fSlideShow,
        g_fAutoInline,
        g_fSendImages,
        g_fComposeFont,
        g_fBlockQuote,
        g_fAutoSig,
        g_fSigHtml;
       
extern CHAR     g_chQuote;
extern CHAR     g_szComposeFont[MAX_PATH];
extern CHAR     g_szSig[MAX_PATH];
extern LONG     g_lHeaderType;

INT_PTR CALLBACK MhtmlDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
HRESULT SetEncodingOptions(IMimeMessage *pMsg, HCHARSET hCharset);
HRESULT IPersistMimeLoad(IUnknown *pUnk, IMimeMessage *pMsg);

CMeHost::CMeHost()
{
    m_fEditMode=FALSE;
    m_fHTMLMode=TRUE;
    *m_szFileW=0;
    *m_szFmt = 0;
    m_pMsg=NULL;
    m_pIntl=NULL;
}


CMeHost::~CMeHost()
{
    SafeRelease(m_pIntl);
    SafeRelease(m_pMsg);
}

 
ULONG CMeHost::AddRef()
{
    return CDocHost::AddRef();
}

ULONG CMeHost::Release()
{
    return CDocHost::Release();
}


HRESULT CMeHost::HrInit(HWND hwndMDIClient, IOleInPlaceFrame *pFrame)
{
    HRESULT         hr=E_FAIL;
    IMimeMessage    *pMsg=0;

	if (pFrame==NULL)
		return E_INVALIDARG;

    hr=CDocHost::HrInit(hwndMDIClient, 99, dhbHost);
    if (FAILED(hr))
        goto error;

	ReplaceInterface(m_pInPlaceFrame, pFrame);

	hr=CDocHost::HrCreateDocObj((LPCLSID)&CLSID_MimeEdit);
    if (FAILED(hr))
        goto error;

    hr=CDocHost::HrShow();
    if (FAILED(hr))
        goto error;

    // need to init MimeEdit with a blank message
    hr = CoCreateInstance(CLSID_IMimeMessage, NULL, CLSCTX_INPROC_SERVER, IID_IMimeMessage, (LPVOID *)&pMsg);
    if (FAILED(hr))
        goto error;

    hr = pMsg->InitNew();
    if (FAILED(hr))
        goto error;

    hr = IPersistMimeLoad(m_lpOleObj, pMsg);

    // need to init MimeEdit with a blank message
    hr = CoCreateInstance(CLSID_IMimeInternational, NULL, CLSCTX_INPROC_SERVER, IID_IMimeInternational, (LPVOID *)&m_pIntl);
    if (FAILED(hr))
        goto error;

error:
    ReleaseObj(pMsg);
    return hr;
}

static char c_szFilter[] = "Rfc 822 Messages (*.eml)\0*.eml\0\0";
HRESULT CMeHost::HrOpen(HWND hwnd)
{
    OPENFILENAME    ofn;
    TCHAR           szFile[MAX_PATH];
    TCHAR           szTitle[MAX_PATH];
    TCHAR           szDefExt[30];

    if (!m_lpOleObj)
        return E_FAIL;

    lstrcpy(szFile, "c:\\*.eml");
    lstrcpy(szDefExt, ".eml");
    lstrcpy(szTitle, "Browse for message...");
    ZeroMemory (&ofn, sizeof (ofn));
    ofn.lStructSize = sizeof (ofn);
    ofn.hwndOwner = hwnd;
    ofn.lpstrFilter = c_szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = sizeof (szFile);
    ofn.lpstrTitle = szTitle;
    ofn.lpstrDefExt = szDefExt;
    ofn.Flags = OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;

    // Show OpenFile Dialog
    if (!GetOpenFileName(&ofn))
        return E_OUTOFMEMORY;

    return HrLoadFile(szFile);
}



HRESULT CMeHost::OnCommand(HWND hwnd, int id, WORD wCmd)
{
    VARIANTARG  va;
    ULONG       uCmd=0,
                uCmdMimeEdit,
                uPrompt = OLECMDEXECOPT_DODEFAULT;
    VARIANTARG  *pvaOut=0,
                *pvaIn=0;
    BSTR        bstrFree=0;
    CHAR        rgch[MAX_PATH];
    WCHAR       rgchW[MAX_PATH];

    switch (id)
        {
        case idmBackground:
            return BackgroundPicture();

        case idmTestBackRed:
            return BackRed();
        
        case idmTestForeRed:
            return ForeRed();

        case idmInsertFile:
            uCmdMimeEdit = MECMDID_INSERTTEXTFILE;
            
            // if shift it down prompt ourselves to test the other codepath
            if (GetKeyState(VK_SHIFT)&0x8000)
                {
                lstrcpy(rgch, "c:\\foo.txt");
                if (GenericPrompt(hwnd, "Insert File...", "pick a filename", rgch, MAX_PATH)!=S_OK)
                    return S_FALSE;
                
                MultiByteToWideChar(CP_ACP, 0, rgch, -1, rgchW, MAX_PATH);
                bstrFree = SysAllocString(rgchW);
                va.vt = VT_BSTR;
                va.bstrVal = bstrFree;
                pvaIn = &va;
                }

            break;

        case idmFont:
            uCmdMimeEdit = MECMDID_FORMATFONT;
            break;

        case idmSetText:
            uCmdMimeEdit = MECMDID_SETTEXT;
            va.vt = VT_BSTR;
            va.bstrVal = SysAllocString(L"This is a sample text string. <BR> It <b><i>can</b></i> be HTML.");
            bstrFree = va.bstrVal;
            pvaIn = &va;
            break;

        case idmSaveAsStationery:
            SaveAsStationery();
            break;

        case idmSaveAsMHTML:
            SaveAsMhtmlTest();
            break;

        case idmLang:
            DialogBoxParam(g_hInst, MAKEINTRESOURCE(iddLang), m_hwnd, ExtLangDlgProc, (LPARAM)this);
            break;

        case idmFmtPreview:
            DialogBoxParam(g_hInst, MAKEINTRESOURCE(iddFmt), m_hwnd, ExtFmtDlgProc, (LPARAM)this);
            break;

        case idmNoHeader:
            uCmdMimeEdit = MECMDID_STYLE;
            va.vt = VT_I4;
            va.lVal = MESTYLE_NOHEADER;
            pvaIn = &va;
            break;

        case idmPreview:
            uCmdMimeEdit = MECMDID_STYLE;
            va.vt = VT_I4;
            va.lVal = MESTYLE_PREVIEW;
            pvaIn = &va;
            break;

        case idmMiniHeader:
            uCmdMimeEdit = MECMDID_STYLE;
            va.vt = VT_I4;
            va.lVal = MESTYLE_MINIHEADER;
            pvaIn = &va;
            break;

        case idmFormatBar:
            uCmdMimeEdit = MECMDID_STYLE;
            va.vt = VT_I4;
            va.lVal = MESTYLE_FORMATBAR;
            pvaIn = &va;
            break;

        case idmViewSource:
        case idmViewMsgSource:
            uCmdMimeEdit = MECMDID_VIEWSOURCE;
            va.vt = VT_I4;
            va.lVal = (id == idmViewSource ? MECMD_VS_HTML : MECMD_VS_MESSAGE);
            pvaIn = &va;
            break;

        case idmCut:
            uCmd=OLECMDID_CUT;
            break;

        case idmCopy:
            uCmd=OLECMDID_COPY;
            break;

        case idmPaste:
            uCmd=OLECMDID_PASTE;
            break;

        case idmUndo:
            uCmd=OLECMDID_UNDO;
            break;

        case idmRedo:
            uCmd=OLECMDID_REDO;
            break;

        case idmSelectAll:
            uCmd=OLECMDID_SELECTALL;
            break;

        case idmOpen:
            HrOpen(hwnd);
            return S_OK;
        
        case idmHTMLMode:
            m_fHTMLMode = !m_fHTMLMode;

            va.vt = VT_BOOL;
            va.boolVal = m_fHTMLMode ? VARIANT_TRUE : VARIANT_FALSE;
            pvaIn = &va;
            m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_EDITHTML, OLECMDEXECOPT_DODEFAULT, &va, NULL);

            if (!m_fHTMLMode && 
                m_pCmdTarget && 
                MessageBox(m_hwnd, "You are going from HTML to plaintext. Do you want to downgrade the document?", "MeHost", MB_YESNO)==IDYES)
                m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_DOWNGRADEPLAINTEXT, OLECMDEXECOPT_DODEFAULT, NULL, NULL);

            return S_OK;

        case idmEditDocument:
            m_fEditMode = !m_fEditMode;
            uCmdMimeEdit = MECMDID_EDITMODE;
            va.vt = VT_BOOL;
            va.boolVal = m_fEditMode ? VARIANT_TRUE : VARIANT_FALSE;
            pvaIn = &va;
            break;
        
        case idmRot13:
            uCmdMimeEdit = MECMDID_ROT13;
            break;

        case idmFind:
            uCmd = OLECMDID_FIND;
            break;

        case idmSpelling:
            uCmd = OLECMDID_SPELL;
            break;

        case idmPrint:
            uCmd = OLECMDID_PRINT;
            break;
        
        case idmSaveAs:
            SaveAs();
            return 0;
        }

    if (m_pCmdTarget)
        {
        if (uCmd)
            m_pCmdTarget->Exec(NULL, uCmd, uPrompt, pvaIn, pvaOut);   
    
        if (uCmdMimeEdit)
            m_pCmdTarget->Exec(&CMDSETID_MimeEdit, uCmdMimeEdit, uPrompt, pvaIn, pvaOut);
        }

    SysFreeString(bstrFree);
    return S_OK;
}


LRESULT CMeHost::OnInitMenuPopup(HWND hwnd, HMENU hmenuPopup, UINT uPos)
{
    MENUITEMINFO    mii;
    HMENU           hmenuMain;
    OLECMD          rgMimeEditCmds[]=   {{MECMDID_EDITMODE, 0},
                                         {MECMDID_ROT13, 0},
                                         {MECMDID_EDITHTML, 0}};
    OLECMD          rgStdCmds[]=       {{OLECMDID_CUT, 0},
                                        {OLECMDID_COPY, 0},
                                        {OLECMDID_PASTE, 0},
                                        {OLECMDID_SELECTALL, 0},
                                        {OLECMDID_UNDO, 0},
                                        {OLECMDID_REDO, 0},
                                        {OLECMDID_FIND, 0}};
    int     rgidsStd[]=                 {idmCut,
                                        idmCopy,
                                        idmPaste,
                                        idmSelectAll,
                                        idmUndo,
                                        idmRedo,
                                        idmFind};
    int     rgidsMimeEdit[]=            {idmEditDocument,
                                         idmRot13,
                                         idmHTMLMode};
    int     i,
            idm;
    VARIANTARG  va;
    ULONG   u;

    hmenuMain = GetMenu(hwnd);
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_ID | MIIM_SUBMENU;
    GetMenuItemInfo(hmenuMain, uPos, TRUE, &mii);

    switch (mii.wID)
        {
        case idmPopupFile:
            EnableMenuItem(hmenuPopup, idmOpen, MF_BYCOMMAND|MF_ENABLED);
            EnableMenuItem(hmenuPopup, idmPrint, MF_BYCOMMAND|MF_ENABLED);
            EnableMenuItem(hmenuPopup, idmSaveAs, MF_BYCOMMAND|MF_ENABLED);
            break;

        case idmPopupEdit:
            if (m_pCmdTarget)
                {
                if (m_pCmdTarget->QueryStatus(NULL, sizeof(rgStdCmds)/sizeof(OLECMD), rgStdCmds, NULL)==S_OK)
                    for(i=0; i<sizeof(rgStdCmds)/sizeof(OLECMD); i++)
                        SetMenuItem(hmenuPopup, rgidsStd[i], rgStdCmds[i].cmdf & OLECMDF_ENABLED);

                if (m_pCmdTarget->QueryStatus(&CMDSETID_MimeEdit, sizeof(rgMimeEditCmds)/sizeof(OLECMD), rgMimeEditCmds, NULL)==S_OK)
                    for(i=0; i<sizeof(rgMimeEditCmds)/sizeof(OLECMD); i++)
                        {
                        SetMenuItem(hmenuPopup, rgidsMimeEdit[i], rgMimeEditCmds[i].cmdf & OLECMDF_ENABLED);
                        CheckMenuItem(hmenuPopup, rgidsMimeEdit[i], MF_BYCOMMAND|(rgMimeEditCmds[i].cmdf & OLECMDF_LATCHED ? MF_CHECKED: MF_UNCHECKED));
                        }                
                }
            break;

        case idmPopupView:
            u = MESTYLE_NOHEADER;
            if (m_pCmdTarget && 
                m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_STYLE, OLECMDEXECOPT_DODEFAULT, NULL, &va)==S_OK)
                u = va.lVal;
            
            switch(u)
                {
                case MESTYLE_NOHEADER:
                    idm = idmNoHeader;
                    break;
                case MESTYLE_MINIHEADER:
                    idm = idmMiniHeader;
                    break;
                case MESTYLE_PREVIEW:
                    idm = idmPreview;
                    break;
                case MESTYLE_FORMATBAR:
                    idm = idmFormatBar;
                    break;
                }
            CheckMenuRadioItem(hmenuPopup, idmNoHeader, idmFormatBar, idm, MF_BYCOMMAND|MF_ENABLED);
            SetMenuItem(hmenuPopup, idmNoHeader, TRUE);
            SetMenuItem(hmenuPopup, idmMiniHeader, TRUE);            
            SetMenuItem(hmenuPopup, idmPreview, TRUE);
            SetMenuItem(hmenuPopup, idmFormatBar, TRUE);
            break;

        case idmPopupTools:
            {
            OLECMD CmdSpell = {OLECMDID_SPELL, 0};

            SetMenuItem(hmenuPopup, idmFmtPreview, TRUE);
            if (m_pCmdTarget)
                m_pCmdTarget->QueryStatus(NULL, 1, &CmdSpell, NULL);

            SetMenuItem(hmenuPopup, idmSpelling, CmdSpell.cmdf & OLECMDF_ENABLED);
            }

            break;
        }
    return 0;
}



HRESULT CMeHost::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pCmdText)
{
    ULONG   uCmd;
    HRESULT hr;

    if (pguidCmdGroup &&
        IsEqualGUID(*pguidCmdGroup, CMDSETID_MimeEditHost))
        {
        for (uCmd=0; uCmd < cCmds; uCmd++)
            rgCmds[uCmd].cmdf = OLECMDF_SUPPORTED|OLECMDF_ENABLED;
        return S_OK;
        }

    hr = CDocHost::QueryStatus(pguidCmdGroup, cCmds, rgCmds, pCmdText);

    if (pguidCmdGroup==NULL)
        {
        for (uCmd=0; uCmd < cCmds; uCmd++)
            {
            switch(rgCmds[uCmd].cmdID)
                {
                case OLECMDID_PROPERTIES:
                    rgCmds[uCmd].cmdf = OLECMDF_SUPPORTED|OLECMDF_ENABLED;
                    break;
                }
            }
        }

    return hr;
}

        

HRESULT CMeHost::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn,	VARIANTARG *pvaOut)
{
    CHAR    rgch[MAX_PATH];
    WCHAR   rgchW[MAX_PATH];

    if (pguidCmdGroup &&
        IsEqualGUID(*pguidCmdGroup, CMDSETID_MimeEditHost))
        {
        switch (nCmdID)
            {
            case MEHOSTCMDID_BORDERFLAGS:
                if (pvaOut)
                    {
                    pvaOut->vt = VT_I4;
                    pvaOut->lVal = MEBF_OUTERCLIENTEDGE|MEBF_FORMATBARSEP;
                    return S_OK;
                    }
                else
                    return E_INVALIDARG;

            case MEHOSTCMDID_SIGNATURE:
                if (pvaOut)
                    {
                    MultiByteToWideChar(CP_ACP, 0, g_szSig, -1, rgchW, MAX_PATH);

                    pvaOut->vt = VT_BSTR;
                    pvaOut->bstrVal = SysAllocString(rgchW);
                    return S_OK;
                    }
                else
                    return E_INVALIDARG;

            case MEHOSTCMDID_SIGNATURE_OPTIONS:
                if (pvaOut)
                    {
                    pvaOut->vt = VT_I4;
                    pvaOut->lVal = MESIGOPT_TOP|(g_fSigHtml?MESIGOPT_HTML:MESIGOPT_PLAIN);
                    return S_OK;
                    }
                else
                    return E_INVALIDARG;

            case MEHOSTCMDID_SIGNATURE_ENABLED:
                if (pvaIn)
                    {
                    if (pvaIn->lVal == MESIG_AUTO && !g_fAutoSig)
                        return S_FALSE;
                    else
                        return S_OK;
                    }
                else
                    return E_INVALIDARG;

            case MEHOSTCMDID_REPLY_TICK_COLOR:
                if (pvaOut)
                    {
                    pvaOut->vt = VT_I4; 
                    pvaOut->lVal = RGB(255,0,0);
                    return S_OK;
                    }
                else
                    return E_INVALIDARG;

            case MEHOSTCMDID_HEADER_TYPE:
                if (pvaOut)
                    {
                    pvaOut->vt = VT_I4;
                    pvaOut->lVal = g_lHeaderType;
                    return S_OK;
                    }
                else
                    return E_INVALIDARG;

            case MEHOSTCMDID_QUOTE_CHAR:
                if (pvaOut)
                    {
                    pvaOut->vt = VT_I4; // apply quoteing to plain-text stream
                    pvaOut->lVal = g_fQuote?g_chQuote:NULL;
                    return S_OK;
                    }
                else
                    return E_INVALIDARG;

            case MEHOSTCMDID_SLIDESHOW_DELAY:
                if (pvaOut)
                    {
                    pvaOut->vt = VT_I4;
                    pvaOut->lVal = 5;
                    return S_OK;
                    }
                else
                    return E_INVALIDARG;

            case MEHOSTCMDID_COMPOSE_FONT:
                if (pvaOut && g_fComposeFont)
                    {
                    MultiByteToWideChar(CP_ACP, 0, g_szComposeFont, -1, rgchW, MAX_PATH);

                    pvaOut->vt = VT_BSTR;
                    pvaOut->bstrVal = SysAllocString(rgchW);
                    }

                return g_fComposeFont?S_OK:S_FALSE;

            case MEHOSTCMDID_FLAGS:
                if (pvaOut)
                    {
                    pvaOut->vt = VT_I4;
                    pvaOut->lVal = 0;
                    
                    if (g_fAutoSig)
                        pvaOut->lVal |= MEO_FLAGS_AUTOTEXT;

                    if (g_fHTML && m_fHTMLMode)
                        pvaOut->lVal |= MEO_FLAGS_HTML;

                    if (g_fAutoInline)
                        pvaOut->lVal |= MEO_FLAGS_AUTOINLINE;

                    if (g_fSlideShow)
                        pvaOut->lVal |= MEO_FLAGS_SLIDESHOW;

                    if (g_fIncludeMsg)
                        pvaOut->lVal |= MEO_FLAGS_INCLUDEMSG;

                    if (g_fSendImages)
                        pvaOut->lVal |= MEO_FLAGS_SENDIMAGES;

                    if (g_fBlockQuote)
                        pvaOut->lVal |= MEO_FLAGS_BLOCKQUOTE;

                    return S_OK;
                    }
                else
                    return E_INVALIDARG;

            case MEHOSTCMDID_ADD_TO_ADDRESSBOOK:
            case MEHOSTCMDID_ADD_TO_FAVORITES:
                if (pvaIn &&
                    pvaIn->vt == VT_BSTR &&
                    pvaIn->bstrVal != NULL)
                    {
                    WideCharToMultiByte(CP_ACP, 0, pvaIn->bstrVal, -1, rgch, MAX_PATH, NULL, NULL);                    
                    MessageBox(m_hwnd, rgch, nCmdID == MEHOSTCMDID_ADD_TO_FAVORITES ? 
                                        "CMeHost - AddToFavorites" :
                                        "CMeHost - AddToAddressBook", MB_OK);
                    return S_OK;
                    }
                else
                    return E_INVALIDARG;

            }
            return OLECMDERR_E_NOTSUPPORTED;
        }

    if (pguidCmdGroup==NULL)
        {
        switch (nCmdID)
            {
            case OLECMDID_PROPERTIES:
                MessageBox(m_hwnd, "This is a place holder for the note properties dialog", "MePad", MB_OK);
                return S_OK;
            }
        }

    return CDocHost::Exec(pguidCmdGroup, nCmdID, nCmdExecOpt, pvaIn, pvaOut);
}


INT_PTR CALLBACK MhtmlDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD   dwFlags;

    switch (msg)
        {
        case WM_INITDIALOG:
            CheckDlgButton(hwnd, idcHTML, BST_CHECKED);
            CheckDlgButton(hwnd, idcPlain, BST_CHECKED);
            CheckDlgButton(hwnd, idcImages, BST_CHECKED);
            CheckDlgButton(hwnd, idcFiles, BST_CHECKED);

            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
                {
                case IDOK:
                    dwFlags = 0;

                    if (IsDlgButtonChecked(hwnd, idcImages))
                        dwFlags |= MECD_ENCODEIMAGES;

                    if (IsDlgButtonChecked(hwnd, idcPlain))
                        dwFlags |= MECD_PLAINTEXT;

                    if (IsDlgButtonChecked(hwnd, idcHTML))
                        dwFlags |= MECD_HTML;

                    if (IsDlgButtonChecked(hwnd, idcFiles))
                        dwFlags |= MECD_ENCODEFILEURLSONLY;

                    EndDialog(hwnd, dwFlags);
                    return TRUE;

                case IDCANCEL:
                    EndDialog(hwnd, -1);
                    return TRUE;
                }
            break;
        }


    return FALSE;
}


INT_PTR CALLBACK CMeHost::ExtFmtDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CMeHost *pHost=(CMeHost *)GetWindowLong(hwnd, DWL_USER);

    if (msg==WM_INITDIALOG)
        {
        pHost = (CMeHost *)lParam;
        SetWindowLong(hwnd, DWL_USER, lParam);
        }

    return pHost?pHost->FmtDlgProc(hwnd, msg, wParam, lParam):FALSE;
}


INT_PTR CALLBACK CMeHost::FmtDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    WCHAR       rgchW[MAX_PATH];
    VARIANTARG  va;
    
    switch (msg)
        {
        case WM_COMMAND:
            switch (LOWORD(wParam))
                {
                case IDOK:
                    GetWindowText(GetDlgItem(hwnd, idcEdit), m_szFmt, sizeof(m_szFmt));
                    MultiByteToWideChar(CP_ACP, 0, m_szFmt, -1, rgchW, MAX_PATH);
                    if (m_pCmdTarget)
                        {
                        va.vt = VT_BSTR;
                        va.bstrVal = (BSTR)rgchW;
                        m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_PREVIEWFORMAT, OLECMDEXECOPT_DODEFAULT, &va, NULL);
                        }

                    // fall tro'
                case IDCANCEL:
                    EndDialog(hwnd, LOWORD(wParam));
                    return TRUE;
                }
            break;

        case WM_INITDIALOG:
            SetWindowText(GetDlgItem(hwnd, idcEdit), m_szFmt);
            SetFocus(GetDlgItem(hwnd, idcEdit));
            break;
        }

    return FALSE;
}


UINT uCodePageFromCharset(IMimeInternational *pIntl, HCHARSET hCharset)
{
    INETCSETINFO    CsetInfo;
    UINT            uiCodePage = GetACP();

    if (hCharset && 
        (pIntl->GetCharsetInfo(hCharset, &CsetInfo)==S_OK))
        uiCodePage = CsetInfo.cpiWindows ;

    return uiCodePage;
}


INT_PTR CALLBACK CMeHost::ExtLangDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CMeHost *pHost=(CMeHost *)GetWindowLong(hwnd, DWL_USER);

    if (msg==WM_INITDIALOG)
        {
        pHost = (CMeHost *)lParam;
        SetWindowLong(hwnd, DWL_USER, lParam);
        }

    return pHost?pHost->LangDlgProc(hwnd, msg, wParam, lParam):FALSE;
}


INT_PTR CALLBACK CMeHost::LangDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    VARIANTARG  va;
    HKEY        hk=0,
                hkSub;
    LONG        cb;
    DWORD       n=0,
                l,
                dwCodePage,
                dwType;
    TCHAR       rgch[MAX_PATH];
    HWND        hwndCombo = GetDlgItem(hwnd, idcLang);
    HCHARSET    hCharset;
    HRESULT     hr;

    switch (msg)
        {
        case WM_COMMAND:
            switch (LOWORD(wParam))
                {
                case IDOK:
                    l = SendMessage(hwndCombo, CB_GETCURSEL, 0 ,0);
                    dwCodePage = SendMessage(hwndCombo, CB_GETITEMDATA, l, 0);
                    m_pIntl->GetCodePageCharset(dwCodePage, CHARSET_BODY, &hCharset);
                    if (m_pCmdTarget)
                        {
                        va.vt = VT_I4;
                        va.lVal = (LONG)hCharset;
                        if (FAILED(hr=m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_CHARSET, OLECMDEXECOPT_DODEFAULT, &va, NULL)))
                            {
                            wsprintf(rgch, "Could not switch language hr=0x%x", hr);
                            MessageBox(m_hwnd, rgch, "MePad", MB_OK);
                            }
                        }

                    // fall tro'
                case IDCANCEL:
                    EndDialog(hwnd, LOWORD(wParam));
                    return TRUE;
                }
            break;

        case WM_INITDIALOG:
            if (RegOpenKey(HKEY_CLASSES_ROOT, "MIME\\Database\\Codepage", &hk)==ERROR_SUCCESS)
                {            
                while (RegEnumKey(hk, n++, rgch, MAX_PATH)==ERROR_SUCCESS)
                    {
                    dwCodePage = atoi(rgch);

                    if (RegOpenKey(hk, rgch, &hkSub)==ERROR_SUCCESS)
                        {
                        cb = MAX_PATH;
                        if (RegQueryValueEx(hkSub, "Description", 0, &dwType, (LPBYTE)rgch, (ULONG *)&cb)==ERROR_SUCCESS)
                            {
                            l = SendMessage(hwndCombo, CB_ADDSTRING, NULL, (LPARAM)rgch);
                            if (l>=0)
                                SendMessage(hwndCombo, CB_SETITEMDATA, l, dwCodePage);

                            }
                        CloseHandle(hkSub);
                        }
                    }
                CloseHandle(hk);
                }; 

            if (m_pCmdTarget)
                {
                m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_CHARSET, OLECMDEXECOPT_DODEFAULT, NULL, &va);
                dwCodePage = uCodePageFromCharset(m_pIntl, (HCHARSET)va.lVal);
                }
            else
                dwCodePage = 0;

            l = SendMessage(hwndCombo, CB_GETCOUNT, NULL, NULL);
            for (n=0; n<l; n++)
                {
                if ((DWORD)SendMessage(hwndCombo, CB_GETITEMDATA, n, NULL)==dwCodePage)
                    {
                    SendMessage(hwndCombo, CB_SETCURSEL, n, NULL);
                    break;
                    }
                }
            
            SetFocus(hwndCombo);
            return TRUE;
        }

    return FALSE;
}



LRESULT CMeHost::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    VARIANTARG          va;
    int                 id;
    BOOL                fDirty=FALSE;
    IOleDocumentView    *pDocView;

    switch (msg)
        {
        case WM_NCACTIVATE:
            if (m_lpOleObj && 
                m_lpOleObj->QueryInterface(IID_IOleDocumentView, (LPVOID *)&pDocView)==S_OK)
                {
                pDocView->UIActivate(LOWORD(wParam));
                pDocView->Release();
                }
            break;

        case WM_CLOSE:
            if (m_pCmdTarget && 
                m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_DIRTY, 0, 0, &va)==S_OK &&
                va.vt == VT_BOOL)
                fDirty = va.boolVal == VARIANT_TRUE;
            
            if (fDirty)
                {
                id = MessageBox(m_hwnd, "This message has been modified. Do you want to save the changes?", 
                                        "MimeEdit Host", MB_YESNOCANCEL);
                if (id==IDCANCEL)
                    return 0;
                
                if (id==IDYES)
                    {
                    if (Save()==MIMEEDIT_E_USERCANCEL)
                        return 0;
                    }

                }
            break;
        }

    return CDocHost::WndProc(hwnd, msg, wParam, lParam);
}





HRESULT CMeHost::Save()
{
    if (*m_szFileW==NULL)
        return SaveAs();

    return SaveToFile(m_szFileW);
}

HRESULT CMeHost::SaveAs()
{
    OPENFILENAME    ofn;
    TCHAR           szFile[MAX_PATH];
    TCHAR           szTitle[MAX_PATH];
    TCHAR           szDefExt[30];

    if (!m_lpOleObj)
        return E_FAIL;

    lstrcpy(szFile, "c:\\*.eml");
    lstrcpy(szDefExt, ".eml");
    lstrcpy(szTitle, "Save Message As...");
    ZeroMemory (&ofn, sizeof (ofn));
    ofn.lStructSize = sizeof (ofn);
    ofn.hwndOwner = m_hwnd;
    ofn.lpstrFilter = c_szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = sizeof (szFile);
    ofn.lpstrTitle = szTitle;
    ofn.lpstrDefExt = szDefExt;
    ofn.Flags = OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT;

    if (*szFile==NULL)
        return E_FAIL;
    

    // Show OpenFile Dialog
    if (!GetSaveFileName(&ofn))
        return MIMEEDIT_E_USERCANCEL;
 
    MultiByteToWideChar(CP_ACP, 0, szFile, -1, m_szFileW, MAX_PATH);

    SetWindowText(m_hwnd, szFile);
    return SaveToFile(m_szFileW);
}

HRESULT CMeHost::SaveAsMhtmlTest()
{
    IMimeMessage        *pMsg;
    IHTMLDocument2      *pDoc;
    IServiceProvider    *pSP;
    DWORD               dwFlags;
            
    if (m_lpOleObj->QueryInterface(IID_IServiceProvider, (LPVOID *)&pSP)==S_OK)
        {
        if (pSP->QueryService(IID_IHTMLDocument2, IID_IHTMLDocument2, (LPVOID *)&pDoc)==S_OK)
            {
            dwFlags = DialogBox(g_hInst, MAKEINTRESOURCE(iddSaveAsMHTML), m_hwnd, MhtmlDlgProc);
            if (dwFlags != -1)
                {
                if (!FAILED(MimeEditCreateMimeDocument(pDoc, m_pMsg, dwFlags, &pMsg)))
                    {
                    SetEncodingOptions(pMsg, GetCharset());
                    pMsg->Commit(0);
                    MimeEditViewSource(m_hwnd, pMsg);
                    pMsg->Release();
                    }
                }
            pDoc->Release();
            }
        pSP->Release();
        }
    return S_OK;
}

HRESULT CMeHost::SaveToFile(LPWSTR pszW)
{
    IPersistMime        *ppm;
    IPersistFile        *pPF;
    IMimeMessage        *pMsg;
    HRESULT             hr;

    hr = m_lpOleObj->QueryInterface(IID_IPersistMime, (LPVOID *)&ppm);
    if (!FAILED(hr))
        {
        hr = CoCreateInstance(CLSID_IMimeMessage, NULL, CLSCTX_INPROC_SERVER, IID_IMimeMessage, (LPVOID *)&pMsg);
        if (!FAILED(hr))
            {
            pMsg->InitNew();

            hr = pMsg->QueryInterface(IID_IPersistFile, (LPVOID *)&pPF);
            if (!FAILED(hr))
                {
                hr = ppm->Save(pMsg, PMS_TEXT|PMS_HTML);
                if (!FAILED(hr))
                    {
                    SetEncodingOptions(pMsg, GetCharset());
                    hr = pPF->Save(pszW, FALSE);
                    }
                pPF->Release();
                }
            pMsg->Release();
            }
        ppm->Release();
        }

    return hr;
}

HCHARSET CMeHost::GetCharset()
{
    VARIANTARG  va;
    HCHARSET    hCharset=0;

    if (m_pCmdTarget && 
        m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_CHARSET, OLECMDEXECOPT_DODEFAULT, NULL, &va)==S_OK)
        hCharset = (HCHARSET)va.lVal;

    // if no charset has been set yet, let's use system codepage
    if (hCharset==NULL)
        m_pIntl->GetCodePageCharset(GetACP(), CHARSET_BODY, &hCharset);

    return hCharset;
}

HRESULT SetEncodingOptions(IMimeMessage *pMsg, HCHARSET hCharset)
{
    PROPVARIANT     rVariant;

    // Save Format
    rVariant.vt = VT_UI4;
    rVariant.ulVal = (ULONG)SAVE_RFC1521;
    pMsg->SetOption(OID_SAVE_FORMAT, &rVariant);

    // Text body encoding
    rVariant.ulVal = (ULONG)IET_QP;
    pMsg->SetOption(OID_TRANSMIT_TEXT_ENCODING, &rVariant);

    // Plain Text body encoding
    rVariant.ulVal = (ULONG)IET_QP;
    pMsg->SetOption(OID_XMIT_PLAIN_TEXT_ENCODING, &rVariant);

    // HTML Text body encoding
    rVariant.ulVal = (ULONG)IET_QP;
    pMsg->SetOption(OID_XMIT_HTML_TEXT_ENCODING, &rVariant);

    pMsg->SetCharset(hCharset, CSET_APPLY_ALL);
    return S_OK;
}



HRESULT IPersistMimeLoad(IUnknown *pUnk, IMimeMessage *pMsg)
{
    IPersistMime    *pPM;
    HRESULT         hr;

    hr = pUnk->QueryInterface(IID_IPersistMime, (LPVOID *)&pPM);
    if (!FAILED(hr))
        {
        hr = pPM->Load(pMsg);
        pPM->Release();
        }
    return hr;
}


HRESULT CMeHost::BackRed()
{
    IServiceProvider    *pSP;
    IHTMLDocument2      *pDoc;
    IHTMLElement        *pElem;
    IHTMLBodyElement    *pBody;
    VARIANTARG          v;    

    if (m_lpOleObj->QueryInterface(IID_IServiceProvider, (LPVOID *)&pSP)==S_OK)
        {
        if (pSP->QueryService(IID_IHTMLDocument2, IID_IHTMLDocument2, (LPVOID *)&pDoc)==S_OK)
            {
            pElem=0;
            pDoc->get_body(&pElem);
            if (pElem)
                {
                if (pElem->QueryInterface(IID_IHTMLBodyElement, (LPVOID *)&pBody)==S_OK)
                    {
                    v.vt = VT_BSTR;
                    v.bstrVal = SysAllocString(L"#FF0000");
                    if (v.bstrVal)
                        {
                        pBody->put_bgColor(v);
                        SysFreeString(v.bstrVal);
                        }
                    pBody->Release();
                    }
                pElem->Release();
                }
            pDoc->Release();
            }
        pSP->Release();
        }
    return S_OK;
    
}

HRESULT CMeHost::ForeRed()
{
    IServiceProvider        *pSP;
    IHTMLDocument2          *pDoc;
    IHTMLSelectionObject    *pSel=0;
    IOleCommandTarget       *pCmdTarget;
    IDispatch               *pID;

    if (m_lpOleObj->QueryInterface(IID_IServiceProvider, (LPVOID *)&pSP)==S_OK)
        {
        if (pSP->QueryService(IID_IHTMLDocument2, IID_IHTMLDocument2, (LPVOID *)&pDoc)==S_OK)
            {
            pDoc->get_selection(&pSel);
            if (pSel)
                {
                pSel->createRange(&pID);
                if (pID)
                    {
                    if (pID->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&pCmdTarget)==S_OK)
                        {
                        VARIANTARG  v;
                        v.vt = VT_BSTR;
                        v.bstrVal = SysAllocString(L"#FF0000");
                        if (v.bstrVal)
                            {
                            pCmdTarget->Exec(&CMDSETID_Forms3, IDM_BACKCOLOR, NULL, &v, NULL);
                            SysFreeString(v.bstrVal);
                            }
                        }
                    pID->Release();
                    }
                pSel->Release();
                }
            pDoc->Release();
            }
        pSP->Release();
        }
    return S_OK;
}


HRESULT CMeHost::SaveAsStationery()
{
    VARIANTARG  vaIn,
                vaOut;
    char        rgch[MAX_PATH],
                rgch2[MAX_PATH+50];
                

    vaIn.vt = VT_BSTR;
    vaIn.bstrVal = SysAllocString(L"C:\\PROGRAM FILES\\COMMON FILES\\MICROSOFT SHARED\\STATIONERY");
    if (vaIn.bstrVal)
        {
        if (m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_SAVEASSTATIONERY, NULL, &vaIn, &vaOut)==S_OK)
            {
            if (WideCharToMultiByte(CP_ACP, 0, vaOut.bstrVal, SysStringLen(vaOut.bstrVal), rgch, MAX_PATH, NULL, NULL))
                {
                wsprintf(rgch2, "Stationery saved to %s", rgch);
                MessageBox(m_hwnd, rgch, "SaveAsStationery", MB_OK);
                }
            SysFreeString(vaOut.bstrVal);
            }
        SysFreeString(vaIn.bstrVal);
        }
    return S_OK;
}

HRESULT CMeHost::BackgroundPicture()
{
    VARIANT va;
    char    szUrl[MAX_PATH];
    WCHAR   szUrlW[MAX_PATH];
    BSTR    bstr;

    *szUrl=0;

    if (m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_BACKGROUNDIMAGE, NULL, NULL, &va)==S_OK)
        WideCharToMultiByte(CP_ACP, 0, va.bstrVal, -1, szUrl, MAX_PATH, NULL, NULL);

    if (GenericPrompt(m_hwnd, "Edit Background Picture...", "Choose a picture", szUrl, MAX_PATH)==S_OK)
        {
        if (MultiByteToWideChar(CP_ACP, 0, szUrl, -1, szUrlW, MAX_PATH) &&
            (bstr = SysAllocString(szUrlW)))
            {
            va.vt = VT_BSTR;
            va.bstrVal = bstr;
            m_pCmdTarget->Exec(&CMDSETID_MimeEdit, MECMDID_BACKGROUNDIMAGE, NULL, &va, NULL);
            SysFreeString(bstr);
            }
        }
    return S_OK;
}

HRESULT CMeHost::HrLoadFile(LPSTR pszFile)
{
    IPersistFile    *pPF;
    IMimeMessage    *pMsg;

    if (!m_lpOleObj)
        return E_FAIL;

    if (pszFile == NULL || *pszFile==NULL)
        return E_FAIL;
    
    MultiByteToWideChar(CP_ACP, 0, pszFile, -1, m_szFileW, MAX_PATH);

    if (CoCreateInstance(CLSID_IMimeMessage, NULL, CLSCTX_INPROC_SERVER, IID_IMimeMessage, (LPVOID *)&pMsg)==S_OK)
        {
        if (pMsg->QueryInterface(IID_IPersistFile, (LPVOID *)&pPF)==S_OK)
            {
            if (pPF->Load(m_szFileW, 0)==S_OK)
                {
                if (IPersistMimeLoad(m_lpOleObj, pMsg)==S_OK)
                    {
                    SetWindowText(m_hwnd, pszFile);
                    ReplaceInterface(m_pMsg, pMsg);
                    }
                }
            pPF->Release();
            } 
        pMsg->Release();
        }            
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mepad\pch.cpp ===
#include "pch.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\attrun.h ===
#define IDC_SAFEOPEN_ALWAYS             1001
#define IDC_SAFEOPEN_ICON               1002
#define IDC_SAFEOPEN_EXPL               1003
#define IDC_SAFEOPEN_AUTOOPEN           1004
#define IDC_SAFEOPEN_AUTOSAVE           1005
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mepad\util.h ===
#ifndef _UTIL_H
#define _UTIL_H

#include <commctrl.h>

#define ReleaseObj(_object) (_object) ? (_object)->Release() : 0

void ProcessTooltips(LPTOOLTIPTEXT lpttt);
UINT TTIdFromCmdId(UINT idCmd);
void HandleMenuSelect(HWND hStatus, WPARAM wParam, LPARAM lParam);
HRESULT GenericPrompt(HWND hwnd, char *szCaption, char *szPrompt, char *szBuffer, int nLen);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mepad\resource.h ===
#ifndef _RESOURCE_H
#define _RESOURCE_H

#define idiApp                          4
// bitmaps
#define idbToolbar                      9
//menu help
#define MH_BASE                         1

// menu commands
#define IDM_FIRST                       100

#define idmPopupFile                    (IDM_FIRST + 0)  
#define idmNew                          (IDM_FIRST + 1)  
#define idmOpen                         (IDM_FIRST + 2)  
#define idmSave                         (IDM_FIRST + 3)  
#define idmSaveAs                       (IDM_FIRST + 4)  
#define idmPageSetup                    (IDM_FIRST + 5)  
#define idmPrint                        (IDM_FIRST + 6)  
#define idmClose                        (IDM_FIRST + 7)  
#define idmPopupGo                      (IDM_FIRST + 8)  
#define idmBack                         (IDM_FIRST + 9)  
#define idmForward                      (IDM_FIRST + 10)  
#define idmPopupHelp                    (IDM_FIRST + 12)  
#define idmAbout                        (IDM_FIRST + 13)  
#define idmToggleToolbar                (IDM_FIRST + 14)  
#define idmToggleStatusbar              (IDM_FIRST + 15)  
#define idmPopupView                    (IDM_FIRST + 16)
#define idmCascade                      (IDM_FIRST + 17)
#define idmTile                         (IDM_FIRST + 18)
#define idmUndo                         (IDM_FIRST + 19)
#define idmRedo                         (IDM_FIRST + 20)
#define idmCut                          (IDM_FIRST + 21)
#define idmCopy                         (IDM_FIRST + 22)
#define idmPaste                        (IDM_FIRST + 23)
#define idmEditDocument                 (IDM_FIRST + 24)
#define idmSelectAll                    (IDM_FIRST + 25)
#define idmPopupEdit                    (IDM_FIRST + 26)
#define idmPopupWindow                  (IDM_FIRST + 27)
#define idmFind                         (IDM_FIRST + 28)
#define idmViewSource                   (IDM_FIRST + 29)
#define idmViewMsgSource                (IDM_FIRST + 30)
#define idmRot13                        (IDM_FIRST + 31)
#define idmNoHeader                     (IDM_FIRST + 35)
#define idmPreview                      (IDM_FIRST + 36)
#define idmMiniHeader                   (IDM_FIRST + 37)
#define idmFormatBar                    (IDM_FIRST + 38)
#define idmPopupTools                   (IDM_FIRST + 39)
#define idmFmtPreview                   (IDM_FIRST + 40)
#define idmLang                         (IDM_FIRST + 41)
#define idmSpelling                     (IDM_FIRST + 42)
#define idmOptions                      (IDM_FIRST + 43)
#define idmSaveAsMHTML                  (IDM_FIRST + 44)
#define idmHTMLMode                     (IDM_FIRST + 45)
#define idmSetText                      (IDM_FIRST + 46)
#define idmFont                         (IDM_FIRST + 47)
#define idmPara                         (IDM_FIRST + 48)
#define idmInsertFile                   (IDM_FIRST + 49)
#define idmTestBackRed                  (IDM_FIRST + 50)
#define idmTestForeRed                  (IDM_FIRST + 51)
#define idmSaveAsStationery             (IDM_FIRST + 52)
#define idmBackground                   (IDM_FIRST + 53)

#define IDM_LAST                        (IDM_FIRST + 2000)


// TOOLTIP strings
#define TT_BASE                         (IDM_LAST + MH_BASE + 1)

// menus
#define idmrMainMenu                    8

// accels
#define idacMeHost                      10

// dialog ID's
#define iddFmt                          100
#define iddLang                         101
#define iddOptions                      102
#define iddSaveAsMHTML                  103
#define iddGeneric                      104

// controls
#define idcEdit                         10
#define idcLang                         11

#define idcAuto                         21
#define idcSlide                        22
#define idcQuote                        23
#define ideQuote                        24
#define idcHTML                         25
#define idcInclude                      26
#define idcSendImages                   27
#define idcImages                       28
#define idcPlain                        29
#define idcHtml                         30
#define idcComposeFont                  31
#define ideComposeFont                  32
#define idrbNone                        40
#define idrbMail                        41
#define idrbNews                        42
#define idrbPrint                       43
#define idcBlockQuote                   50
#define idcSigHtml                      51
#define idcSig                          52
#define ideSig                          53
#define idcFiles                        54
    
#endif  // _RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\basemht.h ===
/*
 *    b a s e m h t . c p p 
 *    
 *    Purpose:
 *        Base classes for MHTML packer objects
 *
 *  History
 *      October 1998: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _BASEMHT_H_
#define _BASEMHT_H_


class CBaseTag :
    public IMimeEditTag
{
public:

    CBaseTag();
    virtual ~CBaseTag();

    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);

    virtual HRESULT STDMETHODCALLTYPE GetSrc(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE SetSrc(BSTR bstr);

    virtual HRESULT STDMETHODCALLTYPE GetDest(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE SetDest(BSTR bstr);

    virtual HRESULT STDMETHODCALLTYPE OnPreSave();
    virtual HRESULT STDMETHODCALLTYPE OnPostSave();

    virtual HRESULT STDMETHODCALLTYPE CanPackage();
    virtual HRESULT STDMETHODCALLTYPE IsValidMimeType(LPWSTR pszTypeW);

    
    virtual HRESULT Init(IHTMLElement *pElem);

protected:
    ULONG           m_cRef;
    IHTMLElement    *m_pElem;
    BSTR            m_bstrDest,
                    m_bstrSrc;
};

 
class CBaseTagCollection :
    public IMimeEditTagCollection
{
public:

    CBaseTagCollection();
    virtual ~CBaseTagCollection();

    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);

    virtual HRESULT STDMETHODCALLTYPE Init(IUnknown *pUnk);
    virtual HRESULT STDMETHODCALLTYPE Next(ULONG cFetch, IMimeEditTag **ppTag, ULONG *pcFetched);
    virtual HRESULT STDMETHODCALLTYPE Reset();
    virtual HRESULT STDMETHODCALLTYPE Count(ULONG *pcItems);

protected:
    ULONG           m_cRef,
                    m_cTags,
                    m_uEnum;
    IMimeEditTag    **m_rgpTags;
    
    
    virtual HRESULT _BuildCollection(IHTMLDocument2 *pDoc) PURE;
    virtual HRESULT _FreeCollection();
};





#endif //_BASEMHT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mepad\util.cpp ===
#include "pch.hxx"
#include "globals.h"
#include "resource.h"
#include "util.h"
#include "mimeole.h"

INT_PTR CALLBACK GenericDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

void ProcessTooltips(LPTOOLTIPTEXT lpttt)
{
    if (lpttt->lpszText = MAKEINTRESOURCE(TTIdFromCmdId(lpttt->hdr.idFrom)))
        lpttt->hinst = g_hInst;
    else
        lpttt->hinst = NULL;
}


UINT TTIdFromCmdId(UINT idCmd)
{
    if (idCmd >= IDM_FIRST && idCmd <= IDM_LAST)
        idCmd += TT_BASE;
    else
        idCmd = 0;
    return(idCmd);
}


void HandleMenuSelect(HWND hStatus, WPARAM wParam, LPARAM lParam)
{
    UINT    fuFlags, uItem;
    HMENU   hmenu=GET_WM_MENUSELECT_HMENU(wParam, lParam);
    CHAR    rgch[MAX_PATH]={0};
    LPSTR   psz=NULL;
    
    if (!hStatus)
        return;

    uItem = (UINT)LOWORD(wParam);
    fuFlags = (UINT)HIWORD(wParam);

    if(fuFlags & MF_POPUP)
    {
        MENUITEMINFO mii = { sizeof(MENUITEMINFO), MIIM_ID, 0 };
        if(hmenu && IsMenu(hmenu) && GetMenuItemInfo(hmenu, uItem, TRUE, &mii))
        {
            // change the parameters to simulate a normal menu item
            uItem = mii.wID;
            fuFlags = 0;
        }
    }         

    if(0 == (fuFlags & (MF_SYSMENU | MF_POPUP)))
    {
        if(uItem >= IDM_FIRST && uItem <= IDM_LAST)
        {
            uItem = uItem + MH_BASE;
            LoadString(g_hInst, (UINT)MAKEINTRESOURCE(uItem), rgch, sizeof(rgch));
            psz = rgch; 
        }
    }

    SendMessage(hStatus, SB_SETTEXT, SBT_NOBORDERS|255, (LPARAM)psz);

}


typedef struct GPINFO_tag
{
    char    *szCaption;
    char    *szPrompt;
    char    *szBuffer;
    int     nLen;
} GPINFO, *PGPINFO;

HRESULT GenericPrompt(HWND hwnd, char *szCaption, char *szPrompt, char *szBuffer, int nLen)
{
    GPINFO  rGInfo;

    rGInfo.szCaption = szCaption;
    rGInfo.szPrompt = szPrompt;
    rGInfo.szBuffer= szBuffer;
    rGInfo.nLen = nLen;

    if (DialogBoxParam(g_hInst, MAKEINTRESOURCE(iddGeneric), hwnd, GenericDlgProc, (LPARAM)&rGInfo)==IDOK)
        return S_OK;
    else
        return MIMEEDIT_E_USERCANCEL;
}


BOOL CALLBACK GenericDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    PGPINFO pGInfo;

    switch (msg)
        {
        case WM_COMMAND:
            pGInfo = (PGPINFO)GetWindowLong(hwnd, DWL_USER);

            switch (LOWORD(wParam))
                {
                case IDOK:
                    GetWindowText(GetDlgItem(hwnd, idcEdit), pGInfo->szBuffer, pGInfo->nLen);

                    // fall tro'
                case IDCANCEL:
                    EndDialog(hwnd, LOWORD(wParam));
                    return TRUE;
                }
            break;

        case WM_INITDIALOG:
            SetWindowLong(hwnd, DWL_USER, lParam);
            pGInfo = (PGPINFO)lParam;
            
            SetWindowText(GetDlgItem(hwnd, -1), pGInfo->szPrompt);
            SetWindowText(hwnd, pGInfo->szCaption);
            SetWindowText(GetDlgItem(hwnd, idcEdit), pGInfo->szBuffer);
            break;
        }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\basemht.cpp ===
/*
 *    b a s e m h t . c p p 
 *    
 *    Purpose:
 *        Base classes for MHTML packer objects
 *
 *  History
 *      October 1998: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */
#include <pch.hxx>
#include "mhtml.h"
#include "basemht.h"

ASSERTDATA

/*
 *  m a c r o s
 */

/*
 *  c o n s t a n t s
 */

/*
 *  t y p e d e f s
 */

 
/* 
 *   F u n c t i o n s
 */


CBaseTag::CBaseTag()
{
    m_cRef = 1;
    m_pElem = NULL;
    m_bstrDest = NULL;
    m_bstrSrc = NULL;
}


CBaseTag::~CBaseTag()
{
    ReleaseObj(m_pElem);
    SysFreeString(m_bstrDest);
    SysFreeString(m_bstrSrc);

}

ULONG CBaseTag::AddRef()
{
    return ++m_cRef;
}

ULONG CBaseTag::Release()
{
    if (--m_cRef==0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}

HRESULT CBaseTag::QueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return TraceResult(E_INVALIDARG);

    *lplpObj = NULL;   // set to NULL, in case we fail.

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IUnknown *)this;
    else if (IsEqualIID(riid, IID_IMimeEditTag))
        *lplpObj = (LPVOID)(IMimeEditTag *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

HRESULT CBaseTag::Init(IHTMLElement *pElem)
{
    if (pElem == NULL)
        return TraceResult(E_INVALIDARG);

    ReplaceInterface(m_pElem, pElem);
    return S_OK;
}

HRESULT CBaseTag::GetSrc(BSTR *pbstr)
{
    if (pbstr == NULL)
        return TraceResult(E_INVALIDARG);

    *pbstr = SysAllocString(m_bstrSrc);
    return *pbstr ? S_OK : E_FAIL;
}

HRESULT CBaseTag::SetSrc(BSTR bstr)
{
    return E_NOTIMPL;
}

HRESULT CBaseTag::GetDest(BSTR *pbstr)
{
    if (pbstr == NULL)
        return TraceResult(E_INVALIDARG);

    *pbstr = SysAllocString(m_bstrDest);
    return *pbstr ? S_OK : E_FAIL;
}

HRESULT CBaseTag::SetDest(BSTR bstr)
{
    SysFreeString(m_bstrDest);
    m_bstrDest = SysAllocString(bstr);
    return S_OK;
}

HRESULT CBaseTag::OnPreSave()
{
    return S_OK;
}

HRESULT CBaseTag::OnPostSave()
{
    return S_OK;
}


HRESULT CBaseTag::CanPackage()
{
    return S_OK;
}

HRESULT CBaseTag::IsValidMimeType(LPWSTR pszTypeW)
{
    return S_OK;
}

    
    
CBaseTagCollection::CBaseTagCollection()
{
    m_cRef = 1;
    m_rgpTags = NULL;
    m_cTags = 0;
    m_uEnum = 0;
}


CBaseTagCollection::~CBaseTagCollection()
{
    _FreeCollection();
}

ULONG CBaseTagCollection::AddRef()
{
    return ++m_cRef;
}

ULONG CBaseTagCollection::Release()
{
    if (--m_cRef==0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}

HRESULT CBaseTagCollection::QueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return TraceResult(E_INVALIDARG);

    *lplpObj = NULL;   // set to NULL, in case we fail.

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (LPVOID)(IUnknown *)this;
    else if (IsEqualIID(riid, IID_IMimeEditTagCollection))
        *lplpObj = (LPVOID)(IMimeEditTagCollection *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}

HRESULT CBaseTagCollection::Init(IUnknown *pDocUnk)
{
    IHTMLDocument2  *pDoc=0;
    HRESULT         hr;

    if (pDocUnk == NULL)
        return E_INVALIDARG;

    hr = pDocUnk->QueryInterface(IID_IHTMLDocument2, (LPVOID *)&pDoc);
    if (FAILED(hr))
        goto error;
    
    hr = _BuildCollection(pDoc);
    if (FAILED(hr))
        goto error;

error:
    ReleaseObj(pDoc);
    return hr;
}

HRESULT CBaseTagCollection::Next(ULONG cWanted, IMimeEditTag **prgpTag, ULONG *pcFetched)
{
    HRESULT     hr=S_OK;
    ULONG       cFetch,
                uTag;

    if (pcFetched)
        *pcFetched = 0;

    // nothing to give back
    if (m_cTags == 0)
        goto exit;

    // Compute number to fetch
    cFetch = min(cWanted, m_cTags - m_uEnum);
    if (0 == cFetch)
        goto exit;

    // Copy cWanted
    for (uTag=0; uTag<cFetch; uTag++)
    {
        prgpTag[uTag] = m_rgpTags[m_uEnum++];
        if (prgpTag[uTag])
            prgpTag[uTag]->AddRef();
    }

    // Return fetced ?
    if (pcFetched)
        *pcFetched = cFetch;

exit:
    return hr;
}

HRESULT CBaseTagCollection::Reset()
{
    m_uEnum = 0;
    return S_OK;
}

HRESULT CBaseTagCollection::Count(ULONG *pcItems)
{
    if (pcItems == NULL)
        return TraceResult(E_INVALIDARG);

    *pcItems = m_cTags;
    return S_OK;
}

HRESULT CBaseTagCollection::_FreeCollection()
{
    ULONG   uImages;

    if (m_rgpTags)
    {
        for (uImages = 0; uImages < m_cTags; uImages++)
            ReleaseObj(m_rgpTags[uImages]);

        MemFree(m_rgpTags);
        m_rgpTags = 0;
        m_cTags = 0;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\body.h ===
#ifndef _BODY_H
#define _BODY_H

/*
 * includes
 */

#include "dochost.h"

/*
 * forward references
 */
interface IHTMLTxtRange;
interface IHTMLElement;
interface IHTMLDocument2;
interface IMoniker;
interface IHTMLBodyElement;
interface IDocHostUIHandler;
interface ITargetFrame2;
interface ITargetFramePriv;

class CBody;
class CFmtBar;
class CAttMenu;
class CSecManager;
class CMsgSource;
class CSpell;

/*
 * constants
 */

enum
{
    BI_MESSAGE,
    BI_MONIKER 
};

/*
 * typedefs
 */
typedef struct BODYINITDATA_tag
{
    DWORD   dwType;
    union
        {
        IMimeMessage    *pMsg;
        IMoniker        *pmk;
        };
}   BODYINITDATA, * LPBODYINITDATA;

typedef CBody *LPBODYOBJ;

typedef struct BODYHOSTINFO_tag
{
    IOleInPlaceSite         *pInPlaceSite;
    IOleInPlaceFrame        *pInPlaceFrame;
    IOleInPlaceActiveObject *pDoc;
} BODYHOSTINFO, *PBODYHOSTINFO;

/*
 * objects
 */

class CBody :
    public CDocHost,
    public IPropertyNotifySink,
    public IDocHostUIHandler,
    public IPersistMime,
    public ITargetFramePriv,
    public IPersistMoniker,
    public IFontCacheNotify
#if 0
    public IDispatch

#endif
{
public:
    CBody();
    virtual ~CBody();


    // override QI to add IBodyObj
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // IPersist     
    virtual HRESULT STDMETHODCALLTYPE GetClassID(CLSID *pCLSID);

    // IPersistMime
    virtual HRESULT STDMETHODCALLTYPE Load(IMimeMessage *pMsg);
    virtual HRESULT STDMETHODCALLTYPE Save(IMimeMessage *pMsg, DWORD dwFlags);

    // IPersistMoniker Members
    virtual HRESULT STDMETHODCALLTYPE Load(BOOL fFullyAvailable, IMoniker *pMoniker, IBindCtx *pBindCtx, DWORD grfMode);
    virtual HRESULT STDMETHODCALLTYPE GetCurMoniker(IMoniker **ppMoniker) {return E_NOTIMPL;}
    virtual HRESULT STDMETHODCALLTYPE Save(IMoniker *pMoniker, IBindCtx *pBindCtx, BOOL fRemember) {return E_NOTIMPL;}
    virtual HRESULT STDMETHODCALLTYPE SaveCompleted(IMoniker *pMoniker, IBindCtx *pBindCtx) {return E_NOTIMPL;}
    virtual HRESULT STDMETHODCALLTYPE IsDirty();

    // IPropertyNotifySink
    virtual HRESULT STDMETHODCALLTYPE OnChanged(DISPID dispid);
    virtual HRESULT STDMETHODCALLTYPE OnRequestEdit (DISPID dispid);

    // DocHostUIHandler
    virtual HRESULT STDMETHODCALLTYPE GetHostInfo(DOCHOSTUIINFO * pInfo);
    virtual HRESULT STDMETHODCALLTYPE ShowUI(DWORD dwID, IOleInPlaceActiveObject * pActiveObject, IOleCommandTarget * pCommandTarget, IOleInPlaceFrame * pFrame, IOleInPlaceUIWindow * pDoc);
    virtual HRESULT STDMETHODCALLTYPE HideUI(void);
    virtual HRESULT STDMETHODCALLTYPE UpdateUI(void);
    virtual HRESULT STDMETHODCALLTYPE EnableModeless(BOOL fEnable);
    virtual HRESULT STDMETHODCALLTYPE OnDocWindowActivate(BOOL fActivate);
    virtual HRESULT STDMETHODCALLTYPE OnFrameWindowActivate(BOOL fActivate);
    virtual HRESULT STDMETHODCALLTYPE ResizeBorder(LPCRECT prcBorder, IOleInPlaceUIWindow * pUIWindow,BOOL fRameWindow);
    virtual HRESULT STDMETHODCALLTYPE GetOptionKeyPath(BSTR * pbstrKey, DWORD dw);
    virtual HRESULT STDMETHODCALLTYPE ShowContextMenu(DWORD dwID, POINT* ppt, IUnknown* pcmdtReserved, IDispatch* pdispReserved);
    virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator(LPMSG lpMsg, const GUID * pguidCmdGroup, DWORD nCmdID);
    virtual HRESULT STDMETHODCALLTYPE GetDropTarget(IDropTarget * pDropTarget, IDropTarget ** ppDropTarget);
    virtual HRESULT STDMETHODCALLTYPE GetExternal(IDispatch **ppDispatch);        
    virtual HRESULT STDMETHODCALLTYPE TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut);
    virtual HRESULT STDMETHODCALLTYPE FilterDataObject(IDataObject *pDO, IDataObject **ppDORet);

    // ITargetFramePriv
    virtual HRESULT STDMETHODCALLTYPE FindFrameDownwards(LPCWSTR pszTargetName, DWORD dwFlags, IUnknown **ppunkTargetFrame);
    virtual HRESULT STDMETHODCALLTYPE FindFrameInContext(LPCWSTR pszTargetName, IUnknown *punkContextFrame, DWORD dwFlags, IUnknown **ppunkTargetFrame) ;
    virtual HRESULT STDMETHODCALLTYPE OnChildFrameActivate(IUnknown *pUnkChildFrame);
    virtual HRESULT STDMETHODCALLTYPE OnChildFrameDeactivate(IUnknown *pUnkChildFrame);
    virtual HRESULT STDMETHODCALLTYPE NavigateHack(DWORD grfHLNF,LPBC pbc, IBindStatusCallback *pibsc, LPCWSTR pszTargetName, LPCWSTR pszUrl, LPCWSTR pszLocation);
    virtual HRESULT STDMETHODCALLTYPE FindBrowserByIndex(DWORD dwID,IUnknown **ppunkBrowser);

    // *** IFontCacheNotify ***
    virtual HRESULT STDMETHODCALLTYPE OnPreFontChange();
    virtual HRESULT STDMETHODCALLTYPE OnPostFontChange();

#if 0
    // *** IDispatch ***
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo);
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid);
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr);
#endif

    // override CDocHost members
    virtual HRESULT STDMETHODCALLTYPE QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject);
    virtual HRESULT STDMETHODCALLTYPE Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    virtual HRESULT STDMETHODCALLTYPE OnUIActivate();
    virtual HRESULT STDMETHODCALLTYPE OnUIDeactivate(BOOL);
    virtual HRESULT STDMETHODCALLTYPE SetStatusText(LPCOLESTR);    
    virtual HRESULT GetDocObjSize(LPRECT prc);
    virtual HRESULT STDMETHODCALLTYPE OnFocus(BOOL fGotFocus);
    
    virtual LRESULT WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    
    HRESULT Init(HWND hwnd, DWORD dwFlags, LPRECT prc, PBODYHOSTINFO pHostInfo);
    HRESULT Close();
    HRESULT UnloadAll();

    HRESULT SetRect(LPRECT prc);
    HRESULT GetRect(LPRECT prc);
    HRESULT UIActivate(BOOL fUIActivate);
    HRESULT LoadStream(LPSTREAM pstm);

    HRESULT OnFrameActivate(BOOL fActivate);

    HRESULT PrivateQueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject);
    HRESULT PrivateQueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText);
    HRESULT PrivateExec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT PrivateTranslateAccelerator(LPMSG lpmsg);
    HRESULT PrivateEnableModeless(BOOL fEnable);
    HRESULT SetParentSites(IOleInPlaceSite *pInPlaceSite, IOleInPlaceFrame *pInPlaceFrame, IOleInPlaceActiveObject *pDoc);

    IHTMLDocument2  *GetDoc(){return m_pDoc;};

    HRESULT SetCharset(HCHARSET hCharset);
    HRESULT GetSelection(IHTMLTxtRange **ppRange);

private:
    DWORD                       m_dwStyle,
                                m_dwNotify,
                                m_dwReadyState,
                                m_cchTotal,
                                m_dwAutoTicks,
                                m_dwFontCacheNotify;
    HCHARSET                    m_hCharset;
    BOOL                        m_fEmpty            : 1,
                                m_fDirty            : 1,
                                m_fDesignMode       : 1,
                                m_fAutoDetect       : 1,
                                m_fPlainMode        : 1,
                                m_fMessageParsed    : 1,
                                m_fOnImage          : 1,
                                m_fLoading          : 1,
                                m_fTabLinks         : 1,
                                m_fSrcTabs          : 1,
                                m_fBkgrndSpelling   : 1,
                                m_fReloadingSrc     : 1,    // reloading source-view
                                m_fWasDirty         : 1,    // used by source-tabs to remember state of edit-mode
                                m_fForceCharsetLoad : 1,    // used when replying and don't keep message body
                                m_fIgnoreAccel      : 1;
    IMimeMessage                *m_pMsg;
    IMimeMessageW               *m_pMsgW;
    IHTMLDocument2              *m_pDoc;
    LPWSTR                      m_pszUrlW;     
    LPTEMPFILEINFO              m_pTempFileUrl;
    ULONG                       m_cchStart,
                                m_uHdrStyle,
                                m_cyPreview,
                                m_cVisibleBtns;
    IDocHostUIHandler          *m_pParentDocHostUI;
    IOleCommandTarget          *m_pParentCmdTarget;
    LPOLEINPLACESITE            m_pParentInPlaceSite;
    LPOLEINPLACEFRAME           m_pParentInPlaceFrame;
    CMsgSource                  *m_pSrcView;
    HWND                        m_hwndBtnBar,
                                m_hwndTab,
                                m_hwndSrc;
    LPSTR                       m_pszLayout;
    LPWSTR                      m_pszFrom,
                                m_pszTo,
                                m_pszCc, 
                                m_pszSubject;
    CFmtBar                    *m_pFmtBar;
    CSpell                     *m_pSpell;
    IHTMLTxtRange              *m_pRangeIgnoreSpell;
    IFontCache                 *m_pFontCache;
    IOleInPlaceActiveObject    *m_pDocActiveObj;
    CAttMenu                   *m_pAttMenu;
    HIMAGELIST                  m_hIml,
                                m_hImlHot;
    CSecManager                 *m_pSecMgr;
    ULONG                       m_uSrcView;
    IDispatch                   *m_pDispContext;
    DWORD                       m_dwContextItem;
    LPSTREAM                    m_pstmHtmlSrc;
    IHashTable                 *m_pHashExternal;
    IMarkupPointer             *m_pAutoStartPtr;

#ifdef PLUSPACK
    // Background speller
	IHTMLSpell					*m_pBkgSpeller;
#endif //PLUSPACK

    // notifications
    void OnReadyStateChanged();
    void OnDocumentReady();
    HRESULT OnWMCommand(HWND hwnd, int id, WORD wCmd);
    HRESULT OnPaint();
    HRESULT OnEraseBkgnd(HDC hdc);
    void WMSize(int x, int y);
    LRESULT WMNotify(WPARAM wParam, NMHDR* pnmhdr);
    HRESULT OnWMCreate();

    // load functions
    HRESULT RegisterLoadNotify(BOOL fRegister);
    HRESULT EnsureLoaded();
    HRESULT LoadFromData(LPBODYINITDATA pbiData);
    HRESULT LoadFromMoniker(IMoniker *pmk, HCHARSET hCharset);

    // Auto-Detect
    HRESULT AutoDetectTimer();
    HRESULT StopAutoDetect();
    HRESULT StartAutoDetect();
    HRESULT UrlHighlight(IHTMLTxtRange *pRange);

    // Trident OM helper functions
    HRESULT DeleteElement(IHTMLElement *pElem);
    HRESULT ReplaceElement(LPCTSTR pszName, BSTR bstrPaste, BOOL fHtml);
    HRESULT SelectElement(IHTMLElement *pElem, BOOL fScrollIntoView);
    HRESULT CreateRangeFromElement(IHTMLElement *pElem, IHTMLTxtRange **ppRange);
    HRESULT CreateRange(IHTMLTxtRange **ppRange);
    HRESULT GetElement(LPCTSTR pszName, IHTMLElement **ppElem);
    HRESULT GetBodyElement(IHTMLBodyElement **ppBody);
    HRESULT GetSelectedAnchor(BSTR* pbstr);
    HRESULT InsertTextAtCaret(BSTR bstr, BOOL fHtml, BOOL fMoveCaretToEnd);
    HRESULT InsertStreamAtCaret(LPSTREAM pstm, BOOL fHtml);
    HRESULT InsertBodyText(BSTR bstrPaste, DWORD dwFlags);
    HRESULT _CreateRangePointer(IMarkupPointer **pPtr);
    HRESULT _UrlHighlightBetweenPtrs(IMarkupPointer *pStartPtr, IMarkupPointer *pEndPtr);
    HRESULT _MovePtrByCch(IMarkupPointer *pPtr, LONG *pcp);

    // Printing
    HRESULT Print(BOOL fPrompt, VARIANTARG *pvaIn);

    // menu helpers
    HRESULT UpdateContextMenu(HMENU hmenuEdit, BOOL fEnableProperties, IDispatch *pDisp);
    HRESULT AppendAnchorItems(HMENU hMenu, IDispatch *pDisp);

    // verb supports
    HRESULT AddToWab();
    HRESULT AddToFavorites();
    HRESULT ViewSource(BOOL fMessage);
    HRESULT DoRot13();
    HRESULT SetStyle(ULONG uStyle);
    DWORD DwChooseProperties();
    HRESULT UpdateCommands();
    HRESULT ShowFormatBar(BOOL fOn);
    HRESULT SetDesignMode(BOOL fOn);
    HRESULT SetPlainTextMode(BOOL fOn);
    HRESULT InsertFile(BSTR bstrFileName);
    HRESULT FormatFont();
    HRESULT FormatPara();
    HRESULT DowngradeToPlainText(BOOL fForceFixedFont);
    HRESULT SetDocumentText(BSTR bstr);
    HRESULT ApplyDocumentVerb(VARIANTARG *pvaIn);
    HRESULT ApplyDocument(IHTMLDocument2 *pDoc);
    HRESULT SaveAttachments();
    HRESULT _OnSaveImage();
    BOOL    IsEmpty();
    HRESULT SafeToEncodeText(ULONG ulCodePage);

    // edit mode support
    HRESULT SetComposeFont(BSTR bstr);
    HRESULT SetHostComposeFont();
    HRESULT PasteReplyHeader();
    HRESULT FormatBlockQuote(COLORREF crTextColor);
    HRESULT GetAutoText(BSTR *pbstr, BOOL *pfTop);
    HRESULT PasteAutoText();
    HRESULT GetHostFlags(LPDWORD pdwFlags);
    HRESULT SetWindowBgColor(BOOL fForce);
    HRESULT InsertBackgroundSound();

    // other
    HRESULT GetWebPageOptions(WEBPAGEOPTIONS *pOptions, BOOL *pfIncludeMsg);
    HRESULT CreateFontCache(LPCSTR pszTridentKey);
    HRESULT HrFormatParagraph();

    // preview pane mode helpers
    HRESULT RecalcPreivewHeight(HDC hdc);
    HRESULT UpdatePreviewLabels();
    LONG lGetClientHeight();
    HRESULT Resize();
    void OutputHeaderText(HDC hdc, LPWSTR psz, int *pcxPos, int cyPos, int cxMax, ULONG uFlags);
    LONG lGetLineHeight(HDC hdc);

    // MHTML saving helpers
    HRESULT ClearDirtyFlag();
    HRESULT ClearUndoStack();
    HRESULT DoHostProperties();
    HRESULT SaveAsStationery(VARIANTARG *pvaIn, VARIANTARG *pvaOut);
    HRESULT TagUnreferencedImages();
    HRESULT GetBackgroundColor(DWORD *pdwColor);
    HRESULT SetBackgroundColor(DWORD dwColor);
    HRESULT SearchForCIDUrls();

    HRESULT UpdateBtnBar();

    HRESULT InitToolbar();
    HRESULT UpdateButtons();
    HRESULT ShowAttachMenu(BOOL fRightClick);
    HRESULT ShowPreview(BOOL fOn);
    HRESULT PointFromButton(int idm, POINT *ppt);
    HRESULT EnsureAttMenu();
    HRESULT EnableSounds(BOOL fOn);

    // source editing mode helpers
    HRESULT ShowSourceView(ULONG uSrcView);
    HRESULT ShowSourceTabs(BOOL fOn);
    HRESULT SetSourceTabs(ULONG ulTab);
    HRESULT IsColorSourceEditing();

    // spellchecker
    HRESULT HrCreateSpeller(BOOL fBkgrnd);
    HRESULT _ReloadWithHtmlSrc(IStream *pstm);
    HRESULT _EnsureSrcView();
};


HRESULT CreateBodyObject(HWND hwnd, DWORD dwFlags, LPRECT prc, PBODYHOSTINFO pHostInfo, LPBODYOBJ *ppBodyObj);


#endif //_BODY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\bodyutil.h ===
/*
 *    b o d y u t i l . h
 *    
 *    Purpose:
 *        Utility functions for body
 *
 *  History
 *      September '96: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _BODYUTIL_H
#define _BODYUTIL_H

interface IMimeMessage;

// header style:
// Mutually Exclusive. Plain means no formatting, html means bolding on field names, table will construct the
// header as a html-table
#define HDR_HTML        0x10000000L
#define HDR_TABLE       0x40000000L
#define HDR_PLAIN       0x80000000L

// additional flags:
#define HDR_PADDING     0x00000001L     // add CRLF before header, or <HR> tag in table mode.
#define HDR_NEWSSTYLE   0x00000002L
#define HDR_HARDCODED   0x00000004L     // hard-coded english headers

HRESULT GetHeaderTable(IMimeMessageW *pMsg, LPWSTR pwszUserName, DWORD dwHdrStyle, LPSTREAM *ppstm);

void GetStringRGB(DWORD rgb, LPSTR pszColor);
void GetRGBFromString(DWORD* pRBG, LPSTR pszColor);

#endif //_BODYUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\body.cpp ===
/*
 *    b o d y . c p p
 *    
 *    Purpose:
 *        base class implementation of Body object. Derrives from CDocHost to host the trident
 *        control.
 *
 *  History
 *      August '96: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */
#include <pch.hxx>
#include "dllmain.h"
#include <shfusion.h>
#include "resource.h"
#include "strconst.h"
#include "htmlstr.h"
#include "mimeolep.h"
#include "mimeutil.h"
#include "htiframe.h"       // ITargetFrame2
#include "htiface.h"        // ITargetFramePriv
#include "vervec.h"         // IVersion*
#include "triutil.h"
#include "util.h"
// #include "dochost.h"
#ifdef PLUSPACK
#include "htmlsp.h"
#endif //PLUSPACK
#include "body.h"
#include "bodyutil.h"
#include "oleutil.h"
#include "secmgr.h"
#include "mhtml.h"
#include "fmtbar.h"
#include "fontcash.h"
#include "attmenu.h"
#include "saveatt.h"
#include "frames.h"
#include "richedit.h"
#include "viewsrc.h"
#include "spell.h"
#include "tags.h"
#include "optary.h"
#include "shlwapip.h"
#include <icutil.h>
#include <demand.h>

ASSERTDATA

/*
 *  m a c r o s
 */
#define SetMenuItem(hmenu, id, fOn)     EnableMenuItem(hmenu, id, (fOn)?MF_ENABLED:MF_DISABLED|MF_GRAYED);

/*
 *  c o n s t a n t s
 */
#define BKGRNDSPELL_TICKTIME    100
#define AUTODETECT_CHUNK        16384
#define AUTODETECT_TICKTIME     200
#define AUTODETECT_TIMEOUT      10
//#define USE_ABORT_TIMER

#define idTimerAutoDetect        110
#define idTimerBkgrndSpell       111

static WCHAR    c_szMailToW[]   =L"mailto:",
                c_szOECmdW[]    =L"oecmd:",                
                c_szHttpW[]     =L"http://",
                c_szFileW[]     =L"file://";

#define CX_LABEL_PADDING        4
#define CY_LINE_PADDING         4

#define COLOR_HEADER            COLOR_3DFACE
#define COLOR_HEADERTXT         COLOR_BTNTEXT
#define COLOR_HEADERFOCUS       COLOR_HIGHLIGHT
#define COLOR_HEADERTXTFOCUS    COLOR_HIGHLIGHTTEXT

#define SMALLHEADERHEIGHT                   3
#define CX_PANEICON             30
#define CY_PANEICON             30
#define CY_PANEPADDING          (2*GetSystemMetrics(SM_CYBORDER))
#define CX_PANEPADDING          (2*GetSystemMetrics(SM_CXBORDER))

enum
    {
    IBTF_INSERTATEND    = 0x0001,
    IBTF_URLHIGHLIGHT   = 0x0002
    };

#define idcTabs     999
#define idcSrcEdit  998

#define HDRTXT_BOLD         0x01
#define HDRTXT_SYSTEMFONT   0x02

/*
 *  t y p e d e f s
 */
class CVerHost :
    public IVersionHost
{
public:
    CVerHost();
    virtual ~CVerHost();


    // IUnknown
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // IVersionHost
    virtual HRESULT STDMETHODCALLTYPE QueryUseLocalVersionVector(BOOL *fUseLocal);
    virtual HRESULT STDMETHODCALLTYPE QueryVersionVector(IVersionVector *pVersion);


private:
    ULONG               m_cRef;
};


/*
 *  g l o b a l s 
 */

static const TCHAR  c_szCaretSpanTag[]      = "<SPAN id=\"__#Ath#CaretPos__\">&nbsp;</SPAN>",
                    c_szCaretSpan[]         = "__#Ath#CaretPos__",
                    c_szSignatureSpanTag[]  = "&nbsp;<SPAN id=\"__#Ath#SignaturePos__\"></SPAN>&nbsp;",
                    c_szSignatureSpan[]     = "__#Ath#SignaturePos__",
                    c_szSigPrefix[]         = "\r\n-- \r\n";

/*
 *  f u n c t i o n   p r o t y p e s
 */
HRESULT CALLBACK FreeDataObj(PDATAOBJINFO pDataObjInfo, DWORD celt);
HRESULT HrSniffUrlForRfc822(LPWSTR pszUrlW);

/*
 *  f u n c t i o n s
 */

//+---------------------------------------------------------------
//
//  Member:     CBody
//
//  Synopsis:   
//
//---------------------------------------------------------------

CBody::CBody()
{
    m_dwReadyState = READYSTATE_UNINITIALIZED;
    m_pszUrlW = NULL;
    m_pMsg = NULL;
    m_pMsgW = NULL;
    m_pDoc = NULL;
    m_hCharset=NULL;
    m_dwNotify=0;
    m_pTempFileUrl=NULL;
    m_pParentDocHostUI=NULL;
    m_pParentCmdTarget=NULL;
    m_pParentInPlaceSite=0;
    m_pParentInPlaceFrame=0;
    m_fPlainMode=FALSE;
    m_uHdrStyle = MESTYLE_NOHEADER ;
    m_pszLayout = NULL;
    m_pszFrom = 0;
    m_pszTo = 0;
    m_pszCc = 0;
    m_pszSubject = 0;
    m_fEmpty = 1;
    m_fMessageParsed=0;
    m_fDirty=0;
    m_fDesignMode=0;
    m_fAutoDetect=0;
    m_fOnImage=0;
    m_fTabLinks=0;
    m_pFmtBar=NULL;
    m_fLoading=1;
    m_fForceCharsetLoad=FALSE;
    m_pRangeIgnoreSpell=0;
    m_pFontCache=0;
    m_pDocActiveObj = 0;
    m_pAttMenu=NULL;
    m_hwndBtnBar=NULL;
    m_hIml=0;
    m_hImlHot=0;
    m_cVisibleBtns=0;
    m_pAttMenu=NULL;
    m_pSecMgr = NULL;
    m_hwndTab=NULL;
    m_hwndSrc=NULL;
    m_uSrcView = 0;
    m_pSrcView=NULL;
    m_fSrcTabs = 0;
    m_fReloadingSrc = FALSE;
    m_pSpell = 0;
    m_fBkgrndSpelling = FALSE;
    m_cchTotal = 0;
    m_dwFontCacheNotify = 0;
    m_fWasDirty = 0;
    m_pDispContext=0;
    m_dwContextItem=0;
    m_pstmHtmlSrc=NULL;
    m_pHashExternal = NULL;
    m_dwAutoTicks = 0;
    m_pAutoStartPtr = 0;
    m_fIgnoreAccel = 0;
#ifdef PLUSPACK
	m_pBkgSpeller = NULL;
#endif //PLUSPACK
}


//+---------------------------------------------------------------
//
//  Member:     CBody
//
//  Synopsis:   
//
//---------------------------------------------------------------
CBody::~CBody()
{
    Assert (m_pDispContext==NULL);
    SafeRelease(m_pAttMenu);
    SafeRelease(m_pParentInPlaceSite);
    SafeRelease(m_pParentInPlaceFrame);
    SafeRelease(m_pFmtBar);
    SafeRelease(m_pRangeIgnoreSpell);
    SafeRelease(m_pFontCache);
    SafeRelease(m_pSecMgr);
    SafeRelease(m_pSrcView);
    SafeRelease(m_pstmHtmlSrc);
    SafeRelease(m_pHashExternal);
    SafeRelease(m_pAutoStartPtr);

    Assert(m_pMsg==NULL);
    Assert(m_pMsgW==NULL);
    Assert(m_pTempFileUrl==NULL);
    Assert(m_pszFrom == 0);
    Assert(m_pszTo == 0);
    Assert(m_pszCc == 0);
    Assert(m_pszSubject == 0);
    SafeMemFree(m_pszLayout);
    if (m_hIml)
        ImageList_Destroy(m_hIml);
    if (m_hImlHot)
        ImageList_Destroy(m_hImlHot);
}


//+---------------------------------------------------------------
//
//  Member:     Init
//
//  Synopsis:   pHostInfo is used to set parent's sites and frames. 
//             the parent inplace site is sent notifications on activation etc
//
//---------------------------------------------------------------
HRESULT CBody::Init(HWND hwndParent, DWORD dwFlags, LPRECT prc, PBODYHOSTINFO pHostInfo)
{
    HRESULT hr;

    TraceCall("CBody::Init");

    if (pHostInfo)
    {
        ReplaceInterface(m_pParentInPlaceSite, pHostInfo->pInPlaceSite);
        ReplaceInterface(m_pParentInPlaceFrame, pHostInfo->pInPlaceFrame);
        ReplaceInterface(m_pDocActiveObj, pHostInfo->pDoc);
        if (m_pParentInPlaceSite)
        {
            // get the dochostUIhandler to delegate to when setparent sites is called
            Assert(m_pParentDocHostUI==NULL);
            Assert(m_pParentCmdTarget==NULL);
            m_pParentInPlaceSite->QueryInterface(IID_IDocHostUIHandler, (LPVOID *)&m_pParentDocHostUI);
            m_pParentInPlaceSite->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&m_pParentCmdTarget);
        }
    }

    m_dwStyle=dwFlags;

    hr = CDocHost::Init(hwndParent, dwFlags&MEBF_OUTERCLIENTEDGE, prc);
    if (FAILED(hr))
        goto error;

    hr = HrCreateFormatBar(m_hwnd, idcFmtBar, dwFlags&MEBF_FORMATBARSEP, &m_pFmtBar);
    if (FAILED(hr))
        goto error;

    // fire-up trident at init time
    hr = EnsureLoaded();

error:
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     Close
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::Close()
{
    IConnectionPoint    *pCP;

    TraceCall("CBody::Close");
    
    UnloadAll();
    RegisterLoadNotify(FALSE);

#ifdef PLUSPACK
	SafeRelease(m_pBkgSpeller);
#endif //PLUSPACK

#ifdef BACKGROUNDSPELL
    if (m_pSpell && m_fBkgrndSpelling)
    {
        m_pSpell->HrRegisterKeyPressNotify(FALSE);
        KillTimer(m_hwnd, idTimerBkgrndSpell);       // done. Stop the timer
    }
#endif // BACKGROUNDSPELL

	// scotts@directeq.com - moved this from destructor - 31463 & 36253
    if(m_pSpell)
        m_pSpell->CloseSpeller();
    SafeRelease(m_pSpell);

    SafeRelease(m_pFmtBar);
    SafeRelease(m_pDoc);
    SafeRelease(m_pParentCmdTarget);
    SafeRelease(m_pParentDocHostUI);
    SafeRelease(m_pParentInPlaceSite);
    SafeRelease(m_pParentInPlaceFrame);
    SafeRelease(m_pDocActiveObj);
    
    if (m_pFontCache && 
        m_pFontCache->QueryInterface(IID_IConnectionPoint, (LPVOID *)&pCP)==S_OK)
    {
        pCP->Unadvise(m_dwFontCacheNotify);
        pCP->Release();
    }
    SafeRelease(m_pFontCache);

    CloseDocObj();
    if (m_hwnd)
    {
        DestroyWindow(m_hwnd);
        m_hwnd=NULL;
    }
    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     WndProc
//
//  Synopsis:   
//
//---------------------------------------------------------------
LRESULT CBody::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HWND    hwndT;

    switch (msg)
        {
        case WM_WININICHANGE:
        case WM_DISPLAYCHANGE:
        case WM_SYSCOLORCHANGE:
        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
            if (m_pFmtBar && 
                m_pFmtBar->GetWindow(&hwndT)==S_OK)
                SendMessage(hwndT, msg, wParam, lParam);
            break;

        case WM_LBUTTONDOWN:
            if (!m_fFocus)
                SetFocus(m_hwnd);
            break;

        case WM_KILLFOCUS:
        case WM_SETFOCUS:
            OnFocus(msg==WM_SETFOCUS);
            break;

        case WM_SIZE:
            // since we do blit stuff we invalidate here
            InvalidateRect(m_hwnd, NULL, FALSE);
            break;

        case WM_ERASEBKGND:
            OnEraseBkgnd((HDC)wParam);
            return TRUE;

        case WM_CREATE:
            if (FAILED(OnWMCreate()))
                return -1;
            break;

        case WM_TIMER:
            if (wParam == idTimerAutoDetect)
                {
                AutoDetectTimer();
                return 0;
                }
            
#ifdef BACKGROUNDSPELL
            if (wParam == idTimerBkgrndSpell)
                {
                if (m_pSpell)
                    m_pSpell->HrBkgrndSpellTimer();
                return 0;
                }
#endif // BACKGROUNDSPELL

            if (m_pSrcView &&
                m_pSrcView->OnTimer(wParam)==S_OK)
                return 0;

            break;

        case WM_COMMAND:
            if(OnWMCommand(
                GET_WM_COMMAND_HWND(wParam, lParam),
                GET_WM_COMMAND_ID(wParam, lParam),
                GET_WM_COMMAND_CMD(wParam, lParam))==S_OK)
                return 0;

            break;

        case WM_NOTIFY:
            return WMNotify(wParam, (NMHDR*)lParam);

        case WM_PAINT:
            if (OnPaint()==S_OK)
                return 0;
            break;
        }
    
    return CDocHost::WndProc(hwnd, msg, wParam, lParam);
}


//+---------------------------------------------------------------
//
//  Member:     QueryInterface
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::QueryInterface(REFIID riid, LPVOID FAR *lplpObj)
{
    TraceCall("CBody::QueryInterface");

    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *lplpObj = (IUnknown *)(IPropertyNotifySink *)this;
    else if (IsEqualIID(riid, IID_IPropertyNotifySink))
        *lplpObj = (IPropertyNotifySink *)this;
    else if (IsEqualIID(riid, IID_IDocHostUIHandler))
        *lplpObj = (IDocHostUIHandler*) this;
    else if (IsEqualIID(riid, IID_IPersistMime))
        *lplpObj = (IPersistMime*) this;
    else if (IsEqualIID(riid, IID_ITargetFramePriv))
        *lplpObj = (ITargetFramePriv*) this;
    else if (IsEqualIID(riid, IID_IPersistMoniker))
        *lplpObj = (LPVOID)(IPersistMoniker *)this;
    else if (IsEqualIID(riid, IID_IFontCacheNotify))
        *lplpObj = (LPVOID)(IFontCacheNotify *)this;
#if 0
    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch *)this;
#endif
    else
        return CDocHost::QueryInterface(riid, lplpObj);
        
    AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------
//
//  Member:     AddRef
//
//  Synopsis:   
//
//---------------------------------------------------------------
ULONG CBody::AddRef()
{
    TraceCall("CBody::AddRef");
    return CDocHost::AddRef();
}

//+---------------------------------------------------------------
//
//  Member:     Release
//
//  Synopsis:   
//
//---------------------------------------------------------------
ULONG CBody::Release()
{
    TraceCall("CBody::Release");
    return CDocHost::Release();
}



//+---------------------------------------------------------------
//
//  Member:     QueryService
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject)
{
    HRESULT             hr=E_FAIL;
    IServiceProvider    *pSP;
    IVersionHost        *pVersion;

    //DebugPrintInterface(riid, "CBody::QueryService");

    // delegate to the mimeedit host first
    if (m_pParentInPlaceSite)
        {
        if (m_pParentInPlaceSite->QueryInterface(IID_IServiceProvider, (LPVOID *)&pSP)==S_OK)
            {
            hr = pSP->QueryService(guidService, riid, ppvObject);
            pSP->Release();
            if (hr==S_OK)
                return S_OK;
            }
        }

    if (IsEqualGUID(guidService, SID_SInternetSecurityManager))
        {
        if (!m_pSecMgr)
            CreateSecurityManger(m_pParentCmdTarget, &m_pSecMgr);

        if (m_pSecMgr)
            return m_pSecMgr->QueryInterface(riid, ppvObject);
        }
    else if (IsEqualGUID(guidService, IID_ITargetFrame2))
        return QueryInterface(riid, ppvObject); 
    else if (IsEqualGUID(guidService, SID_SVersionHost) && IsEqualIID(riid, IID_IVersionHost))
    {
        pVersion = new CVerHost();
        if (!pVersion)
            return E_OUTOFMEMORY;

        *ppvObject = (LPVOID)(IVersionHost *)pVersion;
        return S_OK;
    }

    return CDocHost::QueryService(guidService, riid, ppvObject);
}

// *** IDocHostUIHandler ***

//+---------------------------------------------------------------
//
//  Member:     GetHostInfo
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::GetHostInfo( DOCHOSTUIINFO* pInfo )
{
    HRESULT     hr;

    TraceCall("CBody::GetHostInfo");

    if (m_pParentDocHostUI)
    {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->GetHostInfo(pInfo);
        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
    }

    pInfo->dwDoubleClick    = DOCHOSTUIDBLCLK_DEFAULT;
    pInfo->dwFlags          = DOCHOSTUIFLAG_DIV_BLOCKDEFAULT|DOCHOSTUIFLAG_OPENNEWWIN|
                              DOCHOSTUIFLAG_ACTIVATE_CLIENTHIT_ONLY|
                              DOCHOSTUIFLAG_IME_ENABLE_RECONVERSION |
                              DOCHOSTUIFLAG_CODEPAGELINKEDFONTS;
    
    //This sets the flags that match the browser's encoding
    fGetBrowserUrlEncoding(&pInfo->dwFlags);

    if (!(m_dwStyle & MEBF_INNERCLIENTEDGE))
        pInfo->dwFlags |= DOCHOSTUIFLAG_NO3DBORDER;

    if (m_dwStyle & MEBF_NOSCROLL)
        pInfo->dwFlags |= DOCHOSTUIFLAG_SCROLL_NO;

    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     ShowUI
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::ShowUI(DWORD dwID,   IOleInPlaceActiveObject *pActiveObject,
                      IOleCommandTarget       *pCommandTarget,
                      IOleInPlaceFrame        *pFrame,
                      IOleInPlaceUIWindow     *pDoc)
{
    HRESULT     hr;

    TraceCall("CBody::ShowUI");

    if (m_pParentDocHostUI)
        {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->ShowUI(dwID, pActiveObject, pCommandTarget, pFrame, pDoc);
        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
        }
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     HideUI
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::HideUI(void)
{
    HRESULT     hr;

    TraceCall("CBody::HideUI");

    if (m_pParentDocHostUI)
        {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->HideUI();
        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
        }

    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     UpdateUI
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::UpdateUI(void)
{
    HRESULT hr;

    TraceCall("CBody::UpdateUI");

    if (m_pParentDocHostUI)
        {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->UpdateUI();
        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
        }

    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     EnableModeless
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::EnableModeless(BOOL fEnable)
{
    HRESULT     hr;

    TraceCall("CBody::EnableModeless");
    
    if (m_pParentDocHostUI)
        {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->EnableModeless(fEnable);
        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
        }
    
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     OnDocWindowActivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::OnDocWindowActivate(BOOL fActivate)
{
    HRESULT     hr;

    TraceCall("CBody::OnDocWindowActivate");

    if (m_pParentDocHostUI)
        {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->OnDocWindowActivate(fActivate);
        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
        }

    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     OnFrameWindowActivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::OnFrameWindowActivate(BOOL fActivate)
{
    HRESULT     hr;
    TraceCall("CBody::OnFrameWindowActivate");

    if (m_pParentDocHostUI)
        {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->OnFrameWindowActivate(fActivate);
        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
        }
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     ResizeBorder
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::ResizeBorder(LPCRECT prcBorder,
                            IOleInPlaceUIWindow* pUIWindow,
                            BOOL fRameWindow)
{
    HRESULT     hr;
    TraceCall("CBody::ResizeBorder");

    if (m_pParentDocHostUI)
        {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->ResizeBorder(prcBorder, pUIWindow, fRameWindow);
        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
        }

    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     ShowContextMenu
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::ShowContextMenu( DWORD       dwID,
                               POINT       *pptPosition,
                               IUnknown    *pcmdtReserved,
                               IDispatch   *pDispatchObjectHit)
{
    HRESULT         hr;
    HMENU           hMenu=0;
    INT             id;
    IHTMLTxtRange   *pTxtRange=0;
#ifdef PLUSPACK
    ISpellingSuggestions * pSuggestions = NULL;
    IMarkupPointer       * pPointerLeft = NULL;
    IMarkupPointer       * pPointerRight = NULL;
    IMarkupServices      * pMarkupServices = NULL;
    IDisplayPointer      * pDispPointer = NULL;
    IDisplayServices     * pDisplayServices = NULL;
    IHTMLElement         * pElement = NULL;
    IHTMLBodyElement     * pBody = NULL;
    IHTMLTxtRange           *pRange = NULL;
    IHTMLWindow2            *pWindow = NULL;
    IHTMLEventObj           *pEvent = NULL;
    IHTMLSelectionObject * pSelection = NULL;
    VARIANT_BOOL         fInSquiggle = VARIANT_FALSE;
    VARIANT         var;
    BSTR            bstrSuggestion = NULL;
    BSTR            bstrWord = NULL;
    BSTR            bstrSelectionType = NULL;    
    TCHAR           szAnsiSuggestion[256];
    INT             cch;
    BOOL            fRepeatWord;
    LONG            lCount = 0;
    MENUITEMINFO        mii = {0};

    LONG                    lButton;
    int i;
#else
    BOOL fSpellSuggest=FALSE;
#endif //PLUSPACK
    
    TraceCall("CBody::ShowContextMenu");
    
    if (m_pParentDocHostUI)
    {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->ShowContextMenu(dwID, pptPosition, pcmdtReserved, pDispatchObjectHit);
        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
    }
    
    Assert(m_lpOleObj && m_hwnd);
    
    m_dwContextItem = dwID;
#ifdef PLUSPACK
    hr = GetSelection(&pTxtRange);

    // Background spell context menu
    if(m_fDesignMode && m_pBkgSpeller && m_pDoc)
    {
        // Check for squiggle
        //          
        CHECKHR(hr = m_pBkgSpeller->IsInSquiggle(pTxtRange, &fInSquiggle) );

        if (fInSquiggle)
        {   //only if we have a suggestion
        // Get suggestions
                //
            CHECKHR(hr = m_pBkgSpeller->GetSpellingSuggestions(pTxtRange, FALSE, &pSuggestions) );
                
            //
            // Create the context menu
            //
                
            if (!(hMenu = LoadPopupMenu(idmrCtxtSpellSuggest)))
            {
                hr = TraceResult(E_FAIL);
                goto exit;
            }
            /* CHECKHR(hr = pSuggestions->get_IsDoubleWord(&fRepeatWord) );
            if (fRepeatWord)
                {
                    // if (!AppendMenuA(hMenu, MF_STRING, IDM_DELETEWORD, "&Delete Repeated Word"))
                    //    goto exit;
                    
                }
                else 
                { */
            //
            // Fill with suggestions
            //
            CHECKHR(hr = pSuggestions->get_Count(&lCount) );
                    
            if (lCount < 1)
            {
                if (!AppendMenuA(hMenu, MF_DISABLED | MF_GRAYED, 1, "(no suggestions)"))
                    goto exit;
            }
            else
            {
                V_VT(&var) = VT_I4;
                for (i = 0; (i <= lCount) && ((i + idmSuggest0) <= idmSuggest4); ++i)
                {
                    V_I4(&var) = i + 1; // get_Item starts from 1
                            
                    SysFreeString(bstrSuggestion);
                    bstrSuggestion = NULL;
                    CHECKHR(hr = pSuggestions->get_Item(&var, &bstrSuggestion));
                            
                    cch = WideCharToMultiByte(0, 0, bstrSuggestion, SysStringLen(bstrSuggestion), szAnsiSuggestion, ARRAYSIZE(szAnsiSuggestion), NULL, NULL);
                    if (!cch)
                        goto exit;
                                
                    szAnsiSuggestion[cch] = 0;
                                
                    // Initialize the menu info
                    mii.cbSize = sizeof(mii);
                    mii.fMask = MIIM_ID | MIIM_TYPE;
                    mii.fType = MFT_STRING;
                    mii.fState = MFS_ENABLED;
                    mii.wID = i + idmSuggest0;
                    mii.dwTypeData = szAnsiSuggestion;
                    mii.cch = lstrlen(szAnsiSuggestion);

                    if(!InsertMenuItem(hMenu, 0, TRUE, &mii))
//					if (!AppendMenuA(hMenu, MF_STRING, i + idmSuggest0, szAnsiSuggestion))
                        goto exit;
                }
            }
                    
//            if (!AppendMenuA(hMenu, MF_SEPARATOR, 0, NULL))
//				goto exit;
                    
//                    if (!AppendMenuA(hMenu, MF_STRING, IDM_IGNOREWORD, "&Ignore All"))
//                        goto exit;
        }
        
    }
#endif //PLUSPACK

#ifdef BACKGROUNDSPELL
    if (m_pSpell && m_fBkgrndSpelling)
    {
        HRESULT       hr;
        
        hr = GetSelection(&pTxtRange);
        if (pTxtRange)
        {
            if (m_pSpell->HrHasSquiggle(pTxtRange)==S_OK)
            {
                if (!(hMenu = LoadPopupMenu(idmrCtxtSpellSuggest)))
                {
                    hr = TraceResult(E_FAIL);
                    goto exit;
                }
                
                hr = m_pSpell->HrInsertMenu(hMenu, pTxtRange);
                if (FAILED(hr))
                    goto exit;
                fSpellSuggest = TRUE;
            }
        }
    }
#endif // BACKGROUNDSPELL

#ifdef PLUSPACK
    if (!fInSquiggle)
#else
    if (!fSpellSuggest)
#endif //PLUSPACK
    {
        if (!(hMenu = LoadPopupMenu(m_fDesignMode?idmrCtxtEditMode:idmrCtxtBrowseMode)))
        {
            hr = TraceResult(E_FAIL);
            goto exit;
        }
        
        if (!m_fDesignMode)
        {
            // if in browse mode, query the host to see if we can provider add to WAB and
            // add to fave menu items
            if (dwID == CONTEXT_MENU_ANCHOR)
            {
                AppendAnchorItems(hMenu, pDispatchObjectHit);
            }
            else
            {
                // remove the CopyShortCut command if it's not an anchor
                RemoveMenu(hMenu, idmCopyShortcut, MF_BYCOMMAND);
                // remove the SaveTargetAs command if it's not an anchor
                RemoveMenu(hMenu, idmSaveTargetAs, MF_BYCOMMAND);
            }
            
            if (dwID != CONTEXT_MENU_IMAGE)
                EnableMenuItem(hMenu, idmSavePicture, MF_BYCOMMAND|MF_GRAYED);
        }
        else
        {
            // if in editmode, trident does not pass dwID==CONTEXT_MENU_ANCHOR so we have to
            // test to see if the selection in an anchor to set this. It may fix this in the future
            // so code for both cases
            
            if (dwID==0 && GetSelectedAnchor(NULL)==S_OK)
                dwID = CONTEXT_MENU_ANCHOR;
            
#ifdef FOLLOW_LINK
            // if edit-mode, and not on an anchor, hide the openlink menu command
            if (dwID != CONTEXT_MENU_ANCHOR)
                RemoveMenu(hMenu, idmOpenLink, MF_BYCOMMAND);
#endif
        }
        
        m_fOnImage = !!(dwID == CONTEXT_MENU_IMAGE);
        UpdateContextMenu(hMenu, (dwID == CONTEXT_MENU_IMAGE || dwID == CONTEXT_MENU_ANCHOR), pDispatchObjectHit);
    }
    
    id = (INT)TrackPopupMenu(
        hMenu,
        TPM_LEFTALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD,
        pptPosition->x,
        pptPosition->y,
        0,
        GetParent(m_hwnd),
        NULL);
    
    // we have to use TPM_RETURNCMD here as we need to process the command-id before returning from this
    // function, other wise trident will be confused about the object being clicked on.
#ifdef PLUSPACK
    if (pTxtRange && id!=0 && m_pBkgSpeller && fInSquiggle)
    {
        //
        // Handle command
        //

        switch (id)
        {
            case idmIgnoreAll:
				CHECKHR(hr = m_pBkgSpeller->IgnoreWord(pTxtRange) );
				break;

            /*case IDM_DELETEWORD:
            {
                SysFreeString(bstrSuggestion);
                bstrSuggestion = SysAllocString(L"");
                CHECKHR(hr = pTxtRange->put_text(bstrSuggestion) );
                break;
            } */

            case idmIgnore:
            {
                //
                // mark this as clean
                //
                CHECKHR(hr = m_pBkgSpeller->MarkRegion(pTxtRange, VARIANT_FALSE) );
                break;
            }

            default:
                if ((id - idmSuggest0) <= lCount)
                {
                V_I4(&var) = id - idmSuggest0 + 1; // get_Item starts from 1

                SysFreeString(bstrSuggestion);
                bstrSuggestion = NULL;
                CHECKHR(hr = pSuggestions->get_Item(&var, &bstrSuggestion) );
    
                CHECKHR(hr = pTxtRange->put_text(bstrSuggestion) );
/*                {
                    CHAR    szBuf[MAX_PATH] = {0};
                    BSTR    bstr=0;
                    BSTR    bstrPut=0;
                    LPSTR   pch=0;
                    INT     i=0;
                    cch = WideCharToMultiByte(0, 0, bstrSuggestion, SysStringLen(bstrSuggestion), szAnsiSuggestion, 255, NULL, NULL);
					szAnsiSuggestion[cch] = '\0';
                    pch = szAnsiSuggestion;
                    StrCpyN(szBuf, pch, ARRAYSIZE(szBuf));

                    if (SUCCEEDED(pTxtRange->get_text(&bstr)) && bstr)
                    {
                        LPSTR   pszText = 0;
                        if (SUCCEEDED(HrBSTRToLPSZ(CP_ACP, bstr, &pszText)) && pszText)
                        {
                            LPSTR   psz;
                            INT     nSpaces=0;
                            psz = StrChrI(pszText, ' ');
                            if(psz)
                            {
                                nSpaces = (INT) (&pszText[lstrlen(pszText)] - psz);
                                Assert(nSpaces>=0);
                                for(int i=0; i<(nSpaces-1); i++)
                                    StrCatBuff(szBuf, "&nbsp;", ARRAYSIZE(szBuf));
                                if (nSpaces>0)
                                    StrCatBuff(szBuf, " ", ARRAYSIZE(szBuf));
                            }
                            hr = HrLPSZToBSTR(szBuf, &bstrPut);

                            SafeMemFree(pszText);
                        }
                        SafeSysFreeString(bstr);
                    }
                    if (bstrPut)
                    {
                        pTxtRange->pasteHTML(bstrPut);
                        SafeSysFreeString(bstrPut);
                    }

                }*/
				break;
            }
        }

        hr = S_OK;
        goto exit;
    } 
#else
    if (pTxtRange && id!=0 && m_pSpell && fSpellSuggest && m_pSpell->OnWMCommand(id, pTxtRange)==S_OK)
        goto exit;
#endif //PLUSPACK
    
    // stuff the IDispatch object, so our WMCommand handler can use it
    if (m_pDispContext = pDispatchObjectHit)
        pDispatchObjectHit->AddRef();
    
    if(id != 0)
        OnWMCommand(NULL, id, 0);
       
exit:
    SafeRelease(m_pDispContext);
#ifdef PLUSPACK
    SysFreeString(bstrSuggestion);
    SysFreeString(bstrWord);
    SysFreeString(bstrSelectionType);
#endif //PLUSPACK
    if (hMenu)
        DestroyMenu(hMenu);
#ifdef PLUSPACK
    SafeRelease(pSuggestions);
    SafeRelease(pPointerLeft);
    SafeRelease(pPointerRight);
    SafeRelease(pMarkupServices);
    SafeRelease(pDispPointer);
    SafeRelease(pDisplayServices);
    SafeRelease(pElement);
    SafeRelease(pBody);
    SafeRelease(pSelection);
    SafeRelease(pWindow);
    SafeRelease(pRange);
    SafeRelease(pEvent);
#endif //PLUSPACK
    ReleaseObj(pTxtRange);
    
    m_dwContextItem = 0;
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     GetDropTarget
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::GetDropTarget(IDropTarget *pDropTarget, IDropTarget **ppDropTarget)
{
    HRESULT     hr;

    TraceCall("CBody::GetDropTarget");

    if (m_pParentDocHostUI)
        {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->GetDropTarget(pDropTarget, ppDropTarget);
        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
        }

    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     GetExternal
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::GetExternal(IDispatch **ppDispatch)
{
    HRESULT     hr;

    TraceCall("CBody::GetExternal");

    if (m_pParentDocHostUI)
        {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->GetExternal(ppDispatch);
        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
        }

    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     TranslateUrl
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::TranslateUrl(DWORD dwTranslate, OLECHAR *pwszUrlIn, OLECHAR **ppwszUrlOut)
{
    HRESULT             hr=S_OK;
    LPSTR               pszUrlIn=NULL;
    LPSTR               pszBodyUrl=NULL;
    LPSTR               pszFilePath=NULL;
    LPSTR               pszUrlOut=NULL;
    LPSTR               pszFree=NULL;
    LPSTR               pszGenFName=NULL;
    LPSTR               pszParameters=NULL;
    LPSTR               pszCommandLine=NULL;
    CHAR                szBuffer[MAX_PATH];
    HBODY               hBody;
    IMimeBody          *pBody=NULL;
    IStream            *pStream=NULL;
    PROPVARIANT         rVariant;
    HANDLE              hFile=INVALID_HANDLE_VALUE;
    ULONG               cbTotal;
    CHAR                szFilePath[MAX_PATH + MAX_PATH];
    ULONG               cch;
    BOOL                fReturnAbort=FALSE;
    LPTEMPFILEINFO      pTempFile;
    SHELLEXECUTEINFO    rExecute;
    DWORD               cc = 0;

    TraceCall("CBody::TranslateUrl");


    if (m_pParentDocHostUI)
        {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->TranslateUrl(dwTranslate, pwszUrlIn, ppwszUrlOut);
        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
        }

    // Init
    *ppwszUrlOut = NULL;

    if (NULL == pwszUrlIn || NULL == ppwszUrlOut)
        return TraceResult(E_INVALIDARG);

    // No Message Object
    if ((NULL == m_pMsg) || (NULL == m_pMsgW))
        return S_FALSE;

    // If pwszUrlIn is not already an mhtml: url
    if (StrCmpNIW(pwszUrlIn, L"mhtml:", 6) != 0)
        return S_FALSE;

    // Convert To ANSI
    pszUrlIn = PszToANSI(CP_ACP, pwszUrlIn);
    if (!pszUrlIn)
        {
        hr = E_OUTOFMEMORY;
        goto error;
        }

    // UnEscape the Url
    hr = UrlUnescapeA(pszUrlIn, NULL, NULL, URL_UNESCAPE_INPLACE);
    if (FAILED(hr))
        goto error;

    // Split It
    hr = MimeOleParseMhtmlUrl(pszUrlIn, NULL, &pszBodyUrl);
    if (FAILED(hr))
        goto error;

    // Resolve the body url
    hr = m_pMsg->ResolveURL(NULL, NULL, pszBodyUrl, 0, &hBody);
    if (FAILED(hr))
        goto error;

    // Get an IMimeBody
    hr = m_pMsg->BindToObject(hBody, IID_IMimeBody, (LPVOID *)&pBody);
    if (FAILED(hr))
        goto error;

    // Abort
    fReturnAbort = TRUE;

    // If HTML, then write the entire message source to a temp file and return an mhtml url
    if (pBody->IsContentType(STR_CNT_TEXT, STR_SUB_HTML) == S_OK)
        {
        // Get ixplorer.exe path
        GetExePath(c_szIexploreExe, szBuffer, ARRAYSIZE(szBuffer), FALSE);

        // Set command line
        pszCommandLine = szBuffer;

        // Get a Stream
        hr = m_pMsg->GetMessageSource(&pStream, 0);
        if (FAILED(hr))
            goto error;

        // Init Variant
        rVariant.vt = VT_LPSTR;

        // Get a filename from the message object
        hr = m_pMsg->GetProp(PIDTOSTR(PID_ATT_GENFNAME), 0, &rVariant);
        if (FAILED(hr))
            goto error;

        // Save pszFilePath
        pszGenFName = rVariant.pszVal;

        // Create temp file
        hr = CreateTempFile(pszGenFName, c_szMHTMLExt, &pszFilePath, &hFile);
        if (FAILED(hr))
            goto error;

        // Write the stream to a file
        hr = WriteStreamToFileHandle(pStream, hFile, &cbTotal);
        if (FAILED(hr))
            goto error;

        // Build: mhtml:(pszFilePath)!pszBodyUrl
		cc = lstrlen(c_szMHTMLColon) + lstrlen(c_szFileUrl) + lstrlen(pszFilePath) + 1 + lstrlen(pszBodyUrl) + 1;
        pszParameters = PszAllocA(cc);
        if (!pszParameters)
            {
            hr = E_OUTOFMEMORY;
            goto error;
            }
    
        // Build pszParameters
        wnsprintf(pszParameters, cc, "%s%s%s!%s", c_szMHTMLColon, c_szFileUrl, pszFilePath, pszBodyUrl);
    }
    
    // Otherwise, dump the body data to a temp file and return a url to it
    else
    {
        // Get a Stream
        hr = pBody->GetData(IET_INETCSET, &pStream);
        if (FAILED(hr))
            goto error;

        // Set sizeof szFilePath
        cch = ARRAYSIZE(szFilePath);

        // If cid:
        if (StrCmpNIA(pszBodyUrl, "cid:", 4) == 0 || FAILED(PathCreateFromUrlA(pszBodyUrl, szFilePath, &cch, 0)))
        {
            // Init Variant
            rVariant.vt = VT_LPSTR;

            // Get a filename from the message object
            hr = pBody->GetProp(PIDTOSTR(PID_ATT_GENFNAME), 0, &rVariant);
            if (FAILED(hr))
                goto error;

            // Save pszFilePath
            pszGenFName = rVariant.pszVal;

            // Create temp file
            hr = CreateTempFile(pszGenFName, NULL, &pszFilePath, &hFile);
            if (FAILED(hr))
                goto error;

        }
        else
        {
            // Create temp file
            hr = CreateTempFile(szFilePath, NULL, &pszFilePath, &hFile);
            if (FAILED(hr))
                goto error;

        }

        // Write the stream to a file
        hr = WriteStreamToFileHandle(pStream, hFile, &cbTotal);
        if (FAILED(hr))
            goto error;

        // Build: file://(pszFilePath)
		cc = lstrlen(c_szFileUrl) + lstrlen(pszFilePath) + 1;
        pszUrlOut = PszAllocA(cc);
        if (FAILED(hr))
            goto error;

        // Build pszUrlOut
        wnsprintf(pszUrlOut, cc, "%s%s", c_szFileUrl, pszFilePath);

        // Set the pszCommandLine
        pszCommandLine = pszUrlOut;
    }

    // Close the file - the file must get closed here (i.e. after the call to MimeOleCleanupTempFiles)
    FlushFileBuffers(hFile);
    CloseHandle(hFile);
    hFile = INVALID_HANDLE_VALUE;

    // Is this file safe to run ?
    hr = MimeEditIsSafeToRun(m_hwnd, pszFilePath, FALSE);
    if (FAILED(hr))
        goto error;

    // SaveAs
    if (MIMEEDIT_S_OPENFILE == hr)
    {
        // Locals
        OPENFILENAME    ofn;
        TCHAR           szTitle[CCHMAX_STRINGRES];
        TCHAR           szFilter[CCHMAX_STRINGRES];
        TCHAR           szFile[MAX_PATH];

        // Init
        *szFile=0;
        *szFilter=0;
        *szTitle=0;

        // Copy filename
        StrCpyN(szFile, pszFilePath, ARRAYSIZE(szFile));

        // Init Open file structure
        ZeroMemory (&ofn, sizeof(OPENFILENAME));
        ofn.lStructSize = sizeof(OPENFILENAME);
        ofn.hwndOwner = m_hwnd;
        LoadString(g_hLocRes, idsFilterAttSave, szFilter, sizeof(szFilter));
        ReplaceChars(szFilter, '|', '\0');
        ofn.lpstrFilter = szFilter;
        ofn.nFilterIndex = 1;
        ofn.lpstrFile = szFile;
        ofn.nMaxFile = sizeof (szFile);
        LoadString(g_hLocRes, idsSaveAttachmentAs, szTitle, sizeof(szTitle));
        ofn.lpstrTitle = szTitle;
        ofn.Flags = OFN_NOCHANGEDIR | OFN_NOREADONLYRETURN | OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;

        // Show SaveAs Dialog
        if (HrAthGetFileName(&ofn, FALSE) == S_OK)
        {
            // If the same...
            if (lstrcmpi(pszFilePath, szFile) == 0)
            {
                // Just free pszfilePath so that we don't delete it
                SafeMemFree(pszFilePath);
            }

            // Copy the file - Overwrite
            else
                CopyFile(pszFilePath, szFile, FALSE);
        }

        // Done
        goto error;
    }

    // Must be trying to execute the file
    hr = MimeEditVerifyTrust(m_hwnd, PathFindFileName(pszFilePath), pszFilePath);
    if (FAILED(hr))
        goto error;

    // Setup the Shell Execute Structure
    ZeroMemory (&rExecute, sizeof(SHELLEXECUTEINFO));
    rExecute.cbSize = sizeof(SHELLEXECUTEINFO);
    rExecute.fMask = SEE_MASK_NOCLOSEPROCESS;
    rExecute.hwnd = m_hwnd;
    rExecute.nShow = SW_SHOWNORMAL;
    rExecute.lpFile = pszCommandLine;
    rExecute.lpVerb = NULL;
    rExecute.lpParameters = pszParameters;

    // Execute the File
    TraceInfoSideAssert((0 != ShellExecuteEx(&rExecute)), _MSG("ShellExecuteEx failed - GetLastError() = %d\n", GetLastError()));

    // Add the temp file to the list
    if (SUCCEEDED(AppendTempFileList(&m_pTempFileUrl, pszFilePath, rExecute.hProcess)))
        pszFilePath = NULL;

error:
    // Cleanup
    SafeRelease(pBody);
    SafeRelease(pStream);
    SafeMemFree(pszUrlIn);
    SafeMemFree(pszBodyUrl);
    SafeMemFree(pszFree);
    SafeMemFree(pszUrlOut);
    SafeMemFree(pszGenFName);
    SafeMemFree(pszParameters);

    // Close the file - the file must get closed here (i.e. after the call to MimeOleCleanupTempFiles)
    if (INVALID_HANDLE_VALUE != hFile)
        CloseHandle(hFile);

    // If we still have pszFilePath, delete the file
    if (pszFilePath)
    {
        DeleteFile(pszFilePath);
        g_pMalloc->Free(pszFilePath);
    }

    // Done
    return (TRUE == fReturnAbort) ? E_ABORT : S_FALSE;
}

//+---------------------------------------------------------------
//
//  Member:     FilterDataObject
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::FilterDataObject(IDataObject *pDO, IDataObject **ppDORet)
{
    IDataObject     *pDataObjNew = NULL;
    HRESULT         hr = S_FALSE;
    STGMEDIUM       stgmed;
    DATAOBJINFO*    pInfo = 0;
    DATAOBJINFO*    pInfoCopy = 0;
    FORMATETC       fetc = {0};
    LPBYTE          pCopy=0;
    INT             i, j, cFormats=0;
    USHORT          cfFormat[2] = 
                            {CF_TEXT, CF_UNICODETEXT};
    LPBYTE          lpsz[2]={0};
    ULONG           lStreamLength[2]={0};

    TraceCall("CBody::FilterDataObject");

    if (m_pParentDocHostUI)
        {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->FilterDataObject(pDO, ppDORet);
        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
        }

    if (!m_fPlainMode || !m_fDesignMode)
        return S_FALSE;

    if (pDO==NULL || ppDORet==NULL)
        return S_FALSE;

    *ppDORet = NULL;

    for (i=0; i<ARRAYSIZE(cfFormat); i++)
        {
        // get the plain-text
        fetc.cfFormat=cfFormat[i];
        fetc.dwAspect=DVASPECT_CONTENT;
        fetc.tymed=TYMED_HGLOBAL;
        fetc.lindex=0;

        hr=pDO->QueryGetData(&fetc);
        if(FAILED(hr))
            continue;

        ZeroMemory(&stgmed, sizeof(stgmed));
        hr=pDO->GetData(&fetc, &stgmed);
        if(FAILED(hr))
            goto cleanloop;

        Assert(stgmed.hGlobal);

        // make a copy of the plain text string.
        pCopy = (LPBYTE)GlobalLock(stgmed.hGlobal);

        if (!pCopy)
            {
            hr=E_FAIL;
            goto cleanloop;
            }

        if(fetc.cfFormat == CF_TEXT)
            lStreamLength[i] = lstrlen((LPSTR)pCopy) + 1;
        else
            lStreamLength[i] =  sizeof(WCHAR) * (lstrlenW((LPWSTR)pCopy)+1);

        if (!MemAlloc((LPVOID*)&lpsz[i], lStreamLength[i]))
            {
            hr = E_OUTOFMEMORY;
            goto cleanloop;
            }

        CopyMemory(lpsz[i], pCopy, lStreamLength[i]);
        GlobalUnlock(stgmed.hGlobal);
        cFormats++;

cleanloop:
        // addref the pUnk as it will be release in releasestgmed
        if(stgmed.pUnkForRelease)
            stgmed.pUnkForRelease->AddRef();
        ReleaseStgMedium(&stgmed);
        if(FAILED(hr))
            goto error;
        }

    if(cFormats == 0)
        {
        hr = E_FAIL;
        goto error;
        }

    if (!MemAlloc((LPVOID*)&pInfo, sizeof(DATAOBJINFO)*cFormats))
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    ZeroMemory(pInfo, sizeof(DATAOBJINFO)*cFormats);

    j = 0;
    for(i=0; i<ARRAYSIZE(cfFormat); i++)
        {
        if(lpsz[i] != 0)
            {
            SETDefFormatEtc(pInfo[j].fe, cfFormat[i], TYMED_HGLOBAL);
            pInfo[j].pData = lpsz[i];
            pInfo[j].cbData = lStreamLength[i];
            j++;
            }
        }
    Assert(j == cFormats);

    hr = CreateDataObject(pInfo, cFormats, (PFNFREEDATAOBJ)FreeDataObj, &pDataObjNew);
    if (FAILED(hr))
        goto error;

    //CDataObject will free this now it accepted it
    for(i=0; i<ARRAYSIZE(cfFormat); i++)
        lpsz[i]=NULL;
    pInfo=NULL;
    *ppDORet = pDataObjNew;
    pDataObjNew = NULL;

error:
    for(i=0; i<ARRAYSIZE(cfFormat); i++)
        SafeMemFree(lpsz[i]);
    SafeMemFree(pInfo);     
    ReleaseObj(pDataObjNew);
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     TranslateAccelerator
//
//  Synopsis:   
//              Trident calls the host first before handling an 
//              accelerator. If we return S_OK, it assumes we handled
//              it and carries on. If we return S_FALSE it assumes 
//              we don't care, and it will do it's own action
//
//---------------------------------------------------------------
HRESULT CBody::TranslateAccelerator(LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID)
{
    HRESULT hr;

    TraceCall("CBody::TranslateAccelerator");

    if (m_pParentDocHostUI)
        {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->TranslateAccelerator(lpMsg, pguidCmdGroup, nCmdID);
        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
        }

    // commands which are always available
    switch (nCmdID)
    {
        case 0:
        case IDM_CUT:
        case IDM_COPY:
        case IDM_PASTE:
        case IDM_PASTEINSERT:
        case IDM_DELETE:
        case IDM_DELETEWORD:
        case IDM_SELECTALL:
        case IDM_UNDO:
        case IDM_REDO:
        case IDM_CHANGECASE:
        case IDM_NONBREAK:
            return S_FALSE;
    }

    // commands only available in HTML edit mode
    if (!m_fPlainMode)
    {
        switch  (nCmdID)
        {
            case IDM_BOLD:
            case IDM_UNDERLINE:
            case IDM_ITALIC:
            case IDM_REMOVEFORMAT:
            case IDM_CENTERALIGNPARA:
            case IDM_LEFTALIGNPARA:
            case IDM_RIGHTALIGNPARA:
            case IDM_REMOVEPARAFORMAT:
            case IDM_APPLYNORMAL:
                return S_FALSE;
        }
    }

    if (nCmdID)
        m_fIgnoreAccel = 1;
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     GetOptionKeyPath
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::GetOptionKeyPath(LPOLESTR * pstrKey, DWORD dw)
{
    HRESULT     hr;
    TCHAR       rgch[MAX_PATH];

    TraceCall("CBody::GetOptionKeyPath");

    if (m_pParentDocHostUI)
        {
        // see if parent dochostUIhandler want's to handle. If not they will return _DODEFAULT
        hr = m_pParentDocHostUI->GetOptionKeyPath(pstrKey, dw);
        if (hr==S_OK)
            {
            WideCharToMultiByte(CP_ACP, 0, (WCHAR*)*pstrKey, -1, rgch, ARRAYSIZE(rgch), NULL, NULL);
            CreateFontCache(rgch);
            }

        if (hr != MIMEEDIT_E_DODEFAULT)
            return hr;
        }

    CreateFontCache(NULL);
    return E_NOTIMPL;
}


//+---------------------------------------------------------------
//
//  Member:     EnsureLoaded
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::EnsureLoaded()
{
    HRESULT hr=NOERROR;

    TraceCall("CBody::EnsureLoaded");

    if (!m_lpOleObj)
        {
        hr=CDocHost::CreateDocObj((LPCLSID)&CLSID_HTMLDocument);
        if(FAILED(hr))
            goto error;

        hr = CDocHost::Show();
        if(FAILED(hr))
            goto error;

        Assert (!m_pDoc);

        hr = m_lpOleObj->QueryInterface(IID_IHTMLDocument2, (LPVOID *)&m_pDoc);
        if (FAILED(hr))
            goto error;

        hr = RegisterLoadNotify(TRUE);
        if (FAILED(hr))
            goto error;

        if (m_pFmtBar)
            m_pFmtBar->SetCommandTarget(m_pCmdTarget);
	}

error:
    return hr;
}



//+---------------------------------------------------------------
//
//  Member:     RegisterLoadNotify
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::RegisterLoadNotify(BOOL fRegister)
{
    IConnectionPointContainer   *pCPContainer;
    IConnectionPoint            *pCP;
    HRESULT                     hr=E_FAIL;

    TraceCall("CBody::RegisterLoadNotify");

    if (!m_pDoc)
        return E_FAIL;

    if (m_pDoc)
        {
        hr = m_pDoc->QueryInterface(IID_IConnectionPointContainer, (LPVOID *)&pCPContainer);
        if (!FAILED(hr))
            {
            hr = pCPContainer->FindConnectionPoint(IID_IPropertyNotifySink, &pCP);
            if (!FAILED(hr))
                {
                if (fRegister)
                    {
                    Assert(m_dwNotify == 0);
                    hr = pCP->Advise((IPropertyNotifySink *)this, &m_dwNotify);
                    }
                else
                    {
                    if (m_dwNotify)
                        {
                        hr = pCP->Unadvise(m_dwNotify);
                        m_dwNotify=0;
                        }
                    }
                pCP->Release();
                }        
            pCPContainer->Release();
            }
        }
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     OnChanged
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::OnChanged(DISPID dispid)
{
    TraceCall("CBody::OnChanged");

    if (dispid == DISPID_READYSTATE)
        OnReadyStateChanged();
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     OnRequestEdit
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::OnRequestEdit (DISPID dispid)
{
    TraceCall("CBody::OnRequestEdit");

    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     OnReadyStateChanged
//
//  Synopsis:   
//
//---------------------------------------------------------------
void CBody::OnReadyStateChanged()
{
    HRESULT     hr = S_OK;
    VARIANT     Var;
    IDispatch * pdisp;

    TraceCall("CBody::OnReadyStateChanged");

    if (NULL == m_lpOleObj)
        return;

    if (m_lpOleObj->QueryInterface(IID_IDispatch, (void **)&pdisp)==S_OK)
        {
        if (GetDispProp(pdisp, DISPID_READYSTATE, 0, &Var, NULL)==S_OK)
            {
            // maybe either I4 or I2
            Assert (Var.vt == VT_I4 || Var.vt == VT_I2);
            // we get the ready state so we can warn about sending while downloading
            m_dwReadyState = Var.lVal;
            }
        pdisp->Release();
        }
}

//+---------------------------------------------------------------
//
//  Member:     OnDocumentReady
//
//  Synopsis:   
//
//---------------------------------------------------------------
void CBody::OnDocumentReady()
{
    DWORD   dwFlags;
	
    // quick-scan for CID's not requested before ParseComplete
    if (m_fLoading && !m_fReloadingSrc)
        SearchForCIDUrls();
	
    // send a notification up to the parent
    if (m_pParentCmdTarget)
        m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_ONPARSECOMPLETE, 0, NULL, NULL);
	
    if (m_fAutoDetect)
        StartAutoDetect();
	
#ifdef PLUSPACK
	// Test for new Trident backgound spell check
	if(m_fDesignMode && !m_pBkgSpeller && m_pDoc)
	{
		HRESULT hr = S_OK;
		IHTMLElement     * pElement = NULL;
		IHTMLBodyElement * pBodyElement = NULL;
		IHTMLTxtRange    * pRange = NULL;
		
		//
		// Create the speller
		//
		CHECKHR(hr = CoCreateInstance(CLSID_HTMLSpell, NULL, CLSCTX_INPROC_SERVER,
				IID_IHTMLSpell, (LPVOID*)&m_pBkgSpeller));
		
		//
		// Attach the speller
		//
		
		CHECKHR(hr = m_pDoc->get_body(&pElement));
		
		CHECKHR(hr = m_pBkgSpeller->SetDoc(m_pDoc) );
		CHECKHR(hr = m_pBkgSpeller->Attach(pElement) );
		
		//
		// Mark current content as clean
		//
		
		CHECKHR(hr = pElement->QueryInterface(IID_IHTMLBodyElement, (LPVOID *)&pBodyElement) );
		CHECKHR(hr = pBodyElement->createTextRange(&pRange) );
		CHECKHR(hr = m_pBkgSpeller->MarkRegion((IDispatch *)pRange, TRUE /* fSpellable */) );
		
exit:
		// just cannot load background speller...
		if(FAILED(hr))
			Assert(FALSE);
		
		SafeRelease(pRange);
		SafeRelease(pBodyElement);
		SafeRelease(pElement);
//		return; //(S_OK);
	}
#endif //PLUSPACK
	
#ifdef BACKGROUNDSPELL
	HrCreateSpeller(TRUE);
#endif // BACKGROUNDSPELL
	
    if (m_fLoading && !m_fReloadingSrc)
    {
        // OnDocumentReady can be called >1 times during a load. We use m_fLoading to keep track so
        // we only do this init once.
        
        // paste in the reply header and auto-text on the first download notification.
        if (m_fDesignMode)
        {
            if (m_fForceCharsetLoad)
            {
                TCHAR               rgchCset[CCHMAX_CSET_NAME];
				
                if (SUCCEEDED(HrGetMetaTagName(m_hCharset, rgchCset, ARRAYSIZE(rgchCset))))
                {
                    BSTR bstr;
                    if (SUCCEEDED(HrLPSZToBSTR(rgchCset, &bstr)))
                    {
                        m_pDoc->put_charset(bstr);
                        SysFreeString(bstr);
                    }
                }
            }
			
            // if the host wants to to not send images that originate from an external source
            // then tag them as such now.
            if (GetHostFlags(&dwFlags)==S_OK &&
                !(dwFlags & MEO_FLAGS_SENDEXTERNALIMGSRC))
            {
                SafeRelease(m_pHashExternal);
                HashExternalReferences(m_pDoc, m_pMsg, &m_pHashExternal);
            }
            
            if (!m_fPlainMode)
            {
                SetHostComposeFont();
                SetWindowBgColor(FALSE);
            }
        }
        
        PasteReplyHeader();
        PasteAutoText();
        
        ClearUndoStack();
        ClearDirtyFlag();
        
        // if we get a load notify and we're the previewpane, show the attachment clip
        if (m_uHdrStyle == MESTYLE_PREVIEW)
        {
            UpdateBtnBar();
            UpdatePreviewLabels();
        }
        m_fLoading=0;
    }
    
    m_fMessageParsed=1;
    m_fReloadingSrc=FALSE;
    
}

//+---------------------------------------------------------------
//
//  Member:     SetRect
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::SetRect(LPRECT prc)
{
    TraceCall("CBody::SetRect");

    SetWindowPos(m_hwnd, NULL, prc->left, prc->top, prc->right-prc->left, prc->bottom-prc->top, SWP_NOZORDER);
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     GetRect
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::GetRect(LPRECT prcView)
{
    TraceCall("CBody::GetRect");

    if (prcView == NULL)
        return E_INVALIDARG;

    Assert (IsWindow(m_hwnd));

    GetClientRect(m_hwnd, prcView);
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     UIActivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::UIActivate(BOOL fUIActivate)
{
    TraceCall("CBody::UIActivate");

    if(!m_pDocView)
        return S_OK;

    return m_pDocView->UIActivate(fUIActivate);
}


//+---------------------------------------------------------------
//
//  Member:     Exec
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    TraceCall("CBody::Exec");

    if (pguidCmdGroup && 
        IsEqualGUID(CMDSETID_Forms3, *pguidCmdGroup))
        {
        if (nCmdID == IDM_PARSECOMPLETE)
            {
            OnDocumentReady();
            return S_OK;
            }
        }
    
    if (pguidCmdGroup==NULL)
        {
        switch (nCmdID)
            {
            case OLECMDID_UPDATECOMMANDS:
                UpdateCommands();
                break;
            }
        }        
    return CDocHost::Exec(pguidCmdGroup, nCmdID, nCmdExecOpt, pvaIn, pvaOut);
}



//+---------------------------------------------------------------
//
//  Member:     GetClassID
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::GetClassID(CLSID *pCLSID)
{
    TraceCall("CBody::GetClassID");

    *pCLSID = CLSID_MimeEdit;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     Load
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::Load(IMimeMessage *pMsg)
{
    BODYINITDATA    biData;

    TraceCall("CBody::Load");

    if (pMsg == NULL)
        return TraceResult(E_INVALIDARG);

    biData.dwType = BI_MESSAGE;
    biData.pMsg = pMsg;

    return LoadFromData(&biData);
}

//+---------------------------------------------------------------
//
//  Member:     Save
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::Save(IMimeMessage *pMsg, DWORD dwFlags)
{
    HRESULT                 hr;
    DWORD                   dwMHTMLFlags=0,
                            dwHostFlags;

    TraceCall("CBody::Save");

    if (pMsg==NULL)
        return E_INVALIDARG;

    if (!m_lpOleObj)
        return CO_E_NOT_SUPPORTED;


    if (m_uSrcView != MEST_EDIT)
        return TraceResult(MIMEEDIT_E_CANNOTSAVEWHILESOURCEEDITING);

    if (!((dwFlags & PMS_HTML) || (dwFlags & PMS_TEXT)))
        return TraceResult(MIMEEDIT_E_ILLEGALBODYFORMAT);

    // if trident is not yet done parsing the HTML, we cannot safely save from the tree. 
    if (!m_fMessageParsed)
        return MIMEEDIT_E_CANNOTSAVEUNTILPARSECOMPLETE;
        
    if(dwFlags & PMS_HTML)
        dwMHTMLFlags |= MECD_HTML;

    if(dwFlags & PMS_TEXT)
        dwMHTMLFlags |= MECD_PLAINTEXT;

    if ((GetHostFlags(&dwHostFlags)==S_OK) &&
        (dwHostFlags & MEO_FLAGS_SENDIMAGES))
        dwMHTMLFlags |= MECD_ENCODEIMAGES|MECD_ENCODESOUNDS|MECD_ENCODEVIDEO|MECD_ENCODEPLUGINS;

    // turn off sound-playing during a save
    EnableSounds(FALSE);
    hr = SaveAsMHTML(m_pDoc, dwMHTMLFlags, m_pMsg, pMsg, m_pHashExternal);
    EnableSounds(TRUE);
    // if save was sucessful, but we haven't yet had a readystate complete notify then
    // bubble a warning backup to give the user a chance to cancel.
    if (hr==S_OK)
        {
        if (m_dwReadyState != READYSTATE_COMPLETE)
            hr = MIMEEDIT_W_DOWNLOADNOTCOMPLETE;
        else
            ClearDirtyFlag();   // clear dirty flag if OK with no warnings.
        }

    return hr;
}

HRESULT CBody::Load(BOOL fFullyAvailable, IMoniker *pMoniker, IBindCtx *pBindCtx, DWORD grfMode)
{
    IMimeMessage       *pMsg=0;
    IPersistMoniker    *pMsgMon=0;
    HRESULT             hr;
    BODYINITDATA        biData;
    LPWSTR              pszUrlW=0;

    if (!pMoniker)
        return E_INVALIDARG;

    if (pMoniker->GetDisplayName(NULL, NULL, &pszUrlW)==S_OK &&
        HrSniffUrlForRfc822(pszUrlW)==S_OK)
        {
        // if its a message moniker, load via IMimeMessage
        hr = CoCreateInstance(CLSID_IMimeMessage, NULL, CLSCTX_INPROC_SERVER, IID_IMimeMessage, (LPVOID *)&pMsg);
        if (FAILED(hr))
            goto error;

        hr = pMsg->QueryInterface(IID_IPersistMoniker, (LPVOID*)&pMsgMon);
        if (FAILED(hr))
            goto error;

        hr = pMsgMon->Load(fFullyAvailable, pMoniker, pBindCtx, grfMode);
        if (FAILED(hr))
            goto error;

        biData.dwType = BI_MESSAGE;
        biData.pMsg = pMsg;
        }
    else
        {
        biData.dwType = BI_MONIKER;
        biData.pmk = pMoniker;
        }

    hr = LoadFromData(&biData);

error:
    SafeRelease(pMsg);
    SafeRelease(pMsgMon);
    SafeMemFree(pszUrlW);
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     IsDirty
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::IsDirty()
{
    IPersistStreamInit  *ppsi;
    HRESULT hr=S_FALSE;

    TraceCall("CBody::IsDirty");

    // if we're not on the source-tab, use the old dirty-state
    // if we're on richedit, make sure to see if source changes there
    switch (m_uSrcView)
    {
        case MEST_SOURCE:
            Assert (m_pSrcView);
            return m_pSrcView->IsDirty();

        case MEST_PREVIEW:
            return m_fWasDirty ?S_OK:S_FALSE;
    }

    if (m_lpOleObj && 
        m_lpOleObj->QueryInterface(IID_IPersistStreamInit, (LPVOID *)&ppsi)==S_OK)
        {
        hr = ppsi->IsDirty();
        ppsi->Release();
        }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     LoadStream
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::LoadStream(LPSTREAM pstm)
{
    HRESULT         hr;
    BODYINITDATA    biData;
    IMimeMessage    *pMsg;

    TraceCall("CBody::LoadStream");

    if (pstm == NULL)
        return TraceResult(E_INVALIDARG);

    // convert RFC822 stream into message
    hr = MimeOleCreateMessage(NULL, &pMsg);
    if (!FAILED(hr))
        {
        hr = pMsg->Load(pstm);
        if (!FAILED(hr))
            {
            biData.dwType = BI_MESSAGE;
            biData.pMsg = pMsg;
            hr = LoadFromData(&biData);
            }
        pMsg->Release();
        }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     LoadFromData
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::LoadFromData(LPBODYINITDATA  pbiData)
{
    HRESULT         hr;
    LPMONIKER       pmk=0;
    IMimeMessage    *pMsg;
    DWORD           dwMsgFlags;

    TraceCall("CBody::LoadFromData");

    AssertSz(pbiData && 
            (   (pbiData->dwType == BI_MESSAGE && pbiData->pMsg) || 
                (pbiData->dwType == BI_MONIKER && pbiData->pmk)), 
                "Caller should be validating params");

    Assert (m_lpOleObj);

    // make sure we're unloaded in case of failure
    UnloadAll();

    switch (pbiData->dwType)
    {
        case BI_MESSAGE:
        {
            WEBPAGEOPTIONS  rOptions;
            BOOL            fIncludeMsg;
            BOOL            fDisplayingHtmlHelp = FALSE;
            BOOL            fGotHtmlHelpCharset = FALSE;
            VARIANTARG      va;

            pMsg = pbiData->pMsg;
            Assert(pMsg);
        
            if(SUCCEEDED(m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_HTML_HELP, 0, NULL, &va)))
                fDisplayingHtmlHelp = (va.boolVal == VARIANT_TRUE);

            if(fDisplayingHtmlHelp)
            {
                IStream     *pStream=NULL;
                LPSTR       pszCharset=NULL;

                if(SUCCEEDED(pMsg->GetTextBody(TXT_HTML, IET_INETCSET, &pStream, NULL)))
                {
                    if(SUCCEEDED(GetHtmlCharset(pStream, &pszCharset)))
                    {
                        if(SUCCEEDED(MimeOleFindCharset(pszCharset, &m_hCharset)))
                            fGotHtmlHelpCharset = TRUE;
                        MemFree(pszCharset);
                    }

                    pStream->Release();
                }
            }
        
            if(!fGotHtmlHelpCharset)
            {
                // set the character set for use by the preview pane, painting etc
                IF_FAILEXIT(hr = pMsg->GetCharset(&m_hCharset));
            }
        
            Assert(m_hCharset);
        
            GetWebPageOptions(&rOptions, &fIncludeMsg);

            if (m_fReloadingSrc || fIncludeMsg)
            {
                // only do autodetection if a plain-text message. this will occur if the
                // message is plain-text only or the host is denying HTML.
                if ( (pMsg->GetFlags(&dwMsgFlags)==S_OK) &&
                    (!(dwMsgFlags & IMF_HTML) || !(rOptions.dwFlags & WPF_HTML)))
                    m_fAutoDetect = 1;
            
                 // add NOMETACHASET as we setup a HTML load options now
                 rOptions.dwFlags |= WPF_NOMETACHARSET;

                IF_FAILEXIT(hr = pMsg->CreateWebPage(NULL, &rOptions, 0, &pmk));
            
                pmk->GetDisplayName(NULL, NULL, &m_pszUrlW);
            
                IF_FAILEXIT(hr = LoadFromMoniker(pmk, m_hCharset));
            }
            else
            {
                m_fForceCharsetLoad = TRUE;
            }

            IF_FAILEXIT(hr = pMsg->QueryInterface(IID_IMimeMessageW, (LPVOID*)&m_pMsgW));
            ReplaceInterface(m_pMsg, pMsg);
            break;
        }            

        case BI_MONIKER:
            IF_FAILEXIT(hr = LoadFromMoniker(pbiData->pmk, NULL));
            
            pbiData->pmk->GetDisplayName(NULL, NULL, &m_pszUrlW);
            break;
    }

    if (m_uHdrStyle == MESTYLE_PREVIEW)
        UpdatePreviewLabels();

    m_fEmpty=0;

exit:
    ReleaseObj(pmk);
    return hr;
}




//+---------------------------------------------------------------
//
//  Member:     CreateBodyObject
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CreateBodyObject(HWND hwnd, DWORD dwFlags, LPRECT prc, PBODYHOSTINFO pHostInfo, LPBODYOBJ *ppBodyObj)
{
    CBody           *pBody;
    HRESULT         hr;
    
    TraceCall("CreateBodyObject");

    pBody = new CBody();
    if (!pBody)
        return TraceResult(E_OUTOFMEMORY);

    hr = pBody->Init(hwnd, dwFlags, prc, pHostInfo);
    if (FAILED(hr))
        {
        TraceResult(hr);
        goto error;
        }

    *ppBodyObj = pBody;
    pBody->AddRef();

error:
    pBody->Release();
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     UrlHighlight
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::UrlHighlight(IHTMLTxtRange *pRange)
{
    IOleCommandTarget   *pCmdTarget=NULL;
    VARIANT_BOOL        boolVal;

    TraceCall("UrlHighlight");

    if (!pRange)
        return E_INVALIDARG;

    // calling IDM_AUTODETECT will mark the tree dirty, this is bad for replying to plaintext
    // messages etc. To fix this we preserve the dirty between calls.
    boolVal = IsDirty()==S_OK?VARIANT_TRUE:VARIANT_FALSE;
    if (pRange->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&pCmdTarget)==S_OK)
        {
        pCmdTarget->Exec(&CMDSETID_Forms3, IDM_AUTODETECT, NULL, NULL, NULL);
        pCmdTarget->Release();
        HrSetDirtyFlagImpl(m_pDoc, boolVal);
        }
    return S_OK;
}

HRESULT CBody::StartAutoDetect()
{
    m_cchTotal=0;
    m_cchStart=0;
    SetTimer(m_hwnd, idTimerAutoDetect, AUTODETECT_TICKTIME, NULL);
    return S_OK;
}

HRESULT CBody::AutoDetectTimer()
{
    LONG            cch=0;
    IMimeBody       *pBody;
    IMarkupPointer  *pEndPtr=NULL;
    DWORD           dwPercent;
    WCHAR           wsz[CCHMAX_STRINGRES],
                    wszFmt[CCHMAX_STRINGRES],
                    wsz2[CCHMAX_STRINGRES];
    LPWSTR          pszW;
    HBODY           hBody;
    HRESULT         hr;

    TraceCall("AutoDetectTimer");

    // if mouse has capture, then ignore this timer-tick as user might be scrolling etc.
    if (GetCapture())
        return S_OK;

    // turn of the timer, in case it takes a while
    KillTimer(m_hwnd, idTimerAutoDetect);

    // we try and give a rough %age estimate if autodetect is taking forever
    // we get the total size of the plain-stream and divide the auto detect
    // chunk into it. If we overflow, we sit at 100% for a while. Also, we don't show
    // a %age until we've hit at least 2 auto detect timers (ie. a big document)
    if (m_cchStart == AUTODETECT_CHUNK * 2)
    {
        // time to start showing progress.

        Assert (m_cchTotal == 0);
        if (m_pMsg->GetTextBody(TXT_PLAIN, IET_DECODED, NULL, &hBody)==S_OK)
        {
            if (m_pMsg->BindToObject(hBody, IID_IMimeBody, (LPVOID *)&pBody)==S_OK)
            {
                pBody->GetEstimatedSize(IET_BINARY, &m_cchTotal);
                pBody->Release();
            }
        }
    }

    *wsz = 0;
    LoadStringWrapW(g_hLocRes, idsSearchHLink, wsz, ARRAYSIZE(wsz));

    if (m_cchTotal &&
        LoadStringWrapW(g_hLocRes, idsSearchHLinkPC, wszFmt, ARRAYSIZE(wszFmt)))
    {
        dwPercent = ( m_cchStart * 100 / m_cchTotal );
        if (dwPercent > 100)
            dwPercent = 100;
        wnsprintfW(wsz2, ARRAYSIZE(wsz2), wszFmt, dwPercent);
        StrCatBuffW(wsz, wsz2, ARRAYSIZE(wsz));
    }

    SetStatusText(wsz);

    m_fAutoDetect = 0;

    if (m_pAutoStartPtr == NULL)
    {
        // create a starting pointer cache it incase we
        // do chunking
        hr = _CreateRangePointer(&m_pAutoStartPtr);
        if (FAILED(hr))
            goto error;
    }

    // create an end pointer
    hr = _CreateRangePointer(&pEndPtr);
    if (FAILED(hr))
        goto error;

    // set the end poniter to the start pointer
    hr = pEndPtr->MoveToPointer(m_pAutoStartPtr);
    if (FAILED(hr))
        goto error;

    // increment the end pointer by the amount to detect
    cch = AUTODETECT_CHUNK;
    hr = _MovePtrByCch(pEndPtr, &cch);
    if (FAILED(hr))
        goto error;
    
    m_cchStart += cch;

    hr = _UrlHighlightBetweenPtrs(m_pAutoStartPtr, pEndPtr);
    if (FAILED(hr))
        goto error;

    // there must be more to detect, so set the timer
    if (cch >= AUTODETECT_CHUNK)
    {
        m_fAutoDetect = 1;

        // move the cached start pointer to the current end pointer
        hr = m_pAutoStartPtr->MoveToPointer(pEndPtr);
        if (FAILED(hr))
            goto error;
    }

error:    

    if (m_fAutoDetect)
        SetTimer(m_hwnd, idTimerAutoDetect, AUTODETECT_TICKTIME, NULL);
    else
    {
        SetStatusText(NULL);
        SafeRelease(m_pAutoStartPtr);
    }
    
    ReleaseObj(pEndPtr);
    return hr;
}


HRESULT CBody::_MovePtrByCch(IMarkupPointer *pPtr, LONG *pcp)
{
    HRESULT                 hr;
    LONG                    cch,
                            cchDone=0;
    MARKUP_CONTEXT_TYPE     ctxt;

    do
    {
        cch = *pcp - cchDone ;
        
        hr = pPtr->Right(TRUE, &ctxt, NULL, &cch, NULL);
        if (!FAILED(hr))
            cchDone += cch;
    }
    while ( !FAILED(hr) && 
            ctxt != CONTEXT_TYPE_None &&
            cchDone < *pcp);

    *pcp = cchDone;
    return cchDone ? S_OK : E_FAIL;
}


HRESULT CBody::_CreateRangePointer(IMarkupPointer **ppPtr)
{
    IMarkupServices         *pMarkupServices=0;
    IMarkupPointer          *pPtr=0;
    IHTMLBodyElement        *pBodyElem=0;
    IHTMLElement            *pElem=0;
    HRESULT                 hr;

    if (ppPtr == NULL)
        return E_INVALIDARG;

    *ppPtr = 0;

    // get a markup services object
    hr = m_pDoc->QueryInterface(IID_IMarkupServices, (void **) &pMarkupServices);
    if (FAILED(hr))
        goto error;

    hr = pMarkupServices->CreateMarkupPointer(&pPtr);
    if (FAILED(hr))
        goto error;

    // get the body element
    hr = GetBodyElement(&pBodyElem);
    if (FAILED(hr))
        goto error;

    // get right interface
    hr = pBodyElem->QueryInterface(IID_IHTMLElement, (LPVOID *)&pElem);
    if (FAILED(hr))
        goto error;

    // move start pointer to after begining of <BODY> tag
    hr = pPtr->MoveAdjacentToElement(pElem, ELEM_ADJ_AfterBegin);
    if (FAILED(hr))
        goto error;

    // hand back pointers
    *ppPtr = pPtr;
    pPtr = NULL;

error:
    ReleaseObj(pElem);
    ReleaseObj(pBodyElem);
    ReleaseObj(pMarkupServices);
    ReleaseObj(pPtr);
    return hr;
}

HRESULT CBody::_UrlHighlightBetweenPtrs(IMarkupPointer *pStartPtr, IMarkupPointer *pEndPtr)
{
    IMarkupServices     *pMarkupServices=0;
    IHTMLTxtRange       *pRange=0;
    HRESULT             hr;

    // get a markup services object
    hr = m_pDoc->QueryInterface(IID_IMarkupServices, (void **) &pMarkupServices);
    if (FAILED(hr))
        goto error;

    // create a text range
    hr = CreateRange(&pRange);
    if (FAILED(hr))
        goto error;

    // use markup services to move pointers to range 
    hr = pMarkupServices->MoveRangeToPointers(pStartPtr, pEndPtr, pRange);
    if (FAILED(hr))
        goto error;

    // autodetect range
    hr = UrlHighlight(pRange);
    if (FAILED(hr))
        goto error;

error:
    ReleaseObj(pMarkupServices);
    ReleaseObj(pRange);
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     StopAutoDetect
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::StopAutoDetect()
{
    TraceCall("CBody::StopAutoDetect");
    
    if (m_fAutoDetect)
        {
        m_fAutoDetect = 0;
        KillTimer(m_hwnd, idTimerAutoDetect);
        TraceInfo("AutoDetect: CANCELED");
        }
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     UnloadAll
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::UnloadAll()
{
    TraceCall("CBody::UnloadAll");
    
    StopAutoDetect();

    InvalidateRect(m_hwnd, NULL, TRUE);

    if (!m_fEmpty)
        {
        if (m_lpOleObj)
            HrInitNew(m_lpOleObj);

        // if unloading due to a tab-switch in source-view
        // don't blow away our restriction hash
        if (!m_fReloadingSrc)
            SafeRelease(m_pHashExternal);
        
        SafeRelease(m_pAttMenu);
        SafeRelease(m_pMsg);
        SafeRelease(m_pMsgW);
        SafeRelease(m_pRangeIgnoreSpell);
        SafeRelease(m_pAutoStartPtr);
        SafeCoTaskMemFree(m_pszUrlW);
        SafeFreeTempFileList(m_pTempFileUrl);
        
        SafeMimeOleFree(m_pszSubject);
        SafeMimeOleFree(m_pszTo);
        SafeMimeOleFree(m_pszCc);
        SafeMimeOleFree(m_pszFrom);

        // if unloading, clear button-bar
        if (m_uHdrStyle == MESTYLE_PREVIEW)
            UpdateBtnBar();

        m_dwReadyState = READYSTATE_UNINITIALIZED;
        m_fMessageParsed = 0;
        m_fEmpty = 1;
        m_hCharset = NULL;

        }
    m_fLoading =1;
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     LoadFromMoniker
//
//  Synopsis:   
//
//---------------------------------------------------------------

HRESULT CBody::LoadFromMoniker(IMoniker *pmk, HCHARSET hCharset)
{
    HRESULT             hr=E_FAIL;
    LPPERSISTMONIKER    pPMoniker=0;
    LPBC                pbc=0;
    IHtmlLoadOptions    *phlo;
    DWORD               uCodePage=0;
    INETCSETINFO        CsetInfo;

    TraceCall("CBody::LoadFromMoniker");

    Assert (m_lpOleObj);

    hr=m_lpOleObj->QueryInterface(IID_IPersistMoniker, (LPVOID *)&pPMoniker);
    if(FAILED(hr))
        {
        TraceResult(hr);
        goto error;
        }

    hr=CreateBindCtx(0, &pbc);
    if(FAILED(hr))
        {
        TraceResult(hr);
        goto error;
        }

    if (hCharset)
    {
        // caller wants to override document charset
        if (MimeOleGetCharsetInfo(hCharset, &CsetInfo)==S_OK)
            uCodePage = CsetInfo.cpiInternet;

        if (uCodePage &&
            CoCreateInstance(CLSID_HTMLLoadOptions, NULL, CLSCTX_INPROC_SERVER,
                                IID_IHtmlLoadOptions, (void**)&phlo)==S_OK)
        {
            if (SUCCEEDED(phlo->SetOption(HTMLLOADOPTION_CODEPAGE, 
                                    &uCodePage, sizeof(uCodePage))))
                pbc->RegisterObjectParam(L"__HTMLLOADOPTIONS", phlo);
            phlo->Release();
        }
    }

    hr=pPMoniker->Load(TRUE, pmk, pbc, STGM_READWRITE);
    if(FAILED(hr))
        {
        TraceResult(hr);
        goto error;
        }
error:
    ReleaseObj(pPMoniker);
    ReleaseObj(pbc);
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     OnFrameActivate
//
//  Synopsis:   
//
//---------------------------------------------------------------

HRESULT CBody::OnFrameActivate(BOOL fActivate)
{
    TraceCall("CBody::OnFrameActivate");
    
    if (m_pInPlaceActiveObj)
        m_pInPlaceActiveObj->OnFrameWindowActivate(fActivate);
    
    // enable/disable sounds on frame activation
    EnableSounds(fActivate);
    return S_OK;
}


BOOL CBody::IsEmpty()
{
    BOOL fEmpty = FALSE;
    if (!m_fDesignMode)
    {
        if (m_fEmpty)
            fEmpty = TRUE;
    }

    /*
    ** We need to come up with a good way to test if the text is
    ** empty. The test below always returns FALSE because of an nbsp
    ** that is in the text. If a better algorithm can be found, then 
    ** we can reimplement this. The case that will hit this is posting
    ** a news note without any text. This should generate a TRUE.
    else
    {
        IHTMLElement    *pElem=0;
        IHTMLTxtRange   *pTxtRangeBegin = NULL,
                        *pTxtRangeEnd = NULL;

        m_pDoc->get_body(&pElem);
        if (pElem)
        {
            if (SUCCEEDED(CreateRange(&pTxtRangeBegin)))
            {
                pTxtRangeBegin->collapse(VARIANT_TRUE);
                if (SUCCEEDED(CreateRange(&pTxtRangeEnd)))
                {
                    pTxtRangeEnd->collapse(VARIANT_FALSE);
                    VARIANT_BOOL varBool = VARIANT_FALSE;
                    if (SUCCEEDED(pTxtRangeBegin->isEqual(pTxtRangeEnd, &varBool)) && (VARIANT_TRUE == varBool))
                        fEmpty = TRUE;
                    pTxtRangeEnd->Release();
                }
                pTxtRangeBegin->Release();
            }
            pElem->Release();
        }
    }
    */
    return fEmpty;
}

//+---------------------------------------------------------------
//
//  Member:     CBody::PrivateQueryStatus
//
//  Synopsis:   Private IOleCmdTarget called from the outer document
//              to implement CDoc::CmdTarget
//
//---------------------------------------------------------------
HRESULT CBody::PrivateQueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{
    ULONG   uCmd;
    HRESULT hr=E_FAIL;
    OLECMD  *pCmd;
    ULONG   uCmdDisable;
    static const UINT c_rgcmdIdNoPlain[] = 
    {
        IDM_INDENT, IDM_OUTDENT, IDM_FONT, IDM_BLOCKFMT, IDM_IMAGE, 
        IDM_HORIZONTALLINE, IDM_UNLINK, IDM_HYPERLINK
    };



    TraceCall("CBody::PrivateQueryStatus");

    if (m_uSrcView != MEST_EDIT &&
        m_pSrcView &&
        m_pSrcView->QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText)==S_OK)
        return S_OK;

    if (pguidCmdGroup == NULL)
    {
        if (m_pCmdTarget)
            hr = m_pCmdTarget->QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);
        
        for (uCmd=0; uCmd < cCmds; uCmd++)
        {
            pCmd = &prgCmds[uCmd];
            switch(pCmd->cmdID)
            {
            case OLECMDID_PRINT:
                // if we have no m_pMsg, disable the print verb
                if (!m_pMsg)
                    pCmd->cmdf=OLECMDF_SUPPORTED;
                break;
                
            case OLECMDID_FIND:
                pCmd->cmdf=OLECMDF_ENABLED|OLECMDF_SUPPORTED;
                hr = S_OK;
                break;
                
            case OLECMDID_SPELL:
                pCmd->cmdf=OLECMDF_SUPPORTED;
                
                if ((m_uSrcView == MEST_EDIT) && FCheckSpellAvail(m_pParentCmdTarget))
                    pCmd->cmdf |= OLECMDF_ENABLED;
				hr = S_OK;
                break;
            }
        }
        // delegate standard group to trident
    }
    else if (IsEqualGUID(*pguidCmdGroup, CMDSETID_Forms3))
    {
        // delegate Forms3 group to trident
        if (m_pCmdTarget)
            hr = m_pCmdTarget->QueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);
        
        // post-process triden't query status and disable commands that are not
        // available in plain-text mode
        if (m_fPlainMode)
        {
            for (uCmd=0; uCmd < cCmds; uCmd++)
            {
                for (uCmdDisable = 0; uCmdDisable < ARRAYSIZE(c_rgcmdIdNoPlain); uCmdDisable++)
                {
                    if (c_rgcmdIdNoPlain[uCmdDisable] == prgCmds[uCmd].cmdID)
                    {
                        // if enabled, disable it
                        prgCmds[uCmd].cmdf &= ~OLECMDF_ENABLED;
                        break;
                    }
                }
            }
                
        }
    }
    else if (IsEqualGUID(*pguidCmdGroup, CMDSETID_MimeEdit))
    {
        for (uCmd=0; uCmd < cCmds; uCmd++)
        {
            pCmd = &prgCmds[uCmd];
            
            pCmd->cmdf = OLECMDF_SUPPORTED;
            
            switch(pCmd->cmdID)
            {
            case MECMDID_TABLINKS:
            case MECMDID_APPLYDOCUMENT:
            case MECMDID_SAVEASSTATIONERY:
            case MECMDID_DIRTY:
            case MECMDID_INSERTTEXTFILE:
            case MECMDID_FORMATFONT:
            case MECMDID_SETTEXT:
            case MECMDID_DOWNGRADEPLAINTEXT:
            case MECMDID_CHARSET:
            case MECMDID_ROT13:
            case MECMDID_INSERTTEXT:
            case MECMDID_INSERTHTML:
            case MECMDID_BACKGROUNDCOLOR:
            case MECMDID_STYLE:
            case MECMDID_CANENCODETEXT:    
                pCmd->cmdf|=OLECMDF_ENABLED; 
                break;
                
            case MECMDID_SHOWSOURCETABS:
                if (!m_fPlainMode)
                {
                    // source-editing only available in plain-text mode
                    pCmd->cmdf|=OLECMDF_ENABLED; 
                    if (m_fSrcTabs)
                        pCmd->cmdf|=OLECMDF_LATCHED; 
                }
                break;
                
            case MECMDID_EMPTY:
                pCmd->cmdf|=OLECMDF_ENABLED;
             
                if (IsEmpty())
                    pCmd->cmdf|=OLECMDF_LATCHED;
                break;
                
            case MECMDID_EDITHTML:
                pCmd->cmdf|=OLECMDF_ENABLED;
                
                if (!m_fPlainMode)
                    pCmd->cmdf|=OLECMDF_LATCHED;
                break;
                
            case MECMDID_EDITMODE:
                pCmd->cmdf|=OLECMDF_ENABLED;
                
                if (m_fDesignMode)
                    pCmd->cmdf|=OLECMDF_LATCHED;
                
                break;
                
            case MECMDID_SAVEATTACHMENTS:
                EnsureAttMenu();
                if (m_pAttMenu &&
                    m_pAttMenu->HasEnabledAttach()==S_OK)
                    pCmd->cmdf|=OLECMDF_ENABLED;
                break;
                
            case MECMDID_FORMATPARAGRAPH:
                if (!m_fPlainMode)
                    pCmd->cmdf|=OLECMDF_ENABLED;
                break;
                
            default:
                // not a recognised command
                pCmd->cmdf = 0;
                break;                    
            }
        }
        hr = S_OK;
    }
    else
        hr = OLECMDERR_E_UNKNOWNGROUP;
    
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     CBody::PrivateExec
//
//  Synopsis:   Private IOleCmdTarget called from the outer document
//              to implement CDoc::CmdTarget
//
//---------------------------------------------------------------
HRESULT CBody::PrivateExec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    HRESULT     hr=E_FAIL;

    TraceCall("CBody::PrivateExec");

    if (m_uSrcView != MEST_EDIT &&
        m_pSrcView &&
        m_pSrcView->Exec(pguidCmdGroup, nCmdID, nCmdExecOpt, pvaIn, pvaOut)==S_OK)
        return S_OK;

    if (pguidCmdGroup == NULL || IsEqualGUID(*pguidCmdGroup, CMDSETID_Forms3) || IsEqualGUID(*pguidCmdGroup, CGID_ShellDocView))
        {
        switch (nCmdID)
            {
            case OLECMDID_SPELL:
                {
                VARIANTARG  va;
                // tell trident we are bringing up a modal dialog
                // by calling PrivateEnableModeless
                if (!m_pSpell) //no background spellchecking
                    HrCreateSpeller(FALSE);

                if (m_pSpell)
                    {
                    PrivateEnableModeless(FALSE);
#ifdef BACKGROUNDSPELL
                    if (m_fBkgrndSpelling)
                        KillTimer(m_hwnd, idTimerBkgrndSpell);
#endif // BACKGROUNDSPELL
                    hr = m_pSpell->HrSpellChecking(m_pRangeIgnoreSpell, m_hwnd, (OLECMDEXECOPT_DONTPROMPTUSER==nCmdExecOpt)?TRUE:FALSE);
#ifdef BACKGROUNDSPELL
                    if (m_fBkgrndSpelling)
                        SetTimer(m_hwnd, idTimerBkgrndSpell, BKGRNDSPELL_TICKTIME, NULL);
#endif // BACKGROUNDSPELL
                    PrivateEnableModeless(TRUE);
                    }
                }
                return hr;

            case OLECMDID_PRINT: 
                return Print(nCmdExecOpt!=OLECMDEXECOPT_DONTPROMPTUSER, pvaIn);
            
            case OLECMDID_REFRESH:
                return m_pCmdTarget ? m_pCmdTarget->Exec(&CMDSETID_Forms3, IDM_REFRESH, OLECMDEXECOPT_DODEFAULT, NULL, NULL) : E_FAIL; 

            case OLECMDID_FIND:
                // Trident has own private Find, map OLE find to this.
                return m_pCmdTarget ? m_pCmdTarget->Exec(&CMDSETID_Forms3, IDM_FIND, OLECMDEXECOPT_DODEFAULT, NULL, NULL) : E_FAIL; 
            }
        
        // delegate standard commands and trident commandset we don't handle
        // to trident
        return m_pCmdTarget?m_pCmdTarget->Exec(pguidCmdGroup, nCmdID, nCmdExecOpt, pvaIn, pvaOut):E_NOTIMPL;
        }
    else if (IsEqualGUID(*pguidCmdGroup, CMDSETID_MimeEdit))
        {
        hr = E_INVALIDARG;

        switch (nCmdID)
            {
            case MECMDID_SETSOURCETAB:
                if (pvaIn && pvaIn->vt == VT_I4)
                    return SetSourceTabs(pvaIn->lVal);
                else if (pvaOut)
                {
                    pvaOut->vt = VT_I4;
                    pvaOut->lVal = m_fSrcTabs ? m_uSrcView : MEST_EDIT;
                    return S_OK;
                }
                return E_INVALIDARG;

            case MECMDID_TABLINKS:
                if (pvaIn && pvaIn->vt == VT_BOOL)
                {
                    m_fTabLinks = (pvaIn->boolVal == VARIANT_TRUE);
                    return S_OK;
                }
                return E_INVALIDARG;

            case MECMDID_SAVEATTACHMENTS:
                return SaveAttachments();

            case MECMDID_INSERTBGSOUND:
                return InsertBackgroundSound();

            case MECMDID_BACKGROUNDIMAGE:
                if (pvaIn && pvaIn->vt == VT_BSTR)
                    return SetBackgroundImage(m_pDoc, pvaIn->bstrVal);
                
                if (pvaOut)
                    {
                    pvaOut->vt = VT_BSTR;
                    return GetBackgroundImage(m_pDoc, &pvaOut->bstrVal);
                    }
                
                return E_INVALIDARG;
                
            case MECMDID_SHOWSOURCETABS:
                if (pvaIn && pvaIn->vt == VT_BOOL)
                    {
                    ShowSourceTabs(pvaIn->boolVal == VARIANT_TRUE);
                    return S_OK;
                    }
                return E_INVALIDARG;
                    
            case MECMDID_APPLYDOCUMENT:
                return ApplyDocumentVerb(pvaIn);

            case MECMDID_SAVEASSTATIONERY:
                return SaveAsStationery(pvaIn, pvaOut);

            case MECMDID_DIRTY:
                if (pvaIn &&
                    pvaIn->vt == VT_BOOL)
                    {
                    return HrSetDirtyFlagImpl(m_pDoc, pvaIn->boolVal==VARIANT_TRUE);
                    }
                else if (pvaOut)
                    {
                    pvaOut->vt = VT_BOOL;
                    pvaOut->boolVal = IsDirty()==S_OK?VARIANT_TRUE:VARIANT_FALSE;
                    return S_OK;
                    }
                break;

            case MECMDID_FORMATPARAGRAPH:
                return HrFormatParagraph();
                break;    

            case MECMDID_EMPTY:
                if (pvaOut)
                {
                    pvaOut->vt = VT_BOOL;
                    pvaOut->boolVal = (IsEmpty() ? VARIANT_TRUE : VARIANT_FALSE);
                    return S_OK;
                }
                break;

            case MECMDID_DOWNGRADEPLAINTEXT:
                return DowngradeToPlainText(pvaIn ? (pvaIn->vt == VT_BOOL ? (pvaIn->boolVal == VARIANT_TRUE) : NULL ): NULL );

            case MECMDID_CHARSET:
                if (pvaIn && 
                    pvaIn->vt == VT_I8)
                    {
                    return SetCharset((HCHARSET)pvaIn->ullVal);
                    }
                else if (pvaOut)
                    {
                    pvaOut->vt = VT_I8;
                    pvaOut->ullVal = (ULONGLONG)m_hCharset;
                    return S_OK;
                    }
                        
                break;

            case MECMDID_FORMATFONT:
                return FormatFont();

            case MECMDID_PREVIEWFORMAT:
                if (pvaIn && 
                    pvaIn->vt == VT_BSTR)
                    {
                    SafeMemFree(m_pszLayout);
                    HrBSTRToLPSZ(CP_ACP, pvaIn->bstrVal, &m_pszLayout);
                    RecalcPreivewHeight(NULL);
                    Resize();
                    return S_OK;
                    }
                break;


            case MECMDID_INSERTTEXTFILE:
                return InsertFile((pvaIn && pvaIn->vt==VT_BSTR) ? pvaIn->bstrVal : NULL);

            case MECMDID_VIEWSOURCE:
                if (pvaIn && 
                    pvaIn->vt == VT_I4)
                    {
                    ViewSource(pvaIn->lVal == MECMD_VS_MESSAGE);
                    return S_OK;
                    }
                break;

            case MECMDID_STYLE:
                if (pvaIn && 
                    pvaIn->vt == VT_I4)
                    return SetStyle(pvaIn->lVal);

                if (pvaOut)
                    {
                    pvaOut->vt=VT_I4;
                    pvaOut->lVal = m_uHdrStyle;
                    return S_OK;
                    }
                break;

            case MECMDID_ROT13:
                if (pvaIn == NULL && pvaOut == NULL)
                    {
                    DoRot13();
                    return S_OK;
                    }
                break;

            case MECMDID_INSERTTEXT:
            case MECMDID_INSERTHTML:
                if (pvaIn && pvaIn->vt == VT_BSTR)
                    {
                    return InsertTextAtCaret(pvaIn->bstrVal, MECMDID_INSERTHTML == nCmdID, FALSE);
                    }
                break;

            case MECMDID_BACKGROUNDCOLOR:
                if (pvaIn && VT_I4 == pvaIn->vt)
                    return SetBackgroundColor(pvaIn->ulVal);
                else if (pvaOut)
                    {
                    pvaOut->vt = VT_I4;
                    return GetBackgroundColor(&(pvaOut->ulVal));
                    }
                break;

            case MECMDID_EDITHTML:
                if (pvaIn &&
                    pvaIn->vt == VT_BOOL)
                    {
                    return SetPlainTextMode(pvaIn->boolVal!=VARIANT_TRUE);
                    }
                else if (pvaOut)
                    {
                    pvaOut->vt = VT_BOOL;
                    pvaOut->boolVal = m_fPlainMode?VARIANT_FALSE:VARIANT_TRUE;
                    return S_OK;
                    }
                break;

            case MECMDID_EDITMODE:
                if (pvaIn &&
                    pvaIn->vt == VT_BOOL)
                    {
                    return SetDesignMode(pvaIn->boolVal==VARIANT_TRUE);
                    }
                else if (pvaOut)
                    {
                    pvaOut->vt = VT_BOOL;
                    pvaOut->boolVal = m_fDesignMode?VARIANT_TRUE:VARIANT_FALSE;
                    return S_OK;
                    }
                return E_INVALIDARG;
            
            case MECMDID_SETTEXT:
                if (pvaIn==NULL || pvaIn->vt != VT_BSTR)
                    return E_INVALIDARG;

                return SetDocumentText(pvaIn->bstrVal);

            case MECMDID_CANENCODETEXT:
                if (!pvaIn || pvaIn->vt != VT_UI4)
                    return E_INVALIDARG;
                return SafeToEncodeText(pvaIn->lVal);

            default:
                hr = E_NOTIMPL;

            }
        }

    return hr;

}


HRESULT CBody::PrivateTranslateAccelerator(LPMSG lpmsg)
{
    HRESULT     hr=S_FALSE;
    BOOL        fTabbing=FALSE;
    HWND        hwndFocus;

    // first of all, see if the formatbar is taking it...
    if (m_fUIActive &&
        m_uHdrStyle==MESTYLE_FORMATBAR &&
        m_pFmtBar &&
        m_pFmtBar->TranslateAcclerator(lpmsg)==S_OK)
        return S_OK;
    
    if (m_pSrcView &&
        m_uSrcView == MEST_SOURCE)
        {
        return m_pSrcView->TranslateAccelerator(lpmsg);
        }

    // if trident is not in-place active, don't pass accelerators
    if(!m_pInPlaceActiveObj)
        return S_FALSE;

    if (!m_fFocus)
    {
        // if trident doesn't have focus, make sure it's not a child
        // of trident before blocking
        hwndFocus = GetFocus();
        
        if (hwndFocus == NULL || 
            !IsChild(m_hwndDocObj, hwndFocus))
            return S_FALSE;
    }

    // if Trident has focus and we get a TAB key in edit mode, we snag it and
    // insert a tab ourselves
    if (m_fFocus && 
        lpmsg->message == WM_KEYDOWN && 
        lpmsg->wParam == VK_TAB &&
        m_fDesignMode && 
        !(GetKeyState(VK_SHIFT)&0x8000))
        {
        // plain-tab with no shift in design mode inserts a tag
        InsertTextAtCaret((BSTR)c_bstr_TabChar, FALSE, TRUE);
        return S_OK;
        }

    if (lpmsg->message == WM_KEYDOWN)
        {
        if (lpmsg->wParam == VK_F6)
            return S_FALSE;

        if (lpmsg->wParam == VK_TAB)
            {
            if (!(m_fTabLinks))
                return S_FALSE;
            
            // if this control want's link-tabbing...
            fTabbing=TRUE;
            m_fCycleFocus=0;
            }
        }

    // trident snags EVERYTHING. even non-keystrokes, only pass them keys...
    if(lpmsg->message >= WM_KEYFIRST && lpmsg->message <= WM_KEYLAST)
        {
        hr=m_pInPlaceActiveObj->TranslateAccelerator(lpmsg);

        if (m_fIgnoreAccel)
        {
            m_fIgnoreAccel = 0;
            return S_FALSE;
        }

        if (fTabbing && m_fCycleFocus)
            return S_FALSE;
        }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     CBody::PrivateQueryService
//
//  Synopsis:   Private QueryService called from the outer document
//              to implement CDoc::IServiceProvider
//
//---------------------------------------------------------------
HRESULT CBody::PrivateQueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject)
{
    HRESULT             hr;

    TraceCall("CBody::PrivateQueryService");

    if (!m_pDoc)
        return E_UNEXPECTED;

    if (IsEqualGUID(guidService, IID_IHTMLDocument2) &&
        IsEqualGUID(riid, IID_IHTMLDocument2))
        {
        *ppvObject = (LPVOID)m_pDoc;
        m_pDoc->AddRef();
        return S_OK;
        }

    // RAID 12020. Needed to be able to get at DocHostUI for drop stuff
    else if (IsEqualGUID(guidService, IID_IDocHostUIHandler) &&
        IsEqualGUID(riid, IID_IDocHostUIHandler))
        {
        *ppvObject = (LPVOID)(IDocHostUIHandler*)this;
        AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
}



//+---------------------------------------------------------------
//
//  Member:     CBody::SetDesignMode
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::SetDesignMode(BOOL fOn)
{
    HRESULT hr;

    TraceCall("CBody::SetDesignMode");

    if (fOn == m_fDesignMode)   // bitfield!
        return S_OK;

    Assert (m_pCmdTarget);
    Assert (m_lpOleObj);

    hr = m_pCmdTarget->Exec(&CMDSETID_Forms3, 
                            (fOn?IDM_EDITMODE:IDM_BROWSEMODE),  
                            MSOCMDEXECOPT_DONTPROMPTUSER, 
                            NULL, NULL);
    if (!FAILED(hr))
        {
        m_fDesignMode = !!fOn;  // bitfield
        if (fOn)
            {
            SetHostComposeFont();
            }
        }
    return hr;
}

HRESULT CBody::SetPlainTextMode(BOOL fOn)
{
    VARIANTARG  va;
    BSTR        bstr=0;

    m_fPlainMode=fOn;

    va.bstrVal = NULL;
    if (!fOn && 
        m_pParentCmdTarget)
        m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_COMPOSE_FONT, OLECMDEXECOPT_DODEFAULT, NULL, &va);

    SetComposeFont(va.bstrVal);     //va.bstrVal could be NULL to turn compose font OFF
    SysFreeString(va.bstrVal);
    if (fOn)
    {
        // if going to plain-text mode, remove the tabs
        ShowSourceTabs(FALSE);
    }
    else
    {
        // if going from plain-text > html, then exec a remove formatting command
        // so that the new compose font is applied 
        IHTMLTxtRange           *pTxtRange;
        IOleCommandTarget       *pCmdTarget;

        if (!FAILED(CreateRange(&pTxtRange)))
        {
            if (!FAILED(pTxtRange->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&pCmdTarget)))
            {
                pCmdTarget->Exec(&CMDSETID_Forms3, IDM_REMOVEFORMAT, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
                pCmdTarget->Release();
            }
            pTxtRange->Release();
        }
    }
    return S_OK;
}




//+---------------------------------------------------------------
//
//  Member:     DeleteElement
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::DeleteElement(IHTMLElement *pElem)
{
    HRESULT     hr=E_INVALIDARG;
    
    TraceCall("CBody::DeleteElement");
    if (pElem)
        hr = pElem->put_outerHTML(NULL);

    return hr;        
}


//+---------------------------------------------------------------
//
//  Member:     ReplaceElement
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::ReplaceElement(LPCTSTR pszName, BSTR bstrPaste, BOOL fHtml)
{
    IHTMLElement    *pElem;
    HRESULT         hr;

    TraceCall("CBody::HrReplaceElement");

    if (!FAILED(hr = GetElement(pszName, &pElem)))
        {
        if (fHtml)
            hr = pElem->put_outerHTML(bstrPaste);
        else
            hr = pElem->put_outerText(bstrPaste);
        pElem->Release();
        }
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     SelectElement
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::SelectElement(IHTMLElement *pElem, BOOL fScrollIntoView)
{
    IHTMLTxtRange *pRange;
    HRESULT         hr;
    VARIANT         v;        
    
    TraceCall("CBody::SelectElement");

    if (pElem == NULL)
        return TraceResult(E_INVALIDARG);

    if (!FAILED(hr=CreateRangeFromElement(pElem, &pRange)))
        {
        pRange->collapse(VARIANT_TRUE);
        pRange->select();
        if (fScrollIntoView)
            pRange->scrollIntoView(VARIANT_TRUE);
        pRange->Release();
        }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     CreateRangeFromElement
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::CreateRangeFromElement(IHTMLElement *pElem, IHTMLTxtRange **ppRange)
{
    HRESULT hr;
    IHTMLTxtRange *pRange;

    TraceCall("CBody::CreateRangeFromElement");

    Assert (pElem && ppRange);

    if (!FAILED(hr = CreateRange(&pRange)))
        {
        if (!FAILED(hr = pRange->moveToElementText(pElem)))
            {
            *ppRange = pRange;
            pRange->AddRef();
            }
        pRange->Release();
        }
    return hr;
}



//+---------------------------------------------------------------
//
//  Member:     HrCreateRange
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::CreateRange(IHTMLTxtRange **ppRange)
{
    IHTMLBodyElement        *pBodyElem=0;
    HRESULT                 hr=E_FAIL;

    TraceCall("CBody::HrCreateRange");

    Assert (ppRange);
    *ppRange = NULL;
    if (!FAILED(GetBodyElement(&pBodyElem)))
    {
        pBodyElem->createTextRange(ppRange);
        if (*ppRange)
            hr = S_OK;
        pBodyElem->Release();
    }
    return hr;
}



//+---------------------------------------------------------------
//
//  Member:     CBody::GetSelection
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::GetSelection(IHTMLTxtRange **ppRange)
{
    IHTMLSelectionObject    *pSel=0;
    IHTMLTxtRange           *pTxtRange=0;
    IDispatch               *pID=0;
    HRESULT                 hr=E_FAIL;

    TraceCall("CBody::GetSelection");

    if (ppRange == NULL)
        return TraceResult(E_INVALIDARG);

    *ppRange = NULL;

    if(m_pDoc)
        {
        m_pDoc->get_selection(&pSel);
        if (pSel)
            {
            pSel->createRange(&pID);
            if (pID)
                {
                hr = pID->QueryInterface(IID_IHTMLTxtRange, (LPVOID *)ppRange);
                pID->Release();
                }
            pSel->Release();
            }
        }
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     CBody::GetSelection
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::GetElement(LPCTSTR pszName, IHTMLElement **ppElem)
{
    TraceCall("CBody::GetElement");

    return ::HrGetElementImpl(m_pDoc, pszName, ppElem);
}


//+---------------------------------------------------------------
//
//  Member:     CBody::GetSelection
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::GetBodyElement(IHTMLBodyElement **ppBody)
{
    TraceCall("CBody::GetBodyElement");

    return ::HrGetBodyElement(m_pDoc, ppBody);
}



//+---------------------------------------------------------------
//
//  Member:     CBody::Print
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::Print(BOOL fPrompt, VARIANTARG *pvaIn)
{
    VARIANTARG      va;
    SAFEARRAY      *psa = NULL;
    SAFEARRAYBOUND  rgsaBound[1];
    LONG            l;
    BSTR            bstrFooter  = NULL,
                    bstrHeader  = NULL,
                    bstrUrl     = NULL;
    HRESULT         hr;
    VARIANT         v;
    LPSTREAM        pstm = NULL;
    BOOL            fMHtml = FALSE;
    HBODY           hBody;
    WCHAR           wsz[CCHMAX_STRINGRES];
    LPWSTR          pwszUser = NULL;
    
    TraceCall("CBody::Print");
    
    if (m_pCmdTarget==NULL)
        return TraceResult(E_UNEXPECTED);
    
    // if we're printing an MHTML message, print by URL so that cid:'s print
    // NB: this is a loss of fidelity.
    if (m_pMsg)
        fMHtml = (MimeOleGetRelatedSection(m_pMsg, FALSE, &hBody, NULL)==S_OK) && m_pszUrlW;
    
    rgsaBound[0].lLbound = 0;
    rgsaBound[0].cElements = fMHtml ? 4 : 3;
    
    IF_NULLEXIT(psa = SafeArrayCreate(VT_VARIANT, 1, rgsaBound));
    
    va.vt = VT_ARRAY|VT_BYREF;
    va.parray = psa;
    
    *wsz = 0;
    SideAssert(LoadStringWrapW(g_hLocRes, idsPrintHeader, wsz, ARRAYSIZE(wsz)));
    
    IF_NULLEXIT(bstrHeader = SysAllocString(wsz));
    
    v.vt = VT_BSTR;
    v.bstrVal = bstrHeader;
    
    // don't show the <TITLE> tag on the header
    l=0;
    IF_FAILEXIT(hr = SafeArrayPutElement(psa, &l, &v));
    
    *wsz = 0;
    SideAssert(LoadStringWrapW(g_hLocRes, idsPrintFooter, wsz, ARRAYSIZE(wsz)));
    
    // we want footer to have only date, not URL.
    IF_NULLEXIT(bstrFooter = SysAllocString(wsz));
    
    v.vt = VT_BSTR;
    v.bstrVal = bstrFooter;
    
    // FOOTER
    l=1;
    IF_FAILEXIT(hr = SafeArrayPutElement(psa, &l, &v));
    
    if (m_pMsg)
    {
        if (pvaIn && pvaIn->vt == VT_BSTR)
            pwszUser = pvaIn->bstrVal;

        IF_FAILEXIT(hr = GetHeaderTable(m_pMsgW, pwszUser, HDR_TABLE, &pstm));
        
        HrRewindStream(pstm);
        
        // ISTREAM containing table
        v.vt = VT_UNKNOWN;
        v.punkVal = (LPUNKNOWN)pstm;
        
        l=2;
        IF_FAILEXIT(hr = SafeArrayPutElement(psa, &l, &v));
        
        if (fMHtml)
        {
            bstrUrl = SysAllocString(m_pszUrlW);
            
            v.vt = VT_BSTR;
            v.bstrVal = bstrUrl;
            
            l=3;
            IF_FAILEXIT(hr = SafeArrayPutElement(psa, &l, &v));
        }
        
    }
    
    hr = m_pCmdTarget->Exec(NULL, OLECMDID_PRINT, 
        (fPrompt)?(OLECMDEXECOPT_PROMPTUSER):(OLECMDEXECOPT_DONTPROMPTUSER), &va, NULL);
    IF_FAILEXIT(hr);

exit:
    SysFreeString(bstrFooter);
    SysFreeString(bstrHeader);
    SysFreeString(bstrUrl);
    if (psa)
        SafeArrayDestroy(psa);
    ReleaseObj(pstm);
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     CBody::OnWMCommand
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::OnWMCommand(HWND hwnd, int id, WORD wCmd)
{
    DWORD               nCmdId=0,
                        nCmdIdTrident=0,
                        nCmdIdOESecure=0;
    POINT               pt;
    VARIANTARG          va;
    VARIANTARG          *pvaIn=0,
                        *pvaOut=0;

    TraceCall("CBody::OnWMCommand");

    if (m_pSrcView &&
        m_pSrcView->OnWMCommand(hwnd, id, wCmd)==S_OK)
        return S_OK;

    if (m_pFmtBar && 
        m_pFmtBar->OnWMCommand(hwnd, id, wCmd)==S_OK)
        return S_OK;

    if (!m_pCmdTarget)
        return S_FALSE;

    switch (id)
    {
        case idmPaneEncryption:
        case idmPaneBadEncryption:
            if (PointFromButton(id, &pt)==S_OK)
            {
                va.vt = VT_BYREF;
                va.byref = &pt;
                pvaIn = &va;
                nCmdIdOESecure = OECSECCMD_ENCRYPTED;
            }
            break;

        case idmPaneBadSigning:
        case idmPaneSigning:
            if (PointFromButton(id, &pt)==S_OK)
            {
                va.vt = VT_BYREF;
                va.byref = &pt;
                pvaIn = &va;
                nCmdIdOESecure = OECSECCMD_SIGNED;
            }
            break;

        case idmPaneVCard:
            if (m_pAttMenu)
                m_pAttMenu->LaunchVCard(m_hwnd);
            break;

#ifdef FOLLOW_LINK
        case idmOpenLink:
            nCmdIdTrident = IDM_FOLLOWLINKN;
            break;
#endif

        case idmCopy:
            nCmdId = OLECMDID_COPY;
            break;

        case idmSaveTargetAs:
            nCmdIdTrident = IDM_SAVETARGET;
            break;

        case idmCopyShortcut:
            nCmdIdTrident = IDM_COPYSHORTCUT;
            break;

        case idmCut:
            nCmdId = OLECMDID_CUT;
            break;

        case idmPaste:
            nCmdId = OLECMDID_PASTE;
            break;

        case idmSelectAll:
            nCmdId = OLECMDID_SELECTALL;
            break;

        case idmUndo:
            nCmdId = OLECMDID_UNDO;
            break;

        case idmRedo:
            nCmdId = OLECMDID_REDO;
            break;

        case idmAddToFavorites:
            AddToFavorites();
            return S_OK;

        case idmAddToWAB:
            AddToWab();
            return S_OK;

        case idmSaveBackground:
            nCmdIdTrident = IDM_SAVEBACKGROUND;
            break;

        case idmSavePicture:
			_OnSaveImage();
            break;

        case idmFmtLeft:
            nCmdIdTrident = IDM_JUSTIFYLEFT;
            break;

        case idmFmtCenter:
            nCmdIdTrident = IDM_JUSTIFYCENTER;
            break;

        case idmFmtRight:
            nCmdIdTrident = IDM_JUSTIFYRIGHT;
            break;

        case idmFmtNumbers:
            nCmdIdTrident = IDM_ORDERLIST;
            break;

        case idmFmtBullets:
            nCmdIdTrident = IDM_UNORDERLIST;
            break;

        case idmFmtBlockDirLTR:
            nCmdIdTrident = IDM_BLOCKDIRLTR;
            break;

        case idmFmtBlockDirRTL:
            nCmdIdTrident = IDM_BLOCKDIRRTL;
            break;

        case idmFmtFontDlg:
            return FormatFont();

        case idmFmtParagraphDlg:
            return HrFormatParagraph();
            
        case idmProperties:
            nCmdIdTrident = DwChooseProperties();
            if (nCmdIdTrident==0)
            {
                return DoHostProperties();
            }
            break;
    }

    if(nCmdId)
    {
        m_pCmdTarget->Exec(NULL, nCmdId, OLECMDEXECOPT_DODEFAULT, pvaIn, pvaOut);
        return S_OK;
    }
    
    if(nCmdIdTrident)
    {
        m_pCmdTarget->Exec(&CMDSETID_Forms3, nCmdIdTrident, OLECMDEXECOPT_DODEFAULT,  pvaIn, pvaOut);
        return S_OK;
    }
    
    if (nCmdIdOESecure && m_pParentCmdTarget)
    {
        // delegate security commands to the host
        m_pParentCmdTarget->Exec(&CMDSETID_OESecurity, nCmdIdOESecure, OLECMDEXECOPT_DODEFAULT, pvaIn, pvaOut);
        return S_OK;
    }

    return S_FALSE;
}



//+---------------------------------------------------------------
//
//  Member:     CBody::UpdateContextMenu
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::UpdateContextMenu(HMENU hmenuEdit, BOOL fEnableProperties, IDispatch *pDisp)
{
    OLECMD  rgTridentCmds[]=   {{IDM_FIND, 0},
                                {IDM_SAVEBACKGROUND, 0},
                                {IDM_COPYSHORTCUT, 0},
                                {IDM_SAVETARGET, 0}};
    OLECMD  rgStdCmds[]=       {{OLECMDID_CUT, 0},
                                {OLECMDID_COPY, 0},
                                {OLECMDID_PASTE, 0},
                                {OLECMDID_SELECTALL, 0},
                                {OLECMDID_UNDO, 0},
                                {OLECMDID_REDO, 0}};
    int     rgidsStd[]=        {idmCut,
                                idmCopy,
                                idmPaste,
                                idmSelectAll,
                                idmUndo,
                                idmRedo};    
    int     rgidsTrident[]=    {idmFindText,
                                idmSaveBackground,
                                idmCopyShortcut,
                                idmSaveTargetAs};
    OLECMD  rgFmtCmds[]=       {{IDM_INDENT, 0},    // careful about ordering!!
                                {IDM_OUTDENT, 0},
                                {IDM_FONT, 0}};
    int     rgFmtidm[] =       {idmFmtIncreaseIndent,    // careful about ordering!!
                                idmFmtDecreaseIndent,
                                idmFmtFontDlg};
    OLECMD  rgHostCmds[]=       {{OLECMDID_PROPERTIES, 0}};
    int     rgHostidm[]=    {idmProperties};
    UINT                    ustate;
    int                     i,
                            id;
    BSTR                    bstrHref=NULL;
    BOOL                    fBadLink = FALSE;
    IHTMLAnchorElement      *pAE;

    TraceCall("CBody::UpdateContextMenu");

    if (!m_pCmdTarget || !hmenuEdit)
        return E_INVALIDARG;
    
    if (pDisp &&
        pDisp->QueryInterface(IID_IHTMLAnchorElement, (LPVOID *)&pAE)==S_OK)
    {
        pAE->get_href(&bstrHref);
        if (bstrHref &&
            StrCmpNIW(bstrHref, c_szOECmdW, ARRAYSIZE(c_szOECmdW)-sizeof(WCHAR))==0)
            fBadLink = TRUE;

        pAE->Release();
    }
            
    m_pCmdTarget->QueryStatus(NULL, sizeof(rgStdCmds)/sizeof(OLECMD), rgStdCmds, NULL);
    for (i=0; i<sizeof(rgStdCmds)/sizeof(OLECMD); i++)
        SetMenuItem(hmenuEdit, rgidsStd[i], rgStdCmds[i].cmdf & OLECMDF_ENABLED);

    m_pCmdTarget->QueryStatus(&CMDSETID_Forms3, sizeof(rgTridentCmds)/sizeof(OLECMD), rgTridentCmds, NULL);

    for (i=0; i<sizeof(rgTridentCmds)/sizeof(OLECMD); i++)
    {
        ustate = rgTridentCmds[i].cmdf & OLECMDF_ENABLED;
        
        if (rgidsTrident[i] == idmSaveTargetAs || rgidsTrident[i] == idmCopyShortcut)
            ustate = ustate && !fBadLink;

        SetMenuItem(hmenuEdit, rgidsTrident[i], ustate);
    }

    // set the formatting commands. The are only available when we have focus and we are editing an HTML document
    if (m_fFocus && !m_fPlainMode)
        m_pCmdTarget->QueryStatus(&CMDSETID_Forms3, sizeof(rgFmtCmds)/sizeof(OLECMD), rgFmtCmds, NULL);

    ustate = !m_fPlainMode ? MF_ENABLED : (MF_DISABLED|MF_GRAYED);    
    EnableMenuItem(hmenuEdit, idmFmtParagraphDlg, ustate);

    for(i=0; i<sizeof(rgFmtCmds)/sizeof(OLECMD); i++)
    {
        ustate = (rgFmtCmds[i].cmdf&OLECMDF_ENABLED ? MF_ENABLED: MF_DISABLED|MF_GRAYED) | MF_BYCOMMAND;
        EnableMenuItem(hmenuEdit, rgFmtidm[i], ustate);
        ustate = (rgFmtCmds[i].cmdf&OLECMDF_LATCHED?MF_CHECKED:MF_UNCHECKED) | MF_BYCOMMAND;
        CheckMenuItem(hmenuEdit, rgFmtidm[i], ustate);
    }

    if (m_pParentCmdTarget)
        m_pParentCmdTarget->QueryStatus(NULL, sizeof(rgHostCmds)/sizeof(OLECMD), rgHostCmds, NULL);

    // if we are handling idmProperties then override the host state
    if (fEnableProperties)
        rgHostCmds[0].cmdf = OLECMDF_ENABLED;
    
    for(i=0; i<sizeof(rgHostCmds)/sizeof(OLECMD); i++)
        SetMenuItem(hmenuEdit, rgHostidm[i], rgHostCmds[i].cmdf & OLECMDF_ENABLED);

    SysFreeString(bstrHref);
    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     CBody::AppendAnchorItems
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::AppendAnchorItems(HMENU hMenu, IDispatch *pDisp)
{
    BSTR                    bstr=0;
    TCHAR                   rgch[CCHMAX_STRINGRES];
    HRESULT                 hr=S_OK;
    IHTMLAnchorElement      *pAE;
    OLECMD                  rgHostCmds[]={  {MEHOSTCMDID_ADD_TO_ADDRESSBOOK, 0},
                                            {MEHOSTCMDID_ADD_TO_FAVORITES,  0}};

    TraceCall("CBody::AppendAnchorItems");

    if (!pDisp)
        return S_OK;

    // if no parent cmdtarget, can't do these verbs anyway
    if (m_pParentCmdTarget && 
        m_pParentCmdTarget->QueryStatus(&CMDSETID_MimeEditHost, sizeof(rgHostCmds)/sizeof(OLECMD), rgHostCmds, NULL)==S_OK)
    {
        if (pDisp->QueryInterface(IID_IHTMLAnchorElement, (LPVOID *)&pAE)==S_OK)
        {
            hr = pAE->get_href(&bstr);
            pAE->Release();
        }            
        
        if (bstr)
        {
            *rgch = 0;
            
            // If "mailto:" is in bstr then add it to wab; If "http:" is in bstr, add it to favorites
            if (rgHostCmds[0].cmdf & OLECMDF_ENABLED && 
                StrCmpNIW(bstr, c_szMailToW, ARRAYSIZE(c_szMailToW)-sizeof(WCHAR))==0)
            {
                SideAssert(LoadString(g_hLocRes, idsAddToWAB, rgch, sizeof(rgch)/sizeof(TCHAR)));
                AppendMenu(hMenu, MF_SEPARATOR, 0, 0);
                AppendMenu(hMenu, MF_STRING, idmAddToWAB, rgch);
                RemoveMenu(hMenu, idmSaveTargetAs, MF_BYCOMMAND);   // no point on a mailto: url
            }
            else if (rgHostCmds[1].cmdf & OLECMDF_ENABLED &&
                (StrCmpNIW(bstr, c_szHttpW, ARRAYSIZE(c_szHttpW)-sizeof(WCHAR))==0 || 
                StrCmpNIW(bstr, c_szFileW, ARRAYSIZE(c_szFileW)-sizeof(WCHAR))==0 ))
            {
                SideAssert(LoadString(g_hLocRes, idsAddToFavorites, rgch, sizeof(rgch)/sizeof(TCHAR)));
                AppendMenu(hMenu, MF_SEPARATOR, 0, 0);
                AppendMenu(hMenu, MF_STRING, idmAddToFavorites, rgch);
            }

            SysFreeString(bstr);
        }
    }

    
    return hr;
}




//+---------------------------------------------------------------
//
//  Member:     CBody::GetSelectedAnchor
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::GetSelectedAnchor(BSTR* pbstr)
{
    HRESULT                 hr;
    IHTMLTxtRange           *pTxtRange;
    IHTMLAnchorElement      *pAE;
    IHTMLElement            *pElemParent;

    TraceCall("CBody::GetSelectedAnchor");

    if (pbstr)
        *pbstr=NULL;

    hr = GetSelection(&pTxtRange);
    if (!FAILED(hr))
    {
        hr = pTxtRange->parentElement(&pElemParent);
        if (!FAILED(hr))
        {
            hr = pElemParent->QueryInterface(IID_IHTMLAnchorElement, (LPVOID *)&pAE);
            if (!FAILED(hr))
            {
                if (pbstr)
                    hr = pAE->get_href(pbstr);
                pAE->Release();
            }            
            pElemParent->Release();
        }
        pTxtRange->Release();
    }

    return hr;
}





//+---------------------------------------------------------------
//
//  Member:     CBody::AddToWab
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::AddToWab()
{
    BSTR                    bstr=0,
                            bstrOut;
    HRESULT                 hr=E_FAIL;
    WCHAR                   *pszW;
    VARIANTARG              va;
    IHTMLAnchorElement      *pAE;

    TraceCall("CBody::AddToWab");

    if (!m_pParentCmdTarget)
        return TraceResult(E_UNEXPECTED);

    if (m_pDispContext &&
        m_pDispContext->QueryInterface(IID_IHTMLAnchorElement, (LPVOID *)&pAE)==S_OK)
    {
        pAE->get_href(&bstr);
        pAE->Release();
    }

    if (bstr)
    {
        // double check this is a mailto:
        if (StrCmpNIW(bstr, c_szMailToW, ARRAYSIZE(c_szMailToW)-sizeof(WCHAR))==0)
        {
            pszW = bstr + (ARRAYSIZE(c_szMailToW)-1);
            
            bstrOut = SysAllocString(pszW);
            if (bstrOut)
            {
                va.vt = VT_BSTR;
                va.bstrVal = bstrOut;
                hr = m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_ADD_TO_ADDRESSBOOK, OLECMDEXECOPT_DODEFAULT, &va, NULL);
                SysFreeString(bstrOut);
            }
            else
                hr = TraceResult(E_OUTOFMEMORY);
        }
        SysFreeString(bstr);
    }
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     CBody::AddToFavorites
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::AddToFavorites()
{
    SAFEARRAY              *psa=NULL;
    SAFEARRAYBOUND          rgsaBound[1];
    BSTR                    bstrURL=NULL,
                            bstrDescr=NULL;
    HRESULT                 hr=E_FAIL;
    VARIANTARG              va;
    IHTMLAnchorElement     *pAE=NULL;
    IHTMLElement           *pE=NULL;
    LONG                    l;

    TraceCall("CBody::AddToFavorites");

    if (!m_pParentCmdTarget)
        return TraceResult(E_UNEXPECTED);

    if (m_pDispContext &&
        m_pDispContext->QueryInterface(IID_IHTMLElement, (LPVOID *)&pE)==S_OK)
    {
        pE->get_innerText(&bstrDescr);
        pE->Release();
    }

    if (m_pDispContext &&
        m_pDispContext->QueryInterface(IID_IHTMLAnchorElement, (LPVOID *)&pAE)==S_OK)
    {
        pAE->get_href(&bstrURL);
        pAE->Release();
    }

    if (bstrURL)
    {
        if(!bstrDescr)
            bstrDescr=SysAllocString(bstrURL);

        rgsaBound[0].lLbound = 0;
        rgsaBound[0].cElements = 2;
    
        IF_NULLEXIT(psa = SafeArrayCreate(VT_BSTR, 1, rgsaBound));
    
        va.vt = VT_ARRAY|VT_BSTR;
        va.parray = psa;
    
        l=0;
        IF_FAILEXIT(hr = SafeArrayPutElement(psa, &l, bstrDescr));

        l=1;
        IF_FAILEXIT(hr = SafeArrayPutElement(psa, &l, bstrURL));

        IF_FAILEXIT(hr = m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_ADD_TO_FAVORITES, OLECMDEXECOPT_DODEFAULT, &va, NULL));
    }

exit:
    SysFreeString(bstrDescr);
    SysFreeString(bstrURL);
    if(psa) 
        SafeArrayDestroy(psa);
    
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     CBody::GetWebPageOptions
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::GetWebPageOptions(WEBPAGEOPTIONS *pOptions, BOOL *pfIncludeMsg)
{
    VARIANTARG  va;
    DWORD       dwFlags;

    TraceCall("GetWebPageOptions");

    // set defaults for IN params
    pOptions->cbSize = sizeof(WEBPAGEOPTIONS);
    pOptions->dwFlags = WPF_HTML|WPF_AUTOINLINE;
    pOptions->dwDelay = 5000;
    pOptions->wchQuote = NULL;

    if (pfIncludeMsg)
        *pfIncludeMsg=TRUE;

    // callback to Host for real options
    if (m_pParentCmdTarget)
    {
        if (GetHostFlags(&dwFlags)==S_OK)
        {
            BOOL fSecurityForcesHTMLOff = FALSE;
            VARIANTARG va = {0};

            va.vt = VT_BOOL;
            va.boolVal = VARIANT_FALSE;
            // read msgs all have the autoinline flag set so we use that along with the option setting to determine
            // if html should be disabled
            if (SUCCEEDED(m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_IS_READ_IN_TEXT_ONLY, OLECMDEXECOPT_DODEFAULT, NULL, &va)))
                fSecurityForcesHTMLOff = (VARIANT_TRUE == va.boolVal) && (dwFlags & MEO_FLAGS_AUTOINLINE);

            // convert MEHOST_* flags to WPF_*
            pOptions->dwFlags = 0;

            if (!fSecurityForcesHTMLOff && (dwFlags & MEO_FLAGS_HTML))
                pOptions->dwFlags |= WPF_HTML;

            if (dwFlags & MEO_FLAGS_AUTOINLINE)
                pOptions->dwFlags |= WPF_AUTOINLINE;

            if (dwFlags & MEO_FLAGS_SLIDESHOW)
                pOptions->dwFlags |= WPF_SLIDESHOW;

            if ((!(dwFlags & MEO_FLAGS_INCLUDEMSG)) && pfIncludeMsg)
                *pfIncludeMsg = FALSE;
        }

        if (m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_QUOTE_CHAR, OLECMDEXECOPT_DODEFAULT, NULL, &va)==S_OK)
            pOptions->wchQuote = (WCHAR)va.lVal;
        
        if (m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_SLIDESHOW_DELAY, OLECMDEXECOPT_DODEFAULT, NULL, &va)==S_OK)
            pOptions->dwDelay = (WCHAR)va.lVal;
        
    }
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     ViewSource
//
//  Synopsis:   
//
//---------------------------------------------------------------

HRESULT CBody::ViewSource(BOOL fMessage)
{
    TraceCall("CBody::ViewSource");

    if (fMessage)
        MimeEditViewSource(m_hwnd, m_pMsg);
    else
    {
        if (m_pCmdTarget)
            m_pCmdTarget->Exec(&CMDSETID_Forms3, IDM_VIEWSOURCE, OLECMDEXECOPT_DODEFAULT, NULL, NULL); 
    }
    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     OnUIDeactivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::OnUIDeactivate(BOOL fUndoable)
{
    HRESULT     hr;

    TraceCall("CBody::OnUIDeactivate");
    
    hr = CDocHost::OnUIDeactivate(fUndoable);;

    if (m_pParentInPlaceSite)
        m_pParentInPlaceSite->OnUIDeactivate(fUndoable);

    if (m_pParentInPlaceFrame)
        m_pParentInPlaceFrame->SetActiveObject(NULL, NULL);

    if (m_pFmtBar)
        m_pFmtBar->Update();

    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     OnUIActivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::OnUIActivate()
{
    HRESULT hr;

    TraceCall("CBody::OnUIActivate");

    hr = CDocHost::OnUIActivate();

    if (m_pParentInPlaceSite)
        m_pParentInPlaceSite->OnUIActivate();
    
    if (m_pParentInPlaceFrame)
        m_pParentInPlaceFrame->SetActiveObject(m_pDocActiveObj, NULL);

    if (m_pFmtBar)
        m_pFmtBar->Update();

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SetStatusText
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::SetStatusText(LPCOLESTR pszW)
{
    LPWSTR  pszTempW;

    TraceCall("CDocHost::SetStatusText");

    // bug #2137. This is a nasty hack. If we get a statusbar update
    // with mid://xxx#bookmark then we tear off the mid://xxx portion
    // to show the name more cleanly. 
    // the right fix is for trident to add handling for displaying urls to
    // call IInternetInfo::ParseUrl with PARSE_URL_FRIENDLY

    if (pszW && 
        StrCmpNIW(pszW, L"mid:", 4) == 0 && 
        (pszTempW = StrPBrkW(pszW, L"#")))
        pszW = pszTempW;

    if (m_pParentInPlaceFrame)
        m_pParentInPlaceFrame->SetStatusText(pszW);

    return CDocHost::SetStatusText(pszW);;
}


//+---------------------------------------------------------------
//
//  Member:     DoRot13
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CBody::DoRot13()
{
    IHTMLTxtRange           *pTxtRange;
    HRESULT                 hr;
    BSTR                    bstr;
    LPWSTR                  lpszW;
    ULONG                   cb;

    hr = CreateRange(&pTxtRange);
    if (!FAILED(hr))
    {
        hr=pTxtRange->get_text(&bstr);
        if (!FAILED(hr))
        {
            cb=SysStringLen(bstr);
            
            while(cb--)
            {
                register WCHAR chW;
                
                chW=bstr[cb];
                if (chW >= 'a' && chW <= 'z')
                    bstr[cb] = 'a' + (((chW - 'a') + 13) % 26);
                else if (chW >= 'A' && chW <= 'Z')
                    bstr[cb] = 'A' + (((chW - 'A') + 13) % 26);
                
            }
            
            hr=pTxtRange->put_text(bstr);
            SysFreeString(bstr);
        }
        pTxtRange->Release();
    }
    return hr;
}


void CBody::OutputHeaderText(HDC hdc, LPWSTR psz, int *pcxPos, int cyPos, int cxMax, ULONG uFlags)
{
    static int yLabel = 0;
    int     cch,
            cyOffset = 0;
    SIZE    size;
    RECT    rc;
    WCHAR   szRes[CCHMAX_STRINGRES];
    HFONT   hFont;

    if (IS_INTRESOURCE(psz))
    {
        LoadStringWrapW(g_hLocRes, PtrToUlong(psz), szRes, ARRAYSIZE(szRes));
        psz = szRes;        
    }
    
    cch = lstrlenW(psz);
    
    if (m_pFontCache &&
        m_pFontCache->GetFont((uFlags & HDRTXT_BOLD)?FNT_SYS_ICON_BOLD:FNT_SYS_ICON, (uFlags & HDRTXT_SYSTEMFONT )? NULL : m_hCharset, &hFont)==S_OK)
        SelectObject(hdc, hFont);
    
    GetTextExtentPoint32AthW(hdc, psz, cch, &size, DT_NOPREFIX);

    // bobn: Raid 84705  We need to make sure that the fields line up
    if(yLabel && !(uFlags & (HDRTXT_BOLD|HDRTXT_SYSTEMFONT)))
    {
        cyOffset = yLabel - size.cy;
    }

    rc.top    = cyPos + ((cyOffset < (-2))? (-2) : cyOffset); // bobn: Raid 84705  We need to make sure that the fields line up
    rc.left   = *pcxPos;
    rc.right  = min(*pcxPos + size.cx + 1, cxMax);
    rc.bottom = cyPos + size.cy + cyOffset; // bobn: Raid 84705  We need to make sure that the fields line up
    DrawTextExWrapW(hdc, psz, cch, &rc, DT_NOPREFIX | DT_WORD_ELLIPSIS, NULL);
    *pcxPos=rc.right;

    // bobn: Raid 84705  We need to make sure that the fields line up
    if (uFlags & (HDRTXT_BOLD|HDRTXT_SYSTEMFONT))
    {
        yLabel = size.cy;
    }
}

/* 
 * control strings:
 *   &s - Subject:      &c - Cc:
 *   &t - To:           &d - Date:
 *   &f - From:
 *
 */
HRESULT CBody::OnPaint()
{
    HDC             hdc,
                    hdcMem;
    PAINTSTRUCT     ps;
    RECT            rc,
                    rcBtnBar;
    int             idc;
    SIZE            sze;
    HBITMAP         hbmMem;
    HGDIOBJ         hbmOld;
    int             cx,
                    cxLabels,
                    cy,
                    cxPos,
                    cyPos,
                    cyLine;
    int             iBackColor,
                    iTextColor;
    LPSTR           pszFmt;
    LPSTR           psz,
                    pszLast;
    HFONT           hFont;

    if (m_uHdrStyle == MESTYLE_PREVIEW || 
        m_uHdrStyle == MESTYLE_MINIHEADER)
    {
        hdc=BeginPaint(m_hwnd, &ps);
        
        hdcMem = CreateCompatibleDC(hdc);
        idc=SaveDC(hdcMem);
        
        // select font so cyLine is accurate
        if (m_pFontCache &&
            m_pFontCache->GetFont(FNT_SYS_ICON_BOLD, NULL, &hFont)==S_OK)
            SelectObject(hdcMem, hFont);
        
        GetClientRect(m_hwnd, &rc);
        cx = rc.right;
        cxLabels =  cx - (GetSystemMetrics(SM_CXBORDER)*2);      // account for client-edge
        cy = lGetClientHeight();
        
        if (m_cVisibleBtns)
        {   
            // trim cx if buttons are shown
            Assert(IsWindow(m_hwndBtnBar));
            GetClientRect(m_hwndBtnBar, &rcBtnBar);
            cxLabels -= rcBtnBar.right;
        }
        
        hbmMem = CreateCompatibleBitmap(hdc, cx, cy);
        hbmOld = SelectObject(hdcMem, (HGDIOBJ)hbmMem);
        
        if (m_fFocus)
        {
            iBackColor = COLOR_HEADERFOCUS;
            iTextColor = COLOR_HEADERTXTFOCUS;
        }
        else
        {
            iBackColor = COLOR_HEADER;
            iTextColor = COLOR_HEADERTXT;
        }
        
        FillRect(hdcMem, &rc, GetSysColorBrush(iBackColor));
        
        cxPos = CX_LABEL_PADDING;
        cyPos = CY_LINE_PADDING;
        
        SetBkMode(hdcMem, OPAQUE);
        SetBkColor(hdcMem, GetSysColor(iBackColor));
        SetTextColor(hdcMem, GetSysColor (iTextColor));
        cyLine = lGetLineHeight(hdcMem);
        
        if (m_uHdrStyle == MESTYLE_PREVIEW)
        {
            // if we want the full preview header, let's render the text
            pszFmt = m_pszLayout;
            pszLast = pszFmt;
            
            while (*pszFmt)
            {
                if (*pszFmt == '&')
                {
                    // control character
                    pszFmt++;
                    switch (*pszFmt)
                    {
                    case 'f':
                    case 'F':
                        // from field
                        if (*pszFmt=='f' || (m_pszFrom&& *m_pszFrom))
                        {
                            OutputHeaderText(hdcMem, MAKEINTRESOURCEW(idsFromField), &cxPos, cyPos, cxLabels, HDRTXT_BOLD|HDRTXT_SYSTEMFONT);
                            cxPos+=CX_LABEL_PADDING;
                        }
                        if (m_pszFrom)
                            OutputHeaderText(hdcMem, m_pszFrom, &cxPos, cyPos, cxLabels, 0);
                        cxPos+=2*CX_LABEL_PADDING;
                        break;
                        
                    case 's':
                    case 'S':
                        if (*pszFmt=='s' || (m_pszSubject && *m_pszSubject))
                        {
                            OutputHeaderText(hdcMem, MAKEINTRESOURCEW(idsSubjectField), &cxPos, cyPos, cxLabels, HDRTXT_BOLD|HDRTXT_SYSTEMFONT);
                            cxPos+=CX_LABEL_PADDING;
                        }
                        if (m_pszSubject)
                            OutputHeaderText(hdcMem, m_pszSubject, &cxPos, cyPos, cxLabels, 0);
                        cxPos+=2*CX_LABEL_PADDING;
                        break;
                        
                    case 'c':
                    case 'C':
                        if (*pszFmt=='c' || (m_pszCc && *m_pszCc))
                        {
                            OutputHeaderText(hdcMem, MAKEINTRESOURCEW(idsCcField), &cxPos, cyPos, cxLabels, HDRTXT_BOLD|HDRTXT_SYSTEMFONT);
                            cxPos+=CX_LABEL_PADDING;
                        }
                        if (m_pszCc)
                            OutputHeaderText(hdcMem, m_pszCc, &cxPos, cyPos, cxLabels, 0);
                        cxPos+=2*CX_LABEL_PADDING;
                        break;
                        
                    case 't':
                    case 'T':
                        if (*pszFmt=='t' || (m_pszTo && *m_pszTo))
                        {
                            OutputHeaderText(hdcMem, MAKEINTRESOURCEW(idsToField), &cxPos, cyPos, cxLabels, HDRTXT_BOLD|HDRTXT_SYSTEMFONT);
                            cxPos+=CX_LABEL_PADDING;
                        }
                        if (m_pszTo)
                            OutputHeaderText(hdcMem, m_pszTo, &cxPos, cyPos, cxLabels, 0);
                        cxPos+=2*CX_LABEL_PADDING;
                        break;
                        
                    case 'b':
                        // &b is a line break
                        cxPos = CX_LABEL_PADDING;
                        cyPos += cyLine + 2; // bobn: Arbitrary pad so that we don't clip to the line below
                        break;
                        
                    }
                }
                
                pszFmt++;
            }
            
            if (!m_fFocus)
            {
                // if we don't have focus, paint a 3d edge
                rc.top = 0;
                rc.left = 0;
                rc.right = cx;
                rc.bottom = m_cyPreview;
                DrawEdge(hdcMem, &rc, BDR_RAISEDINNER, BF_RECT);
            }            
        }
        
        BitBlt(hdc, 0, 0, cx, cy, hdcMem, 0, 0, SRCCOPY);
        
        if (!m_lpOleObj)
        {
            HBRUSH hBrush = SelectBrush(hdc, GetSysColorBrush(COLOR_WINDOW));
            GetClientRect(m_hwnd, &rc);
            GetDocObjSize(&rc);
            PatBlt(hdc, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, PATCOPY);
            SelectBrush(hdc, hBrush);
        }
        
        SelectObject(hdcMem, hbmOld);
        RestoreDC(hdcMem, idc);
        
        DeleteObject(hbmMem);
        DeleteDC(hdcMem);
        EndPaint(m_hwnd, &ps);
        return S_OK;
    }
    else
        if (!m_lpOleObj)
        {
            HDC         hdc;
            PAINTSTRUCT ps;
            RECT        rc;
            HBRUSH      hBrush;
            
            GetClientRect(m_hwnd, &rc);
            GetDocObjSize(&rc);
            hdc = BeginPaint(m_hwnd, &ps);
            if (m_dwStyle & MEBF_INNERCLIENTEDGE)
                DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_RECT|BF_ADJUST);
            hBrush = SelectBrush(hdc, GetSysColorBrush(COLOR_WINDOW));
            PatBlt(hdc, rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top, PATCOPY);
            SelectBrush(hdc, hBrush);
            EndPaint(m_hwnd, &ps);
            return S_OK;
        }

    return S_FALSE;
}


LONG CBody::lGetLineHeight(HDC hdc)
{
    HFONT       hfontOld=0,
                hFont;
    TEXTMETRIC  tm;

    if (hdc)
        GetTextMetrics(hdc, &tm);
    else
    {
        // Calculate the height of the line: based on the height of the bold font
        hdc=GetDC(NULL);
        
        if (m_pFontCache &&
            m_pFontCache->GetFont(FNT_SYS_ICON, NULL, &hFont)==S_OK)
            hfontOld = (HFONT)SelectObject(hdc, hFont);
        
        GetTextMetrics(hdc, &tm);
        
        // Set things back
        if (hfontOld)
            SelectObject(hdc, hfontOld);
        ReleaseDC(NULL, hdc);
    }
    
    return tm.tmHeight;
}

HRESULT CBody::RecalcPreivewHeight(HDC hdc)
{
    ULONG       cLines=1;
    LPSTR       psz;
    RECT        rc;

    // default
    if (!m_pszLayout)
        m_pszLayout = PszDup("&f&t&C&b&s");

    // cruise thro' the preview layout string and figure out how many line high we are and the
    // physical pixel height of those lines in the current font

    if (psz = m_pszLayout)
        while (*psz)
        {
            if (*psz == '&' && *(psz+1) == 'b')
                cLines++;
            psz++;
        }

    m_cyPreview = cLines * lGetLineHeight(hdc);
    m_cyPreview+=2*CY_LINE_PADDING;    // padding
    
    if (m_hwndBtnBar)
    {
        // if the button bar is show, account for it.
        GetClientRect(m_hwndBtnBar, &rc);
        rc.bottom+= (2*GetSystemMetrics(SM_CYBORDER));  // factor client edge
        m_cyPreview = max (m_cyPreview, (ULONG)rc.bottom);
    }
    
    
    return S_OK;
}


HRESULT CBody::GetDocObjSize(LPRECT prc)
{
    if(!prc)
        return E_INVALIDARG;

    if (m_uSrcView == MEST_EDIT)
        prc->top+=lGetClientHeight();
        
    if (m_fSrcTabs)
        prc->top+=4;

    if (m_fSrcTabs)
    {
        RECT rc={0};
        
        Assert (m_hwndTab);
        if (TabCtrl_GetItemRect(m_hwndTab, 0, &rc))
            prc->bottom -= (rc.bottom - rc.top) + 2;
        
        InflateRect(prc, -4, -4);
    }

    // make sure we don't make a nonsense rect.
    if(prc->bottom<prc->top)
        prc->bottom=prc->top;

    return NOERROR;
}

HRESULT CBody::UpdatePreviewLabels()
{
    HRESULT hr = S_OK;

    SafeMemFree(m_pszSubject);
    SafeMemFree(m_pszTo);
    SafeMemFree(m_pszCc);
    SafeMemFree(m_pszFrom);

    if (m_pMsgW)
    {
        m_pMsgW->GetAddressFormatW(IAT_CC, AFT_DISPLAY_FRIENDLY, &m_pszCc);

        m_pMsgW->GetAddressFormatW(IAT_FROM, AFT_DISPLAY_FRIENDLY, &m_pszFrom);

        if (FAILED(m_pMsgW->GetAddressFormatW(IAT_TO, AFT_DISPLAY_FRIENDLY, &m_pszTo)))
            MimeOleGetBodyPropW(m_pMsgW, HBODY_ROOT, PIDTOSTR(PID_HDR_NEWSGROUPS), NOFLAGS, &m_pszTo);

        MimeOleGetBodyPropW(m_pMsgW, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, &m_pszSubject);
    }

    InvalidateRect(m_hwnd, NULL, TRUE);
    return hr;
}




HRESULT CBody::OnFocus(BOOL fGotFocus)
{
    if (m_uHdrStyle == MESTYLE_PREVIEW || m_uHdrStyle == MESTYLE_MINIHEADER)
    {
        InvalidateRect(m_hwnd, NULL, TRUE);
        if (m_hwndBtnBar)
            InvalidateRect(m_hwndBtnBar, NULL, TRUE);
    }

    return CDocHost::OnFocus(fGotFocus);
}

HRESULT CBody::OnEraseBkgnd(HDC hdc)
{
    RECT rc;

    GetClientRect(m_hwnd, &rc);
    rc.bottom = lGetClientHeight();
    FillRect(hdc, &rc, GetSysColorBrush(m_fFocus?COLOR_HEADERFOCUS:COLOR_HEADER));
    return S_OK;
}


HRESULT CBody::SetStyle(ULONG uStyle)
{
    if (uStyle == m_uHdrStyle)
        return S_OK;

    m_uHdrStyle = uStyle;
    
    ShowFormatBar(uStyle == MESTYLE_FORMATBAR);
    ShowPreview(uStyle == MESTYLE_PREVIEW);
    Resize();
    return S_OK;
}



LONG CBody::lGetClientHeight()
{
    HWND    hwndFmtbar;
    RECT    rc;

    // even if we don't have a big header, leave a thin
    // line for users to click
    switch (m_uHdrStyle)
        {
        case MESTYLE_PREVIEW:
            return m_cyPreview;
        
        case MESTYLE_MINIHEADER:
            return SMALLHEADERHEIGHT;
        
        case MESTYLE_FORMATBAR:
            
            hwndFmtbar = GetDlgItem(m_hwnd, idcFmtBar);

            if (hwndFmtbar)
            {
                GetClientRect(hwndFmtbar, &rc);
                return rc.bottom-rc.top;
            }
            break;
        }
    return 0;
}


HRESULT CBody::Resize()
{
    RECT rc;

    GetClientRect(m_hwnd, &rc);
    WMSize(rc.right-rc.left, rc.bottom-rc.top);
    InvalidateRect(m_hwnd, NULL, TRUE);
    return S_OK;
}



HRESULT CBody::SetCharset(HCHARSET hCharset)
{
    HRESULT             hr=S_OK;
    BSTR                bstr;
    TCHAR               rgchCset[CCHMAX_CSET_NAME];

    if (hCharset == NULL)
        return E_INVALIDARG;

    if (m_hCharset == hCharset)
        return S_OK;

    if (!m_pDoc)
        return E_UNEXPECTED;

    if (m_fDesignMode)
    {
        // if we're in edit-mode, then we can't reload the document, so we use the trident object
        // model to tell it the charset we want...
        hr = HrGetMetaTagName(hCharset, rgchCset, ARRAYSIZE(rgchCset));
        if (!FAILED(hr))
        {
            hr = HrLPSZToBSTR(rgchCset, &bstr);
            if (!FAILED(hr))
            {
                // this will cause trident to reload with a new meta tag, if the user has changed the charset
                // on the view|language menu
                hr=m_pDoc->put_charset(bstr);
                if (!FAILED(hr))
                {
                    // all went well - switch the language
                    m_hCharset = hCharset;
                }
                SysFreeString(bstr);
            }
        }
        else
        {
            // if lookup in mime database fails, return a good error
            hr = MIMEEDIT_E_CHARSETNOTFOUND;
        }
    }
    else
    {
        // if we're in browse mode, let the base class take care of reloading the document
        if (m_pMsg)
        {
            hr = m_pMsg->SetCharset(hCharset, CSET_APPLY_ALL);
            if (!FAILED(hr))
            {
                IMimeMessage *pMsg=m_pMsg;
                pMsg->AddRef();
                hr = Load(pMsg);
                pMsg->Release();
            }
        }
    }
    
    return hr;
}


HRESULT CBody::PrivateEnableModeless(BOOL fEnable)
{
    if (m_pInPlaceActiveObj)
        m_pInPlaceActiveObj->EnableModeless(fEnable);
    
    return S_OK;
}





HRESULT CBody::ClearDirtyFlag()
{
     return HrSetDirtyFlagImpl(m_pDoc, FALSE);
}



DWORD CBody::DwChooseProperties()
{
    DWORD   dwRet=0;

    // if we are on an image
    if(m_fOnImage)
    {
        m_fOnImage = 0;
        return IDM_IMAGE;
    }
    
    // if we are on an anchor
    if (GetSelectedAnchor(NULL)==S_OK)
        return IDM_HYPERLINK;

    return 0;
}

HRESULT CBody::ShowFormatBar(BOOL fOn)
{
    Assert (m_pFmtBar); // created in Init
        
    if (fOn)
        return m_pFmtBar->Show();
    else
        return m_pFmtBar->Hide();
}


void CBody::WMSize(int cxBody, int cyBody)
{
    RECT    rc,
            rcBar;

    switch (m_uHdrStyle)
        {
        case MESTYLE_FORMATBAR:
            if (m_hwnd)
            {
                HWND    hwndFmtbar = GetDlgItem(m_hwnd, idcFmtBar);
                
                if (hwndFmtbar)
                {
                    // if the format bar is on adjust the window rect accordingly
                    GetClientRect(hwndFmtbar, &rc);
                    SetWindowPos(hwndFmtbar, NULL, m_fSrcTabs?4:0, m_fSrcTabs?4:0, cxBody-(m_fSrcTabs?8:0), rc.bottom-rc.top, SWP_NOACTIVATE|SWP_NOZORDER);
                }
            }
            break;
        
        case MESTYLE_PREVIEW:
            // center toolbar in the preview header and right-align it (note: account for the client edge we paint)
            if (m_hwndBtnBar)
            {
                GetClientRect(m_hwndBtnBar, &rcBar);
                SetWindowPos(m_hwndBtnBar, NULL, cxBody - rcBar.right - (GetSystemMetrics(SM_CXBORDER)*2), (m_cyPreview - rcBar.bottom)/2, 0, 0,SWP_NOACTIVATE|SWP_NOOWNERZORDER|SWP_NOZORDER|SWP_NOSIZE);
            }
            break;
        }

    if (m_fSrcTabs)
    {
        RECT rc;
        
        Assert (m_hwndTab);
        GetClientRect(m_hwnd, &rc);
        GetDocObjSize(&rc);
        
        SetWindowPos(m_hwndTab, HWND_BOTTOM, 0, 0, cxBody, cyBody, SWP_NOACTIVATE);
        if (m_pSrcView)
            m_pSrcView->SetRect(&rc);
    }
    CDocHost::WMSize(cxBody, cyBody);
}

HRESULT CBody::InsertTextAtCaret(BSTR bstr, BOOL fHtml, BOOL fMoveCaretToEnd)
{
    IHTMLTxtRange           *pTxtRange=0;
    HRESULT                 hr=E_FAIL;

    if (!FAILED(hr = GetSelection(&pTxtRange)))
    {
        if(fHtml)
            hr=pTxtRange->pasteHTML(bstr);
        else
            hr=pTxtRange->put_text(bstr);
        
        pTxtRange->collapse( fMoveCaretToEnd ? VARIANT_FALSE : VARIANT_TRUE);
        pTxtRange->select();
        pTxtRange->Release();
    }
    return hr;
}


HRESULT CBody::UpdateCommands()
{
    IHTMLTxtRange           *pTxtRange=0;

    if (m_pFmtBar)
        m_pFmtBar->Update();

    if (m_pParentCmdTarget)
        m_pParentCmdTarget->Exec(NULL, OLECMDID_UPDATECOMMANDS, 0, NULL, NULL);

    return S_OK;
}


LRESULT CBody::WMNotify(WPARAM wParam, NMHDR* pnmhdr)
{
    HFONT   hFont;
    LRESULT lRet;

    if (m_pSrcView &&
        m_pSrcView->OnWMNotify(wParam, pnmhdr, &lRet)==S_OK)
        return lRet;

    switch (wParam)
    {
        case idcTabs:
            switch (pnmhdr->code)
            {
                case TCN_SELCHANGE:
                    ShowSourceView(TabCtrl_GetCurSel(m_hwndTab));
                    break;

                case TCN_SELCHANGING:
                    if (m_fReloadingSrc)
                    {
                        // while loading, prevent switching of tabs
                        MessageBeep(MB_ICONSTOP);
                        return TRUE;
                    }
                    break;
            }
            break;
        
        case idcFmtBar:
            switch (pnmhdr->code)
            {
            case FBN_GETMENUFONT:
                hFont = 0;
                if (m_pFontCache)
                    m_pFontCache->GetFont(FNT_SYS_MENU, NULL, &hFont);
            
                return (LPARAM)hFont;
            
            case FBN_BODYSETFOCUS:
                UIActivate(FALSE);
                UIActivate(TRUE);
                return 0;
            
            case FBN_BODYHASFOCUS:
                return m_fFocus;
            }
            break;
        
        case idcBtnBar:
            switch (pnmhdr->code)
            {
            case NM_RCLICK:
                if (((NMCLICK *)pnmhdr)->dwItemSpec == idmPanePaperclip)
                    ShowAttachMenu(TRUE);
                break;

            case TBN_DROPDOWN:
                if (((TBNOTIFY *)pnmhdr)->iItem == idmPanePaperclip)
                    ShowAttachMenu(FALSE);
                break;
            }
            break;
    }
    return 0;
}



HRESULT CBody::SetHostComposeFont()
{
    VARIANTARG  va;
    
    va.bstrVal = NULL;

    if (m_pParentCmdTarget)
        m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_COMPOSE_FONT, OLECMDEXECOPT_DODEFAULT, NULL, &va);

    SetComposeFont(va.bstrVal);
    SysFreeString(va.bstrVal);
    return S_OK;
}

HRESULT CBody::SetComposeFont(BSTR bstr)
{
    VARIANTARG  va;

    va.vt = VT_BOOL;
    va.boolVal = bstr?VARIANT_TRUE:VARIANT_FALSE;

    if (m_pCmdTarget)
    {
        // turn OFF HTML-Edit mode if bstr==NULL
        m_pCmdTarget->Exec(&CMDSETID_Forms3, IDM_HTMLEDITMODE, OLECMDEXECOPT_DODEFAULT, &va, NULL);
        if (bstr)
        {
            va.vt = VT_BSTR;
            va.bstrVal = bstr;
            m_pCmdTarget->Exec(&CMDSETID_Forms3, IDM_COMPOSESETTINGS, OLECMDEXECOPT_DODEFAULT, &va, NULL);
        }
    }
    return S_OK;
}


HRESULT CBody::ClearUndoStack()
{
    IOleUndoManager     *pUndoManager;
    IServiceProvider    *pSP;
    HRESULT         hr;

    if (!m_lpOleObj)
        return E_FAIL;

    if (!FAILED(hr=m_lpOleObj->QueryInterface(IID_IServiceProvider, (LPVOID *)&pSP)))
    {
        if (!FAILED(hr = pSP->QueryService(SID_SOleUndoManager, IID_IOleUndoManager, (LPVOID *)&pUndoManager)))
        {
            hr = pUndoManager->DiscardFrom(NULL);
            pUndoManager->Release();
        }
        pSP->Release();
    }
    return hr;
}

HRESULT CBody::DowngradeToPlainText(BOOL fForceFixedFont)
{
    IHTMLElement    *pElem=0;
    IHTMLStyle      *pStyle=0;
    IHTMLTxtRange   *pTxtRange;

    BSTR            bstr=0;

    m_pDoc->get_body(&pElem);
    if (pElem)
    {
        pElem->get_innerText(&bstr);    // might be NULL if only images
        pElem->put_innerText(bstr);
        HrRemoveStyleSheets(m_pDoc);
        HrRemoveBackground(m_pDoc);
        SetWindowBgColor(TRUE);         // force back to default color
        SysFreeString(bstr);
        
        if (fForceFixedFont)
        {
            // add <STYLE: font-family: monospace> to the body tag
            pElem->get_style(&pStyle);
            if (pStyle)
            {
                pStyle->put_fontFamily((BSTR)c_bstr_MonoSpace);
                pStyle->Release();
            }
        }        
        
        if (m_fDesignMode)
        {
            // set caret at start
            if (!FAILED(CreateRange(&pTxtRange)))
            {
                pTxtRange->collapse(VARIANT_TRUE);
                pTxtRange->select();
                pTxtRange->Release();
            }
        }

        pElem->Release();
    }

    ClearUndoStack();
    return S_OK;
}

// Returns MIME_S_CHARSET_CONFLICT if can't convert
HRESULT CBody::SafeToEncodeText(ULONG ulCodePage)
{
    HRESULT         hr = S_OK;
    IHTMLElement   *pElem = NULL;
    BSTR            bstr = NULL;
    DWORD           dwTemp = 0;
    INT             cbIn;

    m_pDoc->get_body(&pElem);
    if (pElem)
    {
        pElem->get_innerText(&bstr);
        if (NULL != bstr)
        {
            cbIn = SysStringByteLen(bstr);

            IF_FAILEXIT(hr = ConvertINetString(&dwTemp, CP_UNICODE, ulCodePage, (LPCSTR)bstr, &cbIn, NULL, NULL));
            if (S_FALSE == hr)
                hr = MIME_S_CHARSET_CONFLICT;
        }
    }

exit:
    ReleaseObj(pElem);
    SysFreeString(bstr);
    return hr;
}

HRESULT CBody::SetDocumentText(BSTR bstr)
{
    IHTMLTxtRange           *pTxtRange;
    HRESULT                 hr;

    if (!m_lpOleObj)
        return CO_E_NOT_SUPPORTED;

    hr = CreateRange(&pTxtRange);
    if (!FAILED(hr))
    {
        hr=pTxtRange->pasteHTML(bstr);
        if (!FAILED(hr))
        {
            ClearDirtyFlag();
            // we not empty anymore
            m_fEmpty=FALSE;
        }
        pTxtRange->Release();
    }
    return hr;
}



HRESULT CBody::FormatFont()
{
    return m_pCmdTarget?m_pCmdTarget->Exec(&CMDSETID_Forms3, IDM_FONT, OLECMDEXECOPT_DODEFAULT,  NULL, NULL):E_FAIL;
}



HRESULT CBody::PasteReplyHeader()
{
    HRESULT             hr=S_OK;
    ULONG               uHdrStyle=0;
    LPSTREAM            pstm;
    DWORD               dwFlags=0,
                        dwHdr;
    IHTMLTxtRange       *pRange;
    IOleCommandTarget   *pCmdTarget;
    VARIANTARG          va;

    if (m_pParentCmdTarget)
    {
        if (m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_HEADER_TYPE, 0, NULL, &va)==S_OK)
            uHdrStyle = va.lVal;
        GetHostFlags(&dwFlags);    
    }
    
    if ((uHdrStyle != MEHEADER_NONE) && 
        (dwFlags & MEO_FLAGS_INCLUDEMSG))
    {
        // check to see if the rootstream inserted the auto reply header placeholder
        // if so, replace it
        Assert ((uHdrStyle & MEHEADER_NEWS) || (uHdrStyle & MEHEADER_MAIL));
        
        dwHdr = HDR_PADDING|(dwFlags&MEO_FLAGS_HTML?HDR_HTML:HDR_PLAIN);
        
        if (uHdrStyle & MEHEADER_NEWS)
            dwHdr |= HDR_NEWSSTYLE;
        
        if (uHdrStyle & MEHEADER_FORCE_ENGLISH)
            dwHdr |= HDR_HARDCODED;
        
        pstm = NULL;
        if (SUCCEEDED(hr=GetHeaderTable(m_pMsgW, NULL, dwHdr, &pstm)))
        {
            BSTR    bstr;
            
            if (SUCCEEDED(hr = HrIStreamWToBSTR(pstm, &bstr)))
            {
                // paste reply-headers at the top of the message
                InsertBodyText(bstr, IBTF_URLHIGHLIGHT);
                SysFreeString(bstr);
            }
            pstm->Release();
        }
        
        if (dwFlags & MEO_FLAGS_BLOCKQUOTE)
        {
            // block quote the text
            if (SUCCEEDED(CreateRange(&pRange)))
            {
                if (SUCCEEDED(pRange->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&pCmdTarget)))
                {
                    if (pCmdTarget->Exec(&CMDSETID_Forms3, IDM_INDENT, NULL, NULL, NULL)==S_OK)
                    {
                        if (m_pParentCmdTarget &&
                            m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_REPLY_TICK_COLOR, 0, 0, &va)==S_OK)
                            FormatBlockQuote((COLORREF)va.lVal); 
                    }
                    pCmdTarget->Release();
                }
                pRange->Release();
            }
        }        
        
        
        if (dwFlags & MEO_FLAGS_DONTSPELLCHECKQUOTED)
            CreateRange(&m_pRangeIgnoreSpell);
        
    }
    return hr;
}

HRESULT CBody::InsertBodyText(BSTR bstrPaste, DWORD dwFlags)
{
    IHTMLElement        *pElem;
    IHTMLBodyElement    *pBodyElem;
    HRESULT             hr=E_FAIL;

    if (!FAILED(GetBodyElement(&pBodyElem)))
    {
        if (!FAILED(pBodyElem->QueryInterface(IID_IHTMLElement, (LPVOID *)&pElem)))
        {
            hr = pElem->insertAdjacentHTML((BSTR)(dwFlags & IBTF_INSERTATEND ?c_bstr_BeforeEnd:c_bstr_AfterBegin), bstrPaste);
            
            IHTMLTxtRange       *pRange;
            LONG                cch;
            
            if (!FAILED(hr) && (dwFlags & IBTF_URLHIGHLIGHT))
            {
                if (CreateRangeFromElement(pElem, &pRange)==S_OK)
                {
                    if (!FAILED(pRange->collapse(VARIANT_TRUE)))
                    {
                        if (!FAILED(pRange->moveEnd((BSTR)c_bstr_Character, (LONG)SysStringLen(bstrPaste), (LPLONG)&cch)) && cch!=0)
                            UrlHighlight(pRange);
                    }
                    pRange->Release();
                }
            }
            
            pElem->Release();
        }
        pBodyElem->Release();
    }
    return hr;
}


HRESULT CBody::FormatBlockQuote(COLORREF crTextColor)
{
    HRESULT hr;
    IHTMLElementCollection  *pCollect;
    IHTMLStyle              *pStyle=0;
    IHTMLElement            *pElem;
    ULONG                   cItems;
    TCHAR                   rgch[CCHMAX_STRINGRES];
    BSTR                    bstr;
    VARIANT                 v;

    if (!FAILED(HrGetCollectionOf(m_pDoc, (BSTR)c_bstr_BLOCKQUOTE, &pCollect)))
    {
        cItems = (int)UlGetCollectionCount(pCollect);
        if (cItems > 0 &&
            !FAILED(HrGetCollectionItem(pCollect, 0, IID_IHTMLElement, (LPVOID *)&pElem)))
        {
            pElem->get_style(&pStyle);
            if (pStyle)
            {
                // set the style on the elemen
                // .replyTick { border-left:solid ; border-left-width: 4;
                // border-color: #0000ff; padding-left: 5;
                // margin-left: 5}
                // 5/19/98: fix margin on nesting:
                // padding-right: 0, margin-right:0 
                wnsprintf(rgch, ARRAYSIZE(rgch), "solid 2 #%02x%02x%02x", GetRValue(crTextColor), GetGValue(crTextColor), GetBValue(crTextColor));
                
                if (HrLPSZToBSTR(rgch, &bstr)==S_OK)
                {
                    pStyle->put_borderLeft(bstr);
                    SysFreeString(bstr);
                }
                
                // set the padding and the margin
                v.vt = VT_I4;
                v.lVal = 5;
                pStyle->put_paddingLeft(v);
                pStyle->put_marginLeft(v);
                v.lVal = 0;
                pStyle->put_paddingRight(v);
                pStyle->put_marginRight(v);
                pStyle->Release();
            }
            // first dude in the collection should be the one at the root of the tree
            pElem->Release();
        }
        pCollect->Release();
    }
    return S_OK;
}


HRESULT CBody::GetAutoText(BSTR *pbstr, BOOL *pfTop)
{
    HRESULT         hr;
    BOOL            fSig;
    ULONG           uSigOpt;
    TCHAR           rgchAutoText[4096]; // buffer big enough to build autotext into
    VARIANTARG      va;

    if (!m_pParentCmdTarget)
        return E_FAIL;
    
    if (pfTop)
        *pfTop = TRUE;
    
    *rgchAutoText = 0;
    
    va.vt = VT_I4;
    va.lVal = MESIG_AUTO;        
    fSig = (m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_SIGNATURE_ENABLED, 0, &va, NULL)==S_OK);
    if (fSig &&
        m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_SIGNATURE_OPTIONS, 0, NULL, &va)==S_OK)
    {
        Assert(va.vt==VT_I4);
        uSigOpt = va.lVal;
    }
    
    /*
    let's build a BSTR of the HTML we want to insert.
    
      <DIV>
      <SPAN id=\"__CaretPos__\"><BR></SPAN>
      </DIV>
      <DIV>
      <SPAN id="__Signature__"></SPAN>
      </DIV>
    */
    
    StrCatBuff(rgchAutoText, c_szHtml_DivOpen, ARRAYSIZE(rgchAutoText));
    StrCatBuff(rgchAutoText, c_szCaretSpanTag, ARRAYSIZE(rgchAutoText));
    StrCatBuff(rgchAutoText, c_szHtml_DivClose, ARRAYSIZE(rgchAutoText));
    
    if (fSig)
    {
        StrCatBuff(rgchAutoText, c_szHtml_DivOpen, ARRAYSIZE(rgchAutoText));
        StrCatBuff(rgchAutoText, c_szSignatureSpanTag, ARRAYSIZE(rgchAutoText));
        StrCatBuff(rgchAutoText, c_szHtml_DivClose, ARRAYSIZE(rgchAutoText));
    }
    
    if (pfTop && fSig && uSigOpt & MESIGOPT_BOTTOM)
        *pfTop = FALSE;

    // can use ACP for this conversion as we know all the text is lowansi
    return HrLPSZToBSTR(rgchAutoText, pbstr);
}

HRESULT CBody::PasteAutoText()
{
    HRESULT         hr=S_OK;
    LPSTREAM        pstm;
    DWORD           dwFlags=0;
    BSTR            bstrAutoText=0,
                    bstrSig=0;
    IHTMLElement    *pElem;
    BOOL            fPasteAtTop=TRUE;
    DWORD           dwSigOpt=0;
    VARIANTARG      va;

/*
    For AutoText, we search for a <SPAN> tag that indicates where the caret should be. 
    To find the caret, we use the following rules
        1. look for "_AthCaret"         this is used by a stationery author to set the caret for the stationery
        2. look for "__Ath_AutoCaret"   this is inserted by the rootstream it maybe at the top or bottom (sigopts)
                                        of the document. It should always be present if autotext is needed

    when we find the caret, we insert the auto-text stream we build (contains compose font and/or signature) and
    put the caret at the start of this.
*/
       
    GetHostFlags(&dwFlags);
    
    if (dwFlags & MEO_FLAGS_AUTOTEXT &&
        !FAILED(GetAutoText(&bstrAutoText, &fPasteAtTop)))
    {
        // try a stationery-authored caret
        if (FAILED(ReplaceElement("_AthCaret", bstrAutoText, TRUE)))
        {
            // if there wasn't one, then put at start or end of the body
            // depending on signature
            InsertBodyText(bstrAutoText, fPasteAtTop ? 0:IBTF_INSERTATEND);
        }
        
        va.vt = VT_I4;
        va.lVal = MESIG_AUTO;        
        
        // let's try and insert the signature now.
        if (m_pParentCmdTarget &&
            (m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_SIGNATURE_ENABLED, 0, &va, NULL)==S_OK) &&
            (m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_SIGNATURE_OPTIONS, 0, NULL, &va)==S_OK) && 
            va.vt==VT_I4)
        {
            dwSigOpt = va.lVal;
            if (m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_SIGNATURE, 0, NULL, &va)==S_OK && 
                va.vt==VT_BSTR)
            {
                bstrSig = va.bstrVal;
                // sleazy v2. workaround. Trident pulled out the springloader font code from
                // CElem::put_outerText, so plain-signatures etc no longer go in in the 
                // compose font. We fix this by inserting an &nbsp after the signature span
                // (if there is one) then we can select the nbsp; and paste at that range.
                if (!FAILED(GetElement(c_szSignatureSpan, &pElem)))
                {
                    IHTMLTxtRange *pRange;
                    
                    if (CreateRangeFromElement(pElem, &pRange)==S_OK)
                    {
                        // small change. Now we put in &nbsp;<SPAN>&nbsp; we move the range to
                        // the span and then expand it a char left and right. This range includes the span
                        // do it get's nuked when we paste.
                        LONG cch;
                        
                        SideAssert(pRange->moveEnd((BSTR)c_bstr_Character, 1, &cch)==S_OK && cch==1);
                        SideAssert(pRange->moveStart((BSTR)c_bstr_Character, -1, &cch)==S_OK && cch==-1);
                        
                        if (dwSigOpt & MESIGOPT_HTML)
                            pRange->pasteHTML(bstrSig);
                        else
                        {
                            if(dwSigOpt & MESIGOPT_PREFIX)
                            {
                                BSTR    bstrPrefix;
                                
                                // if a prefix is required (for news), then append one
                                if (HrLPSZToBSTR(c_szSigPrefix, &bstrPrefix)==S_OK)
                                {
                                    pRange->put_text(bstrPrefix);
                                    pRange->collapse(VARIANT_FALSE);
                                    SysFreeString(bstrPrefix);
                                }
                            }
                            pRange->put_text(bstrSig);
                        }
                        pRange->Release();
                    }
                    pElem->Release();
                }
                SysFreeString(bstrSig);
            }
        }
        // if we sucessfully pasted, set the caret at the span marker we
        // just pasted
        if (!FAILED(GetElement(c_szCaretSpan, &pElem)))
        {
            SelectElement(pElem, TRUE);
            DeleteElement(pElem);
            pElem->Release();
        }
        
        SysFreeString(bstrAutoText);
    }
    
    return S_OK;
}


HRESULT CBody::GetHostFlags(LPDWORD pdwFlags)
{
    VARIANTARG  va;
    HRESULT     hr=E_FAIL;
    
    *pdwFlags = 0;
    
    if (m_pParentCmdTarget &&
        !FAILED(hr = m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_FLAGS, 0, NULL, &va)))
        *pdwFlags = va.lVal;

    return hr;
}


HRESULT CBody::GetBackgroundColor(DWORD *pdwColor)
{
    HRESULT             hr;
    IHTMLBodyElement   *pBodyElem=0;
    VARIANT             var;
    TCHAR              *lpszColor = NULL;

    var.vt = VT_BSTR;
    var.bstrVal = NULL;

    hr = GetBodyElement(&pBodyElem);
    if (FAILED(hr))
        goto error;

    hr = pBodyElem->get_bgColor(&var);
    if (FAILED(hr))
        goto error;

    if (var.bstrVal)
    {
        hr = HrBSTRToLPSZ(CP_ACP, var.bstrVal, &lpszColor);
        if (FAILED(hr))
            goto error;
        
        // get_bgColor returns format "#RRGGBB"
        // Only send in "RRGGBB" part of the string
        GetRGBFromString(pdwColor, lpszColor+1);
    }
    else
        *pdwColor = 0x00FFFFFF | GetSysColor(COLOR_WINDOW);

error:
    ReleaseObj(pBodyElem);
    SafeMemFree(lpszColor);
    SysFreeString(var.bstrVal);
    return hr;
}

HRESULT CBody::SetBackgroundColor(DWORD dwColor)
{
    HRESULT             hr;
    IHTMLBodyElement   *pBodyElem=0;
    VARIANT             var;
    TCHAR               szColor[7];  //"#RRGGBB\0"
    BSTR                bstrColor = NULL;

    GetStringRGB(dwColor, szColor);
    hr = HrLPSZToBSTR(szColor, &bstrColor);
    if (FAILED(hr))
        goto error;

    var.vt = VT_BSTR;
    var.bstrVal = bstrColor;

    hr = GetBodyElement(&pBodyElem);
    if (FAILED(hr))
        goto error;

    hr = pBodyElem->put_bgColor(var);

error:
    ReleaseObj(pBodyElem);
    SysFreeString(bstrColor);

    return hr;
}

HRESULT CBody::SetWindowBgColor(BOOL fForce)
{
    HRESULT                 hr;
    IHTMLBodyElement        *pBodyElem=0;
    CHAR                    szBuf[MAX_PATH] = {0};
    DWORD                   dColors = 0;
    VARIANT                 v1, v2;

    v1.vt = VT_BSTR;
    v1.bstrVal = NULL;
    v2.vt = VT_BSTR;
    v2.bstrVal = NULL;

    hr = GetBodyElement(&pBodyElem);
    if (FAILED(hr))
        goto error;

    hr=pBodyElem->get_bgColor(&v1);
    if (FAILED(hr))
        goto error;
    
    if(NULL != v1.bstrVal && !fForce)
        goto error;

    dColors = GetSysColor(COLOR_WINDOW);
    GetStringRGB(dColors, szBuf);

    hr=HrLPSZToBSTR(szBuf, &(v2.bstrVal));
    if (FAILED(hr))
        goto error;

    hr=pBodyElem->put_bgColor(v2);
    if (FAILED(hr))
        goto error;

error:
    ReleaseObj(pBodyElem);
    SysFreeString(v1.bstrVal);
    SysFreeString(v2.bstrVal);
    return hr;
}

#define CCBMAX_FRAMESEARCH  4096

HRESULT CBody::InsertFile(BSTR bstrFileName)
{
    OPENFILENAMEW   ofn;
    WCHAR           wszFile[MAX_PATH],
                    wszTitle[CCHMAX_STRINGRES],                    
                    wszFilter[100],
                    wszDefExt[30];
    BYTE            pbHtml[CCBMAX_FRAMESEARCH];
    HRESULT         hr;
    LPSTREAM        pstm = NULL;
    DWORD           dwFlags=0;
    BOOL            fHtml;
    ULONG           cb=0;    
    
    if (!m_lpOleObj)
        IF_FAILEXIT(hr = E_FAIL);
    
    *wszFile = 0;
    *wszTitle = 0;
    *wszFilter = 0;
    *wszDefExt = 0;
    
    // Load Res Strings
    GetHostFlags(&dwFlags);
    
    if (bstrFileName)
    {
        // if we have a filename, let's use that else prompt for one
        StrCpyNW(wszFile, (LPWSTR)bstrFileName, ARRAYSIZE(wszFile));
    }
    else
    {
        LoadStringWrapW(g_hLocRes, dwFlags&MEO_FLAGS_HTML?idsTextOrHtmlFileFilter:idsTextFileFilter, wszFilter, ARRAYSIZE(wszFilter));
        ReplaceCharsW(wszFilter, L'|', L'\0');
        LoadStringWrapW(g_hLocRes, idsDefTextExt, wszDefExt, ARRAYSIZE(wszDefExt));
        LoadStringWrapW(g_hLocRes, idsInsertTextTitle, wszTitle, ARRAYSIZE(wszTitle));
        
        // Setup Save file struct
        ZeroMemory (&ofn, sizeof (ofn));
        ofn.lStructSize = sizeof (ofn);
        ofn.hwndOwner = m_hwnd;
        ofn.lpstrFilter = wszFilter;
        ofn.nFilterIndex = 1;
        ofn.lpstrFile = wszFile;
        ofn.nMaxFile = ARRAYSIZE(wszFile);
        ofn.lpstrTitle = wszTitle;
        ofn.lpstrDefExt = wszDefExt;
        ofn.Flags = OFN_FILEMUSTEXIST|OFN_HIDEREADONLY|OFN_NOCHANGEDIR;
        
        // Show OpenFile Dialog
        if (!GetOpenFileNameWrapW(&ofn))
            return NOERROR;
    }
    
    if (*wszFile==NULL)
        IF_FAILEXIT(hr = E_FAIL);

    IF_FAILEXIT(hr=OpenFileStreamW(wszFile, OPEN_EXISTING, GENERIC_READ, &pstm));

    fHtml = (dwFlags&MEO_FLAGS_HTML)&&FIsHTMLFileW(wszFile);

    if (fHtml)
    {     
        BOOL fFrames = FALSE;
        BOOL fLittleEndian;

        // if html, do a quick scan of the first 2k for a frameset
        pstm->Read(pbHtml, sizeof(pbHtml) - 2, &cb);
        pbHtml[cb] = 0;
        pbHtml[cb+1] = 0;

        // if we found a frameset tag, warn the user
        if (S_OK == HrIsStreamUnicode(pstm, &fLittleEndian))
        {
            if(StrStrIW((WCHAR*)pbHtml, L"<FRAMESET"))
                fFrames = TRUE;
        }
        else if (StrStrI((CHAR*)pbHtml, "<FRAMESET"))
            fFrames = TRUE;

        if (fFrames)
            AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsInsertTextTitle), MAKEINTRESOURCEW(idsErrInsertFileHasFrames), NULL, MB_OK);
    }

    IF_FAILEXIT(hr=InsertStreamAtCaret(pstm, fHtml));

exit:
    ReleaseObj(pstm);
    return hr;
}


HRESULT CBody::InsertStreamAtCaret(LPSTREAM pstm, BOOL fHtml)
{
    BSTR            bstr;
    HRESULT         hr;
    UINT            uiCodePage = 0 ;
    INETCSETINFO    CsetInfo ;
    LPSTR           pszCharset=NULL;
    HCHARSET        hCharset=NULL;
    IStream         *pstm2;

    HrRewindStream(pstm);

    if (fHtml)
    {
        if (SUCCEEDED(MimeOleCreateVirtualStream(&pstm2)))
        {
            if (SUCCEEDED(HrCopyStream(pstm, pstm2, 0)))
            {
                // if HTML then try and SNIFF the charset from the document
                if (GetHtmlCharset(pstm2, &pszCharset)==S_OK)
                {
                    MimeOleFindCharset(pszCharset, &hCharset);
                    MemFree(pszCharset);
                }
            }

            // Free up the stream
            pstm2->Release();
        }
    }
    
    // if nothing so far, try the message-charset
    if (!hCharset)
        hCharset = m_hCharset;
        
    if (hCharset)
    {
        // get CodePage from HCHARSET
        MimeOleGetCharsetInfo(hCharset,&CsetInfo);
        uiCodePage = CsetInfo.cpiInternet;
    }

    hr=HrIStreamToBSTR(uiCodePage ? uiCodePage : GetACP(), pstm, &bstr);
    if (!(FAILED(hr)))
    {
        hr = InsertTextAtCaret(bstr, fHtml, TRUE);
        SysFreeString(bstr);
    }
    return hr;
}


HRESULT CALLBACK FreeDataObj(PDATAOBJINFO pDataObjInfo, DWORD celt)
{
    // Loop through the data and free it all
    if (pDataObjInfo)
        {
        for (DWORD i = 0; i < celt; i++)
            SafeMemFree(pDataObjInfo[i].pData);
        SafeMemFree(pDataObjInfo);    
        }
    return S_OK;
}

HRESULT CBody::CreateFontCache(LPCSTR pszTridentKey)
{
    VARIANTARG          va;
    HRESULT             hr=S_OK;
    IConnectionPoint   *pCP;

    // time to try and create a font cache. First of all, ask the host if he has one already that we should use
    // if so, we're done. If not, create based on pszTridentKey. If this is NULL we use the IE regkey

    if (m_pFontCache)
        return S_OK;

    if (m_pParentCmdTarget &&
        m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_FONTCACHE, 0, NULL, &va)==S_OK && 
        va.vt == VT_UNKNOWN)
    {
        ReplaceInterface(m_pFontCache, (IFontCache *)va.punkVal);
        (va.punkVal)->Release();
        goto done;
    }
    
    if(g_lpIFontCache)
    {
        ReplaceInterface(m_pFontCache, g_lpIFontCache);
        goto done;
    }
    
done:

    if (m_pFontCache && 
        m_pFontCache->QueryInterface(IID_IConnectionPoint, (LPVOID *)&pCP)==S_OK)
    {
        pCP->Advise((IUnknown *)(IFontCacheNotify *)this, &m_dwFontCacheNotify);
        pCP->Release();
    }

    RecalcPreivewHeight(NULL);
    return hr;
}



HRESULT CBody::DoHostProperties()
{
    return m_pParentCmdTarget?m_pParentCmdTarget->Exec(NULL, OLECMDID_PROPERTIES, 0, NULL, NULL):E_FAIL;
}



HRESULT CBody::SaveAsStationery(VARIANTARG *pvaIn, VARIANTARG *pvaOut)
{
    BSTR                        bstr=0;
    LPSTREAM                    pstm=0,
                                pstmImage=0;
    LPSTR                       lpsz,
                                lpszName;
    TCHAR                       rgch[MAX_PATH],
                                sz[MAX_PATH+CCHMAX_STRINGRES],
                                rgchRes[CCHMAX_STRINGRES],
                                rgchExt[10];
    TCHAR                       rgchUrl[MAX_PATH],      
                                rgchPath[MAX_PATH];
    OPENFILENAME                ofn;
    TCHAR                       szFile[MAX_PATH];
    TCHAR                       szTitle[CCHMAX_STRINGRES];
    TCHAR                       szFilter[100];
    HRESULT                     hr;
    LPSTR                       pszOpenFilePath=NULL;
    WCHAR                       rgchW[MAX_PATH];

    TraceCall("CBody::SaveAsStationery");

    *rgchUrl=0;
    *rgchPath = 0;
    *szFile = 0;
    *szFilter = 0;

    LoadString(g_hLocRes, idsHtmlFileFilter, szFilter, sizeof(szFilter));
    ReplaceChars(szFilter, '|', '\0');

    LoadString(g_hLocRes, idsSaveAsStationery, szTitle, sizeof(szTitle));

    if (pvaIn && pvaIn->vt==VT_BSTR)
    {
        // if we get passed in an initial path to save into, then use it
        if (WideCharToMultiByte(CP_ACP, 0, (WCHAR*)pvaIn->bstrVal, -1, rgchPath, ARRAYSIZE(rgchPath), NULL, NULL))
            pszOpenFilePath = rgchPath;
    }
    
    // Setup Save file struct
    ZeroMemory (&ofn, sizeof (ofn));
    ofn.lStructSize = sizeof (ofn);
    ofn.hwndOwner = m_hwnd;
    ofn.lpstrFilter = szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = sizeof (szFile);
    ofn.lpstrTitle = szTitle;
    ofn.lpstrInitialDir = rgchPath;
    ofn.Flags = OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY | OFN_NOCHANGEDIR;
    
    // Show OpenFile Dialog
    if (!GetSaveFileName(&ofn) || *szFile==NULL)
        return MIMEEDIT_E_USERCANCEL;
    
    StrCpyN(rgchPath, szFile, ARRAYSIZE(rgchPath));
    rgchPath[ofn.nFileOffset] = NULL;
    
    lpszName = &szFile[ofn.nFileOffset];
    if (ofn.nFileExtension)
    {
        if(szFile[ofn.nFileExtension-1] == '.')
            szFile[ofn.nFileExtension-1]=NULL;
    }
    
    if (FAILED(MimeOleCreateVirtualStream(&pstm)))
        return E_OUTOFMEMORY;
    
    HrGetStyleTag(m_pDoc, &bstr);
    
    pstm->Write(c_szHtml_HtmlOpenCR, lstrlen(c_szHtml_HtmlOpenCR), 0);
    if (bstr)
    {
        pstm->Write(c_szHtml_HeadOpenCR, lstrlen(c_szHtml_HeadOpenCR), 0);
        if (HrBSTRToLPSZ(CP_ACP, bstr, &lpsz)==S_OK)
        {
            pstm->Write(lpsz, lstrlen(lpsz), 0);
            MemFree(lpsz);
        }
        pstm->Write(c_szHtml_HeadCloseCR, lstrlen(c_szHtml_HeadCloseCR), 0);
    }
    SysFreeString(bstr);
    
    if (GetBackgroundImage(m_pDoc, &bstr)==S_OK)
    {
        if (HrBSTRToLPSZ(CP_ACP, bstr, &lpsz)==S_OK)
        {
            if (HrBindToUrl(lpsz, &pstmImage)!=S_OK)
                HrFindUrlInMsg(m_pMsg, lpsz, FINDURL_SEARCH_RELATED_ONLY, &pstmImage);
            
            if (pstmImage)
            {
                StrCpyN(rgchUrl, lpszName, ARRAYSIZE(rgchUrl));
                
                // append an extension
                if (HrSniffStreamFileExt(pstmImage, &lpsz)==S_OK) 
                {
                    StrCatBuff(rgchUrl, lpsz, ARRAYSIZE(rgchUrl));
                    SafeMimeOleFree(lpsz);
                }
                
                StrCpyN(rgch, rgchPath, ARRAYSIZE(rgch));
                StrCatBuff(rgch, rgchUrl, ARRAYSIZE(rgch));
                
                if (PathFileExists(rgch))
                {
                    if (!LoadString(g_hLocRes, idsWarnFileExist, rgchRes, ARRAYSIZE(rgchRes)))
                    {
                        hr = E_OUTOFMEMORY;
                        goto error;
                    }
                    wnsprintf(sz, ARRAYSIZE(sz), rgchRes, rgch);
                    
                    // the file exists, warn the dude
                    if (AthMessageBox(m_hwnd, MAKEINTRESOURCE(idsSaveAsStationery), sz, NULL, MB_YESNO|MB_DEFBUTTON2|MB_ICONEXCLAMATION )!=IDYES)
                    {
                        hr = S_OK;
                        goto error;
                    }
                }
                WriteStreamToFile(pstmImage, rgch, CREATE_ALWAYS, GENERIC_WRITE);
                pstmImage->Release();
            }
            MemFree(lpsz);
        }
        SysFreeString(bstr);
    }
    
    if (*rgchUrl)
    {
        // output the body tag with background image
        wnsprintf(rgch, ARRAYSIZE(rgch), c_szHtml_BodyOpenBgCR, rgchUrl);
        pstm->Write(rgch, lstrlen(rgch), 0);
    }
    else
    {
        // reference point for BUG 31874
        if (AthMessageBoxW(m_hwnd, MAKEINTRESOURCEW(idsSaveAsStationery), MAKEINTRESOURCEW(idsWarnBoringStationery), NULL, MB_YESNO|MB_DEFBUTTON2|MB_ICONEXCLAMATION )!=IDYES)
        {
            hr=MIMEEDIT_E_USERCANCEL;
            goto error;
        }    
        pstm->Write(c_szHtml_BodyOpenNbspCR, lstrlen(c_szHtml_BodyOpenNbspCR), 0);
    }
    
    pstm->Write(c_szHtml_BodyCloseCR, lstrlen(c_szHtml_BodyCloseCR), 0);
    pstm->Write(c_szHtml_HtmlCloseCR, lstrlen(c_szHtml_HtmlCloseCR), 0);
    
    StrCpyN(rgch, rgchPath, ARRAYSIZE(rgch));
    StrCatBuff(rgch, lpszName, ARRAYSIZE(rgch));
    StrCatBuff(rgch, ".htm", ARRAYSIZE(rgch));
    WriteStreamToFile(pstm, rgch, CREATE_ALWAYS, GENERIC_WRITE);
    
    if (pvaOut)
    {
        // if set, the caller wants the actual filename that was written, so convert rgch to a BSTR
        pvaOut->vt = VT_BSTR;
        pvaOut->bstrVal = NULL;
        HrLPSZToBSTR(rgch, &pvaOut->bstrVal);
    }

error:
    ReleaseObj(pstm);
    return hr;
}

HRESULT CBody::TagUnreferencedImages()
{
    ULONG                   uImage,
                            cImages;
    IHTMLElementCollection  *pCollect;
    IHTMLBodyElement        *pBody;
    IUnknown                *pUnk;
    BSTR                    bstr;
    CHAR                    szUrl[INTERNET_MAX_URL_LENGTH];

    // BUG: we can't use the image collection, as it shows images up multiple times
    // for NAV compatibility. Have to filter the 'all' collection on "IMG" tags.
    
    if (HrGetCollectionOf(m_pDoc, (BSTR)c_bstr_IMG, &pCollect)==S_OK)
    {
        cImages = UlGetCollectionCount(pCollect);
        
        for (uImage=0; uImage<cImages; uImage++)
        {
            if (HrGetCollectionItem(pCollect, uImage, IID_IUnknown, (LPVOID *)&pUnk)==S_OK)
            {
                if (HrGetMember(pUnk, (BSTR)c_bstr_SRC, VARIANT_FALSE, &bstr)==S_OK)
                {
                    if (WideCharToMultiByte(CP_ACP, 0, bstr, -1, szUrl, INTERNET_MAX_URL_LENGTH, NULL, NULL) &&
                        HrFindUrlInMsg(m_pMsg, szUrl, FINDURL_SEARCH_RELATED_ONLY, NULL)!=S_OK)
                    {
                        // this URL was not in the message, let's tag it as a NOSEND url
                        HrSetMember(pUnk, (BSTR)c_bstr_NOSEND, (BSTR)c_bstr_1);
                    }                
                    SysFreeString(bstr);
                }
                pUnk->Release();
            }
        }
        pCollect->Release();
    }
    
    // if the background is not included tag as NOSEND
    if (!FAILED(GetBodyElement(&pBody)))
    {
        if (!FAILED(GetBackgroundImage(m_pDoc, &bstr)))
        {
            if (WideCharToMultiByte(CP_ACP, 0, bstr, -1, szUrl, INTERNET_MAX_URL_LENGTH, NULL, NULL) &&
                HrFindUrlInMsg(m_pMsg, szUrl, FINDURL_SEARCH_RELATED_ONLY, NULL)!=S_OK)
            {
                HrSetMember(pBody, (BSTR)c_bstr_NOSEND, (BSTR)c_bstr_1);
            }
            SysFreeString(bstr);
        }
        pBody->Release();
    }
    
    return S_OK;
}


HRESULT CBody::FindFrameDownwards(LPCWSTR pszTargetName, DWORD dwFlags, IUnknown **ppunkTargetFrame)
{
    if (ppunkTargetFrame)
        *ppunkTargetFrame=NULL;

    return E_NOTIMPL;
}

HRESULT CBody::FindFrameInContext(LPCWSTR pszTargetName, IUnknown *punkContextFrame, DWORD dwFlags, IUnknown **ppunkTargetFrame) 
{
    return DoFindFrameInContext(m_lpOleObj, (IUnknown *)(IPropertyNotifySink *)this, 
                                pszTargetName, punkContextFrame, dwFlags, ppunkTargetFrame);
}

HRESULT CBody::OnChildFrameActivate(IUnknown *pUnkChildFrame)
{
    return S_OK;
}

HRESULT CBody::OnChildFrameDeactivate(IUnknown *pUnkChildFrame)
{
    return S_OK;
}

HRESULT CBody::NavigateHack(DWORD grfHLNF,LPBC pbc, IBindStatusCallback *pibsc, LPCWSTR pszTargetName, LPCWSTR pszUrl, LPCWSTR pszLocation)
{
    return E_NOTIMPL;
}

HRESULT CBody::FindBrowserByIndex(DWORD dwID,IUnknown **ppunkBrowser)
{
    if (ppunkBrowser)
        *ppunkBrowser=NULL;

    return E_NOTIMPL;
}


HRESULT CBody::ApplyDocumentVerb(VARIANTARG *pvaIn)
{
    HRESULT             hr;
    IHTMLDocument2      *pDoc=0;

    TraceCall("CBody::ApplyDocumentVerb");

    if(pvaIn && pvaIn->vt==VT_UNKNOWN && pvaIn->punkVal)
        pvaIn->punkVal->QueryInterface(IID_IHTMLDocument2, (LPVOID *)&pDoc);

    hr = ApplyDocument(pDoc);
    ReleaseObj(pDoc);
    return hr;
}

HRESULT CBody::ApplyDocument(IHTMLDocument2 *pDocStationery)
{
    HRESULT             hr;

    TraceCall("CBody::ApplyDocument");
    
    if(pDocStationery)
    {
        hr = HrCopyStyleSheets(pDocStationery, m_pDoc);
        if  (!FAILED(hr))
            hr = HrCopyBackground(pDocStationery, m_pDoc);
    }
    else
    {
        hr = HrRemoveStyleSheets(m_pDoc);
        if (!FAILED(hr))
            hr = HrRemoveBackground(m_pDoc);
    }
    return hr;
}



HRESULT CBody::OnWMCreate()
{
    RecalcPreivewHeight(NULL);
    return S_OK;
}



static const TBBUTTON g_rgBtnBarButtons[] = {
        { itbBadSign,   idmPaneBadSigning,      TBSTATE_ENABLED, TBSTYLE_BUTTON,   {0,0}, 0,  2 },
        { itbSigning,   idmPaneSigning,         TBSTATE_ENABLED, TBSTYLE_BUTTON,   {0,0}, 0,  0 },
        { itbEncryption,idmPaneEncryption,      TBSTATE_ENABLED, TBSTYLE_BUTTON,   {0,0}, 0,  1 },
        { itbBadEnc,    idmPaneBadEncryption,   TBSTATE_ENABLED, TBSTYLE_BUTTON,   {0,0}, 0,  3 },
        { itbVCard,     idmPaneVCard,           TBSTATE_ENABLED, TBSTYLE_BUTTON,   {0,0}, 0,  4 },
        { itbPaperclip, idmPanePaperclip,       TBSTATE_ENABLED, TBSTYLE_DROPDOWN, {0,0}, 0,  5 },
    };


HRESULT CBody::InitToolbar()
{
    TCHAR       rgch[CCHMAX_STRINGRES];
    DWORD       dwBtnSize;
    
    if (!m_hwndBtnBar)
    {
        Assert (!m_hIml);
        Assert (!m_hImlHot);
        
        m_hwndBtnBar = CreateWindowEx(0, TOOLBARCLASSNAME, NULL,
            TBSTYLE_TRANSPARENT|TBSTYLE_FLAT|TBSTYLE_TOOLTIPS|WS_CHILD|WS_CLIPSIBLINGS|CCS_NODIVIDER|CCS_NORESIZE|CCS_NOPARENTALIGN,
            0, 0, 32, 100, m_hwnd, (HMENU)idcBtnBar, g_hInst, NULL);
        
        if (!m_hwndBtnBar)
            return E_FAIL;
        
        m_hIml = ImageList_LoadImage(g_hLocRes, MAKEINTRESOURCE(idbPaneBar32), CX_PANEICON, 0, RGB(255, 0, 255), IMAGE_BITMAP, LR_LOADMAP3DCOLORS|LR_CREATEDIBSECTION);
        if (!m_hIml)
            return E_OUTOFMEMORY;
        
        SendMessage(m_hwndBtnBar, TB_SETIMAGELIST, 0, (LPARAM)m_hIml);
        
        m_hImlHot = ImageList_LoadImage(g_hLocRes, MAKEINTRESOURCE(idbPaneBar32Hot), CX_PANEICON, 0, RGB(255, 0, 255), IMAGE_BITMAP, LR_LOADMAP3DCOLORS|LR_CREATEDIBSECTION);
        if (!m_hImlHot)
            return E_OUTOFMEMORY;
        
        SendMessage(m_hwndBtnBar, TB_SETHOTIMAGELIST, 0, (LPARAM)m_hImlHot);
        SendMessage(m_hwndBtnBar, TB_SETMAXTEXTROWS, 0, 0L);
        SendMessage(m_hwndBtnBar, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
        SendMessage(m_hwndBtnBar, TB_ADDBUTTONS, ARRAYSIZE(g_rgBtnBarButtons), (LPARAM)g_rgBtnBarButtons);
        if (LoadString(g_hLocRes, idsBtnBarTTList, rgch, ARRAYSIZE(rgch)))
        {
            ReplaceChars(rgch, '|', '\0');
            SendMessage(m_hwndBtnBar, TB_ADDSTRING,  0, (LPARAM)rgch);
        }
        
        m_cVisibleBtns = 0;
        // set the initial height of the toolbar, based on the button size
        dwBtnSize = (DWORD) SendMessage(m_hwndBtnBar, TB_GETBUTTONSIZE, 0, 0);
        SetWindowPos(m_hwndBtnBar, NULL, 0, 0, 0, HIWORD(dwBtnSize), SWP_NOACTIVATE|SWP_NOOWNERZORDER|SWP_NOZORDER|SWP_NOMOVE);
        // now that we have setup the button height, recalc the preview header height
        RecalcPreivewHeight(NULL);
        Resize();
    }
    return S_OK;
}


HRESULT CBody::UpdateButtons()
{
    ULONG   dwBtnSize,
            uBtn;
    OLECMD  rgSecureCmds[]={{OECSECCMD_ENCRYPTED, 0},
                            {OECSECCMD_SIGNED, 0}};
    RECT    rc;
    int     cxBar;

    Assert (m_hwndBtnBar);

    // hide all the buttons
    m_cVisibleBtns=0;
    for (uBtn = 0; uBtn < ARRAYSIZE(g_rgBtnBarButtons); uBtn++)
        SendMessage(m_hwndBtnBar, TB_HIDEBUTTON, g_rgBtnBarButtons[uBtn].idCommand, MAKELONG(TRUE, 0));

    // turn on the applicable buttons.
    if (m_pAttMenu && m_pAttMenu->HasAttach()==S_OK)
    {
        SendMessage(m_hwndBtnBar, TB_HIDEBUTTON, idmPanePaperclip, MAKELONG(FALSE, 0));
        m_cVisibleBtns++; 
    }
    
    if (m_pAttMenu && m_pAttMenu->HasVCard()==S_OK)
    {
        SendMessage(m_hwndBtnBar, TB_HIDEBUTTON, idmPaneVCard, MAKELONG(FALSE, 0));
        m_cVisibleBtns++;
    }
    
    // see if the host supports our private S/Mime functionality
    // we query the host for the security state of the message, this can take one of 3 forms for both
    // signed and ecrypted: (none, good or bad) represented by (OLECMDF_INVISIBLE, OLECMDF_ENABLED, and OLECMDF_DISABLED) 
    // respectivley
    if (m_pParentCmdTarget)
    {
        if (m_pParentCmdTarget->QueryStatus(&CMDSETID_OESecurity, ARRAYSIZE(rgSecureCmds), rgSecureCmds, NULL)==S_OK)
        {
            if (rgSecureCmds[0].cmdf & OLECMDF_SUPPORTED && !(rgSecureCmds[0].cmdf & OLECMDF_INVISIBLE))
            {
                SendMessage(m_hwndBtnBar, TB_HIDEBUTTON, rgSecureCmds[0].cmdf & OLECMDF_ENABLED ? idmPaneEncryption : idmPaneBadEncryption, MAKELONG(FALSE, 0));
                m_cVisibleBtns++;
            }
            
            if (rgSecureCmds[1].cmdf & OLECMDF_SUPPORTED && !(rgSecureCmds[1].cmdf & OLECMDF_INVISIBLE))
            {
                SendMessage(m_hwndBtnBar, TB_HIDEBUTTON, rgSecureCmds[1].cmdf & OLECMDF_ENABLED ? idmPaneSigning : idmPaneBadSigning, MAKELONG(FALSE, 0));
                m_cVisibleBtns++;
            }
        }
    }

    // size the toolbar based on the number of visible buttons
    dwBtnSize = (DWORD) SendMessage(m_hwndBtnBar, TB_GETBUTTONSIZE, 0, 0);
    cxBar = LOWORD(dwBtnSize)*m_cVisibleBtns;
    GetClientRect(m_hwnd, &rc);
    AssertSz(m_cyPreview >= HIWORD(dwBtnSize), "preview header is too small for the button bar");
    SetWindowPos(m_hwndBtnBar, NULL, rc.right - cxBar, (m_cyPreview - HIWORD(dwBtnSize))/2, LOWORD(dwBtnSize)*m_cVisibleBtns, HIWORD(dwBtnSize),SWP_NOACTIVATE|SWP_NOOWNERZORDER|SWP_NOZORDER|SWP_SHOWWINDOW);
    return S_OK;
}

HRESULT CBody::ShowAttachMenu(BOOL fRightClick)
{
    POINT   pt;

    PointFromButton(idmPanePaperclip, &pt);

    if (m_pAttMenu && m_pAttMenu->HasAttach()==S_OK)
        m_pAttMenu->Show(m_hwnd, &pt, fRightClick);

    return S_OK;
}

HRESULT CBody::ShowPreview(BOOL fOn)
{
    if (fOn)
    {
        UpdatePreviewLabels();
        
        // if user turns on the preview pane after loaded, then defer-create the attachment menu
        if (m_fMessageParsed)
            UpdateBtnBar();
        
    }

    if (m_hwndBtnBar)
        ShowWindow(m_hwndBtnBar, fOn?SW_SHOW:SW_HIDE);

    return S_OK;
}

HRESULT CBody::PointFromButton(int idm, POINT *ppt)
{
    RECT    rc;

    if (!SendMessage(m_hwndBtnBar, TB_GETRECT, idm, (LPARAM)&rc))
        return E_FAIL;

    ppt->x = rc.right;
    ppt->y = rc.bottom;
    ClientToScreen(m_hwndBtnBar, ppt);
    return S_OK;    
}


HRESULT CBody::UpdateBtnBar()
{
    HRESULT     hr;

    // create the attachment menu. This will be destroyed on every load/unload to reflect the new state of the
    // message
    if (!m_pAttMenu && m_pMsg)
        {
        hr = EnsureAttMenu();
        if (FAILED(hr))
            goto error;
        }

    // make sure the button bar is created. This will be created once per preview pane
    hr = InitToolbar();
    if (FAILED(hr))
        goto error;

    hr = UpdateButtons();

error:
    return hr;
}


HRESULT CBody::EnsureAttMenu()
{
    HRESULT hr=S_OK;
        
    if (!m_pAttMenu && m_pMsg)
    {
        m_pAttMenu = new CAttMenu();
        if (!m_pAttMenu)
            return E_OUTOFMEMORY;
        
        hr = m_pAttMenu->Init(m_pMsg, m_pFontCache, m_pParentInPlaceFrame, m_pParentCmdTarget);
        if (FAILED(hr))
            goto error;
    }
error:
    return hr;
}



HRESULT HrSniffUrlForRfc822(LPWSTR pszUrlW)
{
    LPWSTR  lpszW;
    HRESULT hr = S_FALSE;

    if (!FAILED(FindMimeFromData(NULL, pszUrlW, NULL, NULL, NULL, NULL, &lpszW, 0)))
        {
        if (StrCmpW(lpszW, L"message/rfc822")==0)
            hr = S_OK;
        CoTaskMemFree(lpszW);
        }
    return hr;
}

HRESULT CBody::SaveAttachments()
{
    return SaveAttachmentsWithPath(m_hwnd, m_pParentCmdTarget, m_pMsg);
}

HRESULT CBody::InsertBackgroundSound()
{
    ULONG           cRepeat;
    BSTR            bstrUrl;
    BGSOUNDDLG      rBGSound;
    
    rBGSound.wszUrl[0]=0;    // null string
    rBGSound.cRepeat = 1;   // default to 1 repeat
    
    if (GetBackgroundSound(m_pDoc, &rBGSound.cRepeat, &bstrUrl)==S_OK)
    {
        StrCpyNW(rBGSound.wszUrl, bstrUrl, ARRAYSIZE(rBGSound.wszUrl));
        SysFreeString(bstrUrl);
    }
    
    if (S_OK == DoBackgroundSoundDlg(m_hwnd, &rBGSound))
    {
        bstrUrl = SysAllocString(rBGSound.wszUrl);
        if (bstrUrl)
        {
            SetBackgroundSound(m_pDoc, rBGSound.cRepeat, bstrUrl);
            SysFreeString(bstrUrl);
        }
    }
    return S_OK;
}

HRESULT CBody::EnableSounds(BOOL fOn)
{
    VARIANTARG  va;

    va.vt = VT_I4;
    va.lVal = fOn;
    if (m_pCmdTarget)
        m_pCmdTarget->Exec(&CMDSETID_Forms3, IDM_ENABLE_INTERACTION, NULL, &va, NULL);
    return S_OK;
}

HRESULT CBody::ShowSourceTabs(BOOL fOn)
{
    TC_ITEM     tci;
    HFONT       hFont;
    TCHAR       rgch[CCHMAX_STRINGRES];
    WNDCLASSEX  wc;
    int         i;
    
    if (fOn == m_fSrcTabs)
        return S_OK;
    
    if (!fOn && m_hwndTab)
    {       
        // if turning off, make sure we got back to edit-mode
        SetSourceTabs(MEST_EDIT);
    }
    
    if (m_hwndTab)
    {               // already created
        ShowWindow(m_hwndTab, fOn?SW_SHOW:SW_HIDE);
        goto exit;
    }
    
    
    m_hwndTab = CreateWindowEx(0,
        WC_TABCONTROL, 
        NULL,
        WS_CHILD|WS_TABSTOP|WS_VISIBLE|TCS_BOTTOM|TCS_FIXEDWIDTH,
        0, 0, 0, 0,
        m_hwnd, 
        (HMENU)idcTabs, 
        g_hLocRes, 
        NULL);
    if (!m_hwndTab)
        return E_FAIL;
    
    tci.mask = TCIF_TEXT;
    for (i=MEST_EDIT; i<=MEST_PREVIEW; i++)
    {
        LoadString(g_hLocRes, idsEditTab+i, rgch, ARRAYSIZE(rgch));
        tci.pszText = rgch;
        TabCtrl_InsertItem(m_hwndTab, i, &tci);
    }
    
    if (m_pFontCache &&
        m_pFontCache->GetFont(FNT_SYS_ICON, NULL, &hFont)==S_OK)
        SendMessage(m_hwndTab, WM_SETFONT, (WPARAM)hFont, 0);

exit:
    m_fSrcTabs = fOn;
    Resize();
    return S_OK;
}


HRESULT CBody::ShowSourceView(ULONG uSrcView)
{
    IStream *pstm;
    BOOL    fFocus;
    HRESULT hr=S_OK;

    if (m_uSrcView == uSrcView) // noop
        return S_OK;

    /* store information about the current state. we care about
        - who has focus
        - caching the IStream of 'current' HTML
        - dirty states
    */
    switch (m_uSrcView)
    {
        case MEST_EDIT:
            // if switching away from edit-mode remember the dirty state
            m_fWasDirty = IsDirty() == S_OK;
            fFocus = m_fUIActive;
            SafeRelease(m_pstmHtmlSrc);
            GetBodyStream(m_pDoc, TRUE, &m_pstmHtmlSrc);
            break;
            
        case MEST_PREVIEW:
            // m_pstmHtml is not saved from this mode, assume the previous setting
            AssertSz(m_pstmHtmlSrc, "This should be set from a previous switch");
            fFocus = m_fUIActive;
            break;
        
        case MEST_SOURCE:
            // if switching away from source-mode remember the dirty state
            Assert (m_pSrcView);
            SafeRelease(m_pstmHtmlSrc);
            m_pSrcView->Save(&m_pstmHtmlSrc);
            m_fWasDirty = m_pSrcView->IsDirty() == S_OK;
            fFocus = m_pSrcView->HasFocus()==S_OK;
            break;
    }


    m_pDocView->UIActivate(FALSE);

    // at this point m_pstmSrcHtml contains the new HTML source
    switch (uSrcView)
    {
        case MEST_EDIT:
            /* when switching to edit mode.
                - reload trident
                - ensure design-mode
                - restore focus
                - restore dirty state 
                - hide source-view (if shown) 
            */
            SetDesignMode(TRUE);
            _ReloadWithHtmlSrc(m_pstmHtmlSrc);
            HrSetDirtyFlagImpl(m_pDoc, !!m_fWasDirty);
            if (fFocus)
                m_pDocView->UIActivate(TRUE);
            if (m_pSrcView)
                m_pSrcView->Show(FALSE, FALSE);
            m_pDocView->Show(TRUE);
            break;
            
        case MEST_PREVIEW:
            /* when switching to preview mode.
                - reload trident
                - ensure design-mode is OFF
                - restore focus
                - restore dirty state
                - hide source-view (if shown) 
            */
            SetDesignMode(FALSE);
            _ReloadWithHtmlSrc(m_pstmHtmlSrc);
            if (fFocus)
                m_pDocView->UIActivate(TRUE);
            if (m_pSrcView)
                m_pSrcView->Show(FALSE, FALSE);
            m_pDocView->Show(TRUE);
            break;

        case MEST_SOURCE:
            /* when switching to source mode.
                - defer-create the source view window (if needed)
                - hide trident
                - restore focus 
                - restore dirty state */

            hr = _EnsureSrcView();
            if (FAILED(hr))
                goto error;
              
            Assert (m_pSrcView);
            m_pSrcView->Show(TRUE, IsColorSourceEditing()==S_OK);
            m_pSrcView->Load(m_pstmHtmlSrc);
            m_pSrcView->SetDirty(m_fWasDirty);
            m_pDocView->Show(FALSE);
            // restore focus
            if (fFocus)
                m_pSrcView->SetFocus();
            break;
    }

    ShowFormatBar(uSrcView == MEST_EDIT && m_uHdrStyle == MESTYLE_FORMATBAR);
    m_uSrcView = uSrcView;
    Resize();

error:
    return hr;
}


HRESULT CBody::SetSourceTabs(ULONG ulTab)
{
    int     rgNext[3] = {MEST_SOURCE, MEST_PREVIEW, MEST_EDIT},
            rgPrev[3] = {MEST_PREVIEW, MEST_EDIT, MEST_SOURCE};

    if (!m_fSrcTabs)            // do nothing if not in source-tab-mode
        return E_UNEXPECTED;

    switch (ulTab)
    {
        case MEST_NEXT:
            ulTab = rgNext[m_uSrcView];
            break;

        case MEST_PREVIOUS:
            ulTab = rgPrev[m_uSrcView];
            break;

        case MEST_EDIT:
        case MEST_SOURCE:
        case MEST_PREVIEW:
            break;
        
        default:
            return E_INVALIDARG;
    }

    Assert (((int) ulTab) >= MEST_EDIT && ((int) ulTab) <= MEST_PREVIEW);
    ShowSourceView(ulTab);
    TabCtrl_SetCurSel(m_hwndTab, ulTab);
    return S_OK;
} 

HRESULT CBody::IsColorSourceEditing()
{
    VARIANTARG  va;
    
    if (m_pParentCmdTarget &&
        m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_SOURCEEDIT_FLAGS, 0, NULL, &va)==S_OK &&
        va.vt == VT_I4 &&
        !(va.lVal & MESRCFLAGS_COLOR))
        return S_FALSE;

    return S_OK;
}

HRESULT CBody::HrCreateSpeller(BOOL fBkgrnd)
{
    HRESULT     hr;
    VARIANTARG  va;

    if (m_pSpell)
        return NOERROR;

#ifndef BACKGROUNDSPELL
	// just to make sure background spelling is disabled
	Assert(!fBkgrnd);
	fBkgrnd = FALSE;
#endif // !BACKGROUNDSPELL

    if (m_fDesignMode && m_pDoc && m_pParentCmdTarget && FCheckSpellAvail(m_pParentCmdTarget) &&
        SUCCEEDED(m_pParentCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_SPELL_OPTIONS, OLECMDEXECOPT_DODEFAULT, NULL, &va)))
    {
        if (((V_I4(&va) & MESPELLOPT_CHECKONTYPE) && fBkgrnd) || !fBkgrnd)
            m_pSpell = new CSpell(m_pDoc, m_pParentCmdTarget, V_I4(&va));
    }

    if (m_pSpell)
    {
        if (!m_pSpell->OpenSpeller())
        {
            SafeRelease(m_pSpell);
            return E_FAIL;
        }

#ifdef BACKGROUNDSPELL
        if (fBkgrnd)
        {
            SetTimer(m_hwnd, idTimerBkgrndSpell, BKGRNDSPELL_TICKTIME, NULL);
            m_pSpell->HrRegisterKeyPressNotify(TRUE);
            m_fBkgrndSpelling = TRUE;
        }
#endif // BACKGROUNDSPELL
    }

    return m_pSpell ? NOERROR : E_FAIL;
}



HRESULT CBody::OnPreFontChange()
{
    return S_OK;
}

HRESULT CBody::OnPostFontChange()
{
    HFONT   hFont;

    RecalcPreivewHeight(NULL);
    Resize();

    // update the tabfont
    if (m_hwndTab && 
        m_pFontCache &&
        m_pFontCache->GetFont(FNT_SYS_ICON, NULL, &hFont)==S_OK)
        SendMessage(m_hwndTab, WM_SETFONT, (WPARAM)hFont, 0);

    return S_OK;
}

extern BOOL                g_fCanEditBiDi;
HRESULT CBody::HrFormatParagraph()
{
    OLECMD  rgCmds[]= { {IDM_JUSTIFYLEFT, 0},    // careful about ordering!!
                        {IDM_JUSTIFYRIGHT, 0},
                        {IDM_JUSTIFYCENTER, 0},
                        {IDM_JUSTIFYFULL, 0},
                        {IDM_ORDERLIST, 0},
                        {IDM_UNORDERLIST, 0},
                        {IDM_BLOCKDIRLTR, 0},
                        {IDM_BLOCKDIRRTL, 0}};

    int     rgidm[] = { idmFmtLeft,              // careful about ordering!!
                        idmFmtRight,
                        idmFmtCenter,
                        idmFmtJustify,
                        idmFmtNumbers,
                        idmFmtBullets,
                        idmFmtBlockDirLTR,
                        idmFmtBlockDirRTL};
    PARAPROP ParaProp;
    int i;
    if(FAILED(m_pCmdTarget->QueryStatus(&CMDSETID_Forms3, sizeof(rgCmds)/sizeof(OLECMD), rgCmds, NULL)))
        return E_FAIL;
    memset(&ParaProp, 0, sizeof(PARAPROP));

    for(i = 0; i < 4; i++)
        if(rgCmds[i].cmdf&OLECMDF_LATCHED)
            ParaProp.group[0].iID=rgidm[i];

    ParaProp.group[1].iID = idmFmtBulletsNone;
   
    for(i = 4; i < 6; i++)
        if(rgCmds[i].cmdf&OLECMDF_LATCHED)
            ParaProp.group[1].iID=rgidm[i];

    for(i = 6; i < 8; i++)
        if(rgCmds[i].cmdf&OLECMDF_LATCHED)
            ParaProp.group[2].iID=rgidm[i];

    if(DialogBoxParam(g_hLocRes, MAKEINTRESOURCE(iddFormatPara), m_hwnd, FmtParaDlgProc, (LPARAM)&ParaProp)==IDOK)
    {
        // Dir attribute implies direction.
        // lets change it first
        for(i = g_fCanEditBiDi? 2 : 1; i > -1; i--)
            if(ParaProp.group[i].bChanged)
            {
                OnWMCommand(m_hwnd, ParaProp.group[i].iID, 0);
            }
        
    }
            
  return S_OK;     
}

//+---------------------------------------------------------------
//
//  Member:     SearchForCIDUrls
//
//  Synopsis:   added to support MSPHONE. They send documents with
//              multipart/related CID:foo.wav files, the URLs are renderd
//              using an Active-Movive control embedded in the HTML. 
//              Trident never fires pluggable protocol requests for the 
//              urls and so we don't flag the attachments as rendered. Here we 
//              walk the document and try and find any CID's that are referenced
//              in the HTML. APP requests get fired when the page goes oncomplete and 
//              the activex controls are activated.
//---------------------------------------------------------------
HRESULT CBody::SearchForCIDUrls()
{
    HBODY                   hBody;
    IMimeEditTagCollection *pCollect;
    ULONG                   cFetched;
    IMimeEditTag           *pTag;
    BSTR                    bstrSrc;
    LPSTR                   pszUrlA,
                            pszBodyA;

    // nothing todo if there is no multipart/related section
    if (m_pMsg == NULL ||  
        MimeOleGetRelatedSection(m_pMsg, FALSE, &hBody, NULL)!=S_OK)
        return S_OK;

    // active-movie controls (for MSPHONE)
    if (CreateActiveMovieCollection(m_pDoc, &pCollect)==S_OK)
    {
        pCollect->Reset();

        while (pCollect->Next(1, &pTag, &cFetched)==S_OK && cFetched==1)
        {
            if (pTag->GetSrc(&bstrSrc)==S_OK)
            {
                pszUrlA = PszToANSI(CP_ACP, bstrSrc);
                if (pszUrlA)
                {
                    // if it's an MHTML: url then we have to fixup to get the cid:
                    // as ResolveURL won't recognize it
                    if (StrCmpNIA(pszUrlA, "mhtml:", 6)==0)
                    {
                        if (!FAILED(MimeOleParseMhtmlUrl(pszUrlA, NULL, &pszBodyA)))
                        {
                            // pszBody pszUrlA is guarnteed to be smaller 
                            StrCpyN(pszUrlA, pszBodyA, lstrlen(pszUrlA)+1);
                            SafeMimeOleFree(pszBodyA);
                        }
                    }
                    m_pMsg->ResolveURL(NULL, NULL, pszUrlA, URL_RESOLVE_RENDERED, NULL);
                    MemFree(pszUrlA);
                }
                SysFreeString(bstrSrc);
            }
            pTag->Release();
        }
        pCollect->Release();
    }
    return S_OK;
}

HRESULT CBody::_ReloadWithHtmlSrc(IStream *pstm)
{
    IMimeMessage    *pMsg;

    // if we're currently in HTML view, save the changes and reload trident
    if (m_pMsg && pstm)
    {
        pMsg = m_pMsg;
        pMsg->AddRef();
        pMsg->SetTextBody(TXT_HTML, IET_INETCSET, NULL, pstm, NULL);
        m_fReloadingSrc = TRUE;
        Load(pMsg);
        m_fLoading = FALSE;
        pMsg->Release();
    }
    return S_OK;
}


HRESULT CBody::_EnsureSrcView()
{
    HRESULT hr=S_OK;

    if (!m_pSrcView)
    {
        m_pSrcView = new CMsgSource();
        if (!m_pSrcView)
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }

        hr = m_pSrcView->Init(m_hwnd, idcSrcEdit, (IOleCommandTarget *)this);
        if (FAILED(hr))
            goto error;
    }
    
error:
    return hr;
}



/*
 * Function: _OnSaveImage
 * 
 * Purpose:
 *      if we're doing a SaveAs on an image, trident will not show the correct options in the save-as dialog
 *	    unless the image is in the cache. For auto-inlined images, we changed the behaviour for OE5 to show
 *      them thro' the pluggable protocol. This is a hack to preload the cache with the pluggable protocol to
 *      the image. Note that we also need to delete the cache entry as the full URL is not persitable across sessions. 
 *      ie: given the mhtml://mid:xxxxx!foobar.gif the mid: generated number is reused across OE sessions.
 *
 */

HRESULT CBody::_OnSaveImage()
{
	IHTMLImgElement	*pImg;
	BSTR			bstr=NULL;
    LPSTR           pszUrlA=NULL;
    LPSTREAM        pstm=NULL;
    HRESULT         hrCached=E_FAIL;

    // try and get the image URL (m_pDispContext points to the object the context menu is acting on)
	if (m_pDispContext &&
		m_pDispContext->QueryInterface(IID_IHTMLImgElement, (LPVOID *)&pImg)==S_OK)
	{
		pImg->get_src(&bstr);
		if (bstr)
        {
            pszUrlA = PszToANSI(CP_ACP, bstr);
            SysFreeString(bstr);
        }
        pImg->Release();
	}
	
    // if this URL is in the mutlipart/related secion
    if (!FAILED(HrFindUrlInMsg(m_pMsg, pszUrlA, 0, &pstm)))
    {
        DeleteUrlCacheEntryA(pszUrlA);
        hrCached = CreateCacheFileFromStream(pszUrlA, pstm);
        pstm->Release();
    }
    
	
	Assert (m_pCmdTarget);
    m_pCmdTarget->Exec(&CMDSETID_Forms3, IDM_SAVEPICTURE, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
    
    // if we successfully cached this URL, be sure to remove it once the save is complete.
    if (SUCCEEDED(hrCached))
        DeleteUrlCacheEntryA(pszUrlA);

    MemFree(pszUrlA);
    return S_OK;
}


CVerHost::CVerHost()
{
    m_cRef=1;
}


CVerHost::~CVerHost()
{
}


HRESULT CVerHost::QueryInterface(REFIID riid, LPVOID FAR *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IVersionHost))
        *lplpObj = (IVersionHost *) this;
    else
        return E_NOINTERFACE;
        
    AddRef();
    return NOERROR;
}

ULONG CVerHost::AddRef()
{
    return ++m_cRef;
}


ULONG CVerHost::Release()
{
    if (--m_cRef==0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}

HRESULT CVerHost::QueryUseLocalVersionVector(BOOL *fUseLocal)
{
    *fUseLocal = TRUE;
    return S_OK;
}


HRESULT CVerHost::QueryVersionVector(IVersionVector *pVersion)
{

    if (pVersion == NULL)
        return E_INVALIDARG;

   return pVersion->SetVersion(L"VML", NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\dochost.cpp ===
/*
 *    d o c h o s t . c p p
 *    
 *    Purpose:
 *        basic implementation of a docobject host. Used by the body class to
 *        host Trident and/or MSHTML
 *
 *  History
 *      August '96: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include <pch.hxx>
#include "dllmain.h"
#include "strconst.h"
#include "msoert.h"
#include "dochost.h"
#include "oleutil.h"

ASSERTDATA

/*
 *  m a c r o s
 */

/*
 *  c o n s t a n t s
 */

/*
 *  t y p e d e f s
 */

/*
 *  g l o b a l s 
 */

/*
 *  f u n c t i o n   p r o t y p e s
 */

/*
 *  f u n c t i o n s
 */




//+---------------------------------------------------------------
//
//  Member:     CDocHost
//
//  Synopsis:   
//
//---------------------------------------------------------------
CDocHost::CDocHost()
{
/*
    Not initialised
    Member:                 Initialised In:
    --------------------+---------------------------
*/
    m_cRef=1;
    m_hwnd=0;
    m_pDocView=0;
    m_lpOleObj=0;
    m_pCmdTarget=0;
    m_hwndDocObj=NULL;
    m_fUIActive=FALSE;
    m_fFocus=FALSE;
    m_fDownloading=FALSE;
    m_fCycleFocus=FALSE;
    m_pInPlaceActiveObj = NULL;
    m_dwFrameWidth = 0;
    m_dwFrameHeight = 0;
}

//+---------------------------------------------------------------
//
//  Member:     
//
//  Synopsis:   
//
//---------------------------------------------------------------
CDocHost::~CDocHost()
{
    // These should all get feed up when we get a WM_DESTROY and close the docobj
    Assert(m_lpOleObj==NULL);
    Assert(m_pDocView==NULL);
    Assert(m_pInPlaceActiveObj==NULL);
    Assert(m_pCmdTarget==NULL);
}

//+---------------------------------------------------------------
//
//  Member:     AddRef
//
//  Synopsis:   
//
//---------------------------------------------------------------
ULONG CDocHost::AddRef()
{
    TraceCall("CDocHost::AddRef");

    //TraceInfo(_MSG("CDocHost::AddRef: cRef==%d", m_cRef+1));
    return ++m_cRef;
}

//+---------------------------------------------------------------
//
//  Member:     Release
//
//  Synopsis:   
//
//---------------------------------------------------------------
ULONG CDocHost::Release()
{
    TraceCall("CDocHost::Release");
    
    //TraceInfo(_MSG("CDocHost::Release: cRef==%d", m_cRef-1));    
    if (--m_cRef==0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}


//+---------------------------------------------------------------
//
//  Member:     QueryInterface
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::QueryInterface(REFIID riid, LPVOID *lplpObj)
{
    TraceCall("CDocHost::QueryInterface");

    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;   // set to NULL, in case we fail.

    //DebugPrintInterface(riid, "CDocHost");

    if (IsEqualIID(riid, IID_IOleInPlaceUIWindow))
        *lplpObj = (LPVOID)(IOleInPlaceUIWindow *)this;

    else if (IsEqualIID(riid, IID_IOleInPlaceSite))
        *lplpObj = (LPVOID)(LPOLEINPLACESITE)this;

    else if (IsEqualIID(riid, IID_IOleClientSite))
        *lplpObj = (LPVOID)(LPOLECLIENTSITE)this;

    else if (IsEqualIID(riid, IID_IOleControlSite))
        *lplpObj = (LPVOID)(IOleControlSite *)this;

    else if (IsEqualIID(riid, IID_IAdviseSink))
        *lplpObj = (LPVOID)(LPADVISESINK)this;

    else if (IsEqualIID(riid, IID_IOleDocumentSite))
        *lplpObj = (LPVOID)(LPOLEDOCUMENTSITE)this;

    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *lplpObj = (LPVOID)(LPOLECOMMANDTARGET)this;

    else if (IsEqualIID(riid, IID_IServiceProvider))
        *lplpObj = (LPVOID)(LPSERVICEPROVIDER)this;

    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}



//+---------------------------------------------------------------
//
//  Member:     ExtWndProc
//
//  Synopsis:   
//
//---------------------------------------------------------------
LRESULT CALLBACK CDocHost::ExtWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LPDOCHOST pDocHost;

    if(msg==WM_CREATE)
        {
        pDocHost=(CDocHost *)((LPCREATESTRUCT)lParam)->lpCreateParams;
        if(!pDocHost)
            return -1;

        if(FAILED(pDocHost->OnCreate(hwnd)))
            return -1;
        }
    
    pDocHost = (LPDOCHOST)GetWndThisPtr(hwnd);
    if(pDocHost)
        return pDocHost->WndProc(hwnd, msg, wParam, lParam);
    else
        return DefWindowProc(hwnd, msg, wParam, lParam);
}

//+---------------------------------------------------------------
//
//  Member:     WndProc
//
//  Synopsis:   
//
//---------------------------------------------------------------
LRESULT CDocHost::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
        {

        case WM_SETFOCUS:
            if(m_pDocView)
                m_pDocView->UIActivate(TRUE);
            break;

        case WM_SIZE:
            WMSize(LOWORD(lParam), HIWORD(lParam));
            return 0;

        case WM_CLOSE:
            return 0;   // prevent alt-f4's

        case WM_DESTROY:
            OnDestroy();
            break;

        case WM_NCDESTROY:
            OnNCDestroy();
            break;

        case WM_WININICHANGE:
        case WM_DISPLAYCHANGE:
        case WM_SYSCOLORCHANGE:
        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
            if (m_hwndDocObj)
                return SendMessage(m_hwndDocObj, msg, wParam, lParam);
            break;
            
        case WM_USER + 1:
            // Hook for testing automation
            // copy the contents of trident onto the clipboard.
            return CmdSelectAllCopy(m_pCmdTarget);
        }
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

//+---------------------------------------------------------------
//
//  Member:     OnNCDestroy
//
//  Synopsis:   
//

//+---------------------------------------------------------------
//
//  Member:     OnNCDestroy
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::OnNCDestroy()
{
    TraceCall("CDocHost::OnNCDestroy");
    SetWindowLongPtr(m_hwnd, GWLP_USERDATA, NULL);
    m_hwnd = NULL;
    Release();
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     OnDestroy
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::OnDestroy()
{
    TraceCall("CDocHost::OnDestroy");

    return CloseDocObj();
}


//+---------------------------------------------------------------
//
//  Member:     OnCreate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::OnCreate(HWND hwnd)
{
    TraceCall("CDocHost::OnCreate");

    m_hwnd = hwnd;
    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)this);
    AddRef();

    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     CreateDocObj
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::CreateDocObj(LPCLSID pCLSID)
{
    HRESULT             hr=NOERROR;

    TraceCall("CDocHost::CreateDocObj");

    if(!pCLSID)
        return E_INVALIDARG;

    Assert(!m_lpOleObj);
    Assert(!m_pDocView);
    Assert(!m_pCmdTarget);

    hr = CoCreateInstance(*pCLSID, NULL, CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER,
                                        IID_IOleObject, (LPVOID *)&m_lpOleObj);
    if (FAILED(hr))
        {
        TraceResult(hr);
        goto error;
        }

    hr = m_lpOleObj->SetClientSite((LPOLECLIENTSITE)this);
    if (FAILED(hr))
        {
        TraceResult(hr);
        goto error;
        }

    hr = m_lpOleObj->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&m_pCmdTarget);
    if (FAILED(hr))
        {
        TraceResult(hr);
        goto error;
        }

    hr = HrInitNew(m_lpOleObj);
    if (FAILED(hr))
        {
        TraceResult(hr);
        goto error;
        }

error:
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     Show
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::Show()
{
    RECT                rc;
    HRESULT             hr;

    TraceCall("CDocHost::Show");

    GetClientRect(m_hwnd, &rc);
    GetDocObjSize(&rc);
  
    hr=m_lpOleObj->DoVerb(OLEIVERB_SHOW, NULL, (LPOLECLIENTSITE)this, 0, m_hwnd, &rc);
    if(FAILED(hr))
        goto error;
error:
    return hr;
}



//+---------------------------------------------------------------
//
//  Member:     CloseDocObj
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::CloseDocObj()
{
    LPOLEINPLACEOBJECT  pInPlaceObj=0;

    TraceCall("CDocHost::CloseDocObj");

    SafeRelease(m_pCmdTarget);

    if(m_pDocView)
        {
        m_pDocView->UIActivate(FALSE);
        m_pDocView->CloseView(0);
        m_pDocView->SetInPlaceSite(NULL);
        m_pDocView->Release();
        m_pDocView=NULL;
        }

    if (m_lpOleObj)
        {
        // deactivate the docobj
        if (!FAILED(m_lpOleObj->QueryInterface(IID_IOleInPlaceObject, (LPVOID*)&pInPlaceObj)))
            {
            pInPlaceObj->InPlaceDeactivate();
            pInPlaceObj->Release();
            }
        
        // close the ole object, but blow off changes as we have either extracted 
        // them ourselves or don't care.
        m_lpOleObj->Close(OLECLOSE_NOSAVE);
#ifdef DEBUG
        ULONG   uRef;
        uRef=
#endif
        m_lpOleObj->Release();
        m_lpOleObj=NULL;
        AssertSz(uRef==0, "We leaked a docobject!");
        }

    m_fDownloading=FALSE;
    m_fFocus=FALSE;
    m_fUIActive=FALSE;
    return NOERROR;
}


//+---------------------------------------------------------------
//
//  Member:     Init
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::Init(HWND hwndParent, BOOL fBorder, LPRECT prc)
{
    HRESULT     hr=S_OK;
    HWND        hwnd;
    WNDCLASSW   wc;

    TraceCall("CDocHost::Init");

    if(!IsWindow(hwndParent))
        return E_INVALIDARG;

    if (!GetClassInfoWrapW(g_hLocRes, c_wszDocHostWndClass, &wc))
        {
        ZeroMemory(&wc, sizeof(WNDCLASS));
        wc.lpfnWndProc   = CDocHost::ExtWndProc;
        wc.hInstance     = g_hLocRes;
        wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wc.lpszClassName = c_wszDocHostWndClass;
        wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
        wc.style = CS_DBLCLKS;

        if(!RegisterClassWrapW(&wc))
            return E_OUTOFMEMORY;
        }

    hwnd=CreateWindowExWrapW(WS_EX_NOPARENTNOTIFY|(fBorder?WS_EX_CLIENTEDGE:0),
                        c_wszDocHostWndClass, 
                        NULL,
                        WS_CLIPCHILDREN|WS_CLIPSIBLINGS|WS_CHILD|WS_TABSTOP|WS_VISIBLE,
                        prc->left, 
                        prc->right,
                        prc->right-prc->left, 
                        prc->bottom-prc->top, 
                        hwndParent, 
                        NULL, 
                        g_hLocRes, 
                        (LPVOID)this);
    if(!hwnd)
        {
        hr=E_OUTOFMEMORY;
        goto error;
        }

    SetWindowPos(m_hwnd, NULL, prc->left, prc->top, prc->right-prc->left, prc->bottom-prc->top, SWP_NOZORDER);

error:
    return hr;
}


// *** IOleWindow ***

//+---------------------------------------------------------------
//
//  Member:     GetWindow
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::GetWindow(HWND *phwnd)
{
    TraceCall("CDocHost::GetWindow");
    *phwnd=m_hwnd;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     ContextSensitiveHelp
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::ContextSensitiveHelp(BOOL fEnterMode)
{
    TraceCall("CDocHost::ContextSensitiveHelp");
    return E_NOTIMPL;
}

// *** IOleInPlaceUIWindow methods ***
//+---------------------------------------------------------------
//
//  Member:     GetBorder
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::GetBorder(LPRECT lprectBorder)
{
    TraceCall("CDocHost::GetBorder");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     RequestBorderSpace
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::RequestBorderSpace(LPCBORDERWIDTHS pborderwidths)
{
    TraceCall("CDocHost::RequestBorderSpace");
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SetBorderSpace
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::SetBorderSpace(LPCBORDERWIDTHS lpborderwidths)
{
    TraceCall("CDocHost::IOleInPlaceUIWindow::SetBorderSpace");
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     SetActiveObject
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::SetActiveObject(IOleInPlaceActiveObject * pActiveObject, LPCOLESTR lpszObjName)
{
    TraceCall("CDocHost::IOleInPlaceUIWindow::SetActiveObject");

    ReplaceInterface(m_pInPlaceActiveObj, pActiveObject);
    return S_OK;
}

    // *** IOleInPlaceFrame methods ***

//+---------------------------------------------------------------
//
//  Member:     CDocHost::InsertMenus
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::InsertMenus(HMENU, LPOLEMENUGROUPWIDTHS)
{
    TraceCall("CDocHost::InsertMenus");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     CDocHost::SetMenu
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::SetMenu(HMENU, HOLEMENU, HWND)
{
    TraceCall("CDocHost::SetMenu");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     CDocHost::RemoveMenus
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::RemoveMenus(HMENU)
{
    TraceCall("CDocHost::RemoveMenus");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     CDocHost::SetStatusText
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::SetStatusText(LPCOLESTR pszW)
{
    TraceCall("CDocHost::SetStatusText");
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     CDocHost::EnableModeless
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::EnableModeless(BOOL fEnable)
{
    TraceCall("CDocHost::EnableModeless");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     CDocHost::TranslateAccelerator
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::TranslateAccelerator(LPMSG, WORD)
{
    TraceCall("CDocHost::TranslateAccelerator");
    return E_NOTIMPL;
}




// **** IOleInPlaceSite methods ****

//+---------------------------------------------------------------
//
//  Member:     CanInPlaceActivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::CanInPlaceActivate()
{
    TraceCall("CDocHost::IOleInPlaceSite::CanInPlaceActivate");
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     OnInPlaceActivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::OnInPlaceActivate()
{
    LPOLEINPLACEACTIVEOBJECT    pInPlaceActive;

    TraceCall("CDocHost::OnInPlaceActivate");

    Assert(m_lpOleObj);

    if (m_lpOleObj->QueryInterface(IID_IOleInPlaceActiveObject, (LPVOID *)&pInPlaceActive)==S_OK)
        {
        SideAssert((pInPlaceActive->GetWindow(&m_hwndDocObj)==NOERROR)&& IsWindow(m_hwndDocObj));
        pInPlaceActive->Release();
        }
    
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     OnUIActivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::OnUIActivate()
{
    TraceCall("CDocHost::OnUIActivate");
    m_fUIActive=TRUE;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     GetWindowContext
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::GetWindowContext( IOleInPlaceFrame    **ppFrame,
                                    IOleInPlaceUIWindow **ppDoc,
                                    LPRECT              lprcPosRect, 
                                    LPRECT              lprcClipRect,
                                    LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    TraceCall("CDocHost::IOleInPlaceSite::GetWindowContext");

    *ppFrame = (LPOLEINPLACEFRAME)this;
    AddRef();

    *ppDoc = NULL;

    GetClientRect(m_hwnd, lprcPosRect);
    GetDocObjSize(lprcPosRect);
    *lprcClipRect = *lprcPosRect;

    lpFrameInfo->fMDIApp = FALSE;
    lpFrameInfo->hwndFrame = m_hwnd;
    lpFrameInfo->haccel = NULL;
    lpFrameInfo->cAccelEntries = 0;
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     Scroll
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::Scroll(SIZE scrollExtent)
{
    // the docobject consumes the entireview, so scroll requests
    // are meaningless. Return NOERROR to indicate that they're scolled
    // into view.
    TraceCall("CDocHost::IOleInPlaceSite::Scroll");
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     OnUIDeactivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::OnUIDeactivate(BOOL fUndoable)
{
    TraceCall("CDocHost::OnUIDeactivate");
    m_fUIActive=FALSE;
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     OnInPlaceDeactivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::OnInPlaceDeactivate()
{
    TraceCall("CDocHost::OnInPlaceDeactivate");
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     DiscardUndoState
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::DiscardUndoState()
{
    TraceCall("CDocHost::IOleInPlaceSite::DiscardUndoState");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     DeactivateAndUndo
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::DeactivateAndUndo()
{
    TraceCall("CDocHost::IOleInPlaceSite::DeactivateAndUndo");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     OnPosRectChange
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::OnPosRectChange(LPCRECT lprcPosRect)
{
    TraceCall("CDocHost::IOleInPlaceSite::OnPosRectChange");
    return E_NOTIMPL;
}


// IOleClientSite methods.

//+---------------------------------------------------------------
//
//  Member:     SaveObject
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::SaveObject()
{
    TraceCall("CDocHost::IOleClientSite::SaveObject");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     GetMoniker
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER *ppmnk)
{
    TraceCall("CDocHost::IOleClientSite::GetMoniker");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     GetContainer
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::GetContainer(LPOLECONTAINER *ppCont)
{
    TraceCall("CDocHost::IOleClientSite::GetContainer");
    if(ppCont)
        *ppCont=NULL;
    return E_NOINTERFACE;
}


//+---------------------------------------------------------------
//
//  Member:     ShowObject
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::ShowObject()
{
    // always shown. 
    // $TODO: do we need to restore the browser here if it is
    // minimised?
    TraceCall("CDocHost::IOleClientSite::ShowObject");
    return NOERROR;
}

//+---------------------------------------------------------------
//
//  Member:     OnShowWindow
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::OnShowWindow(BOOL fShow)
{
    TraceCall("CDocHost::IOleClientSite::OnShowWindow");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     RequestNewObjectLayout
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::RequestNewObjectLayout()
{
    TraceCall("CDocHost::IOleClientSite::RequestNewObjectLayout");
    return E_NOTIMPL;
}

// IOleDocumentSite

//+---------------------------------------------------------------
//
//  Member:     ActivateMe
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::ActivateMe(LPOLEDOCUMENTVIEW pViewToActivate)
{
    TraceCall("CDocHost::IOleDocumentSite::ActivateMe");
    return CreateDocView();
}


//+---------------------------------------------------------------
//
//  Member:     CreateDocView
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::CreateDocView()
{
    HRESULT         hr;
    LPOLEDOCUMENT   pOleDoc=NULL;

    TraceCall("CDocHost::CreateDocView");
    AssertSz(!m_pDocView, "why is this still set??");
    AssertSz(m_lpOleObj, "uh? no docobject at this point?");

    hr=OleRun(m_lpOleObj);
    if(FAILED(hr))
        goto error;
    
    hr=m_lpOleObj->QueryInterface(IID_IOleDocument, (LPVOID*)&pOleDoc);
    if(FAILED(hr))
        goto error;

    hr=pOleDoc->CreateView(this, NULL,0,&m_pDocView);
    if(FAILED(hr))
        goto error;

    hr=m_pDocView->SetInPlaceSite(this);
    if(FAILED(hr))
        goto error;

    hr=m_pDocView->Show(TRUE);
    if(FAILED(hr))
        goto error;

error:
    ReleaseObj(pOleDoc);
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     QueryStatus
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pCmdText)
{
    ULONG ul;

    TraceCall("CDocHost::CDocHost::QueryStatus");

    if (!rgCmds)
        return E_INVALIDARG;

    if (pguidCmdGroup == NULL)
        {
        TraceInfo("IOleCmdTarget::QueryStatus - std group");
        DebugPrintCmdIdBlock(cCmds, rgCmds);

        for (ul=0;ul<cCmds; ul++)
            {
            switch (rgCmds[ul].cmdID)
                {
                case OLECMDID_OPEN:
                case OLECMDID_SAVE:
                case OLECMDID_PRINT:
                    rgCmds[ul].cmdf = MSOCMDF_ENABLED;
                    break;

                default:
                    rgCmds[ul].cmdf = 0;
                    break;
                }
            }

        /* for now we deal only with status text*/
        if (pCmdText)
            {
            if (!(pCmdText->cmdtextf & OLECMDTEXTF_STATUS))
                {
                pCmdText->cmdtextf = OLECMDTEXTF_NONE;// is this needed?
                pCmdText->cwActual = 0;
                return NOERROR;
                }
            }
        return NOERROR;
        }

    TraceInfo("IOleCmdTarget::QueryStatus - unknown group");
    return OLECMDERR_E_UNKNOWNGROUP;
}

//+---------------------------------------------------------------
//
//  Member:     Exec
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG *pvaIn,    VARIANTARG *pvaOut)
{
    TraceCall("CDocHost::Exec");

    if (pguidCmdGroup == NULL)
        {
        switch(nCmdID)
            {
             case OLECMDID_SETDOWNLOADSTATE:
                if(pvaIn->vt==VT_I4)
                    {
                    m_fDownloading=pvaIn->lVal;
                    return S_OK;
                    }
                break;

            case OLECMDID_UPDATECOMMANDS:
                OnUpdateCommands();
                break;

            case OLECMDID_SETPROGRESSPOS:
                // when done downloading trident now hits us with a 
                // setprogresspos == -1 to indicate we should remove the "Done"
                if (pvaIn->lVal == -1)
                    SetStatusText(NULL);
                return S_OK;

            case OLECMDID_SETPROGRESSTEXT:
                if(pvaIn->vt == (VT_BSTR))
                    SetStatusText((LPCOLESTR)pvaIn->bstrVal);
                return S_OK;

            default:
                return OLECMDERR_E_NOTSUPPORTED;
            }
        }
    return OLECMDERR_E_UNKNOWNGROUP;
}

//+---------------------------------------------------------------
//
//  Member:     WMSize
//
//  Synopsis:   
//
//---------------------------------------------------------------
void CDocHost::WMSize(int cxBody, int cyBody)
{
    RECT rc={0};

    TraceCall("CDocHost::WMSize");

    if(m_pDocView)
        {
        rc.bottom=cyBody;
        rc.right=cxBody;

        // give the subclass a chance to override the size of the
        // docobj
        GetDocObjSize(&rc);
#ifndef WIN16  //Trident RECTL
        m_pDocView->SetRect(&rc);
#else
        RECTL  rc2 = { rc.left, rc.top, rc.right, rc.bottom };
        m_pDocView->SetRect((LPRECT)&rc2);
#endif
        }

} 



//+---------------------------------------------------------------
//
//  Member:     QueryService
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject)
{
    TraceCall("CDocHost::QueryService");

    //DebugPrintInterface((REFIID)riid, "CDocHost::QueryService");
    return E_UNEXPECTED;
}


// *** IOleControlSite *** 

//+---------------------------------------------------------------
//
//  Member:     OnControlInfoChanged
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::OnControlInfoChanged()
{
    TraceCall("CDocHost::OnControlInfoChanged");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     LockInPlaceActive
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::LockInPlaceActive(BOOL fLock)
{
    TraceCall("CDocHost::LockInPlaceActive");
    return E_NOTIMPL;
}


//+---------------------------------------------------------------
//
//  Member:     GetExtendedControl
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::GetExtendedControl(LPDISPATCH *ppDisp)
{
    TraceCall("CDocHost::GetExtendedControl");

    if (ppDisp)
        *ppDisp=NULL;

    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     TransformCoords
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::TransformCoords(POINTL *pPtlHimetric, POINTF *pPtfContainer,DWORD dwFlags)
{
    TraceCall("CDocHost::TransformCoords");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     TranslateAccelerator
//
// Synopsis:   
//
// this is a little trippy, so bear with me. When we get a tab, and trident is UIActive we always pass it off to them
// if it tabs off the end of its internal tab order (a list of urls for instance) then we get hit with a VK_TAB in our
// IOleControlSite::TranslateAccel. If so then we set m_fCycleFocus to TRUE and return S_OK to indicate we took the tab
// tridents IOIPAO::TranslateAccel returns S_OK to indicate it snagged the TAB, we then detect if we set cyclefocus to true
// there and if so, we return S_FALSE from CBody::HrTranslateAccel to indicate to the browser that we didn't take it and it
// move the focus on
//
//---------------------------------------------------------------
HRESULT CDocHost::TranslateAccelerator(LPMSG lpMsg, DWORD grfModifiers)
{
    TraceCall("CDocHost::TranslateAccelerator");
    if (lpMsg->message == WM_KEYDOWN && lpMsg->wParam == VK_TAB)
        {
        m_fCycleFocus=TRUE;
        return S_OK;
        }

    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     OnFocus
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::OnFocus(BOOL fGotFocus)
{
    TraceCall("CDocHost::OnFocus");

    m_fFocus = fGotFocus;

    // the docobj has focus now, be sure to send a notification
    // to the parent of the dochost so that in the case of the
    // mailview, it can call OnViewActivate
#if 0
    // BUGBUG needed here??
    NMHDR nmhdr;
    
    nmhdr.hwndFrom = m_hwnd;
    nmhdr.idFrom = GetDlgCtrlID(m_hwnd);
    nmhdr.code = m_fFocus ? NM_SETFOCUS : NM_KILLFOCUS;
    SendMessage(GetParent(m_hwnd), WM_NOTIFY, nmhdr.idFrom, (LPARAM)&nmhdr);
#endif
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     ShowPropertyFrame
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::ShowPropertyFrame(void)
{
    TraceCall("CDocHost::ShowPropertyFrame");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     OnUpdateCommands
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDocHost::OnUpdateCommands()
{
    TraceCall("CDocHost::OnUpdateCommands");
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\doc.cpp ===
/*
 *    d o c  . c p p
 *    
 *    Purpose:
 *
 *  History
 *     
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include <pch.hxx>
#include <resource.h>
#include <strconst.h>
#ifdef PLUSPACK
#include "htmlsp.h"
#endif //PLUSPACK
#include "demand.h"
#include "dllmain.h"
#include "msoert.h"
#include "doc.h"
#include "htiframe.h"       //ITargetFrame2
#include "htiface.h"        //ITargetFramePriv
#include "body.h"
#include "util.h" 
#include "oleutil.h"
#include "triutil.h"

//+---------------------------------------------------------------
//
//  Member:     Constructor
//
//  Synopsis:   
//
//---------------------------------------------------------------
CDoc::CDoc(IUnknown *pUnkOuter) : CPrivateUnknown(pUnkOuter)
{
    m_ulState = OS_PASSIVE;
    m_hwndParent = NULL;
    m_pClientSite = NULL;
    m_pIPSite = NULL;
    m_lpszAppName = NULL;
    m_pInPlaceFrame=NULL;
    m_pInPlaceUIWindow=NULL;
    m_pBodyObj=NULL;
    m_pTypeInfo=NULL;
    DllAddRef();
}

//+---------------------------------------------------------------
//
//  Member:     Destructor
//
//  Synopsis:   
//
//---------------------------------------------------------------
CDoc::~CDoc()
{
    DllRelease();
    SafeMemFree(m_lpszAppName);
    SafeRelease(m_pClientSite);
}

//+---------------------------------------------------------------
//
//  Member:     PrivateQueryInterface
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    TraceCall("CDoc::PrivateQueryInterface");

    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IOleObject))
        *lplpObj = (LPVOID)(IOleObject *)this;
    else if (IsEqualIID(riid, IID_IOleDocument))
        *lplpObj = (LPVOID)(IOleDocument *)this;
    else if (IsEqualIID(riid, IID_IOleDocumentView))
        *lplpObj = (LPVOID)(IOleDocumentView *)this;
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
        *lplpObj = (LPVOID)(IOleCommandTarget *)this;
    else if (IsEqualIID(riid, IID_IServiceProvider))
        *lplpObj = (LPVOID)(IServiceProvider *)this;
    else if (IsEqualIID(riid, IID_IOleInPlaceObject))
        *lplpObj = (LPVOID)(IOleInPlaceObject *)this;
    else if (IsEqualIID(riid, IID_IOleInPlaceActiveObject))
        *lplpObj = (LPVOID)(IOleInPlaceActiveObject *)this;
    else if (IsEqualIID(riid, IID_IPersistStreamInit))
        *lplpObj = (LPVOID)(IPersistStreamInit *)this;
    else if (IsEqualIID(riid, IID_IPersistMoniker))
        *lplpObj = (LPVOID)(IPersistMoniker *)this;
    else if (IsEqualIID(riid, IID_IDispatch))
        *lplpObj = (LPVOID)(IDispatch *)this;
    else if (IsEqualIID(riid, IID_IMimeEdit))
        *lplpObj = (LPVOID)(IMimeEdit *)this;
    else if (IsEqualIID(riid, IID_IQuickActivate))
        *lplpObj = (LPVOID)(IQuickActivate *)this;
#ifdef OFFICE_BINDER
    else if (IsEqualIID(riid, IID_IPersistStorage))
        *lplpObj = (LPVOID)(IPersistStorage *)this;
#endif
    else if (IsEqualIID(riid, IID_IPersistMime))
        *lplpObj = (LPVOID)(IPersistMime *)this;
    else if (IsEqualIID(riid, IID_IPersistFile))
        *lplpObj = (LPVOID)(IPersistFile *)this;
    else
        {
        //DebugPrintInterface(riid, "CDoc::{not supported}=");
        return E_NOINTERFACE;
        }
    AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------
//
//  Member:     GetClassID
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetClassID(CLSID *pClassID)
{
	TraceCall("CDoc::GetClassID");

	*pClassID = CLSID_MimeEdit;
    return NOERROR;
}

// *** IPersistMime ***


//+---------------------------------------------------------------
//
//  Member:     Load
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::Load(IMimeMessage *pMsg)
{
	TraceCall("CDoc::Load");

    return m_pBodyObj ? m_pBodyObj->Load(pMsg) : TraceResult(E_UNEXPECTED);
}

//+---------------------------------------------------------------
//
//  Member:     Save
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::Save(IMimeMessage *pMsg, DWORD dwFlags)
{
    IPersistMime    *pPM;
    HRESULT         hr;

	TraceCall("CDoc::Save");

    if (!m_pBodyObj)
        return TraceResult(E_UNEXPECTED);

    hr = m_pBodyObj->QueryInterface(IID_IPersistMime, (LPVOID *)&pPM);
    if (!FAILED(hr))
        {
        hr = pPM->Save(pMsg, dwFlags);
        pPM->Release();
        }
    return hr;
}

// *** IPersistStreamInit ***

//+---------------------------------------------------------------
//
//  Member:     IsDirty
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::IsDirty()
{
	TraceCall("CDoc::IsDirty");

    return m_pBodyObj?m_pBodyObj->IsDirty():TraceResult(E_UNEXPECTED);
}

//+---------------------------------------------------------------
//
//  Member:     Load
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::Load(LPSTREAM pstm)
{
	TraceCall("CDoc::Load");

    return m_pBodyObj?m_pBodyObj->LoadStream(pstm):TraceResult(E_UNEXPECTED);
}

//+---------------------------------------------------------------
//
//  Member:     Save
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::Save(LPSTREAM pstm, BOOL fClearDirty)
{
	TraceCall("CDoc::Save");
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     GetSizeMax
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetSizeMax(ULARGE_INTEGER * pCbSize)
{
	TraceCall("CDoc::GetSizeMax");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     InitNew
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::InitNew()
{
	TraceCall("CDoc::InitNew");
    if (m_pBodyObj)
        return m_pBodyObj->UnloadAll();

    return S_OK;
}

// *** IOleDocument ***
//+---------------------------------------------------------------
//
//  Member:     CreateView
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::CreateView(IOleInPlaceSite *pIPSite, IStream *pstm, DWORD dwReserved, IOleDocumentView **ppView)
{
    HRESULT         hr;

    TraceCall("CDoc::CreateView");

    if (pIPSite == NULL || ppView == NULL)
        return TraceResult(E_INVALIDARG);

    if (m_pClientSite == NULL)
        return TraceResult(E_FAIL);

    hr = SetInPlaceSite(pIPSite);
    if (FAILED(hr))
        {
        TraceResult(hr);
        goto error;
        }

    hr = PrivateQueryInterface(IID_IOleDocumentView, (void **)ppView);
    if (FAILED(hr))
        {
        TraceResult(hr);
        goto error;
        }

error:
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     GetDocMiscStatus
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetDocMiscStatus(DWORD *pdwStatus)
{
    TraceCall("CDoc::GetDocMiscStatus");
    
    *pdwStatus = DOCMISC_CANTOPENEDIT | DOCMISC_NOFILESUPPORT;
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     EnumViews
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::EnumViews(IEnumOleDocumentViews **ppEnum, IOleDocumentView **ppView)
{
    TraceCall("CDoc::EnumViews");

    HRESULT hr = S_OK;

    if (ppEnum == NULL || ppView == NULL)
        return TraceResult(E_INVALIDARG);
        
    *ppEnum = NULL;

    return PrivateQueryInterface(IID_IOleDocumentView, (void **)ppView);
}


// *** IOleDocumentView ***
//+---------------------------------------------------------------
//
//  Member:     SetInPlaceSite
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::SetInPlaceSite(IOleInPlaceSite *pIPSite)
{
    TraceCall("CDoc::SetInPlaceSite");

    // destroys the docobj and detaches from the current client site
    // replaces the client site pointer read for a ::Show
    DeactivateInPlace();
    ReplaceInterface(m_pIPSite, pIPSite);
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     GetInPlaceSite
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetInPlaceSite(IOleInPlaceSite **ppIPSite)
{
    TraceCall("CDoc::GetInPlaceSite");

    if (!ppIPSite)
        return E_INVALIDARG;

    if (*ppIPSite=m_pIPSite)
        {
        m_pIPSite->AddRef();
        return S_OK;
        }
    else
        return E_FAIL;
}


//+---------------------------------------------------------------
//
//  Member:     GetDocument
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetDocument(IUnknown **ppunk)
{
    TraceCall("CDoc::GetDocument");

    if (ppunk==NULL)
        return E_INVALIDARG;

    *ppunk = (IOleDocument *)this;
    (*ppunk)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     SetRect
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::SetRect(LPRECT prcView)
{
    if (m_pBodyObj)
        m_pBodyObj->SetRect(prcView);
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     GetRect
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetRect(LPRECT prcView)
{
    TraceCall("CDoc::GetRect");

    if (m_pBodyObj)
        m_pBodyObj->GetRect(prcView);
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     SetRectComplex
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::SetRectComplex(LPRECT prcView, LPRECT prcHScroll, LPRECT prcVScroll, LPRECT prcSizeBox)
{
    TraceCall("CDoc::SetRectComplex");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     Show
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::Show(BOOL fShow)
{
    HRESULT hr;

    TraceCall("CDoc::Show");
    
    hr = ActivateInPlace();
    if (FAILED(hr))
        {
        TraceResult(hr);
        goto error;
        }

error:
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     UIActivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::UIActivate(BOOL fUIActivate)
{
    HRESULT     hr=S_OK;

    TraceCall("CDoc::UIActivate");

#ifdef OFFICE_BINDER
    if (fUIActivate)
        {
        hr = ActivateInPlace();
        }
#endif    
    if (m_pBodyObj)
        return m_pBodyObj->UIActivate(fUIActivate);
    
    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     Open
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::Open()
{
    TraceCall("CDoc::Open");
    
    // no single instance View|Frame supported
    return E_NOTIMPL;
}
//+---------------------------------------------------------------
//
//  Member:     CloseView
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::CloseView(DWORD dwReserved)
{
    TraceCall("CDoc::CloseView");
    
    // to close the view, set the Site to NULL
    SetInPlaceSite(NULL);
    return S_OK;
}
//+---------------------------------------------------------------
//
//  Member:     SaveViewState
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::SaveViewState(LPSTREAM pstm)
{
    TraceCall("CDoc::SaveViewState");
    return S_OK;    // we don't keep view state
}
//+---------------------------------------------------------------
//
//  Member:     ApplyViewState
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::ApplyViewState(LPSTREAM pstm)
{
    TraceCall("CDoc::ApplyViewState");
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     Clone
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::Clone(IOleInPlaceSite *pIPSiteNew, IOleDocumentView **ppViewNew)
{
    TraceCall("CDoc::Clone");
    return E_NOTIMPL;
}

// *** IOleObject ***
//+---------------------------------------------------------------
//
//  Member:     SetClientSite
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::SetClientSite(IOleClientSite *pClientSite)
{
    TraceCall("CDoc::SetClientSite");

    if (m_pClientSite && pClientSite)
        {
        // don't allow them to change the client site
        TraceInfo("Host attempt to change client-site fefused");
        return E_INVALIDARG;
        }

    ReplaceInterface(m_pClientSite, pClientSite);
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     GetClientSite
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetClientSite(IOleClientSite **ppClientSite)
{
    TraceCall("CDoc::GetClientSite");

    if (!ppClientSite)
        return E_INVALIDARG;

    if (*ppClientSite=m_pClientSite)
        {
        m_pClientSite->AddRef();
        return S_OK;
        }
    else
        return E_FAIL;
}

//+---------------------------------------------------------------
//
//  Member:     SetHostNames
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::SetHostNames(LPCOLESTR szContainerAppW, LPCOLESTR szContainerObjW)
{
    TraceCall("CDoc::SetHostNames");

    SafeMemFree(m_lpszAppName);
    if (szContainerAppW)
        m_lpszAppName = PszToANSI(CP_ACP, szContainerAppW);

    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     Close
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::Close(DWORD dwSaveOption)
{
    HRESULT hr = S_OK;
    BOOL    fSave;
    int     id;
    TCHAR   szTitle[MAX_PATH];

    TraceCall("CDoc::Close");

    // if our object is dirty then we should save it, depending on the
    // save options
    if (m_pClientSite && 
        m_pBodyObj && 
        m_pBodyObj->IsDirty()==S_OK)
        {
        switch(dwSaveOption)
            {
            case OLECLOSE_SAVEIFDIRTY:
                fSave = TRUE;
                break;

            case OLECLOSE_NOSAVE:
                fSave = FALSE;
                break;

            case OLECLOSE_PROMPTSAVE:
                {
                if(m_ulState != OS_UIACTIVE)
                    {
                    // if we're not UI active, then don't prompt
                    fSave=TRUE;
                    break;
                    }

                GetHostName(szTitle, sizeof(szTitle)/sizeof(TCHAR));
                id = AthMessageBox(m_hwndParent, szTitle, MAKEINTRESOURCE(idsSaveModifiedObject), NULL, MB_YESNOCANCEL);
                if (id == 0)
                    return TraceResult(E_OUTOFMEMORY);
                else if (id == IDCANCEL)
                    return TraceResult(OLE_E_PROMPTSAVECANCELLED);

                fSave=(id == IDYES);
                }
                break;

        default:
            return TraceResult(E_INVALIDARG);
            }
        
        if (fSave)
            hr = m_pClientSite->SaveObject();
        }

    if (hr==S_OK)
        hr = DeactivateInPlace();

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     SetMoniker
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::SetMoniker(DWORD dwWhichMoniker, IMoniker *pmk)
{
    TraceCall("CDoc::SetMoniker");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     GetMoniker
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk)
{
    TraceCall("CDoc::GetMoniker");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     InitFromData
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::InitFromData(IDataObject *pDataObject, BOOL fCreation, DWORD dwReserved)
{
    TraceCall("CDoc::InitFromData");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     GetClipboardData
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetClipboardData(DWORD dwReserved, IDataObject **ppDataObject)
{
    TraceCall("CDoc::GetClipboardData");
    
    if (ppDataObject == NULL)
        return TraceResult(E_INVALIDARG);

    *ppDataObject = NULL;
    return TraceResult(E_NOTIMPL);
}

//+---------------------------------------------------------------
//
//  Member:     DoVerb
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::DoVerb(LONG iVerb, LPMSG lpmsg, IOleClientSite *pActiveSite, LONG lindex, HWND hwndParent, LPCRECT lprcPosRect)
{
    TraceCall("CDoc::DoVerb");
    switch (iVerb)
        {
        case OLEIVERB_SHOW:
        case OLEIVERB_PRIMARY:
            return DoShow(pActiveSite, hwndParent, lprcPosRect);;
        
        case OLEIVERB_INPLACEACTIVATE:
            return Show(TRUE);
        }
  
    return OLEOBJ_S_INVALIDVERB;
}

//+---------------------------------------------------------------
//
//  Member:     EnumVerbs
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::EnumVerbs(IEnumOLEVERB **ppEnumOleVerb)
{
    TraceCall("CDoc::EnumVerbs");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     Update
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::Update()
{
    TraceCall("CDoc::Update");
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     IsUpToDate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::IsUpToDate()
{
    TraceCall("CDoc::IsUpToDate");
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     GetUserClassID
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetUserClassID(CLSID *pCLSID)
{
    TraceCall("CDoc::GetUserClassID");
	
    if (pCLSID==NULL)
        return TraceResult(E_INVALIDARG);

    *pCLSID = CLSID_MimeEdit;
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     GetUserType
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetUserType(DWORD dwFormOfType, LPOLESTR *pszUserType)
{
    TCHAR   szRes[CCHMAX_STRINGRES];
    int     ids;

    TraceCall("CDoc::GetUserType");
   
    if (pszUserType==NULL)
        return TraceResult(E_INVALIDARG);

    *pszUserType = NULL;

    switch (dwFormOfType)
        {
        case USERCLASSTYPE_APPNAME:
            ids = idsUserTypeApp;
            break;

        case USERCLASSTYPE_SHORT:
            ids = idsUserTypeShort;
            break;

        case USERCLASSTYPE_FULL:
            ids = idsUserTypeFull;
            break;

        default:
            return TraceResult(E_INVALIDARG);
        }   

    if (!LoadString(g_hLocRes, ids, szRes, sizeof(szRes)/sizeof(TCHAR)))
        return TraceResult(E_OUTOFMEMORY);

    *pszUserType = PszToUnicode(CP_ACP, szRes);
    return *pszUserType ? S_OK : TraceResult(E_OUTOFMEMORY);
}

//+---------------------------------------------------------------
//
//  Member:     SetExtent
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::SetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    TraceCall("CDoc::SetExtent");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     GetExtent
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    TraceCall("CDoc::GetExtent");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     Advise
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection)
{
    TraceCall("CDoc::Advise");
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     Unadvise
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::Unadvise(DWORD dwConnection)
{
    TraceCall("CDoc::Unadvise");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     EnumAdvise
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::EnumAdvise(IEnumSTATDATA **ppenumAdvise)
{
    TraceCall("CDoc::EnumAdvise");
    return E_NOTIMPL;
}

//+---------------------------------------------------------------
//
//  Member:     GetMiscStatus
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus)
{
    TraceCall("CDoc::GetMiscStatus");
    
    if (pdwStatus==NULL)
        return E_INVALIDARG;    

    *pdwStatus = OLEMISC_INSIDEOUT; // BUGBUG: not sure what to set here
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     SetColorScheme
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::SetColorScheme(LOGPALETTE *pLogpal)
{
    TraceCall("CDoc::SetColorScheme");

    return E_NOTIMPL;
}


// *** IOleInPlaceObject ***

//+---------------------------------------------------------------
//
//  Member:     InPlaceDeactivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::InPlaceDeactivate()
{
    TraceCall("CDoc::InPlaceDeactivate");
    
    return DeactivateInPlace();
}

//+---------------------------------------------------------------
//
//  Member:     UIDeactivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::UIDeactivate()
{
    TraceCall("CDoc::UIDeactivate");

    if (m_pBodyObj)
        m_pBodyObj->UIActivate(FALSE);

    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     SetObjectRects
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::SetObjectRects(LPCRECT lprcPosRect, LPCRECT lprcClipRect)
{
    TraceCall("CDoc::SetObjectRects");
 
    return SetRect((LPRECT)lprcPosRect);
}

//+---------------------------------------------------------------
//
//  Member:     ReactivateAndUndo
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::ReactivateAndUndo()
{
    TraceCall("CDoc::ReactivateAndUndo");
    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     GetWindow
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetWindow(HWND *phwnd)
{
    TraceCall("CDoc::GetWindow");

    if (phwnd==NULL)
        return E_INVALIDARG;

    return m_pBodyObj?m_pBodyObj->GetWindow(phwnd):E_FAIL;
}

//+---------------------------------------------------------------
//
//  Member:     ContextSensitiveHelp
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::ContextSensitiveHelp(BOOL fEnterMode)
{
    TraceCall("CDoc::ContextSensitiveHelp");
    return E_NOTIMPL;
}



//+---------------------------------------------------------------
//
//  Member:     TranslateAccelerator
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::TranslateAccelerator(LPMSG lpmsg)
{
    return m_pBodyObj ? m_pBodyObj->PrivateTranslateAccelerator(lpmsg) : S_FALSE;
}

//+---------------------------------------------------------------
//
//  Member:     OnFrameWindowActivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::OnFrameWindowActivate(BOOL fActivate)
{
    TraceCall("CDoc::OnFrameWindowActivate");
    if (m_pBodyObj)
		m_pBodyObj->OnFrameActivate(fActivate);

	return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     OnDocWindowActivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::OnDocWindowActivate(BOOL fActivate)
{
    TraceCall("CDoc::OnDocWindowActivate");
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     ResizeBorder
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::ResizeBorder(LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fFrameWindow)
{
    TraceCall("CDoc::ResizeBorder");
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     EnableModeless
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::EnableModeless(BOOL fEnable)
{
    TraceCall("CDoc::EnableModeless");
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     QueryStatus
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText)
{
    TraceCall("CDoc::QueryStatus");

    if (m_pBodyObj==NULL)
        return TraceResult(E_UNEXPECTED);

    return m_pBodyObj->PrivateQueryStatus(pguidCmdGroup, cCmds, prgCmds, pCmdText);
}

//+---------------------------------------------------------------
//
//  Member:     Exec
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANT *pvaIn, VARIANT *pvaOut)
{
    HRESULT     hr=E_FAIL;

    TraceCall("CDoc::Exec");

    if (m_pBodyObj==NULL)
        return TraceResult(E_UNEXPECTED);

    return m_pBodyObj->PrivateExec(pguidCmdGroup, nCmdID, nCmdexecopt, pvaIn, pvaOut);
}


//+---------------------------------------------------------------
//
//  Member:     QueryService
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject)
{
    TraceCall("CDoc::QueryService");

    if (m_pBodyObj==NULL)
        return TraceResult(E_UNEXPECTED);

    return m_pBodyObj->PrivateQueryService(guidService, riid, ppvObject);
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::DoShow
//
//  Synopsis:   response to IOleObject::DoVerb for showing object
//
//---------------------------------------------------------------
HRESULT CDoc::DoShow(IOleClientSite *pActiveSite, HWND hwndParent, LPCRECT lprcPosRect)
{
    HRESULT     hr;

    TraceCall("CDoc::DoShow");

    if (m_ulState >= OS_INPLACE)        // if we're already running return S_OK
        return S_OK;
    
    if (!IsWindow(hwndParent))
        return OLEOBJ_S_INVALIDHWND;

    if (pActiveSite == NULL)
        return E_INVALIDARG;

    ReplaceInterface(m_pClientSite, pActiveSite);
    m_hwndParent = hwndParent;

    return ActivateView();
}

//+---------------------------------------------------------------
//
//  Member:     CDoc::ActivateView
//
//  Synopsis:   Activate an IOleDocumentView
//
//---------------------------------------------------------------
HRESULT CDoc::ActivateView()
{
    HRESULT             hr;
    IOleDocumentSite    *pDocSite;

    TraceCall("CDoc::ActivateView");

    Assert(m_ulState < OS_INPLACE);
    Assert(m_pClientSite);

    if (!FAILED(hr = m_pClientSite->QueryInterface(IID_IOleDocumentSite, (void **)&pDocSite)))
        {
        hr = pDocSite->ActivateMe((IOleDocumentView *)this);
        pDocSite->Release();
        }

    return hr;
}


HRESULT CDoc::Load(BOOL fFullyAvailable, IMoniker *pMoniker, IBindCtx *pBindCtx, DWORD grfMode)
{
    return m_pBodyObj->Load(fFullyAvailable, pMoniker, pBindCtx, grfMode);
}

HRESULT CDoc::GetCurMoniker(IMoniker **ppMoniker)
{
    return m_pBodyObj->GetCurMoniker(ppMoniker);
}

HRESULT CDoc::Save(IMoniker *pMoniker, IBindCtx *pBindCtx, BOOL fRemember)
{
    return m_pBodyObj->Save(pMoniker, pBindCtx, fRemember);
}

HRESULT CDoc::SaveCompleted(IMoniker *pMoniker, IBindCtx *pBindCtx)
{
    return m_pBodyObj->SaveCompleted(pMoniker, pBindCtx);
}

//+---------------------------------------------------------------
//
//  Member:     ActivateInPlace
//
//  Synopsis:   In place activates the object using the std. inplace
//              activation protocol to create the inplace window.
//
//---------------------------------------------------------------
HRESULT CDoc::ActivateInPlace()
{
    HRESULT             hr;
    HWND                hwndSite;
    RECT                rcPos,
                        rcClip;
    OLEINPLACEFRAMEINFO rFrameInfo;

    TraceCall("CDoc::ActivateInPlace");

    if (!m_pClientSite)
        return TraceResult(E_UNEXPECTED);

    if (m_ulState >= OS_INPLACE)        // if we're already running return S_OK
        return S_OK;

    // If we don't already have an inplace site, query for one. Note. we don't yet support 
    // negotiation for a windowless site. We may want to add this code.
    if (!m_pIPSite)
        m_pClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_pIPSite);

    if (!m_pIPSite)
        return TraceResult(E_FAIL);

    if (m_pIPSite->CanInPlaceActivate() != S_OK)
        {
        TraceInfo("Container refused In-Place activation!");
        return TraceResult(E_FAIL);        
        }

    Assert(m_pInPlaceFrame==NULL && m_pInPlaceUIWindow==NULL);

    rFrameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
    ZeroMemory(&rcPos, sizeof(RECT));
    ZeroMemory(&rcClip, sizeof(RECT));

    hr = m_pIPSite->GetWindowContext(&m_pInPlaceFrame, &m_pInPlaceUIWindow,  &rcPos, &rcClip, &rFrameInfo);
    if (FAILED(hr))
        {
        TraceResult(hr);
        goto error;
        }

    hr = m_pIPSite->GetWindow(&hwndSite);
    if (FAILED(hr))
        {
        TraceResult(hr);
        goto error;
        }

    hr = AttachWin(hwndSite, &rcPos);
    if (FAILED(hr))
        {
        TraceResult(hr);
        goto error;
        }

    //  Notify our container that we are going in-place active.
    m_ulState = OS_INPLACE;
    m_pIPSite->OnInPlaceActivate();

    if (m_pInPlaceFrame)
        m_pInPlaceFrame->SetActiveObject((IOleInPlaceActiveObject *)this, NULL);

    if (m_pInPlaceUIWindow)
        m_pInPlaceUIWindow->SetActiveObject((IOleInPlaceActiveObject *)this, NULL);
        
error:
    return hr;
}


//+---------------------------------------------------------------
//
//  Member:     AttachWin
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::AttachWin(HWND hwndParent, LPRECT lprcPos)
{
    HRESULT		        hr;
	DWORD               dwFlags=MEBF_OUTERCLIENTEDGE|MEBF_FORMATBARSEP;
    VARIANTARG          va;
    IOleCommandTarget   *pCmdTarget;
    BODYHOSTINFO        rHostInfo;

	TraceCall("CDoc::AttachWin");

    if (!IsWindow(hwndParent) || lprcPos == NULL)
        return TraceResult(E_INVALIDARG);

    // get border flags from host before we create the body, so we can fix the client edges
    if (m_pClientSite &&
        m_pClientSite->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&pCmdTarget)==S_OK)
        {
        if (pCmdTarget->Exec(&CMDSETID_MimeEditHost, MEHOSTCMDID_BORDERFLAGS, 0, NULL, &va)==S_OK && va.vt==VT_I4)
            dwFlags = va.lVal;
        pCmdTarget->Release();
        }

	rHostInfo.pInPlaceSite = m_pIPSite;
    rHostInfo.pInPlaceFrame = m_pInPlaceFrame;
    rHostInfo.pDoc = (IOleInPlaceActiveObject *)this;
    
    hr = CreateBodyObject(hwndParent, dwFlags, lprcPos, &rHostInfo, &m_pBodyObj);
	if (FAILED(hr))
		{
		TraceResult(hr);
		goto error;
		}

error:
	return hr;
}


//+---------------------------------------------------------------
//
//  Member:     DeactivateInPlace
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::DeactivateInPlace()
{
    TraceCall("CDoc::DeactivateInPlace");

    if (m_pBodyObj)
        {
        m_pBodyObj->Close();
        m_pBodyObj->Release();
        m_pBodyObj=NULL;
        }

    //  Notify our container that we're in-place deactivating
    if (m_ulState == OS_INPLACE)
        {
        //  The container may reenter us, so need to remember that
        //    we've done almost all the transition to OS_RUNNING

        m_ulState = OS_RUNNING;

        //  Errors from this notification are ignored (in the function
        //    which calls this one); we don't allow our container to stop
        //    us from in-place deactivating

        if (m_pIPSite)
            m_pIPSite->OnInPlaceDeactivate();

        }

    SafeRelease(m_pIPSite);
    SafeRelease(m_pInPlaceFrame);
    SafeRelease(m_pInPlaceUIWindow);
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     ActivateUI
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::ActivateUI()
{
    HRESULT     hr;

    TraceCall("CDoc::ActivateUI");

    if (!m_pIPSite)
        return TraceResult(E_UNEXPECTED);

    m_ulState = OS_UIACTIVE;

    if (FAILED(hr=m_pIPSite->OnUIActivate()))
        {
        //  If the container fails the OnUIActivate call, then we
        //  give up and stay IPA

        if (m_ulState == OS_UIACTIVE)
            m_ulState = OS_INPLACE;

        }

    return hr;
}

//+---------------------------------------------------------------
//
//  Member:     DeactivateUI
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::DeactivateUI()
{
    TraceCall("CDoc::DectivateInPlace");

    if (!m_pIPSite)
        return TraceResult(E_UNEXPECTED);

    m_ulState = OS_INPLACE;
    m_pIPSite->OnUIDeactivate(FALSE);
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     GetHostName
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetHostName(LPSTR szTitle, ULONG cch)
{
	TraceCall("CDoc::GetHostName");

    *szTitle = 0;

    if (m_lpszAppName)
        {
        StrCpyN(szTitle, m_lpszAppName, cch);
        }
    else
        {
        SideAssert(LoadString(g_hLocRes, idsAppName, szTitle, cch));
        }
    return S_OK;
}


#ifdef OFFICE_BINDER
HRESULT CDoc::InitNew(IStorage *pStg)
{
    return S_OK;
}
HRESULT CDoc::Load(IStorage *pStg)
{
    return S_OK;
}

HRESULT CDoc::Save(IStorage *pStgSave, BOOL fSameAsLoad)
{
    return S_OK;
}

HRESULT CDoc::SaveCompleted(IStorage *pStgNew)
{
    return S_OK;
}

HRESULT CDoc::HandsOffStorage()
{
    return S_OK;
}
#endif

HRESULT CDoc::GetTypeInfoCount(UINT *pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}

HRESULT CDoc::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    HRESULT hr;

    *pptinfo = NULL;
    
    if (itinfo)
        return DISP_E_BADINDEX;

    hr = EnsureTypeLibrary();
    if (FAILED(hr))
        goto error;

    m_pTypeInfo->AddRef();
    *pptinfo = m_pTypeInfo;

error:
    return hr;
}

HRESULT CDoc::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
{
    HRESULT hr;

    hr = EnsureTypeLibrary();
    if (FAILED(hr))
        goto error;

    hr = DispGetIDsOfNames(m_pTypeInfo, rgszNames, cNames, rgdispid);

error:
    return hr;
}

HRESULT CDoc::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
    HRESULT hr;

    hr = EnsureTypeLibrary();
    if (FAILED(hr))
        goto error;

    hr = DispInvoke((IDispatch *)this, m_pTypeInfo, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);    

error:
    return hr;
}

// *** IQuickActivate ***
//+---------------------------------------------------------------
//
//  Member:     QuickActivate
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::QuickActivate(QACONTAINER *pQaContainer, QACONTROL *pQaControl)
{
    TraceCall("CDoc::QuickActivate");

    if (pQaControl == NULL || pQaContainer == NULL)
        return E_INVALIDARG;

    pQaControl->cbSize = sizeof(QACONTROL);
    pQaControl->dwMiscStatus = OLEMISC_INSIDEOUT|OLEMISC_ACTIVATEWHENVISIBLE;
    pQaControl->dwViewStatus = 0;
    pQaControl->dwEventCookie = 0;
    pQaControl->dwPropNotifyCookie = 0;
    pQaControl->dwPointerActivationPolicy = 0;

    if (m_pClientSite || pQaContainer->pClientSite==NULL)
        return E_FAIL;

    m_pClientSite = pQaContainer->pClientSite;
    m_pClientSite ->AddRef();

    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     SetContentExtent
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::SetContentExtent(LPSIZEL pSizel)
{
    TraceCall("CDoc::SetContentExtent");
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     GetContentExtent
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CDoc::GetContentExtent(LPSIZEL pSizel)
{
    TraceCall("CDoc::GetContentExtent");
    return S_OK;
}


HRESULT CDoc::EnsureTypeLibrary()
{
    HRESULT     hr;
    ITypeLib    *pTypeLib;
    
    TraceCall("EnsureTypeLibrary()");

    if (m_pTypeInfo)
        return S_OK;

    hr = GetTypeLibrary(&pTypeLib);
    if (!FAILED(hr))
        {
        hr = pTypeLib->GetTypeInfoOfGuid(IID_IMimeEdit, &m_pTypeInfo);
        pTypeLib->Release();
        }
    return hr;
}

HRESULT CDoc::get_src(BSTR *pbstr)
{
    *pbstr = NULL;
    return E_NOTIMPL;
}

HRESULT CDoc::put_src(BSTR bstr)
{
    IMoniker        *pmk;

    HRESULT         hr;
    IMimeMessage    *pMsg;
    IPersistMoniker    *pPMK;
        
    if (CreateURLMoniker(NULL, bstr, &pmk))
        return E_FAIL;

    hr = CoCreateInstance(CLSID_IMimeMessage, NULL, CLSCTX_INPROC_SERVER, IID_IMimeMessage, (LPVOID *)&pMsg);
    if (!FAILED(hr))
        {
        hr = pMsg->QueryInterface(IID_IPersistMoniker, (LPVOID *)&pPMK);
        if (!FAILED(hr))
            {
            hr=pPMK->Load(TRUE, pmk, NULL, STGM_READWRITE);
            if (!FAILED(hr))
                {
                hr = Load(pMsg);
                }
            pPMK->Release();
            } 
        pMsg->Release();
        }            
    return hr;
}

HRESULT CDoc::put_header(LONG lStyle)
{
    VARIANTARG va;

    va.vt = VT_I4;
    va.lVal = lStyle;
    return m_pBodyObj?m_pBodyObj->PrivateExec(&CMDSETID_MimeEdit, MECMDID_STYLE, OLECMDEXECOPT_DODEFAULT, &va, NULL):E_FAIL;
}
 
HRESULT CDoc::put_editMode(VARIANT_BOOL b)
{
    VARIANTARG va;

    va.vt = VT_BOOL;
    va.boolVal = b;
    return m_pBodyObj?m_pBodyObj->PrivateExec(&CMDSETID_MimeEdit, MECMDID_EDITMODE, OLECMDEXECOPT_DODEFAULT, &va, NULL):E_FAIL;
}

HRESULT CDoc::get_editMode(VARIANT_BOOL *pbool)
{
    VARIANTARG va;
    
    TraceCall("CDoc::get_editMode");

    if (m_pBodyObj &&
        m_pBodyObj->PrivateExec(&CMDSETID_MimeEdit, MECMDID_EDITMODE, OLECMDEXECOPT_DODEFAULT, NULL, &va)==S_OK)
        {
        Assert(va.vt == VT_BOOL);
        *pbool = va.boolVal;
        return S_OK;
        }
    return TraceResult(E_FAIL);
}


HRESULT CDoc::get_messageSource(BSTR *pbstr)
{
    IMimeMessage    *pMsg;
    IStream         *pstm;
    HRESULT         hr=E_FAIL;

    if (MimeOleCreateMessage(NULL, &pMsg)==S_OK)
        {
        if (!FAILED(Save(pMsg, MECD_HTML|MECD_PLAINTEXT|MECD_ENCODEIMAGES|MECD_ENCODESOUNDS)) &&
            pMsg->Commit(0)==S_OK && 
            pMsg->GetMessageSource(&pstm, 0)==S_OK)
            {
            hr = HrIStreamToBSTR(GetACP(), pstm, pbstr);
            pstm->Release();
            }
        pMsg->Release();
        }
    return hr;
}

HRESULT CDoc::get_text(BSTR *pbstr)
{
    IStream *pstm;

    *pbstr = NULL;
    if (GetBodyStream(m_pBodyObj->GetDoc(), FALSE, &pstm)==S_OK)
        {
        HrIStreamToBSTR(NULL, pstm, pbstr);
        pstm->Release();
        }
    return S_OK;
}

HRESULT CDoc::get_html(BSTR *pbstr)
{
// BUGBUGBUG: hack for HOTMAIL page demo
    IStream     *pstm;
    HCHARSET    hCharset;

    *pbstr = NULL;
    
    MimeOleGetCodePageCharset(1252, CHARSET_BODY, &hCharset);
    m_pBodyObj->SetCharset(hCharset);

    if (GetBodyStream(m_pBodyObj->GetDoc(), TRUE, &pstm)==S_OK)
        {
        HrIStreamToBSTR(NULL, pstm, pbstr);
        pstm->Release();
        }
    return S_OK;
// BUGBUGBUG: hack for HOTMAIL page demo
}

HRESULT CDoc::get_doc(IDispatch **ppDoc)
{
    *ppDoc = 0;
    if (m_pBodyObj)
        (m_pBodyObj->GetDoc())->QueryInterface(IID_IDispatch, (LPVOID *)ppDoc);
    return S_OK;
}

 

HRESULT CDoc::get_header(LONG *plStyle)
{
    VARIANTARG va;
    HRESULT     hr;

    if (!m_pBodyObj)
        return E_FAIL;

    hr = m_pBodyObj->PrivateExec(&CMDSETID_MimeEdit, MECMDID_STYLE, OLECMDEXECOPT_DODEFAULT, NULL, &va);
    *plStyle = va.lVal;
    return hr;
}

HRESULT CDoc::clear()
{
    if (m_pBodyObj)
        m_pBodyObj->UnloadAll();
 
    return S_OK;
}

 


HRESULT CDoc::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    HRESULT         hr;
    IMimeMessage    *pMsg;
    IPersistFile    *pPF;
        
    hr = CoCreateInstance(CLSID_IMimeMessage, NULL, CLSCTX_INPROC_SERVER, IID_IMimeMessage, (LPVOID *)&pMsg);
    if (!FAILED(hr))
        {
        hr = pMsg->QueryInterface(IID_IPersistFile, (LPVOID *)&pPF);
        if (!FAILED(hr))
            {
            hr = pPF->Load(pszFileName, dwMode);
            if (!FAILED(hr))
                {
                hr = Load(pMsg);
                }
            pPF->Release();
            } 
        pMsg->Release();
        }            
    return hr;
}

HRESULT CDoc::Save(LPCOLESTR pszFileName, BOOL fRemember)
{
    return E_NOTIMPL;
}

HRESULT CDoc::SaveCompleted(LPCOLESTR pszFileName)
{
    return S_OK;
}

HRESULT CDoc::GetCurFile(LPOLESTR * ppszFileName)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\bodyutil.cpp ===
/*
 *    b o d y u t i l . c p p
 *    
 *    Purpose:
 *        utility functions for body
 *
 *  History
 *      August '96: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#include <pch.hxx>
#include "dllmain.h"
#include "olealloc.h"
#include "resource.h"
#include "htmlstr.h"
#include "strconst.h"
#include "bodyutil.h"
#include "plainstm.h"
#include "mimeutil.h"
#include "util.h"
#include "demand.h"

ASSERTDATA


/*
 *  t y p e d e f s
 */

enum
{
    HEADER_FROM=0,
    HEADER_NEWSGROUP,
    HEADER_TO,
    HEADER_CC,
    HEADER_SENT,
    HEADER_ATTACH,
    HEADER_SUBJECT,
    HEADER_MAX
};


/*
 *  m a c r o s
 */
#define WSZ_CB(str)         (lstrlenW(str)*sizeof(WCHAR))
#define WSZ_CBNULL(str)     ((lstrlenW(str)+1)*sizeof(WCHAR))

#define WSZ_CCH(str)        lstrlenW(str)
#define WSZ_CCHNULL(str)    (lstrlenW(str)+1)

/*
 *  c o n s t a n t s
 */

static const WCHAR  c_wszHtmlDIV_Close[]            = L"</DIV>\r\n",
                    c_wszTableTag_Close[]           = L"</TABLE>\r\n",
                    c_wszHtml[]                     = L"<HTML>\r\n",
                    c_wszHtmlReplyAnchor[]          = L"<A href=\"mailto:%s\" TITLE=\"%s\">%s</A>\r\n",
                    c_wszHtml_HeaderDIV[]           = L"<DIV>\r\n<B>%s</B> ",
                    c_wszHtml_DIV_BR_DIV[]          = L"<DIV><BR></DIV>\r\n",
                    c_wszHtml_FromDIV[]             = L"<DIV STYLE=\"background:#E4E4E4; font-color:black\">\r\n<B>%s</B> ",
                    
                    c_wszHtml_HeaderDIVFmt_Start[]  = L"<DIV>\r\n<B>",
                    c_wszHtml_HeaderDIVFmt_Middle[] = L"</B> ",
                    c_wszHtml_HeaderDIVFmt_End[]    = L"</DIV>",

                    c_wszHtml_HeaderDIVFmt_Plain_Start[]= L"<DIV>\r\n",
                    c_wszHtml_HeaderDIVFmt_Plain_Middle[]= L" ",
                    c_wszHtml_HeaderDIVFmt_Plain_End[]  = L"</DIV>";

static const int    c_cchHtml_HeaderDIVFmt_Start   = ARRAYSIZE(c_wszHtml_HeaderDIVFmt_Start) - 1,
                    c_cchHtml_HeaderDIVFmt_Middle  = ARRAYSIZE(c_wszHtml_HeaderDIVFmt_Middle) - 1,
                    c_cchHtml_HeaderDIVFmt_End     = ARRAYSIZE(c_wszHtml_HeaderDIVFmt_End) - 1,
                                       
                    c_cchHtml_HeaderDIVFmt_Plain_Start  = ARRAYSIZE(c_wszHtml_HeaderDIVFmt_Plain_Start) - 1,
                    c_cchHtml_HeaderDIVFmt_Plain_Middle = ARRAYSIZE(c_wszHtml_HeaderDIVFmt_Plain_Middle) - 1,
                    c_cchHtml_HeaderDIVFmt_Plain_End    = ARRAYSIZE(c_wszHtml_HeaderDIVFmt_Plain_End) - 1;

// HARDCODED Western headers
static const LPWSTR c_rgwszHeaders[HEADER_MAX] = {  L"From:",
                                                    L"Newsgroups:",
                                                    L"To:",
                                                    L"Cc:",
                                                    L"Sent:",
                                                    L"Attach:",
                                                    L"Subject:"};
static const int   c_rgidsHeaders[HEADER_MAX] ={   
                                                    idsFromField, 
                                                    idsNewsgroupsField, 
                                                    idsToField, 
                                                    idsCcField, 
                                                    idsDateField, 
                                                    idsAttachField,
                                                    idsSubjectField};

/*
 *  g l o b a l s 
 */


/*
 *  p r o t o t y p e s
 */
HRESULT CreatePrintHeader(IMimeMessageW *pMsg, LPWSTR pwszUser, DWORD dwFlags, LPSTREAM pstm);
HRESULT CreateMailHeader(IMimeMessageW *pMsg, DWORD dwFlags, LPSTREAM pstm);
HRESULT CreateNewsHeader(IMimeMessageW *pMsg, DWORD dwFlags, LPSTREAM pstm);
HRESULT GetHeaderLabel(ULONG uHeader, DWORD dwFlags, LPWSTR *ppwszOut);
HRESULT GetHeaderText(IMimeMessageW *pMsg, ULONG uHeader, DWORD dwFlags, LPWSTR *ppwszOut);
HRESULT CreateHTMLAddressLine(IMimeMessageW *pMsg, DWORD dwAdrTypes, LPWSTR *ppwszOut);
void DropAngles(LPWSTR pwszIn, LPWSTR *ppwszOut);

/*
 *  f u n c t i o n s
 */

 
 /*
 * Trident doesn't do a good job of converting tables->plaintext, so we can't use
 * a table to construct the header of a re: fw: etc to get nice alignment on the 
 * field boundaries. We can use a table, however for printing. We need to be able to
 * construct a header (in html source) in 3 flavours:
 *
 * HDR_PLAIN    (regular text, eg: reply in plain-mode)
 * HDR_HTML     (regular text, with bolded fields, eg: reply in html-mode)
 * HDR_TABLE    (use table to get improved output, eg: printing)
 *
 */
HRESULT GetHeaderTable(IMimeMessageW *pMsg, LPWSTR pwszUserName, DWORD dwHdrStyle, LPSTREAM *ppstm)
{
    HRESULT     hr = S_OK;
    LPSTREAM    pstm = NULL;
    BYTE        bUniMark = 0xFF;

    if (pMsg==NULL || ppstm==NULL)
        IF_FAILEXIT(hr = E_INVALIDARG);

    IF_FAILEXIT(hr = MimeOleCreateVirtualStream(&pstm));

    // Write out the BOM
    IF_FAILEXIT(hr = pstm->Write(&bUniMark, sizeof(bUniMark), NULL));
    bUniMark = 0xFE;
    IF_FAILEXIT(hr = pstm->Write(&bUniMark, sizeof(bUniMark), NULL));

    if (dwHdrStyle & HDR_TABLE)
        IF_FAILEXIT(hr = CreatePrintHeader(pMsg, pwszUserName, dwHdrStyle, pstm));

    else if (dwHdrStyle & HDR_NEWSSTYLE)
        IF_FAILEXIT(hr = CreateNewsHeader(pMsg, dwHdrStyle, pstm));

    else
        IF_FAILEXIT(hr = CreateMailHeader(pMsg, dwHdrStyle, pstm));

    *ppstm = pstm;
    pstm = NULL;

exit:
    ReleaseObj(pstm);
    return hr;
}


HRESULT CreateNewsHeader(IMimeMessageW *pMsg, DWORD dwFlags, LPSTREAM pstm)
{
    HRESULT         hr = S_OK;
    WCHAR           wsz[CCHMAX_STRINGRES];
    ULONG           cch,
                    cb;
    LPWSTR          pwsz = NULL,
                    pwszFrom = NULL,
                    pwszMsgId = NULL,
                    pwszFmtMsgId = NULL,
                    pwszHtml;

    Assert(pMsg);
    Assert(pstm);

    pMsg->GetAddressFormatW(IAT_FROM, AFT_DISPLAY_BOTH, &pwszFrom);
    MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_MESSAGEID), NOFLAGS, &pwszMsgId);

    *wsz = 0;
    cch = LoadStringWrapW(g_hLocRes, idsReplyTextPrefix, wsz, ARRAYSIZE(wsz));
    cb = cch*sizeof(WCHAR);
        
    // Opie assumes me these Sz function never return NULL. Only an empty buffer
    if (pwszFrom)
        cb += WSZ_CB(pwszFrom);
    else
        pwszFrom=(LPWSTR)c_szEmptyW;

    if (pwszMsgId)
    {
            // We purposely remove < and > from the msgId so Trident will correctly
            // format the msgId as a news: link and not a mailto:
            DropAngles(pwszMsgId, &pwszFmtMsgId);
            cb += WSZ_CB(pwszFmtMsgId);
    }
    else
        pwszFmtMsgId=(LPWSTR)c_szEmptyW;

    // Add null
    cb += sizeof(WCHAR);

    IF_NULLEXIT(MemAlloc((LPVOID *)&pwsz, cb));
    
    IF_FAILEXIT(hr = pstm->Write(c_wszHtml_DivOpen, WSZ_CB(c_wszHtml_DivOpen), NULL));

    // We just write out the e-mail name and news:message-id,
    // trident does URL autodetection and makes the e-mail into a mailto link and the
    // news: into a news link.
    wnsprintfW(pwsz, cb, wsz, pwszFrom, pwszFmtMsgId);

    IF_FAILEXIT(hr = EscapeStringToHTML(pwsz, &pwszHtml));

    pstm->Write(pwszHtml, WSZ_CB(pwszHtml), NULL);
    MemFree(pwszHtml);
        
    IF_FAILEXIT(hr = pstm->Write(c_wszHtml_DivClose, WSZ_CB(c_wszHtml_DivClose), NULL));

exit:    
    if (pwszFrom != c_szEmptyW)
        MemFree(pwszFrom);

    MemFree(pwszMsgId);
    // pwszFmtMsgId was freed when we freed lpsMsgId

    MemFree(pwsz);
    return hr;
}





/*
<DIV style="font: 10pt arial">
  -----Original Message-----
  <DIV STYLE="background:gainsboro; font-color:black">
    <B>From:</B> <a href="mailto:justinf@microsoft.com">Justin Ferrari</a>
  </DIV>
  <DIV>
    <B>To:</B> 
    <A href="mailto:johnt@microsoft.com" TITLE="johnt@microsoft.com">John Tafoya</A>; 
    <A href="mailto:laurena@microsoft.com" TITLE="laurena@microsoft.com">Lauren Antonoff</A>; 
    <A href="mailto:dhaws@microsoft.com" TITLE="dhaws@microsoft.com">Dave Haws</A>; 
    <A href="mailto:jdoe@microsoft.com" TITLE="jdoe@microsoft.com">John Doe</A>
  </DIV>
  <DIV>
    <B>Date:</B> Tuesday, September 01, 1998 10:40 AM
  </DIV>
  <DIV>
    <B>Subject: </B>Re: A plea to save the life of the News Server combo box
  </DIV>
  <DIV><BR></DIV>
</DIV>
*/

HRESULT CreateMailHeader(IMimeMessageW *pMsg, DWORD dwFlags, LPSTREAM pstm)
{
    ULONG           uHeader,
                    cchFmt;
    WCHAR           wsz[CCHMAX_STRINGRES],
                    wszText[CCHMAX_STRINGRES];
    LPWSTR          pwsz = NULL,
                    pwszText = NULL,
                    pwszLabel = NULL,
                    pwszHtml = NULL;
    
    LPCWSTR         pwszFmtStart,
                    pwszFmtMiddle,
                    pwszFmtEnd;
    int             cchFmtStart,
                    cchFmtMiddle,
                    cchFmtEnd;

    HRESULT         hr = S_OK;

    if (pMsg==NULL || pstm==NULL)
        IF_FAILEXIT(hr = E_INVALIDARG);

    // emit a table to display the username
    if (LoadStringWrapW(g_hLocRes, 
                        dwFlags & HDR_HTML ? idsReplyHeader_Html_SepBlock : idsReplyHeader_SepBlock, 
                        wsz, 
                        ARRAYSIZE(wsz)))
    {
        *wszText=0;
        if (dwFlags & HDR_HARDCODED)
            StrCpyNW(wszText, L"----- Original Message -----", ARRAYSIZE(wszText));
        else
            LoadStringWrapW(g_hLocRes, idsReplySep, wszText, ARRAYSIZE(wszText));

        IF_NULLEXIT(pwsz = PszAllocW(WSZ_CCH(wszText) + WSZ_CCH(wsz) + 1));

        wnsprintfW(pwsz, (WSZ_CCH(wszText) + WSZ_CCH(wsz) + 1), wsz, wszText);
        pstm->Write(pwsz, WSZ_CB(pwsz), NULL);
        SafeMemFree(pwsz);
    }

    if (dwFlags & HDR_HTML)
    {
        pwszFmtStart  = c_wszHtml_HeaderDIVFmt_Start;
        pwszFmtMiddle = c_wszHtml_HeaderDIVFmt_Middle;
        pwszFmtEnd    = c_wszHtml_HeaderDIVFmt_End;

        cchFmtStart  = c_cchHtml_HeaderDIVFmt_Start;
        cchFmtMiddle = c_cchHtml_HeaderDIVFmt_Middle;
        cchFmtEnd    = c_cchHtml_HeaderDIVFmt_End;
    }
    else
    {
        pwszFmtStart  = c_wszHtml_HeaderDIVFmt_Plain_Start;
        pwszFmtMiddle = c_wszHtml_HeaderDIVFmt_Plain_Middle;
        pwszFmtEnd    = c_wszHtml_HeaderDIVFmt_Plain_End;

        cchFmtStart  = c_cchHtml_HeaderDIVFmt_Plain_Start;
        cchFmtMiddle = c_cchHtml_HeaderDIVFmt_Plain_Middle;
        cchFmtEnd    = c_cchHtml_HeaderDIVFmt_Plain_End;
    }

    // write out each header row
    for (uHeader=0; uHeader<HEADER_MAX; uHeader++)
    {
        // skip attachment header for reply and forward headers
        if (uHeader == HEADER_ATTACH)
            continue;

        // special case address-headers in HTML-Mode
        if (dwFlags & HDR_HTML)
        {
            switch (uHeader)
            {
                case HEADER_FROM:
                {
                    if (CreateHTMLAddressLine(pMsg, IAT_FROM, &pwsz)==S_OK)
                    {
                        if (GetHeaderLabel(uHeader, dwFlags, &pwszLabel)==S_OK)
                        {
                            // pszLabel is fixed size
                            wnsprintfW(wsz, ARRAYSIZE(wsz), c_wszHtml_FromDIV, pwszLabel); 
                            pstm->Write(wsz, WSZ_CB(wsz), NULL);
                            pstm->Write(pwsz, WSZ_CB(pwsz), NULL);
                            pstm->Write(c_wszHtmlDIV_Close, WSZ_CB(c_wszHtmlDIV_Close), NULL);
                            SafeMemFree(pwszLabel);
                        }
                        SafeMemFree(pwsz);
                    }
                    continue;
                }

                case HEADER_TO:
                case HEADER_CC:
                {
                    if (CreateHTMLAddressLine(pMsg, uHeader == HEADER_TO ? IAT_TO : IAT_CC, &pwsz)==S_OK)
                    {
                        if (GetHeaderLabel(uHeader, dwFlags, &pwszLabel)==S_OK)
                        {
                            wnsprintfW(wsz, ARRAYSIZE(wsz), c_wszHtml_HeaderDIV, pwszLabel);   // pszLabel is fixed size
                            pstm->Write(wsz, WSZ_CB(wsz), NULL);
                            pstm->Write(pwsz, WSZ_CB(pwsz), NULL);
                            pstm->Write(c_wszHtmlDIV_Close, WSZ_CB(c_wszHtmlDIV_Close), NULL);
                            SafeMemFree(pwszLabel);
                        }
                        SafeMemFree(pwsz);
                    }
                    continue;
                }
            }
        }

        // normal headers
        if (GetHeaderLabel(uHeader, dwFlags, &pwszLabel)==S_OK)
        {
            if (GetHeaderText(pMsg, uHeader, dwFlags, &pwszText)==S_OK)
            {
                if (*pwszText)   // ignore empty strings
                {
                    int cch = 0;
                    int cchLabel;
                    int cchHtml;
                    
                    IF_FAILEXIT(hr = EscapeStringToHTML(pwszText, &pwszHtml));
                    
                    cchLabel = WSZ_CCH(pwszLabel);
                    cchHtml  = WSZ_CCH(pwszHtml);

                    // 1 for the NULL
                    DWORD cchSize = (cchLabel + cchHtml + cchFmtStart + cchFmtMiddle + cchFmtEnd + 1);
                    IF_NULLEXIT(pwsz = PszAllocW(cchSize));

                    // Avoid potentially dumping > 1024 into wnsprintfW
                    StrCpyNW(pwsz, pwszFmtStart, cchSize);
                    cch = cchFmtStart;
                    StrCpyNW(&pwsz[cch], pwszLabel, cchSize - cch);
                    cch += cchLabel;
                    StrCpyNW(&pwsz[cch], pwszFmtMiddle, cchSize - cch);
                    cch += cchFmtMiddle;
                    StrCpyNW(&pwsz[cch], pwszHtml, cchSize - cch);
                    cch += cchHtml;
                    StrCpyNW(&pwsz[cch], pwszFmtEnd, cchSize - cch);
                    cch += cchFmtEnd;

                    pstm->Write(pwsz, cch * sizeof(WCHAR), NULL);

                    SafeMemFree(pwsz);
                    SafeMemFree(pwszHtml);
                }
                SafeMemFree(pwszText);
            }
            SafeMemFree(pwszLabel);
        }            
    }

    // Close the <DIV> that wraps the whole thing in a font
    pstm->Write(c_wszHtmlDIV_Close, WSZ_CB(c_wszHtmlDIV_Close), NULL);
    
    // add a <DIV><BR></DIV> to give one line-spacing
    pstm->Write(c_wszHtml_DIV_BR_DIV, WSZ_CB(c_wszHtml_DIV_BR_DIV), NULL);

exit:
    MemFree(pwszHtml);
    MemFree(pwszText);
    MemFree(pwszLabel);
    MemFree(pwsz);

    return hr;
}


HRESULT CreatePrintHeader(IMimeMessageW *pMsg, LPWSTR pwszUser, DWORD dwFlags, LPSTREAM pstm)
{
    ULONG           uHeader;
    WCHAR           wsz[CCHMAX_STRINGRES];
    LPWSTR          pwsz = NULL,
                    pwszText = NULL,
                    pwszLabel = NULL,
                    pwszHtml = NULL;
    HRESULT         hr = S_OK;
    int             cch = 0;

    if (pMsg==NULL || pstm==NULL)
        IF_FAILEXIT(hr = E_INVALIDARG);
    
    // if no username, use "" so wsprintf is happy
    if (pwszUser == NULL)
        pwszUser = (LPWSTR)c_szEmptyW;

    // Emit an <HTML> tag for trident autodetector (used on the print-header)
    pstm->Write(c_wszHtml, WSZ_CB(c_wszHtml), NULL);

    // emit a table to display the username
    if (LoadStringWrapW(g_hLocRes, idsPrintTable_UserName, wsz, ARRAYSIZE(wsz)))
    {
        IF_FAILEXIT(hr = EscapeStringToHTML(pwszUser, &pwszHtml));
        IF_NULLEXIT(pwsz = PszAllocW(WSZ_CCH(wsz) + WSZ_CCH(pwszHtml) + 1));

        wnsprintfW(pwsz, (WSZ_CCH(wsz) + WSZ_CCH(pwszHtml) + 1), wsz, pwszHtml);
        pstm->Write(pwsz, WSZ_CB(pwsz), NULL);

        SafeMemFree(pwsz);
        SafeMemFree(pwszHtml);
    }

    // start the main-table
    if (LoadStringWrapW(g_hLocRes, idsPrintTable_Header, wsz, ARRAYSIZE(wsz)))
    {
        pstm->Write(wsz, WSZ_CB(wsz), NULL);

        if (LoadStringWrapW(g_hLocRes, idsPrintTable_HeaderRow, wsz, ARRAYSIZE(wsz)))
        {
            // write out each header row
            for (uHeader=0; uHeader<HEADER_MAX; uHeader++)
            {
                if (GetHeaderLabel(uHeader, dwFlags, &pwszLabel)==S_OK)
                {
                    if (GetHeaderText(pMsg, uHeader, dwFlags, &pwszText)==S_OK)
                    {
                        if (*pwszText)   // ignore empty strings
                        {
                            IF_FAILEXIT(hr = EscapeStringToHTML(pwszText, &pwszHtml));

                            cch = lstrlenW(pwszLabel) + lstrlenW(pwszHtml) + lstrlenW(wsz) +1;
                            IF_NULLEXIT(pwsz = PszAllocW(cch));

                            wnsprintfW(pwsz, cch, wsz, pwszLabel, pwszHtml);
                            pstm->Write(pwsz, WSZ_CB(pwsz), NULL);

                            SafeMemFree(pwsz);
                            SafeMemFree(pwszHtml);
                        }
                        SafeMemFree(pwszText);
                    }
                    SafeMemFree(pwszLabel);
                }
            }
        }
        pstm->Write(c_wszTableTag_Close, WSZ_CB(c_wszTableTag_Close), NULL);
    }

exit:
    MemFree(pwsz);
    MemFree(pwszHtml);
    MemFree(pwszText);
    MemFree(pwszLabel);

    return hr;
}


HRESULT GetHeaderText(IMimeMessageW *pMsg, ULONG uHeader, DWORD dwFlags, LPWSTR *ppwszOut)
{
    PROPVARIANT     pv;
    HBODY          *rghAttach = NULL;
    ULONG           cAttach,
                    uAttach,
                    cchSize=0;
    LPWSTR         *rgpwsz = NULL,
                    pwszWrite = NULL,
                    pwszEnd = NULL;
    HRESULT         hr = S_OK;

    Assert(pMsg);
    Assert(ppwszOut);
    *ppwszOut = 0;

    switch (uHeader)
    {
        case HEADER_FROM:
            pMsg->GetAddressFormatW(IAT_FROM, AFT_DISPLAY_BOTH, ppwszOut);
            break;

        case HEADER_NEWSGROUP:
            MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_NEWSGROUPS), NOFLAGS, ppwszOut);
            break;

        case HEADER_TO:
            pMsg->GetAddressFormatW(IAT_TO, AFT_DISPLAY_BOTH, ppwszOut);
            break;

        case HEADER_CC:
            pMsg->GetAddressFormatW(IAT_CC, AFT_DISPLAY_BOTH, ppwszOut);
            break;

        case HEADER_ATTACH:
            if (pMsg->GetAttachments(&cAttach, &rghAttach)==S_OK && cAttach)
            {
                // create cache-string list
                IF_NULLEXIT(rgpwsz = (LPWSTR*)ZeroAllocate(sizeof(*rgpwsz) * cAttach));
            
                for (uAttach=0; uAttach<cAttach; uAttach++)
                {
                    if (MimeOleGetBodyPropW(pMsg, rghAttach[uAttach], PIDTOSTR(PID_ATT_GENFNAME), NOFLAGS, &rgpwsz[uAttach])==S_OK)
                        cchSize += (WSZ_CCH(rgpwsz[uAttach]) + 2);     // +2 for "; "
                }

                IF_NULLEXIT(MemAlloc((LPVOID *)ppwszOut, cchSize * sizeof((*ppwszOut)[0])));
                pwszWrite = *ppwszOut;
                pwszEnd = pwszWrite + cchSize;

                for (uAttach=0; uAttach<cAttach; uAttach++)
                {
                    StrCpyNW(pwszWrite, rgpwsz[uAttach], (DWORD)(pwszEnd-pwszWrite));
                    pwszWrite += WSZ_CCH(rgpwsz[uAttach]);
                    if (uAttach != cAttach -1)
                    {
                        StrCpyNW(pwszWrite, L"; ", (DWORD)(pwszEnd-pwszWrite));
                        pwszWrite += 2;
                    }
                }
            }
            break;

        case HEADER_SENT:
            pv.vt = VT_FILETIME;
            if (SUCCEEDED(pMsg->GetProp(PIDTOSTR(PID_ATT_SENTTIME), 0, &pv)))
            {
                LPWSTR  lpwsz = NULL;
                INT     cch = 0;
                
                IF_NULLEXIT(MemAlloc((LPVOID*)&lpwsz, CCHMAX_STRINGRES * sizeof(*lpwsz)));

                *lpwsz = 0;

                // always force a western date if using hardcoded headers
                // For the formatted date, DTM_FORCEWESTERN flag returns English date and time. 
                // Without DTM_FORCEWESTERN the formatted time may not be representable in ASCII.
                cch = AthFileTimeToDateTimeW(&pv.filetime, lpwsz, CCHMAX_STRINGRES, 
                                             DTM_NOSECONDS|DTM_LONGDATE|(dwFlags & HDR_HARDCODED ?DTM_FORCEWESTERN:0));
                
                *ppwszOut = lpwsz;
            }
            break;
        
        case HEADER_SUBJECT:
            MimeOleGetBodyPropW(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, ppwszOut);
            break;

        default:
            AssertSz(0, "Not Supported");
    }

exit:
    // free cached string-list
    if (rgpwsz)
    {
        for (uAttach=0; uAttach<cAttach; uAttach++)
            MemFree(rgpwsz[uAttach]);
        MemFree(rgpwsz);
    }

    MemFree(rghAttach);

    // In this case, we failed but that is ok so don't trace result.
    // Just means that the field asked for is empty.
    if (SUCCEEDED(hr) && (0 == *ppwszOut))
        hr = E_FAIL;


    return hr;
}

HRESULT GetHeaderLabel(ULONG uHeader, DWORD dwFlags, LPWSTR *ppwszOut)
{
    WCHAR           wsz[CCHMAX_STRINGRES];

    Assert(ppwszOut);
    *ppwszOut = 0;

    if (dwFlags & HDR_HARDCODED)
        *ppwszOut = PszDupW(c_rgwszHeaders[uHeader]);
    else
    {
        if(LoadStringWrapW(g_hLocRes, c_rgidsHeaders[uHeader], wsz, ARRAYSIZE(wsz)))
            *ppwszOut = PszDupW(wsz);
    }
    return *ppwszOut ? S_OK : E_FAIL;
}


HRESULT CreateHTMLAddressLine(IMimeMessageW *pMsg, DWORD dwAdrTypes, LPWSTR *ppwszOut)
{
    ADDRESSLIST     rAdrList = {0};
    BOOL            fFreeAdrList;
    ULONG           i;
    ULONG           cb=0;
    LPWSTR          pwsz = NULL,
                    pwszWrite = NULL,
                    pwszEnd = NULL,
                    pwszEmail = NULL,
                    pwszEmailLoop = NULL,
                    pwszFriendly = NULL,
                   *rgpwszEmail = NULL,
                   *rgpwszFriendly = NULL;
    ULONG           cAddr = 0;
    HRESULT         hr = S_OK;

    Assert (pMsg);
    
    // Get address table
    IF_FAILEXIT(hr = pMsg->GetAddressTypes(dwAdrTypes, IAP_FRIENDLYW|IAP_EMAIL, &rAdrList));

    cAddr = rAdrList.cAdrs;
    
    // If no addresses, bail
    if (cAddr == 0)
        IF_FAILEXIT(hr = E_FAIL);

    // Allocate array for escaped email addresses
    IF_NULLEXIT(rgpwszEmail = (LPWSTR*)ZeroAllocate(sizeof(*rgpwszEmail) * cAddr));
    
    // Allocate array for escaped displaynames
    IF_NULLEXIT(rgpwszFriendly = (LPWSTR*)ZeroAllocate(sizeof(*rgpwszFriendly) * cAddr));

    for (i=0; i < cAddr; i++)
    {
        // escape all of the names into our name array
        if (rAdrList.prgAdr[i].pszEmail)
        {
            IF_NULLEXIT(pwszEmail = PszToUnicode(CP_ACP, rAdrList.prgAdr[i].pszEmail));

            // Escape Into Array
            IF_FAILEXIT(hr = EscapeStringToHTML(pwszEmail, &rgpwszEmail[i]));

            // Use Email if no Friendly Name
            if (NULL == (pwszFriendly = rAdrList.prgAdr[i].pszFriendlyW))
                pwszFriendly = pwszEmail;

            IF_FAILEXIT(hr = EscapeStringToHTML(pwszFriendly, &rgpwszFriendly[i]));
            
            // for each address we use 2*email + display + htmlgoo + "; "
            // if display == null, we use email. We skip if email==NULL (failure case)
            cb += (
                    2*WSZ_CCH(rgpwszEmail[i]) + 
                    WSZ_CCH(rgpwszFriendly[i]) + 
                    WSZ_CCH(c_wszHtmlReplyAnchor) + 
                    2
                  ) * sizeof(WCHAR);
            SafeMemFree(pwszEmail);
        }
    }

    IF_NULLEXIT(MemAlloc((LPVOID *)&pwsz, cb));

    pwszWrite = pwsz;
    pwszEnd = pwszWrite + (cb/sizeof(WCHAR));
    for (i=0; i < cAddr; i++)
    {
        if (pwszEmailLoop = rgpwszEmail[i])
        {
            pwszFriendly = rgpwszFriendly[i];
            Assert (pwszFriendly);
            wnsprintfW(pwszWrite, (DWORD)(pwszEnd-pwszWrite), c_wszHtmlReplyAnchor, pwszEmailLoop, pwszEmailLoop, pwszFriendly);
            pwszWrite += WSZ_CCH(pwszWrite);
            if (i != cAddr-1)
            {
                StrCpyNW(pwszWrite, L"; ", (DWORD)(pwszEnd-pwszWrite));
                pwszWrite += 2;
            }
        }
    }

    *ppwszOut = pwsz;
    pwsz = NULL;         // freed by caller

exit:
    if (rgpwszEmail)
    {
        for (i=0; i < cAddr; i++)
            MemFree(rgpwszEmail[i]);
        MemFree(rgpwszEmail);
    }

    if (rgpwszFriendly)
    {
        for (i=0; i < cAddr; i++)
            MemFree(rgpwszFriendly[i]);
        MemFree(rgpwszFriendly);
    }

    MemFree(pwsz);
    MemFree(pwszEmail);
    g_pMoleAlloc->FreeAddressList(&rAdrList);
    return hr;
}



void GetRGBFromString(DWORD* pRGB, LPSTR pszColor)
{
    DWORD   dwShiftAmount = 0,
            rgb = 0,
            n;
    CHAR    ch;
    
    Assert(pRGB);
    Assert(lstrlen(pszColor) == lstrlen("RRGGBB"));
    
    *pRGB = 0;
    
    while (0 != (ch = *pszColor++))
    {
        if (ch >= '0' && ch <= '9')
            n = ch - '0';
        else if(ch >= 'A' && ch <= 'F')
            n = ch - 'A' + 10;
        else 
        {
            Assert(ch >= 'a' && ch <= 'f')
                n = ch - 'a' + 10;
        }
        rgb = (rgb << 4) + n;
    }
    
    rgb = ((rgb & 0x00ff0000) >> 16 ) | (rgb & 0x0000ff00) | ((rgb & 0x000000ff) << 16);
    *pRGB = rgb;
}

void GetStringRGB(DWORD rgb, LPSTR pszColor)
{
    INT           i;
    DWORD         crTemp;
    
    Assert(pszColor);
    
    rgb = ((rgb & 0x00ff0000) >> 16 ) | (rgb & 0x0000ff00) | ((rgb & 0x000000ff) << 16);
    for(i = 0; i < 6; i++)
    {
        crTemp = (rgb & (0x00f00000 >> (4*i))) >> (4*(5-i));
        pszColor[i] = (CHAR)((crTemp < 10)? (crTemp+'0') : (crTemp+ 'a' - 10));
    }
    pszColor[6] = '\0';
}


/*
    This function drops the enclosing < and > around a msg-id
    RFC822:     msg-id = "<" addr-spec ">"
    NOTE:
    The input buffer is MODIFIED and the output pointer
    points to memory in pszIn!
*/
void DropAngles(LPWSTR pwszIn, LPWSTR *ppwszOut)
{
    if (pwszIn)
    {
        WCHAR ch;
        LPWSTR pwszCurrent = pwszIn;
        
        // First character should be <, but be robust and scan for it
        while ((ch = *pwszCurrent++) && (ch != L'<'));
        
        if (ch)
            // We are interested in stuff after the angle bracket
            *ppwszOut = pwszCurrent;
        else
            // Perhaps the message-id was malformed and doesn't contain a <
            *ppwszOut = pwszIn;
        
        pwszCurrent = *ppwszOut;
        
        // Find the close bracket and null it out
        while ((ch = *pwszCurrent) && (ch != L'>'))
            pwszCurrent++;
        
        // If we found a >, overwrite it with NULL
        if (ch)
            *pwszCurrent = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\doc.h ===
/*
 *    d o c . h
 *    
 *    Purpose:
 *
 *  History
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _DOC_H
#define _DOC_H

#include "privunk.h"
#include "mimeedit.h"

class CBody;
interface IOleObject;
interface IOleDocument;
interface IOleDocumentView;
interface IPersistMime; 
interface IMimeMessage;
 
//#define OFFICE_BINDER

enum OLE_SERVER_STATE
    {
    OS_PASSIVE,
    OS_LOADED,                          // handler but no server
    OS_RUNNING,                         // server running, invisible
    OS_INPLACE,                         // server running, inplace-active, no U.
    OS_UIACTIVE,                        // server running, inplace-active, w/ U.
    };

class CDoc:
    public IOleObject,
    public IOleInPlaceObject,
    public IOleInPlaceActiveObject,
    public IOleDocument,
    public IOleDocumentView,
    public IOleCommandTarget,
    public IServiceProvider,
    public IPersistMime,
    public IPersistStreamInit,
    public IPersistFile,
    public IPersistMoniker,
    public IMimeEdit,
    public IQuickActivate,
#ifdef OFFICE_BINDER
    public IPersistStorage,
#endif

    public CPrivateUnknown
{
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { 
        return CPrivateUnknown::QueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void) { 
        return CPrivateUnknown::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) { 
        return CPrivateUnknown::Release(); };

    // *** IOleDocument ***
    virtual HRESULT STDMETHODCALLTYPE CreateView(IOleInPlaceSite *pSite, IStream *pstm, DWORD dwReserved, IOleDocumentView **ppView);
    virtual HRESULT STDMETHODCALLTYPE GetDocMiscStatus(DWORD *pdwStatus);
    virtual HRESULT STDMETHODCALLTYPE EnumViews(IEnumOleDocumentViews **ppEnum, IOleDocumentView **ppView);

    // *** IOleDocumentView ***
    virtual HRESULT STDMETHODCALLTYPE SetInPlaceSite(IOleInPlaceSite *pIPSite);
    virtual HRESULT STDMETHODCALLTYPE GetInPlaceSite(IOleInPlaceSite **ppIPSite);
    virtual HRESULT STDMETHODCALLTYPE GetDocument(IUnknown **ppunk);
    virtual HRESULT STDMETHODCALLTYPE SetRect(LPRECT prcView);
    virtual HRESULT STDMETHODCALLTYPE GetRect(LPRECT prcView);
    virtual HRESULT STDMETHODCALLTYPE SetRectComplex(LPRECT prcView, LPRECT prcHScroll, LPRECT prcVScroll, LPRECT prcSizeBox);
    virtual HRESULT STDMETHODCALLTYPE Show(BOOL fShow);
    virtual HRESULT STDMETHODCALLTYPE UIActivate(BOOL fUIActivate);
    virtual HRESULT STDMETHODCALLTYPE Open();
    virtual HRESULT STDMETHODCALLTYPE CloseView(DWORD dwReserved);
    virtual HRESULT STDMETHODCALLTYPE SaveViewState(LPSTREAM pstm);
    virtual HRESULT STDMETHODCALLTYPE ApplyViewState(LPSTREAM pstm);
    virtual HRESULT STDMETHODCALLTYPE Clone(IOleInPlaceSite *pIPSiteNew, IOleDocumentView **ppViewNew);

    // *** IOleObject ***
    virtual HRESULT STDMETHODCALLTYPE SetClientSite(IOleClientSite *pClientSite);
    virtual HRESULT STDMETHODCALLTYPE GetClientSite(IOleClientSite **ppClientSite);
    virtual HRESULT STDMETHODCALLTYPE SetHostNames(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj);
    virtual HRESULT STDMETHODCALLTYPE Close(DWORD dwSaveOption);
    virtual HRESULT STDMETHODCALLTYPE SetMoniker(DWORD dwWhichMoniker, IMoniker *pmk);
    virtual HRESULT STDMETHODCALLTYPE GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk);
    virtual HRESULT STDMETHODCALLTYPE InitFromData(IDataObject *pDataObject, BOOL fCreation, DWORD dwReserved);
    virtual HRESULT STDMETHODCALLTYPE GetClipboardData(DWORD dwReserved, IDataObject **ppDataObject);
    virtual HRESULT STDMETHODCALLTYPE DoVerb(LONG iVerb, LPMSG lpmsg, IOleClientSite *pActiveSite, LONG lindex, HWND hwndParent, LPCRECT lprcPosRect);
    virtual HRESULT STDMETHODCALLTYPE EnumVerbs(IEnumOLEVERB **ppEnumOleVerb);
    virtual HRESULT STDMETHODCALLTYPE Update();
    virtual HRESULT STDMETHODCALLTYPE IsUpToDate();
    virtual HRESULT STDMETHODCALLTYPE GetUserClassID(CLSID *pClsid);
    virtual HRESULT STDMETHODCALLTYPE GetUserType(DWORD dwFormOfType, LPOLESTR *pszUserType);
    virtual HRESULT STDMETHODCALLTYPE SetExtent(DWORD dwDrawAspect, SIZEL *psizel);
    virtual HRESULT STDMETHODCALLTYPE GetExtent(DWORD dwDrawAspect, SIZEL *psizel);
    virtual HRESULT STDMETHODCALLTYPE Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection);
    virtual HRESULT STDMETHODCALLTYPE Unadvise(DWORD dwConnection);
    virtual HRESULT STDMETHODCALLTYPE EnumAdvise(IEnumSTATDATA **ppenumAdvise);
    virtual HRESULT STDMETHODCALLTYPE GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus);
    virtual HRESULT STDMETHODCALLTYPE SetColorScheme(LOGPALETTE *pLogpal);

    // *** IOleInPlaceObject ***
    virtual HRESULT STDMETHODCALLTYPE InPlaceDeactivate();
    virtual HRESULT STDMETHODCALLTYPE UIDeactivate();
    virtual HRESULT STDMETHODCALLTYPE SetObjectRects(LPCRECT lprcPosRect, LPCRECT lprcClipRect);
    virtual HRESULT STDMETHODCALLTYPE ReactivateAndUndo();

    // *** IOleWindow *** 
    virtual HRESULT STDMETHODCALLTYPE GetWindow(HWND *phwnd);
    virtual HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL fEnterMode);

    // *** IOleInPlaceActiveObject ***
    virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator(LPMSG lpmsg);
    virtual HRESULT STDMETHODCALLTYPE OnFrameWindowActivate(BOOL fActivate);
    virtual HRESULT STDMETHODCALLTYPE OnDocWindowActivate(BOOL fActivate);
    virtual HRESULT STDMETHODCALLTYPE ResizeBorder(LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fFrameWindow);
    virtual HRESULT STDMETHODCALLTYPE EnableModeless(BOOL fEnable);

    // *** IOleCommandTarget ***
    virtual HRESULT STDMETHODCALLTYPE QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT *pCmdText);
    virtual HRESULT STDMETHODCALLTYPE Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANT *pvaIn, VARIANT *pvaOut);

    // *** IServiceProvider ***
    virtual HRESULT STDMETHODCALLTYPE QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject);

    // *** IPersist ***
    virtual HRESULT STDMETHODCALLTYPE GetClassID(CLSID *pClassID);

    // *** IPersistMime ***
	virtual HRESULT STDMETHODCALLTYPE Load(IMimeMessage *pMsg);
	virtual HRESULT STDMETHODCALLTYPE Save(IMimeMessage *pMsg, DWORD dwFlags);

    // *** IPersistStreamInit ***
    virtual HRESULT STDMETHODCALLTYPE IsDirty();
    virtual HRESULT STDMETHODCALLTYPE Load(LPSTREAM pstm);
    virtual HRESULT STDMETHODCALLTYPE Save(LPSTREAM pstm, BOOL fClearDirty);
    virtual HRESULT STDMETHODCALLTYPE GetSizeMax(ULARGE_INTEGER * pCbSize);
    virtual HRESULT STDMETHODCALLTYPE InitNew();

    // IPersistMoniker Members
    virtual HRESULT STDMETHODCALLTYPE Load(BOOL fFullyAvailable, IMoniker *pMoniker, IBindCtx *pBindCtx, DWORD grfMode);
    virtual HRESULT STDMETHODCALLTYPE GetCurMoniker(IMoniker **ppMoniker);
    virtual HRESULT STDMETHODCALLTYPE Save(IMoniker *pMoniker, IBindCtx *pBindCtx, BOOL fRemember);
    virtual HRESULT STDMETHODCALLTYPE SaveCompleted(IMoniker *pMoniker, IBindCtx *pBindCtx);

#ifdef OFFICE_BINDER
    // *** IPersistStorage ***
    virtual HRESULT STDMETHODCALLTYPE InitNew(IStorage *pStg);
    virtual HRESULT STDMETHODCALLTYPE Load(IStorage *pStg);
    virtual HRESULT STDMETHODCALLTYPE Save(IStorage *pStgSave, BOOL fSameAsLoad);
    virtual HRESULT STDMETHODCALLTYPE SaveCompleted(IStorage *pStgNew);
    virtual HRESULT STDMETHODCALLTYPE HandsOffStorage();
#endif

    // *** IDispatch ***
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo);
    virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
    virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid);
    virtual HRESULT STDMETHODCALLTYPE Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr);

    // *** IMimeEdit **
    virtual HRESULT STDMETHODCALLTYPE put_src(BSTR bstr);
    virtual HRESULT STDMETHODCALLTYPE get_src(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE put_header(LONG lStyle);
    virtual HRESULT STDMETHODCALLTYPE get_header(LONG *plStyle);
    virtual HRESULT STDMETHODCALLTYPE put_editMode(VARIANT_BOOL b);
    virtual HRESULT STDMETHODCALLTYPE get_editMode(VARIANT_BOOL *pbool);
    virtual HRESULT STDMETHODCALLTYPE get_messageSource(BSTR *pbstr);

// OE5_BETA2 needs to be defined in public headers
    virtual HRESULT STDMETHODCALLTYPE get_text(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE get_html(BSTR *pbstr);
    virtual HRESULT STDMETHODCALLTYPE clear();
    virtual HRESULT STDMETHODCALLTYPE get_doc(IDispatch **ppDoc);

// OE5_BETA2 needs to be defined in public headers

    // *** IQuickActivate ***
    virtual HRESULT STDMETHODCALLTYPE QuickActivate(QACONTAINER *pQaContainer, QACONTROL *pQaControl);
    virtual HRESULT STDMETHODCALLTYPE SetContentExtent(LPSIZEL pSizel);
    virtual HRESULT STDMETHODCALLTYPE GetContentExtent(LPSIZEL pSizel);

    // *** IPersistFile ***
    virtual HRESULT STDMETHODCALLTYPE Load(LPCOLESTR pszFileName, DWORD dwMode);
    virtual HRESULT STDMETHODCALLTYPE Save(LPCOLESTR pszFileName, BOOL fRemember);
    virtual HRESULT STDMETHODCALLTYPE SaveCompleted(LPCOLESTR pszFileName);
    virtual HRESULT STDMETHODCALLTYPE GetCurFile(LPOLESTR * ppszFileName);

    CDoc(IUnknown *pUnkOuter=NULL);
    virtual ~CDoc();

private:
    ULONG               m_ulState;
    HWND                m_hwndParent;
    LPSTR               m_lpszAppName;
    IOleClientSite      *m_pClientSite;
    IOleInPlaceSite     *m_pIPSite;
    IOleInPlaceFrame    *m_pInPlaceFrame;
    IOleInPlaceUIWindow *m_pInPlaceUIWindow;
	CBody				*m_pBodyObj;
    LPTYPEINFO          m_pTypeInfo;

    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);

    HRESULT ActivateView();
    HRESULT ActivateInPlace();
    HRESULT DeactivateInPlace();
    HRESULT ActivateUI();
    HRESULT DeactivateUI();

    HRESULT DoShow(IOleClientSite *pActiveSite, HWND hwndParent, LPCRECT lprcPosRect);

	HRESULT AttachWin(HWND hwndParent, LPRECT lprcPos);

    BOOL OnCreate(HWND hwnd);
    BOOL OnNCDestroy();

    HRESULT GetHostName(LPSTR szTitle, ULONG cch);
    HRESULT EnsureTypeLibrary();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\dochost.h ===
/*
 *    d o c h o s t . h
 *    
 *    Purpose:
 *        basic implementation of a docobject host. Used by the body class to
 *        host Trident and/or MSHTML
 *
 *  History
 *      August '96: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _DOCHOST_H
#define _DOCHOST_H

class CDocHost:
    public IOleInPlaceFrame,
    public IOleInPlaceSite,
    public IOleClientSite,
    public IOleControlSite,
    public IOleDocumentSite,
    public IOleCommandTarget,
    public IServiceProvider
{
public:
    // *** IUnknown methods ***
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, LPVOID FAR *);
    virtual ULONG STDMETHODCALLTYPE AddRef();
    virtual ULONG STDMETHODCALLTYPE Release();

    // *** IOleWindow methods ***
    virtual HRESULT STDMETHODCALLTYPE GetWindow(HWND *);
    virtual HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL);

    // *** IOleInPlaceUIWindow methods ***
    virtual HRESULT STDMETHODCALLTYPE GetBorder(LPRECT);
    virtual HRESULT STDMETHODCALLTYPE RequestBorderSpace(LPCBORDERWIDTHS);
    virtual HRESULT STDMETHODCALLTYPE SetBorderSpace(LPCBORDERWIDTHS);
    virtual HRESULT STDMETHODCALLTYPE SetActiveObject(IOleInPlaceActiveObject *, LPCOLESTR); 
    
    // *** IOleInPlaceFrame methods ***
    virtual HRESULT STDMETHODCALLTYPE InsertMenus(HMENU, LPOLEMENUGROUPWIDTHS);
    virtual HRESULT STDMETHODCALLTYPE SetMenu(HMENU, HOLEMENU, HWND);
    virtual HRESULT STDMETHODCALLTYPE RemoveMenus(HMENU);
    virtual HRESULT STDMETHODCALLTYPE SetStatusText(LPCOLESTR);    
    virtual HRESULT STDMETHODCALLTYPE EnableModeless(BOOL);
    virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator(LPMSG, WORD);

    // IOleInPlaceSite methods.
    virtual HRESULT STDMETHODCALLTYPE CanInPlaceActivate();
    virtual HRESULT STDMETHODCALLTYPE OnInPlaceActivate();
    virtual HRESULT STDMETHODCALLTYPE OnUIActivate();
    virtual HRESULT STDMETHODCALLTYPE GetWindowContext(LPOLEINPLACEFRAME *, LPOLEINPLACEUIWINDOW *, LPRECT, LPRECT, LPOLEINPLACEFRAMEINFO);
    virtual HRESULT STDMETHODCALLTYPE Scroll(SIZE);
    virtual HRESULT STDMETHODCALLTYPE OnUIDeactivate(BOOL);
    virtual HRESULT STDMETHODCALLTYPE OnInPlaceDeactivate();
    virtual HRESULT STDMETHODCALLTYPE DiscardUndoState();
    virtual HRESULT STDMETHODCALLTYPE DeactivateAndUndo();
    virtual HRESULT STDMETHODCALLTYPE OnPosRectChange(LPCRECT);

    // IOleClientSite methods.
    virtual HRESULT STDMETHODCALLTYPE SaveObject();
    virtual HRESULT STDMETHODCALLTYPE GetMoniker(DWORD, DWORD, LPMONIKER *);
    virtual HRESULT STDMETHODCALLTYPE GetContainer(LPOLECONTAINER *);
    virtual HRESULT STDMETHODCALLTYPE ShowObject();
    virtual HRESULT STDMETHODCALLTYPE OnShowWindow(BOOL);
    virtual HRESULT STDMETHODCALLTYPE RequestNewObjectLayout();

    // IOleControlSite
    virtual HRESULT STDMETHODCALLTYPE OnControlInfoChanged();
    virtual HRESULT STDMETHODCALLTYPE LockInPlaceActive(BOOL fLock);
    virtual HRESULT STDMETHODCALLTYPE GetExtendedControl(LPDISPATCH *ppDisp);
    virtual HRESULT STDMETHODCALLTYPE TransformCoords(POINTL *pPtlHimetric, POINTF *pPtfContainer,DWORD dwFlags);
    virtual HRESULT STDMETHODCALLTYPE TranslateAccelerator(MSG *lpMsg,DWORD grfModifiers);
    virtual HRESULT STDMETHODCALLTYPE OnFocus(BOOL fGotFocus);
    virtual HRESULT STDMETHODCALLTYPE ShowPropertyFrame(void);

    // IOleDocumentSite
    virtual HRESULT STDMETHODCALLTYPE ActivateMe(LPOLEDOCUMENTVIEW);

    // IOleCommandTarget
    virtual HRESULT STDMETHODCALLTYPE QueryStatus(const GUID *, ULONG, OLECMD prgCmds[], OLECMDTEXT *);
    virtual HRESULT STDMETHODCALLTYPE Exec(const GUID *, DWORD, DWORD, VARIANTARG *, VARIANTARG *);

    // IServiceProvider
    virtual HRESULT STDMETHODCALLTYPE QueryService(REFGUID guidService, REFIID riid, LPVOID *ppvObject);

    CDocHost();
    virtual ~CDocHost();
    
    // statics
    static LRESULT CALLBACK ExtWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    virtual LRESULT WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
   
    virtual HRESULT GetDocObjSize(LPRECT prc)
        {return E_NOTIMPL;};

    HRESULT CreateDocObj(LPCLSID pCLSID);
    HRESULT CloseDocObj();

    HRESULT Init(HWND hwndParent, BOOL fBorder, LPRECT prc);

    
    LPOLEOBJECT                 m_lpOleObj;
    LPOLECOMMANDTARGET          m_pCmdTarget;

protected:
    HWND                        m_hwnd,
                                m_hwndDocObj;
    LPOLEDOCUMENTVIEW           m_pDocView;
    BOOL                        m_fDownloading,
                                m_fFocus,
                                m_fUIActive,
                                m_fCycleFocus;
    LPOLEINPLACEACTIVEOBJECT    m_pInPlaceActiveObj;
	
	virtual HRESULT Show();
    virtual HRESULT OnUpdateCommands();
    virtual void WMSize(int x, int y);

private:
    ULONG               m_cRef;
    DWORD               m_dwFrameWidth,
                        m_dwFrameHeight;

    HRESULT CreateDocView();

    HRESULT OnCreate(HWND hwnd);
    HRESULT OnNCDestroy();
    HRESULT OnDestroy();
};

typedef CDocHost DOCHOST;
typedef DOCHOST *LPDOCHOST;

#endif //_DOCHOST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\frames.h ===
#ifndef _FRAMES_H
#define _FRAMES_H

HRESULT DoFindFrameInContext(IUnknown *pUnkTrident, IUnknown *pUnkThis,LPCWSTR pszTargetName, IUnknown *punkContextFrame, DWORD dwFlags, IUnknown **ppunkTargetFrame);


#endif //_FRAMES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\fmtbar.h ===
#ifndef _FMTBAR_H
#define _FMTBAR_H

#define FBN_BODYHASFOCUS    8001
#define FBN_BODYSETFOCUS    8002
#define FBN_GETMENUFONT     8003

class CFmtBar
{
public:
   	CFmtBar(BOOL fSep);
	~CFmtBar();

    ULONG AddRef();
    ULONG Release();

    HRESULT Init(HWND hwndParent, int iddlg);
    HRESULT SetCommandTarget(LPOLECOMMANDTARGET pCmdTarget);
    HRESULT OnWMCommand(HWND hwnd, int id, WORD wCmd);
    HRESULT Update();

    HRESULT Show();
    HRESULT Hide();

    HRESULT TranslateAcclerator(LPMSG lpMsg);
    HRESULT GetWindow(HWND *pHwnd);

    static LRESULT CALLBACK ExtWndProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK EditSubProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK ComboBoxSubProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK RebarSubProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
    static INT CALLBACK ExtEnumFontNamesProcEx(ENUMLOGFONTEX *plf, NEWTEXTMETRICEX *ptm, INT nFontType, LPARAM lParam);

private:
    IOleCommandTarget   *m_pCmdTarget;
    ULONG               m_cRef;
    HWND                m_hwnd,
                        m_hwndParent,
                        m_hwndToolbar,
                        m_hwndName,
                        m_hwndSize,
                        m_hwndRebar,
                        m_hwndTT;

    HMENU               m_hmenuColor,
                        m_hmenuTag;
    WNDPROC             m_wndprocEdit,
                        m_wndprocNameComboBox,
                        m_wndprocSizeComboBox,
                        m_wndprocRebar;
    HBITMAP             m_hbmName;
    BOOL                m_fDestroyTagMenu   :1,
                        m_fVisible          :1,
                        m_fSep              :1;
    int                 m_idd;
    HIMAGELIST          m_himlHot,
                        m_himl;

    HBITMAP LoadDIBBitmap(int id);
    VOID AddToolTip(HWND hwndToolTips, HWND hwnd, UINT idRsrc);
    DWORD FlipColor(DWORD rgb);
    HRESULT HrShowTagMenu(POINT pt);
    HRESULT HrInitTagMenu();
    INT XFontSizeCombo(HDC hdc);
    HRESULT CheckColor();

    INT EnumFontNamesProcEx(ENUMLOGFONTEX *plf, NEWTEXTMETRICEX *ptm, INT nFontType);

    // format bar
    void FillFontNames();
    void FillSizes();

    HRESULT ExecCommand(UINT uCmDId, DWORD dwOpt, VARIANTARG  *pvaIn);
    LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    // message handling
    void OnNCDestroy();
    HRESULT OnNCCreate(HWND hwnd);
    void WMNotify(WPARAM wParam, NMHDR* pnmhdr);

    // owner draw
    void OnDrawItem(LPDRAWITEMSTRUCT pdis);
    void OnMeasureItem(LPMEASUREITEMSTRUCT pmis);
    void ComboBox_WMDrawItem(LPDRAWITEMSTRUCT pdis);

    BOOL FBodyHasFocus();
    void SetBodyFocus();

    HMENU hmenuGetStyleTagMenu();

    HRESULT AttachWin();
    
    HIMAGELIST _CreateToolbarBitmap(int idb, int cx);
    HRESULT _SetToolbarBitmaps();    
    HRESULT _FreeImageLists();
    
};



typedef CFmtBar *LPFORMATBAR;

HRESULT HrCreateFormatBar(HWND hwndParent, int iddlg, BOOL fSep, LPFORMATBAR *ppFmtBar);

#endif  // _FMTBAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\fmtbar.cpp ===
/*
 *      f m t b a r . c p p
 *
 *      Format Bar based on IOleCommandTarget
 *      Owner:  brettm / a-mli
 *
 */
#include <pch.hxx>
#include "dllmain.h"
#include <shfusion.h>
#include "demand.h"
#include "resource.h"
#include "util.h"
#include "mshtml.h"
#include "mshtmhst.h"
#include "mshtmcid.h"
#include "docobj.h"
#include "fmtbar.h"
#include "strconst.h"
#include "comctrlp.h"
#include <shlguidp.h>

/*
 *  WS_EX_LAYOUTRTL ported from winuser.h
 */
#if WINVER < 0X0500
#define WS_EX_LAYOUTRTL                 0x00400000L // Right to left mirroring
#endif // WS_EX_LAYOUTRTL

/*
 *  m a c r o s
 */
#define GETINDEX(m) ((DWORD)((((m & 0xff000000) >> 24) & 0x000000ff)))
#define MAKEINDEX(b, l) (((DWORD)l & 0x00ffffff) | ((DWORD)b << 24))

/*
 *  c o n s t a n t s
 */
#define cxButtonSep 8
#define dxToolbarButton 16
#define COMBOBUFSIZE 64
#define dxFormatFontBitmap 20
#define dyFormatFontBitmap 12
#define NFONTSIZES 7
#define TEMPBUFSIZE 30
#define CYDROPDOWNEXPANDRATIO  8
#define SIZETEXTLIMIT 8
#define cxDUName 100
#define cyToolbarOffset 2
#define idcCoolbar      45

// FormatBar stuff
enum 
    {
    itbFormattingTag,
    itbFormattingBold,
    itbFormattingItalic,
    itbFormattingUnderline,
    itbFormattingColor,
    itbFormattingNumbers,
    itbFormattingBullets,
    itbFormattingDecreaseIndent,
    itbFormattingIncreaseIndent,
    itbFormattingLeft,
    itbFormattingCenter,
    itbFormattingRight,
    itbFormattingJustify,
    itbFormattingInsertHLine,
    itbFormattingInsertLink,
    itbFormattingInsertImage,
    ctbFormatting
    };


// FormatBar Paragraph direction stuff
enum
    {
    itbFormattingBlockDirLTR = ctbFormatting,
    itbFormattingBlockDirRTL,
    };



/*
 *  t y p e d e f s
 */
/*
 *  g l o b a l   d a t a
 */

static const TCHAR      c_szComboBox[] =    "ComboBox",
                        c_szFmtBarClass[] = "MimeEdit_FormatBar",
                        c_szThis[]          = "OE_This";

/*
 *      Color table for dropdown on toolbar.  Matches COMMDLG colors
 *      exactly.
 */

static DWORD rgrgbColors[] = 
    {
    RGB(  0,   0, 0),     // "BLACK"},   
    RGB(128,   0, 0),     // "MAROON"},
    RGB(  0, 128, 0),     // "GREEN"},
    RGB(128, 128, 0),     // "OLIVE"},
    RGB(  0,   0, 128),   // "NAVY"},
    RGB(128,   0, 128),   // "PURPLE"},
    RGB(  0, 128, 128),   // "TEAL"},
    RGB(128, 128, 128),   // "GREY"}, 
    RGB(192, 192, 192),   // "SILVER"},  
    RGB(255,   0, 0),     // "RED"}, 
    RGB(  0, 255, 0),     // "LIME"}, 
    RGB(255, 255, 0),     // "YELLOW"},
    RGB(  0,   0, 255),   // "BLUE"},  
    RGB(255,   0, 255),   // "FUSCHIA"},
    RGB(  0, 255, 255),   // "AQUA"}, 
    RGB(255, 255, 255)    // "WHITE"}    
    };


static TBBUTTON rgtbbutton[] =
{
    { itbFormattingTag, idmFmtTag,
            TBSTATE_ENABLED, TBSTYLE_DROPDOWN, {0}, 0L, -1 },
    { cxButtonSep, 0L,
            TBSTATE_ENABLED, TBSTYLE_SEP, {0}, 0L, -1 },
    { itbFormattingBold, idmFmtBold,
            TBSTATE_ENABLED, TBSTYLE_CHECK, {0}, 0L, -1 },
    { itbFormattingItalic, idmFmtItalic,
            TBSTATE_ENABLED, TBSTYLE_CHECK, {0}, 0L, -1 },
    { itbFormattingUnderline, idmFmtUnderline,
            TBSTATE_ENABLED, TBSTYLE_CHECK, {0}, 0L, -1 },
    { itbFormattingColor, idmFmtColor,
            TBSTATE_ENABLED, TBSTYLE_DROPDOWN, {0}, 0L, -1 },
    { cxButtonSep, 0L,
            TBSTATE_ENABLED, TBSTYLE_SEP, {0}, 0L, -1 },
    { itbFormattingNumbers, idmFmtNumbers,
            TBSTATE_ENABLED, TBSTYLE_CHECK, {0}, 0L, -1 },
    { itbFormattingBullets, idmFmtBullets,
            TBSTATE_ENABLED, TBSTYLE_CHECK, {0}, 0L, -1 },
    { itbFormattingDecreaseIndent, idmFmtDecreaseIndent,
            TBSTATE_ENABLED, TBSTYLE_BUTTON, {0}, 0L, -1 },
    { itbFormattingIncreaseIndent, idmFmtIncreaseIndent,
            TBSTATE_ENABLED, TBSTYLE_BUTTON, {0}, 0L, -1 },
    { cxButtonSep, 0L,
            TBSTATE_ENABLED, TBSTYLE_SEP, {0}, 0L, -1 },
    { itbFormattingLeft, idmFmtLeft,
            TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, {0}, 0L, -1 },
    { itbFormattingCenter, idmFmtCenter,
            TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, {0}, 0L, -1 },
    { itbFormattingRight, idmFmtRight,
            TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, {0}, 0L, -1 },
    { itbFormattingJustify, idmFmtJustify,
            TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, {0}, 0L, -1 },
    { cxButtonSep, 0L,
            TBSTATE_ENABLED, TBSTYLE_SEP, {0}, 0L, -1 },
    { itbFormattingInsertHLine, idmFmtInsertHLine,
            TBSTATE_ENABLED, TBSTYLE_BUTTON, {0}, 0L, -1 },
    { itbFormattingInsertLink, idmEditLink,
            TBSTATE_ENABLED, TBSTYLE_BUTTON, {0}, 0L, -1 },
    { itbFormattingInsertImage, idmInsertImage,
            TBSTATE_ENABLED, TBSTYLE_BUTTON, {0}, 0L, -1 }
};

static TBBUTTON rgtbblkdirbutton[] =
{

    { itbFormattingBlockDirLTR, idmFmtBlockDirLTR,
            TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, {0}, 0L, -1 },
    { itbFormattingBlockDirRTL, idmFmtBlockDirRTL,
            TBSTATE_ENABLED, TBSTYLE_CHECKGROUP, {0}, 0L, -1 },
    { cxButtonSep, 0L,
            TBSTATE_ENABLED, TBSTYLE_SEP, {0}, 0L, -1 }
};            
            
#define ctbbutton           (sizeof(rgtbbutton) / sizeof(TBBUTTON))


/*
 *  p r o t o t y p e s
 */

HRESULT ColorMenu_Show(HMENU hmenuColor, HWND hwndParent, POINT pt, COLORREF *pclrf);
void Color_WMDrawItem(HWND hwnd, LPDRAWITEMSTRUCT pdis);
void Color_WMMeasureItem(HWND hwnd, HDC hdc, LPMEASUREITEMSTRUCT pmis);
INT GetColorIndex(INT rbg);
HFONT hFontGetMenuFont(HWND hwnd);

/*
 *  f u n c t i o n s
 */

CFmtBar::CFmtBar(BOOL fSep)
{
    m_cRef=1;

    m_hwnd = NULL;
    m_hwndToolbar = NULL;
    m_hwndName = NULL;
    m_hwndSize = NULL;

    m_wndprocEdit = NULL;
    m_wndprocNameComboBox = NULL;
    m_wndprocSizeComboBox = NULL;
    m_hbmName = NULL;
    m_hmenuColor = NULL;
    m_hmenuTag = NULL;
    m_fDestroyTagMenu = 1;
    m_pCmdTarget=0;
    m_fVisible = 0;
    m_fSep = !!fSep;
    m_himlHot = NULL;
    m_himl = NULL;
}

CFmtBar::~CFmtBar()
{
    if (m_hbmName)
        DeleteObject(m_hbmName);

    if (m_hmenuColor)
        DestroyMenu(m_hmenuColor);

    if (m_hmenuTag && !!m_fDestroyTagMenu)
        DestroyMenu(m_hmenuTag);

    _FreeImageLists();
}

ULONG CFmtBar::AddRef()
{
    return ++m_cRef;
}

ULONG CFmtBar::Release()
{
    ULONG   cRef=--m_cRef;

    if(m_cRef==0)
        delete this;

    return cRef;
}


HRESULT CreateColorMenu(ULONG idmStart, HMENU* pMenu)
{
    DWORD               irgb;
    DWORD               mniColor;

    if(pMenu == NULL)
        return E_INVALIDARG;

    *pMenu = CreatePopupMenu();

    if (*pMenu == NULL)
        return E_OUTOFMEMORY;

    // Add the COLORREF version of each entry into the menu
    for (irgb = 0, mniColor=idmStart; irgb < sizeof(rgrgbColors)/sizeof(DWORD); ++irgb, ++mniColor)
        AppendMenu(*pMenu, MF_ENABLED|MF_OWNERDRAW, mniColor, (LPCSTR)IntToPtr(MAKEINDEX(irgb, rgrgbColors[irgb])));

    return S_OK;
}




LRESULT CALLBACK CFmtBar::ExtWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    LPFORMATBAR pFmtBar=0;

    if (msg==WM_NCCREATE)
        {
        pFmtBar=(CFmtBar *)((LPCREATESTRUCT)lParam)->lpCreateParams;
        if(!pFmtBar)
            return -1;

        return (pFmtBar->OnNCCreate(hwnd)==S_OK);
        }

    pFmtBar = (LPFORMATBAR)GetWndThisPtr(hwnd);
    if (pFmtBar)
        return pFmtBar->WndProc(hwnd, msg, wParam, lParam);
    else
        return DefWindowProc(hwnd, msg, wParam, lParam);
}

extern BOOL g_fCanEditBiDi;


HRESULT CFmtBar::OnNCCreate(HWND hwnd)
{
    RECT    rc;
    HFONT           hfontOld,
                    hfontToolbar;
    HWND            hwndEdit,
                    hwndToolTips;
    BOOL            fRet;
    HDC             hdc, 
                    hdcParent;
    TEXTMETRIC      tm;
    INT             yPos;
    INT             cxDownButton;
    INT             cxName;
    INT             cxSize,
                    cx;
    INT             cyToolbarButton;
    INT             cyDropDownRollHeight;
    INT             cyExpandedList;
    const POINT     pt = {5, 5};
    LONG            lstyle;
    TOOLINFO        ti;
    
    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)this);
    m_hwnd=hwnd;
    AddRef();

    m_hwndRebar = CreateWindowEx(0, REBARCLASSNAME, NULL,
                        WS_VISIBLE | WS_CHILD | WS_CLIPCHILDREN |
                        WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NOPARENTALIGN,
                        0, 0, 100, 136, m_hwnd, (HMENU) idcCoolbar, g_hInst, NULL);

    if (!m_hwndRebar)
        return E_OUTOFMEMORY;

	SendMessage(m_hwndRebar, RB_SETTEXTCOLOR, 0, (LPARAM)GetSysColor(COLOR_BTNTEXT));
    SendMessage(m_hwndRebar, RB_SETBKCOLOR, 0, (LPARAM)GetSysColor(COLOR_BTNFACE));
    //SendMessage(m_hwndRebar, RB_SETEXTENDEDSTYLE, RBS_EX_OFFICE9, RBS_EX_OFFICE9);
	SendMessage(m_hwndRebar, CCM_SETVERSION, COMCTL32_VERSION, 0);


    // [a-msadek]; Fix for bug#55069
    // DO NOT remove CCS_TOP from creation styles below
    // It is a default style and toolbar WinProc will addit any way durin
    // WM_NCCREATE processing. However, it will cause WM_STYLECHANGING to be sent
    // Due to a bug in SetWindowPos() for a mirrored window, it will never return from seding
    // messages calling a stack overflow
    // No need to put it only for a mirrored window since it will be added any way
    // Look @ comctl32\toolbar.c, functions ToolbarWndProc() and TBAutoSize();
    
    m_hwndToolbar = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, NULL,
                        WS_CHILD|WS_CLIPCHILDREN|WS_VISIBLE|CCS_TOP|CCS_NOPARENTALIGN|CCS_NODIVIDER|
                        TBSTYLE_TOOLTIPS|TBSTYLE_FLAT,
                        0, 0, 0, 0, m_hwndRebar, NULL, 
                        g_hInst, NULL);


    if (!m_hwndToolbar)
        return E_OUTOFMEMORY;

    SendMessage(m_hwndToolbar, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);
    SendMessage(m_hwndToolbar, TB_ADDBUTTONS, (WPARAM)ctbbutton, (LPARAM)rgtbbutton);
    SendMessage(m_hwndToolbar, TB_SETBUTTONSIZE, 0, MAKELONG(dxToolbarButton, dxToolbarButton));

    _SetToolbarBitmaps();

    // add BiDi direction buttons
    if(g_fCanEditBiDi)
    {
        SendMessage(m_hwndToolbar, TB_INSERTBUTTON, ctbbutton - 3, (LPARAM) (LPVOID) &rgtbblkdirbutton[2]);
        SendMessage(m_hwndToolbar, TB_INSERTBUTTON, ctbbutton - 3, (LPARAM) (LPVOID) &rgtbblkdirbutton[1]);
        SendMessage(m_hwndToolbar, TB_INSERTBUTTON, ctbbutton - 3, (LPARAM) (LPVOID) &rgtbblkdirbutton[0]);
        SendMessage(m_hwndToolbar, TB_AUTOSIZE, (WPARAM)0, (LPARAM)0);
    }

    hdcParent = GetDC(GetParent(hwnd));
    if (!hdcParent)
        return E_OUTOFMEMORY;

    hdc = CreateCompatibleDC(hdcParent);
    ReleaseDC(GetParent(hwnd), hdcParent);

    if (!hdc)
        return E_OUTOFMEMORY;

    hfontToolbar = (HFONT) SendMessage(m_hwndToolbar, WM_GETFONT, 0, 0);

    // Get font metrics (of System font) so that we can properly scale the
    // format bar layout
    hfontOld = (HFONT)SelectObject(hdc, hfontToolbar);
    GetTextMetrics(hdc, &tm);
    
    cxDownButton = GetSystemMetrics(SM_CXVSCROLL) + GetSystemMetrics(SM_CXDLGFRAME);
    cxName = (cxDUName * tm.tmAveCharWidth) / 4 + cxDownButton;
    cxSize = XFontSizeCombo(hdc) + cxDownButton;
    SelectObject(hdc, hfontOld);
    DeleteDC(hdc);

    // set the size of the formatbar based on the size of the toolbar plus 2 pixels padding
    GetClientRect(m_hwndToolbar, &rc);
    SetWindowPos(m_hwnd, NULL, 0, 0, rc.right-rc.left, rc.bottom-rc.top + (2*cyToolbarOffset) + (m_fSep?2:0), SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);

    // Determine how tall the buttons are so we can size our other controls
    // accordingly
    SendMessage(m_hwndToolbar, TB_GETITEMRECT, 1, (LPARAM) &rc);
    cyToolbarButton = rc.bottom - rc.top + 1;

    // Figure out size of expanded dropdown lists
    cyExpandedList = CYDROPDOWNEXPANDRATIO * cyToolbarButton;

    // Get the ToolTips window handle
    hwndToolTips = (HWND) SendMessage(m_hwndToolbar, TB_GETTOOLTIPS, 0, 0);

    m_hwndName = CreateWindow(c_szComboBox, NULL,
                                      WS_CHILD | WS_VSCROLL | CBS_DROPDOWN |
                                      CBS_SORT | CBS_HASSTRINGS |
                                      CBS_OWNERDRAWFIXED |WS_VISIBLE,
                                      0, 0, cxName, cyExpandedList,
                                      m_hwndToolbar,
                                      (HMENU) idmFmtFont, g_hLocRes, NULL);

    if (!m_hwndName)
        return E_OUTOFMEMORY;

    ComboBox_SetExtendedUI(m_hwndName, TRUE);

    // Load up the mini-icons for TrueType or Printer font
    m_hbmName = LoadDIBBitmap(idbFormatBarFont);
    if (!m_hbmName)
        return E_OUTOFMEMORY;

    // Compute the right edge of the combobox
    SetWindowFont(m_hwndName, hfontToolbar, TRUE);

    // The Size
    m_hwndSize = CreateWindow(c_szComboBox, NULL,
                                      WS_CHILD | WS_VSCROLL | CBS_DROPDOWNLIST |
                                      WS_VISIBLE,
                                      cxName + cxButtonSep, 0, cxSize, cyExpandedList,
                                      m_hwndToolbar,
                                      (HMENU) idmFmtSize, g_hLocRes, NULL);

    if (!m_hwndSize)
        return E_OUTOFMEMORY;

    m_hwndTT = CreateWindowEx(WS_EX_TOPMOST, TOOLTIPS_CLASS, NULL, 0,
                                CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                                NULL, (HMENU) NULL, g_hInst, NULL);
    if (!m_hwndTT)
        return E_OUTOFMEMORY;

    ZeroMemory(&ti, sizeof(TOOLINFO));
    ti.cbSize = sizeof(TOOLINFO);
    ti.uFlags   = TTF_IDISHWND | TTF_TRANSPARENT | TTF_TRACK | TTF_ABSOLUTE;
    ti.hwnd = m_hwndName;
    ti.uId = (ULONG_PTR)m_hwndName;

    SendMessage(m_hwndTT, TTM_ADDTOOL, 0, (LPARAM)&ti);
    SendMessage(m_hwndTT, WM_SETFONT, (WPARAM)(HFONT)SendMessage(m_hwndToolbar, WM_GETFONT, 0, 0), 0);

    ComboBox_SetExtendedUI(m_hwndSize, TRUE);
    SetWindowFont(m_hwndSize, hfontToolbar, TRUE);
    // font sizes up to 4 digits are allowed
    ComboBox_LimitText(m_hwndSize, SIZETEXTLIMIT);
    // The color popup menu (initially empty)
    // Set the rolled-up heights of the combo boxes to all be the same
    cyDropDownRollHeight = LOWORD(SendMessage(m_hwndSize, CB_GETITEMHEIGHT, (WPARAM)-1, 0));
    // hwndName is ownerdrawn
    SendMessage(m_hwndName, CB_SETITEMHEIGHT, (WPARAM)-1, cyDropDownRollHeight);
    // Determine how tall the toolbar is so we can center the comboboxes
    GetClientRect(m_hwndToolbar, &rc);
    // Get size of toolbar window
    yPos = rc.bottom;
    // Get size of combobox
    GetClientRect(m_hwndSize, &rc);
    yPos = (yPos - rc.bottom) / 2;

    // We have a mirroring bug in GetWindowRect
    // It will give wrong cocordinates causing combos to go outside the screen
    // Ignore y-positioning in this case

    if(!(GetWindowLong(m_hwndToolbar, GWL_EXSTYLE) & WS_EX_LAYOUTRTL))
    {
        GetWindowRect(m_hwndName, &rc);
        MapWindowPoints(NULL, hwnd, (LPPOINT)&rc, 2);
        MoveWindow(m_hwndName, rc.left, yPos, rc.right-rc.left, rc.bottom-rc.top, FALSE);
        GetWindowRect(m_hwndSize, &rc);
        MapWindowPoints(NULL, hwnd, (LPPOINT)&rc, 2);
        MoveWindow(m_hwndSize, rc.left, yPos, rc.right-rc.left, rc.bottom-rc.top, FALSE);
    }
    hwndEdit = ::GetWindow(m_hwndName, GW_CHILD);

    // Add tooltips for the controls we just added
    AddToolTip(hwndToolTips, m_hwndName, idsTTFormattingFont);
    AddToolTip(hwndToolTips, m_hwndSize, idsTTFormattingSize);
    AddToolTip(hwndToolTips, hwndEdit, idsTTFormattingFont);

    // Subclass the comboboxes and their edit controls
    // Do the name edit control first
    m_wndprocEdit = SubclassWindow(hwndEdit, EditSubProc);
    m_wndprocNameComboBox = SubclassWindow(m_hwndName, ComboBoxSubProc);
    m_wndprocSizeComboBox = SubclassWindow(m_hwndSize, ComboBoxSubProc);

    // give the control This pointers
    SetProp(m_hwndName, c_szThis, (LPVOID)this);
    SetProp(m_hwndSize, c_szThis, (LPVOID)this);
    SetProp(hwndEdit, c_szThis, (LPVOID)this);

    GetClientRect(m_hwndToolbar, &rc);

    cx = cxName + cxSize + cxButtonSep * 2;
    REBARBANDINFO   rbbi;

    POINT   ptIdeal = {0};
    SendMessage(m_hwndToolbar, TB_GETIDEALSIZE, FALSE, (LPARAM)&ptIdeal);

    ZeroMemory(&rbbi, sizeof(rbbi));
    rbbi.cbSize     = sizeof(REBARBANDINFO);
    rbbi.fMask      = RBBIM_SIZE | RBBIM_CHILD | RBBIM_CHILDSIZE | RBBIM_IDEALSIZE | RBBIM_STYLE;
	rbbi.fStyle		= RBBS_USECHEVRON;
    rbbi.cx         = 0;
    rbbi.hwndChild  = m_hwndToolbar;
    rbbi.cxMinChild = 0;
    rbbi.cyMinChild = rc.bottom;
    rbbi.cxIdeal    = ptIdeal.x + cx;

    SendMessage(m_hwndRebar, RB_INSERTBAND, (UINT)-1, (LPARAM)(LPREBARBANDINFO)&rbbi);

    // Indent the toolbar buttons for the comboboxes
    SendMessage(m_hwndToolbar, TB_SETINDENT, cx, 0);

    // Load up the names of the fonts and colors
    FillFontNames();
    FillSizes();
    return S_OK;
}


void CFmtBar::OnNCDestroy()
{
    SetWindowLongPtr(m_hwnd, GWLP_USERDATA, 0);
    m_hwnd=0;
    Release();
}

LRESULT CALLBACK CFmtBar::WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
    {
        case WM_DESTROY:
            // unsubclass the windows
            if (m_wndprocEdit)
            {
                SubclassWindow(::GetWindow(m_hwndName, GW_CHILD), m_wndprocEdit);
                RemoveProp(::GetWindow(m_hwndName, GW_CHILD), c_szThis);
            }

            if (m_wndprocNameComboBox)
            {
                SubclassWindow(m_hwndName, m_wndprocNameComboBox);
                RemoveProp(m_hwndName, c_szThis);
            }

            if (m_wndprocSizeComboBox)
            {
                SubclassWindow(m_hwndSize, m_wndprocSizeComboBox);
                RemoveProp(m_hwndSize, c_szThis);
            }
            DestroyWindow(m_hwndTT);
            m_hwndTT=NULL;
            break;

        case WM_NCDESTROY:
            OnNCDestroy();
            break;

        case WM_COMMAND:
            if(OnWMCommand(GET_WM_COMMAND_HWND(wParam, lParam),
                         GET_WM_COMMAND_ID(wParam, lParam),
                         GET_WM_COMMAND_CMD(wParam, lParam))==S_OK)
                return 0;
            break;

        case WM_PAINT:
            if (m_fSep)
                {
                HDC         hdc;
                PAINTSTRUCT ps;
                RECT        rc;                
                
                hdc=BeginPaint(hwnd, &ps);
                if (hdc)
                    {
                    GetClientRect(hwnd, &rc);
                    rc.top = rc.bottom-3;
                    //rc.bottom+=1;
                    DrawEdge(hdc, &rc, BDR_RAISEDOUTER, BF_BOTTOM);
                    EndPaint(hwnd, &ps);
                    }
                return 0;
                }
            break;

        case WM_NOTIFY:
            WMNotify(wParam, (NMHDR*)lParam);
            return 0;

        case WM_SIZE:
            {
            RECT        rc;

            GetClientRect(m_hwndRebar, &rc);

            // resize the width of the toolbar
            if(rc.right != (INT)LOWORD(lParam))
                SetWindowPos(m_hwndRebar, NULL, 0, cyToolbarOffset, LOWORD(lParam), HIWORD(lParam), SWP_NOZORDER|SWP_NOACTIVATE);
            }
            break;

        case WM_DRAWITEM:
            OnDrawItem((LPDRAWITEMSTRUCT)lParam);
            break;

        case WM_SYSCOLORCHANGE:
            _SetToolbarBitmaps();
            UpdateRebarBandColors(m_hwndRebar);
            // fall thro'

        case WM_WININICHANGE:
        case WM_DISPLAYCHANGE:
        case WM_QUERYNEWPALETTE:
        case WM_PALETTECHANGED:
            SendMessage(m_hwndRebar, msg, wParam, lParam);
            break;


        case WM_MEASUREITEM:
            OnMeasureItem((LPMEASUREITEMSTRUCT)lParam);
            break;
    }

    return DefWindowProc(hwnd, msg, wParam, lParam);
}

HRESULT CFmtBar::Init(HWND hwndParent, int idDlgItem)
{
    // stuff these values. We don't create the formatbar until the first call to Show()
    // to allow better perf.
    m_hwndParent = hwndParent;
    m_idd = idDlgItem;
    return S_OK;
}



// displays the colorpopup menu at the specified point. if clrf if NULL, then no clrf is returned
// but instead the appropriate WM_COMMAND is dispatched to the parent window
HRESULT ColorMenu_Show(HMENU hmenuColor, HWND hwndParent, POINT pt, COLORREF *pclrf)
{
    HRESULT     hr=NOERROR;
    int         tpm=TPM_LEFTALIGN|TPM_LEFTBUTTON;

    if(hmenuColor == NULL)
        return E_INVALIDARG;

    if(pclrf)
         tpm|=TPM_RETURNCMD;

    int id = TrackPopupMenu(hmenuColor, tpm,pt.x, pt.y, 0, hwndParent, NULL);

    switch(id)
        {
        case 1:
            return NOERROR;
        case 0:
            return E_FAIL;
        case -1:
            return MIMEEDIT_E_USERCANCEL;

        case idmFmtColor1:
        case idmFmtColor2:
        case idmFmtColor3:
        case idmFmtColor4:
        case idmFmtColor5:
        case idmFmtColor6:
        case idmFmtColor7:
        case idmFmtColor8:
        case idmFmtColor9:
        case idmFmtColor10:
        case idmFmtColor11:
        case idmFmtColor12:
        case idmFmtColor13:
        case idmFmtColor14:
        case idmFmtColor15:
        case idmFmtColor16:
            AssertSz(pclrf, "this HAS to be set to get this id back...");
            *pclrf=rgrgbColors[id-idmFmtColor1];
            return NOERROR;

        default:
            AssertSz(0, "unexpected return from TrackPopupMenu");
        }

    return E_FAIL;
}

HRESULT CFmtBar::CheckColor()
{
    HRESULT     hr=E_FAIL;
    INT         iFound = -1, irgb;
    VARIANTARG  va;

    if (!m_pCmdTarget)
        return E_FAIL;

    va.vt = VT_I4;
    va.lVal = -1;
    hr = m_pCmdTarget->Exec(&CMDSETID_Forms3,
                       IDM_FORECOLOR,
                       MSOCMDEXECOPT_DONTPROMPTUSER,
                       NULL, &va);
    if(FAILED(hr))
        goto error;

    if(va.lVal == -1)
        goto error;

    iFound = GetColorIndex(va.lVal);

error:
    CheckMenuRadioItem(m_hmenuColor, idmFmtColor1, idmFmtColor16, idmFmtColor1+iFound, MF_BYCOMMAND);
    return hr;
}


INT GetColorIndex(INT rbg)
{
    INT iFound = -1;

    for (int irgb = 1; irgb < sizeof(rgrgbColors)/sizeof(DWORD); ++irgb)
        if  ((rbg&0x00ffffff) == (LONG)rgrgbColors[irgb])
            {
            iFound = irgb;
            break;
            }
    return iFound;
}



HRESULT CFmtBar::HrInitTagMenu()
{
    HRESULT     hr=NOERROR;
    int         id;
    int         tpm=TPM_LEFTALIGN|TPM_LEFTBUTTON;
    VARIANTARG  va;
    VARIANTARG  *pvaIn=0;
    TCHAR szBufMenu[MAX_PATH] = {0};
    TCHAR szBufTag[MAX_PATH] = {0};

    if (!m_pCmdTarget)
        return E_FAIL;

    if (!m_hmenuTag && 
        FAILED(HrCreateTridentMenu(m_pCmdTarget, TM_TAGMENU, idmFmtTagFirst, idmFmtTagLast-idmFmtTagFirst, &m_hmenuTag)))
        return E_FAIL;

    hr = HrCheckTridentMenu(m_pCmdTarget, TM_TAGMENU, idmFmtTagFirst, idmFmtTagLast, m_hmenuTag);

    return hr;
}


HRESULT CFmtBar::HrShowTagMenu(POINT pt)
{
    HRESULT hr;
    int     tpm=TPM_LEFTALIGN|TPM_LEFTBUTTON;

    hr = HrInitTagMenu();
    if(FAILED(hr))
        return hr;

    TrackPopupMenu(m_hmenuTag, tpm, pt.x, pt.y, 0, m_hwnd, NULL);

    return hr;
}

HMENU CFmtBar::hmenuGetStyleTagMenu()
{
    HRESULT hr;

    hr = HrInitTagMenu();
    if(FAILED(hr))
        return NULL;

    m_fDestroyTagMenu = 0;
    return m_hmenuTag;
}


// update toolbar buttons and font name/size combo boxes.
HRESULT CFmtBar::Update()
{
    UINT        uCmdID=0;
    CHAR        szBuf[COMBOBUFSIZE/2];
    CHAR        szBufbstrVal[COMBOBUFSIZE/2];
    int         i;
    INT         iPointSize=0, iHTMLSize=0;
    HWND        hwndEdit;
    OLECMD  rgCmds[]= {
                        {IDM_FONTNAME, 0},
                        {IDM_FONTSIZE, 0},
                        {IDM_FORECOLOR, 0},
                        {IDM_BOLD, 0},
                        {IDM_ITALIC, 0},
                        {IDM_UNDERLINE, 0},
                        {IDM_ORDERLIST, 0},
                        {IDM_UNORDERLIST, 0},
                        {IDM_JUSTIFYLEFT, 0},
                        {IDM_JUSTIFYRIGHT, 0},
                        {IDM_JUSTIFYCENTER, 0},
                        {IDM_JUSTIFYFULL, 0},
                        {IDM_BLOCKDIRLTR, 0},
                        {IDM_BLOCKDIRRTL, 0},                        
                        {IDM_OUTDENT, 0},
                        {IDM_INDENT, 0},
                        {IDM_HORIZONTALLINE, 0},
                        {IDM_HYPERLINK, 0},
                        {IDM_IMAGE, 0},
                        {IDM_BLOCKFMT, 0}};

    int     rgidm[] = { 0,
                        0,
                        idmFmtColor,
                        idmFmtBold,
                        idmFmtItalic,
                        idmFmtUnderline,
                        idmFmtNumbers,
                        idmFmtBullets,
                        idmFmtLeft,
                        idmFmtRight,
                        idmFmtCenter,
                        idmFmtJustify,
                        idmFmtBlockDirLTR,
                        idmFmtBlockDirRTL,
                        idmFmtDecreaseIndent,
                        idmFmtIncreaseIndent,
                        idmFmtInsertHLine,
                        idmEditLink,
                        idmInsertImage,
                        idmFmtTag};

    ULONG   uState;
    BOOL    fUIActive;

    if (!m_hwnd)        // no UI visible yet
        return S_OK;

    if (!m_pCmdTarget)
    {
        EnableWindow(m_hwndName, FALSE);
        EnableWindow(m_hwndSize, FALSE);
        
        for (i=2; i<sizeof(rgCmds)/sizeof(OLECMD); i++)
            SendMessage(m_hwndToolbar, TB_SETSTATE, rgidm[i], MAKELONG(0, 0));
        return S_OK;
    }

    HWND hwndFocus = GetFocus();

    if (m_hwndToolbar == hwndFocus ||
       (hwndFocus && m_hwndToolbar==GetParent(hwndFocus)) ||
       (hwndFocus && GetParent(hwndFocus) && m_hwndToolbar==GetParent(GetParent(hwndFocus))) )
        return S_OK;

    fUIActive = FBodyHasFocus();
    
    if (fUIActive)
        m_pCmdTarget->QueryStatus(&CMDSETID_Forms3, sizeof(rgCmds)/sizeof(OLECMD), rgCmds, NULL);
    
    EnableWindow(m_hwndName, fUIActive  && (rgCmds[0].cmdf&OLECMDF_ENABLED));
    EnableWindow(m_hwndSize, fUIActive  && (rgCmds[1].cmdf&OLECMDF_ENABLED));
    
    for (i=2; i<sizeof(rgCmds)/sizeof(OLECMD); i++)
    {
        uState=(rgCmds[i].cmdf&OLECMDF_LATCHED ? TBSTATE_PRESSED: 0)|
            (rgCmds[i].cmdf&OLECMDF_ENABLED ? TBSTATE_ENABLED: 0);
        SendMessage(m_hwndToolbar, TB_SETSTATE, rgidm[i], MAKELONG(uState, 0));
    }

    if (!fUIActive)
        return S_OK;

    // update font name combo box
    VARIANTARG  va;
    va.vt = VT_BSTR;
    va.bstrVal = NULL;
    
    if (m_pCmdTarget->Exec(&CMDSETID_Forms3, IDM_FONTNAME, MSOCMDEXECOPT_DONTPROMPTUSER, NULL, &va) == S_OK)
    {
        hwndEdit = ::GetWindow(m_hwndName, GW_CHILD);
        if (va.vt == VT_BSTR)
        {
            *szBuf = 0;
            *szBufbstrVal = 0;

            // we have a font-name, let's see if we need to update
            ComboBox_GetText(hwndEdit, szBuf, COMBOBUFSIZE/2);
            WideCharToMultiByte(CP_ACP, 0, (WCHAR*)va.bstrVal, -1, szBufbstrVal, COMBOBUFSIZE/2, NULL, NULL);
            
            if (StrCmpI(szBufbstrVal, szBuf) != 0)
            {
                if(ComboBox_SelectString(m_hwndName, -1, szBufbstrVal) == -1)
                    ComboBox_SetText(hwndEdit, szBufbstrVal);
            }
            
            SafeSysFreeString(va.bstrVal);
        }
        else
            ComboBox_SetText(hwndEdit, "");
    }


    // update font size combo box
    va.vt = VT_I4;
    va.lVal = 0;
    
    if (m_pCmdTarget->Exec(&CMDSETID_Forms3, IDM_FONTSIZE, MSOCMDEXECOPT_DONTPROMPTUSER, NULL, &va)==S_OK && 
        va.vt == VT_I4)
    {
        // font size if returned in the 1 to 7 range, for I4
        // see if the font size has changed
        *szBuf = 0;

        if(ComboBox_GetText(m_hwndSize, szBuf, sizeof(szBuf)))
        {
            iPointSize = StrToInt(szBuf);
            Assert(iPointSize>=8 && iPointSize<=36);
            iHTMLSize = PointSizeToHTMLSize(iPointSize);
        }

        if(iHTMLSize != va.lVal)
            ComboBox_SetCurSel(m_hwndSize, va.lVal-1);
    }
    else
        ComboBox_SetCurSel(m_hwndSize, -1);

    return S_OK;
}

HRESULT CFmtBar::OnWMCommand(HWND hwnd, int id, WORD wCmd)
{
    UINT        uCmdID=0;
    VARIANTARG  va;
    VARIANTARG  *pvaIn=0;
    HRESULT     hr = S_FALSE;
    DWORD       dwOpt=MSOCMDEXECOPT_DONTPROMPTUSER;
    TOOLINFO    ti;

    ZeroMemory(&va, sizeof(va));

    switch(wCmd)
        {
        case CBN_SELENDCANCEL:
            // clear the tooltip
            ZeroMemory(&ti, sizeof(TOOLINFO));
            ti.cbSize = sizeof(TOOLINFO);
            ti.hwnd = m_hwndName;
            ti.uId = (ULONG_PTR)m_hwndName;

            SendMessage(m_hwndTT, TTM_TRACKACTIVATE, FALSE, (LPARAM) &ti);
            break;

        case CBN_SELENDOK:
            {
            CHAR                szBuf[COMBOBUFSIZE];
            UINT                uSel;

            // clear the tooltip
            ZeroMemory(&ti, sizeof(TOOLINFO));
            ti.cbSize = sizeof(TOOLINFO);
            ti.hwnd = m_hwndName;
            ti.uId = (ULONG_PTR)m_hwndName;

            SendMessage(m_hwndTT, TTM_TRACKACTIVATE, FALSE, (LPARAM) &ti);

            if(idmFmtFont == id)
            {
                uCmdID = IDM_FONTNAME;

                uSel = ComboBox_GetCurSel(m_hwndName);
//                if(uSel < 0)
//                    return hr;

                ComboBox_GetLBText(m_hwndName, uSel, szBuf);
            
                va.vt = VT_BSTR;
                pvaIn = &va;
                hr=HrLPSZToBSTR(szBuf, &va.bstrVal);
                if (FAILED(hr))
                    goto Cleanup;
            }
            else if(idmFmtSize == id)
            {
                // when setting font size use:
                // VT_I4: for 1 - 7 range
                // VT_STRING: for -2 -> +4 range.
                uCmdID = IDM_FONTSIZE;
                uSel = ComboBox_GetCurSel(m_hwndSize);
                if(-1 == uSel)
                   return hr;
                va.vt = VT_I4;
                va.lVal = uSel + 1;
                pvaIn = &va;
            }
        
            // set focus back to Trident, call HrUIActivate() after ComboBox operations.
            SetBodyFocus();
        
            hr = ExecCommand(uCmdID, dwOpt, pvaIn);
            if(FAILED(hr))
                goto Cleanup;

    Cleanup:
            if(va.vt == VT_BSTR && va.bstrVal != NULL)
               SysFreeString(va.bstrVal);

            return hr;
            }
        }

    switch(id)
        {
        case idmFmtBold:
            uCmdID=IDM_BOLD;
            break;

        case idmFmtItalic:
           uCmdID=IDM_ITALIC;
           break;

        case idmFmtUnderline:
            uCmdID=IDM_UNDERLINE;
            break;

        case idmAccelBullets:
        case idmFmtBullets:
            uCmdID=IDM_UNORDERLIST;
            break;

        case idmFmtNumbers:
            uCmdID=IDM_ORDERLIST;
            break;

        case idmAccelJustify:
        case idmFmtJustify:
            uCmdID=IDM_JUSTIFYFULL;
            break;

        case idmAccelLeft:
        case idmFmtLeft:
            uCmdID=IDM_JUSTIFYLEFT;
            break;

        case idmAccelCenter:
        case idmFmtCenter:
            uCmdID=IDM_JUSTIFYCENTER;
            break;

        case idmAccelRight:
        case idmFmtRight:
            uCmdID=IDM_JUSTIFYRIGHT;
            break;

        case idmFmtBlockDirLTR:
            uCmdID=IDM_BLOCKDIRLTR;
            break;

        case idmFmtBlockDirRTL:
            uCmdID=IDM_BLOCKDIRRTL;
            break;
            
        case idmAccelDecreaseIndent:
        case idmFmtDecreaseIndent:
            uCmdID=IDM_OUTDENT;

            break;

        case idmAccelIncreaseIndent:
        case idmFmtIncreaseIndent:
            uCmdID=IDM_INDENT;
            break;

        case idmEditLink:
            uCmdID=IDM_HYPERLINK;
            dwOpt = MSOCMDEXECOPT_PROMPTUSER;
            break;

        case idmUnInsertLink:
            uCmdID=IDM_UNLINK;
            break;

        case idmFmtInsertHLine:
            uCmdID=IDM_HORIZONTALLINE;
            break;

        case idmInsertImage:
            uCmdID=IDM_IMAGE;
            dwOpt = MSOCMDEXECOPT_PROMPTUSER;
            break;

        case idmFmtColor1:
        case idmFmtColor2:
        case idmFmtColor3:
        case idmFmtColor4:
        case idmFmtColor5:
        case idmFmtColor6:
        case idmFmtColor7:
        case idmFmtColor8:
        case idmFmtColor9:
        case idmFmtColor10:
        case idmFmtColor11:
        case idmFmtColor12:
        case idmFmtColor13:
        case idmFmtColor14:
        case idmFmtColor15:
        case idmFmtColor16:
            {
            uCmdID  = IDM_FORECOLOR;
            va.vt   = VT_I4;
            va.lVal = rgrgbColors[id-idmFmtColor1];
            pvaIn   = &va;
            break;
            }
        }


    if(id >= idmFmtTagFirst && id <= idmFmtTagLast) //style tags
        {
        TCHAR szBuf[MAX_PATH] = {0};
        GetMenuString(m_hmenuTag, id, szBuf, MAX_PATH, MF_BYCOMMAND);
        Assert(*szBuf);//should not be empty

        hr=HrLPSZToBSTR(szBuf, &va.bstrVal);
        if (FAILED(hr))
            goto error;

        va.vt      = VT_BSTR;
        pvaIn      = &va;
        uCmdID = IDM_BLOCKFMT;
        }

    if(0 != uCmdID && m_pCmdTarget)
        {
        hr = ExecCommand(uCmdID, dwOpt, pvaIn);
        if(FAILED(hr))
            goto error;
        }

error:
    if(va.vt == VT_BSTR && va.bstrVal != NULL)
       SysFreeString(va.bstrVal);

    return hr;

}

HRESULT CFmtBar::ExecCommand(UINT uCmdID, DWORD dwOpt, VARIANTARG  *pvaIn)
{
    HRESULT hr = S_FALSE;

    if(uCmdID && m_pCmdTarget)
        hr = m_pCmdTarget->Exec(&CMDSETID_Forms3,
                             uCmdID,
                             dwOpt,
                             pvaIn, NULL);
    return hr;

}

HRESULT CFmtBar::SetCommandTarget(LPOLECOMMANDTARGET pCmdTarget)
{
    // ALERT: we don't refcount these to avoid circular counts
    // as this poitner is valid during the lifetime of the formatbar
    m_pCmdTarget=pCmdTarget;
    return NOERROR;
}

HRESULT HrCreateFormatBar(HWND hwndParent, int iddlg, BOOL fSep, LPFORMATBAR *ppFmtBar)
{
    LPFORMATBAR pFmtBar=0;
    HRESULT     hr;

    if(!ppFmtBar)
        return E_INVALIDARG;

    *ppFmtBar=NULL;

    if(!(pFmtBar=new CFmtBar(fSep)))
        return E_OUTOFMEMORY;

    hr=pFmtBar->Init(hwndParent, iddlg);
    if(FAILED(hr))
        goto error;

    *ppFmtBar=pFmtBar;
    pFmtBar->AddRef();

error:
    ReleaseObj(pFmtBar);
    return hr;
}

void CFmtBar::WMNotify(WPARAM wParam, NMHDR* pnmhdr)
{

    LPNMREBARCHEVRON pnmch;

    if (pnmhdr->idFrom == idcCoolbar)
    {
        switch (pnmhdr->code)
        {

            case RBN_CHEVRONPUSHED:
            {                    
                ITrackShellMenu* ptsm;                   
                CoCreateInstance(CLSID_TrackShellMenu, NULL, CLSCTX_INPROC_SERVER, IID_ITrackShellMenu, 
                    (LPVOID*)&ptsm);
                if (!ptsm)
                    break;

                ptsm->Initialize(0, 0, 0, SMINIT_TOPLEVEL|SMINIT_VERTICAL);
            
                LPNMREBARCHEVRON pnmch = (LPNMREBARCHEVRON) pnmhdr;                                        
                ptsm->SetObscured(m_hwndToolbar, NULL, SMSET_TOP);
            
                MapWindowPoints(m_hwndRebar, HWND_DESKTOP, (LPPOINT)&pnmch->rc, 2);                  
                POINTL pt = {pnmch->rc.left, pnmch->rc.right};                   
                ptsm->Popup(m_hwndRebar, &pt, (RECTL*)&pnmch->rc, MPPF_BOTTOM);            
                ptsm->Release();                  
                break;      
            }

        }
    }


    switch(pnmhdr->code)
    {
        case TBN_DROPDOWN:
            {
            RECT    rc;
            POINT   pt;
            LPTBNOTIFY pTBN = (LPTBNOTIFY) pnmhdr;

            if(pTBN->iItem == idmFmtColor)
                SendMessage(m_hwndToolbar, TB_GETITEMRECT, 5, (LPARAM) &rc);
            else if(pTBN->iItem == idmFmtTag)
                SendMessage(m_hwndToolbar, TB_GETITEMRECT, 1, (LPARAM) &rc);

            MapWindowPoints(m_hwndToolbar, NULL, (LPPOINT)&rc, 2);
            pt.x=(GetWindowLong(m_hwndToolbar, GWL_EXSTYLE) & WS_EX_LAYOUTRTL) ?rc.right : rc.left;
            pt.y=rc.bottom+2;

            if(pTBN->iItem == idmFmtColor)
                {
                CheckColor();
                ColorMenu_Show(m_hmenuColor, m_hwnd, pt, NULL);
                }
            else 
                if(pTBN->iItem == idmFmtTag)
                    HrShowTagMenu(pt);
            }
            break;

        case TTN_NEEDTEXT:
            ProcessTooltips((LPTOOLTIPTEXTOE) pnmhdr);
            break;

    }

}


void CFmtBar::OnDrawItem(LPDRAWITEMSTRUCT pdis)
{
    switch(pdis->CtlType)
    {
    case ODT_MENU:
        Color_WMDrawItem(m_hwnd, pdis);
        break;

    case ODT_COMBOBOX:
        ComboBox_WMDrawItem(pdis);
        break;

    default:
        AssertSz(0, "OwnerDraw type not supported");
    }
}


void CFmtBar::OnMeasureItem(LPMEASUREITEMSTRUCT pmis)
{
    HDC         hdc;
    HFONT       hfontOld;
    TEXTMETRIC  tm;
        
    hdc = GetDC(m_hwnd);
    if(hdc)
        {
        switch(pmis->CtlType)
            {
            case ODT_MENU:
                Color_WMMeasureItem(m_hwnd, hdc, pmis);
                break;
            
            case ODT_COMBOBOX:
                hfontOld = (HFONT)SelectObject(hdc, (HFONT)SendMessage(m_hwndToolbar, WM_GETFONT, 0, 0));
                GetTextMetrics(hdc, &tm);
                SelectObject(hdc, hfontOld);
                pmis->itemHeight = tm.tmHeight;
                break;
            
            default:
                AssertSz(0, "OwnerDraw type not supported");
            }
        
        ReleaseDC(m_hwnd, hdc);
        }
}

void Color_WMMeasureItem(HWND hwnd, HDC hdc, LPMEASUREITEMSTRUCT pmis)
{
    HFONT       hfontOld;
    TEXTMETRIC  tm;
    UINT        id = pmis->itemID;
    TCHAR       szColor[MAX_PATH]={0};

    Assert (pmis->CtlType == ODT_MENU);

    
    hfontOld = (HFONT)SelectObject(hdc, hFontGetMenuFont(hwnd));
    GetTextMetrics(hdc, &tm);
    SelectObject(hdc, hfontOld);

    ULONG index = GETINDEX(pmis->itemData);
    LoadString(g_hLocRes, index + idsColor1,
                       szColor, sizeof(szColor)/sizeof(TCHAR));

    pmis->itemHeight = tm.tmHeight;
    pmis->itemWidth = GetSystemMetrics(SM_CXMENUCHECK) +
                      2 * GetSystemMetrics(SM_CXBORDER) + 
                      2 * tm.tmHeight +
                      (lstrlen(szColor) + 2) *tm.tmAveCharWidth;
}

// fill font name combo box
void CFmtBar::FillFontNames()
{
    LOGFONT lf = {0};
    HDC hdc;

    // reset the contents of the combo
    SendMessage(m_hwndName, CB_RESETCONTENT, 0, 0);

    hdc = GetDC(NULL);
    if (hdc)
    {
        //to enumerate all styles of all fonts for the default character set
        lf.lfFaceName[0] = '\0';
        lf.lfCharSet = DEFAULT_CHARSET;

        EnumFontFamiliesEx(hdc, &lf, (FONTENUMPROC)ExtEnumFontNamesProcEx, (LPARAM)this, 0);
        ReleaseDC(NULL, hdc);
    }
}


LRESULT CALLBACK CFmtBar::EditSubProc(HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    CHAR    szBuf[TEMPBUFSIZE];
    HWND    hwndCombo = GetParent(hwnd);
    LPFORMATBAR pFmtBar = NULL;

    if(hwndCombo == NULL)
    {
        AssertSz(0, "This is bad");
        return 0;
    }

    pFmtBar = (LPFORMATBAR)GetProp(hwnd, c_szThis);
    if(pFmtBar == NULL)
    {
        AssertSz(0, "This is bad");
        return 0;
    }

    *szBuf = 0;

    switch (wMsg)
    {
    case WM_KEYDOWN:
        switch(wParam)
        {
        case VK_ESCAPE:
            pFmtBar->SetBodyFocus();
            return 0;

        case VK_RETURN:
            if (!SendMessage(pFmtBar->m_hwndName, CB_GETDROPPEDSTATE, 0, 0))
            {
                ComboBox_GetText(hwnd, szBuf, sizeof(szBuf));
                ComboBox_SelectString(pFmtBar->m_hwndName, -1, szBuf);
                SendMessage(pFmtBar->m_hwnd, WM_COMMAND, (WPARAM)MAKELONG(idmFmtFont, CBN_SELENDOK), (LPARAM)pFmtBar->m_hwndName);
                return 0;
            }
        }

        break;

    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_MOUSEMOVE:
        {
        MSG msg;

        msg.lParam = lParam;
        msg.wParam = wParam;
        msg.message = wMsg;
        msg.hwnd = hwnd;

        SendMessage((HWND)SendMessage(pFmtBar->m_hwndToolbar, TB_GETTOOLTIPS, 0, 0), TTM_RELAYEVENT, 0, (LPARAM) &msg);
        }
        break;
    }

    return CallWindowProc(pFmtBar->m_wndprocEdit, hwnd, wMsg, wParam, lParam);
}

LRESULT CALLBACK CFmtBar::ComboBoxSubProc(HWND hwnd, UINT wMsg, WPARAM wParam,
                                                                        LPARAM lParam)
{
    INT                             nID = GetWindowID(hwnd);
    WNDPROC                         wndprocNext;
    LPFORMATBAR pFmtBar = NULL;

    pFmtBar = (LPFORMATBAR)GetProp(hwnd, c_szThis);
    if(pFmtBar == NULL)
    {
        AssertSz(0, "This is bad");
        return 0;
    }

    
    switch (wMsg)
    {
    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_MOUSEMOVE:
        {
          MSG msg;

          msg.lParam = lParam;
          msg.wParam = wParam;
          msg.message = wMsg;
          msg.hwnd = hwnd;

            SendMessage((HWND)SendMessage(pFmtBar->m_hwndToolbar, TB_GETTOOLTIPS, 0, 0), TTM_RELAYEVENT, 0, (LPARAM) &msg);
        }
         break;
    }

    if (nID == idmFmtFont)
        wndprocNext = pFmtBar->m_wndprocNameComboBox;
    else
        wndprocNext = pFmtBar->m_wndprocSizeComboBox;
    return wndprocNext ? CallWindowProc(wndprocNext, hwnd, wMsg, wParam, lParam) : 0;
}


INT CALLBACK CFmtBar::ExtEnumFontNamesProcEx(ENUMLOGFONTEX *plf, NEWTEXTMETRICEX *ptm, INT nFontType, LPARAM lParam)
{
    return ((CFmtBar *)lParam)->EnumFontNamesProcEx(plf, ptm, nFontType);
}

INT CFmtBar::EnumFontNamesProcEx(ENUMLOGFONTEX *plf, NEWTEXTMETRICEX *ptm, INT nFontType)
{
    CFmtBar     *pFmtBar;
    LONG        l;

    // skip vertical fonts for OE
    if (plf->elfLogFont.lfFaceName[0]=='@')
        return TRUE;

    // if the font is already listed, don't re-list it
    if(ComboBox_FindStringExact(m_hwndName, -1, plf->elfLogFont.lfFaceName) != -1)
        return TRUE;

    l = ComboBox_AddString(m_hwndName, plf->elfLogFont.lfFaceName);
    if (l!=-1)
        ComboBox_SetItemData(m_hwndName, l, nFontType);

    return TRUE;
}

INT CFmtBar::XFontSizeCombo(HDC hdc)
{
    LONG                id;
    TCHAR               szBuf[TEMPBUFSIZE];
    *szBuf = 0;
    INT                 iMax=0;
    SIZE                rSize;

    for(id = idsFontSize0; id < NFONTSIZES + idsFontSize0; ++id)
        {
        LoadString(g_hLocRes, id, szBuf, sizeof(szBuf));
        GetTextExtentPoint32 (hdc, szBuf, lstrlen(szBuf), &rSize);
        if(rSize.cx > iMax)
            iMax = rSize.cx;
        }
    return iMax + 10;
}

void CFmtBar::FillSizes()
{
    LONG                            id;
    TCHAR                           szBuf[TEMPBUFSIZE];
    *szBuf = 0;
    LRESULT                         lr;

    // Empty the current list
    SendMessage(m_hwndSize, CB_RESETCONTENT, 0, 0);

    for (id = idsFontSize0; id < NFONTSIZES + idsFontSize0; ++id)
        {
        LoadString(g_hLocRes, id, szBuf, sizeof(szBuf));
        lr = SendMessage(m_hwndSize, CB_ADDSTRING, 0, (LPARAM) szBuf);
        if (lr == CB_ERR || lr == CB_ERRSPACE)
           break;
        }

}

#define BACKGROUND              0x000000FF      // bright blue
#define BACKGROUNDSEL   0x00FF00FF      // bright blue
DWORD CFmtBar::FlipColor(DWORD rgb)
{
    return RGB(GetBValue(rgb), GetGValue(rgb), GetRValue(rgb));
}

// load bitmap for true type font
HBITMAP CFmtBar::LoadDIBBitmap(int id)
{
    HDC                                     hdc;
    HRSRC                           h;
    DWORD FAR *                     p;
    LPSTR                           lpBits;
    HANDLE                          hRes;
    LPBITMAPINFOHEADER      lpBitmapInfo;
    LPVOID                          lpRes;
    DWORD                           cbRes;
    int                                     numcolors;
    DWORD                           rgbSelected;
    DWORD                           rgbUnselected;
    HBITMAP                         hbm;

    rgbSelected = FlipColor(GetSysColor(COLOR_HIGHLIGHT));
    rgbUnselected = FlipColor(GetSysColor(COLOR_WINDOW));

    h = FindResource(g_hLocRes, MAKEINTRESOURCE(id), RT_BITMAP);
    hRes = LoadResource(g_hLocRes, h);

    /* Lock the bitmap and get a pointer to the color table. */
    lpRes = LockResource(hRes);

    if (!lpRes)
            return NULL;

    /* Copy the resource since we shouldn't modify the original */
    cbRes = SizeofResource(g_hLocRes, h);
    if(!MemAlloc((LPVOID *)&lpBitmapInfo, LOWORD(cbRes)))
            return NULL;
    CopyMemory(lpBitmapInfo, lpRes, cbRes);

    p = (DWORD FAR *)((LPSTR)(lpBitmapInfo) + lpBitmapInfo->biSize);

    /* Search for the Solid Blue entry and replace it with the current
     * background RGB.
    */
    numcolors = 16;

    while (numcolors-- > 0)
    {
       if (*p == BACKGROUND)
           *p = rgbUnselected;
       else if (*p == BACKGROUNDSEL)
           *p = rgbSelected;
       p++;
    }

    /* First skip over the header structure */
    lpBits = (LPSTR)(lpBitmapInfo + 1);

    /* Skip the color table entries, if any */
    lpBits += (1 << (lpBitmapInfo->biBitCount)) * sizeof(RGBQUAD);

    /* Create a color bitmap compatible with the display device */
    hdc = GetDC(NULL);
    hbm = CreateDIBitmap(hdc, lpBitmapInfo, (DWORD)CBM_INIT, lpBits,
                                             (LPBITMAPINFO)lpBitmapInfo, DIB_RGB_COLORS);
    ReleaseDC(NULL, hdc);

    SafeMemFree(lpBitmapInfo);
    FreeResource(hRes);

    return hbm;
}

VOID CFmtBar::AddToolTip(HWND hwndToolTips, HWND hwnd, UINT idRsrc)
{
    TOOLINFO        ti = { 0 };

    ti.cbSize = sizeof(TOOLINFO);
    ti.uFlags = TTF_IDISHWND;

    ti.hwnd = hwnd;
    ti.uId = (UINT_PTR) hwnd;
    GetWindowRect(hwnd, &ti.rect);
    ti.hinst = g_hLocRes;
    ti.lpszText = (LPSTR) IntToPtr(idRsrc);

    SendMessage(hwndToolTips, TTM_ADDTOOL, 0, (LPARAM) &ti);
}


HRESULT CFmtBar::TranslateAcclerator(LPMSG lpMsg)
{
    HWND    hwndFocus;

    if (m_hwnd && 
        lpMsg->message==WM_KEYDOWN &&
        ((lpMsg->wParam==VK_RETURN || lpMsg->wParam==VK_ESCAPE)))
        {
        hwndFocus=GetFocus();

        // if focus is on the size combolist or in the edit of the
        // name combobox, then we translate the messages to the window.
        if(hwndFocus==::GetWindow(m_hwndName, GW_CHILD) || 
            hwndFocus==m_hwndSize)
            {
            TranslateMessage(lpMsg);
            DispatchMessage(lpMsg);
            return S_OK;
            }
        }

    return S_FALSE;
}

BOOL CFmtBar::FBodyHasFocus()
{
    NMHDR   nmhdr;

    nmhdr.hwndFrom=m_hwnd;
    nmhdr.idFrom=GetDlgCtrlID(m_hwnd);
    nmhdr.code=FBN_BODYHASFOCUS;

    return (0 != SendMessage(GetParent(m_hwnd), WM_NOTIFY, nmhdr.idFrom, (LPARAM)&nmhdr));
}

void CFmtBar::SetBodyFocus()
{
    NMHDR   nmhdr;

    nmhdr.hwndFrom=m_hwnd;
    nmhdr.idFrom=GetDlgCtrlID(m_hwnd);
    nmhdr.code=FBN_BODYSETFOCUS;

    SendMessage(GetParent(m_hwnd), WM_NOTIFY, nmhdr.idFrom, (LPARAM)&nmhdr);
}



void CFmtBar::ComboBox_WMDrawItem(LPDRAWITEMSTRUCT pdis)
{
    HDC     hdc, 
            hdcMem;
    DWORD   rgbBack, rgbText;
    char    szFace[LF_FACESIZE + 10];
    HBITMAP hbmOld;
    int     dy, 
            x;
    INT     nFontType = (INT) pdis->itemData;
    SIZE    size;
    TOOLINFO    ti;
    RECT        rc;
    
    Assert(pdis->CtlID == idmFmtFont);
    hdc = pdis->hDC;

    if (pdis->itemState & ODS_SELECTED)
        {
        rgbBack = SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
        rgbText = SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
        }
    else
        {
        rgbBack = SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
        rgbText = SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
        }

    SendMessage(pdis->hwndItem, CB_GETLBTEXT, pdis->itemID,
                            (LPARAM)(LPSTR)szFace);
    ExtTextOut(hdc, pdis->rcItem.left + dxFormatFontBitmap,
                       pdis->rcItem.top, ETO_OPAQUE, &pdis->rcItem,
                       szFace, lstrlen(szFace), NULL);

    // if selected, see if it is clipped, so that we know to show a tooltip
    if ((pdis->itemState & ODS_SELECTED) && 
        GetTextExtentPoint32(hdc, szFace, lstrlen(szFace), &size) && 
        size.cx + dxFormatFontBitmap >= pdis->rcItem.right)
    {
        ZeroMemory(&ti, sizeof(TOOLINFO));
        ti.cbSize = sizeof(TOOLINFO);
        ti.hwnd = m_hwndName;
        ti.uId = (UINT_PTR)m_hwndName;
        ti.lpszText = szFace;
        
        SendMessage(m_hwndName, CB_GETDROPPEDCONTROLRECT, 0, (LPARAM)&rc);

        SendMessage(m_hwndTT, TTM_UPDATETIPTEXT, 0, (LPARAM)&ti);
        SendMessage(m_hwndTT, TTM_TRACKPOSITION, 0, MAKELPARAM(rc.left + pdis->rcItem.left + dxFormatFontBitmap, 
                                                               rc.top + pdis->rcItem.top));
        SendMessage(m_hwndTT, TTM_TRACKACTIVATE, TRUE, (LPARAM) &ti);
    }
    else
        SendMessage(m_hwndTT, TTM_TRACKACTIVATE, FALSE, (LPARAM) &ti);


    hdcMem = CreateCompatibleDC(hdc);
    if (hdcMem)
        {
        if (m_hbmName)
            {
            hbmOld = (HBITMAP)SelectObject(hdcMem, m_hbmName);

            x = dxFormatFontBitmap;
            if (nFontType & TRUETYPE_FONTTYPE)
                x = 0;
            else if ((nFontType & (PRINTER_FONTTYPE | DEVICE_FONTTYPE)) ==
                         (PRINTER_FONTTYPE | DEVICE_FONTTYPE))
                x = dxFormatFontBitmap;
            else
                goto SkipBlt;

            dy = ((pdis->rcItem.bottom - pdis->rcItem.top) -
                            dyFormatFontBitmap) / 2;

            BitBlt(hdc, pdis->rcItem.left, pdis->rcItem.top + dy,
                       dxFormatFontBitmap, dyFormatFontBitmap, hdcMem,
                       x, pdis->itemState & ODS_SELECTED ? dyFormatFontBitmap: 0,
                       SRCCOPY);

SkipBlt:
        SelectObject(hdcMem, hbmOld);
            }
            DeleteDC(hdcMem);
        }

    SetTextColor(hdc, rgbText);
    SetBkColor(hdc, rgbBack);
}


void Color_WMDrawItem(HWND hwnd, LPDRAWITEMSTRUCT pdis)
{
    HBRUSH                          hbr;
    WORD                            dx, dy, dxBorder;
    RECT                            rc;
    TCHAR                           szColor[MAX_PATH]={0};
    DWORD                           rgbBack, rgbText;
    UINT                            id = pdis->itemID;
    ULONG                           index = 0;

    Assert (pdis->CtlType == ODT_MENU);

    if(pdis->itemState&ODS_SELECTED)
        {
        rgbBack = SetBkColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHT));
        rgbText = SetTextColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
        }
    else
        {
        rgbBack = SetBkColor(pdis->hDC, GetSysColor(COLOR_MENU));
        rgbText = SetTextColor(pdis->hDC, GetSysColor(COLOR_MENUTEXT));
        }
        
    // compute coordinates of color rectangle and draw it
    dxBorder  = (WORD) GetSystemMetrics(SM_CXBORDER);
    dx    = (WORD) GetSystemMetrics(SM_CXMENUCHECK);

    dy        = (WORD) GetSystemMetrics(SM_CYBORDER);
    rc.top    = pdis->rcItem.top + dy;
    rc.bottom = pdis->rcItem.bottom - dy;
    rc.left   = pdis->rcItem.left + dx;
    rc.right  = rc.left + 2 * (rc.bottom - rc.top);

    index = GETINDEX(pdis->itemData);
    LoadString(g_hLocRes, index + idsColor1,
                       szColor, sizeof(szColor)/sizeof(TCHAR));

    SelectObject(pdis->hDC, hFontGetMenuFont(hwnd));

    ExtTextOut(pdis->hDC, rc.right + 2*dxBorder,
                       pdis->rcItem.top, ETO_OPAQUE, &pdis->rcItem,
                       szColor, lstrlen(szColor), NULL);


    hbr = CreateSolidBrush((DWORD)(pdis->itemData & 0x00ffffff));

    if (hbr)
        {
        hbr = (HBRUSH)SelectObject (pdis->hDC, hbr);
        Rectangle(pdis->hDC, rc.left, rc.top, rc.right, rc.bottom);
        DeleteObject(SelectObject(pdis->hDC, hbr));
        }

    // draw radio check.
    if (pdis->itemState&ODS_CHECKED)
        {
        WORD left, top, radius;

        if(pdis->itemState&ODS_SELECTED)
            hbr = CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHTTEXT));
        else
            hbr = CreateSolidBrush(GetSysColor(COLOR_MENUTEXT));

        if (hbr)
            {
            hbr = (HBRUSH)SelectObject (pdis->hDC, hbr);
#ifndef WIN16
            left = (WORD) (pdis->rcItem.left + GetSystemMetrics(SM_CXMENUCHECK) / 2);
#else
            left = pdis->rcItem.left + LOWORD( GetMenuCheckMarkDimensions() ) / 2;
#endif
            top = (WORD) (rc.top + (rc.bottom - rc.top) / 2);
#ifndef WIN16
            radius = (WORD) (GetSystemMetrics(SM_CXMENUCHECK) / 4);
#else
            radius = LOWORD( GetMenuCheckMarkDimensions() ) / 4;
#endif
            Ellipse(pdis->hDC, left-radius, top-radius, left+radius, top+radius);
            DeleteObject(SelectObject(pdis->hDC, hbr));
            }
        }

    SetTextColor(pdis->hDC, rgbText);
    SetBkColor(pdis->hDC, rgbBack);
}


HRESULT CFmtBar::Show()
{
    HRESULT hr;

    if (m_fVisible)
        return S_OK;

    hr = AttachWin();
    if (FAILED(hr))
        return hr;

    ShowWindow(m_hwnd, SW_SHOW);
    m_fVisible=1;
    Update();
    return S_OK;
}

HRESULT CFmtBar::Hide()
{
    if (!m_fVisible)
        return S_OK;

    ShowWindow(m_hwnd, SW_HIDE);
    m_fVisible=0;
    return S_OK;
}

HRESULT CFmtBar::GetWindow(HWND *pHwnd)
{
    *pHwnd = m_hwnd;
    return S_OK;
}

HRESULT CFmtBar::AttachWin()
{
    HWND            hwnd;
    WNDCLASS        wc;

    if (m_hwnd)     // already created
        return S_OK;

    if (FAILED(CreateColorMenu(idmFmtColor1, &m_hmenuColor)))
        return E_FAIL;

    if (!GetClassInfo(g_hLocRes, c_szFmtBarClass, &wc))
        {
        ZeroMemory(&wc, sizeof(WNDCLASS));
        
        wc.style = CS_BYTEALIGNWINDOW;
        wc.lpfnWndProc = CFmtBar::ExtWndProc;
        wc.hInstance = g_hLocRes;
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
        wc.lpszClassName = c_szFmtBarClass;
        if (!RegisterClass(&wc))
            return E_FAIL;
        }

    hwnd = CreateWindowEx(WS_EX_CONTROLPARENT,
                          c_szFmtBarClass, NULL,
                          WS_CHILD|WS_CLIPCHILDREN,
                          0, 0, 0, 0,
                          m_hwndParent, (HMENU)IntToPtr(m_idd), g_hLocRes, (LPVOID)this);

    if(!hwnd)
        return E_OUTOFMEMORY;

    return S_OK;
}

HFONT hFontGetMenuFont(HWND hwnd)
{
    NMHDR   nmhdr;

    nmhdr.hwndFrom=hwnd;
    nmhdr.idFrom=GetDlgCtrlID(hwnd);
    nmhdr.code=FBN_GETMENUFONT;

    return (HFONT)SendMessage(GetParent(hwnd), WM_NOTIFY, nmhdr.idFrom, (LPARAM)&nmhdr);
}



HRESULT CFmtBar::_SetToolbarBitmaps()
{
    // release toolbar references
    SendMessage(m_hwndToolbar, TB_SETIMAGELIST, 0, (LPARAM)NULL);
    SendMessage(m_hwndToolbar, TB_SETHOTIMAGELIST, 0, (LPARAM)NULL);

    _FreeImageLists();

    // set the normal imagelist
    m_himl = LoadMappedToolbarBitmap(g_hLocRes, idbFormatBar, dxToolbarButton);
    if (!m_himl)
        return E_OUTOFMEMORY;

    SendMessage(m_hwndToolbar, TB_SETIMAGELIST, 0, (LPARAM)m_himl);

    // the the HOT imagelist
    m_himlHot = LoadMappedToolbarBitmap(g_hLocRes, idbFormatBarHot, dxToolbarButton);
    if (!m_himlHot)
        return E_OUTOFMEMORY;

    SendMessage(m_hwndToolbar, TB_SETHOTIMAGELIST, 0, (LPARAM)m_himlHot);
    return S_OK;
}

HRESULT CFmtBar::_FreeImageLists()
{
    if (m_himlHot)
    {
        ImageList_Destroy(m_himlHot);
        m_himlHot = NULL;
    }

    if (m_himl)
    {
        ImageList_Destroy(m_himl);
        m_himl = NULL;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\mhtml.h ===
/*
 *    m h t m l . c p p
 *    
 *    Purpose:
 *        MHTML packing utilities
 *
 *  History
 *      August '96: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */

#ifndef _MHTML_H
#define _MHTML_H



HRESULT SaveAsMHTML(IHTMLDocument2 *pDoc, DWORD dwFlags, IMimeMessage *pMsgSrc, IMimeMessage *pMsgDest, IHashTable *pHashRestricted);
HRESULT HashExternalReferences(IHTMLDocument2 *pDoc, IMimeMessage *pMsg, IHashTable **ppHash);



#endif // _MHTML_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\hash.h ===
/*
 *    hash.h
 *    
 *    Purpose:
 *        implementation of a string hash table
 *    
 *    Owner:
 *        EricAn
 *
 *    History:
 *      Mar 97: Created.
 *    
 *    Copyright (C) Microsoft Corp. 1997
 */

#ifndef __HASH_H
#define __HASH_H

typedef struct tagHASHENTRY *PHASHENTRY;
typedef struct tagHASHENTRY {
    LPSTR       pszKey;
    LPVOID      pv;
    PHASHENTRY  pheNext;        
} HASHENTRY;

class CHash :
    public IHashTable,
    public CPrivateUnknown
{
public:
    // ---------------------------------------------------------------------------
    // IUnknown members
    // ---------------------------------------------------------------------------
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { 
        return CPrivateUnknown::QueryInterface(riid, ppvObj); };
    virtual STDMETHODIMP_(ULONG) AddRef(void) { 
        return CPrivateUnknown::AddRef();};
    virtual STDMETHODIMP_(ULONG) Release(void) { 
        return CPrivateUnknown::Release(); };

    // IHashTable
    HRESULT STDMETHODCALLTYPE Init(DWORD dwSize, BOOL fDupeKeys);
    HRESULT STDMETHODCALLTYPE Insert(LPSTR psz, LPVOID pv, DWORD dwFlags);
    HRESULT STDMETHODCALLTYPE Replace(LPSTR psz, LPVOID pv);
    HRESULT STDMETHODCALLTYPE Find(LPSTR psz, BOOL fRemove, LPVOID *ppv);
    HRESULT STDMETHODCALLTYPE Reset();
    HRESULT STDMETHODCALLTYPE Next(ULONG cFetch, LPVOID **prgpv, ULONG *pcFetched);


    CHash(IUnknown *pUnkOuter=NULL);
    virtual ~CHash();

protected:
    inline DWORD Hash(LPSTR psz);

    DWORD       m_cBins,
                m_iListBinEnum;
    PHASHENTRY  m_rgBins,
                m_pLastEntryEnum;
    BOOL        m_fDupe;

    virtual HRESULT PrivateQueryInterface(REFIID riid, LPVOID * ppvObj);

#ifdef DEBUG
    void Stats();
#endif

};

#endif // __HASH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\hash.cpp ===
/*
 *    hash.cpp
 *    
 *    Purpose:
 *        implementation of a string hash table
 *    
 *    Owner:
 *        EricAn
 *
 *    History:
 *      Mar 97: Created.
 *    
 *    Copyright (C) Microsoft Corp. 1997
 */

#include <pch.hxx>
#include "dllmain.h"
#include "privunk.h"
#include "hash.h"
#include "demand.h"

// possible hash-table sizes, chosen from primes not close to powers of 2
static const DWORD s_rgPrimes[] = { 29, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593 };

BOOL FastStrCmp(char *psz1, char *psz2)
{
    if (psz1 == NULL || psz2 == NULL)
        return FALSE;

    while (*psz1 && *psz2 && (*psz1 == *psz2)) 
    {
        psz1++;
        psz2++;
    };

    return *psz1 == *psz2;
}

//+---------------------------------------------------------------
//
//  Member:     Constructor
//
//  Synopsis:   
//
//---------------------------------------------------------------
CHash::CHash(IUnknown *pUnkOuter) : CPrivateUnknown(pUnkOuter)
{
    m_cBins = 0;
    m_rgBins = NULL;
    m_fDupe = FALSE;
    m_pLastEntryEnum = NULL;
    m_iListBinEnum = 0;

    DllAddRef();
}


CHash::~CHash()
{
    PHASHENTRY phe, pheTemp;

    for (DWORD dw = 0; dw < m_cBins; dw++)
        {
        if (m_rgBins[dw].pheNext)
            {
            phe = m_rgBins[dw].pheNext;
            while (phe)
                {
                pheTemp = phe;
                phe = phe->pheNext;
                if (m_fDupe && pheTemp->pszKey)
                    MemFree(pheTemp->pszKey);

                MemFree(pheTemp);
                }
            }
        
        if (m_rgBins[dw].pszKey && m_fDupe)
            MemFree(m_rgBins[dw].pszKey);

        }
    SafeMemFree(m_rgBins);
    DllRelease();
}

HRESULT CHash::Init(DWORD dwSize, BOOL fDupeKeys)
{    
    int i = 0;

    m_fDupe = fDupeKeys;

    while (i < (ARRAYSIZE(s_rgPrimes) - 1) && s_rgPrimes[i] < dwSize)
        i++;
    Assert(s_rgPrimes[i] >= dwSize || i == (ARRAYSIZE(s_rgPrimes)-1));
    m_cBins = s_rgPrimes[i];

    if (!MemAlloc((LPVOID*)&m_rgBins, m_cBins * sizeof(HASHENTRY)))
        return E_OUTOFMEMORY;

    ZeroMemory(m_rgBins, m_cBins * sizeof(HASHENTRY));

    return NOERROR;
}

DWORD CHash::Hash(LPSTR psz)
{
    DWORD h = 0;
    while (*psz)
        h = ((h << 4) + *psz++ + (h >> 28));
    return (h % m_cBins);
}

HRESULT CHash::Insert(LPSTR psz, LPVOID pv, DWORD dwFlags)
{
    PHASHENTRY phe = &m_rgBins[Hash(psz)];

    if (m_fDupe &&
        (!(psz = PszDupA(psz))))
        return E_OUTOFMEMORY;

    if (HF_NO_DUPLICATES & dwFlags)
    {
        PHASHENTRY pheCurrent = phe;

        // Check for duplicate entries: if found, do not insert this entry
        do
        {
            if (pheCurrent->pszKey && FastStrCmp(pheCurrent->pszKey, psz))
            {
                // This is already in our hash table. Replace data value
                pheCurrent->pv = pv;
                if (m_fDupe)
                    MemFree(psz);

                return NOERROR;
            }

            // Advance pointer
            pheCurrent = pheCurrent->pheNext;
        } while (NULL != pheCurrent);
    }

    if (phe->pszKey)
        {
        PHASHENTRY pheNew;

        if (!MemAlloc((LPVOID*)&pheNew, sizeof(HASHENTRY)))
            {
            if (m_fDupe)
                MemFree(psz);
            return E_OUTOFMEMORY;
            }
        pheNew->pheNext = phe->pheNext;
        phe->pheNext = pheNew;
        phe = pheNew;
        }

    phe->pszKey = psz;
    phe->pv = pv;
    return NOERROR;
}

HRESULT CHash::Find(LPSTR psz, BOOL fRemove, LPVOID * ppv)
{
    PHASHENTRY  phe     = &m_rgBins[Hash(psz)],
                phePrev = NULL,
                pheTemp;

    if (phe->pszKey)
    {
        do
        {
            if (FastStrCmp(phe->pszKey, psz))
            {
                *ppv = phe->pv;
                if (fRemove)
                {
                    if (m_fDupe)
                        SafeMemFree(phe->pszKey);

                    if (phePrev)
                    {
                        // mid-chain
                        phePrev->pheNext = phe->pheNext;
                        MemFree(phe);
                    }
                    else
                    {
                        // head of bucket
                        phe->pv = NULL;
                        phe->pszKey = NULL;
                        pheTemp = phe->pheNext;
                        if (pheTemp)
                        {
                            CopyMemory(phe, pheTemp, sizeof(HASHENTRY));
                            MemFree(pheTemp);
                        }
                    }
                }
                return NOERROR;
            }
            phePrev = phe;
            phe = phe->pheNext;
        }
        while (phe);
    }
    return CO_E_NOMATCHINGNAMEFOUND;
}

HRESULT CHash::Replace(LPSTR psz, LPVOID pv)
{
    PHASHENTRY phe = &m_rgBins[Hash(psz)];

    if (phe->pszKey)
        {
        do
            {
            if (FastStrCmp(phe->pszKey, psz))
                {
                phe->pv = pv;
                return NOERROR;
                }
            phe = phe->pheNext;
            }
        while (phe);
        }
    return CO_E_NOMATCHINGNAMEFOUND;
}


HRESULT CHash::Reset()
{
    m_iListBinEnum = 0;
    m_pLastEntryEnum = &m_rgBins[0];
    return S_OK;
}

HRESULT CHash::Next(ULONG cFetch, LPVOID **prgpv, ULONG *pcFetched)
{
    LPVOID      *rgpv;
    ULONG       cFound=0;
    PHASHENTRY  phe;
    HRESULT     hr;

    if (!MemAlloc((LPVOID *)&rgpv, sizeof(LPVOID) * cFetch))
        return E_OUTOFMEMORY;
 
    ZeroMemory(rgpv, sizeof(LPVOID) * cFetch);

    while (m_pLastEntryEnum)
    {
        if (m_pLastEntryEnum->pszKey)
            rgpv[cFound++] = m_pLastEntryEnum->pv;
        
        m_pLastEntryEnum = m_pLastEntryEnum->pheNext;
        
        if (!m_pLastEntryEnum && m_iListBinEnum < m_cBins -1)
            m_pLastEntryEnum = &m_rgBins[++m_iListBinEnum];

        if (cFound == cFetch)
            break;
    }

    hr = cFound ? (cFound == cFetch ? S_OK : S_FALSE) : E_FAIL;
    if (FAILED(hr))
    {
        MemFree(rgpv);
        rgpv = NULL;
    }

    *prgpv = rgpv;
    *pcFetched = cFound;
    return hr;
}


#ifdef DEBUG
void CHash::Stats()
{
    DWORD       dwLongest = 0;
    DWORD       dwCollisions = 0;
    DWORD       dwTotalCost = 0;
    DWORD       dwItems = 0;
    DWORD       dwLength;
    DWORD       dw;
    PHASHENTRY  phe;
    DWORD       rgLen[100];

    TraceCall("CHash::Stats()");

    ZeroMemory(rgLen, sizeof(rgLen));

    for (dw = 0; dw < m_cBins; dw++)
        {
        dwLength = 0;
        if (m_rgBins[dw].pszKey)
            {
            dwLength++;
            phe = m_rgBins[dw].pheNext;
            while (phe)
                {
                dwCollisions++;
                dwLength++;
                phe = phe->pheNext;
                }
            }
        if (dwLength > dwLongest)
            dwLongest = dwLength;
        dwTotalCost += (dwLength * (dwLength + 1)) / 2;
        dwItems += dwLength;
        rgLen[dwLength]++;
        }

    TraceInfo(_MSG("\tdwCollisions = %ld\r\n\tdwLongest = %ld\r\n\tdwItems = %ld\r\n\tdwTotalCost = %ld",
                dwCollisions, dwLongest, dwItems, dwTotalCost));

    for (dw = 0; dw <= dwLongest; dw++)
        TraceInfo(_MSG("Len %d: %d", dw, rgLen[dw]));
}
#endif


//+---------------------------------------------------------------
//
//  Member:     PrivateQueryInterface
//
//  Synopsis:   
//
//---------------------------------------------------------------
HRESULT CHash::PrivateQueryInterface(REFIID riid, LPVOID *lplpObj)
{
    if(!lplpObj)
        return E_INVALIDARG;

    *lplpObj = NULL;

    if (IsEqualIID(riid, IID_IHashTable))
        *lplpObj = (LPVOID)(IHashTable *)this;
    else
        return E_NOINTERFACE;

    AddRef();
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\frames.cpp ===
/*
 *    f r a m e s . c p p
 *    
 *    Purpose:
 *        Frameset helper functions
 *
 *  History
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */
#include <pch.hxx>
#include "frames.h"
#include "htiframe.h"       //ITargetFrame2
#include "htiface.h"        //ITargetFramePriv

ASSERTDATA

typedef enum _TARGET_TYPE {
    TARGET_FRAMENAME,
    TARGET_SELF,
    TARGET_PARENT,
    TARGET_BLANK,
    TARGET_TOP,
    TARGET_MAIN
} TARGET_TYPE;

typedef struct _TARGETENTRY 
    {
    TARGET_TYPE     targetType;
    const WCHAR     *pTargetValue;
    } TARGETENTRY;

static const TARGETENTRY targetTable[] =
{
    {TARGET_SELF, L"_self"},
    {TARGET_PARENT, L"_parent"},
    {TARGET_BLANK, L"_blank"},
    {TARGET_TOP, L"_top"},
    {TARGET_MAIN, L"_main"},
    {TARGET_SELF, NULL}
};


/*******************************************************************

    NAME:       ParseTargetType

    SYNOPSIS:   Maps pszTarget into a target class.

    IMPLEMENTATION:
    Treats unknown MAGIC targets as _self

********************************************************************/
TARGET_TYPE ParseTargetType(LPCOLESTR pszTarget)
{
    const TARGETENTRY *pEntry = targetTable;

    if (pszTarget[0] != '_') return TARGET_FRAMENAME;
    while (pEntry->pTargetValue)
    {
        if (!StrCmpW(pszTarget, pEntry->pTargetValue)) return pEntry->targetType;
        pEntry++;
    }
    //  Treat unknown MAGIC targets as regular frame name! <<for NETSCAPE compatibility>>
    return TARGET_FRAMENAME;
}


HRESULT DoFindFrameInContext(IUnknown *pUnkTrident, IUnknown *pUnkThis, LPCWSTR pszTargetName, IUnknown *punkContextFrame, DWORD dwFlags, IUnknown **ppunkTargetFrame) 
{
    IOleContainer       *pOleContainer;
    LPENUMUNKNOWN       penumUnknown;
    LPUNKNOWN           punkChild,
                        punkChildFrame;
    ITargetFramePriv    *ptgfpChild;
    HRESULT             hr = E_FAIL;    
    TARGET_TYPE         targetType;

    Assert (pUnkTrident && pUnkThis);

    targetType = ParseTargetType(pszTargetName);
    if (targetType != TARGET_FRAMENAME)
        {
        // blank frames need to open a new browser window
        if (targetType == TARGET_BLANK)
            {
            *ppunkTargetFrame = NULL;
            return S_OK;
            }

        // must be a margic target name if it's _self, _parent, _top or _main
        // let's just return our own target frame
        *ppunkTargetFrame = pUnkThis;
        pUnkThis->AddRef();
        return S_OK;
        }
    else
        {
        if (pUnkTrident && 
            pUnkTrident->QueryInterface(IID_IOleContainer, (LPVOID *)&pOleContainer)==S_OK)
            {
            if (pOleContainer->EnumObjects(OLECONTF_EMBEDDINGS, &penumUnknown)==S_OK)
                {
                while(  hr!=S_OK && 
                        penumUnknown->Next(1, &punkChild, NULL)==S_OK)
                    {
                    if (punkChild->QueryInterface(IID_ITargetFramePriv, (LPVOID *)&ptgfpChild)==S_OK)
                        {
                        if (ptgfpChild->QueryInterface(IID_IUnknown, (LPVOID *)&punkChildFrame)==S_OK)
                            {
                            //  to avoid recursion - if this isn't the punkContextFrame, see if embedding supports ITargetFrame 
                            if (punkChildFrame != punkContextFrame)
                                {
                                hr = ptgfpChild->FindFrameDownwards(pszTargetName, dwFlags, ppunkTargetFrame); 
                                }
                            punkChildFrame->Release();
                            }
                        ptgfpChild->Release();
                        }
                    punkChild->Release();
                    }
                penumUnknown->Release();
                }
            pOleContainer->Release();
            } 
        }
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\inetcomm\mimeedit\mhtml.cpp ===
/*
 *    m h t m l . c p p
 *    
 *    Purpose:
 *        MHTML packing utilities
 *
 *  History
 *      August '96: brettm - created
 *    
 *    Copyright (C) Microsoft Corp. 1995, 1996.
 */
#include <pch.hxx>
#include "dllmain.h"
#include "resource.h"
#include "strconst.h"
#include "htmlstr.h"
#include "mimeutil.h"
#include "triutil.h"
#include "util.h"
#include "oleutil.h"
#include "demand.h"
#include "mhtml.h"
#include "tags.h"

ASSERTDATA

/*
 *  m a c r o s
 */

/*
 *  c o n s t a n t s
 */

static const TCHAR   c_szRegExtension[] = "SOFTWARE\\Microsoft\\MimeEdit\\MHTML Extension";



/*
 *  t y p e d e f s
 */

/*
 *  g l o b a l s 
 */
    
/*
 *  f u n c t i o n   p r o t y p e s
 */


/*
 *  f u n c t i o n s
 */


class CPackager
{
public:
    
    CPackager();
    virtual ~CPackager();

    ULONG AddRef();
    ULONG Release();

    HRESULT PackageData(IHTMLDocument2 *pDoc, IMimeMessage *pMsgSrc, IMimeMessage *pMsgDest, DWORD dwFlags, IHashTable *pHashRestricted);

private:
    ULONG           m_cRef;
    IMimeMessage    *m_pMsgSrc,
                    *m_pMsgDest;
    IHashTable      *m_pHash,
                    *m_pHashRestricted;

    HRESULT _PackageCollectionData(IMimeEditTagCollection *pCollect);
    HRESULT _PackageUrlData(IMimeEditTag *pTag);

    HRESULT _RemapUrls(IMimeEditTagCollection *pCollect, BOOL fSave);
    HRESULT _CanonicaliseContentId(LPWSTR pszUrlW, BSTR *pbstr);
    HRESULT _ShouldUseContentId(LPSTR pszUrl);
    HRESULT _BuildCollectionTable(DWORD dwFlags, IHTMLDocument2 *pDoc, IMimeEditTagCollection ***prgpCollect, ULONG *pcCount);

};





CPackager::CPackager()
{
    m_cRef = 1;
    m_pMsgSrc = NULL;
    m_pMsgDest = NULL;
    m_pHash = NULL;
    m_pHashRestricted = NULL;
}

CPackager::~CPackager()
{
    ReleaseObj(m_pMsgSrc);
    ReleaseObj(m_pMsgDest);
    ReleaseObj(m_pHash);
    ReleaseObj(m_pHashRestricted);
}


ULONG CPackager::AddRef()
{
    return ++m_cRef;
}

ULONG CPackager::Release()
{
    if (--m_cRef==0)
        {
        delete this;
        return 0;
        }
    return m_cRef;
}

HRESULT CPackager::PackageData(IHTMLDocument2 *pDoc, IMimeMessage *pMsgSrc, IMimeMessage *pMsgDest, DWORD dwFlags, IHashTable *pHashRestricted)
{
    LPSTREAM                pstm;
    HRESULT                 hr,
                            hrWarnings=S_OK;
    HBODY                   hBodyHtml=0;
    IMimeEditTagCollection  **rgpCollect=NULL;
    ULONG                   uCollect,
                            cCollect=0,
                            cItems=0,
                            cCount;

    // BUGBUG: propagate hrWarnings back up
    TraceCall("CBody::Save");

    if (pDoc==NULL || pMsgDest==NULL)
        return E_INVALIDARG;

    ReplaceInterface(m_pMsgSrc, pMsgSrc);
    ReplaceInterface(m_pMsgDest, pMsgDest);
    ReplaceInterface(m_pHashRestricted, pHashRestricted);

    hr = _BuildCollectionTable(dwFlags, pDoc, &rgpCollect, &cCollect);
    if (FAILED(hr))
        hrWarnings = hr;

    // count the number of items we need to package and 
    // prepare a hash-table for duplicate entries
    for (uCollect = 0; uCollect < cCollect; uCollect++)
    {
        Assert (rgpCollect[uCollect]);

        if ((rgpCollect[uCollect])->Count(&cCount)==S_OK)
            cItems+=cCount;
    }

    if (cItems)
    {
        // create the hashtable
        hr = MimeOleCreateHashTable(cItems, TRUE, &m_pHash);
        if (FAILED(hr))
            goto error;
    }

    // package the data required for each collection
    for (uCollect = 0; uCollect < cCollect; uCollect++)
    {
        // package the data
        hr = _PackageCollectionData(rgpCollect[uCollect]);
        if (FAILED(hr))
            goto error;

        if (hr != S_OK)         // retain any 'warnings'
            hrWarnings = hr;

        // map all the URLs to CID:// urls if necessary
        hr = _RemapUrls(rgpCollect[uCollect], TRUE);
        if (FAILED(hr))
            goto error;
    }
        
    // get an HTML stream
    if(dwFlags & MECD_HTML)
    {
        hr = GetBodyStream(pDoc, TRUE, &pstm);
        if (!FAILED(hr))
        {
            hr = pMsgDest->SetTextBody(TXT_HTML, IET_INETCSET, NULL, pstm, &hBodyHtml);
            pstm->Release();
        }

        if (FAILED(hr))
            goto error;
    }

    // get a plain-text stream
    if(dwFlags & MECD_PLAINTEXT)
    {
        hr = GetBodyStream(pDoc, FALSE, &pstm);
        if (!FAILED(hr))
        {
            // if we set a html body part, then be sure to pass in hBodyHtml so Opie knows what the alternate is
            // alternative to.
            hr = pMsgDest->SetTextBody(TXT_PLAIN, IET_UNICODE, hBodyHtml, pstm, NULL);
            pstm->Release();
        }
        
        if (FAILED(hr))
            goto error;
    }

    
    for (uCollect = 0; uCollect < cCollect; uCollect++)
    {
        // remap all of the URL's back to their original location
        hr = _RemapUrls(rgpCollect[uCollect], FALSE);
        if (FAILED(hr))
            goto error;
    
    }
        
    
error:
    // release the collection objects
    if (rgpCollect)
    {
        for (uCollect = 0; uCollect < cCollect; uCollect++)
            ReleaseObj(rgpCollect[uCollect]);
        MemFree(rgpCollect);
    }
    
    return hr==S_OK ? hrWarnings : hr;
}


HRESULT CPackager::_BuildCollectionTable(DWORD dwFlags, IHTMLDocument2 *pDoc, IMimeEditTagCollection ***prgpCollect, ULONG *pcCount)
{
    IMimeEditTagCollection    **rgpCollect=NULL;
    HKEY                        hkey;
    ULONG                       cPlugin=0,
                                cCount = 0,
                                cAlloc = 0,
                                i,
                                cb;
    TCHAR                       szGUID[MAX_PATH];
    IID                         iid;
    HRESULT                     hr=E_FAIL;
    LONG                        lResult;
    LPWSTR                      pszGuidW;
    
    *prgpCollect = NULL;
    *pcCount = NULL;

    // reserve space for 2 image collections (bgimage and img)
    if (dwFlags & MECD_ENCODEIMAGES)
        cAlloc+=2;

    // reserver space for bgsounds
    if (dwFlags & MECD_ENCODESOUNDS)
        cAlloc++;

    // reserver space for active-movies
    if (dwFlags & MECD_ENCODEVIDEO)
        cAlloc++;

    // reserve space for plugin types
    if ((dwFlags & MECD_ENCODEPLUGINS) && 
        RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegExtension, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        if (RegQueryInfoKey(hkey, NULL, NULL, 0, &cPlugin, NULL, NULL, NULL, NULL, NULL, NULL, NULL) == ERROR_SUCCESS &&
            cPlugin > 0)
            cAlloc += cPlugin;
        RegCloseKey(hkey);
    }

    // allocate the table of collection pointers
    if (!MemAlloc((LPVOID *)&rgpCollect, sizeof(IMimeEditTagCollection *) * cAlloc))
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto error;
    }
    
    // zero-init the table
    ZeroMemory((LPVOID)rgpCollect, sizeof(IMimeEditTagCollection *) * cAlloc);


    if (dwFlags & MECD_ENCODEIMAGES)
    {
        // image collection
        if (FAILED(CreateOEImageCollection(pDoc, &rgpCollect[cCount])))
            hr = MIMEEDIT_W_BADURLSNOTATTACHED; // bubble back a warning, but don't fail
        else
            cCount++;
    }

    if (dwFlags & MECD_ENCODEIMAGES)
    {
        // background images
        if (FAILED(CreateBGImageCollection(pDoc, &rgpCollect[cCount])))
            hr = MIMEEDIT_W_BADURLSNOTATTACHED; // bubble back a warning, but don't fail
        else
            cCount++;
    }

    if (dwFlags & MECD_ENCODESOUNDS)
    {
        // background sounds
        if (FAILED(CreateBGSoundCollection(pDoc, &rgpCollect[cCount])))
            hr = MIMEEDIT_W_BADURLSNOTATTACHED; // bubble back a warning, but don't fail
        else
            cCount++;
    }

    
    if (dwFlags & MECD_ENCODEVIDEO)
    {
        // active-movie controls (for MSPHONE)
        if (FAILED(CreateActiveMovieCollection(pDoc, &rgpCollect[cCount])))
            hr = MIMEEDIT_W_BADURLSNOTATTACHED; // bubble back a warning, but don't fail
        else
            cCount++;
    }

    if ((dwFlags & MECD_ENCODEPLUGINS) && 
        cPlugin &&
        RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegExtension, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        // Start Enumerating the keys
        for (i = 0; i < cPlugin; i++)
        {
            // Enumerate Friendly Names
            cb = sizeof(szGUID);
            lResult = RegEnumKeyEx(hkey, i, szGUID, &cb, 0, NULL, NULL, NULL);

            // No more items
            if (lResult == ERROR_NO_MORE_ITEMS)
                break;

            // Error, lets move onto the next account
            if (lResult != ERROR_SUCCESS)
            {
                Assert(FALSE);
                continue;
            }

            pszGuidW = PszToUnicode(CP_ACP, szGUID);
            if (pszGuidW)
            {
                // convert the string to a guid
                if (IIDFromString(pszGuidW, &iid) == S_OK)
                {
                    // cocreate the plugin
                    if (CoCreateInstance(iid, NULL, CLSCTX_INPROC_SERVER, IID_IMimeEditTagCollection, (LPVOID *)&rgpCollect[cCount])==S_OK)
                    {
                        // try and init the document
                        if (!FAILED((rgpCollect[cCount])->Init(pDoc)))
                        {
                            cCount++;
                        }
                        else
                        {
                            SafeRelease(rgpCollect[cCount]);
                        }
                    }
                    else
                        hr = MIMEEDIT_W_BADURLSNOTATTACHED; // bubble back a warning, but don't fail
                }
                MemFree(pszGuidW);
            }
        }
        RegCloseKey(hkey);
    }


    *prgpCollect = rgpCollect;
    *pcCount = cCount;
    rgpCollect = NULL;
    hr = S_OK;

error:
    if (rgpCollect)
    {   
        for (i = 0; i < cAlloc; i++)
            SafeRelease(rgpCollect[i]);

        MemFree(rgpCollect);
    }
    return hr;
}


HRESULT CPackager::_PackageCollectionData(IMimeEditTagCollection *pCollect)
{
    ULONG           cFetched;
    IMimeEditTag    *pTag;
    BOOL            fBadLinks = FALSE;

    Assert (pCollect);

    pCollect->Reset();

    while (pCollect->Next(1, &pTag, &cFetched)==S_OK && cFetched==1)
    {
        Assert (pTag);

        if (pTag->CanPackage() != S_OK ||
            _PackageUrlData(pTag) != S_OK)
        {
            // we failed to package this body part. Be sure to return a warning when we're done
            // but let's keep trucking for now...
            fBadLinks = TRUE;
        }
        pTag->Release();
    }

    return fBadLinks ? MIMEEDIT_W_BADURLSNOTATTACHED : S_OK;;
}


HRESULT CPackager::_PackageUrlData(IMimeEditTag *pTag)
{
    HRESULT     hr=S_OK;
    LPSTREAM    pstm;
    HBODY       hBody=0,
                hBodyOld;
    LPSTR       lpszCID=0,
                lpszCIDUrl;
    LPSTR       pszUrlA=0,
                pszBody;

    BSTR        bstrSrc=NULL,
                bstrCID=NULL;
    LPWSTR      pszMimeTypeW=NULL;

    if (pTag == NULL)
        return E_INVALIDARG;

    pTag->GetSrc(&bstrSrc);

    pszUrlA = PszToANSI(CP_ACP, bstrSrc);
    if (!pszUrlA)
        return TraceResult(E_OUTOFMEMORY);

    DWORD cchSize = (lstrlenA(pszUrlA) + 1);
    // if the URL is a restricted URL then we simply exit without packing any data
    if (m_pHashRestricted &&
        m_pHashRestricted->Find(pszUrlA, FALSE, (LPVOID *)&hBody)==S_OK)
    {
        MemFree(pszUrlA);
        return S_OK;
    }

    // hack: if it's an MHTML: url then we have to fixup to get the cid:
    if (StrCmpNIA(pszUrlA, "mhtml:", 6)==0)
    {
        if (!FAILED(MimeOleParseMhtmlUrl(pszUrlA, NULL, &pszBody)))
        {
            // pszBody pszUrlA is guarnteed to be smaller 
            StrCpyNA(pszUrlA, pszBody, cchSize * sizeof(pszUrlA[0]));
            SafeMimeOleFree(pszBody);
        }
    }
    
    if (m_pHash && 
        m_pHash->Find(pszUrlA, FALSE, (LPVOID *)&hBody)==S_OK)
    {
        // we've already seen this url one before in this document, and have it's HBODY already
        // so there's no need to do any work
        // try and get the content-id incase the caller is interested
        
        // BUGBUG? possible more than CID need to be ported here...
        MimeOleGetBodyPropA(m_pMsgDest, hBody, PIDTOSTR(PID_HDR_CNTID), NOFLAGS, &lpszCID);
        goto found;
    }

    // see if szUrl is in the related section of the source message
    if (m_pMsgSrc && 
        m_pMsgSrc->ResolveURL(NULL, NULL, pszUrlA, 0, &hBody)==S_OK)
    {
        hBodyOld = hBody;
        
        // this URL is already in the related section, and we haven't seen it already.
        // then let's bind to the data and attach it
        if (m_pMsgSrc->BindToObject(hBody, IID_IStream, (LPVOID *)&pstm)==S_OK)
        {
            // if it's a FILE:// url we use CID: else we use Content-Location
            hr = m_pMsgDest->AttachURL(NULL, pszUrlA, (_ShouldUseContentId(pszUrlA)==S_OK ? URL_ATTACH_GENERATE_CID : 0 )|URL_ATTACH_SET_CNTTYPE, pstm, &lpszCID, &hBody);
            pstm->Release();
        }
        
        // be sure to copy the old content-type and filename over
        HrCopyHeader(m_pMsgDest, hBody, m_pMsgSrc, hBodyOld, PIDTOSTR(PID_HDR_CNTTYPE));
        HrCopyHeader(m_pMsgDest, hBody, m_pMsgSrc, hBodyOld, PIDTOSTR(PID_HDR_CNTLOC));
        HrCopyHeader(m_pMsgDest, hBody, m_pMsgSrc, hBodyOld, PIDTOSTR(STR_PAR_FILENAME));
    }
    else
    {
        // if not, then let's try and bind to it ourselves. We don't go thro' MimeOle for this, as we want to
        // fail if the URL is bad, so we don't add the part to the Tree.
        hr = HrBindToUrl(pszUrlA, &pstm);
        if (!FAILED(hr))
        {
            hr = SniffStreamForMimeType(pstm, &pszMimeTypeW);
            if (!FAILED(hr))
            {
                if (pTag->IsValidMimeType(pszMimeTypeW)==S_OK)
                {
                    LPWSTR  pszFileNameW;

                    // if it's a FILE:// url we use CID: else we use Content-Location
                    hr = m_pMsgDest->AttachURL(NULL, pszUrlA, (_ShouldUseContentId(pszUrlA)==S_OK ? URL_ATTACH_GENERATE_CID : 0 )|URL_ATTACH_SET_CNTTYPE, pstm, &lpszCID, &hBody);
                    if (!FAILED(hr))
                    {
                        // if attaching a new attachment, try and sniff the file-name
                        pszFileNameW = PathFindFileNameW(bstrSrc);
                        if (pszFileNameW)
                            MimeOleSetBodyPropW(m_pMsgDest, hBody, PIDTOSTR(STR_PAR_FILENAME), NOFLAGS, pszFileNameW);
                    }
                }
                else
                    hr = E_FAIL;
                
                CoTaskMemFree(pszMimeTypeW);
            }
            pstm->Release();
        }
    }

    // add to the hash table
    if (m_pHash && 
        !FAILED(hr) && hBody)
        hr = m_pHash->Insert(pszUrlA, (void*)hBody, NOFLAGS);


found:
    // if we found the content-ID we need to return an allocated BSTR with it in.
    if (lpszCID)
    {
        LPWSTR  pszCIDW;

        pszCIDW = PszToUnicode(CP_ACP, lpszCID);
        if (pszCIDW)
        {
            if (_CanonicaliseContentId(pszCIDW, &bstrCID)==S_OK)
            {
                pTag->SetDest(bstrCID);
                SysFreeString(bstrCID);
            }
            MemFree(pszCIDW);
        }
        SafeMimeOleFree(lpszCID);
    }

    SafeMemFree(pszUrlA);
    return hr;
}

HRESULT CPackager::_ShouldUseContentId(LPSTR pszUrl)
{
    // we use Content-Location for urls that begin with "http:", "https:" and "ftp:" for all
    // others we will use Content-Id

    if (StrCmpNIA(pszUrl, "ftp:", 4)==0 ||
        StrCmpNIA(pszUrl, "http:", 5)==0 ||
        StrCmpNIA(pszUrl, "https:", 6)==0)
        return S_FALSE;

    return S_OK;        
}




HRESULT CPackager::_RemapUrls(IMimeEditTagCollection *pCollect, BOOL fSave)
{
    ULONG       cFetched;
    IMimeEditTag *pTag;

    Assert (pCollect);

    pCollect->Reset();

    while (pCollect->Next(1, &pTag, &cFetched)==S_OK && cFetched==1)
    {
        Assert (pTag);

        if (fSave)
            pTag->OnPreSave();
        else 
            pTag->OnPostSave();

        pTag->Release();
    }
    return S_OK;
}

HRESULT CPackager::_CanonicaliseContentId(LPWSTR pszUrlW, BSTR *pbstr)
{
    HRESULT     hr;

    *pbstr = NULL;

    if (StrCmpNIW(pszUrlW, L"cid:", 4)!=0)
    {
        DWORD cchSize = (lstrlenW(pszUrlW) + 4);
        *pbstr = SysAllocStringLen(NULL, cchSize);
        if (*pbstr)
        {
            StrCpyNW(*pbstr, L"cid:", cchSize);
            StrCatBuffW(*pbstr, pszUrlW, cchSize);
        }
    }
    else
        *pbstr = SysAllocString(pszUrlW);

    return *pbstr ? S_OK : E_OUTOFMEMORY;
}

HRESULT SaveAsMHTML(IHTMLDocument2 *pDoc, DWORD dwFlags, IMimeMessage *pMsgSrc, IMimeMessage *pMsgDest, IHashTable *pHashRestricted)
{
    CPackager   *pPacker=0;
    HRESULT     hr;

    TraceCall("CBody::Save");

    pPacker = new CPackager();
    if (!pPacker)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto error;
    }

    hr = pPacker->PackageData(pDoc, pMsgSrc, pMsgDest, dwFlags, pHashRestricted);
    if (FAILED(hr))
        goto error;

error:
    ReleaseObj(pPacker);
    return hr;
}




HRESULT HashExternalReferences(I