
                    
                            // okay, it's in one of our caches
                            if ( !IsCanonicalName( szFileName ) ) {
                                HANDLE hfind = FindFirstFile( szShort, &wfd );
                                if ( hfind != INVALID_HANDLE_VALUE ) {
                                    szFileName = wfd.cFileName;
                                    FindClose(hfind);
                                } else
                                    szFileName = NULL;
                            }

                            if ( szFileName != NULL  ) {
                                StrNCpy( szLong, s_kdMap.m_aKDMap[iKnownDir].szCanonical, cchBuffer);
                                // chop off szT right before the file name.
                                // if this is longer than the known dir name, we have a
                                // conflict.* subdirectory and must add this before the file
                                if ( cchBase != s_kdMap.m_aKDMap[iKnownDir].cchShort &&
                                     cchBase != s_kdMap.m_aKDMap[iKnownDir].cchCanonical ) {
                                    LPTSTR szConflict;
                                    CHAR chT = szT[cchBase];
                                    szT[cchBase] = '\0';
                                    // search back from before the file name.
                                    for ( szConflict = &szT[cchBase - 2];
                                          *szConflict != '\\'; szConflict-- );
                                    szConflict++; // we already have a '\'
                                    StrCatBuff( szLong, szConflict, cchBuffer);
                                    szT[cchBase] = chT;
                                }
                                StrCatBuff( szLong, szFileName, cchBuffer);
                                hr = S_OK;
                            }

                        } else {
        #ifndef UNICODE
                            WCHAR *szwT = new WCHAR[MAX_PATH];
                            if ( szwT && 
                                 MultiByteToWideChar( CP_ACP, 0, szShort, -1, szwT, MAX_PATH ) )
                                pidl = s_pfnILCreate( szwT );
                            delete szwT;
        #else
                            pidl = s_pfnILCreate( szShort );
        #endif
                            if ( pidl != NULL ) {
                                // Now we get the shell to turn the item id list back into 
                                // a path rich in long file names, which is our canonical form
                                if ( SHGetPathFromIDList( pidl, szT ) ) {
                                    if ( szLong != NULL ) {
#ifdef UNICODE
                                        LPWSTR szLongW;
                                        hr = Ansi2Unicode( szT, &szLongW );
                                        if ( SUCCEEDED(hr) ) {
                                            StrCpyNW( szLong, szLongW, cchBuffer );
                                            delete szLongW;
                                        }
#else
                                        //BUFFER OVERRUN lstrcpyA( szLong, szT );
                                        StrCpyN( szLong, szT, cchBuffer );
                                        hr = S_OK;
#endif
                                    }
                                }
                                s_pfnILFree( pidl );
                            } // if we got the pidl
                        } // else we're getting shell32 to do the dirty-work
                    } // if we got the full path/file name
                } // else we can't use GetLongPathName

                delete szT;
            } // if we can get out temp string
        } 
        FreeLibrary( hmodS32 );
        FreeLibrary( hmodK32 );
    }

    return ((hr==S_OK)? lstrlen(szLong) : 0);
}

STDAPI_(DWORD) CDLGetLongPathNameA( LPSTR szLong, LPCSTR szShort, DWORD cchBuffer)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Dword,
                "CDLGetLongPathNameA",
                "%.80q, %.80q, %#x",
                szLong, szShort, cchBuffer
                ));
    HRESULT hr;
                
    if (!szShort || !szLong)
    {
        hr = E_FAIL;
        DEBUG_LEAVE(hr);
        return hr;
    }
#ifndef UNICODE
    hr = s_CDLGetLongPathName( szLong, szShort, cchBuffer );

    DEBUG_LEAVE(hr);
    return hr;
#else
    LPWSTR szShortW;
    TCHAR  szLongT[MAX_PATH];

    hr = Ansi2Unicode( szShort, &szShortW );
    if ( SUCCEEDED(hr) ) {
        hr = s_CDLGetLongPathName( szLongT, szShortW, MAX_PATH );
        if ( SUCCEEDED(hr) ) {
            LPSTR szLongA;
            hr = Unicode2Ansi( szLongT, &szLongA );
            if ( SUCCEEDED(hr) ) {
                lstrcpynA( szLong, szLongA, cchBuffer );
                delete szLongA;
            }
        }
        delete szShortW;
    }

    DEBUG_LEAVE(hr);
    return hr;
#endif
}

STDAPI_(DWORD) CDLGetLongPathNameW( LPWSTR szLong, LPCWSTR szShort, DWORD cchBuffer)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Dword,
                "CDLGetLongPathNameW",
                "%.80q, %.80q, %#x",
                szLong, szShort, cchBuffer
                ));
    HRESULT hr;

    if (!szShort || !szLong)
    {
        hr = E_FAIL;
        DEBUG_LEAVE(hr);
        return hr;
    }
    
#ifdef UNICODE
    hr = s_CDLGetLongPathName( szLong, szShort, cchBuffer );

    DEBUG_LEAVE(hr);
    return hr;
#else
    LPSTR szShortA;
    TCHAR  szLongT[MAX_PATH];

    hr = Unicode2Ansi( szShort, &szShortA );
    if ( SUCCEEDED(hr) ) {
        hr = s_CDLGetLongPathName( szLongT, szShortA, cchBuffer );
        if ( SUCCEEDED(hr) ) {
            LPWSTR szLongW;
            hr = Ansi2Unicode( szLongT, &szLongW );
            if ( SUCCEEDED(hr) ) {
                StrCpyNW( szLong, szLongW, cchBuffer );
                delete szLongW;
            }
        }
        delete szShortA;
    }

    DEBUG_LEAVE(hr);
    return hr;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\helpers.cxx ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1995                    **
//*********************************************************************
//
//    HELPERS.CPP
//
//    HISTORY:
//    
//    9/01/95        philco        Created.
//
//

#include <cdlpch.h>

BOOL GetEXEName(LPSTR szCmdLine);


///////***********       Helper functions        *********/////////////


/*******************************************************************

    NAME:        Unicode2Ansi
        
    SYNOPSIS:    Converts a unicode widechar string to ansi (MBCS)

    NOTES:        Caller must free out parameter using delete
                    
********************************************************************/
HRESULT Unicode2Ansi(const wchar_t *src, char ** dest)
{
    if ((src == NULL) || (dest == NULL))
        return E_INVALIDARG;

    // find out required buffer size and allocate it.
    int len = WideCharToMultiByte(CP_ACP, 0, src, -1, NULL, 0, NULL, NULL);
    *dest = new char [len*sizeof(char)];
    if (!*dest)
        return E_OUTOFMEMORY;

    // Now do the actual conversion
    if ((WideCharToMultiByte(CP_ACP, 0, src, -1, *dest, len*sizeof(char), 
                                                            NULL, NULL)) != 0)
        return S_OK; 
    else
        return E_FAIL;
}


/*******************************************************************

    NAME:        Ansi2Unicode
        
    SYNOPSIS:    Converts an ansi (MBCS) string to unicode.

    Notes:        Caller must free out parameter using delete
                        
********************************************************************/
HRESULT Ansi2Unicode(const char * src, wchar_t **dest)
{
    if ((src == NULL) || (dest == NULL))
        return E_INVALIDARG;

    // find out required buffer size and allocate it
    int len = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, src, -1, NULL, 0);
    *dest = new WCHAR [len*sizeof(WCHAR)];
    if (!*dest)
        return E_OUTOFMEMORY;

    // Do the actual conversion.
    if ((MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, src, -1, *dest, 
                                                    len*sizeof(wchar_t))) != 0)
        return S_OK; 
    else
        return E_FAIL;
}


/*******************************************************************

    NAME:        ConvertANSItoCLSID
        
    SYNOPSIS:    Converts an ANSI string to a CLSID structure (address
                of which is passed by caller as an [out] parameter)
                    
********************************************************************/
HRESULT ConvertANSItoCLSID(const char *pszCLSID, CLSID * clsid)
{
    ASSERT(pszCLSID != NULL);
    ASSERT(clsid != NULL);

    HRESULT hr = S_OK;
    LPOLESTR wcstr = NULL;

    // Since OLE is Unicode only, we need to convert pszClsid to Unicode.
    hr = Ansi2Unicode(pszCLSID, &wcstr);
    if (FAILED(hr))
        goto cleanup;

    // Get CLSID from string
    hr = CLSIDFromString(wcstr, clsid);
    if (FAILED(hr))
        goto cleanup;

cleanup:
    if (wcstr != NULL) 
        delete wcstr;   // Delete unicode string.  We're done.
    return hr;
}

/*******************************************************************

    NAME:        ConvertFriendlyANSItoCLSID
        
    SYNOPSIS:    Works like ConvertANSItoCLSID but allows prefix
                 of "clsid:" CLSID is passed as [out]
                 parameter.
   
********************************************************************/
HRESULT ConvertFriendlyANSItoCLSID(char *pszCLSID, CLSID * clsid)
{
    static const char *szClsid = "clsid:";
    ASSERT(pszCLSID != NULL);
    ASSERT(clsid != NULL);
    
    HRESULT hr = S_OK;

    // try OLE form.
    hr = ConvertANSItoCLSID(pszCLSID,clsid);
    if (SUCCEEDED(hr))
        goto cleanup;

    // try for prefix "clsid:"

    if (StrCmpNA(pszCLSID, szClsid, lstrlenA(szClsid)) == 0) {

        hr = ConvertANSItoCLSID(pszCLSID + lstrlenA(szClsid), clsid);
        if (SUCCEEDED(hr))
            goto cleanup;

        // construct COM form of clsid:
        LPSTR szTmp = NULL;
        szTmp = new char[lstrlenA(pszCLSID) - lstrlenA(szClsid) + 2 + 1];
        if (!szTmp) {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
        lstrcpyA(szTmp,"{");
        lstrcatA(szTmp,pszCLSID + lstrlenA(szClsid));
        lstrcatA(szTmp,"}");

        hr = ConvertANSItoCLSID(szTmp,clsid);
        delete [] szTmp;
        if (SUCCEEDED(hr))
            goto cleanup;
    }
    
    // error code passes through
    
cleanup:

    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: GetExtnAndBaseFileName
//
// Parameters:
//    in szName: a filename or URL
//  out update pbasefilename to point into this szName
//
//    Returns:
//    out: extn
// ---------------------------------------------------------------------------
FILEXTN GetExtnAndBaseFileName( char *szName, char **plpBaseFileName)
{
    char *pCur = szName;
    char *pExt = NULL;
    char szExtCopy[4];
    FILEXTN extn = FILEXTN_UNKNOWN;

    const static char *szCAB = "CAB";
    const static char *szINF = "INF";
    const static char *szDLL = "DLL";
    const static char *szOCX = "OCX";
    const static char *szEXE = "EXE";
    const static char *szOSD = "OSD";
    const static char *szCAT = "CAT";

    *plpBaseFileName = szName;

    // find location of last '.' and '/' in name
    for (;*pCur; *pCur++) {
        if (*pCur == '.')
            pExt = pCur+1;
        if ((*pCur == '/') || (*pCur == '\\'))
            *plpBaseFileName = pCur+1;
    }

    if (!pExt || !*pExt) { // if no '.' or as last char
        extn = FILEXTN_NONE;
        goto Exit;
    }

    StrNCpy(szExtCopy, pExt, 4);

    CharUpperBuff(szExtCopy, 3);

    if (lstrcmp(szExtCopy, szCAB)     == 0) {
        extn = FILEXTN_CAB;
        goto Exit;
    }

    if (lstrcmp(szExtCopy, szOCX)     == 0) {
        extn = FILEXTN_OCX;
        goto Exit;
    }

    if (lstrcmp(szExtCopy, szDLL)     == 0) {
        extn = FILEXTN_DLL;
        goto Exit;
    }

    if (lstrcmp(szExtCopy, szEXE)     == 0) {
        extn = FILEXTN_EXE;
        goto Exit;
    }

    if (lstrcmp(szExtCopy, szINF)     == 0) {
        extn = FILEXTN_INF;
        goto Exit;
    }

    if (lstrcmp(szExtCopy, szOSD)     == 0) {
        extn = FILEXTN_OSD;
        goto Exit;
    }

    if (lstrcmp(szExtCopy, szCAT)     == 0) {
        extn = FILEXTN_CAT;
        goto Exit;
    }

Exit:

    return extn;
}

// ---------------------------------------------------------------------------
// %%Function: GetVersionFromString
//
//    converts version in text format (a,b,c,d) into two dwords (a,b), (c,d)
//    The printed version number is of format a.b.d (but, we don't care)
// ---------------------------------------------------------------------------
HRESULT
GetVersionFromString(const char *szBuf, LPDWORD pdwFileVersionMS, LPDWORD pdwFileVersionLS, char cSeperator)
{
    // cdl.h defines cSeperator as a default parameter: ','
    const char *pch = szBuf;
    char ch;
    char szMaxString[30];

    *pdwFileVersionMS = 0;
    *pdwFileVersionLS = 0;

    if (!pch)            // default to zero if none provided
        return S_OK;
    wsprintf(szMaxString, "-1%c-1%c-1%c-1", cSeperator, cSeperator, cSeperator);

    if (lstrcmp(pch, szMaxString) == 0) {
        *pdwFileVersionMS = 0xffffffff;
        *pdwFileVersionLS = 0xffffffff;
        return S_OK;
    }

    USHORT n = 0;

    USHORT a = 0;
    USHORT b = 0;
    USHORT c = 0;
    USHORT d = 0;

    enum HAVE { HAVE_NONE, HAVE_A, HAVE_B, HAVE_C, HAVE_D } have = HAVE_NONE;


    for (ch = *pch++;;ch = *pch++) {

        if ((ch == cSeperator) || (ch == '\0')) {

            switch (have) {

            case HAVE_NONE:
                a = n;
                have = HAVE_A;
                break;

            case HAVE_A:
                b = n;
                have = HAVE_B;
                break;

            case HAVE_B:
                c = n;
                have = HAVE_C;
                break;

            case HAVE_C:
                d = n;
                have = HAVE_D;
                break;

            case HAVE_D:
                return E_INVALIDARG; // invalid arg
            }

            if (ch == '\0') {
                // all done convert a,b,c,d into two dwords of version

                *pdwFileVersionMS = ((a << 16)|b);
                *pdwFileVersionLS = ((c << 16)|d);

                return S_OK;
            }

            n = 0; // reset

        } else if ( (ch < '0') || (ch > '9'))
            return E_INVALIDARG;    // invalid arg
        else
            n = n*10 + (ch - '0');


    } /* end forever */

    // NEVERREACHED
}

//************************************************************
// CheckFileImplementsCLSID
//
// checks if a clsid is implemented by the given file
// Return S_OK on success.
//
// pszFileName:  Full path to the file whose clsid we
//               desire.
//  rClsid:    clsid to check
//

HRESULT CheckFileImplementsCLSID(const char *pszFileName, REFCLSID rClsid)
{
    LPTYPELIB ptlib = NULL;
    LPTYPEINFO lpTypeInfo = NULL;
    LPTYPEATTR lpTypeAttr = NULL;
    WCHAR puszFileName[MAX_PATH];  // unicode string
    HRESULT hr = S_OK;

    //
    // LoadTypeLib() needs the string in unicode.
    //
    MultiByteToWideChar(CP_ACP, 0, pszFileName, -1, puszFileName, sizeof(puszFileName) / sizeof(wchar_t));

    hr = LoadTypeLib(puszFileName, &ptlib);

    if (FAILED(hr))
        return hr;

    hr = ptlib->GetTypeInfoOfGuid(rClsid, &lpTypeInfo);

    if (SUCCEEDED(hr)) {

        if (S_OK != (hr = lpTypeInfo->GetTypeAttr(&lpTypeAttr))) {
            goto Exit;
        }

        if (TKIND_COCLASS == lpTypeAttr->typekind) {

            Assert(IsEqualGUID( lpTypeAttr->guid, rClsid));

            // success
            goto Exit;
        }

    
    }


Exit:

    if (lpTypeAttr != NULL) lpTypeInfo->ReleaseTypeAttr(lpTypeAttr);
    if (lpTypeInfo != NULL) lpTypeInfo->Release();
    if (ptlib != NULL)      ptlib->Release();

    return hr;
}

HRESULT CDLDupWStr( LPWSTR *pszwstrDst, LPCWSTR szwSrc )
{
    HRESULT hr = S_OK;

    *pszwstrDst = new WCHAR[lstrlenW(szwSrc)+1];
    if (*pszwstrDst)
        StrCpyW( *pszwstrDst, szwSrc );
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

extern CMutexSem g_mxsCodeDownloadGlobals;

HRESULT 
MakeUniqueTempDirectory(LPCSTR szTempDir, LPSTR szUniqueTempDir, int iLen)
{
    int n = 1;
    HRESULT hr = S_OK;

    //execute entire function under critical section
    CLock lck(g_mxsCodeDownloadGlobals);

    do {

        if (n > 100)    // avoid infinite loop!
            break;

        wnsprintf(szUniqueTempDir, iLen-1, "%s%s%d.tmp", szTempDir, "ICD", n++);


    } while (GetFileAttributes(szUniqueTempDir) != -1);

    if (!CreateDirectory(szUniqueTempDir, NULL)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}

HRESULT
ComposeHackClsidFromMime(LPSTR szHackMimeType, int iLen, LPCSTR szClsid)
{
    HRESULT hr = S_OK;
    char szID[MAX_PATH];
    LPSTR pchDest = szID;

    for (LPCSTR pchSrc = szClsid; *pchDest = *pchSrc; pchSrc++,pchDest++) {

        if (*pchSrc == '/') {
            *pchDest++ = '_';   
            *pchDest++ = '2';   
            *pchDest++ = 'F';   
            *pchDest = '_'; 
            
        }
    }

    wnsprintf(szHackMimeType, iLen-1, "&CLSID=%s", szID);

    return hr;
}


HRESULT
RemoveDirectoryAndChildren(LPCSTR szDir)
{
    HRESULT hr = S_OK;
    HANDLE hf = INVALID_HANDLE_VALUE;
    char szBuf[MAX_PATH];
    WIN32_FIND_DATA fd;

    if (RemoveDirectory(szDir))
        goto Exit;

    // ha! we have a case where the directory is probbaly not empty

    StrNCpy(szBuf, szDir, sizeof(szBuf));
    StrCatBuff(szBuf, "\\*", sizeof(szBuf));

    if ((hf = FindFirstFile(szBuf, &fd)) == INVALID_HANDLE_VALUE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    do {

        if ( (lstrcmp(fd.cFileName, ".") == 0) || 
             (lstrcmp(fd.cFileName, "..") == 0))
            continue;

        wnsprintf(szBuf, sizeof(szBuf)-1, "%s\\%s", szDir, fd.cFileName);
        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            SetFileAttributes(szBuf, 
                FILE_ATTRIBUTE_DIRECTORY|FILE_ATTRIBUTE_NORMAL);

            if (FAILED((hr=RemoveDirectoryAndChildren(szBuf)))) {
                goto Exit;
            }

        } else {

            SetFileAttributes(szBuf, FILE_ATTRIBUTE_NORMAL);
            if (!DeleteFile(szBuf)) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }
        }


    } while (FindNextFile(hf, &fd));


    if (GetLastError() != ERROR_NO_MORE_FILES) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    if (hf != INVALID_HANDLE_VALUE) {
        FindClose(hf);
        hf = INVALID_HANDLE_VALUE;
    }

    // here if all subdirs/children removed
    /// re-attempt to remove the main dir
    if (!RemoveDirectory(szDir)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

Exit:

    if (hf != INVALID_HANDLE_VALUE)
        FindClose(hf);

    return hr;
}


HRESULT IsExtnHandled(LPSTR pszExt)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "IsExtnHandled",
                "%.80q",
                pszExt
                ));
                
    HRESULT hr = REGDB_E_CLASSNOTREG;

    HKEY        hkRoot = HKEY_CLASSES_ROOT;
    char        szFileExt[MAX_PATH];
    DWORD       cbFileExt = sizeof(szFileExt);

    char szCmdLine[2*MAX_PATH];
    char szProgID[2*MAX_PATH];
    LONG  cbProgID = sizeof(szProgID);
    DWORD dwType;
    DWORD dwLen = sizeof(szCmdLine);
    HKEY hkeyCmd = 0;

    if (pszExt[0] == '\0')
    {
        goto Exit;
    }

    StrNCpy(szFileExt,pszExt, sizeof(szFileExt));

    Assert((szFileExt[0] == '.'));

    // the entry begins with '.' so it may be a file extension
    // query the value (which is the ProgID)

    if (RegQueryValue(hkRoot, szFileExt, szProgID, &cbProgID) == ERROR_SUCCESS)
    {
        // we got the value (ProgID), now query for the CLSID
        // string and convert it to a CLSID
        StrCatBuff(szProgID, "\\Shell\\Open\\Command", sizeof(szProgID));

        if ( (RegOpenKeyEx(HKEY_CLASSES_ROOT, szProgID, 0, KEY_QUERY_VALUE, &hkeyCmd) == ERROR_SUCCESS) &&
             (SHQueryValueEx(hkeyCmd, NULL, NULL, &dwType, &szCmdLine, &dwLen) == ERROR_SUCCESS) && dwLen)

        {
            if (GetEXEName(szCmdLine)) {
                hr = S_OK;
            }
        }
    }

Exit:

    if (hkeyCmd)
        RegCloseKey(hkeyCmd);

    DEBUG_LEAVE(hr);
    return hr;
}

#define SZMIMESIZE_MAX  128

HRESULT IsMimeHandled(LPCWSTR pwszMime)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "IsMimeHandled",
                "%.80wq",
                pwszMime
                ));
                
    HRESULT hr = S_OK;
    HKEY hMimeKey = NULL;
    DWORD dwType;
    char szValue[MAX_PATH];
    DWORD dwValueLen = MAX_PATH;
    static char szMimeKey[]     = "MIME\\Database\\Content Type\\";
    static char szExtension[]     = "Extension";
    const ULONG ulMimeKeyLen    = ((sizeof(szMimeKey)/sizeof(char))-1);
    char szKey[SZMIMESIZE_MAX + ulMimeKeyLen];
    LPSTR pszMime = NULL;

    if (SUCCEEDED((hr=::Unicode2Ansi(pwszMime, &pszMime)))) {

        StrNCpy(szKey, szMimeKey, sizeof(szKey));
        StrCatBuff(szKey, pszMime, sizeof(szKey));

        hr = REGDB_E_READREGDB;

        if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, KEY_QUERY_VALUE, &hMimeKey) == ERROR_SUCCESS) {

            if (RegQueryValueEx(hMimeKey
                    , szExtension
                    , NULL
                    , &dwType
                    , (LPBYTE)szValue
                    , &dwValueLen) == ERROR_SUCCESS) {

                hr = IsExtnHandled(szValue);
            }
        }
    }

    if (hMimeKey) {
        RegCloseKey(hMimeKey);
    }

    SAFEDELETE(pszMime);

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\fdidll.c ===
/*
 *  FDIDLL.C -- FDI interface using CABINET.DLL
 *
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1997
 *  All Rights Reserved.
 *
 *  Author:
 *      Mike Sliger
 *
 *  History:
 *      21-Jan-1997 msliger Initial version
 *      24-Jan-1997 msliger Changed to public include file
 *
 *  Overview:
 *      This code is a wrapper which provides access to the actual FDI code
 *      in CABINET.DLL.  CABINET.DLL dynamically loads/unloads as needed.
 */
 
#include <windows.h>

#include "fdi.h"

static HINSTANCE hCabinetDll;   /* DLL module handle */

/* pointers to the functions in the DLL */

static HFDI (FAR DIAMONDAPI *pfnFDICreate)(
        PFNALLOC            pfnalloc,
        PFNFREE             pfnfree,
        PFNOPEN             pfnopen,
        PFNREAD             pfnread,
        PFNWRITE            pfnwrite,
        PFNCLOSE            pfnclose,
        PFNSEEK             pfnseek,
        int                 cpuType,
        PERF                perf);
static BOOL (FAR DIAMONDAPI *pfnFDIIsCabinet)(
        HFDI                hfdi,
        INT_PTR             hf,
        PFDICABINETINFO     pfdici);
static BOOL (FAR DIAMONDAPI *pfnFDICopy)(
        HFDI                hfdi,
        char                *pszCabinet,
        char                *pszCabPath,
        int                 flags,
        PFNFDINOTIFY        pfnfdin,
        PFNFDIDECRYPT       pfnfdid,
        void                *pvUser);
static BOOL (FAR DIAMONDAPI *pfnFDIDestroy)(
        HFDI                hfdi);


/*
 *  FDICreate -- Create an FDI context
 *
 *  See fdi_int.h for entry/exit conditions.
 */

HFDI FAR DIAMONDAPI FDICreate(PFNALLOC pfnalloc,
                              PFNFREE  pfnfree,
                              PFNOPEN  pfnopen,
                              PFNREAD  pfnread,
                              PFNWRITE pfnwrite,
                              PFNCLOSE pfnclose,
                              PFNSEEK  pfnseek,
                              int      cpuType,
                              PERF     perf)
{
    HFDI hfdi;

    hCabinetDll = LoadLibrary("CABINET");
    if (hCabinetDll == NULL)
    {
        return(NULL);
    }

    pfnFDICreate = (void *) GetProcAddress(hCabinetDll,"FDICreate");
    pfnFDICopy = (void *) GetProcAddress(hCabinetDll,"FDICopy");
    pfnFDIIsCabinet = (void *) GetProcAddress(hCabinetDll,"FDIIsCabinet");
    pfnFDIDestroy = (void *) GetProcAddress(hCabinetDll,"FDIDestroy");

    if ((pfnFDICreate == NULL) ||
        (pfnFDICopy == NULL) ||
        (pfnFDIIsCabinet == NULL) ||
        (pfnFDIDestroy == NULL))
    {
        FreeLibrary(hCabinetDll);

        return(NULL);
    }

    hfdi = pfnFDICreate(pfnalloc,pfnfree,
            pfnopen,pfnread,pfnwrite,pfnclose,pfnseek,cpuType,perf);
    if (hfdi == NULL)
    {
        FreeLibrary(hCabinetDll);
    }

    return(hfdi);
}


/*
 *  FDIIsCabinet -- Determines if file is a cabinet, returns info if it is
 *
 *  See fdi_int.h for entry/exit conditions.
 */

BOOL FAR DIAMONDAPI FDIIsCabinet(HFDI            hfdi,
                                 INT_PTR         hf,
                                 PFDICABINETINFO pfdici)
{
    if (pfnFDIIsCabinet == NULL)
    {
        return(FALSE);
    }

    return(pfnFDIIsCabinet(hfdi,hf,pfdici));
}


/*
 *  FDICopy -- extracts files from a cabinet
 *
 *  See fdi_int.h for entry/exit conditions.
 */

BOOL FAR DIAMONDAPI FDICopy(HFDI          hfdi,
                            char         *pszCabinet,
                            char         *pszCabPath,
                            int           flags,
                            PFNFDINOTIFY  pfnfdin,
                            PFNFDIDECRYPT pfnfdid,
                            void         *pvUser)
{
    if (pfnFDICopy == NULL)
    {
        return(FALSE);
    }

    return(pfnFDICopy(hfdi,pszCabinet,pszCabPath,flags,pfnfdin,pfnfdid,pvUser));
}


/*
 *  FDIDestroy -- Destroy an FDI context
 *
 *  See fdi_int.h for entry/exit conditions.
 */

BOOL FAR DIAMONDAPI FDIDestroy(HFDI hfdi)
{
    BOOL rc;

    if (pfnFDIDestroy == NULL)
    {
        return(FALSE);
    }

    rc = pfnFDIDestroy(hfdi);
    if (rc == TRUE)
    {
        FreeLibrary(hCabinetDll);
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\isctrl.cxx ===
#include <cdlpch.h>
#pragma hdrstop

#include "verp.h"
#include <mstask.h>
#include <pkgguid.h>

extern LCID g_lcidBrowser;     // default to english
extern char g_szBrowserPrimaryLang[];
// global that encapsulates delay-loaded version.dll
CVersion g_versiondll;
extern BOOL g_bRunOnWin95;

HRESULT NeedForceLanguageCheck(HKEY hkeyCLSID, CLocalComponentInfo *plci);
BOOL    SniffStringFileInfo( LPSTR szFileName, LPCTSTR lpszSubblock, DWORD *pdw = NULL );
HRESULT IsDistUnitLocallyInstalledSxS(LPCWSTR wszDistUnit, LPCWSTR wszClsid, DWORD dwFileVersionMS, DWORD dwFileVersionLS, CLocalComponentInfo * plci);
void ExtractVersion(char *pszDistUnit, DWORD *pdwVerMS, DWORD *pdwVerLS);

DWORD SearchPathA_Wrap(
  LPCSTR lpPath,      // search path
  LPCSTR lpFileName,  // file name
  LPCSTR lpExtension, // file extension
  DWORD nBufferLength, // size of buffer
  LPSTR lpBuffer,     // found file name buffer
  LPSTR *lpFilePart   // file component
)
{
    DWORD dwRet = SearchPath(lpPath, lpFileName, lpExtension, nBufferLength, lpBuffer, lpFilePart);

    //Trap the possible failures.
    if (dwRet && (dwRet < nBufferLength))
    {
        ASSERT(lpFilePart); //All the current calls to this definitely pass this in.
        if (! *lpFilePart)
        {
            //IE6 bug 19001
            // If a dir is passed in in lpFileName terminating with a "/", then this happens ->
            // to avoid the subsequent crash in MakeDestDir, make this point to the terminating 
            // NULL character.  This return value would have made better sense from SearchPath, methinx.
            *lpFilePart = lpBuffer+dwRet;
        }
    }
    else
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        dwRet = 0; //simulate failure even for insufficient buffer.  Unlikely with INTERNET_MAX_PATH,
                // since we would have failed much before this in urlmon download code, but be safe 
                // and not assume success as the code does prior to this.
    }

    return dwRet;
}       

// ---------------------------------------------------------------------------
// %%Function: CLocalComponentInfo::CLocalComponentInfo
// ---------------------------------------------------------------------------
CLocalComponentInfo::CLocalComponentInfo()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CLocalComponentInfo::CLocalComponentInfo",
                "this=%#x",
                this
                ));
                
    szExistingFileName[0] = '\0';
    pBaseExistingFileName = NULL;
    lpDestDir = NULL;
    dwLocFVMS = 0;
    dwLocFVLS = 0;
    ftLastModified.dwLowDateTime = 0;
    ftLastModified.dwHighDateTime = 0;
    lcid = g_lcidBrowser;

    bForceLangGetLatest = FALSE;

    pbEtag = NULL;

    dwAvailMS = 0;
    dwAvailLS = 0;

    DEBUG_LEAVE(0);
}  // CLocalComponentInfo

// ---------------------------------------------------------------------------
// %%Function: CLocalComponentInfo::~CLocalComponentInfo
// ---------------------------------------------------------------------------
CLocalComponentInfo::~CLocalComponentInfo()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CLocalComponentInfo::~CLocalComponentInfo",
                "this=%#x",
                this
                ));
                
    SAFEDELETE(lpDestDir);

    SAFEDELETE(pbEtag);

    DEBUG_LEAVE(0);
}  // ~CLocalComponentInfo

// ---------------------------------------------------------------------------
// %%Function: CLocalComponentInfo::MakeDestDir
// ---------------------------------------------------------------------------
HRESULT
CLocalComponentInfo::MakeDestDir()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CLocalComponentInfo::MakeDestDir",
                "this=%#x",
                this
                ));

    HRESULT hr = S_OK;

    ASSERT(pBaseExistingFileName);

    if (szExistingFileName[0]) {

        DWORD cbLen = (DWORD) (pBaseExistingFileName - szExistingFileName);


        lpDestDir = new char[cbLen + 1];

        if (lpDestDir) {
            StrNCpy(lpDestDir, szExistingFileName, cbLen);
        } else {
            hr = E_OUTOFMEMORY;
        }
    }

    DEBUG_LEAVE(hr);
    return hr;

}  // ~MakeDestDir


// ---------------------------------------------------------------------------
// %%Function: CModuleUsage::CModuleUsage
// CModuleUsage is the basic download obj.
// ---------------------------------------------------------------------------
CModuleUsage::CModuleUsage(LPCSTR szFileName, DWORD muflags, HRESULT *phr)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CModuleUsage::CModuleUsage",
                "this=%#x, %.80q, %x, %#x",
                this, szFileName, muflags, phr
                ));

    m_szFileName = NULL;

    if (szFileName) {
        CHAR szCanonical[MAX_PATH];

        if ( CDLGetLongPathNameA( szCanonical, szFileName, MAX_PATH ) != 0 )
            m_szFileName = new char [lstrlen(szCanonical)+1];

        if (m_szFileName) {
            lstrcpy(m_szFileName, szCanonical);
        }
        else
        {
            // CDLGetLongPathName failed, so we are on a platform that
            // doesn't support it, and we can't guess what the right long
            // pathname is. Just use the short one
            m_szFileName = new char [lstrlen(szFileName)+1];

            if (m_szFileName) {
                lstrcpy(m_szFileName, szFileName);
            }
            else {
                *phr = E_OUTOFMEMORY;
            }
        }
    }

    m_dwFlags = muflags;

    DEBUG_LEAVE(0);
}  // CModuleUsage

// ---------------------------------------------------------------------------
// %%Function: CModuleUsage::~CModuleUsage
// ---------------------------------------------------------------------------
CModuleUsage::~CModuleUsage()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CModuleUsage::~CModuleUsage",
                "this=%#x",
                this
                ));
                
    if (m_szFileName)
        SAFEDELETE(m_szFileName);

    DEBUG_LEAVE(0);
}  // ~CModuleUsage

// ---------------------------------------------------------------------------
// %%Function: CModuleUsage::Update(LPCSTR lpClientName)
// ---------------------------------------------------------------------------
HRESULT
CModuleUsage::Update(LPCSTR lpClientName)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CModuleUsage::Update",
                "this=%#x, %.80q",
                this, lpClientName
                ));

    HRESULT hr = ::UpdateModuleUsage(m_szFileName,
                            lpClientName, NULL,
                            m_dwFlags);

    DEBUG_LEAVE(hr);
    return hr;
}  // ~CModuleUsage

HRESULT
GetVersionHint(HKEY hkeyVersion, DWORD *pdwVersionMS, DWORD *pdwVersionLS)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "GetVersionHint",
                "%#x, %#x, %#x",
                hkeyVersion, pdwVersionMS, pdwVersionLS
                ));
                
    DWORD Size = MAX_PATH;
    char szVersionBuf[MAX_PATH];
    DWORD dwType;
    HRESULT hr = S_OK;

    *pdwVersionMS = 0;
    *pdwVersionLS = 0;

    DWORD lResult = ::RegQueryValueEx(hkeyVersion, NULL, NULL, &dwType, 
                        (unsigned char *)szVersionBuf, &Size);

    if (lResult != ERROR_SUCCESS) {

        // value not found, consider this is always with bad/low version
        // of InstalledVersion

        hr = S_FALSE;
        goto Exit;
    }

    if ( FAILED(GetVersionFromString(szVersionBuf, pdwVersionMS, pdwVersionLS))){
        hr = S_FALSE;
    }

Exit:

    DEBUG_LEAVE(hr);
    return hr;
}


/*******************************************************************

    NAME:        CheckInstalledVersionHint
        
    SYNOPSIS:   Checks for key InstalledVersion under {...}
                If no key then we fail
                once key is present we check version numbers
                S_OK: local version is good enough
                S_FALSE: need update:
                ERROR: not applicable, caller proceeds with InProcServer32
                check.

                [HKCR:clsid]
                    [{...}]
                        [InstalledVersion]
                        Deafult     "1,0,0,1"
                        Path        "c:\foo\foo.ocx"

                The Path is optional, if find we will req update id
                file pointed to by path is missing on client. This is a
                way to robustify if user deletes the file on disk but 
                not the regsitry (unclean uninstall)
                In this case update is needed
                    
********************************************************************/
HRESULT  
CheckInstalledVersionHint(
    HKEY hKeyEmbedding,
    CLocalComponentInfo *plci,
    DWORD dwFileVersionMS,
    DWORD dwFileVersionLS)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CheckInstalledVersionHint",
                "%#x, %#x, %x, %x",
                hKeyEmbedding, plci, dwFileVersionMS, dwFileVersionLS
                ));
                
    HRESULT hr = S_OK;
    DWORD Size = MAX_PATH;
    DWORD dwType =0;
    LONG lResult = ERROR_SUCCESS;

    const static char * szInstalledVersion = "InstalledVersion";
    const static char * szAvailableVersion = "AvailableVersion";
    const static char * szPATH = "Path";
    const static char * szLASTMODIFIED = "LastModified";
    const static char * szETAG = "Etag";

    char szVersionBuf[MAX_PATH];
    char szFileName[MAX_PATH];
    HKEY hKeyVersion = 0;
    HKEY hkeyAvailableVersion = 0;

    DWORD dwLocFVMS = 0;
    DWORD dwLocFVLS = 0;
    char szLastMod[INTERNET_RFC1123_BUFSIZE+1];

    if (RegOpenKeyEx(hKeyEmbedding, szAvailableVersion, 0, 
            KEY_READ, &hkeyAvailableVersion) == ERROR_SUCCESS) {

        DWORD dwAvailMS = 0;
        DWORD dwAvailLS = 0;

        if ( GetVersionHint(hkeyAvailableVersion, &dwAvailMS, &dwAvailLS) == S_OK){

            plci->dwAvailMS = dwAvailMS;
            plci->dwAvailLS = dwAvailLS;
        }

    }


    lResult = ::RegOpenKeyEx(hKeyEmbedding, szInstalledVersion, 0, 
                        KEY_READ, &hKeyVersion);

    if (lResult != ERROR_SUCCESS) {

        // key not found, consider this is regular ActiveX with no hint
        // of InstalledVersion

        hr = HRESULT_FROM_WIN32(lResult);
        goto Exit;
    }

    if ( GetVersionHint(hKeyVersion, &dwLocFVMS, &dwLocFVLS) == S_FALSE){
        hr = S_FALSE;
        goto Exit;
    }

    plci->dwLocFVMS = dwLocFVMS;
    plci->dwLocFVLS = dwLocFVLS;

    Size = INTERNET_RFC1123_BUFSIZE + 1;
    lResult = ::RegQueryValueEx(hKeyVersion, szLASTMODIFIED, NULL, &dwType, 
                        (unsigned char *)szLastMod, &Size);

    if (lResult == ERROR_SUCCESS) {

        SYSTEMTIME st;
        FILETIME ft;
        // convert intenet time to file time
        if (InternetTimeToSystemTimeA(szLastMod, &st, 0) &&
             SystemTimeToFileTime(&st, &ft) ) {

            memcpy(&(plci->ftLastModified), &ft, sizeof(FILETIME));

        }
    }

    Size = 0;
    lResult = ::RegQueryValueEx(hKeyVersion, szETAG, NULL, &dwType, 
                        (unsigned char *)NULL, &Size);
    if (lResult == ERROR_SUCCESS) {
        char *pbEtag = new char [Size];
        if (pbEtag) {
            lResult = ::RegQueryValueEx(hKeyVersion, szETAG, NULL, &dwType, 
                        (unsigned char *)pbEtag, &Size);
            if (lResult == ERROR_SUCCESS)
                plci->pbEtag = pbEtag;
            else
                delete pbEtag;
        }
    }

    // check file versions
    if ((dwFileVersionMS > dwLocFVMS) ||
             ((dwFileVersionMS == dwLocFVMS) &&
                 (dwFileVersionLS > dwLocFVLS)))
                     hr = S_FALSE;


    if (hr == S_OK) {

        // if we seem to have the right version
        // check if the file physically exists on disk
        // the software can specify this by having a PATH="c:\foo\foo.class"

        // if present we will check for physical file existance

        dwType = 0;
        Size = MAX_PATH;
        lResult = ::SHQueryValueEx(hKeyVersion, szPATH, NULL, &dwType, 
                            (unsigned char *)szFileName, &Size);

        if (lResult != ERROR_SUCCESS)
            goto Exit;

        // value present, check if file is present
        if (GetFileAttributes(szFileName) == -1) {

            // if file is not physically present then clear out our
            // local file version. this comes in the way of doing
            // get latest. (ie get latest will assume that if a local file 
            // is present then do If-Modified-Since
            plci->dwLocFVMS = 0;
            plci->dwLocFVLS = 0;

            hr = S_FALSE;
        }
    }

Exit:

    if (hKeyVersion)
        ::RegCloseKey(hKeyVersion);
    if (hkeyAvailableVersion)
        ::RegCloseKey(hkeyAvailableVersion);

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT
CreateJavaPackageManager(IJavaPackageManager **ppPackageManager)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CreateJavaPackageManager",
                "%#x",
                ppPackageManager
                ));
                
    HRESULT hr = S_OK;

    Assert(ppPackageManager);

    if (!(*ppPackageManager)) {
       ICreateJavaPackageMgr *picjpm;

        hr=CoCreateInstance(CLSID_JavaPackageManager,NULL,(CLSCTX_INPROC_SERVER),
            IID_ICreateJavaPackageMgr,(LPVOID *) &picjpm);
        if (SUCCEEDED(hr)) {
            hr = picjpm->GetPackageManager(ppPackageManager);
            picjpm->Release();
        }
    }

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT
IsPackageLocallyInstalled(IJavaPackageManager **ppPackageManager, LPCWSTR szPackageName, 
                            LPCWSTR szNameSpace, DWORD dwVersionMS, DWORD dwVersionLS)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "IsPackageLocallyInstalled",
                "%#x, %.80wq, %.80wq, %x, %x",
                ppPackageManager, szPackageName, szNameSpace, dwVersionMS, dwVersionLS
                ));
                
    HRESULT hr = S_OK;      // assume Ok!
    IJavaPackage *pJavaPkg = NULL;
    DWORD dwLocMS = 0;
    DWORD dwLocLS = 0;

    Assert(ppPackageManager);

    if (!(*ppPackageManager)) {
        hr = CreateJavaPackageManager(ppPackageManager);

        if (FAILED(hr))
            goto Exit;
    }


    if (SUCCEEDED((*ppPackageManager)->GetPackage(szPackageName, szNameSpace,  &pJavaPkg))) {

        Assert(pJavaPkg);

        pJavaPkg->GetVersion(&dwLocMS, &dwLocLS);

        if ((dwVersionMS > dwLocMS) ||
                 ((dwVersionMS == dwLocMS) &&
                     (dwVersionLS > dwLocLS)))
                         hr = S_FALSE;


        BSTR bstrFileName = NULL;
        if (SUCCEEDED(pJavaPkg->GetFilePath(&bstrFileName))) {

            // check if file really exists
            LPSTR szFileName = NULL;

            if (SUCCEEDED(Unicode2Ansi(bstrFileName, &szFileName))) {
                if (GetFileAttributes(szFileName) == -1)
                    hr = S_FALSE;
            } else {
                hr = S_FALSE;
            }
        } else {
            hr = S_FALSE;
        }

        SAFESYSFREESTRING(bstrFileName);
        SAFERELEASE(pJavaPkg);

    } else {
        hr = S_FALSE;
    }

Exit:

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT
AreNameSpacePackagesIntact(HKEY hkeyJava, LPCWSTR lpwszNameSpace, IJavaPackageManager **ppPackageManager)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "AreNameSpacePackagesIntact",
                "%#x, %.80wq, %#x",
                hkeyJava, lpwszNameSpace, ppPackageManager
                ));
                
    int iValue = 0;
    DWORD dwType = REG_SZ;
    DWORD dwValueSize = MAX_PATH;
    char szPkgName[MAX_PATH];
    HRESULT hr = S_OK;

    while (
        RegEnumValue(hkeyJava, iValue++, szPkgName, &dwValueSize, 0,
            &dwType, NULL, NULL) == ERROR_SUCCESS) {

        LPWSTR lpwszPkgName = NULL;

        dwValueSize = MAX_PATH; // reset

        if ( (Ansi2Unicode(szPkgName,&lpwszPkgName) == S_OK)
            && ((IsPackageLocallyInstalled
            (ppPackageManager, lpwszPkgName, lpwszNameSpace, 0,0) != S_OK)) ) {

            hr = S_FALSE;
            SAFEDELETE(lpwszPkgName);
            break;
        }
        SAFEDELETE(lpwszPkgName);
    }

    DEBUG_LEAVE(hr);
    return hr;
}


HRESULT
ArePackagesIntact(HKEY hkeyContains)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "ArePackagesIntact",
                "%#x",
                hkeyContains
                ));
                
    HRESULT hr = S_OK;
    HKEY hkeyJava = 0;
    const static char * szJava = "Java";
    IJavaPackageManager *pPackageManager = NULL;
    DWORD iSubKey = 0;
    DWORD dwSize = MAX_PATH;
    DWORD lResult;
    char szNameSpace[MAX_PATH];

    // first validate pkgs in the global namespace
    if (RegOpenKeyEx( hkeyContains, szJava,
            0, KEY_READ, &hkeyJava) == ERROR_SUCCESS) {

        hr = AreNameSpacePackagesIntact(hkeyJava, NULL, &pPackageManager);

        if (hr != S_OK)
            goto Exit;
    } else {
        goto Exit;
    }

    // validate pkgs in each of other namespaces, if any
    while ( (lResult = RegEnumKeyEx(hkeyJava, iSubKey++, szNameSpace, &dwSize, NULL, NULL, NULL, NULL)) == ERROR_SUCCESS) {

        dwSize = MAX_PATH;
        HKEY hkeyNameSpace = 0;

        if (RegOpenKeyEx( hkeyJava, szNameSpace,
                0, KEY_READ, &hkeyNameSpace) == ERROR_SUCCESS) {

            LPWSTR lpwszNameSpace = NULL;

            if (Ansi2Unicode(szNameSpace,&lpwszNameSpace) == S_OK)
                hr = AreNameSpacePackagesIntact(hkeyNameSpace, lpwszNameSpace,
                    &pPackageManager);

            SAFEDELETE(lpwszNameSpace);
            RegCloseKey(hkeyNameSpace);

            if (hr != S_OK)
                goto Exit;
        }
    }


    if (lResult != ERROR_NO_MORE_ITEMS) {
        hr = HRESULT_FROM_WIN32(lResult);
        //FALLTHRU goto Exit;
    }

Exit:

    SAFERELEASE(pPackageManager);

    if (hkeyJava)
        RegCloseKey(hkeyJava);

    DEBUG_LEAVE(hr);
    return hr;
}

/*******************************************************************

NAME:        IsDistUnitLocallyInstalled
    
SYNOPSIS:   S_OK - distribution is installed correctly
            S_FALSE - distribution unit entry exists, but not installed
                      or installed incorrectly
            E_FAIL - distribution unit doesn't exit (no entry for it)
  
********************************************************************/

HRESULT
IsDistUnitLocallyInstalled(
    LPCWSTR szDistUnit,
    DWORD dwFileVersionMS,
    DWORD dwFileVersionLS,
    CLocalComponentInfo *plci,
    LPSTR szDestDirHint,
    LPBOOL pbParanoidCheck,
    DWORD flags)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "IsDistUnitLocallyInstalled",
                "%.80wq, %x, %x, %#x, %.80q, %#x, %x",
                szDistUnit, dwFileVersionMS, dwFileVersionLS, plci, szDestDirHint, pbParanoidCheck, flags
                ));
                
    LPSTR pszDist = NULL;
    HRESULT hr = S_FALSE;
    HKEY hkeyDist = 0, hkeyThisDist = 0;
    HKEY hkeyContains = 0;
    HKEY hkeyFiles = 0;
    HKEY hkeyDepends = 0;
    const static char * szContains = "Contains";
    const static char * szFiles = "Files";
    const static char * szDistUnitStr = "Distribution Units";
    LONG lResult = ERROR_SUCCESS;
    char szFileName[MAX_PATH];
    ULONG cbSize = MAX_PATH;
    DWORD dwType = REG_SZ;

    if (pbParanoidCheck) {
        *pbParanoidCheck = FALSE;
    }

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_DIST_UNITS,
                          0, KEY_READ, &hkeyDist);

    if (lResult != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(REGDB_E_KEYMISSING);
        goto Exit;
    }

    if (FAILED((hr=::Unicode2Ansi(szDistUnit, &pszDist))))
    {
        goto Exit;
    }

    hr = S_FALSE;   // reset to NOT found

    // Open the key for this embedding:

    lResult = ::RegOpenKeyEx(hkeyDist, pszDist, 0, KEY_READ, 
                    &hkeyThisDist);

    if (lResult == ERROR_SUCCESS) {

        hr = CheckInstalledVersionHint( hkeyThisDist, plci,
            dwFileVersionMS, dwFileVersionLS);

    }
    else
    {
        hr = HRESULT_FROM_WIN32(REGDB_E_KEYMISSING);
        goto Exit;
    }

    if (hr == S_OK || (SUCCEEDED(hr) && dwFileVersionMS == -1 && dwFileVersionLS == -1)) {

        if (RegOpenKeyEx( hkeyThisDist, szContains, 
            0, KEY_READ, &hkeyContains) == ERROR_SUCCESS) {

            if (pbParanoidCheck) {
                *pbParanoidCheck = TRUE;
            }

            // BUGBUG: only do if paranoid flag on?

            // assert dependency state installed correctly on machine
            // this is where we would have to walk the dependecy tree
            // as well as make sure the contained packages and files
            // are indeed availabel on the client machine
            // BUGBUG: maybe we should only do this in paranoid mode
            // instead of all the time.

            if (RegOpenKeyEx( hkeyContains, szDistUnitStr,
                0, KEY_READ, &hkeyDepends) == ERROR_SUCCESS ) {
        
                int iSubKey = 0;
                while (RegEnumValue(hkeyDepends, iSubKey++,
                    szFileName, &cbSize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {

                    CLocalComponentInfo lci;
                    LPWSTR wszFileName = 0;
                    CLSID clsidTemp;

                    if (FAILED(Ansi2Unicode(szFileName, &wszFileName)))
                        break;
                    
                    clsidTemp = CLSID_NULL;

                    if (wszFileName)
                        CLSIDFromString(wszFileName, &clsidTemp);
                    // if above call fails DistUnit is not clsid

                    if (IsControlLocallyInstalled(NULL, &clsidTemp, wszFileName, 0,0, &lci, NULL) != S_OK) {
                        SAFEDELETE(wszFileName);

                        plci->dwLocFVMS = 0;
                        plci->dwLocFVLS = 0;

                        hr = S_FALSE;
                        goto Exit;
                    }

                    SAFEDELETE(wszFileName);
                    cbSize = MAX_PATH;
               }
            }

            if (RegOpenKeyEx( hkeyContains, szFiles,
                    0, KEY_READ, &hkeyFiles) == ERROR_SUCCESS) {

                int iValue = 0;
                DWORD dwType = REG_SZ;
                DWORD dwValueSize = MAX_PATH;

                while (RegEnumValue(hkeyFiles, iValue++, 
                    szFileName, &dwValueSize, 0, &dwType, NULL, NULL) == ERROR_SUCCESS) {

                    dwValueSize = MAX_PATH; // reset

                    if (GetFileAttributes(szFileName) == -1) {

                        // if file is not physically present then clear out our
                        // local file version. this comes in the way of doing
                        // get latest. (get latest will assume that if a local 
                        // file is present then do If-Modified-Since

                        plci->dwLocFVMS = 0;
                        plci->dwLocFVLS = 0;

                        hr = S_FALSE;
                        goto Exit;
                    }
                }
            }

            if (ArePackagesIntact(hkeyContains) == S_FALSE) {
                plci->dwLocFVMS = 0;
                plci->dwLocFVLS = 0;
                hr = S_FALSE;
                goto Exit;
            }

        }

    } else {

        hr = S_FALSE; // mark not present, don't error out
    }


Exit:
    if (pszDist)
        delete pszDist;

    if (hkeyDepends)
        ::RegCloseKey(hkeyDepends);

    if (hkeyFiles)
        ::RegCloseKey(hkeyFiles);

    if (hkeyContains)
        ::RegCloseKey(hkeyContains);

    if (hkeyThisDist)
        ::RegCloseKey(hkeyThisDist);

    if (hkeyDist)
        ::RegCloseKey(hkeyDist);

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT
IsFileLocallyInstalled(
    LPSTR lpCurCode,
    DWORD dwFileVersionMS,
    DWORD dwFileVersionLS,
    CLocalComponentInfo *plci,
    LPSTR szDestDirHint,
    BOOL bExactVersion
    )
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "IsFileLocallyInstalled",
                "%.80q, %x, %x, %#x, %.80q, %B",
                lpCurCode, dwFileVersionMS, dwFileVersionLS, plci, szDestDirHint, bExactVersion
                ));
                
    HRESULT hr = S_FALSE;

    // no clsid, but we have a file name

    // first check for a file of the same name in DestDirHint.
    // This is the directory that the main OCX file existed on
    // and so should be checked first.

    // In case this is a new install this will point to the 
    // suggested destination dir for the DLL.

    if (szDestDirHint) {
        
        if (SearchPathA_Wrap( szDestDirHint, 
                    lpCurCode, NULL, MAX_PATH, 
                        plci->szExistingFileName, &(plci->pBaseExistingFileName))) {

            //    check fileversion to see if update reqd.
            hr = LocalVersionOK(0,plci,dwFileVersionMS, dwFileVersionLS, bExactVersion);

            goto Exit;
        }
    }

    // file not found in suggested destination. Look in system searchpath
    // SearchPath for this filename 

    if (!(SearchPathA_Wrap( NULL, lpCurCode, NULL, MAX_PATH, 
                                        plci->szExistingFileName, &(plci->pBaseExistingFileName)))) {
            hr = S_FALSE;
            goto Exit;
    }

    //    check fileversion to see if update reqd.
    hr = LocalVersionOK(0,plci,dwFileVersionMS, dwFileVersionLS, bExactVersion);

Exit:

    DEBUG_LEAVE(hr);
    return hr;
}

BOOL GetEXEName(LPSTR szCmdLine)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Bool,
                "GetEXEName",
                "%.80q",
                szCmdLine
                ));

    Assert(szCmdLine);

    LPSTR pchStartBaseName = szCmdLine;
    BOOL bFullyQualified = FALSE;
    BOOL bHasSpaces = FALSE;
    char *pch;

    if (*szCmdLine == '"') {
        szCmdLine++;
        char *pszEnd = StrStrA(szCmdLine, "\"");
        
        ASSERT(pszEnd);
        *pszEnd = '\0';

        if (GetFileAttributes(szCmdLine) != -1) {
            //found the EXE name, but got to get rid of the first quote

            szCmdLine--; // step back to the "
            while (*szCmdLine) {
                *szCmdLine = *(szCmdLine + 1);
                szCmdLine++;
            }

            DEBUG_LEAVE(TRUE);
            return TRUE;
        }

        szCmdLine--; // step back to the "
        while (*szCmdLine) {
            *szCmdLine = *(szCmdLine + 1);
            szCmdLine++;
        }

        DEBUG_LEAVE(FALSE);
        return FALSE;
    }
        

    // skip past the directory if fully qualified.
    for (pch = szCmdLine; *pch; pch++) {

        if (*pch == '\\')
            pchStartBaseName = pch;

        if ( (*pch == ' ') || (*pch == '\t') )
            bHasSpaces = TRUE;
    }

    if (!bHasSpaces) {
        if (GetFileAttributes(szCmdLine) != -1) {
            //found the EXE name, it is already in szCmdLine

            DEBUG_LEAVE(TRUE);
            return TRUE;
        }

        DEBUG_LEAVE(FALSE);
        return FALSE;
    }

    // pchStartBaseName now points at the last '\\' if any
    if (*pchStartBaseName == '\\') {
        pchStartBaseName++;

        bFullyQualified = TRUE;
    }

    // pchStartBaseName no points at the base name of the EXE.

    // Now look for spaces. When we find a space we will 
    // replace with a '\0' and check if the cmd line is valid. 
    // if valid, this must be the EXE name, return
    // if not valid, march on to do the same. when we finish
    // examining all of the cmd line, or no more spaces, likely the
    // EXE is missing.

    for (pch = pchStartBaseName; *pch != '\0'; pch++) {

        if ( (*pch == ' ') || (*pch == '\t') ) {
            
            char chTemp = *pch; // sacve the white spc char

            *pch = '\0'; // stomp the spc with nul. now we have in szCmdLine
                        // what could be the full EXE name

            if (bFullyQualified) {

                if (GetFileAttributes(szCmdLine) != -1) {
                    //found the EXE name, it is already in szCmdLine

                    DEBUG_LEAVE(TRUE);
                    return TRUE;
                }

            } else {

                char szBuf[MAX_PATH];
                LPSTR pBaseFileName;

                if (SearchPathA_Wrap( NULL, szCmdLine, NULL, MAX_PATH, 
                        szBuf, &pBaseFileName)) {

                    //found the EXE name, it is already in szCmdLine

                    DEBUG_LEAVE(TRUE);
                    return TRUE;
                }
            }

            *pch = chTemp; // restore the while spc and move past.
        }

    }

    DEBUG_LEAVE(FALSE);
    return FALSE;
}

BOOL
AdviseForceDownload(const LPCLSID lpclsid, DWORD dwClsContext)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Bool,
                "AdviseForceDownload",
                "%#x, %x",
                lpclsid, dwClsContext
                ));
                
    HRESULT hr = S_OK;
    BOOL bNullClsid = lpclsid?IsEqualGUID(*lpclsid , CLSID_NULL):TRUE;
    HKEY hKeyClsid = 0;
    HKEY hKeyEmbedding = 0;
    HKEY hkeyDist = 0;
    BOOL bForceDownload = TRUE;
    LPOLESTR pwcsClsid = NULL;
    DWORD dwType;
    LONG lResult = ERROR_SUCCESS;
    static char * szAppID = "AppID";
    LPSTR pszClsid = NULL;
    CLocalComponentInfo lci;
    static char * szInprocServer32 = "InProcServer32";
    static char * szLocalServer32 = "LocalServer32";

    if (bNullClsid)
        goto Exit;

    // return if we can't get a valid string representation of the CLSID
    if (FAILED((hr=StringFromCLSID(*lpclsid, &pwcsClsid))))
        goto Exit;

    Assert(pwcsClsid != NULL);


    if (FAILED((hr=::Unicode2Ansi(pwcsClsid, &pszClsid))))
    {
        goto Exit;
    }

    // Open root HKEY_CLASSES_ROOT\CLSID key
    lResult = ::RegOpenKeyEx(HKEY_CLASSES_ROOT, "CLSID", 0, KEY_READ, &hKeyClsid);


    if (lResult == ERROR_SUCCESS)
    {
        
        // Open the key for this embedding:
        lResult = ::RegOpenKeyEx(hKeyClsid, pszClsid, 0, KEY_READ, 
                        &hKeyEmbedding);

        if (lResult == ERROR_SUCCESS) {

            // check for hint of FileVersion before actually getting FileVersion
            // This way non-PE files, like Java, random data etc. can be
            // accomodated with CODEBASE= with proper version checking.
            // If they are not really COM object then they can't be 
            // instantiated by COM or us (if object needed). But if they
            // use AsyncGetClassBits(no object instantiated) or from the
            // browser give height=0 width=0, the browser will not
            // report placeholders with errors, so they can work gracefully
            // overloading the object tag to do version checking and
            // random stuff

            hr = CheckInstalledVersionHint( hKeyEmbedding, &lci,
                0, 0);

            // if the key is found and 
            // if the latest version is not available then 
            // return now with false, if right version is already 
            // present return. If the key is missing then we
            // proceed with checks for InprocServer32/LocalServer32
            if (SUCCEEDED(hr)) {

                // if using installed version hint and the verdict is 
                // local good enough
                if (hr == S_OK)
                    bForceDownload = FALSE;

                goto Exit;
            }


            hr = S_OK;  // reset


            // ckeck if DCOM
            HKEY hKeyAppID;
            lResult = ::RegOpenKeyEx(hKeyEmbedding, szAppID, 0, 
                                KEY_READ, &hKeyAppID);
            if (lResult == ERROR_SUCCESS) {

                // DCOM 
                // just assume that this is the latest version already
                // we never attempt code download for dcom

                bForceDownload = FALSE; // no force download for DCOM

                RegCloseKey(hKeyAppID);
                goto Exit;
            }

            HKEY hKeyInProc;
            lResult = ::RegOpenKeyEx(hKeyEmbedding, szInprocServer32, 0, 
                                KEY_READ, &hKeyInProc);

            if (lResult != ERROR_SUCCESS) {
                if (RegOpenKeyEx(hKeyEmbedding, szLocalServer32, 0, 
                                KEY_READ, &hKeyInProc) == ERROR_SUCCESS) {

                    // specific look for vb doc obj hack where they just use 
                    // the OBJECT tag to do code download, but not hosting

                    // no inproc but we have localserver
                    // we could have failed because we pass the wrong clsctx

                    RegCloseKey(hKeyInProc);
                    if (!(dwClsContext & CLSCTX_LOCAL_SERVER))
                        bForceDownload = FALSE;
                }

            } else {
                RegCloseKey(hKeyInProc);
            }
        }
    }


    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_DIST_UNITS,
                          0, KEY_READ, &hkeyDist);

    if (lResult == ERROR_SUCCESS)
    {

        // Open the key for this embedding:
        HKEY hkeyThisDist = 0;

        if (RegOpenKeyEx(hkeyDist, pszClsid, 0, KEY_READ, 
                        &hkeyThisDist) == ERROR_SUCCESS) {

            HKEY hkeyJava = 0;
            if (RegOpenKeyEx(hkeyThisDist, "Contains\\Java", 0, KEY_READ, 
                        &hkeyJava) == ERROR_SUCCESS) {
                bForceDownload = FALSE;
                RegCloseKey(hkeyJava);

            }

            RegCloseKey(hkeyThisDist);
        }

        RegCloseKey(hkeyDist);
    }



Exit:
    if (pwcsClsid)
        delete pwcsClsid;

    if (pszClsid)
        delete pszClsid;

    if (hKeyClsid)
        ::RegCloseKey(hKeyClsid);
    if (hKeyEmbedding)
        ::RegCloseKey(hKeyEmbedding);

    DEBUG_LEAVE(bForceDownload);
    return bForceDownload;

}

/*******************************************************************

NAME:        IsControlLocallyInstalled
    
SYNOPSIS:   Indicates whether the provided CLSID represents an
            OLE control.
            If no clsid provided then checks to see if lpCurCode
            exists in system and checks file version to verify if
            update is needed
                
********************************************************************/
HRESULT  
IsControlLocallyInstalled(LPSTR lpCurCode, const LPCLSID lpclsid, 
    LPCWSTR szDistUnit,
    DWORD dwFileVersionMS, DWORD dwFileVersionLS,
    CLocalComponentInfo *plci,
    LPSTR szDestDirHint,
    BOOL bExactVersion)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "IsControlLocallyInstalled",
                "%.80q, %#x, %.80wq, %x, %x, %#x, %.80q, %B",
                lpCurCode, lpclsid, szDistUnit, dwFileVersionMS, dwFileVersionLS, plci, szDestDirHint, bExactVersion
                ));
                
    HRESULT hr1, hr2, hrResult, hr = S_FALSE;
    BOOL bNullClsid = lpclsid?IsEqualGUID(*lpclsid , CLSID_NULL):TRUE;
    BOOL bParanoidCheck = FALSE;

    if ( bNullClsid  && (lpCurCode == NULL) && (szDistUnit == NULL) ) {

        hr =  E_INVALIDARG;
        goto Exit;

    }

    // hr1: HRESULT for whether the dist unit is installed
    // hr2: HRESULT for whether the particular clsid is installed
    // hrResult: HRESULT for whether the particular clsid is present (but not necessarily installed correctly)

    if (szDistUnit) {
        hr1 = IsDistUnitLocallyInstalled( szDistUnit, dwFileVersionMS, dwFileVersionLS, plci, szDestDirHint, &bParanoidCheck, 0);
    } else {

        if (bNullClsid)
        {
            hr1 = IsFileLocallyInstalled( lpCurCode, dwFileVersionMS, dwFileVersionLS, plci, szDestDirHint, bExactVersion);

            // if no dist unit name or clsid and this is
            // clearly just checking for dependent file then
            // no need to fall thru and check the com br as well

            hr = hr1;
            goto Exit;
        }
        else
        {
            hr1 = E_FAIL;
        }

    }

    hr2 = IsCLSIDLocallyInstalled( lpCurCode, lpclsid, szDistUnit, dwFileVersionMS, dwFileVersionLS, plci, szDestDirHint, &hrResult , bExactVersion);

    if (hr2 != S_OK)
    {
        // if HKLM\CLSID\{CLSID} existed, but control wasn't there, we fail with that error
        // otherwise we fail with hr1.
        if (SUCCEEDED(hrResult))
        {
            hr = hr2;            
        }
        else
        {
            // if DU check returned S_FALSE or S_OK we return that, otherwise return from CLSID check.

            if (SUCCEEDED(hr1))
            {
                hr = hr1;
            }
            else
            {
                hr = hr2;
            }
        }
    }
    else
    {
        if (hr1 == S_FALSE)
        {
            // COM branch says we are OK, but Distribution unit says we are lacking.
            // if we did paranoid checking and then failed the DU then
            // really fail. But if we just looked at the InstalledVersion 
            // in the registry and concluded that our DU is no good then we
            // should go by the COM br and succeed the call as the user
            // could have obtained a newer version thru a mechanism other than
            // code download and so we have no business trying to update this

            // BUGBUG: do we at this point try to correct our registry
            // record of the version? need to ship tomorrow!

            if (bParanoidCheck)
                hr = hr1;
            else
                hr = hr2;

        }
        else
        {
            hr = hr2;
        }
    }

Exit:

    DEBUG_LEAVE(hr);
    return hr;
}

/*******************************************************************

NAME:        IsCLSIDLocallyInstalled
    
SYNOPSIS:   Indicates whether the provided CLSID represents an
            OLE control.
            If no clsid provided then checks to see if lpCurCode
            exists in system and checks file version to verify if
            update is needed
                
********************************************************************/
HRESULT  
IsCLSIDLocallyInstalled(LPSTR lpCurCode, const LPCLSID lpclsid, 
    LPCWSTR szDistUnit,
    DWORD dwFileVersionMS, DWORD dwFileVersionLS,
    CLocalComponentInfo *plci,
    LPSTR szDestDirHint,
    HRESULT *pHrExtra,
    BOOL bExactVersion
    )


{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "IsCLSIDLocallyInstalled",
                "%.80q, %#x, %.80wq, %x, %x, %#x, %.80q, %#x, %B",
                lpCurCode, lpclsid, szDistUnit, dwFileVersionMS, dwFileVersionLS, plci, szDestDirHint, pHrExtra, bExactVersion
                ));
                
    LPSTR pszClsid = NULL;
    LPOLESTR pwcsClsid = NULL;
    HRESULT hr = S_FALSE;
    DWORD dwType;
    LONG lResult = ERROR_SUCCESS;
    static char * szInprocServer32 = "InProcServer32";
    static char * szLocalServer32 = "LocalServer32";
    static char * szAppID = "AppID";
    HKEY hKeyClsid = 0;
    DWORD Size = MAX_PATH;

    if (pHrExtra)
        *pHrExtra = E_FAIL;

    // return if we can't get a valid string representation of the CLSID
    if (FAILED((hr=StringFromCLSID(*lpclsid, &pwcsClsid))))
        goto Exit;

    Assert(pwcsClsid != NULL);

    // Open root HKEY_CLASSES_ROOT\CLSID key
    lResult = ::RegOpenKeyEx(HKEY_CLASSES_ROOT, "CLSID", 0, KEY_READ, &hKeyClsid);

    if (lResult == ERROR_SUCCESS)
    {
        if (FAILED((hr=::Unicode2Ansi(pwcsClsid, &pszClsid))))
        {
            goto Exit;
        }
        
        // Open the key for this embedding:
        HKEY hKeyEmbedding;
        HKEY hKeyInProc;

        lResult = ::RegOpenKeyEx(hKeyClsid, pszClsid, 0, KEY_READ, 
                        &hKeyEmbedding);

        if (lResult == ERROR_SUCCESS) {

            // check for hint of FileVersion before actually getting FileVersion
            // This way non-PE files, like Java, random data etc. can be
            // accomodated with CODEBASE= with proper version checking.
            // If they are not really COM object then they can't be 
            // instantiated by COM or us (if object needed). But if they
            // use AsyncGetClassBits(no object instantiated) or from the
            // browser give height=0 width=0, the browser will not
            // report placeholders with errors, so they can work gracefully
            // overloading the object tag to do version checking and
            // random stuff

            if (pHrExtra)
            {
                // indicate that CLSID reg key exists, so any failures after this
                // imply the control is not registered correctly
                *pHrExtra = S_OK;
            }

            hr = CheckInstalledVersionHint( hKeyEmbedding, plci,
                dwFileVersionMS, dwFileVersionLS);

            // if the key is found and 
            // if the latest version is not available then 
            // return now with false, if right version is already 
            // present return. If the key is missing then we
            // proceed with checks for InprocServer32/LocalServer32
            if (SUCCEEDED(hr))
                goto finish_all;

            hr = S_OK;  // reset

            // ckeck if DCOM
            HKEY hKeyAppID;
            lResult = ::RegOpenKeyEx(hKeyEmbedding, szAppID, 0, 
                                KEY_READ, &hKeyAppID);
            if (lResult == ERROR_SUCCESS) {

                // DCOM 
                // just assume that this is the latest version already
                // we never attempt code download for dcom

                ::RegCloseKey(hKeyAppID);
                goto finish_all;
            }


            lResult = ::RegOpenKeyEx(hKeyEmbedding, szInprocServer32, 0, 
                                KEY_READ, &hKeyInProc);

            if (lResult == ERROR_SUCCESS) {

                Size = MAX_PATH;
                lResult = ::SHQueryValueEx(hKeyInProc, NULL, NULL, &dwType, 
                                    (unsigned char *)plci->szExistingFileName, &Size);

                if (lResult == ERROR_SUCCESS) {

                    if (!(SearchPathA_Wrap( NULL, 
                                plci->szExistingFileName, NULL, MAX_PATH, 
                                    plci->szExistingFileName, &(plci->pBaseExistingFileName)))) {
                        hr = S_FALSE;
                        goto finish_verchecks;
                    }

                    //    check fileversion to see if update reqd.
                    hr = LocalVersionOK(hKeyEmbedding, plci,
                                dwFileVersionMS, dwFileVersionLS, bExactVersion);

                    if (plci->bForceLangGetLatest) {
                        hr = NeedForceLanguageCheck(hKeyEmbedding, plci);
                    }

                    goto finish_verchecks;

                } else {
                    hr = S_FALSE; // problem: can't locate file
                    goto finish_verchecks;
                }

            } else {

                lResult = ::RegOpenKeyEx(hKeyEmbedding, szLocalServer32, 0, 
                                KEY_READ, &hKeyInProc);

                if (lResult != ERROR_SUCCESS) {
                    hr = S_FALSE; // problem :have a clsid but, can't locate it
                    goto finish_all;
                 }    

                Size = MAX_PATH;
                lResult = ::SHQueryValueEx(hKeyInProc, NULL, NULL, &dwType, 
                                    (unsigned char *)plci->szExistingFileName, &Size);

                if (lResult == ERROR_SUCCESS) {

                    // strip out args if any for this localserver32
                    // and extract only the EXE name

                    GetEXEName(plci->szExistingFileName);

                    if (!(SearchPathA_Wrap( NULL, 
                                plci->szExistingFileName, NULL, MAX_PATH, 
                                    plci->szExistingFileName, &(plci->pBaseExistingFileName)))) {
                        hr = S_FALSE;
                        goto finish_verchecks;
                    }

                    //    check fileversion to see if update reqd.
                    hr = LocalVersionOK(hKeyEmbedding, plci, dwFileVersionMS, dwFileVersionLS, bExactVersion);

                    if (plci->bForceLangGetLatest)
                        hr = NeedForceLanguageCheck(hKeyEmbedding, plci);

                    goto finish_verchecks;

                } else {
                    hr = S_FALSE; // problem: can't locate file
                    goto finish_verchecks;
                }

            }


            finish_verchecks:
            ::RegCloseKey(hKeyInProc);

            finish_all:

            ::RegCloseKey(hKeyEmbedding);

        } else {
            // here if we could not find the embedding in HKCR\CLSID
            
            hr = S_FALSE;
            
        }

    } else
        hr = S_FALSE;

Exit:

    // release the string allocated by StringFromCLSID
    if (pwcsClsid)
        delete pwcsClsid;

    if (pszClsid)
        delete pszClsid;

    if (hKeyClsid)
        ::RegCloseKey(hKeyClsid);

    DEBUG_LEAVE(hr);
    return hr;
}

BOOL SupportsSelfRegister(LPSTR szFileName)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Bool,
                "SupportsSelfRegister",
                "%.80q",
                szFileName
                ));
                
    HRESULT hr = SniffStringFileInfo( szFileName, TEXT("OLESelfRegister") );

    DEBUG_LEAVE(hr);
    return hr;
}

BOOL WantsAutoExpire(LPSTR szFileName, DWORD *pnExpireDays)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Bool,
                "WantsAutoExpire",
                "%.80q, %#x",
                szFileName, pnExpireDays
                ));
                
    HRESULT hr = SniffStringFileInfo( szFileName, TEXT("Expire"), pnExpireDays );

    DEBUG_LEAVE(hr);
    return hr;
}


HRESULT GetFileVersion(CLocalComponentInfo *plci, LPDWORD pdwFileVersionMS, LPDWORD pdwFileVersionLS)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "GetFileVersion",
                "%#x, %#x, %#x",
                plci, pdwFileVersionMS, pdwFileVersionLS
                ));
                
    DWORD  handle;
    UINT  uiInfoSize;
    UINT  uiVerSize ;
    UINT  uiSize ;
    BYTE* pbData = NULL ;
    VS_FIXEDFILEINFO *lpVSInfo;;
    HRESULT hr = S_OK;
    LPVOID lpVerBuffer = NULL;

#ifdef UNIX
    // We don't have version.dll
    DebugBreak();

    DEBUG_LEAVE(E_INVALIDARG);
    return E_INVALIDARG;
#endif

    if (!pdwFileVersionMS || !pdwFileVersionLS) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *pdwFileVersionMS = 0;
    *pdwFileVersionLS = 0;

    // Get the size of the version information.
    uiInfoSize = g_versiondll.GetFileVersionInfoSize( (char *)plci->szExistingFileName, &handle);

    if (uiInfoSize == 0) {
        hr = S_FALSE;
        goto Exit;
    }

    // Allocate a buffer for the version information.
    pbData = new BYTE[uiInfoSize] ;
    if (!pbData)
    {
        DEBUG_LEAVE(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }
    
    // Fill the buffer with the version information.
    if (!g_versiondll.GetFileVersionInfo((char *)plci->szExistingFileName, handle, uiInfoSize, pbData)) {
         hr = HRESULT_FROM_WIN32(GetLastError());
         goto Exit ;
    }

    // Get the translation information.
    if (!g_versiondll.VerQueryValue( pbData, "\\", (void**)&lpVSInfo, &uiVerSize)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit ;
    }    

    if (!uiVerSize) {
        hr = E_FAIL;
        goto Exit ;
    }

    *pdwFileVersionMS = lpVSInfo->dwFileVersionMS;
    *pdwFileVersionLS = lpVSInfo->dwFileVersionLS;

    // Get the translation information.
    if (!g_versiondll.VerQueryValue( pbData, "\\VarFileInfo\\Translation", &lpVerBuffer, &uiVerSize)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit ;
    }    

    if (!uiVerSize) {
        hr = E_FAIL;
        goto Exit ;
    }

     plci->lcid = LOWORD(*((DWORD *) lpVerBuffer));   // Language ID

Exit:

    if (pbData)
        delete [] pbData ;

    DEBUG_LEAVE(hr);
    return hr;
}

DWORD
GetLanguageCheckInterval(HKEY hkeyCheckPeriod)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Dword,
                "GetLanguageCheckInterval",
                "%#x",
                hkeyCheckPeriod
                ));
                
    DWORD dwMagicDays = 30;

    DWORD dwType = REG_DWORD;
    DWORD dwSize = sizeof(DWORD);
    char szLangString[MAX_PATH];

    LCID lcidPriOverride = PRIMARYLANGID(LANGIDFROMLCID(GetThreadLocale()));
    LCID lcidPriBrowser = PRIMARYLANGID(LANGIDFROMLCID(g_lcidBrowser));

    if (SUCCEEDED(GetLangString(lcidPriOverride, szLangString, sizeof(szLangString)))) {

        if (RegQueryValueEx(hkeyCheckPeriod, szLangString, NULL, &dwType, 
            (unsigned char *)&dwMagicDays, &dwSize) == ERROR_SUCCESS) {

            DEBUG_LEAVE(dwMagicDays);
            return dwMagicDays;
        }
    }

    if ( (lcidPriOverride != lcidPriBrowser) &&
        SUCCEEDED(GetLangString(lcidPriBrowser, szLangString, sizeof(szLangString)))) {

        if (RegQueryValueEx(hkeyCheckPeriod, szLangString, NULL, &dwType, 
            (unsigned char *)&dwMagicDays, &dwSize) == ERROR_SUCCESS) {

            DEBUG_LEAVE(dwMagicDays);
            return dwMagicDays;
        }
    }

    DEBUG_LEAVE(dwMagicDays);
    return dwMagicDays;
}

// returns:
//          S_OK: local version OK or local version lang check not reqd now
//          S_FALSE: localversion not of right lang force lang check now
//          ERROR: fail

HRESULT NeedForceLanguageCheck(HKEY hkeyCLSID, CLocalComponentInfo *plci)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "NeedForceLanguageCheck",
                "%#x, %#x",
                hkeyCLSID, plci
                ));
                
    HRESULT hr = S_OK;
    DWORD lResult;
    const char *szCHECKPERIOD = "LanguageCheckPeriod";
    const char *szLASTCHECKEDHI = "LastCheckedHi";
    DWORD dwMagicPerDay = 201;
    DWORD dwMagicDays;
    DWORD dwType;
    DWORD dwSize;
    FILETIME ftlast, ftnow;
    SYSTEMTIME st;
    HKEY hkeyCheckPeriod = 0;
    char szLangEnable[MAX_PATH];


    if (!plci->bForceLangGetLatest)
    {
        DEBUG_LEAVE(hr);
        return hr;
    }
    
    // lang is mismatched for this browser
    // check when was the last time we checked for the right lang

    if ((lResult = RegOpenKeyEx( hkeyCLSID, szCHECKPERIOD,
                        0, KEY_READ, &hkeyCheckPeriod)) != ERROR_SUCCESS) {
        plci->bForceLangGetLatest = FALSE;
        goto Exit;

    }

    szLangEnable[0] = '\0';
    dwType = REG_SZ;
    dwSize = MAX_PATH;
    if ( (RegQueryValueEx(hkeyCheckPeriod, NULL, NULL, &dwType, 
         (unsigned char *)szLangEnable, &dwSize) != ERROR_SUCCESS) ||
         lstrcmpi(szLangEnable, "Enabled") != 0 ) {

        plci->bForceLangGetLatest = FALSE;
        goto Exit;
    }

    // see if lang check interval is specified for this lang
    dwMagicDays = GetLanguageCheckInterval(hkeyCheckPeriod);

    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ftnow);
    ftnow.dwLowDateTime = 0;

    memset(&ftlast, 0, sizeof(FILETIME));

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    if (RegQueryValueEx(hkeyCheckPeriod, szLASTCHECKEDHI, NULL, &dwType, 
        (unsigned char *)&ftlast.dwHighDateTime, &dwSize) == ERROR_SUCCESS) {

        ftlast.dwHighDateTime += (dwMagicPerDay * dwMagicDays);
    }

    if (CompareFileTime(&ftlast, &ftnow) > 0) {
        plci->bForceLangGetLatest = FALSE;
    }


Exit:

    SAFEREGCLOSEKEY(hkeyCheckPeriod);

    if (FAILED(hr))
        plci->bForceLangGetLatest = FALSE;

    hr = plci->bForceLangGetLatest?S_FALSE:S_OK;

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT IsRightLanguageLocallyInstalled(CLocalComponentInfo *plci)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "IsRightLanguageLocallyInstalled",
                "%#x",
                plci
                ));
                
    HRESULT hr = S_OK;
    LCID lcidLocalVersion;
    LCID lcidNeeded;

    if (!plci->lcid)    // lang neutral?
        goto Exit;

    // make sure that the browser locale and lang strings are
    // initialized at this point

    hr = InitBrowserLangStrings();

    if (FAILED(hr))
        goto Exit;

    // BUGBUG: we are using threadlocale here instead of the 
    // bindopts from the bindctx passed in
    if (plci->lcid == GetThreadLocale())    // full match with override?
        goto Exit;
    if (plci->lcid == g_lcidBrowser)    // full match with browser?
        goto Exit;

    // get primary lang of local version
    lcidLocalVersion = PRIMARYLANGID(LANGIDFROMLCID(plci->lcid));

    // check with primary language of override
    lcidNeeded = PRIMARYLANGID(LANGIDFROMLCID(GetThreadLocale()));

    if (lcidLocalVersion == lcidNeeded)     // same primary lang?
        goto Exit;

    // check with primary language of browser
    lcidNeeded = PRIMARYLANGID(LANGIDFROMLCID(g_lcidBrowser));

    if (lcidLocalVersion == lcidNeeded)     // same primary lang?
        goto Exit;


    // BUGBUG: how to detect language neutral or multiligual OCX

    // we have a mismatch
    // check when was the last time we check and if past the
    // interval to check for new language availability
    // force a download now.
    
    hr = S_FALSE;

    plci->bForceLangGetLatest = TRUE;

Exit:

    DEBUG_LEAVE(hr);
    return hr;
}

// 
HRESULT LocalVersionOK(HKEY hkeyCLSID, CLocalComponentInfo *plci, DWORD dwFileVersionMS, 
                        DWORD dwFileVersionLS, BOOL bExactVersion)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "LocalVersionOK",
                "%#x, %#x, %x, %x, %B",
                hkeyCLSID, plci, dwFileVersionMS, dwFileVersionLS, bExactVersion
                ));
                
    DWORD  handle;
    HRESULT hr = S_OK; // assume local version OK.
    DWORD dwLocFVMS = 0;
    DWORD dwLocFVLS = 0;
    HKEY hkeyCheckPeriod = 0;
    const char *szCHECKPERIOD = "LanguageCheckPeriod";

    if (FAILED(hr = plci->MakeDestDir()) ) {
        goto Exit;
    }

#ifdef UNIX

    DEBUG_LEAVE(S_OK);
    return S_OK;
#endif 

    if ((dwFileVersionMS == 0) && (dwFileVersionLS == 0)) {

        // for dlls that don't require lang support and have no version req
        // don't check version numbers
        // this is to boost perf on system/IE dlls

        // One can also avoid such checks
        // by adding a [InstalledVersion] key under the clsid

        if (!hkeyCLSID || RegOpenKeyEx( hkeyCLSID, szCHECKPERIOD,
                            0, KEY_READ, &hkeyCheckPeriod) != ERROR_SUCCESS) {
            goto Exit;

        }


    }

    hr = GetFileVersion( plci, &dwLocFVMS, &dwLocFVLS);

    if (hr == S_OK) {

        plci->dwLocFVMS = dwLocFVMS;
        plci->dwLocFVLS = dwLocFVLS;

        if (bExactVersion) {
            if (dwFileVersionMS != dwLocFVMS || dwFileVersionLS != dwLocFVLS) {
                hr = S_FALSE;
            } else {
                // check language
                // sets the plci->bForcelangGetLatest if reqd
                IsRightLanguageLocallyInstalled(plci);
            }
        }
        else {
            if ((dwFileVersionMS > dwLocFVMS) ||
                     ((dwFileVersionMS == dwLocFVMS) &&
                         (dwFileVersionLS > dwLocFVLS))) {
                             hr = S_FALSE;
            } else {
                // check language
                // sets the plci->bForcelangGetLatest if reqd
                IsRightLanguageLocallyInstalled(plci);
    
            }
        }
    }

    if ((dwFileVersionMS == 0) && (dwFileVersionLS == 0)) {
        hr = S_OK;
    }

    if ((dwFileVersionMS == -1) && (dwFileVersionLS == -1)) {
        hr = S_FALSE;
    }
    

Exit:

    if (hkeyCheckPeriod)
        RegCloseKey(hkeyCheckPeriod);

    DEBUG_LEAVE(hr);
    return hr;
}


/*
 *
 * UpdateSharedDlls
 *
 * the SharedDlls section looks like this
 *
 * [SharedDlls]
 *        C:\Windows\System\foo.ocx = <ref count>
 *
 *    Parameters:
 *
 *    szFileName        full file name of module we want to use
 *
 *    Returns:
 *
 *        S_OK    incremented tge shared dlls ref count.
 *
 *        Error    the error encountered
 */

HRESULT
UpdateSharedDlls( LPCSTR szFileName)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "UpdateSharedDlls",
                "%.80q",
                szFileName
                ));
                
    HKEY hKeySD = NULL;
    HRESULT hr = S_OK;
    DWORD dwType;
    DWORD dwRef = 1;
    DWORD dwSize = sizeof(DWORD);
    LONG lResult;

    // get the main SHAREDDLLS key ready; this is never freed!


    if ((lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REGSTR_PATH_SHAREDDLLS,
                        0, KEY_ALL_ACCESS, &hKeySD)) != ERROR_SUCCESS) {
        if ((lResult = RegCreateKey( HKEY_LOCAL_MACHINE,
                   REGSTR_PATH_SHAREDDLLS, &hKeySD)) != ERROR_SUCCESS) {
            hKeySD = NULL;
            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
        }
    }


    // now look for szFileName
    lResult = SHQueryValueEx(hKeySD, szFileName, NULL, &dwType, 
                        (unsigned char *)&dwRef, &dwSize);

    if (lResult == ERROR_SUCCESS)
        dwRef++;

    // does not exist. Create one and initialize to 1

    if ((lResult = RegSetValueEx (hKeySD, szFileName, 0, REG_DWORD,
                        (unsigned char *)&dwRef, 
                        sizeof(DWORD))) != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(lResult);
        goto Exit;
    }

Exit:

    if (hKeySD)
        RegCloseKey(hKeySD);

    DEBUG_LEAVE(hr);
    return hr;
}

/*
 *
 * UpdateModuleUsage
 *
 * the module usage section in the regitry looks like this
 *
 * [ModuleUsage]
 *        [c:/windows/occache/foo.ocx]
 *            Owner = Internet Code Downloader
 *            FileVersion = <optional text version of 64-bit fileversion of ocx
 *            [clients]
 *                Internet Code Downloader = <this client's ref count>
 * To allow for full path names without using the backslash we convert
 * backslahes to forward slashes.
 *
 *
 *    Parameters:
 *
 *    szFileName        full file name of module we want to use
 *
 *    szClientName      name of or stringfromclsid of client.
 *
 *    szClientPath      optional (if present we can detect if client is gone)
 *
 *    muFlags:
 *        MU_CLIENT    mark ourselves client
 *        MU_OWNER     mark ourselves owner
 *
 *    Returns:
 *        S_OK    we updated the module usage section, 
 *                and if that was previously absent then we also upped the 
 *                shared dlls count.
 *
 *        Error    the error encountered
 */
HRESULT 
UpdateModuleUsage(
    LPCSTR szFileName,
    LPCSTR szClientName,
    LPCSTR szClientPath,
    LONG muFlags)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "UpdateModuleUsage",
                "%.80q, %.80q, %.80q, %x",
                szFileName, szClientName, szClientPath, muFlags
                ));
                
    HRESULT hr = S_OK;
    LONG lResult = 0;
    BOOL fUpdateSharedDlls = TRUE;

    DWORD dwType;
    HKEY hKeyMod = NULL;

    DWORD dwSize = MAX_PATH;
    char szBuf[MAX_PATH];

    const char *pchSrc;
    char *pchDest;
    static const LPCSTR szCLIENTPATHDEFAULT = "";
    LPCSTR lpClientPath = (szClientPath)?szClientPath:szCLIENTPATHDEFAULT;

    HKEY hKeyMU = NULL;
    static const char szOWNER[] = ".Owner";
    static const char szUNKNOWN[] = "Unknown Owner";

    Assert(szClientName);
    DWORD cbClientName = lstrlen(szClientName);
    DWORD cbUnknown = sizeof(szUNKNOWN);

    char szShortFileName[MAX_PATH];

#ifdef SHORTEN
    if (!GetShortPathName(szFileName, szShortFileName, MAX_PATH)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
#else
    StrNCpy(szShortFileName, szFileName, sizeof(szShortFileName));
#endif

    if (g_bRunOnWin95) {
        char szCharFileName[MAX_PATH];

        OemToCharBuff(szShortFileName, szCharFileName, sizeof(szCharFileName) / sizeof(szCharFileName[0]));
        StrNCpy(szShortFileName, szCharFileName, sizeof(szShortFileName));
    }

    // get the main MODULEUSAGE key ready; this is never freed!

    if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, REGSTR_PATH_MODULE_USAGE,
            0, KEY_ALL_ACCESS, &hKeyMU) != ERROR_SUCCESS)
        if ((lResult = RegCreateKey( HKEY_LOCAL_MACHINE,
                   REGSTR_PATH_MODULE_USAGE, &hKeyMU)) != ERROR_SUCCESS) {
            hKeyMU = NULL;
            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
        }


    // check if Usage section is present for this dll
    // open the file's section we are concerned with
    // if absent create it


    // BUGBUG: win95 registry bug does not allow keys to be > 255
    // MAX_PATH for filename is 260
    pchDest = szBuf;
    for (pchSrc = szShortFileName; *pchSrc != '\0'; pchSrc++, pchDest++) {
        if ((*pchDest = *pchSrc) == '\\')
            *pchDest = '/';
    }
    *pchDest = '\0'; // null terminate
    szBuf[256] = '\0'; // truncate if longer than 255 ude to win95 registry bug

    if (RegOpenKeyEx( hKeyMU, szBuf,
            0, KEY_ALL_ACCESS, &hKeyMod) != ERROR_SUCCESS) {
        if ((lResult = RegCreateKey( hKeyMU,
                   szBuf, &hKeyMod)) != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
            }
    }


    // now look for '.Owner='
    dwSize = MAX_PATH;
    szBuf[0] = '\0';
    if (RegQueryValueEx(hKeyMod, szOWNER, NULL, &dwType, 
                        (unsigned char *)szBuf, &dwSize) == ERROR_SUCCESS) {
        if ((lstrcmpi(szBuf, szClientName) != 0) && (muFlags & MU_OWNER)) {
            // if we are the not the owner we can't make ourselves the owner
            hr = E_INVALIDARG;
            goto Exit;
        }

    } else {

        // '.Owner =' does not exist. Create one and initialize to us
        // if muFlags & MU_OWNER

        if (((lResult = RegSetValueEx (hKeyMod, szOWNER, 0, REG_SZ,
                (UCHAR *)((muFlags & MU_OWNER)?szClientName:szUNKNOWN),
                ((muFlags & MU_OWNER)?cbClientName:cbUnknown)))) != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
        }

    }


    // look for szClientName already marked as a client

    dwSize = MAX_PATH;
    if (SHQueryValueEx(hKeyMod, szClientName, NULL, &dwType, 
                        (unsigned char *)szBuf, &dwSize) == ERROR_SUCCESS) {

        // signal that we have already registered as a 
        // client and so don't up ref count in shareddlls

        fUpdateSharedDlls = FALSE; 


    } else {

        // add ourselves as a client

        if ((lResult =RegSetValueEx(hKeyMod, szClientName, 0, REG_SZ,
                (unsigned char *)lpClientPath, lstrlen(lpClientPath)+1 )) != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
        }

    }


Exit:

    if (hKeyMod)
        RegCloseKey(hKeyMod);

    if (hKeyMU)
        RegCloseKey(hKeyMU);

    // Update ref count in SharedDlls only if usage section was not
    // already updated. This will ensure that the code downloader has
    // just one ref count represented in SharedDlls

    if ( fUpdateSharedDlls)
        hr = UpdateSharedDlls(szShortFileName);

    DEBUG_LEAVE(hr);
    return hr;

}

// Name: SniffStringFileInfo
// Parameters:
//     szFileName   -   full path to file whose StringFileInfo we want to sniff
//     lpszSubblock -   sub block of the StringFileInfo to look for
//     pdw          -   place to put the string, interpreted as a number
// Returns:
//     TRUE - if the subblock is present.
//     FALSE - if the subblock is absent.
// Notes:
//     This function implements stuff common to SupportsSelfRegister and WantsAutoExpire

BOOL SniffStringFileInfo(  LPSTR szFileName, LPCTSTR lpszSubblock, DWORD *pdw )
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Bool,
                "SniffStringFileInfo",
                "%.80q, %#x, %#x",
                szFileName, lpszSubblock, pdw
                ));
                
    BOOL bResult = FALSE;
    DWORD  handle;
    UINT  uiInfoSize;
    UINT  uiVerSize ;
    UINT  uiSize ;
    BYTE* pbData = NULL ;
    DWORD* lpBuffer;
    TCHAR szName[512] ;
    LPTSTR szExpire;

    if ( pdw )
        *pdw = 0;

#ifdef UNIX
    // Don't have version.dll
    DebugBreak();

    DEBUG_LEAVE(FALSE);
    return FALSE;
#endif 
    // Get the size of the version information.
    uiInfoSize = g_versiondll.GetFileVersionInfoSize( szFileName, &handle);

    if (uiInfoSize == 0) 
    {
        DEBUG_LEAVE(FALSE);
        return FALSE ;
    }
    
    // Allocate a buffer for the version information.
    pbData = new BYTE[uiInfoSize] ;

    if (!pbData)
    {
        DEBUG_LEAVE(TRUE);
        return TRUE; // nothing nasty, just quirky
    }

    // Fill the buffer with the version information.
    bResult = g_versiondll.GetFileVersionInfo( szFileName, handle, uiInfoSize, pbData);

    if (!bResult) goto Exit ;

    // Get the translation information.
    bResult = g_versiondll.VerQueryValue( pbData, "\\VarFileInfo\\Translation",
                       (void**)&lpBuffer, &uiVerSize);

    if (!bResult) goto Exit ;

    if (!uiVerSize) goto Exit ;

    // Build the path to the OLESelfRegister key
    // using the translation information.
    wnsprintf( szName, ARRAY_ELEMENTS(szName)-1, "\\StringFileInfo\\%04hX%04hX\\%s",
              LOWORD(*lpBuffer), HIWORD(*lpBuffer), lpszSubblock) ;

    // Search for the key.
    bResult = g_versiondll.VerQueryValue( pbData, szName, (void**)&szExpire, &uiSize);

    // If there's a string there, we need to convert it to a count of days.
    if ( bResult && pdw && uiSize )
    {
        DWORD dwExpire = 0;

        for ( ; *szExpire; szExpire++ )
        {
            if ( (*szExpire >= TEXT('0') && *szExpire <= TEXT('9')) )
                dwExpire = dwExpire * 10 + *szExpire - TEXT('0');
            else
                break;
        }

        if (dwExpire > MAX_EXPIRE_DAYS)
            dwExpire = MAX_EXPIRE_DAYS;

        *pdw = dwExpire;
    }

Exit:
    delete [] pbData ;
    
    DEBUG_LEAVE(bResult);
    return bResult ;
}

void ExtractVersion(char *pszDistUnit, DWORD *pdwVerMS, DWORD *pdwVerLS)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "ExtractVersion",
                "%.80q, %#x, %#x",
                pszDistUnit, pdwVerMS, pdwVerLS
                ));
                
    char                    *pszCopy = NULL;
    char                    *pszPtr = NULL;
    int                      iLen = 0;

    if (!pszDistUnit)
    {
        DEBUG_LEAVE(0);
        return;
    }

    iLen = lstrlen(pszDistUnit) + 1;
    pszCopy = new char[iLen];

    if (!pszCopy) {

        DEBUG_LEAVE(0);
        return;
    }

    StrNCpy(pszCopy, pszDistUnit, iLen);

    pszPtr = pszCopy;

    // Convert _ to , for GetVersionFromString()

    while (*pszPtr)
    {
        if (*pszPtr == '_')
        {
            *pszPtr = ',';
        }

        pszPtr++;
    }

    pszPtr = StrStrA(pszCopy, "!");

    if (pszPtr) {
        pszPtr++;
        GetVersionFromString(pszPtr, pdwVerMS, pdwVerLS);
    }

    SAFEDELETE(pszCopy);

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\hooks.cxx ===
// ===========================================================================
// File: HOOKS.CXX
//    implements CSetupHook
//


#include <cdlpch.h>
#include "advpkp.h"
#include "advpub.h"

CRunSetupHook g_RunSetupHook;
extern DWORD  g_dwCodeDownloadSetupFlags;

// ---------------------------------------------------------------------------
// %%Function: CSetupHook::CSetupHook
// ---------------------------------------------------------------------------
CSetupHook::CSetupHook(
    CDownload *pdl,
    LPCSTR szHook,
    LPCSTR szInf,
    LPCSTR szInfSection,
    DWORD flags,
    HRESULT *phr)
    :
    m_pdl(pdl),
    m_flags(flags),
    m_state(INSTALL_INIT)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CSetupHook::CSetupHook",
                "this=%#x, %.80q, %.80q, %.80q, %#x, %#x",
                this, pdl, szHook, szInf, szInfSection, flags, phr
                ));
                
    Assert(szInf);

    *phr = S_OK;

    if (szInf) {

        m_szInf= new char [lstrlen(szInf)+1];

        if (m_szInf)
            lstrcpy(m_szInf, szInf);
        else
            *phr = E_OUTOFMEMORY;
    } else {
        m_szInf = NULL;
    }

    if (szInfSection) {

        m_szInfSection = new char [lstrlen(szInfSection)+1];

        if (m_szInfSection)
            lstrcpy(m_szInfSection, szInfSection);
        else
            *phr = E_OUTOFMEMORY;
    } else {
        m_szInfSection = NULL;
    }

    if (szHook) {

        m_szHook = new char [lstrlen(szHook)+1];

        if (m_szHook)
            lstrcpy(m_szHook, szHook);
        else
            *phr = E_OUTOFMEMORY;
    } else {
        m_szHook = NULL;
    }

    DEBUG_LEAVE(0);
}  // CSetupHook

// ---------------------------------------------------------------------------
// %%Function: CSetupHook::~CSetupHook
// ---------------------------------------------------------------------------
CSetupHook::~CSetupHook()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CSetupHook::~CSetupHook",
                "this=%#x",
                this
                ));
                
    if (m_szInf)
        SAFEDELETE(m_szInf);

    if (m_szInfSection)
        SAFEDELETE(m_szInfSection);

    if (m_szHook)
        SAFEDELETE(m_szHook);

    DEBUG_LEAVE(0);
}  // ~CSetupHook


// ---------------------------------------------------------------------------
// %%Function: CSetupHook::ExpandVar
// ---------------------------------------------------------------------------
HRESULT
CSetupHook::ExpandVar(
    LPSTR& pchSrc,          // passed by ref!
    LPSTR& pchOut,          // passed by ref!
    DWORD& cbLen,           // passed by ref!
    DWORD cbBuffer,
    const char * szVars[],
    const char * szValues[])
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSetupHook::ExpandVar",
                "%#x, %#x, %#x, %#x, %#x, %#x",
                &pchSrc, &pchOut, &cbLen, cbBuffer, szVars, szValues
                ));
                
    HRESULT hr = S_FALSE;
    int cbvar = 0;

    Assert (*pchSrc == '%');

    for (int i=0; szVars[i] && (cbvar = lstrlen(szVars[i])) ; i++) { // for each variable

        int cbneed = 0;

        if ( (szValues[i] == NULL) || !(cbneed = lstrlen(szValues[i])))
            continue;

        cbneed++;   // add for nul

        if (0 == strncmp(szVars[i], pchSrc, cbvar)) {

            // found something we can expand

                if ((cbLen + cbneed) >= cbBuffer) {
                    // out of buffer space
                    *pchOut = '\0'; // term
                    hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                    goto Exit;
                }

                lstrcpy(pchOut, szValues[i]);
                cbLen += (cbneed -1); //don't count the nul

                pchSrc += cbvar;        // skip past the var in pchSrc
                pchOut += (cbneed -1);  // skip past dir in pchOut

                hr = S_OK;
                goto Exit;

        }
    }

Exit:

    DEBUG_LEAVE(hr);
    return hr;
    
}

// ---------------------------------------------------------------------------
// %%Function: CSetupHook::TranslateString
// ---------------------------------------------------------------------------
HRESULT
CSetupHook::TranslateString()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSetupHook::TranslateString",
                "this=%#x",
                this
                ));
                
    Assert(m_pdl);
    Assert(m_szInf);
    Assert(m_szHook);

    HRESULT hr = S_OK;

    DWORD_PTR flags = (g_dwCodeDownloadSetupFlags & CDSF_USE_SETUPAPI)?RSC_FLAG_SETUPAPI:0;

    // there's a command line in the run= command.
    // have advpack tranalate it for us.

    DWORD dwBufferSize = 0;
    DWORD dwRequiredSize = 0;

    // get reqd size to hold expanded string
#ifdef WX86
    if (m_pdl->GetCodeDownload()->GetMultiArch()->GetRequiredArch() == PROCESSOR_ARCHITECTURE_INTEL) {
        hr = g_RunSetupHook.TranslateInfStringX86(
                m_pdl->GetCodeDownload()->GetMainInf(), // inf name
                NULL,                                   // use DefaultInstall
                m_szHook,                               // hook section name
                "run",                                  // key name
                NULL,                                   // find out size reqd.
                dwBufferSize,
                &dwRequiredSize,
                (PVOID)flags);
    } else {
        hr = g_RunSetupHook.TranslateInfString(
                m_pdl->GetCodeDownload()->GetMainInf(), // inf name
                NULL,                                   // use DefaultInstall
                m_szHook,                               // hook section name
                "run",                                  // key name
                NULL,                                   // find out size reqd.
                dwBufferSize,
                &dwRequiredSize,
                (PVOID)flags);
    }
#else

    hr = g_RunSetupHook.TranslateInfString(
            m_pdl->GetCodeDownload()->GetMainInf(), // inf name
            NULL,                                   // use DefaultInstall 
            m_szHook,                               // hook section name
            "run",                                  // key name
            NULL,                                   // find out size reqd.
            dwBufferSize,
            &dwRequiredSize,
            (PVOID)flags);
#endif


    if (FAILED(hr))
        goto Exit;

    Assert(dwRequiredSize);

    if (m_szInf)
        SAFEDELETE(m_szInf);

    m_szInf= new char [(dwBufferSize = dwRequiredSize+1)];

    if (!m_szInf) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    // the real thing
#ifdef WX86
    if (m_pdl->GetCodeDownload()->GetMultiArch()->GetRequiredArch() == PROCESSOR_ARCHITECTURE_INTEL) {
        hr = g_RunSetupHook.TranslateInfStringX86(
                m_pdl->GetCodeDownload()->GetMainInf(), // inf name
                NULL,                                   // use DefaultInstall
                m_szHook,                               // hook section name
                "run",                                  // key name
                m_szInf,
                dwBufferSize,
                &dwRequiredSize,
                (PVOID)flags);
    } else {
        hr = g_RunSetupHook.TranslateInfString(
                m_pdl->GetCodeDownload()->GetMainInf(), // inf name
                NULL,                                   // use DefaultInstall
                m_szHook,                               // hook section name
                "run",                                  // key name
                m_szInf,
                dwBufferSize,
                &dwRequiredSize,
                (PVOID)flags);
    }
#else
    hr = g_RunSetupHook.TranslateInfString(
            m_pdl->GetCodeDownload()->GetMainInf(), // inf name
            NULL,                                   // use DefaultInstall 
            m_szHook,                               // hook section name
            "run",                                  // key name
            m_szInf,
            dwBufferSize,
            &dwRequiredSize,
            (PVOID)flags);
#endif



Exit:

    DEBUG_LEAVE(hr);
    return hr;
        
}


// ---------------------------------------------------------------------------
// %%Function: CSetupHook::ExpandCommandLine
// ---------------------------------------------------------------------------
HRESULT
CSetupHook::ExpandCommandLine(
    LPSTR szSrc,
    LPSTR szBuf,
    DWORD cbBuffer,
    const char * szVars[],
    const char * szValues[])
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSetupHook::ExpandCommandLine",
                "%.80q, %.80q, %#x, %#x, %#x",
                szSrc, szBuf, cbBuffer, szVars, szValues
                ));
                
    Assert(cbBuffer);


    HRESULT hr = S_FALSE;

    LPSTR pchSrc = szSrc;     // start parsing at begining of cmdline

    LPSTR pchOut = szBuf;       // set at begin of out buffer
    DWORD cbLen = 0;

    while (*pchSrc) {

        // look for match of any of our env vars
        if (*pchSrc == '%') {

            HRESULT hr1 = ExpandVar(pchSrc, pchOut, cbLen, // all passed by ref!
                cbBuffer, szVars, szValues);  

            if (FAILED(hr1)) {
                hr = hr1;
                goto Exit;
            }


            if (hr1 == S_OK) {    // expand var expanded this
                hr = hr1;
                continue;
            }
        }
            
        // copy till the next % or nul
        if ((cbLen + 1) < cbBuffer) {

            *pchOut++ = *pchSrc++;
            cbLen++;

        } else {

            // out of buffer space
            *pchOut = '\0'; // term
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;

        }


    }

    *pchOut = '\0'; // term


Exit:

    DEBUG_LEAVE(hr);
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CSetupHook::Run
// ---------------------------------------------------------------------------
HRESULT
CSetupHook::Run()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSetupHook::Run",
                "this=%#x",
                this
                ));
                
    Assert(m_pdl);
    CCodeDownload *pcdl = m_pdl->GetCodeDownload();
    Assert(pcdl);
    HWND hWnd = pcdl->GetClientBinding()->GetHWND();

    HANDLE hExe = INVALID_HANDLE_VALUE;
    HRESULT hr = S_OK;
    DWORD flags = m_flags;

#define SIZE_CMD_LINE   2048

    char szBuf[SIZE_CMD_LINE];  // enough for commandline

    DWORD nStatusText = 0;
    WCHAR szStatusText[SIZE_CMD_LINE];

    Assert(m_szInf);

    // BEGIN NOTE: add vars and values in matching order
    // add a var by adding a new define VAR_NEW_VAR = NUM_VARS++
    const char *szVars[] = {

#define VAR_EXTRACT_DIR     0       // dir hook CABs are expanded to temporarily
        "%EXTRACT_DIR%",

#define VAR_OBJECT_DIR      1       // dir the main object will be installed to
        "%OBJECT_DIR%",             // usually activex cache dir, sometimes
                                    // a conflict dir or dir of prev version
                                    // of object

#define VAR_SRC_URL         2       // CODEBASE where we got this from
        "%SRC_URL%",                
                                    
                                    

#define NUM_VARS            3

        ""
    };

    char      szSrcURL[INTERNET_MAX_URL_LENGTH];
    LPCWSTR   wzSrcURL = NULL;

    szSrcURL[0] = '\0';
    if ((wzSrcURL = GetSrcURL()) != NULL) {
        WideCharToMultiByte(CP_ACP, 0, wzSrcURL, -1, szSrcURL, MAX_PATH, 0, 0);
    }

    const char *szValues[NUM_VARS + 1];
    szValues[VAR_EXTRACT_DIR] = GetHookDir();
    szValues[VAR_OBJECT_DIR] = GetObjectDir();
    szValues[VAR_SRC_URL] = szSrcURL;
    szValues[NUM_VARS] = NULL;
    // END NOTE: add vars and values in matching order


    if (m_flags & RSC_FLAG_INF) {

        flags |= RSC_FLAG_QUIET;

        if (g_dwCodeDownloadSetupFlags & CDSF_USE_SETUPAPI)
            flags |= RSC_FLAG_SETUPAPI;

        // get fully qualified name for INF

        if (GetHookDir()) {

            if (!catDirAndFile(szBuf, SIZE_CMD_LINE, GetHookDir(),
                               m_szInf)) {
                hr = E_UNEXPECTED;
                goto Exit;
            }
        } else {

            // no hook dir
            Assert(m_pdl->GetExtn() != FILEXTN_CAB);

            StrNCpy(szBuf, m_pdl->GetFileName(), sizeof(szBuf));
        }

    } else {

        // cmd line

        // have ADVPACK expand out custom LDID vars in run= cmdline
        // then we will process for our own vars
        // this allows the user to specify custom dirs thru the INF
        // and use it in the cmd line off registry keys

        hr = TranslateString();
        if (FAILED(hr))
            goto Exit;

        // look for and substitute variables like %EXTRACT_DIR%
        // and expand out the command line

        hr = ExpandCommandLine(m_szInf, szBuf, SIZE_CMD_LINE, szVars, szValues);

        if (FAILED(hr))
            goto Exit;

        hr = S_OK;  // reset

    }

    nStatusText = MultiByteToWideChar(CP_ACP, 0, szBuf,
        -1, szStatusText, SIZE_CMD_LINE);


#ifdef WX86
    if (m_pdl->GetCodeDownload()->GetMultiArch()->GetRequiredArch() == PROCESSOR_ARCHITECTURE_INTEL) {
        hr = g_RunSetupHook.RunSetupCommandX86(hWnd,
            szBuf,
            m_szInfSection,
            // extracted files in this dir
            (char *)((GetHookDir())?GetHookDir():m_pdl->GetCodeDownload()->GetCacheDir()),
            NULL, /*title*/
            &hExe,                          // handle to wait on for EXE
            flags,
            NULL);
    } else {
        hr = g_RunSetupHook.RunSetupCommand(hWnd,
            szBuf,
            m_szInfSection,
            // extracted files in this dir
            (char *)((GetHookDir())?GetHookDir():m_pdl->GetCodeDownload()->GetCacheDir()),
            NULL, /*title*/
            &hExe,                          // handle to wait on for EXE
            flags,
            NULL);
    }
#else
    hr = g_RunSetupHook.RunSetupCommand(hWnd,
        szBuf,
        m_szInfSection,
        // extracted files in this dir
        (char *)((GetHookDir())?GetHookDir():m_pdl->GetCodeDownload()->GetCacheDir()), 
        NULL, /*title*/
        &hExe,                          // handle to wait on for EXE
        flags,
        NULL);
#endif


    if (SUCCEEDED(hr) && (m_flags & RSC_FLAG_INF)) {

        // pass a notification to reboot
        if (hr == ERROR_SUCCESS_REBOOT_REQUIRED) {

            ICodeInstall* pCodeInstall = pcdl->GetICodeInstall();
            if (pCodeInstall) {
                pCodeInstall->OnCodeInstallProblem(
                                    CIP_NEED_REBOOT,
                                    NULL, szStatusText, 0);
            }

            pcdl->SetRebootRequired();
            hr = S_OK;
        }
    }

    // if we launched an EXE then we would have to mark as waiting for it
    if (hExe != INVALID_HANDLE_VALUE) {
        
        pcdl->SetWaitingForEXE(szBuf, FALSE /*don't delete EXE */);
        pcdl->SetWaitingForEXEHandle(hExe);
    }

Exit:

    if (FAILED(hr)) {
        pcdl->CodeDownloadDebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_RUNSETUPHOOK_FAILED, hr, m_szInf);
    } else {
        pcdl->CodeDownloadDebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_HOOK_COMPLETE, m_szHook);

    }


    SetState(INSTALL_DONE);

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\langcode.cxx ===
/*=========================================================================*
 |     
 |                                                                         |
 |                Copyright 1995 by Microsoft Corporation                  |
 |                         KevinGj - January 1997                          |
 |                                                                         |
 |=========================================================================|
 |                  LangInfo.cpp : Locale/Language information             |
 *=========================================================================*/

#include <cdlpch.h>
//=======================================================================//

HRESULT GetLangStringMod(HMODULE hMod, LCID localeID, char *szThisLang, int iLen);


//**********nSize needs to be greater than 2 at least.
BOOL CLangInfo::GetAcceptLanguageString(LCID Locale, char *szAcceptLngStr, int nSize)
{
    CHAR szThisLang[MAX_PATH];
    BOOL bRetVal = TRUE;
    HRESULT hr;
    
    if (!m_hMod)
    {
        m_hMod = LoadLibrary("mlang.dll");
    }
    if (!m_hMod) 
    {   
        bRetVal = FALSE;
        goto Exit;
    }

    hr = GetLangStringMod(m_hMod, Locale, szThisLang, sizeof(szThisLang));

    if (SUCCEEDED(hr))
    {
        if (lstrlenA(szThisLang) < nSize)
        {
            strcpy(szAcceptLngStr, szThisLang);
            
            DEBUG_PRINT(DOWNLOAD, 
                INFO,
                ("CLangInfo::GetAcceptLanguageString::this=%#x, szAcceptLngStr=%.10q\n",
                this, szAcceptLngStr
                ));
        }
        else
        {
            bRetVal = FALSE;
        }
        
        goto Exit;
    }
    
    LCID lcid = (NULL);
    char szLocaleStr[10];
    lcid = GetPrimaryLanguageInfo(Locale, szLocaleStr, sizeof(szLocaleStr)); 
    if(lcid)
    {
    	 hr = GetLangStringMod(m_hMod, lcid, szThisLang, sizeof(szThisLang));
        if (SUCCEEDED(hr) && (lstrlenA(szThisLang) < nSize))
        {   
            strcpy(szAcceptLngStr, szThisLang);
            szAcceptLngStr[2] = '\0';
            
            DEBUG_PRINT(DOWNLOAD, 
                INFO,
                ("CLangInfo::GetAcceptLanguageString-Primary::this=%#x, szAcceptLngStr=%.10q\n",
                this, szAcceptLngStr
                ));
                
            goto Exit;
        }
    }
    
    bRetVal = FALSE;

Exit:
    return bRetVal;
}

//-----------------------------------------------------------------------//

BOOL CLangInfo::GetLocaleStrings(LCID Locale, char *szLocaleStr, int iLen) const

{
    int iReturn = 0;
    char szBuff[50];

    iReturn = GetLocaleInfo(Locale, LOCALE_SABBREVLANGNAME, szBuff, sizeof(szBuff));
    
    if((!iReturn) ||  ((sizeof(szLocaleStr)/sizeof(szLocaleStr[0])) < iReturn))
        return(0);

    StrNCpy(szLocaleStr, szBuff, iLen);
    return(TRUE);
}


//-----------------------------------------------------------------------//

LCID CLangInfo::GetPrimaryLanguageInfo(LCID Locale, char *szLocaleStr, int iLen) const
{
    LCID lcid = NULL;
    int iReturn = 0;
    char szBuff[50];

    lcid = MAKELCID(MAKELANGID(PRIMARYLANGID(LANGIDFROMLCID(Locale)), SUBLANG_DEFAULT), SORT_DEFAULT);
    iReturn = GetLocaleInfo(lcid, LOCALE_SABBREVLANGNAME, szBuff, sizeof(szBuff));
    
    if((!iReturn) ||  ((sizeof(szLocaleStr)/sizeof(szLocaleStr[0])) < iReturn))
        return(0);

    StrNCpy(szLocaleStr, szBuff, iLen);
    return(lcid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\langcode.h ===
/*=========================================================================*
 |                LRC32 - Localized Resource Test Utility                  |
 |                                                                         |
 |                Copyright 1996 by Microsoft Corporation                  |
 |                         KevinGj - January 1996                          |
 |                                                                         |
 |=========================================================================|
 |              LangInfo.h : Header for the CLangInfo class                |
 *=========================================================================*/

#ifndef LANGCODE_H
#define LANGCODE_H


#include "windows.h"

class CLangInfo
{
public:
    //Constructors
    CLangInfo()
    {
        m_hMod = LoadLibrary("mlang.dll");
    }

    ~CLangInfo()
    {
        if (m_hMod)
            FreeLibrary(m_hMod);
    }
    
    //Queries
    BOOL GetAcceptLanguageString(LCID Locale, char *szAcceptLngStr, int nSize);
    BOOL GetLocaleStrings(LCID Locale, char *szLocaleStr, int iLen) const;

private:
    LCID GetPrimaryLanguageInfo(LCID Locale, char *szLocaleStr, int iLen) const;
    HMODULE m_hMod;

};

#endif // LANGINFO_H

//=======================================================================//
//                                          - EOF -                                 //
//=======================================================================//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\jit.cxx ===
// ===========================================================================
// File: JIT.CXX
//    The Just In Time setup of IE addon components
//

#include <cdlpch.h>
#include <mshtmhst.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <commctrl.h>
#include <shfusion.h>
#include <inseng.h>
#include "webjit.h"
#include "webjitres.h"

#include "mluisupp.h"
#include "shellapi.h"

#define IDD_JAVAVMJITDIALOG             20001
#define IDC_NOMOREDIALOG                20002
#define IDC_MOREINFO                    20003
#define IDC_STATIC                      -1
#define IDS_JAVAVMFAQURL		        20005

const CLSID CLSID_AppletOCX = { 0x08B0e5c0, 0x4FCB, 0x11CF, 0xAA, 0xA5, 0x00, 0x40, 0x1C, 0x60, 0x85, 0x01 };
const char *g_pszCLSID_AppletOCX = "{08B0e5c0-4FCB-11CF-AAA5-00401C608501}";
const WCHAR *g_pwszCLSID_AppletOCX = L"{08B0e5c0-4FCB-11CF-AAA5-00401C608501}";
#ifdef UNIX
#include <unixfile.h>
#endif /* UNIX */

extern HINSTANCE g_hInst;

HRESULT
GetComponentIDFromIEFeature(LPCSTR pszIEFeature, LPSTR *ppszComponentID)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "GetComponentIDFromIEFeature",
                "%.80q, %#x",
                pszIEFeature, ppszComponentID
                ));

    HRESULT hr = S_OK;
    HKEY hkeyFeatureComponentID =0;
    DWORD lResult;
    char szComponentID[MAX_PATH];
    DWORD dwSize = MAX_PATH;
    DWORD dwType;


    *ppszComponentID = NULL;

    if ((lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
        REGKEY_ACTIVESETUP_FEATURECOMPID, 0, KEY_READ,
        &hkeyFeatureComponentID)) != ERROR_SUCCESS) {

        hr = HRESULT_FROM_WIN32(lResult);
        goto Exit;
    }


    szComponentID[0] = '\0';
    if (SHQueryValueEx(hkeyFeatureComponentID, pszIEFeature, NULL, &dwType, 
                        (unsigned char *)szComponentID, &dwSize) == ERROR_SUCCESS) {

        *ppszComponentID = new char [dwSize+1];
        if (*ppszComponentID == NULL) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        lstrcpy(*ppszComponentID, szComponentID);

        // FALLTHROUGH to exit

    } else {
        hr = E_UNEXPECTED;
        // FALLTHROUGH to exit
    }

Exit:

    if (hkeyFeatureComponentID)
        ::RegCloseKey(hkeyFeatureComponentID);

    DEBUG_LEAVE(hr);
    return hr;
}


HRESULT GetComponentIDFromCLSSPEC(uCLSSPEC *pClassspec, LPSTR * ppszComponentID)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "GetComponentIDFromCLSSPEC",
                "%#x, %#x",
                pClassspec, ppszComponentID
                ));
                
    HRESULT hr = S_OK;
    *ppszComponentID = NULL;
    LPWSTR pwszIEFeature = NULL;
    LPSTR pszIEFeature = NULL;
    LPCWSTR pwszMimeType = NULL;
    CLSID inclsid = CLSID_NULL;
    QUERYCONTEXT qcInternal;
    memset(&qcInternal, 0, sizeof(QUERYCONTEXT));
    BOOL bUnknown = FALSE;
    int iRes = 0;
    int length = 0;

    switch(pClassspec->tyspec)
    {
        case TYSPEC_PROGID:

            // BUGBUG: we don't have JIT tables for progid to feature id
            // so this will only work for PEEK for installed versions
            if (FAILED((hr=CLSIDFromProgID(pClassspec->tagged_union.pProgId, 
                    &inclsid))))
                goto Exit;

            hr = GetIEFeatureFromClass(&pwszIEFeature, inclsid, &qcInternal);
            if (hr != S_OK)
                goto Exit;

            break;

        case TYSPEC_CLSID:
            inclsid = pClassspec->tagged_union.clsid;
            hr = GetIEFeatureFromClass(&pwszIEFeature, inclsid, &qcInternal);

            if (hr != S_OK)
                goto Exit;

            break;

        case TYSPEC_MIMETYPE:
            pwszMimeType = (LPCWSTR) pClassspec->tagged_union.pMimeType;
            hr = GetIEFeatureFromMime(&pwszIEFeature, pwszMimeType, &qcInternal);

            if (hr != S_OK)
                goto Exit;

            break;

        case TYSPEC_FILENAME:

            // overload filename to be Active Setup feature ID
            hr = CDLDupWStr( &pwszIEFeature, pClassspec->tagged_union.pFileName);
            if (hr != S_OK)
                goto Exit;

            break;

        default:
            hr = E_INVALIDARG;
            goto Exit;
    }

    if(pwszIEFeature == NULL)
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    // Change the wide character IEFeature to a multibyte string
    length = lstrlenW(pwszIEFeature) + 1;
    pszIEFeature = new CHAR[length];
    if(pszIEFeature == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    bUnknown = FALSE;
    iRes = WideCharToMultiByte(CP_ACP, 0, pwszIEFeature,length, 
                                   pszIEFeature, length,NULL,&bUnknown);
    // unknown multibyte character
    if(bUnknown == TRUE)
    {
        hr = E_INVALIDARG;
        goto Exit;
    }
    // failed for other reason
    if(iRes == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    
    // Get a ComponentID from the FeatureID
    hr = GetComponentIDFromIEFeature(pszIEFeature, ppszComponentID);
    if(FAILED(hr))
    {
        goto Exit;
    }

    hr = S_OK;

Exit:
    SAFEDELETE(pszIEFeature);
    SAFEDELETE(pwszIEFeature);

    DEBUG_LEAVE(hr);
    return hr;
}


#define FEATURE_VERSION_SEPARATOR       ';'
#define ALT_FEATURE_VERSION_SEPARATOR   '!'

// if the IE Feature for this mime/clsid has an IE recommended version
// then modify the querycontext to reflect this as if the caller wanted this
// version. If the caller already has specifies a version that overrides
// the recommnedation.
// format: featurename;a,b,c,d

HRESULT
ParseIEFeature(LPSTR pszIEFeatureWithVersion,
    QUERYCONTEXT *pQuery,
    LPWSTR *ppwszIEFeature,
    QUERYCONTEXT *pQueryRec)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "ParseIEFeature",
                "%.80q, %#x, %#x, %#x",
                pszIEFeatureWithVersion, pQuery, ppwszIEFeature, pQueryRec
                ));
                
    HRESULT hr = S_OK;
    DWORD dwIERecommendedVersionHi = 0;
    DWORD dwIERecommendedVersionLo = 0;

    LPSTR pchVersion = StrChr(pszIEFeatureWithVersion, FEATURE_VERSION_SEPARATOR);

    if (!pchVersion) 
    {
        pchVersion = StrChr(pszIEFeatureWithVersion, ALT_FEATURE_VERSION_SEPARATOR);
    }

    if (pchVersion) 
    {
        *pchVersion = '\0';  // stomp version separator so 
                            // pszIEFetaureWithVersion has just the feature name
        pchVersion++;

        if (*pchVersion 
            && ((!(pQuery->dwVersionHi|pQuery->dwVersionLo))
                || pQueryRec)) 
        {
            // now pointing at version string
            // of format a,b,c,d

            hr = GetVersionFromString(pchVersion,
                    &dwIERecommendedVersionHi, &dwIERecommendedVersionLo);

            if ( SUCCEEDED(hr)) 
            {
                if (!(pQuery->dwVersionHi|pQuery->dwVersionLo))
                {
                    pQuery->dwVersionHi = dwIERecommendedVersionHi;
                    pQuery->dwVersionLo = dwIERecommendedVersionLo;
                }
                if (pQueryRec)
                {
                    pQueryRec->dwVersionHi = dwIERecommendedVersionHi;
                    pQueryRec->dwVersionLo = dwIERecommendedVersionLo;
                }
            }
            else if (pQuery->dwVersionHi|pQuery->dwVersionLo)
            {
                hr = S_OK; //don't introduce new error codes into path if query already has version (COMPAT)
            }
        }
    }

    if ( SUCCEEDED(hr) && ppwszIEFeature) 
        hr=Ansi2Unicode(pszIEFeatureWithVersion, ppwszIEFeature);

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT
GetIEFeatureFromMime(LPWSTR *ppwszIEFeature, LPCWSTR pwszMimeType, QUERYCONTEXT *pQuery, QUERYCONTEXT* pQueryRec)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "GetIEFeatureFromMime",
                "%#x, %.80wq, %#x, %#x",
                ppwszIEFeature, pwszMimeType, pQuery, pQueryRec
                ));

    HRESULT hr = S_OK;
    HKEY hkeyMimeFeature =0;
    LPSTR pszMime = NULL;
    DWORD lResult;
    char szFeature[MAX_PATH];
    DWORD dwSize = MAX_PATH;
    DWORD dwType;

    if (FAILED((hr=::Unicode2Ansi(pwszMimeType, &pszMime))))
    {
        goto Exit;
    }

    if ((lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
        REGKEY_ACTIVESETUP_MIMEFEATURE, 0, KEY_READ,
        &hkeyMimeFeature)) != ERROR_SUCCESS) 
    {
#if JIT_IN_BUILD
        hr = HRESULT_FROM_WIN32(lResult);
#else
        hr = S_FALSE;
#endif
        goto Exit;
    }


    szFeature[0] = '\0';
    if (SHQueryValueEx(hkeyMimeFeature, pszMime, NULL, &dwType, 
                        (unsigned char *)szFeature, &dwSize) == ERROR_SUCCESS) 
    {
        if (dwSize > MAX_PATH) 
        {
            // limit the feature name to MAX_PATH as buffer overrun protection
            hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
            goto Exit;
        }

        hr = ParseIEFeature(szFeature, pQuery, ppwszIEFeature, pQueryRec);

        // FALLTHROUGH to exit
    }
    else
    {
        hr = S_FALSE;
        // FALLTHROUGH to exit
    }

Exit:

    if (hkeyMimeFeature)
        ::RegCloseKey(hkeyMimeFeature);

    delete[] pszMime;

    DEBUG_LEAVE(hr);
    return hr;
}


HRESULT
GetIEFeatureFromClass(LPWSTR *ppwszIEFeature, REFCLSID clsid, QUERYCONTEXT *pQuery, QUERYCONTEXT *pQueryRec)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "GetIEFeatureFromClass",
                "%#x, %#x, %#x",
                ppwszIEFeature, &clsid, pQuery, pQueryRec
                ));

    HRESULT hr = S_OK;
    LPOLESTR pwcsClsid = NULL;
    LPSTR pszClsid = NULL;
    HKEY hkeyClsidFeature =0;
    DWORD lResult;
    char szFeature[MAX_PATH];
    DWORD dwSize = MAX_PATH;
    DWORD dwType;


    // return if we can't get a valid string representation of the CLSID
    if (FAILED((hr=StringFromCLSID(clsid, &pwcsClsid))))
        goto Exit;

    if (FAILED((hr=::Unicode2Ansi(pwcsClsid, &pszClsid))))
    {
        goto Exit;
    }

    if ((lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
        REGKEY_ACTIVESETUP_CLSIDFEATURE, 0, KEY_READ,
        &hkeyClsidFeature)) != ERROR_SUCCESS)
    {
#if JIT_IN_BUILD
        hr = HRESULT_FROM_WIN32(lResult);
#else
        hr = S_FALSE;
#endif
        goto Exit;
    }


    szFeature[0] = '\0';
    if (SHQueryValueEx(hkeyClsidFeature, pszClsid, NULL, &dwType, 
                        (unsigned char *)szFeature, &dwSize) == ERROR_SUCCESS)
    {
        if (dwSize > MAX_PATH) 
        {
            // limit the feature name to MAX_PATH as buffer overrun protection
            hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
            goto Exit;
        }

        hr = ParseIEFeature(szFeature, pQuery, ppwszIEFeature, pQueryRec);
        // FALLTHROUGH to exit

    }
    else
    {
        hr = S_FALSE;
        // FALLTHROUGH to exit
    }

Exit:

    if (hkeyClsidFeature)
        ::RegCloseKey(hkeyClsidFeature);

    SAFEDELETE(pwcsClsid);
    SAFEDELETE(pszClsid);

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT
IsActiveSetupFeatureLocallyInstalled(
    LPCSTR pszDist,
    QUERYCONTEXT *pQuery,
    LPSTR *ppszComponentID,
    DWORD *pdwVersionHi,
    DWORD *pdwVersionLo,
    DWORD dwFlags)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "IsActiveSetupFeatureLocallyInstalled",
                "%.80q, %#x, %#x, %#x, %#x, %#x",
                pszDist, pQuery, ppszComponentID, pdwVersionHi, pdwVersionLo, dwFlags
                ));
                
    HRESULT hr = S_FALSE;       // Not installed by active setup.
    LONG    lResult = ERROR_SUCCESS;
    CHAR* pszKey = NULL;
    BOOL bAllocedKey = FALSE;
    int     nKey;
     
    char    szKey[2*MAX_PATH];
    char    szVersion[MAX_PATH];
    HKEY    hKey    = NULL;
    DWORD   dwSize;
    DWORD   dwValue;
    DWORD   dwType;
    BOOL    fIsInstalled = FALSE;
    WORD    wVersion[4];
    DWORD   dwCurMS = 0;
    DWORD   dwCurLS = 0;

    const static char * szLocale = "Locale";
    const static char * szIsInstalled = "IsInstalled";
    const static char * szActVersion = "Version";
    const static char * szCOMPONENTID = "ComponentID";
    const static char * szKEYFILENAME = "KeyFileName";

    if (pdwVersionHi && pdwVersionLo) 
    {
        *pdwVersionHi = 0;
        *pdwVersionLo = 0;
    }

    if (ppszComponentID) 
    { 
        // if we need a componentID
        GetComponentIDFromIEFeature(pszDist, ppszComponentID);
    }

    ULONG ulenDist = lstrlenA(pszDist);
    //sizeof counts terminating NULL also, so subtract 2, and add 1 for the final NULL
    ULONG ulenConst = sizeof(REGKEY_ACTIVESETUP_COMPONENTS)/sizeof(CHAR) + sizeof("\\")/sizeof(CHAR) - 2 + 1;
    
    if ((ulenDist+ulenConst)  > sizeof(szKey))
    {
    	pszKey = new CHAR[ulenDist+ulenConst];
    }

    if (pszKey)
    {
    	bAllocedKey = TRUE;
    	nKey = ulenDist+ulenConst;
    }
    else
    {
    	pszKey = szKey;
    	nKey = sizeof(szKey);
    }

    StrNCpy(pszKey, REGKEY_ACTIVESETUP_COMPONENTS, nKey);
    StrCatBuff(pszKey, "\\", nKey);
    StrCatBuff(pszKey, pszDist, nKey);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwValue);
        // Old format of the Installed components did not have the IsInstalled value.
        if (RegQueryValueEx( hKey, szIsInstalled, NULL, NULL, (LPBYTE)&dwValue, &dwSize) != ERROR_SUCCESS)
        {
            dwValue = 0;
        }
        fIsInstalled = (dwValue != 0);
        if (fIsInstalled)
        {
            hr = S_OK;

        } 
        else 
        {
            // hr is S_FALSE;
            goto Exit;
        }

        if (pQuery && ((pQuery->dwVersionHi|pQuery->dwVersionLo) ||
                        (dwFlags & FIEF_FLAG_PEEK)) ) 
        {
            dwSize = sizeof(szVersion);
            if ( (lResult = RegQueryValueEx(hKey, szActVersion, NULL, &dwType, (LPBYTE)szVersion, &dwSize)) == ERROR_SUCCESS )
            {
                Assert(dwType == REG_SZ);

                if ( SUCCEEDED(GetVersionFromString(szVersion, &dwCurMS, &dwCurLS)))
                {
                    if (dwCurMS > pQuery->dwVersionHi ||
                     (dwCurMS == pQuery->dwVersionHi && dwCurLS >= pQuery->dwVersionLo)) 
                    {
                        hr = S_OK;
                    } 
                    else 
                    {
                        hr = S_FALSE;
                    }

                    if (pdwVersionHi && pdwVersionLo) 
                    {
                        *pdwVersionHi = dwCurMS;
                        *pdwVersionLo = dwCurLS;
                    }
                } 
                else 
                {
                    hr = S_FALSE;
                }
            } 
            else 
            {
                hr = S_FALSE;
            }
        }

        if (hr == S_OK) 
        {
            // we think it is installed
            // robustify with key file presence check
            dwSize = sizeof(szVersion);
            dwType = REG_SZ;
            if ( SHQueryValueEx(hKey, szKEYFILENAME, NULL, &dwType, (LPBYTE)szVersion, &dwSize) == ERROR_SUCCESS ) 
            {
                // value present, check if file is present
                if (GetFileAttributes(szVersion) == -1)
                    hr = S_FALSE;
            }
        }
    }

Exit:

    if (bAllocedKey)
    {
       delete [] pszKey;
    }

    SAFEREGCLOSEKEY(hKey);

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT
GetInstalledVersion(
    LPCWSTR pwszIEFeature,
    QUERYCONTEXT *pQuery)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "GetInstalledVersion",
                "%.100wq, %#x",
                pwszIEFeature, pQuery
                ));
                
    HRESULT hr = E_FAIL;
    LPSTR pszIEFeature = NULL;
    HKEY hKey = NULL;
    LONG    lResult = ERROR_SUCCESS;
    CHAR* pszKey = NULL;
    BOOL bAllocedKey = FALSE;
    int 	nKey;
     
    char szKey[2*MAX_PATH];
    char szVersion[MAX_PATH];
    DWORD dwSize, dwType;
    DWORD dwCurMS, dwCurLS;
    const static char * szActVersion = "Version";
    
    if (FAILED((hr=::Unicode2Ansi(pwszIEFeature, &pszIEFeature))))
    {
        goto Exit;
    }

    ULONG ulenDist = lstrlenA(pszIEFeature);
    //sizeof counts terminating NULL also, so subtract 2, and add 1 for the final NULL
    ULONG ulenConst = sizeof(REGKEY_ACTIVESETUP_COMPONENTS)/sizeof(CHAR) + sizeof("\\")/sizeof(CHAR) - 2 + 1;
    
    if ((ulenDist+ulenConst)  > sizeof(szKey))
    {
    	pszKey = new CHAR[ulenDist+ulenConst];
    }

    if (pszKey)
    {
    	bAllocedKey = TRUE;
    	nKey = ulenDist + ulenConst;
    }
    else
    {
    	pszKey = szKey;
    	nKey = sizeof(szKey);
    }
    
    StrNCpy(pszKey, REGKEY_ACTIVESETUP_COMPONENTS, nKey);
    StrCatBuff(pszKey, "\\", nKey);
    StrCatBuff(pszKey, pszIEFeature, nKey);
    
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(szVersion);
        if ( (lResult = RegQueryValueEx(hKey, szActVersion, NULL, &dwType, (LPBYTE)szVersion, &dwSize)) == ERROR_SUCCESS )
        {
            Assert(dwType == REG_SZ);

            if ( SUCCEEDED(GetVersionFromString(szVersion, &dwCurMS, &dwCurLS)))
            {
                if (pQuery) 
                {
                    pQuery->dwVersionHi = dwCurMS;
                    pQuery->dwVersionLo = dwCurLS;
                    hr = S_OK;
                }
            }
        }
    }
    
Exit:

    if (bAllocedKey)
    {
       delete [] pszKey;
    }

    if (pszIEFeature)
    {
        delete [] pszIEFeature;
    }

    SAFEREGCLOSEKEY(hKey);

    DEBUG_LEAVE(hr);
    return hr;
}

typedef HRESULT (*PFNGETICIFFILEFROMFILE)(ICifFile **, LPCSTR pszFile);

HRESULT
IsCIFVersionGoodEnough(
    QUERYCONTEXT *pQuery,
    LPCSTR pszID)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "IsCIFVersionGoodEnough",
                "%#x, %.80q",
                pQuery, pszID
                ));
                
    // BUGBUG: not side by side aware!!!
    const static char * szCIFPATH = "iesetup.cif";

    HRESULT hr = S_OK;
    ICifFile *pcif;
    ICifComponent *pcomp;
    DWORD dwVersionHi = 0;
    DWORD dwVersionLo = 0;
    PFNGETICIFFILEFROMFILE pfnGetICifFileFromFile = NULL;
    HMODULE hMod = LoadLibrary("inseng.dll");

    if ( !hMod ||
        (!(pfnGetICifFileFromFile = (PFNGETICIFFILEFROMFILE)GetProcAddress(hMod,
        "GetICifFileFromFile")))) {

        DEBUG_LEAVE(E_UNEXPECTED);
        return E_UNEXPECTED;
    }

    if(SUCCEEDED(pfnGetICifFileFromFile(&pcif, szCIFPATH)))   // szCifPath is full path to cif, or 8.3 and it defaults to look in ie dir for it
    {
       if(SUCCEEDED(pcif->FindComponent(pszID, &pcomp)))   // pszID is id of what you are interested in
       {
          pcomp->GetVersion(&dwVersionHi, &dwVersionLo);
          // BUGBUG: ?
          // pcomp->Release();

        if (pQuery->dwVersionHi > dwVersionHi ||
         (dwVersionHi == pQuery->dwVersionHi && pQuery->dwVersionLo > dwVersionLo)) {
            hr = HRESULT_FROM_WIN32(ERROR_UNKNOWN_REVISION);
        }

       }
       pcif->Release();
    }


    if (hMod)
        FreeLibrary(hMod);

    DEBUG_LEAVE(hr);
    return hr;
}


/* Returns:
 *
 *      S_OK:    Is Installed
 *      S_FALSE: Is Available, Needs to be faulted in.
 *      ERROR
 *
 */

HRESULT
IsIEFeatureInstalled(
    LPCWSTR pwszIEFeature,
    QUERYCONTEXT *pQuery,
    LPWSTR *ppwszSetupPage,
    LPWSTR *ppwszCompID,
    DWORD dwFlags,
    BOOL *pbWebJit,
    LPSTR *ppszWebJitUrl,
    BOOL fOnlyCheckInstall
    )
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "IsIEFeatureInstalled",
                "%.80wq, %#x, %#x, %#x, %#x, %B",
                pwszIEFeature, pQuery, ppwszSetupPage, ppwszCompID, dwFlags, fOnlyCheckInstall
                ));
                
    HRESULT hr = S_FALSE;   // assume need to fault in
    LPSTR pszIEFeature = NULL;
    LPSTR pszComponentID = NULL;
    const static char * szSETUPPAGE = "JITSetupPage";
    const static char * szQUERYFEATURE = "feature=";
    LONG lResult;
    HKEY hkeyActiveSetup = 0;
    HKEY hkeyWebJitUrls = 0;
    char szJITPage[INTERNET_MAX_URL_LENGTH];
    DWORD dwType;
    DWORD dwSize = INTERNET_MAX_URL_LENGTH;
    DWORD dwInstalledVersionHi =0;
    DWORD dwInstalledVersionLo =0;
    BOOL  bComponentDeclined = FALSE;

#ifdef UNIX
    {
        /* Unix special handling for features like java VM
         * For instance, libmsjava.so will always be installed.
         * But, is the Sun VM installed?
         */
        hr = CheckIEFeatureOnUnix(pwszIEFeature, &dwInstalledVersionHi, &dwInstalledVersionLo, dwFlags);
        if (hr == S_OK || hr == ERROR_PRODUCT_UNINSTALLED)
           goto Exit; /* Found on Unix and Handled */
    }
#endif /* UNIX */

    if (FAILED((hr=::Unicode2Ansi(pwszIEFeature, &pszIEFeature))))
    {
        goto Exit;
    }

    hr = IsActiveSetupFeatureLocallyInstalled(pszIEFeature, pQuery, fOnlyCheckInstall ? NULL : &pszComponentID, &dwInstalledVersionHi, &dwInstalledVersionLo, dwFlags);

    if (fOnlyCheckInstall)
    {
        goto Exit;
    }
    
    if (hr == S_FALSE) 
    {
        // not installed, need to JIT
        // find out if this is JITDeclined

        if (SHRegGetUSValue( REGKEY_DECLINED_IOD, pszIEFeature, NULL, NULL, NULL, 0,NULL,0) == ERROR_SUCCESS)
        {
            bComponentDeclined = TRUE;
        }
    }

    if (((hr != S_OK) || dwFlags & FIEF_FLAG_SKIP_INSTALLED_VERSION_CHECK)
        && ppwszSetupPage && ppwszCompID) 
    {
        if (pszComponentID && ppszWebJitUrl && pbWebJit)
        {
            if ((lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
                REGKEY_WEBJITURLS, 0, KEY_READ,
                &hkeyWebJitUrls)) == ERROR_SUCCESS) 
            {
                //reuse temporary array for WebJITURL
                szJITPage[0] = '\0';
                if (SHQueryValueEx(hkeyWebJitUrls, pszComponentID, NULL, &dwType, 
                    (unsigned char *)szJITPage, &dwSize) == ERROR_SUCCESS) 
                {
                    LPSTR pszWebJitUrl = new CHAR[dwSize+1];

                    if (!pszWebJitUrl)
                    {
                        hr = E_OUTOFMEMORY;
                        goto Exit;
                    }
                    lstrcpy(pszWebJitUrl, szJITPage);
                    *ppszWebJitUrl = pszWebJitUrl;
                    *pbWebJit = TRUE;
                    HRESULT hr1 = ::Ansi2Unicode(pszComponentID, ppwszCompID);
                    if (FAILED(hr1))
                    {
                        hr = hr1;
                    }
                    goto Exit;
                }
            }
            *pbWebJit = FALSE;
        }

        if ((lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE, 
                REGKEY_ACTIVESETUP, 0, KEY_READ,
                &hkeyActiveSetup)) != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
        }

        szJITPage[0] = '\0';
        if (SHQueryValueEx(hkeyActiveSetup, szSETUPPAGE, NULL, &dwType, 
            (unsigned char *)szJITPage, &dwSize) == ERROR_SUCCESS) 
        {
            HRESULT hr1 = ::Ansi2Unicode(szJITPage, ppwszSetupPage);
            if(FAILED(hr1))
                hr = hr1;       // else hr still = S_FALSE;

            if (pszComponentID) 
            {
                if ((sizeof(szQUERYFEATURE) + lstrlen(pszComponentID) +1)
                    < INTERNET_MAX_URL_LENGTH)
                {
                    lstrcpy(szJITPage, szQUERYFEATURE);
                    lstrcat(szJITPage, pszComponentID);

                    if ( (dwFlags & FIEF_FLAG_CHECK_CIFVERSION) &&
                            pQuery && 
                            (pQuery->dwVersionHi|pQuery->dwVersionLo)) 
                    {
                        hr1=IsCIFVersionGoodEnough(pQuery, pszComponentID);
                        if (FAILED(hr1)) 
                        {
                            hr = hr1;
                            goto Exit;
                        }
                    }

                    HRESULT hr1 = ::Ansi2Unicode(szJITPage, ppwszCompID);
                    if(FAILED(hr1))
                        hr = hr1;       // else hr still = S_FALSE;
                } 
                else 
                {
                    hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
                }
            }
        }
    }

Exit:

    if (pQuery && (dwFlags & FIEF_FLAG_PEEK)) 
    {
        pQuery->dwVersionHi = dwInstalledVersionHi;
        pQuery->dwVersionLo = dwInstalledVersionLo;
    }

    SAFEDELETE(pszIEFeature);
    SAFEDELETE(pszComponentID);

    if (hkeyActiveSetup)
        RegCloseKey(hkeyActiveSetup);

    if (hkeyWebJitUrls)
        RegCloseKey(hkeyWebJitUrls);
        
    if (bComponentDeclined) 
    {
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
    }

    DEBUG_LEAVE(hr);
    return hr;
}
    

HRESULT
IsJITRestricted(BOOL bWebJit)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "IsJITRestricted",
                "%B",
                bWebJit
                ));

    HKEY hkeyRest = 0;
    BOOL bJITRest = FALSE;
    DWORD dwValue = 0;
    DWORD dwLen = sizeof(DWORD);
    HRESULT hr = S_OK;
    OSVERSIONINFO osvi;

    // BUGBUG: NT RAID #216898--when you install IE5 and the shell cabs
    // on NT5, the NoJITSetup reg value is blown away, but we can't figure
    // out who is doing this. JIT should not occur for NT5. This hack
    // is a work-around so JIT does not occur under NT5 and above.


    if (!bWebJit)
    {
        osvi.dwOSVersionInfoSize = sizeof(osvi);
        GetVersionEx(&osvi);

        if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
            osvi.dwMajorVersion >= 5) {
            hr = E_ACCESSDENIED;
            goto Exit;
        }
    }
    
    // per-machine JIT off policy
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_INFODEL_REST, 0, KEY_READ, &hkeyRest) == ERROR_SUCCESS) 
    {
        if (!bWebJit)
        {
            if (RegQueryValueEx( hkeyRest, REGVAL_JIT_REST, NULL, NULL,
                          (LPBYTE)&dwValue, &dwLen) == ERROR_SUCCESS && dwValue)
                hr = E_ACCESSDENIED;
        }
        else
        {
            if (RegQueryValueEx( hkeyRest, REGVAL_WEBJIT_REST, NULL, NULL,
                          (LPBYTE)&dwValue, &dwLen) == ERROR_SUCCESS && dwValue)
                hr = E_ACCESSDENIED;
        }
        RegCloseKey(hkeyRest);
    }

    if (SUCCEEDED(hr)) 
    {
        // Check to see if the user has turned it off under advanced options
        // make this appear in UI similar to the admin restricted case
        // hence the return value of access_denied
        dwValue = 0;
        dwLen = sizeof(DWORD);
        if (!bWebJit)
        {
            if (SHRegGetUSValue( REGSTR_PATH_IE_MAIN, REGVAL_JIT_REST, NULL, (LPBYTE)&dwValue, &dwLen, 0,NULL,0) == ERROR_SUCCESS && dwValue)
                hr = E_ACCESSDENIED;
        }
        else 
        {
            if (SHRegGetUSValue( REGSTR_PATH_IE_MAIN, REGVAL_WEBJIT_REST, NULL, (LPBYTE)&dwValue, &dwLen, 0,NULL,0) == ERROR_SUCCESS && dwValue)
                hr = E_ACCESSDENIED;
        }
    }

Exit:

    DEBUG_LEAVE(hr);
    return hr;
}
    
HRESULT
SetJITDeclined(
    LPCWSTR pwszIEFeature)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "SetJITDeclined",
                "%.80wq",
                pwszIEFeature
                ));
                
    HRESULT hr = S_FALSE;   // assume need to fault in
    LPSTR pszIEFeature = NULL;
    LONG    lResult = ERROR_SUCCESS;
    HKEY    hKey    = NULL;
    DWORD   dwSize;
    DWORD   dwValue;
    LPSTR szNull = "";

    if (FAILED((hr=::Unicode2Ansi(pwszIEFeature, &pszIEFeature))))
    {
        goto Exit;
    }


    if (RegOpenKeyEx(HKEY_CURRENT_USER, REGKEY_DECLINED_IOD, 0, KEY_WRITE, &hKey) != ERROR_SUCCESS)
    {
        if ((lResult = RegCreateKey( HKEY_CURRENT_USER,
                   REGKEY_DECLINED_IOD, &hKey)) != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
        }
    }

    if (((lResult = RegSetValueEx (hKey, pszIEFeature, 0, REG_SZ,
            (unsigned char *)szNull, 1))) != ERROR_SUCCESS) {

        hr = HRESULT_FROM_WIN32(lResult);
    }


Exit:

    if (hKey)
        RegCloseKey(hKey);

    SAFEDELETE(pszIEFeature);

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT
HasFeatureAlreadyBeenRejected(
    LPCWSTR szDistUnit)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "HasFeatureAlreadyBeenRejected",
                "%.80wq",
                szDistUnit
                ));
                
    HRESULT hr = S_OK;
    LISTPOSITION curpos;
    LPCWSTR pwszRejectedFeature = NULL;
    int iNumRejected;
    int i;

    CUrlMkTls tls(hr); // hr passed by reference!

    if (FAILED(hr))
        goto Exit;

    iNumRejected = tls->pRejectedFeaturesList->GetCount();
    curpos = tls->pRejectedFeaturesList->GetHeadPosition();

    // walk thru all the rejected features in the thread and check for match
    for (i=0; i < iNumRejected; i++) {

        pwszRejectedFeature = tls->pRejectedFeaturesList->GetNext(curpos);

        if (StrCmpIW(szDistUnit, pwszRejectedFeature) == 0) {

            hr = S_FALSE;
            break;
        }
    }

Exit:

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT
RelinquishCodeDownloadCookies()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "RelinquishCodeDownloadCookies",
                NULL
                ));
                
    HRESULT hr = S_OK;

    CUrlMkTls tls(hr); // hr passed by reference!
    if (FAILED(hr))
        goto Exit;

    Assert(tls->pTrustCookie);
    Assert(tls->pSetupCookie);

    if (!tls->pTrustCookie || !tls->pSetupCookie) {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    tls->pSetupCookie->JITRelinquish();
    tls->pTrustCookie->JITRelinquish();

Exit:

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT
AcquireCodeDownloadCookies()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "AcquireCodeDownloadCookies",
                NULL
                ));
                
    HRESULT hr = S_OK;
    HRESULT hrJITTrustCookie = E_FAIL;
    HRESULT hrJITSetupCookie = E_FAIL;

    CUrlMkTls tls(hr); // hr passed by reference!
    if (FAILED(hr))
        goto Exit;

    // are both cookies free?
    if (!(tls->pTrustCookie->IsFree() && tls->pSetupCookie->IsFree())) {
        hr = E_FAIL;
        goto Exit;
    }

    // if both cookies are free, grab them
    // thius will ensure that code downloads are
    // frozen or pended to the point JIT completes

    hrJITTrustCookie = tls->pTrustCookie->JITAcquire();

    if (FAILED(hrJITTrustCookie)) {
        Assert(TRUE);
        hr = hrJITTrustCookie;
        goto Exit;
    }

    hrJITSetupCookie = tls->pSetupCookie->JITAcquire();
    if (FAILED(hrJITSetupCookie)) {
        Assert(TRUE);
        hr = hrJITSetupCookie;
        goto Exit;
    }

    // taken both the cookies

Exit:

    if (FAILED(hr)) {

        if (SUCCEEDED(hrJITSetupCookie))
            tls->pSetupCookie->JITRelinquish();

        if (SUCCEEDED(hrJITTrustCookie))
            tls->pTrustCookie->JITRelinquish();
    }

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT
GetDialogArgs(LPCWSTR pwszCompID, DWORD dwFlags, VARIANT& vtDialogArg)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "GetDialogArgs",
                "%.80wq, %#x, %#x",
                pwszCompID, dwFlags, &vtDialogArg
                ));
                
    HRESULT hr = S_OK;
    WCHAR pwszFLAGS[] = L"&flag=forceUI";
    WCHAR pwszArgs[INTERNET_MAX_URL_LENGTH];// large buffer


    StrCpyNW(pwszArgs, pwszCompID, INTERNET_MAX_URL_LENGTH);

    if (dwFlags & FIEF_FLAG_FORCE_JITUI) {

        StrCatBuffW(pwszArgs, pwszFLAGS, INTERNET_MAX_URL_LENGTH);
    }

    vtDialogArg.bstrVal =  SysAllocString(pwszArgs);

    ASSERT(vtDialogArg.bstrVal); 
    if(vtDialogArg.bstrVal)
    {
        vtDialogArg.vt = VT_BSTR;   
    }
    else
    {
        hr =  E_OUTOFMEMORY;
        goto Exit;
    }

Exit:

    DEBUG_LEAVE(hr);
    return hr;
}

//for WebJit
#define MAX_URL_STRING      INTERNET_MAX_URL_LENGTH
VOID URLSubstitution(LPCSTR pszUrlIn, LPSTR pszUrlOut, DWORD cchSize, DWORD dwSubstitutions);
#define URLSUB_OLCID        0x00000040  // The hexadecimal Locale ID (LCID) or Language ID (LID) of the operating system.
#define URLSUB_CLCID        0x00000080  // The hexadecimal Locale ID (LCID) or Language ID (LID) of the current user?s Regional Setting (as in Control Panel).
#define URLSUB_ALL          0xFFFFFFFF

BOOL CALLBACK JavaVMJitProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam) 
{ 
    switch (message) 
    { 
        case WM_COMMAND: 
            switch (LOWORD(wParam)) 
            { 
                case IDOK: 
                    if (SendDlgItemMessage(hwndDlg, IDC_NOMOREDIALOG, BM_GETSTATE, 0, 0) == BST_CHECKED)
                    {
                        //Never ask again
                        SetJITDeclined(g_pwszCLSID_AppletOCX);
                    }

                    EndDialog(hwndDlg, wParam); 
                    return TRUE;
                case IDC_MOREINFO:
                    if (HIWORD(wParam) == BN_CLICKED)
                    {
                        TCHAR szJavaFAQRegUrl[1024], szJavaFAQUrl[1024];
                        if (0 < LoadString(g_hInst, IDS_JAVAVMFAQURL, szJavaFAQRegUrl, sizeof(szJavaFAQRegUrl)/sizeof(szJavaFAQRegUrl[0])))
                        {
                            URLSubstitution(szJavaFAQRegUrl, szJavaFAQUrl, sizeof(szJavaFAQRegUrl)/sizeof(szJavaFAQRegUrl[0]), URLSUB_OLCID|URLSUB_CLCID);
                            ShellExecute(hwndDlg, NULL, szJavaFAQUrl, NULL, NULL, SW_SHOWDEFAULT);
                        }
                    }
                    break;
            } 
    } 
    return FALSE; 
} 

/* 
 * FaultInIEFeature
 *
 * Description:
 *
 *      Synchronous API that is to be invoked by client of an IE feature before
 *      accessing the feature. If the feature is already installed then it 
 *      succeeds and the client should attempt to access the feature. Success
 *      return by the API does not guarantee that the feature is fully installed
 *      or will work. The client should still robustify access to the feature 
 *      with proper error checking.
 *      If the API detects that the feature is missing on the client then it
 *      maps the feature identified by a clsid or mimetype (in the classspec)
 *      into a feature name/id and then invokes a HTML dialog with the feature
 *      name in the form of http://...../setuppage.htm?FeatureName=<featurename>
 *      The page can communicate back a return value thru 
 *      window.external.returnValue. The following are recognized now:
 *
 *  #define JITPAGE_RETVAL_SUCCESS              0x0 // successfully installed
 *  #define JITPAGE_RETVAL_CANCELLED            0x1 // was cancelled by user
 *  #define JITPAGE_RETVAL_DONTASK_THISWINDOW   0x2 // don't ask again in this
 *
 * Parameters:
 *
 *      hWnd:           parent hwnd for htmldialog
 *      pClassSpec:     ptr to union {clsid, mimetype ...} 
 *      querycontext:   to specify version, lcid of feature(lcid not impl)
 *                      This is an IN/OUT param. The installed version
 *                      number is returned is FIEF_FLAG_PEEK is passed in
 *      dwFlags:        control behaviour such as UI/no UI, peek versus faultin
 *                      FIEF_FLAG_PEEK
 *
 *              FIEF_FLAG_FORCE_JITUI
 *                  Force JIT even if user has cancelled a previous JIT in
 *                  the same session or even asked to Never JIT this feature.
 *
 *              FIEF_FLAG_PEEK
 *                  Don't fault in just peek. Peek has the side effect of
 *                  returning currently installed version in the querycontext
 *
 *              FIEF_FLAG_SKIP_INSTALLED_VERSION_CHECK
 *                  Ignore local version being satisfactory and force JIT
 *                  download. Typically called by code download or other caller
 *                  after a CoCreateInstance call has failed with
 *                  REGDB_E_CLASSNOTREG or ERROR_MOD_NOT_FOUND (missing
 *                  dependency dll). The registry probably still looks like
 *                  this feature is installed, but really isn't or is damaged.
 *
 *
 * Returns:
 *
 *      S_OK:    Is Installed. Caller needs to CoCreate or BindToObject or some
 *               other system service to invoke the class or mime handler.
 *      S_FALSE: Class or Mime is not part of an IE feature. Caller needs to
 *               CoCreate or BindToObject or some other system service to 
 *               invoke the class or mime handler.
 *      E_ACCESSDENIED
 *               Admin has turned off JIT feature.
 *      HRESULT_FROM_WIN32(ERROR_CANCELLED):
 *               Could have been cancelled by the user or has been requested
 *               by user not to bother again in this browser window.
 *      HRESULT_FROM_WIN32(ERROR_PRODUCT_UNINSTALLED):
 *               Returned if the feature is not installed, but FIEF_FLAG_PEEK
 *               was specified
 *      HRESULT_FROM_WIN32(ERROR_REVISION_UNKNOWN);
 *               Returned when dwFlag FIEF_FLAG_CHECK_CIFVERSION is passed and
 *               the local version is not good enough AND the version in the CIF
 *               that would get JIT installed is also less then the version
 *               requested by the caller. This flag is typically passed by a
 *               caller such as code download in URLMON that has the means to
 *               get the requested version by installing the CODEBASE object.
 *
 *      ERROR:
 *               Other error.
 *
 */

#define HELP_CLSID L"{45ea75a0-a269-11d1-b5bf-0000f8051515}"

BOOL IsWin32X86();

STDAPI
FaultInIEFeature(
    HWND         hWnd,
    uCLSSPEC     *pClassSpec,
    QUERYCONTEXT *pQuery,
    DWORD        dwFlags
    )
{
    DEBUG_ENTER_API((DBG_DOWNLOAD,
                    Hresult,
                    "FaultInIEFeature",
                    "%#x, %#x, %#x, %#x",
                    hWnd, pClassSpec, pQuery, dwFlags
                    ));
                
    HRESULT hr = S_OK;
    HRESULT hrCDLCookies=E_FAIL;
    WCHAR *pwszMUISetupFile = NULL;
    WCHAR pwszMUISetupPage[MAX_PATH];
    CLSID inclsid = CLSID_NULL;
    LPCWSTR pwszDistUnit=NULL; 
    LPCWSTR pwszFileExt=NULL;
    LPCWSTR pwszMimeType=NULL;
    LPWSTR pwszIEFeature=NULL;
    LPWSTR pwszSetupPage=NULL;
    LPWSTR pwszCompID=NULL;
    HINSTANCE hInst = 0;
    IMoniker *pMk = NULL;
    SHOWHTMLDIALOGFN  *pfnShowHTMLDialog = NULL;
    VARIANT vtRetVal;
    VARIANT vtDialogArg;
    VariantInit(&vtRetVal);
    VariantInit(&vtDialogArg);
    QUERYCONTEXT qcInternal;

    BOOL   bShowHelp = FALSE;
    LPWSTR pwszHelpFeature=NULL;
    LPWSTR pwszHelpSetupPage=NULL;
    LPWSTR pwszHelpCompID=NULL;
    CLSID HelpCLSID = CLSID_NULL;
    QUERYCONTEXT qcHelp;

    LPSTR pszWebJitRegUrl = 0;
    LPSTR pszWebJitUrl = 0;
    BOOL  bWebJit = FALSE;
    QUERYCONTEXT qcRequested;
    QUERYCONTEXT qcRecommended;
    QUERYCONTEXT* pQueryInstalled = NULL;
    ULONG_PTR uCookie = 0;
    
    // setup the per thread tls list for rejected features, so we
    // don't bother the user multiple times for the same feature
    // needs review on whether this is per thread or per process

    CUrlMkTls tls(hr); // hr passed by reference!
    if (FAILED(hr))
        goto Exit;

    hr = SetCodeDownloadTLSVars();

    if (FAILED(hr))
        goto Exit;

    if (pQuery) 
    {
        memcpy(&qcInternal, pQuery, sizeof(QUERYCONTEXT));
    } 
    else 
    {
        memset(&qcInternal, 0, sizeof(QUERYCONTEXT));
    }

    memset(&qcRecommended, 0, sizeof(QUERYCONTEXT));
    
    //   Get the class spec.
    if(pClassSpec != NULL)
    {
        switch(pClassSpec->tyspec)
        {
        case TYSPEC_PROGID:

            // BUGBUG: we don't have JIT tables for progid to feature id
            // so this will only work for PEEK for installed versions
            if (FAILED((hr=CLSIDFromProgID(pClassSpec->tagged_union.pProgId, 
                    &inclsid))))
                goto Exit;

            hr = GetIEFeatureFromClass(&pwszIEFeature, inclsid, &qcInternal, &qcRecommended);
            if (hr != S_OK)
                goto Exit;

            break;

        case TYSPEC_CLSID:
            inclsid = pClassSpec->tagged_union.clsid;
            hr = GetIEFeatureFromClass(&pwszIEFeature, inclsid, &qcInternal, &qcRecommended);

            if (hr != S_OK)
                goto Exit;

            break;

        case TYSPEC_MIMETYPE:
            pwszMimeType = (LPCWSTR) pClassSpec->tagged_union.pMimeType;
            hr = GetIEFeatureFromMime(&pwszIEFeature, pwszMimeType, &qcInternal, &qcRecommended);

            if (hr != S_OK)
                goto Exit;

            break;

        case TYSPEC_FILENAME:

            // overload filename to be Active Setup feature ID
            hr = CDLDupWStr( &pwszIEFeature, pClassSpec->tagged_union.pFileName);
            if (hr != S_OK)
                goto Exit;

            break;

        default:
            hr = E_INVALIDARG;
            goto Exit;
        }
    } 
    else 
    {
        hr = E_INVALIDARG;
        goto Exit;
    }

    // We have a feature now
    ASSERT(pwszIEFeature);

    if (!pwszIEFeature) 
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    // copy over the recommended or the user-desired version, before it may be stomped by IsIEFeatureInstalled.
    memcpy(&qcRequested, &qcInternal, sizeof(QUERYCONTEXT));
    hr = IsIEFeatureInstalled(pwszIEFeature, &qcInternal, &pwszSetupPage, &pwszCompID, dwFlags, &bWebJit, &pszWebJitRegUrl, FALSE);
    
    if ((dwFlags & FIEF_FLAG_PEEK)  && pQuery) 
    {
        memcpy(pQuery, &qcInternal, sizeof(QUERYCONTEXT));
    }

    if (hr == HRESULT_FROM_WIN32(ERROR_CANCELLED)) 
    {
        if (!(dwFlags & FIEF_FLAG_FORCE_JITUI))
            goto Exit;
        else
            hr = S_FALSE;
    }
    
    if (bWebJit
        && (hr == S_FALSE)
        && (qcRecommended.dwVersionHi || qcRecommended.dwVersionLo)
        && ((qcRequested.dwVersionHi > qcRecommended.dwVersionHi)
            || ((qcRequested.dwVersionLo > qcRecommended.dwVersionLo)
                && (qcRequested.dwVersionHi == qcRecommended.dwVersionHi))))
    {
        //Don't WEBJIT if the requested version < recommeded version.
        hr = HRESULT_FROM_WIN32(ERROR_UNKNOWN_REVISION);
    }

    if (FAILED(hr) || (hr == S_OK && !(dwFlags & FIEF_FLAG_SKIP_INSTALLED_VERSION_CHECK)))
        goto Exit;
        
    if (SUCCEEDED(hr) && pwszSetupPage && !bWebJit) 
    {
        pwszMUISetupFile = PathFindFileNameW(pwszSetupPage);
        hr = SHGetWebFolderFilePathW(pwszMUISetupFile, pwszMUISetupPage, MAX_PATH);
    }

    hr = IsJITRestricted(bWebJit);

    if (hr == E_ACCESSDENIED 
        || ((hr == HRESULT_FROM_WIN32(ERROR_CANCELLED)) 
        && (!(dwFlags & FIEF_FLAG_FORCE_JITUI))
         )
       ) 
    {
        goto Exit;
    }

    if (!(dwFlags & FIEF_FLAG_FORCE_JITUI)) 
    {
        hr = HasFeatureAlreadyBeenRejected(pwszIEFeature);
        if (hr == S_FALSE) 
        {
            // already been rejected
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            goto Exit;
        }
    }

    // We have a setup page for the feature now
    // need to faultin feature
    if (dwFlags & FIEF_FLAG_PEEK) 
    {
        hr = HRESULT_FROM_WIN32(ERROR_PRODUCT_UNINSTALLED);

        goto Exit;
    }

    if (!pwszCompID) 
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    // faultin feature
    // now we need to acuire some code download cookies
    // trust and setup. This is to make sure that we don't
    // have a JIT and WVT dialog up at the same time
    // we aslo want to avoid having to do a JIT and a code download
    // restart machine dialog come up in the middle

    hrCDLCookies = AcquireCodeDownloadCookies();

    //if (FAILED(hrCDLCookies))
    {
        // Just try and make the new JIT dialog plaster on top of the 
        // WVT dialog, but make the WVT dialog disabled while JIT is up
        // this can be done by hopefully just parenting the JIT with the
        // trust dialog instead of the one passed in.

        HWND hWndParent = hWnd;
        HWND hWndTop = hWnd;

        while ( (hWndParent = GetParent(hWndParent)) != NULL) 
        {
            hWndTop = hWndParent;
        }

        hWnd = GetLastActivePopup(hWndTop);
    }

    //VENKATK
    DWORD dwRetVal;
    if (!bWebJit)
    {
        hr = GetDialogArgs(pwszCompID, dwFlags, vtDialogArg);

        if (FAILED(hr))
            goto Exit;
       
        //#81608: Do not show the "?" help icon if Help is not installed
        CLSIDFromString(HELP_CLSID, &HelpCLSID);
        memset(&qcHelp, 0, sizeof(QUERYCONTEXT));
        GetIEFeatureFromClass(&pwszHelpFeature, HelpCLSID, &qcHelp);
        if (pwszHelpFeature && *pwszHelpFeature)
        {
            if (IsIEFeatureInstalled(pwszHelpFeature, &qcHelp, &pwszHelpSetupPage, &pwszHelpCompID, 0, NULL, NULL, FALSE) == S_OK)
            {
                // Help Feature is installed. Turn on the "?" flag.
                bShowHelp = TRUE;
            }
        }

        hr =  CreateURLMoniker(NULL, pwszMUISetupPage, &pMk);

        if (FAILED(hr))
            goto Exit;

        hInst = LoadLibraryEx(TEXT("MSHTML.DLL"), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

        if (!hInst)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        pfnShowHTMLDialog = (SHOWHTMLDIALOGFN *)GetProcAddress(hInst, "ShowHTMLDialog");
        if (!pfnShowHTMLDialog) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        DEBUG_ENTER((DBG_DOWNLOAD,
                    Dword,
                    "EXTERNAL::ShowHTMLDialog",
                    "%#x, %#x, %.200wq",
                    hWnd, pMk, pwszMUISetupPage
                    ));

        if (bShowHelp)
            (*pfnShowHTMLDialog)(hWnd, pMk, &vtDialogArg, NULL, &vtRetVal);
        else
            (*pfnShowHTMLDialog)(hWnd, pMk, &vtDialogArg, L"help:no;", &vtRetVal);

        // below to release inseng.dll and asctrls.ocx the setup helper and
        // control used in the JIT setup page. This is to help people
        // running iesetup for the next build after they have had a JIT
        // to not require a reboot

        dwRetVal = (vtRetVal.vt == VT_I4) ? vtRetVal.lVal : 0;
        DEBUG_LEAVE(dwRetVal);

        CoFreeUnusedLibraries();
    }
    else
    {
        //WEBJIT
        WEBJIT_PARAM sWebJitParam;

        if (!IsWin32X86())
        {
            hr = HRESULT_FROM_WIN32(ERROR_INSTALL_PLATFORM_UNSUPPORTED);
            goto Exit;
        }
        
        //KV-should we do this?  Is a NULL handle value being used to indicate no UI? - Verify.
        if (!hWnd)
        {
            hWnd = GetActiveWindow();
        }

        //We do not want to jit Java VM
        if (IsEqualIID(inclsid, CLSID_AppletOCX))
        {
            if (ERROR_SUCCESS != SHRegGetUSValue( REGKEY_DECLINED_IOD, g_pszCLSID_AppletOCX, NULL, NULL, NULL, 0, NULL, 0))
            {
                //Pop up the dialog box if this has not been declined;
                DialogBox(g_hInst, MAKEINTRESOURCE(IDD_JAVAVMJITDIALOG), hWnd, (DLGPROC)JavaVMJitProc);
            }
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            goto Exit;
        }

        pszWebJitUrl = new CHAR[MAX_URL_STRING];

        if (!pszWebJitUrl)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        pQueryInstalled = new QUERYCONTEXT;

        if (pQueryInstalled
            && (SUCCEEDED(GetInstalledVersion(pwszIEFeature, pQueryInstalled))))
        {
            sWebJitParam.pQueryInstalled = pQueryInstalled;
        }
        else
        {
            sWebJitParam.pQueryInstalled = NULL;
        }
            
        URLSubstitution(pszWebJitRegUrl, pszWebJitUrl, MAX_URL_STRING, URLSUB_OLCID|URLSUB_CLCID);
        
        sWebJitParam.lpszResource = pszWebJitUrl;
        sWebJitParam.dwFlags = dwFlags;
        sWebJitParam.pwszComponentId = pwszCompID;
        sWebJitParam.hWndParent = hWnd;

        CWebJit* pWebJit = new CWebJit(&sWebJitParam);
        if (!pWebJit)
        {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
        if (!pWebJit->InitCommonControlsForWebJit())
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
        
        DEBUG_ENTER((DBG_DOWNLOAD,
                    Dword,
                    "EXTERNAL::DialogBoxParamA",
                    "%#x, %.200wq, %.200q, %.200q, %#x",
                    hWnd, pwszCompID, pszWebJitRegUrl, pszWebJitUrl, dwFlags
                    ));

        SHActivateContext(&uCookie);

        sWebJitParam.pWebJit = pWebJit;
        DialogBoxParamA(MLGetHinst(), MAKEINTRESOURCE(IDD_WEBJIT), hWnd, WebJitProc, (LPARAM)&sWebJitParam);
        dwRetVal = pWebJit->GetResult();

        if (uCookie)
        {
            SHDeactivateContext(uCookie);
        }

        DEBUG_LEAVE(dwRetVal);

        //Need to set hr to SUCCESS if install succeeded.
        if (dwRetVal == S_OK)
        {
            QUERYCONTEXT qcInternal2;
            memcpy(&qcInternal2, &qcRequested, sizeof(QUERYCONTEXT));
            
            hr = IsIEFeatureInstalled(pwszIEFeature, &qcInternal2, NULL, NULL, 0, NULL, NULL, TRUE);
            //hr now has either S_OK or S_FALSE from IsIEFeatureInstalled
        }
        
        pWebJit->Release();
    }
    
    if (dwRetVal == JITPAGE_RETVAL_CANCELLED) 
    {
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
    } 
    else if (dwRetVal == JITPAGE_RETVAL_NEED_REBOOT) 
    {
        hr = HRESULT_FROM_WIN32(ERROR_SUCCESS_REBOOT_REQUIRED);
    } 
    else if (dwRetVal == JITPAGE_RETVAL_DONTASK_THISWINDOW) 
    {
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        tls->pRejectedFeaturesList->AddHead(pwszIEFeature);
        pwszIEFeature = NULL;
    } 
    else if (dwRetVal == JITPAGE_RETVAL_DONTASK_EVER) 
    {
        SetJITDeclined(pwszIEFeature);
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
    } 
    else if (FAILED(dwRetVal)) 
    {
        hr = (HRESULT)dwRetVal;
    }

Exit:

    if (SUCCEEDED(hrCDLCookies)) 
    {
        HRESULT hr1 = RelinquishCodeDownloadCookies();

        if (FAILED(hr1) && SUCCEEDED(hr))
            hr = hr1;
    }

    SAFERELEASE(pMk);
    SAFEDELETE(pwszIEFeature);
    SAFEDELETE(pwszSetupPage);
    SAFEDELETE(pwszCompID);
    VariantClear(&vtDialogArg);

    SAFEDELETE(pwszHelpFeature);
    SAFEDELETE(pwszHelpSetupPage);
    SAFEDELETE(pwszHelpCompID);

    SAFEDELETE(pszWebJitRegUrl);
    SAFEDELETE(pszWebJitUrl);
    SAFEDELETE(pQueryInstalled);
    if (hInst)
        FreeLibrary(hInst);

    DEBUG_LEAVE_API(hr);
    return hr;
}

//This won't work for WebJit but nobody seems to call this anywhere in the codebase.
STDAPI_(BOOL) IsJITInProgress()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Bool,
                "IsJITInProgress",
                NULL
                ));
                    
    HWND             hwnd;

    hwnd = FindWindow(JIT_DIALOG_CLASS_NAME, JIT_DIALOG_CAPTION);

    DEBUG_LEAVE(hwnd != NULL);
    return (hwnd != NULL);  // not a typo (FindWindow returns NULL for unfound)
}

//This is an abbreviated part of the code in shdocvw.
#define MAX_SUBSTR_SIZE     100
typedef struct tagURLSub
{
    LPCTSTR szTag;
    DWORD dwType;
} 
URLSUB;

const static URLSUB c_UrlSub[] = 
{
    {TEXT("{SUB_OLCID}"),   URLSUB_OLCID},
    {TEXT("{SUB_CLCID}"),   URLSUB_CLCID},
};

VOID URLSubstitution(LPCSTR pszUrlIn, LPSTR pszUrlOut, DWORD cchSize, DWORD dwSubstitutions)
{
    DWORD dwIndex;
    CHAR szTempUrl[MAX_URL_STRING];
    ASSERT(cchSize <= ARRAYSIZE(szTempUrl));    // We will truncate anything longer than MAX_URL_STRING

    StrCpyN(szTempUrl, pszUrlIn, ARRAYSIZE(szTempUrl));

    for (dwIndex = 0; dwIndex < ARRAYSIZE(c_UrlSub); dwIndex++)
    {
        while (dwSubstitutions & c_UrlSub[dwIndex].dwType)
        {
            LPSTR pszTag = StrStr(szTempUrl, c_UrlSub[dwIndex].szTag);

            if (pszTag)
            {
                CHAR szCopyUrl[MAX_URL_STRING];
                CHAR szSubStr[MAX_SUBSTR_SIZE];  // The Substitution

                // Copy URL Before Substitution.
                StrCpyN(szCopyUrl, szTempUrl, (int)(pszTag-szTempUrl+1));
                pszTag += lstrlen(c_UrlSub[dwIndex].szTag);

                switch (c_UrlSub[dwIndex].dwType)
                {
                case URLSUB_OLCID:
                    wnsprintf(szSubStr, ARRAYSIZE(szSubStr), _T("%#04lx"), GetSystemDefaultLCID());
                    break;

                case URLSUB_CLCID:
                    wnsprintf(szSubStr, ARRAYSIZE(szSubStr), _T("%#04lx"), GetUserDefaultLCID());
                    break;
                }
                // Add the Substitution String to the end (will become the middle)
                StrCatBuff(szCopyUrl, szSubStr, ARRAYSIZE(szCopyUrl));
                // Add the rest of the URL after the substitution substring.
                StrCatBuff(szCopyUrl, pszTag, ARRAYSIZE(szCopyUrl));
                StrCpyN(szTempUrl, szCopyUrl, ARRAYSIZE(szTempUrl));
            }
            else
                break;  // This will allow us to replace all the occurances of this string.
        }
    }
    StrCpyN(pszUrlOut, szTempUrl, cchSize);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\jsetup.cxx ===
// ===========================================================================
// File: JSETUP.CXX
//    implements CJavaSetup
//


#include <cdlpch.h>
#include <pkgguid.h>

// ---------------------------------------------------------------------------
// %%Function: CJavaSetup::CJavaSetup
// ---------------------------------------------------------------------------
CJavaSetup::CJavaSetup(
    CDownload *pdl,
    LPCWSTR szPackageName,
    LPCWSTR szNameSpace,
    IXMLElement *pPackage,
    DWORD dwVersionMS,
    DWORD dwVersionLS,
    DWORD flags,
    HRESULT *phr)
    :
    m_pdl(pdl),
    m_dwVersionMS(dwVersionMS),
    m_dwVersionLS(dwVersionLS),
    m_flags(flags),
    m_state(INSTALL_INIT)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CJavaSetup::CJavaSetup",
                "this=%#x, %#x, %.80wq, %.80wq, %#x, %#x, %#x, %#x, %#x",
                this, pdl, szPackageName, szNameSpace, pPackage, dwVersionMS, dwVersionLS, flags, phr
                ));
                
    *phr = S_OK;

    if (szPackageName) {

        DWORD len = lstrlenW(szPackageName) +1;

        m_szPackageName = new WCHAR [len]; // make private copy

        if (m_szPackageName)
            StrCpyW(m_szPackageName, szPackageName);
        else
            *phr = E_OUTOFMEMORY;

    } else {
        m_szPackageName = NULL;
    }

    if (szNameSpace) {

        DWORD len = lstrlenW(szNameSpace) +1;

        m_szNameSpace = new WCHAR [len]; // make private copy

        if (m_szNameSpace)
            StrCpyW(m_szNameSpace, szNameSpace);
        else
            *phr = E_OUTOFMEMORY;

    } else {
        m_szNameSpace = NULL;
    }

    m_pPackage = pPackage;
    if (pPackage) {
        pPackage->AddRef(); 
    }

    DEBUG_LEAVE(0);
}  // CJavaSetup

// ---------------------------------------------------------------------------
// %%Function: CJavaSetup::~CJavaSetup
// ---------------------------------------------------------------------------
CJavaSetup::~CJavaSetup()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CJavaSetup::~CJavaSetup",
                "this=%#x",
                this
                ));
                
    SAFEDELETE(m_szPackageName);
    SAFEDELETE(m_szNameSpace);
    SAFERELEASE(m_pPackage);

    DEBUG_LEAVE(0);
}  // ~CJavaSetup

// ---------------------------------------------------------------------------
// %%Function: CJavaSetup::DoSetup
// ---------------------------------------------------------------------------
HRESULT
CJavaSetup::DoSetup()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CJavaSetup::DoSetup",
                "this=%#x",
                this
                ));
                
    Assert(m_pdl);
    CCodeDownload *pcdl = m_pdl->GetCodeDownload();
    Assert(pcdl);
    HWND hWnd = pcdl->GetClientBinding()->GetHWND();
    HRESULT hr = S_OK;
    CList<CJavaSetup*,CJavaSetup*> *pjsList = m_pdl->GetJavaSetupList();
    PACKAGEINSTALLINFO *PackageInfo = NULL;
    LPCWSTR pwszNameSpace = NULL;
    int i;

    if (SUCCEEDED(hr)) {

        // call the pkg mgr to install the package.

        int nCntjs = pjsList->GetCount(), njs = 0;
        POSITION pos = pjsList->GetHeadPosition();
        BOOL bInstallReqd = FALSE;

        // find the first setup that needs to be installed and then record 
        // its namespace. We will then instal all packages in the CDownload
        // that macth that namespace and then return. On each call we will
        // install all pkgs in a namespace till all setups are done.
        for (i=0; i<nCntjs; i++) {

            CJavaSetup *pjs = pjsList->GetNext(pos);
            Assert(pjs != NULL);

            if (pjs->GetState() != INSTALL_DONE) {
                pwszNameSpace = pjs->GetNameSpace();
                bInstallReqd = TRUE;
                break;
            }
        }

        if (!bInstallReqd)
        {
            DEBUG_LEAVE(hr);
            return hr;
        }

        PackageInfo = new PACKAGEINSTALLINFO[nCntjs];
        if (PackageInfo == NULL) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        PACKAGESECURITYINFO PkgSecInfo;
        ZeroMemory(PackageInfo,sizeof(PACKAGEINSTALLINFO)*nCntjs);
        ZeroMemory(&PkgSecInfo,sizeof(PkgSecInfo));

        pos = pjsList->GetHeadPosition();
        for (i=0; i<nCntjs; i++) {

            CJavaSetup *pjs = pjsList->GetNext(pos);
            Assert(pjs != NULL);

            // when installing multiple packages, if some are installed they should be skipped.
            if (pjs->GetPackageFlags() & CJS_FLAG_NOSETUP) {
                pjs->SetState(INSTALL_DONE);
                continue;
            }

            if  ((pjs->GetState() != INSTALL_DONE) &&
                 ((pjs->GetNameSpace() == pwszNameSpace) || 
                  ( pwszNameSpace && pjs->GetNameSpace() && 
                    (StrCmpIW(pjs->GetNameSpace(), pwszNameSpace) == 0)))) {

                pcdl->CodeDownloadDebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_JAVA_PKG_SETUP, pjs->GetPackageName(), (pwszNameSpace)?pwszNameSpace:L"Global");

                PACKAGEINSTALLINFO *CurPackageInfo = &PackageInfo[njs];

                CurPackageInfo->cbStruct = sizeof(PACKAGEINSTALLINFO);
                CurPackageInfo->pszPackageName = pjs->GetPackageName();
                pjs->GetPackageVersion(CurPackageInfo->dwVersionMS, CurPackageInfo->dwVersionLS);
    
                CurPackageInfo->pszDistributionUnit = pcdl->GetMainDistUnit();   // Should be same dist unit

                CurPackageInfo->pUnknown = (IUnknown *)(pjs->GetPackageXMLElement());

                if (pjs->GetPackageFlags() & CJS_FLAG_SYSTEM) {
                    CurPackageInfo->dwFlags |= JPMPII_SYSTEMCLASS;          // Already true by zeroing
                } else {
                    CurPackageInfo->dwFlags |= JPMPII_NONSYSTEMCLASS;
                }

                if (pjs->GetPackageFlags() & CJS_FLAG_NEEDSTRUSTEDSOURCE) {
                    CurPackageInfo->dwFlags |= JPMPII_NEEDSTRUSTEDSOURCE;
                }

                njs++;
                pjs->SetState(INSTALL_DONE);
            }
        }

        Assert(pos == NULL);                // Should be exact count.

        // if nothing actually needs to be installed, skip calling InstallPackage
        if (njs == 0)
            goto Exit;

        PkgSecInfo.cbStruct = sizeof(PkgSecInfo);
        PJAVA_TRUST pjt = m_pdl->GetJavaTrust();
        if (pjt) {
            PkgSecInfo.pCapabilities = pjt->pbJavaPermissions;
            PkgSecInfo.cbCapabilities = pjt->cbJavaPermissions;
            PkgSecInfo.pSigner = pjt->pbSigner;
            PkgSecInfo.cbSigner = pjt->cbSigner;
            PkgSecInfo.fAllPermissions = pjt->fAllPermissions;
        }

        WCHAR szCabName[MAX_PATH];

        if (!MultiByteToWideChar(CP_ACP, 0, m_pdl->GetFileName(), -1, szCabName, MAX_PATH)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }

        hr = pcdl->GetPackageManager()->InstallPackage(szCabName, pwszNameSpace,
                JPMINST_CAB,&PackageInfo[0],njs,0, &PkgSecInfo);
            
    }


Exit:
    SAFEDELETE(PackageInfo);

    if (FAILED(hr)) {
        pcdl->CodeDownloadDebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_JAVA_PKG_FAILED, hr);
    }

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\packet.cxx ===
// ===========================================================================
// File: PACKET.CXX
//
// Packet Manager for Code Downloader
// A Packet is a unit of work that takes time eg. trust verifcation of a piece
// setup of a piece or INF processing of one piece. To be able to have the
// client be responsive with UI and abort capabilty we need to split out work 
// into as small units as possible and queue up these CDLPackets
// CDLPackets get run on a timer per thread.


#include <cdlpch.h>


//+---------------------------------------------------------------------------
//
//  Function:   CDL_PacketProcessProc
//
//  Synopsis:   the timer proc to process packet
//
//  Arguments:  [hWnd] --
//              [WPARAM] --
//              [idEvent] --
//              [dwTime] --
//
//  Returns:
//----------------------------------------------------------------------------
VOID CALLBACK CDL_PacketProcessProc(HWND hWnd, UINT msg, UINT_PTR idEvent, DWORD dwTime)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CDL_PacketProcessProc",
                "%#x, #x, %#x, %#x",
                hWnd, msg, idEvent, dwTime
                ));
                
    HRESULT hr = NO_ERROR;
    CUrlMkTls tls(hr); // hr passed by reference!

    Assert(SUCCEEDED(hr));
    Assert(msg == WM_TIMER);
    Assert(idEvent);

    if (SUCCEEDED(hr)) {     // if tls ctor passed above

        Assert(tls->pCDLPacketMgr);

        // give the packet mgr a time slice
        // so a packet can be processed.

        if (tls->pCDLPacketMgr)
            hr = tls->pCDLPacketMgr->TimeSlice();

        Assert(SUCCEEDED(hr));
    }

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Function:   CCDLPacketMgr::CCDLPacketMgr
//----------------------------------------------------------------------------
CCDLPacketMgr::CCDLPacketMgr()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CCDLPacketMgr::CCDLPacketMgr",
                "this=%#x",
                this
                ));
                
    m_Timer = 0;

    m_PacketList.RemoveAll();

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Function:   CCDLPacketMgr::~CCDLPacketMgr
//----------------------------------------------------------------------------
CCDLPacketMgr::~CCDLPacketMgr()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CCDLPacketMgr::~CCDLPacketMgr",
                "this=%#x",
                this
                ));
                
    if (m_Timer) {
        KillTimer(NULL, m_Timer);
    }

    m_PacketList.RemoveAll();

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Function:   CCDLPacketMgr::AbortPackets(CDownload *pdl)
//
//  Aborts all packets on the thread that are to do with pdl or
//  its parent codedownload (pdl->GetCodeDownload())
//----------------------------------------------------------------------------
HRESULT 
CCDLPacketMgr::AbortPackets(CDownload *pdl)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCDLPacketMgr::AbortPackets",
                "this=%#x, %#x",
                this, pdl
                ));

    HRESULT hr = S_FALSE; //assume none found to be killed
    int iNumPkts;
    LISTPOSITION pos;

    if (!pdl) {

        DEBUG_LEAVE(E_INVALIDARG);
        return  E_INVALIDARG;
    }


    iNumPkts = m_PacketList.GetCount();
    pos = m_PacketList.GetHeadPosition();

    for (int i=0; i < iNumPkts; i++) {

        CCDLPacket *pPkt = m_PacketList.GetNext(pos); // pass ref!

        if ( (pdl == pPkt->GetDownload()) ||
             (pdl->GetCodeDownload() == pPkt->GetCodeDownload()) ) {

            // AbortPackekts is only called from DoSetup. There should
            // normally be no packets left to kill.
            // Assert that this is a NOP.

            UrlMkDebugOut((DEB_CODEDL, "CODE DL:AbortPackets URL:(%ws)\n", pdl->GetURL()));

            Assert(pPkt == NULL);

            Kill(pPkt);

            hr = S_OK;  // indicate killed atleast one

        }
    }

    // here is no more packets in this thread that match CDownload* pdl

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CCDLPacketMgr::Kill(CCDLPacket *pPkt)
//
//  kills packet (removes it from the thread list and deletes it
//----------------------------------------------------------------------------
HRESULT 
CCDLPacketMgr::Kill(CCDLPacket *pPkt)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCDLPacketMgr::Kill",
                "this=%#x, %#x",
                this, pPkt
                ));

    LISTPOSITION pos = m_PacketList.Find(pPkt);

    if(pos != NULL)
        m_PacketList.RemoveAt(pos);

    delete pPkt;

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   CCDLPacketMgr::Post(CCDLPacket *pPkt, ULONG pri)
//
//  Adds the packet to the list. The packet will get processed
//  on a subsequent timer in the order it appears on the list
//  Also kicks off a timer if none exists already
//----------------------------------------------------------------------------
HRESULT
CCDLPacketMgr::Post(CCDLPacket *pPkt, ULONG pri)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCDLPacketMgr::Post",
                "this=%#x, %#x, %#x",
                this, pPkt, pri
                ));
                
    HRESULT hr = S_OK;
    UINT_PTR idEvent = (UINT_PTR) this;

    if (!m_Timer) {
        m_Timer = SetTimer(NULL, idEvent,
                        PROCESS_PACKET_INTERVAL, CDL_PacketProcessProc);

        if (!m_Timer) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }
    }

    //BUGBUG: if we want priority classes then we soudl really have
    // multiple lists! This will also affect the order if
    // any sequencing is involved
    if (pri == PACKET_PRIORITY_HIGH) {
        
        m_PacketList.AddHead(pPkt);

    } else {
        
        m_PacketList.AddTail(pPkt);

    }


Exit:

    DEBUG_LEAVE(hr);
    return hr;

}

//+---------------------------------------------------------------------------
//
//  Function:   CCDLPacketMgr::TimeSlice()
//
//  called from the timer proc.
//  This is like a simple light weight thread machinery that executes/processes
//  one packet per timer msg.
//  Kills the timer if there are no other code downloads on thread.
//----------------------------------------------------------------------------
HRESULT 
CCDLPacketMgr::TimeSlice()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCDLPacketMgr::TimeSlice",
                "this=%#x",
                this
                ));
                
    HRESULT hr = S_OK;

    int iNumPkts = m_PacketList.GetCount();

    if (!iNumPkts) {

        // nothing to do. This may happen when processing the previous 
        // packet yields and so we re-enter the timer proc without
        // ever completing the first.

        DEBUG_LEAVE(hr);
        return hr;
    }

    // have work to do!

    CCDLPacket* pPkt = m_PacketList.RemoveHead();

    Assert(pPkt);

    hr = pPkt->Process();

    // need to refresh this value as the procesing of current pkt
    // may have posted other packets!

    iNumPkts = m_PacketList.GetCount();

    if (!iNumPkts && 
        (CCodeDownload::AnyCodeDownloadsInThread() == S_FALSE)) {

        if (m_Timer) {

            KillTimer(NULL, m_Timer);
            m_Timer = 0;
        }
    }

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CCDLPacket::CCDLPacket(DWORD type, CDownload *pdl, DWORD param)
//
//  twin constructors that take either CDownload or CCodeDownload obj
//----------------------------------------------------------------------------
CCDLPacket::CCDLPacket(DWORD type, CDownload *pdl, DWORD_PTR param)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CCDLPacket::CCDLPacket",
                "this=%#x, %#x, %#x, %#x",
                this, type, pdl, param
                ));
                
    m_signature = CPP_SIGNATURE;

    m_type = type;

    m_param = param;

    Assert ((GETMSGTYPE(m_type) == MSG_CDOWNLOAD_OBJ));
    Assert(pdl);

    m_obj.pdl = pdl;

    DEBUG_LEAVE(0);
};

//+---------------------------------------------------------------------------
//
//  Function:CCDLPacket::CCDLPacket(DWORD type, CCodeDownload *pcdl,DWORD param)
//----------------------------------------------------------------------------
CCDLPacket::CCDLPacket(DWORD type, CCodeDownload *pcdl, DWORD_PTR param)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CCDLPacket::CCDLPacket",
                "this=%#x, %#x, %#x, %#x",
                this, type, pcdl, param
                ));
                
    m_signature = CPP_SIGNATURE;

    m_type = type;

    m_param = param;

    Assert ((GETMSGTYPE(m_type) == MSG_CCODEDOWNLOAD_OBJ));
    Assert(pcdl);

    m_obj.pcdl = pcdl;

    DEBUG_LEAVE(0);
};

//+---------------------------------------------------------------------------
//
//  Function:   CCDLPacket::~CCDLPacket()
//----------------------------------------------------------------------------
CCDLPacket::~CCDLPacket()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CCDLPacket::~CCDLPacket",
                "this=%#x",
                this
                ));
                
    m_signature = 0;

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Function:   CCDLPacket::Post(ULONG pri)
//
//  just punts the posting work to the packet mgr.
//----------------------------------------------------------------------------
HRESULT
CCDLPacket::Post(ULONG pri)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCDLPacket::Post",
                "this=%#x, %#x",
                this, pri
                ));
                
    HRESULT hr = S_OK;
    CUrlMkTls tls(hr); // hr passed by reference!

    if (FAILED(hr)) {     // if tls ctor failed above
        goto Exit;
    }

    Assert(m_obj.pcdl);

    Assert(tls->pCDLPacketMgr);

    if (tls->pCDLPacketMgr)
        hr = tls->pCDLPacketMgr->Post(this, pri);

Exit:

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CCDLPacket::Process()
//
//  Called from the packet manager's TimeSlice to process packet.
//----------------------------------------------------------------------------
HRESULT
CCDLPacket::Process()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCDLPacket::Process",
                "this=%#x",
                this
                ));
                
    HRESULT hr = S_OK;

    // Code Download messages, arrive in this order
    // First a binding completes and needs to be trusted
    // Next the trusted piece gets processed in ProcessPiece
    // Next if the piece arrived was a CAB and had an INF in it
    // the INF gets processed piece by piece
    // initiating new downloads if necessary or extracting out of
    // already arrived CAB
    // After all pieces are processed and all bindings completed
    // we enter the setup phase, setting up one piece per message.
    // The reason we break it up into some many messages is to make the
    // browser be as responsive during code download and installation as
    // possible and keep the clouds animation smooth.


    Assert(m_signature == CPP_SIGNATURE);

    switch(m_type) {

    case CODE_DOWNLOAD_TRUST_PIECE:
        {
            CDownload *pdl =  m_obj.pdl;

            if (pdl)
                pdl->VerifyTrust();
        }
        break;

    case CODE_DOWNLOAD_PROCESS_PIECE:
        {
            CDownload *pdl =  m_obj.pdl;

            if (pdl)
                pdl->ProcessPiece();
        }
        break;

    case CODE_DOWNLOAD_PROCESS_INF:
        {
            CCodeDownload *pcdl =  m_obj.pcdl;

            if (pcdl)
                pcdl->ProcessInf( (CDownload *) m_param);
        }
        break;

    case CODE_DOWNLOAD_SETUP:
        {
            CCodeDownload *pcdl =  m_obj.pcdl;

            if (pcdl)
                pcdl->DoSetup();
        }
        break;

    case CODE_DOWNLOAD_WAIT_FOR_EXE:
        {
            CCodeDownload *pcdl =  m_obj.pcdl;

            if (pcdl) {
                hr = pcdl->SelfRegEXETimeout();
                Assert(SUCCEEDED(hr));
            }
        }
        break;
    }

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   CCDLPacket::Kill()
//----------------------------------------------------------------------------
HRESULT
CCDLPacket::Kill()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CCDLPacket::Kill",
                "this=%#x",
                this
                ));
                
    HRESULT hr = S_OK;
    CUrlMkTls tls(hr); // hr passed by reference!

    if (FAILED(hr)) {     // if tls ctor failed above
        goto Exit;
    }

    Assert(tls->pCDLPacketMgr);

    if (tls->pCDLPacketMgr)
        hr = tls->pCDLPacketMgr->Kill(this);
Exit:

    DEBUG_LEAVE(S_OK);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\logo3bsc.cxx ===
#include <cdlpch.h>
#include <winineti.h>
#include <shellapi.h>

// Globals

#ifdef LOGO3_SUPPORT_AUTOINSTALL
CList<Logo3CodeDLBSC *, Logo3CodeDLBSC *>     g_CDLList;
CMutexSem                                     g_mxsCDL;
UINT                                          g_Timer;
#endif

Logo3CodeDLBSC::Logo3CodeDLBSC(CSoftDist *pSoftDist,
                               IBindStatusCallback *pClientBSC,
                               LPSTR szCodeBase, LPWSTR wzDistUnit)
: _cRef(1)
, _pIBinding(NULL)
, _pClientBSC(pClientBSC)
, _bPrecacheOnly(FALSE)
, _pbc(NULL)
, _pSoftDist(pSoftDist)
#ifdef LOGO3_SUPPORT_AUTOINSTALL
, _uiTimer(0)
, _hProc(INVALID_HANDLE_VALUE)
#endif
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "Logo3CodeDLBSC::Logo3CodeDLBSC",
                "this=%#x, %#x, %#x, %.80q, %.80wq",
                this, pSoftDist, pClientBSC, szCodeBase, wzDistUnit
                ));
                
    DWORD                 len = 0;

    _szCodeBase = new char[lstrlen(szCodeBase) + 1];
    if (_szCodeBase)
    {
        lstrcpy(_szCodeBase, szCodeBase);
    }

    if (_pClientBSC)
    {
        _pClientBSC->AddRef();
    }

    if (_pSoftDist)
    {
        _pSoftDist->AddRef();
    }
    
    len = WideCharToMultiByte(CP_ACP,0, wzDistUnit, -1, NULL, 0, NULL, NULL);
    _szDistUnit = new TCHAR[len];
    if (_szDistUnit)
    {
        WideCharToMultiByte(CP_ACP, 0, wzDistUnit , -1, _szDistUnit,
                            len, NULL, NULL);
    }

    DEBUG_LEAVE(0);
}

Logo3CodeDLBSC::~Logo3CodeDLBSC()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "Logo3CodeDLBSC::~Logo3CodeDLBSC",
                "this=%#x",
                this
                ));

    if (_pClientBSC)
    {
        _pClientBSC->Release();
    }
    
    if (_pbc)
    {
        _pbc->Release();
    }

    if (_pSoftDist)
    {
        _pSoftDist->Release();
    }

    delete [] _szCodeBase;
    delete [] _szDistUnit;

    DEBUG_LEAVE(0);
}

/*
 *
 * IUnknown Methods
 *
 */

STDMETHODIMP Logo3CodeDLBSC::QueryInterface(REFIID riid, void **ppv)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "Logo3CodeDLBSC::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppv
                ));
                
    HRESULT          hr = E_NOINTERFACE;

    *ppv = NULL;
    if (riid == IID_IUnknown || riid == IID_IBindStatusCallback)
    {
        *ppv = (IBindStatusCallback *)this;
    }
    if (*ppv != NULL)
    {
        ((IUnknown *)*ppv)->AddRef();
        hr = S_OK;
    }

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP_(ULONG) Logo3CodeDLBSC::AddRef()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Dword,
                "Logo3CodeDLBSC::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    ULONG ulRet = ++_cRef;

    DEBUG_LEAVE(ulRet);
    return ulRet;
}

STDMETHODIMP_(ULONG) Logo3CodeDLBSC::Release()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Dword,
                "Logo3CodeDLBSC::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    if (--_cRef)
    {
        DEBUG_LEAVE(_cRef);
        return _cRef;
    }
    delete this;

    DEBUG_LEAVE(0);
    return 0;
}

/*
 *
 * IBindStatusCallback Methods
 *
 */

STDMETHODIMP Logo3CodeDLBSC::OnStartBinding(DWORD grfBSCOption, IBinding *pib)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "Logo3CodeDLBSC::IBindStatusCallback::OnStartBinding",
                "this=%#x, %#x, %#x",
                this, grfBSCOption, pib
                ));
                
    HRESULT                  hr = S_OK;

    if (_pIBinding != NULL)
    {
        _pIBinding->Release();
    }
    _pIBinding = pib;

    if (_pIBinding != NULL)
    {
        _pIBinding->AddRef();
    }

    if (_pClientBSC != NULL)
    {
        hr =  _pClientBSC->OnStartBinding(grfBSCOption, pib);
    }

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP Logo3CodeDLBSC::OnStopBinding(HRESULT hr, LPCWSTR szError)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "Logo3CodeDLBSC::IBindStatusCallback::OnStopBinding",
                "this=%#x, %#x, %.80wq",
                this, hr, szError
                ));
                
#ifdef LOGO3_SUPPORT_AUTOINSTALL
    CLock                             lck(g_mxsCDL); // Mutex this method
#endif
    DWORD                             dwSize = 0;
    LPINTERNET_CACHE_ENTRY_INFO       lpCacheEntryInfo = NULL;
    SHELLEXECUTEINFO                  sei;
    TCHAR                             achShortName[MAX_PATH];
    HANDLE                            hFile = INVALID_HANDLE_VALUE;
    LPWSTR                            pwzUrl = NULL;

#ifdef LOGO3_SUPPORT_AUTOINSTALL
    // These vars are used for trust verification.
    // AS TODO: Get these values from QI'ing and QS'ing from the
    // client BindStatusCallback. For now, just use NULL values.

    IInternetHostSecurityManager     *pHostSecurityManager = NULL;
    HWND                              hWnd = (HWND)INVALID_HANDLE_VALUE;
    PJAVA_TRUST                       pJavaTrust = NULL;
#endif

    AddRef();  // RevokeBindStatusCallback() will destroy us too soon.

    if (_pIBinding != NULL)
    {
        _pIBinding->Release();
        _pIBinding = NULL;
    }
    
#ifdef LOGO3_SUPPORT_AUTOINSTALL
    lpCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)achBuffer;
    dwSize = MAX_CACHE_ENTRY_INFO_SIZE;
    GetUrlCacheEntryInfo(_szCodeBase, lpCacheEntryInfo, &dwSize);
    GetShortPathName(lpCacheEntryInfo->lpszLocalFileName, achShortName,
                     MAX_PATH);
    // Do trust verification

    if (!_bPrecacheOnly)
    {
        if ( (hFile = CreateFile(achShortName, GENERIC_READ, FILE_SHARE_READ,
                                 NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0))
                                 == INVALID_HANDLE_VALUE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto Exit;
        }                             
                                 
        Ansi2Unicode(_szCodeBase, &pwzUrl);
        hr = _wvt.VerifyTrust(hFile, hWnd, &pJavaTrust, pwzUrl,
                              pHostSecurityManager);
                              
        SAFEDELETE(pJavaTrust);  
        SAFEDELETE(pwzUrl);
        CloseHandle(hFile);
    }
#endif


#ifdef LOGO3_SUPPORT_AUTOINSTALL
    if (_bPrecacheOnly)
    {
#endif

     
    if (SUCCEEDED(hr))
    {
        // Mark all downloads of the same group to be downloaded
        hr = _pSoftDist->Logo3DownloadNext();
    }
    else
    {
        // Get last download's group and search for another one to download
        hr = _pSoftDist->Logo3DownloadRedundant();
    }

    if ((FAILED(hr) && hr != E_PENDING) || hr == S_FALSE)
    {
        _pClientBSC->OnStopBinding(hr, szError);
        RecordPrecacheValue(hr);
    }

#ifdef LOGO3_SUPPORT_AUTOINSTALL
    }
    else
    {
        sei.fMask = SEE_MASK_NOCLOSEPROCESS | SEE_MASK_FLAG_NO_UI;
        sei.hwnd = NULL;
        sei.lpVerb = NULL; // "Open" is the default verb
        sei.lpFile = achShortName;
        sei.lpParameters = NULL;
        sei.lpDirectory = NULL;
        sei.nShow = SW_SHOWDEFAULT;
        sei.lpIDList = NULL;
        sei.lpClass = NULL;
        sei.hkeyClass = 0;
        sei.dwHotKey = 0;
        sei.hIcon = INVALID_HANDLE_VALUE;
        sei.cbSize = sizeof(sei);
    
        if (!ShellExecuteEx(&sei)) {
            goto Exit;
        }
    
        _hProc = sei.hProcess;
        if (!g_Timer) {
            g_Timer = SetTimer(NULL, (UINT)this, TIMEOUT_INTERVAL, TimeOutProc);
        }
        g_CDLList.AddTail(this);
        AddRef();
    }
#endif

    Assert(_pbc);
    RevokeBindStatusCallback(_pbc, this);
    
    _pbc->Release();
    _pbc = NULL;

    Release();

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP Logo3CodeDLBSC::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "Logo3CodeDLBSC::IBindStatusCallback::OnObjectAvailable",
                "this=%#x, %#x, %#x",
                this, &riid, punk
                ));
                
    HRESULT                  hr = S_OK;

    if (_pClientBSC)
    {
        hr = _pClientBSC->OnObjectAvailable(riid, punk);
    }

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP Logo3CodeDLBSC::GetPriority(LONG *pnPriority)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "Logo3CodeDLBSC::IBindStatusCallback::GetPriority",
                "this=%#x, %#x",
                this, pnPriority
                ));
                
    HRESULT                  hr = S_OK;

    if (_pClientBSC)
    {
        hr = _pClientBSC->GetPriority(pnPriority);
    }

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP Logo3CodeDLBSC::OnLowResource(DWORD dwReserved)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "Logo3CodeDLBSC::IBindStatusCallback::OnLowResource",
                "this=%#x, %#x",
                this, dwReserved
                ));
                
    HRESULT                  hr = S_OK;

    if (_pClientBSC)
    {
        hr = _pClientBSC->OnLowResource(dwReserved);
    }

    DEBUG_LEAVE(hr);
    return hr;
}  

STDMETHODIMP Logo3CodeDLBSC::OnProgress(ULONG ulProgress, ULONG ulProgressMax,
                                    ULONG ulStatusCode,
                                    LPCWSTR szStatusText)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "Logo3CodeDLBSC::IBindStatusCallback::OnProgress",
                "this=%#x, %#x, %#x, %#x, %.80wq",
                this, ulProgress, ulProgressMax, ulStatusCode, szStatusText
                ));
                
    HRESULT                  hr = S_OK;

    if (_pClientBSC)
    {
        hr = _pClientBSC->OnProgress(ulProgress, ulProgressMax,
                                     ulStatusCode, szStatusText);
    }

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP Logo3CodeDLBSC::GetBindInfo(DWORD *pgrfBINDF, BINDINFO *pbindInfo)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "Logo3CodeDLBSC::IBindStatusCallback::GetBindInfo",
                "this=%#x, %#x, %#x",
                this, pgrfBINDF, pbindInfo
                ));
                
    HRESULT                  hr = S_OK;

    *pgrfBINDF |= BINDF_ASYNCHRONOUS;
    if (_pClientBSC)
    {
        hr = _pClientBSC->GetBindInfo(pgrfBINDF, pbindInfo);
        if (*pgrfBINDF & BINDF_SILENTOPERATION)
        {
            _bPrecacheOnly = TRUE;
        }
    }

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

STDMETHODIMP Logo3CodeDLBSC::OnDataAvailable(DWORD grfBSCF, DWORD dwSize,
                                         FORMATETC *pformatetc,
                                         STGMEDIUM *pstgmed)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "Logo3CodeDLBSC::IBindStatusCallback::OnDataAvailable",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, grfBSCF, dwSize, pformatetc, pstgmed
                ));
                
    HRESULT                  hr = S_OK;

    if (_pClientBSC)
    {
        hr = _pClientBSC->OnDataAvailable(grfBSCF, dwSize, pformatetc,
                                          pstgmed);
    }

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

void Logo3CodeDLBSC::SetBindCtx(IBindCtx *pbc)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "Logo3CodeDLBSC::SetBindCtx",
                "this=%#x, %#x",
                this, pbc
                ));
                
    _pbc = pbc;

    if (_pbc)
    {
        _pbc->AddRef();
    }

    DEBUG_LEAVE(0);
}

STDMETHODIMP Logo3CodeDLBSC::RecordPrecacheValue(HRESULT hr)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "Logo3CodeDLBSC::RecordPrecacheValue",
                "this=%#x, %#x",
                this, hr
                ));
                
    HRESULT                           hrRet = S_OK;
    DWORD                             lResult = 0;
    HKEY                              hkeyLogo3 = 0;
    HKEY                              hkeyVersion = 0;
    char                              achBuffer[MAX_CACHE_ENTRY_INFO_SIZE];
    static const char                *szAvailableVersion = "AvailableVersion";
    static const char                *szPrecache = "Precache";

    if (_szDistUnit != NULL)
    {
        wnsprintf(achBuffer, sizeof(achBuffer)-1,  "%s\\%s", REGSTR_PATH_LOGO3_SETTINGS, _szDistUnit);
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, achBuffer, 0, KEY_ALL_ACCESS,
                         &hkeyLogo3) == ERROR_SUCCESS)
        {
            if (RegOpenKeyEx(hkeyLogo3, szAvailableVersion,
                             0, KEY_ALL_ACCESS, &hkeyVersion) != ERROR_SUCCESS)
            {
                if ((lResult = RegCreateKey(hkeyLogo3, szAvailableVersion,
                                            &hkeyVersion)) != ERROR_SUCCESS)
                {
                    hrRet = HRESULT_FROM_WIN32(lResult);
                    goto Exit;
                }
            }
        
            // record result of caching bits.
        
            HRESULT hrRecord = hr;
            
            if (FAILED(hr))
            {
                hrRecord = ERROR_IO_INCOMPLETE;
            }
            
            lResult = ::RegSetValueEx(hkeyVersion, szPrecache, NULL, REG_DWORD, 
                                      (unsigned char *)&hrRecord, sizeof(DWORD));

            if (lResult != ERROR_SUCCESS)
            {
                hrRet = HRESULT_FROM_WIN32(lResult);
                goto Exit;
            }
        }
    }
    else {
        hrRet = E_INVALIDARG;
    }

Exit:

    if (hkeyLogo3)
    {
        RegCloseKey(hkeyLogo3);
    }

    if (hkeyVersion)
    {
        RegCloseKey(hkeyVersion);
    }

    DEBUG_LEAVE(hrRet);
    return hrRet;
}

#ifdef LOGO3_SUPPORT_AUTOINSTALL

void Logo3CodeDLBSC::TimeOut()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "Logo3CodeDLBSC::TimeOut",
                "this=%#x",
                this
                ));
                
    CLock                             lck(g_mxsCDL); // Mutex req for CDLList
    LISTPOSITION                      pos = NULL;

    if (WaitForSingleObjectEx(_hProc, 0, FALSE) == WAIT_OBJECT_0)
    {
        Assert(_pClientBSC);
        _pClientBSC->OnStopBinding(S_OK, NULL);

        // Remove self from code download list
        pos = g_CDLList.Find(this);
        Assert(pos);
        g_CDLList.RemoveAt(pos);
        Release();

        // If no more code downloads, kill the timer
        if (!g_CDLList.GetCount()) {
            KillTimer(NULL, g_Timer);
            g_Timer = 0;
        }
    }

    DEBUG_LEAVE(0);
}


void CALLBACK TimeOutProc(HWND hwnd, UINT msg, UINT idEvent, DWORD dwTime)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "TimeOutProc",
                "%#x, %#x, %#x, %#x",
                hwnd, msg, idEvent, dwTime
                ));
                
    LISTPOSITION                    pos = NULL;
    Logo3CodeDLBSC                 *bsc = NULL;

    lpos = g_CDLList.GetHeadPosition();
    while (lpos) {
        bsc = g_CDLList.GetNext(pos);
        Assert(bsc);
        bsc->TimeOut();
    }

    DEBUG_LEAVE(0);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\pefile.h ===
#define SIZE_OF_NT_SIGNATURE    sizeof (DWORD)

/* global macros to define header offsets into file */
/* offset to PE file signature                     */
#define NTSIGNATURE(a) ((LPVOID)((BYTE *)a           +  \
            ((PIMAGE_DOS_HEADER)a)->e_lfanew))

/* DOS header identifies the NT PEFile signature dword
   the PEFILE header exists just after that dword          */
#define PEFHDROFFSET(a) ((LPVOID)((BYTE *)a          +  \
             ((PIMAGE_DOS_HEADER)a)->e_lfanew    +  \
             SIZE_OF_NT_SIGNATURE))

/* PE optional header is immediately after PEFile header       */
#define OPTHDROFFSET(a) ((LPVOID)((BYTE *)a          +  \
             ((PIMAGE_DOS_HEADER)a)->e_lfanew    +  \
             SIZE_OF_NT_SIGNATURE            +  \
             sizeof (IMAGE_FILE_HEADER)))

/* section headers are immediately after PE optional header    */
#define SECHDROFFSET(a) ((LPVOID) IMAGE_FIRST_SECTION(NTSIGNATURE(a)))

/* global prototypes for functions in pefile.c */
/* PE file header info */
DWORD   WINAPI ImageFileType (LPVOID);
BOOL    WINAPI GetPEFileHeader (LPVOID, PIMAGE_FILE_HEADER);

LPVOID  WINAPI GetImageBase (LPVOID);
LPVOID  WINAPI ImageDirectoryOffset (LPVOID, DWORD);

/* PE section header info */
int WINAPI GetSectionNames (LPVOID, HANDLE, char **);
BOOL    WINAPI GetSectionHdrByName (LPVOID, PIMAGE_SECTION_HEADER, char *);

/* export section info */
int WINAPI GetExportFunctionNames (LPVOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\softdist.cxx ===
// ===========================================================================
// File: SOFTDIST.CXX
//    Channel Software Distribution Unit Tag handler
//

#include <cdlpch.h>
#include <winineti.h>
#include <shlwapip.h>
#include <msxml.h>

LPCSTR szWinNT = "WinNT";
LPCSTR szWin95 = "Win95";

LPCSTR szPlatform = "Win32"; 

LPCOLESTR szMSInstallProgID = L"MSInstall.SoftDistExt";

const TCHAR c_szTrayUI[] = TEXT("MS_WebcheckMonitor");  // Do not change this string. LoadWC relies on it.
const TCHAR c_szTrayMenu[] = TEXT("TrayMenu");

const LPTSTR szControlSetup = _T("Status");
const DWORD dwStatusOK = 0;
const DWORD dwStatusSuspend = 1;
const DWORD dwStatusResume = 2;
const DWORD dwStatusAbort = 3;

const UM_NEEDREBOOT   = WM_USER + 16;

extern char *g_szProcessorTypes[];
extern char g_szBrowserLang[];
extern int g_lenBrowserLang;
extern char g_szBrowserPrimaryLang[];
extern int g_lenBrowserPrimaryLang;
extern LCID g_lcidBrowser;



#define ERROR_EXIT(cond) if (!(cond)) { \
        goto Exit;}

extern COleAutDll g_OleAutDll;

//REVIEW: This is located in cdl.cxx for page swapping reasons.  (OSD's are processed 
//        more than CDF/<SoftDist>'s?

HRESULT ProcessImplementation(IXMLElement *pConfig,
                              CList<CCodeBaseHold *, CCodeBaseHold *> *pcbhList,
                              LCID lcidOverride,
#ifdef WX86
                              CMultiArch *MultiArch,
#endif
                              LPWSTR szBaseURL);


HRESULT 
GetAbstract(HKEY hkeyAv, LPSTR *ppszAbstract)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "GetAbstract",
                "%#x, %#x",
                hkeyAv, ppszAbstract
                ));
                
    HRESULT hr = S_OK;
    DWORD Size,dwType;
    LONG lResult;

    if (ppszAbstract) {

        *ppszAbstract = NULL;

        if (RegQueryValueEx(hkeyAv, REGVAL_ABSTRACT_AVAILABLE, NULL, &dwType, 
            NULL, &Size) == ERROR_SUCCESS) {

            *ppszAbstract = new char[Size];

            if (!*ppszAbstract) {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
            if ((lResult = RegQueryValueEx(hkeyAv, REGVAL_ABSTRACT_AVAILABLE, NULL, &dwType, 
                (unsigned char *)*ppszAbstract, &Size) != ERROR_SUCCESS)) {

                hr = HRESULT_FROM_WIN32(lResult);
            }

        }
    }

Exit:

    DEBUG_LEAVE(hr);
    return hr;
}

BOOL
IsAbstractDifferent(HKEY hkeyAv, LPSTR szNewAbstract)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Bool,
                "IsAbstractDifferent",
                "%#x, %.80q",
                hkeyAv, szNewAbstract
                ));
                
    LPSTR pszOldAbstract = NULL;
    BOOL bDifferent = TRUE;

    if ((GetAbstract(hkeyAv, &pszOldAbstract) == S_OK) && pszOldAbstract) {

        if (szNewAbstract)
            bDifferent = lstrcmp(pszOldAbstract, szNewAbstract) != 0;

        delete pszOldAbstract;


    }
    
    DEBUG_LEAVE(bDifferent);
    return bDifferent;
}

/******************************************************************************
    Constructor, Destructor and helper methods
******************************************************************************/

CSoftDist::CSoftDist()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CSoftDist::CSoftDist",
                "this=%#x",
                this
                ));
                
    DllAddRef();
    m_cRef = 1;
    m_szDistUnit = NULL;

    m_szCDFURL = NULL;

    m_szTitle = NULL;
    m_szAbstract = NULL;
    m_szHREF = NULL;

    m_szLanguages = NULL;

    m_dwVersionMS = m_dwVersionLS = 0;

    m_dwVersionAdvertisedMS = m_dwVersionAdvertisedLS = 0;
    m_dwAdState = SOFTDIST_ADSTATE_NONE;

    m_Style = STYLE_MSICD;
    
    m_sdMSInstall = NULL;
    m_pClientBSC = NULL;
    m_szBaseURL = NULL;

    memset(&m_distunitinst, 0, sizeof(DISTUNITINST));

    DetermineOSAndCPUVersion();
    
    DEBUG_LEAVE(0);
}

CSoftDist::~CSoftDist()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CSoftDist::~CSoftDist",
                "this=%#x",
                this
                ));
                
    Assert(m_cRef == 0);

    SAFERELEASE(m_sdMSInstall);

    SAFEDELETE(m_szDistUnit);

    SAFEDELETE(m_szCDFURL);
    SAFEDELETE(m_szTitle);
    SAFEDELETE(m_szAbstract);
    SAFEDELETE(m_szHREF);
    SAFEDELETE(m_szLanguages);
    SAFEDELETE(m_pClientBSC);
    SAFEDELETE(m_szBaseURL);

    DllRelease();

    DEBUG_LEAVE(0);
}

/******************************************************************************
    IUnknown Methods
******************************************************************************/

STDMETHODIMP CSoftDist::QueryInterface(
                                                REFIID iid, 
                                                void** ppvObject)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSoftDist::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &iid, ppvObject
                ));
                
    *ppvObject = NULL;

    if (iid == IID_IUnknown)
    {
        *ppvObject = (void*)this;
    }
    else if (iid == IID_ISoftDistExt)
    {
        *ppvObject = (void*)(ISoftDistExt*)this;
    }

    if (*ppvObject) 
    {
        ((LPUNKNOWN)*ppvObject)->AddRef();
    
        DEBUG_LEAVE(S_OK);
        return S_OK;
    }

    DEBUG_LEAVE(E_NOINTERFACE);
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSoftDist::AddRef()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Dword,
                "CSoftDist::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    ULONG ulRet = ++m_cRef;

    DEBUG_LEAVE(ulRet);
    return ulRet;
}

STDMETHODIMP_(ULONG) CSoftDist::Release()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Dword,
                "CSoftDist::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    if (--m_cRef)
    {
        DEBUG_LEAVE(m_cRef);
        return m_cRef;
    }
    
    delete this;

    DEBUG_LEAVE(0);
    return 0;   
}


/******************************************************************************
    ISoftDistExt Methods
******************************************************************************/
/*
 * return values:
 *  All success codes indicate user should be notified through channel UI.
 *
 *  S_OK:       Locally not available, Send Email (Show in channel UI)
 *  S_FALSE:    Locally not available. Don't send Email. (But show in channel UI)
 *
 *  ERROR_ALREADY_EXISTS:Locally already installed. Don't send email/advertise.
 *  ERROR:               Processing error, fail.
 *
 *  For additional information on usage flags, set dwReserved to a valid pointer
 *  and it will set appropriate bit fields
 *
 */
STDMETHODIMP 
CSoftDist::ProcessSoftDist(LPCWSTR szCDFURL, IXMLElement *pSoftDist, LPSOFTDISTINFO psdi)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSoftDist::ProcessSoftDist",
                "this=%#x, %.80wq, %#x, %#x",
                this, szCDFURL, pSoftDist, psdi
                ));
                
    HRESULT hr = S_FALSE;               // default: send email, no precache
    char szVersion[MAX_PATH];
    char szStyle[MAX_PATH];
    LPSTR szThisOS = NULL;
    LPWSTR szTitle = NULL;
    IXMLElement *pTitle = NULL, *pConfig = NULL, *pLang = NULL, 
                *pAbstract = NULL, *pUsage = NULL, *pDeleteOnInstall = NULL;
    IXMLElement *pParent = NULL;
    BOOL bPrecache = FALSE, bChannelUIOnly = FALSE, bAutoInstall = FALSE, 
         bIsPrecached = FALSE, bDeleteOnInstall = FALSE;
    BOOL fFoundConfig = FALSE;
    LPDWORD lpFlags = NULL;
    BOOL bIsValidCDF = FALSE;

    if (psdi) {
        if (psdi->cbSize < sizeof(SOFTDISTINFO))
        {
            DEBUG_LEAVE(E_INVALIDARG);
            return E_INVALIDARG;
        }
        
        psdi->dwFlags = 0;
    }

    if (szCDFURL && FAILED((hr=::Unicode2Ansi(szCDFURL, &m_szCDFURL))))
    {
        goto Exit;
    }

    // Try to use the BASE tag from the channel.

    // BUGBUG: This is a really convoluted way to get at the channel
    // BASE URL, but there is no way for webcheck to pass this
    // information to us w/o changing the ISoftDistExt interface.

    pSoftDist->get_parent(&pParent);
    if (pParent) {
        DupAttribute(pParent, CHANNEL_ATTRIB_BASE, &m_szBaseURL);
        SAFERELEASE(pParent);
    }

    hr = DupAttribute(pSoftDist, DU_ATTRIB_NAME, &m_szDistUnit);
    ERROR_EXIT(SUCCEEDED(hr));

    // code around assumes that MAX_PATH is MAX size of dist unit
    // we try to make a key name with the distunit and that limit is
    // now MAX_PATH. Hence the reasoning to limit this to MAX_PATH

    if (lstrlenW(m_szDistUnit) >= MAX_PATH) {
        hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
        goto Exit;
    }

    hr = DupAttributeA(pSoftDist, DU_ATTRIB_HREF, &m_szHREF);
    ERROR_EXIT(SUCCEEDED(hr));
    if (psdi) {
        hr = Ansi2Unicode( m_szHREF, &psdi->szHREF );
        if ( FAILED(hr) )
            goto Exit;
    }

    hr = GetAttributeA(pSoftDist, DU_ATTRIB_VERSION, szVersion, MAX_PATH);
    ERROR_EXIT(SUCCEEDED(hr));

    if ( FAILED(GetVersionFromString(szVersion, &m_dwVersionMS, &m_dwVersionLS))){
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    if (!(m_dwVersionMS | m_dwVersionLS)) {         // zero is invalid advt version

        hr = E_INVALIDARG;
        goto Exit;
    }

    if (psdi) {

        CHAR szTemp[MAX_PATH];
        psdi->dwFlags = 0;

        psdi->dwUpdateVersionMS = m_dwVersionMS;
        psdi->dwUpdateVersionLS = m_dwVersionLS;

        psdi->dwAdvertisedVersionMS = m_dwVersionAdvertisedMS;
        psdi->dwAdvertisedVersionLS = m_dwVersionAdvertisedLS;

        if (GetFirstChildTag(pSoftDist, DU_TAG_USAGE, &pUsage) == S_OK) {

            VARIANT vtVal;
            VariantInit(&vtVal);
            
            if (SUCCEEDED(pUsage->getAttribute(DU_ATTRIB_VALUE, &vtVal)) && (vtVal.vt == VT_BSTR)) {

                if (!StrCmpIW(vtVal.bstrVal, DU_ATTRIB_EMAIL))
                     psdi->dwFlags |= SOFTDIST_FLAG_USAGE_EMAIL;

//                SAFESYSFREESTRING(vtVal.bstrVal);
                 
            }
            VariantClear(&vtVal);
                
            SAFERELEASE(pUsage);
        }

        if (SUCCEEDED(GetAttributeA(pSoftDist, DU_ATTRIB_PRECACHE, szTemp, MAX_PATH))) {
        
            if (szTemp[0] == 'Y' || szTemp[0] == 'y') {
                psdi->dwFlags |= SOFTDIST_FLAG_USAGE_PRECACHE;
                bPrecache = TRUE;
            }
            
        }

        if (SUCCEEDED(GetAttributeA(pSoftDist, DU_ATTRIB_AUTOINSTALL, szTemp, MAX_PATH))) {
        
            if (szTemp[0] == 'Y' || szTemp[0] == 'y') {
                psdi->dwFlags |= SOFTDIST_FLAG_USAGE_AUTOINSTALL;
                bPrecache = TRUE;
                bAutoInstall = TRUE;
            }
            
        }
    
    }

    // get abstract
    if(GetFirstChildTag(pSoftDist,DU_TAG_ABSTRACT, &pAbstract) == S_OK) {
        
        BSTR bstrAbstract = NULL;
        hr = pAbstract->get_text(&bstrAbstract);
        ERROR_EXIT(SUCCEEDED(hr));

        if (FAILED(Unicode2Ansi(bstrAbstract, &m_szAbstract))) {
            hr = E_OUTOFMEMORY;
            SAFESYSFREESTRING(bstrAbstract);
            goto Exit;
        }

        if (psdi) {
            psdi->szAbstract = new WCHAR[lstrlenW(bstrAbstract)+1];
            if (!psdi->szAbstract) {
                hr = E_OUTOFMEMORY;
                SAFESYSFREESTRING(bstrAbstract);
                goto Exit;
            } else {
                StrCpyW(psdi->szAbstract, bstrAbstract);
            }
        }

        SAFESYSFREESTRING(bstrAbstract);
    }

    // get title
    if(GetFirstChildTag(pSoftDist,DU_TAG_TITLE, &pTitle) == S_OK) {
        BSTR bstrTitle = NULL;
        hr = pTitle->get_text(&bstrTitle);
        ERROR_EXIT(SUCCEEDED(hr));

        if (FAILED(Unicode2Ansi(bstrTitle, &m_szTitle))) {
            hr = E_OUTOFMEMORY;
            SAFESYSFREESTRING(bstrTitle);
            goto Exit;
        }

        if (psdi) {
            psdi->szTitle = new WCHAR[lstrlenW(bstrTitle)+1];
            if (!psdi->szTitle) {
                hr = E_OUTOFMEMORY;
                SAFESYSFREESTRING(bstrTitle);
                goto Exit;
            } else {
                StrCpyW(psdi->szTitle, bstrTitle);
            }
        }
        
        SAFESYSFREESTRING(bstrTitle);
    }

    // get langs available
    if(GetFirstChildTag(pSoftDist,DU_TAG_LANG, &pLang) == S_OK) {
        BSTR bstrLang = NULL;
        hr = pLang->get_text(&bstrLang);
        ERROR_EXIT(SUCCEEDED(hr));

        DWORD len = lstrlenW(bstrLang);
        m_szLanguages = new char [len+1];
        if (!m_szLanguages) {
            hr = E_OUTOFMEMORY;
            SAFESYSFREESTRING(bstrLang);
            goto Exit;
        }
        WideCharToMultiByte(CP_ACP, 0, bstrLang , -1, m_szLanguages,
                            len, NULL, NULL);

        SAFESYSFREESTRING(bstrLang);
    }

    // <deleteoninstall />
    if (GetFirstChildTag(pSoftDist, DU_TAG_DELETEONINSTALL, &pDeleteOnInstall) == S_OK) {
        SAFERELEASE(pDeleteOnInstall);
        bDeleteOnInstall = TRUE;
    }

    // style tells us who to ask
    // accomodate Darwin here
    if(SUCCEEDED(GetAttributeA(pSoftDist, DU_ATTRIB_STYLE, szStyle, MAX_PATH))){

        (void) GetStyleFromString(szStyle, &m_Style);

        if (m_Style == STYLE_UNKNOWN) {

            if (m_sdMSInstall == NULL) {

                CLSID clsidOther;
                LPWSTR wszStyle = NULL;

                if (FAILED(DupAttribute(pSoftDist, DU_ATTRIB_STYLE, &wszStyle)))
                    goto Exit;

                if (SUCCEEDED(CLSIDFromProgID(wszStyle, &clsidOther))) {
                    
                    if (FAILED(hr = CoCreateInstance(clsidOther, NULL, CLSCTX_INPROC_SERVER,
                                    IID_ISoftDistExt, (void **)&m_sdMSInstall)))
                        goto Exit;

                    m_Style = STYLE_OTHER;

                }
                // If failed, continue as normal.
            }
        }

        if (m_Style == STYLE_MSINSTALL) {
            
            if (m_sdMSInstall == NULL) {

                CLSID clsidMSInstall;

                if (FAILED(hr = CLSIDFromProgID(szMSInstallProgID, &clsidMSInstall)))
                    goto Exit;
                
                if (FAILED(hr = CoCreateInstance(clsidMSInstall, NULL, CLSCTX_INPROC_SERVER, 
                                    IID_ISoftDistExt, (void **)&m_sdMSInstall)))
                    goto Exit;

            }
        }

        if (m_sdMSInstall != NULL) {
            hr = m_sdMSInstall->ProcessSoftDist(szCDFURL, pSoftDist, psdi);
            goto Exit;
        }

    }

    // get list of available languages here

    hr = InitBrowserLangStrings();
    if (FAILED(hr))
        goto Exit;

    // check if software already locally installed
    hr = IsLocallyInstalled(m_szDistUnit, m_dwVersionMS, m_dwVersionLS, m_szLanguages, m_Style);

    if ( psdi != NULL )
    {
        if ( SUCCEEDED(hr) )
        {
            psdi->dwInstalledVersionMS = m_distunitinst.dwInstalledVersionMS;
            psdi->dwInstalledVersionLS = m_distunitinst.dwInstalledVersionLS;
        }
        else
        {
            // No version.
            psdi->dwInstalledVersionMS = 0xFFFFFFFF;
            psdi->dwInstalledVersionLS = 0xFFFFFFFF;
        }
    }

    if (hr != S_FALSE) {
        if (hr == S_OK) {            
            
            if (psdi && bDeleteOnInstall) {
                psdi->dwFlags |=  SOFTDIST_FLAG_DELETE_SUBSCRIPTION;
            }

            hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
        }
        goto Exit;
    }

    // check here to see if Advertised already to avoid
    // processing filters?
    if (FAILED(hr = IsAdvertised(&bIsPrecached, &bIsValidCDF)))
        goto Exit;

    // If already advertised then only precache once.
    if (hr == S_OK) {
        if ((!bPrecache) || (!bAutoInstall && bPrecache && bIsPrecached)) {
            bChannelUIOnly = TRUE;
        }
    }

    // version doesn't already exist
    // process filters to see if we can Advertise this

    // look for dependency & config filters.  If either fails, then we don't do Channel UI or
    // email notification.

    if (FAILED(hr = CheckDependency(pSoftDist)))
        goto Exit;

    if (FAILED(hr = CheckConfig(pSoftDist)))
        goto Exit;

    if (bChannelUIOnly)
    {
        // we record advertise again to stomp the title & abstract
        if (bIsValidCDF) {
            
            hr = Advertise(/*bFullAdvt*/FALSE);
        }

        // We are already advertised, we want Channel UI but not email notification.
        hr = S_FALSE;
    }
    else
    {
        if (bIsValidCDF) {

            // Advertise software, mark as Advertised
            hr = Advertise(/*bFullAdvt*/TRUE);

            // We advertise in Channel UI and email notification.
            hr = S_OK;
        
        } else {
        
            // if not an authorized CDF then we can't trigger email notification or download
            hr = S_FALSE;
        }

    }

Exit:
    SAFERELEASE(pLang);
    SAFERELEASE(pAbstract);
    SAFERELEASE(pTitle);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP
CSoftDist::GetFirstCodeBase(LPWSTR *szCodeBase, LPDWORD lpdwSize)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSoftDist::GetFirstCodeBase",
                "this=%#x, %#x, %#x",
                this, szCodeBase, lpdwSize
                ));
                
    HRESULT hr;
    if (m_sdMSInstall != NULL)
    {
        hr = m_sdMSInstall->GetFirstCodeBase(szCodeBase, lpdwSize);

        DEBUG_LEAVE(hr);
        return hr;
    }
    m_curPos = m_cbh.GetHeadPosition();
    hr = GetNextCodeBase(szCodeBase, lpdwSize);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP
CSoftDist::GetNextCodeBase(LPWSTR *szCodeBase, LPDWORD lpdwSize)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSoftDist::GetNextCodeBase",
                "this=%#x, %#x, %#x",
                this, szCodeBase, lpdwSize
                ));
                
    HRESULT hr = S_OK;
    CCodeBaseHold *cbh = NULL;

    if (m_sdMSInstall != NULL)
    {
        hr = m_sdMSInstall->GetNextCodeBase(szCodeBase, lpdwSize);

        DEBUG_LEAVE(hr);
        return hr;
    }
    if (szCodeBase == NULL || lpdwSize == NULL) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *szCodeBase = NULL;
    *lpdwSize = 0;

    if (m_curPos == NULL) {
        hr = E_FAIL;
        goto Exit;
    }

    cbh = m_cbh.GetNext(m_curPos);

    hr = CDLDupWStr( szCodeBase, cbh->wszCodeBase );
    *lpdwSize = cbh->dwSize;
    
Exit:

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP 
CSoftDist::AsyncInstallDistributionUnit(IBindCtx *pbc, LPVOID pvReserved, DWORD dwFlags, LPCODEBASEHOLD lpcbh)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSoftDist::AsyncInstallDistributionUnit",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, pbc, pvReserved, dwFlags, lpcbh
                ));
                
    HRESULT                   hr = S_OK;
    LPWSTR                    szCodeBase = NULL;
    DWORD                     dwSize;

    
    if ((lpcbh) && (lpcbh->cbSize == sizeof(CODEBASEHOLD)))
    {
        hr = ::AsyncInstallDistributionUnit(
                            lpcbh->szDistUnit,
                            NULL,
                            NULL,
                            lpcbh->dwVersionMS,
                            lpcbh->dwVersionLS,
                            lpcbh->szCodeBase,            // URL of code base
                            pbc,
                            NULL,
                            0);

    } else if (m_Style == STYLE_MSICD) {

        if (SUCCEEDED(GetFirstCodeBase(&szCodeBase, &dwSize))) {
            CCodeBaseHold *pcbh;

            pcbh = m_cbh.GetHead();
            pcbh->dwFlags |= CBH_FLAGS_DOWNLOADED;
            hr = ::AsyncInstallDistributionUnit(
                            m_szDistUnit,
                            NULL,
                            NULL,
                            m_dwVersionMS,
                            m_dwVersionLS,
                            szCodeBase,            // URL of code base
                            pbc,
                            NULL,
                            0);

            // NOTE: EAX should be MK_S_ASYNC (0x401E8)

        } else
            hr = E_FAIL;

        // Return successful no matter what

    } else if (m_Style == STYLE_MSINSTALL || m_Style == STYLE_OTHER) {

        if (m_sdMSInstall == NULL) {

            hr = E_FAIL;                    // Interfaces should be here but aren't.

        } else {
        
            hr = m_sdMSInstall->AsyncInstallDistributionUnit(pbc, pvReserved, dwFlags, lpcbh);

        }

    } else if (m_Style == STYLE_ACTIVE_SETUP) {

        if (SUCCEEDED(GetFirstCodeBase(&szCodeBase, &dwSize))) {

            CActiveSetupBinding *pasb = NULL;
            IBindStatusCallback *pbsc = NULL;

            if (SUCCEEDED(pbc->GetObjectParam(REG_BSCB_HOLDER, (IUnknown **)&pbsc))) {

                pasb = new CActiveSetupBinding(pbc, pbsc, szCodeBase, m_szDistUnit, &hr);
                if (pasb && FAILED(hr)) {
    
                    SAFERELEASE(pasb);          // deletes itself

                }

                SAFERELEASE(pbsc);

                // NOTE: This is not a memory leak, the object will clean itself up when it
                //       is done the binding operation.

            }
            else
                hr = E_FAIL;
        }
        else
            hr = E_FAIL;

    } else if (m_Style == STYLE_LOGO3) {
        CCodeBaseHold          *pcbhCur = NULL;

        m_curPos = m_cbh.GetHeadPosition();
        if (m_curPos == 0) {
            goto Exit;
        }
        pcbhCur = m_cbh.GetAt(m_curPos);
        if (pcbhCur == NULL) {
            goto Exit;
        }

        CDLDupWStr(&szCodeBase, pcbhCur->wszCodeBase);
        dwSize = pcbhCur->dwSize;
        pcbhCur->dwFlags |= CBH_FLAGS_DOWNLOADED;

        if (pbc != NULL) {
            pbc->GetObjectParam(REG_BSCB_HOLDER, (IUnknown **)&m_pClientBSC);
        }
        
        hr = Logo3Download(szCodeBase);

    } else {

        hr = E_NOTIMPL;

    }
    
Exit:

    SAFEDELETE(szCodeBase);

    DEBUG_LEAVE(hr);
    return hr;
}

/******************************************************************************
    CheckDependency
******************************************************************************/
/* This checks for filter criteria in <Config> tags.
 *
 * <!ELEMENT Dependency (SoftDist)* | Language | Processor | Platform>
 *
 * Returns: E_ERROR code if Dependency check fails or badly formatted.
 *
 */
HRESULT
CSoftDist::CheckDependency(IXMLElement *pSoftDist)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSoftDist::CheckDependency",
                "this=%#x, %#x",
                this, pSoftDist
                ));
                
    int nLastChildTag = -1;
    LPSTR szLanguages = NULL;
    LPWSTR szCoreDist = NULL;
    IXMLElement *pDepend = NULL, *pCoreDist = NULL;
    IXMLElement *pProcessor = NULL, *pPlatform = NULL, *pLang = NULL;
    HRESULT hr = S_OK;
    DWORD style;

    while (GetNextChildTag(pSoftDist, DU_TAG_DEPENDENCY, &pDepend, nLastChildTag) == S_OK) {

        LPWSTR szCoreDist = NULL;
        union {
            char szVersion[MAX_PATH];
            char szStyle[MAX_PATH];
            char szProcessor[MAX_PATH];
            char szPlatformAttr[MAX_PATH];
        };

        // check for 'softdist' tag and version info.
        int nLastSoftDist = -1;
        while (GetNextChildTag(pDepend, DU_TAG_SOFTDIST, &pCoreDist, nLastSoftDist) == S_OK) {

            // default values if attributes are not specified.
            DWORD dwVersionMS = 0, dwVersionLS = 0, style = m_Style;

            // look for language tag (if present), otherwise NULL.
            SAFEDELETE(szLanguages);
            if (GetFirstChildTag(pCoreDist, DU_TAG_LANG, &pLang) == S_OK) {
                BSTR bstrLang = NULL;
                pLang->get_text(&bstrLang);

                DWORD len = lstrlenW(bstrLang);
                szLanguages = new char[len+1];
                if (!szLanguages) {
                    hr = E_OUTOFMEMORY;
                    SAFESYSFREESTRING(bstrLang);
                    goto Exit;
                }
                WideCharToMultiByte(CP_ACP, 0, bstrLang , -1, szLanguages,
                                    len, NULL, NULL);

                SAFESYSFREESTRING(bstrLang);
            }

            if (FAILED(hr = DupAttribute(pCoreDist, DU_ATTRIB_NAME, &szCoreDist)))
                goto Exit;

            if (SUCCEEDED(GetAttributeA(pCoreDist, DU_ATTRIB_VERSION, szVersion, MAX_PATH))) {
                
                if (FAILED(GetVersionFromString(szVersion, &dwVersionMS, &dwVersionLS))) {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    goto Exit;
                }
         
            }

            if (SUCCEEDED(GetAttributeA(pCoreDist, DU_ATTRIB_STYLE, szStyle, MAX_PATH))) {

                // return is not required
                (void) GetStyleFromString(szStyle, &style);

            }

            hr = IsLocallyInstalled(szCoreDist, dwVersionMS, dwVersionLS,
                                szLanguages != NULL ? szLanguages : m_szLanguages, style);
            SAFEDELETE(szCoreDist);

            // core product doesn't exist, or version is lower than required.
            if (hr != S_OK)  {
                 hr = HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
                 goto Exit;
            }
            SAFERELEASE(pCoreDist);

        } // while for softdist

        // check processor
        if (GetFirstChildTag(pDepend, DU_TAG_PROCESSOR, &pProcessor) == S_OK) {

            if (FAILED(hr = GetAttributeA(pProcessor, DU_ATTRIB_VALUE, szProcessor, MAX_PATH)))
                goto Exit;

#ifdef WX86
            char *szPreferredArch;
            char *szAlternateArch;
            HRESULT hrArch;

            GetMultiArch()->SelectArchitecturePreferences(
                        g_szProcessorTypes[g_CPUType],
                        g_szProcessorTypes[PROCESSOR_ARCHITECTURE_INTEL],
                        &szPreferredArch,
                        &szAlternateArch);

            if (lstrcmpi(szPreferredArch, szProcessor) == 0) {
                hrArch = GetMultiArch()->RequirePrimaryArch();
                Assert(SUCCEEDED(hrArch));
            } else if (szAlternateArch && lstrcmpi(szAlternateArch, szProcessor) == 0) {
                hrArch = GetMultiArch()->RequireAlternateArch();
                Assert(SUCCEEDED(hrArch));
            } else {
                //
                // Processor type is neither perferred nor alternate.
                //
                hr = HRESULT_FROM_WIN32(ERROR_EXE_MACHINE_TYPE_MISMATCH);
                goto Exit;
            }
#else
	    if (lstrcmpi(g_szProcessorTypes[g_CPUType],szProcessor) != 0) {
                hr = HRESULT_FROM_WIN32(ERROR_EXE_MACHINE_TYPE_MISMATCH);
                goto Exit;
            }
#endif
        }

        // check platform
        if (GetFirstChildTag(pDepend, DU_TAG_PLATFORM, &pPlatform) == S_OK) {

            if (FAILED(hr = GetAttributeA(pPlatform, DU_ATTRIB_VALUE, szPlatformAttr, MAX_PATH)))
                goto Exit;

            if (lstrcmpi(szPlatform, szPlatformAttr) != 0) {
                hr = HRESULT_FROM_WIN32(ERROR_EXE_MACHINE_TYPE_MISMATCH);
                goto Exit;
            }

        }

        SAFERELEASE(pDepend);

    } // dependency check loop
Exit:
    SAFERELEASE(pDepend);
    SAFERELEASE(pCoreDist);
    SAFERELEASE(pProcessor);
    SAFERELEASE(pPlatform);
    SAFERELEASE(pLang);

    SAFEDELETE(szLanguages);
    SAFEDELETE(szCoreDist);

    DEBUG_LEAVE(hr);
    return hr;
}

/******************************************************************************
    CheckConfig
******************************************************************************/
/* This checks for filter criteria in <Config> tags.
 *
 * <!ELEMENT Config (CodeBase)*>
 * <!ATTLIST Config Language CDATA #IMPLIED>
 * <!ATTLIST Config (OS OSVersion) CDATA #IMPLIED>
 * <!ATTLIST Config Processor CDATA #IMPLIED>
 */
HRESULT
CSoftDist::CheckConfig(IXMLElement *pSoftDist)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSoftDist::CheckConfig",
                "this=%#x, %#x",
                this, pSoftDist
                ));
                
    IXMLElement *pConfig = NULL;
    IXMLElement *pCodeBase = NULL;
    BOOL fFoundMatchingConfig = FALSE;
    BOOL fFoundAnyConfig = FALSE;
    HRESULT hr = S_OK;
    int nLastChildTag = -1;
    int nLastChildCodeBase = -1;
    WCHAR szResult[INTERNET_MAX_URL_LENGTH];
    DWORD dwSize = 0;

    // Process CONFIG tags 
    while (GetNextChildTag(pSoftDist, DU_TAG_CONFIG, &pConfig, nLastChildTag) == S_OK) {

        fFoundAnyConfig = TRUE;

        if (ProcessImplementation(pConfig, &m_cbh, GetThreadLocale(),
#ifdef WX86
                                  GetMultiArch(),
#endif
                                  m_szBaseURL) == S_OK) {
            fFoundMatchingConfig = TRUE;
            break;
        }

        SAFERELEASE(pConfig);
    }

    // if at least one config and none match, return with error.
    if (fFoundAnyConfig && !fFoundMatchingConfig) {
        hr = HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
        goto Exit;
    }

Exit:
    SAFERELEASE(pConfig);
    SAFERELEASE(pCodeBase);

    DEBUG_LEAVE(hr);
    return hr;
}

typedef HRESULT (STDAPICALLTYPE *PFNLCIDTORFC1766)(LCID, LPSTR, DWORD);

HRESULT
GetLangStringMod(HMODULE hMod, LCID localeID, char *szThisLang, int iLen)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "GetLangStringMod",
                "%#x, %#x, %.80q",
                hMod, localeID, szThisLang
                ));
                
    PFNLCIDTORFC1766 pfnLCIDToRFC1766 = NULL;
    HRESULT hr = S_OK;

#ifdef UNICODE
    pfnLCIDToRFC1766 = (PFNLCIDTORFC1766)GetProcAddress(hMod, "LcidToRfc1766W");
#else
    pfnLCIDToRFC1766 = (PFNLCIDTORFC1766)GetProcAddress(hMod, "LcidToRfc1766A");
#endif

    if (pfnLCIDToRFC1766) {

        hr = pfnLCIDToRFC1766(localeID, szThisLang, iLen);

    } else {
        hr = E_UNEXPECTED;
    } 

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT
GetLangString(LCID localeID, char *szThisLang, int iLen)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "GetLangString",
                "%#x, %.80q",
                localeID, szThisLang
                ));
                
    HRESULT hr = S_OK;
    HMODULE hMod = 0;
    LCID lcidPrimaryBrowser = PRIMARYLANGID(LANGIDFROMLCID(g_lcidBrowser));


    // use cached copies of browser lang string
    if ( (localeID == g_lcidBrowser) && g_szBrowserLang[0] ) {

        StrNCpy(szThisLang, g_szBrowserLang, iLen);
        goto Exit;

    }

    if ( (localeID == lcidPrimaryBrowser) && g_szBrowserPrimaryLang[0] ) {

        StrNCpy(szThisLang, g_szBrowserPrimaryLang, iLen);
        goto Exit;

    }

    hMod = LoadLibrary("mlang.dll");

    if (!hMod) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }


    hr = GetLangStringMod(hMod, localeID, szThisLang, iLen);

Exit:

    if (hMod)
        FreeLibrary(hMod);

    DEBUG_LEAVE(hr);
    return hr;
}

// globals for code downloader
extern CMutexSem g_mxsCodeDownloadGlobals;
BOOL g_bLangInit = FALSE;

HRESULT
InitBrowserLangStrings()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "InitBrowserLangStrings",
                NULL
                ));
                
    HRESULT hr = S_OK;
    CLock lck(g_mxsCodeDownloadGlobals);
    static const char *cszSHDOCVW = "\\shdocvw.dll";

    if (g_bLangInit)
    {
        DEBUG_LEAVE(hr);
        return hr;
    }
    
    g_bLangInit = TRUE;

    CLocalComponentInfo lci;
    DWORD dwVerMS, dwVerLS;

    GetSystemDirectory(lci.szExistingFileName, MAX_PATH);

    StrCatBuff(lci.szExistingFileName, cszSHDOCVW, sizeof(lci.szExistingFileName));
    if (SUCCEEDED(GetFileVersion(&lci, &dwVerMS, &dwVerLS))) {
        if (lci.lcid) {

            g_lcidBrowser = lci.lcid;

        }
    }

    HMODULE hMod = LoadLibrary("mlang.dll");
    LCID lcidPrimaryBrowser = PRIMARYLANGID(LANGIDFROMLCID(g_lcidBrowser));

    if (hMod) {

        hr = GetLangStringMod(hMod, g_lcidBrowser, g_szBrowserLang, g_lenBrowserLang);
        hr = GetLangStringMod(hMod, lcidPrimaryBrowser, g_szBrowserPrimaryLang, g_lenBrowserPrimaryLang);
        FreeLibrary(hMod);
    } else {

        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    DEBUG_LEAVE(hr);
    return hr;
}

/******************************************************************************
    CheckLanguage
******************************************************************************/
/* The languages string is of the form,
 *  lang1;lang2;lang3;...
 *
 *  OR = '*' (the first character is an asterick).
 *
 * This routine will scan the LocaleID string (as saved from registry, GetLocaleInfo)
 * for an occurrence in the szLanguage string.  If found, it returns true.  If '*'
 * is specified, the result is always true.  Regular expressions are otherwise
 * not supported.
 *
 */
HRESULT CheckLanguage(LCID localeID, LPTSTR szLanguage)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CheckLanguage",
                "%#x, %.80q",
                localeID, szLanguage
                ));
                
    LCID lcidPrimaryBrowser = PRIMARYLANGID(LANGIDFROMLCID(g_lcidBrowser));
    CHAR szThisLang[MAX_PATH];
    int i;
    HRESULT hr = S_OK;

    if (szLanguage == NULL)
    {
        DEBUG_LEAVE(S_OK);
        return S_OK;
    }
    if (*szLanguage == '*')
    {
        DEBUG_LEAVE(S_OK);
        return S_OK;
    }
    hr = GetLangString(localeID, (char *)szThisLang, sizeof(szThisLang));

    if (FAILED(hr)) {
        DEBUG_LEAVE(hr);
        return hr;
    }

    if (AreAllLanguagesPresent((char *)szThisLang, szLanguage)) {
        DEBUG_LEAVE(S_OK);
        return S_OK;
    }           
    
    // check with primary language
    localeID = PRIMARYLANGID(LANGIDFROMLCID(localeID));

    hr = GetLangString(localeID, (char *)szThisLang, sizeof(szThisLang));

    if (FAILED(hr)) {
        DEBUG_LEAVE(hr);
        return hr;
    }

    if (AreAllLanguagesPresent((char *)szThisLang, szLanguage)) {
        DEBUG_LEAVE(S_OK);
        return S_OK;
    }           


    hr = HRESULT_FROM_WIN32(ERROR_RESOURCE_LANG_NOT_FOUND);
    
    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT
CSoftDist::IsLocallyInstalled(LPCWSTR szDistUnit, DWORD dwVersionMS, DWORD dwVersionLS, LPCSTR szLanguages, DWORD Style)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSoftDist::IsLocallyInstalled",
                "this=%#x, %.80wq, %#x, %#x, %.80q, %#x",
                this, szDistUnit, dwVersionMS, dwVersionLS, szLanguages, Style
                ));
                
    Assert(szDistUnit);
    HRESULT hr = S_OK;
    if (Style == STYLE_MSICD)
        hr = IsICDLocallyInstalled(szDistUnit, dwVersionMS, dwVersionLS, szLanguages);
    else if (Style == STYLE_ACTIVE_SETUP)
        hr = IsActSetupLocallyInstalled(szDistUnit, dwVersionMS, dwVersionLS, szLanguages);
    else if (Style == STYLE_LOGO3)
        hr = IsLogo3LocallyInstalled(szDistUnit, dwVersionMS, dwVersionLS, szLanguages);
    else
        hr = E_UNEXPECTED;
    
    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT
CSoftDist::IsLogo3LocallyInstalled(LPCWSTR szDistUnit, DWORD dwVersionMS, DWORD dwVersionLS, LPCSTR szLanguages)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSoftDist::IsLogo3LocallyInstalled",
                "this=%#x, %.80wq, %#x, %#x, %.80q",
                this, szDistUnit, dwVersionMS, dwVersionLS, szLanguages
                ));
                
    HRESULT                hr = S_OK; 
    DWORD                  dwInstVersionMS = 0;
    DWORD                  dwInstVersionLS = 0;
    DWORD                  dwType = 0;
    DWORD                  dwLen = 0;
    LPSTR                  szDU = NULL;
    HKEY                   hkeyLogo3 = 0;
    HKEY                   hkeyDist = 0;

// No LOGO3 language information is stored, so language checking is not
// possible yet.

    Assert(szDistUnit);
    if (!szDistUnit) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    dwLen = WideCharToMultiByte(CP_ACP,0, szDistUnit, -1, NULL, 0, NULL, NULL);
    szDU = new char [dwLen];
    if (szDU == NULL) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    WideCharToMultiByte(CP_ACP, 0, szDistUnit , -1, szDU,
                        dwLen, NULL, NULL);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_LOGO3_SETTINGS,
                     0, KEY_READ, &hkeyLogo3) != ERROR_SUCCESS) {
        hr = E_FAIL;
        goto Exit;
    }

    if (RegOpenKeyEx(hkeyLogo3, szDU, 0, KEY_READ, &hkeyDist) != ERROR_SUCCESS) {
        hr = S_FALSE;
        goto Exit;
    }

    dwLen = sizeof(DWORD);
    if (RegQueryValueEx(hkeyDist, REGVAL_LOGO3_MAJORVERSION, 0, &dwType,
                        (LPBYTE)&dwInstVersionMS, &dwLen) != ERROR_SUCCESS) {
        hr = S_FALSE;
        goto Exit;
    }

    dwLen = sizeof(DWORD);
    if (RegQueryValueEx(hkeyDist, REGVAL_LOGO3_MINORVERSION, 0, &dwType,
                        (LPBYTE)&dwInstVersionLS, &dwLen) != ERROR_SUCCESS) {
        hr = S_FALSE;
        goto Exit;
    }

    m_distunitinst.dwInstalledVersionMS = dwInstVersionMS;
    m_distunitinst.dwInstalledVersionLS = dwInstVersionLS;

    if (dwInstVersionMS > dwVersionMS ||
        (dwInstVersionMS == dwVersionMS && dwInstVersionLS >= dwVersionLS)) {
        hr = S_OK;
    } else {
        hr = S_FALSE;
    }

Exit:

    if (hkeyLogo3) {
        RegCloseKey(hkeyLogo3);
    }

    if (hkeyDist) {
        RegCloseKey(hkeyDist);
    }

    if (szDU) {
        delete [] szDU;
    }
    
    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT
CSoftDist::IsICDLocallyInstalled(LPCWSTR szDistUnit, DWORD dwVersionMS, DWORD dwVersionLS, LPCSTR szLanguages)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSoftDist::IsICDLocallyInstalled",
                "this=%#x, %.80wq, %#x, %#x, %.80q",
                this, szDistUnit, dwVersionMS, dwVersionLS, szLanguages
                ));
                
    Assert(szDistUnit);
    CLSID inclsid = CLSID_NULL;
    HRESULT hr = S_OK;

    CLocalComponentInfo* plci = NULL;

    plci = new CLocalComponentInfo();
    if(!plci) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

     // if fails szDistUnit is not clsid
    CLSIDFromString((LPOLESTR)szDistUnit, &inclsid);

    // check to see if locally installed.
    if ((hr = IsControlLocallyInstalled(NULL,
            (LPCLSID)&inclsid, szDistUnit,
            dwVersionMS, dwVersionLS, plci, NULL)) != S_FALSE) {

        // S_OK if local version OK
        // ERROR, fail
        goto Exit;

    }

    // check for other hooks like Active Setup, Add/Remove Programs here

Exit:
    if (plci)
    {
        m_distunitinst.dwInstalledVersionMS = plci->dwLocFVMS;
        m_distunitinst.dwInstalledVersionLS = plci->dwLocFVLS;
    }

    SAFEDELETE(plci);
    
    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT
CSoftDist::IsAdvertised(LPBOOL lpfIsPrecached, LPBOOL lpfIsAuthorizedCDF)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSoftDist::IsAdvertised",
                "this=%#x, %#x, %#x",
                this, lpfIsPrecached, lpfIsAuthorizedCDF
                ));
                
    HRESULT hr = S_OK;
    if (m_Style == STYLE_MSICD)
        hr = IsICDAdvertised(lpfIsPrecached, lpfIsAuthorizedCDF);
    else if (m_Style == STYLE_ACTIVE_SETUP)
        hr = IsActSetupAdvertised(lpfIsPrecached, lpfIsAuthorizedCDF);
    else if (m_Style == STYLE_LOGO3)
        hr = IsLogo3Advertised(lpfIsPrecached, lpfIsAuthorizedCDF);
    else
        hr = E_UNEXPECTED;
    
    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT
CSoftDist::IsLogo3Advertised(LPBOOL lpfIsPrecached, LPBOOL lpfIsAuthorizedCDF)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSoftDist::IsLogo3Advertised",
                "this=%#x, %#x, %#x",
                this, lpfIsPrecached, lpfIsAuthorizedCDF
                ));
                
    HRESULT                       hr = S_OK;
    HKEY                          hkeyDistInfo = 0;
    HKEY                          hkeyAdvertisedVersion = 0;
    HKEY                          hkeyAuthCDF = 0;
    HKEY                          hkeyLogo3 = 0;
    DWORD                         lResult = 0;
    DWORD                         dwSize = 0;
    DWORD                         dwType;
    LPSTR                         szDU = NULL;
    DWORD                         dwLen = 0;
    DWORD                         dwCurAdvMS = 0;
    DWORD                         dwCurAdvLS = 0;
    char                          szBuffer[MAX_REGSTR_LEN];
    char                          szVersionBuf[MAX_PATH];
    static const char            *szPrecache = "Precache";
    static const char            *szAbstract = "Abstract";
    static const char            *szAuthorizedCDF = "AuthorizedCDFPrefix";
    static const char            *szHREF = "HREF";
    static const char            *szTITLE = "TITLE";

    ASSERT(lpfIsPrecached && lpfIsAuthorizedCDF);

    if (!lpfIsPrecached || !lpfIsAuthorizedCDF) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *lpfIsPrecached = FALSE;
    *lpfIsAuthorizedCDF = FALSE;

    if (m_szDistUnit) {
        if (FAILED(Unicode2Ansi(m_szDistUnit, &szDU))) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }
    }
    else {
        hr = E_INVALIDARG;
        goto Exit;
    }

    wnsprintf(szBuffer, sizeof(szBuffer)-1, "%s\\%s", REGSTR_PATH_LOGO3_SETTINGS, szDU);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuffer, 0, KEY_READ,
                     &hkeyLogo3) != ERROR_SUCCESS) {
        hr = S_FALSE;
        goto Exit;
    }

    *lpfIsAuthorizedCDF = IsAuthorizedCDF(hkeyLogo3);

    if (RegOpenKeyEx(hkeyLogo3, "AvailableVersion", 0, KEY_READ,
                     &hkeyDistInfo) != ERROR_SUCCESS) {
        hr = S_FALSE;
        goto Exit;
    }

    dwSize = sizeof(DWORD);
    if (RegQueryValueEx(hkeyDistInfo, szPrecache, 0, &dwType,
                        (unsigned char *)&lResult, &dwSize) == ERROR_SUCCESS) {
        // Precached value was the code download HR
        *lpfIsPrecached = (SUCCEEDED(lResult)) ? (TRUE) : (FALSE);
    }

    // This key is optionally present.
    dwSize = MAX_PATH;
    if (RegQueryValueEx(hkeyDistInfo, REGSTR_LOGO3_ADVERTISED_VERSION, NULL, &dwType,
                        (unsigned char *)szVersionBuf, &dwSize) == ERROR_SUCCESS)
    {
        GetVersionFromString(szVersionBuf, &m_dwVersionAdvertisedMS, &m_dwVersionAdvertisedLS);
    }

    // Get the AdState, if any
    dwSize = sizeof(DWORD);
    RegQueryValueEx(hkeyDistInfo, REGVAL_ADSTATE, NULL, NULL, (LPBYTE)&m_dwAdState, &dwSize);

    if (!m_szAbstract) {
        if (RegQueryValueEx(hkeyDistInfo, szAbstract, NULL, &dwType,
            NULL, &dwSize) == ERROR_SUCCESS) {

            m_szAbstract = new char[dwSize];
            if (!m_szAbstract) {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            if (RegQueryValueEx(hkeyDistInfo, szAbstract, NULL, &dwType,
                (unsigned char *)m_szAbstract, &dwSize) != ERROR_SUCCESS) {

                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }

        }
    }

    if (!m_szHREF) {
        if (RegQueryValueEx(hkeyDistInfo, szHREF, NULL, &dwType,
            NULL, &dwSize) == ERROR_SUCCESS) {

            m_szHREF = new char[dwSize];
            if (!m_szHREF) {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            if (RegQueryValueEx(hkeyDistInfo, szHREF, NULL, &dwType,
                (unsigned char *)m_szHREF, &dwSize) != ERROR_SUCCESS) {

                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }

        }
    }

    if (!m_szTitle) {
        if (RegQueryValueEx(hkeyDistInfo, szTITLE, NULL, &dwType,
            NULL, &dwSize) == ERROR_SUCCESS) {

            m_szTitle = new char[dwSize];
            if (!m_szHREF) {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }

            if (RegQueryValueEx(hkeyDistInfo, szTITLE, NULL, &dwType,
                (unsigned char *)m_szTitle, &dwSize) != ERROR_SUCCESS) {

                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }

        }
    }

    dwSize = MAX_PATH;
    if (RegQueryValueEx(hkeyDistInfo, NULL, NULL, &dwType,
                        (unsigned char *)szVersionBuf, &dwSize) != ERROR_SUCCESS) {
        hr = S_FALSE;
        goto Exit;
    }

    if ( FAILED(GetVersionFromString(szVersionBuf, &dwCurAdvMS, &dwCurAdvLS))){
        hr = S_FALSE;
        goto Exit;
    }

    if (!(m_dwVersionMS|m_dwVersionLS)) {
        m_dwVersionMS = dwCurAdvMS;
        m_dwVersionLS = dwCurAdvLS;
    }

    if (IsCDFNewerVersion(dwCurAdvMS, dwCurAdvLS)) {
        hr = S_FALSE;
    }
    else {
        hr = S_OK;
    }

Exit:

    if (hkeyDistInfo) {
        RegCloseKey(hkeyDistInfo);
    }

    if (hkeyAdvertisedVersion) {
        RegCloseKey(hkeyAdvertisedVersion);
    }

    if (hkeyLogo3) {
        RegCloseKey(hkeyLogo3);
    }

    if (hkeyAuthCDF) {
        RegCloseKey(hkeyAuthCDF);
    }

    SAFEDELETE(szDU);
    
    DEBUG_LEAVE(hr);
    return hr;
}

// **** IsICDAdvertised ****
// returns: S_FALSE for not advertised (or newest version not advertised)
//          S_OK for advertised

HRESULT
CSoftDist::IsICDAdvertised(LPBOOL lpfIsPrecached, LPBOOL lpfIsAuthorizedCDF)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSoftDist::IsICDAdvertised",
                "this=%#x, %#x, %#x",
                this, lpfIsPrecached, lpfIsAuthorizedCDF
                ));
                
    HRESULT hr = S_OK;
    LONG lResult = ERROR_SUCCESS;
    HKEY hkeyDist =0;
    HKEY hkeyThisDist = 0;
    HKEY hkeyVersion = 0;
    HKEY hkeyAdvertisedVersion = 0;
    DWORD Size = MAX_PATH;
    DWORD SizeDword = sizeof(DWORD);
    DWORD dwType;

    DWORD dwCurAdvMS = 0;
    DWORD dwCurAdvLS = 0;

    const static char * szAvailableVersion = "AvailableVersion";
    const static char * szHREF = "HREF";
    const static char * szABSTRACT = "Abstract";
    const static char * szPrecache = "Precache";
    const static char * szAuthorizedCDF = "AuthorizedCDFPrefix";

    LPSTR pszDist = NULL;

    char szVersionBuf[MAX_PATH];

    ASSERT(lpfIsPrecached && lpfIsAuthorizedCDF);
    if (!lpfIsPrecached || !lpfIsAuthorizedCDF) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *lpfIsPrecached = FALSE;
    *lpfIsAuthorizedCDF = TRUE;

    if ((lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REGSTR_PATH_DIST_UNITS,
                        0, KEY_ALL_ACCESS, &hkeyDist)) != ERROR_SUCCESS) {

        hr = S_FALSE;
        goto Exit;
    }

    if (FAILED((hr=::Unicode2Ansi(m_szDistUnit, &pszDist))))
    {
        goto Exit;
    }

    // open the dist unit key for this dist unit.
    if (RegOpenKeyEx( hkeyDist, pszDist,
            0, KEY_ALL_ACCESS, &hkeyThisDist) != ERROR_SUCCESS) {
        hr = S_FALSE;
        goto Exit;
    }

    *lpfIsAuthorizedCDF = IsAuthorizedCDF(hkeyThisDist, /*bOptional*/TRUE);

    if (RegOpenKeyEx( hkeyThisDist, szAvailableVersion,
            0, KEY_ALL_ACCESS, &hkeyVersion) != ERROR_SUCCESS) {
        hr = S_FALSE;
        goto Exit;
    }

    if (RegQueryValueEx(hkeyVersion, szPrecache, 0, &dwType, 
        (unsigned char *)&lResult, &SizeDword) == ERROR_SUCCESS) {

        // check for success or common error conditions which indicate we have bits.
        if (SUCCEEDED(lResult)) {
            *lpfIsPrecached = TRUE;
        } else {
            *lpfIsPrecached = FALSE;
        }
    }

    // This key is optionally present.
    if ( RegOpenKeyEx( hkeyThisDist, REGKEY_MSICD_ADVERTISED_VERSION,
            0, KEY_ALL_ACCESS, &hkeyAdvertisedVersion) == ERROR_SUCCESS )
    {
        Size = MAX_PATH;

        if (RegQueryValueEx(hkeyAdvertisedVersion, NULL, NULL, &dwType, 
                (unsigned char *)szVersionBuf, &Size) == ERROR_SUCCESS)
            GetVersionFromString(szVersionBuf, &m_dwVersionAdvertisedMS, &m_dwVersionAdvertisedLS);
        // Get the AdState, if any
        SizeDword = sizeof(DWORD);
        RegQueryValueEx( hkeyAdvertisedVersion, REGVAL_ADSTATE, NULL, NULL, (LPBYTE)&m_dwAdState, &SizeDword);
    }

    // save away the advt info like Title, href, abstract
    // if called from GetDistributionUnitAdvt()
    if (!m_szTitle) {
        if (RegQueryValueEx(hkeyThisDist, NULL, NULL, &dwType, 
            NULL, &Size) == ERROR_SUCCESS) {

            m_szTitle = new char[Size];

            if (!m_szTitle) {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
            if (RegQueryValueEx(hkeyThisDist, NULL, NULL, &dwType, 
                (unsigned char *)m_szTitle, &Size) != ERROR_SUCCESS) {

                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }

        }
    }

    if (!m_szAbstract) {
        if (RegQueryValueEx(hkeyVersion, szABSTRACT, NULL, &dwType, 
            NULL, &Size) == ERROR_SUCCESS) {

            m_szAbstract = new char[Size];

            if (!m_szAbstract) {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
            if (RegQueryValueEx(hkeyVersion, szABSTRACT, NULL, &dwType, 
                (unsigned char *)m_szAbstract, &Size) != ERROR_SUCCESS) {

                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }

        }
    }

    if (!m_szHREF) {
        if (RegQueryValueEx(hkeyVersion, szHREF, NULL, &dwType, 
            NULL, &Size) == ERROR_SUCCESS) {

            m_szHREF = new char[Size];

            if (!m_szHREF) {
                hr = E_OUTOFMEMORY;
                goto Exit;
            }
            if (RegQueryValueEx(hkeyVersion, szHREF, NULL, &dwType, 
                (unsigned char *)m_szHREF, &Size) != ERROR_SUCCESS) {

                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }

        }
    }

    if (RegQueryValueEx(hkeyVersion, NULL, NULL, &dwType, 
            (unsigned char *)szVersionBuf, &Size) != ERROR_SUCCESS) {
        hr = S_FALSE;
        goto Exit;
    }

    if ( FAILED(GetVersionFromString(szVersionBuf, &dwCurAdvMS, &dwCurAdvLS))){
        hr = S_FALSE;
        goto Exit;
    }

    if (!(m_dwVersionMS|m_dwVersionLS)) {
        m_dwVersionMS = dwCurAdvMS;
        m_dwVersionLS = dwCurAdvLS;
    }

    if (IsCDFNewerVersion(dwCurAdvMS, dwCurAdvLS))
        hr = S_FALSE;
    else 
        hr = S_OK;

Exit:
    SAFEDELETE(pszDist);

    SAFEREGCLOSEKEY(hkeyVersion);
    SAFEREGCLOSEKEY(hkeyAdvertisedVersion);
    SAFEREGCLOSEKEY(hkeyDist);
    SAFEREGCLOSEKEY(hkeyThisDist);
    
    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT
CSoftDist::Advertise(BOOL bFullAdvt)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSoftDist::Advertise",
                "this=%#x, %B",
                this, bFullAdvt
                ));
                
    HRESULT hr = S_OK;
    if (m_Style == STYLE_MSICD)
        hr = ICDAdvertise(bFullAdvt);
    else if (m_Style == STYLE_ACTIVE_SETUP)
        hr = ActSetupAdvertise(bFullAdvt);
    else if (m_Style == STYLE_LOGO3)
        hr = Logo3Advertise(bFullAdvt);
    else
        hr = E_UNEXPECTED;
    
    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT
CSoftDist::Logo3Advertise(BOOL bFullAdvt)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSoftDist::Logo3Advertise",
                "this=%#x, %B",
                this, bFullAdvt
                ));
                
    HRESULT                  hr = S_OK;
    DWORD                    dwLen = 0;
    DWORD                    lResult = 0;
    LPSTR                    szDU = NULL;
    HKEY                     hkeyLogo3 = 0;
    HKEY                     hkeyDist = 0;
    HKEY                     hkeyAvailVersion = 0;
    DWORD                    dwAdState;
    static const char       *szAvailableVersion = "AvailableVersion";
    static const char       *szPrecache = "Precache";
    static const char       *szHREF = "HREF";
    static const char       *szTitle = "Title";
    char                     szVersionBuf[MAX_PATH];


    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_LOGO3_SETTINGS,
                     0, KEY_ALL_ACCESS, &hkeyLogo3) != ERROR_SUCCESS) {
        hr = E_FAIL;
        goto Exit;
    }

    dwLen = WideCharToMultiByte(CP_ACP,0, m_szDistUnit, -1, NULL, 0, NULL, NULL);
    szDU = new char [dwLen];
    if (szDU == NULL) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    WideCharToMultiByte(CP_ACP, 0, m_szDistUnit , -1, szDU, dwLen, NULL, NULL);

    if (RegOpenKeyEx(hkeyLogo3, szDU, 0, KEY_ALL_ACCESS, &hkeyDist) != ERROR_SUCCESS) {
        // Create key if it doesn't exist
        if ((lResult = RegCreateKey(hkeyLogo3, szDU, &hkeyDist)) != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
        }
    }

    if (RegOpenKeyEx(hkeyDist, szAvailableVersion, 0, KEY_ALL_ACCESS,
                     &hkeyAvailVersion) != ERROR_SUCCESS) {
        if ((lResult = RegCreateKey(hkeyDist, szAvailableVersion, &hkeyAvailVersion)) != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
        }
    }

    wsprintf(szVersionBuf, "%d,%d,%d,%d",
            (m_dwVersionMS & 0xffff0000)>>16,
            (m_dwVersionMS & 0xffff),
            (m_dwVersionLS & 0xffff0000)>>16,
            (m_dwVersionLS & 0xffff));

    lResult = ::RegSetValueEx(hkeyAvailVersion, NULL, NULL, REG_SZ,
                              (unsigned char *)szVersionBuf,
                              lstrlen(szVersionBuf) + 1);

    if (bFullAdvt || IsAbstractDifferent(hkeyAvailVersion, m_szAbstract)) {
        // Clear previous AdState, if any
        dwAdState = SOFTDIST_ADSTATE_NONE;
        // Don't panic if this fails
        lResult = ::RegSetValueEx(hkeyAvailVersion, REGVAL_ADSTATE, NULL,
                        REG_DWORD, (unsigned char *)&dwAdState, sizeof(DWORD));

        // save HREF
        if ((lResult == ERROR_SUCCESS) && m_szHREF) {
            lResult = ::RegSetValueEx(hkeyAvailVersion, szHREF, NULL, REG_SZ,
                                      (unsigned char *)m_szHREF,
                                      lstrlen(m_szHREF) + 1);
        }

        // save Abstract
        if ((lResult == ERROR_SUCCESS) && m_szAbstract) {
            lResult = RegSetValueEx(hkeyAvailVersion, REGVAL_ABSTRACT_AVAILABLE,
                        NULL, REG_SZ, (unsigned char *)m_szAbstract,
                            lstrlen(m_szAbstract) + 1);
        }

        // save Title
        if ((lResult == ERROR_SUCCESS) && m_szTitle) {
            lResult = ::RegSetValueEx(hkeyAvailVersion, szTitle, NULL, REG_SZ,
                                      (unsigned char *)m_szTitle,
                                      lstrlen(m_szTitle) + 1);

        }

    }

    if (lResult != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(lResult);
        goto Exit;
    }

    // new advertisement, remove old precache
    if (bFullAdvt)
        ::RegDeleteValue(hkeyAvailVersion, szPrecache);


Exit:

    if (hkeyLogo3) {
        RegCloseKey(hkeyLogo3);
    }

    if (hkeyDist) {
        RegCloseKey(hkeyDist);
    }

    if (hkeyAvailVersion) {
        RegCloseKey(hkeyAvailVersion);
    }

    if (szDU) {
        delete [] szDU;
    }

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT
CSoftDist::ICDAdvertise(BOOL bFullAdvt)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSoftDist::ICDAdvertise",
                "this=%#x, %B",
                this, bFullAdvt
                ));
                
    HRESULT hr = S_OK;
    LONG lResult = ERROR_SUCCESS;
    HKEY hkeyDist =0;
    HKEY hkeyThisDist = 0;
    HKEY hkeyDownloadInfo = 0;

    HKEY hkeyVersion = 0;
    HKEY hkeyAdvertisedVersion = 0;

    const static char * szAvailableVersion = "AvailableVersion";
    const static char * szDownloadInfo = "DownloadInformation";
    const static char * szCODEBASE = "CODEBASE";
    const static char * szLOCALCDF = "CDF";
    const static char * szINSTALLER = "Installer";
    const static char * szMSICD = "MSICD";
    const static char * szHREF = "HREF";
    const static char * szPrecache = "Precache";
    char szTmpCodeBase[MAX_PATH+sizeof(szCODEBASE)+5];    
    LPSTR pszCodeBase = NULL;
    int numCodeBase;
    POSITION pos;

    LPSTR pszDist = NULL;

    char szVersionBuf[MAX_PATH];

    if ((lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE, REGSTR_PATH_DIST_UNITS,
                        0, KEY_ALL_ACCESS, &hkeyDist)) != ERROR_SUCCESS) {
        if ((lResult = RegCreateKey( HKEY_LOCAL_MACHINE,
                   REGSTR_PATH_DIST_UNITS, &hkeyDist)) != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
        }
    }

    if (FAILED((hr=::Unicode2Ansi(m_szDistUnit, &pszDist))))
    {
        goto Exit;
    }

    // open/create the dist unit key for this dist unit.
    if (RegOpenKeyEx( hkeyDist, pszDist,
            0, KEY_ALL_ACCESS, &hkeyThisDist) != ERROR_SUCCESS) {
        if ((lResult = RegCreateKey( hkeyDist,
                   pszDist, &hkeyThisDist)) != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
            }
    }

    if (m_szTitle && 
        ((lResult = ::RegSetValueEx(hkeyThisDist, NULL, NULL, REG_SZ, 
                (unsigned char *)m_szTitle,
                lstrlen(m_szTitle)+1)) != ERROR_SUCCESS)){

        hr = HRESULT_FROM_WIN32(lResult);
        goto Exit;
    }

    lResult = ::RegSetValueEx(hkeyThisDist, szINSTALLER, NULL, REG_SZ, 
                        (unsigned char *)szMSICD, sizeof(szMSICD)+1);

    if (lResult != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(lResult);
        goto Exit;
    }


    // open/create the download info key for this dist unit.
    if (RegOpenKeyEx( hkeyThisDist, szDownloadInfo,
            0, KEY_ALL_ACCESS, &hkeyDownloadInfo) != ERROR_SUCCESS) {
        if ((lResult = RegCreateKey( hkeyThisDist,
                   szDownloadInfo, &hkeyDownloadInfo)) != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
            }
    }

    // set download info params
    if (GetCDF() &&  (lResult = ::RegSetValueEx(hkeyDownloadInfo, 
        szLOCALCDF, NULL, REG_SZ, (unsigned char *)GetCDF(), lstrlen(GetCDF())+1)) != ERROR_SUCCESS) {

        hr = HRESULT_FROM_WIN32(lResult);
        goto Exit;
    }

    pos = m_cbh.GetHeadPosition();
    numCodeBase = 1;
    while (pos != NULL) {

        CCodeBaseHold *cbh = m_cbh.GetNext(pos);
        if (numCodeBase <= 1)
            lstrcpy((char *)szTmpCodeBase, szCODEBASE);
        else
            wsprintf(szTmpCodeBase, "%s%d", szCODEBASE, numCodeBase);

        if (FAILED(::Unicode2Ansi(cbh->wszCodeBase,&pszCodeBase))) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        if ((lResult = ::RegSetValueEx(hkeyDownloadInfo, szTmpCodeBase,
            NULL, REG_SZ, (unsigned char *)pszCodeBase, strlen(pszCodeBase))) != ERROR_SUCCESS) {
            
            SAFEDELETE(pszCodeBase);
            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
        }

        SAFEDELETE(pszCodeBase);
        numCodeBase ++;
    }

    // Note Version
    wsprintf(szVersionBuf, "%d,%d,%d,%d",
            (m_dwVersionMS & 0xffff0000)>>16,
            (m_dwVersionMS & 0xffff),
            (m_dwVersionLS & 0xffff0000)>>16,
            (m_dwVersionLS & 0xffff));

    if (RegOpenKeyEx( hkeyThisDist, szAvailableVersion,
            0, KEY_ALL_ACCESS, &hkeyVersion) != ERROR_SUCCESS) {
        if ((lResult = RegCreateKey( hkeyThisDist,
                   szAvailableVersion, &hkeyVersion)) != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(lResult);
            goto Exit;
            }
    }

    if (bFullAdvt || IsAbstractDifferent(hkeyVersion, m_szAbstract)) {

        // Clear previous AdState, if any
        if (RegOpenKey(hkeyThisDist, REGKEY_MSICD_ADVERTISED_VERSION, &hkeyAdvertisedVersion) == ERROR_SUCCESS)
        {
            DWORD dwAdState = SOFTDIST_ADSTATE_NONE;

            // Don't panic if this fails
            lResult = ::RegSetValueEx(hkeyAdvertisedVersion, REGVAL_ADSTATE, NULL, REG_DWORD, 
                                      (unsigned char *)&dwAdState, sizeof(DWORD) );
        }
    }

    // new advertisement, remove old precache
    if (bFullAdvt)
        ::RegDeleteValue(hkeyVersion, szPrecache);
  
    lResult = ::RegSetValueEx(hkeyVersion, NULL, NULL, REG_SZ, 
                        (unsigned char *)szVersionBuf, lstrlen(szVersionBuf)+1);
    // save HREF
    if ( (lResult == ERROR_SUCCESS) && m_szHREF)
        lResult = ::RegSetValueEx(hkeyVersion, szHREF, NULL, REG_SZ, 
                        (unsigned char *)m_szHREF, lstrlen(m_szHREF)+1);
    // save Abstract
    if ( (lResult == ERROR_SUCCESS) && m_szAbstract)
        lResult = ::RegSetValueEx(hkeyVersion, REGVAL_ABSTRACT_AVAILABLE, NULL, REG_SZ, 
                        (unsigned char *)m_szAbstract, lstrlen(m_szAbstract)+1);

    if (lResult != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(lResult);
        goto Exit;
    }

Exit:
    SAFEDELETE(pszDist);
    SAFEDELETE(pszCodeBase);
    SAFEREGCLOSEKEY(hkeyDownloadInfo);
    SAFEREGCLOSEKEY(hkeyVersion);
    SAFEREGCLOSEKEY(hkeyDist);
    SAFEREGCLOSEKEY(hkeyThisDist);
    SAFEREGCLOSEKEY(hkeyAdvertisedVersion);
    
    DEBUG_LEAVE(hr);
    return hr;
}

BOOL
CSoftDist::IsAuthorizedCDF(HKEY hkeyRootDU, BOOL bOptional)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Bool,
                "CSoftDist::IsAuthorizedCDF",
                "this=%#x, %#x, %B",
                this, hkeyRootDU, bOptional
                ));
                
    const static char *szAuthorizedCDF="AuthorizedCDFPrefix";
    BOOL fResult = FALSE;
    HRESULT hr;
    int iValue = 0;
    CHAR szEnumCDF[MAX_PATH];
    DWORD dwValueSize = MAX_PATH;
    LPWSTR wzCDFURL = 0;
    IInternetSecurityManager *pism = 0;
    DWORD dwZone = 0, dwType = 0;
    HKEY hkeyAuthCDF = 0;
    DWORD                         dwPolicy = 0;
    DWORD                         dwContext = 0;

    if (!hkeyRootDU) {
        goto Exit;
    }

    if (!m_szCDFURL) {
        goto Exit;
    }

    if (FAILED(CoInternetCreateSecurityManager(NULL, &pism, 0)) || !pism) {
        goto Exit;
    }

    if (FAILED(Ansi2Unicode(m_szCDFURL, &wzCDFURL))) {
        goto Exit;
    }

    pism->ProcessUrlAction(wzCDFURL, URLACTION_CHANNEL_SOFTDIST_PERMISSIONS,
               (BYTE *)&dwPolicy, sizeof(dwPolicy),
               (BYTE *)&dwContext, sizeof(dwContext),
               PUAF_NOUI, 0);

    if (dwPolicy == URLPOLICY_CHANNEL_SOFTDIST_AUTOINSTALL)
    {
        fResult = TRUE;
        goto Exit;
    }

    // if no "AuthorizedCDF" key exists we don't do any prefix checking
    if (RegOpenKeyEx( hkeyRootDU, szAuthorizedCDF,
            0, KEY_READ, &hkeyAuthCDF) != ERROR_SUCCESS) {

        if (bOptional)
            fResult = TRUE;
        goto Exit;
    }

    iValue = 0;
    while (RegEnumValue(hkeyAuthCDF, iValue++, 
           szEnumCDF, &dwValueSize, 0, &dwType, NULL, NULL) == ERROR_SUCCESS) {

        dwValueSize = MAX_PATH; // reset

        // check for partial match, if found return true.
        if (StrCmpNI(szEnumCDF, m_szCDFURL, min(lstrlenA(szEnumCDF), lstrlenA(m_szCDFURL))) == 0) {
            fResult = TRUE;
            goto Exit;
        }
    }

Exit:
    SAFERELEASE(pism);
    SAFEDELETE(wzCDFURL);

    if (hkeyAuthCDF)
        RegCloseKey(hkeyAuthCDF);

    DEBUG_LEAVE(fResult);
    return fResult;
}

BOOL
CSoftDist::IsCDFNewerVersion(DWORD dwLocFVMS, DWORD dwLocFVLS)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Bool,
                "CSoftDist::IsCDFNewerVersion",
                "this=%#x, %#x, %#x",
                this, dwLocFVMS, dwLocFVLS
                ));
                
    BOOL fRet = ((m_dwVersionMS > dwLocFVMS) ||
                    ((m_dwVersionMS == dwLocFVMS) &&
                        (m_dwVersionLS > dwLocFVLS)));

    DEBUG_LEAVE(fRet);
    return fRet;
}


HRESULT
CSoftDist::IsActSetupLocallyInstalled(LPCWSTR szDistUnit, DWORD dwVersionMS, DWORD dwVersionLS, LPCSTR szLanguages)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSoftDist::IsActSetupLocallyInstalled",
                "this=%#x, %.80wq, %#x, %#x, %.80q",
                this, szDistUnit, dwVersionMS, dwVersionLS, szLanguages
                ));
                
    Assert(szDistUnit);
    HRESULT hr = S_FALSE, hr2;       // Not installed by active setup.
    LONG    lResult = ERROR_SUCCESS;
    LPSTR  pszKey = NULL;
    BOOL   bAllocedKey = FALSE;
    int        nKey;

    //we've done this at THREE other places in the code, so let's raise this from 1 to 2 *MAX_PATH
    char    szKey[2*MAX_PATH];
    char    szVersion[MAX_PATH];
    HKEY    hKey    = NULL;
    DWORD   dwSize;
    DWORD   dwValue;
    DWORD   dwType;
    BOOL    fIsInstalled = FALSE;
    WORD    wVersion[4];
    LPSTR   pszDist = NULL;
    DWORD   dwCurMS = 0;
    DWORD   dwCurLS = 0;

    const static char * szLocale = "Locale";
    const static char * szIsInstalled = "IsInstalled";
    const static char * szActVersion = "Version";

    if (FAILED((hr2=::Unicode2Ansi(szDistUnit, &pszDist))))
    {
        hr = hr2;
        goto Exit;
    }

    ULONG ulenDist = lstrlenA(pszDist);
    //sizeof counts terminating NULL also, so subtract 2, and add 1 for the final NULL
    ULONG ulenConst = sizeof(REGKEY_ACTIVESETUP_COMPONENTS)/sizeof(CHAR) + sizeof("\\")/sizeof(CHAR) - 2 + 1;
    
    if ((ulenDist+ulenConst)  > sizeof(szKey))
    {
    	pszKey = new CHAR[ulenDist+ulenConst];
    }

    if  (pszKey)
    {
    	bAllocedKey = TRUE;
    	nKey = ulenDist+ulenConst;
    }
    else
    {
    	pszKey = szKey;
    	nKey = sizeof(szKey);
    }

    StrNCpy(pszKey, REGKEY_ACTIVESETUP_COMPONENTS, nKey);
    StrCatBuff(pszKey, "\\", nKey);
    StrCatBuff(pszKey, pszDist, nKey);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        // Check for the installed language. And see if it fits the availabel szLanguages
        dwSize = sizeof(szVersion);
        if (RegQueryValueEx( hKey, szLocale, NULL, NULL, (LPBYTE)szVersion, &dwSize) == ERROR_SUCCESS)
        {
            if (szLanguages && !AreAllLanguagesPresent(szVersion, szLanguages))
                goto Exit;
        }

        dwSize = sizeof(dwValue);
        // Old format of the Installed components did not have the IsInstalled value.
        if (RegQueryValueEx( hKey, szIsInstalled, NULL, NULL, (LPBYTE)&dwValue, &dwSize) != ERROR_SUCCESS)
        {
            dwValue = 0;
        }
        fIsInstalled = (dwValue != 0);
        if (fIsInstalled)
        {
            dwSize = sizeof(szVersion);
            if ( (lResult = RegQueryValueEx(hKey, szActVersion, NULL, &dwType, (LPBYTE)szVersion, &dwSize)) == ERROR_SUCCESS )
            {
                if (dwType == REG_SZ)
                {
                    if ( SUCCEEDED(GetVersionFromString(szVersion, &dwCurMS, &dwCurLS)))
                    {
                        m_distunitinst.dwInstalledVersionMS = dwCurMS;
                        m_distunitinst.dwInstalledVersionLS = dwCurLS;

                        if (dwCurMS > dwVersionMS ||
                         (dwCurMS == dwVersionMS && dwCurLS >= dwVersionLS)) {
                            hr = S_OK;
                        } else {
                            hr = S_FALSE;
                        }

                    }
                }
                else
                {
                    dwSize = 4 * sizeof(WORD);
                    if ( (lResult = RegQueryValueEx(hKey, szActVersion, NULL, NULL, (LPBYTE)wVersion, &dwSize)) == ERROR_SUCCESS )
                    {
                        // The registry version number is saved hi-word MS lo-word MS hi-word LS lo-word LS
                        // therefore we need to put the data manualy into the DWORDs
                        dwCurMS = (DWORD)wVersion[0] << 16;    // Make hi word of MS version
                        dwCurMS += (DWORD)wVersion[1];         // Make lo word of MS version
                        dwCurLS = (DWORD)wVersion[2] << 16;    // Make hi word of LS version
                        dwCurLS += (DWORD)wVersion[3];         // Make lo word of LS version
                        if (dwCurMS > dwVersionMS ||
                         (dwCurMS == dwVersionMS && dwCurLS >= dwVersionLS)) {
                            hr = S_OK;
                        } else {
                            hr = S_FALSE;
                        }

                    }
                    else
                        hr = HRESULT_FROM_WIN32(lResult);
                }
            }
            // If "Version" doesn't exist we assume its been advertised
            // but not locally installed.

        }
    }

Exit:

    if (bAllocedKey)
    {
    	delete [] pszKey;
    }
    
    SAFEREGCLOSEKEY(hKey);
    SAFEDELETE(pszDist);
    
    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT CSoftDist::ActSetupAdvertise(BOOL bFullAdvt)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSoftDist::ActSetupAdvertise",
                "this=%#x, %B",
                this, bFullAdvt
                ));

    LPSTR  pszKey = NULL;
    BOOL   bAllocedKey = FALSE;
    int        nKey;

    char    szKey[2*MAX_PATH];
    HKEY    hKey;
    HRESULT hr = S_OK;
    LPSTR   pszDist = NULL;
    LONG    lResult = ERROR_SUCCESS;
    static const char            *szPrecache = "Precache";

    if (FAILED((hr=::Unicode2Ansi(m_szDistUnit, &pszDist))))
    {
        goto Exit;
    }

    ULONG ulenDist = lstrlenA(pszDist);
    //sizeof counts terminating NULL also, so subtract 2, and add 1 for the final NULL
    ULONG ulenConst = sizeof(REGKEY_ACTIVESETUP_COMPONENTS)/sizeof(CHAR) + sizeof("\\")/sizeof(CHAR) - 2 + 1;
    
    if ((ulenDist+ulenConst)  > sizeof(szKey))
    {
    	pszKey = new CHAR[ulenDist+ulenConst];
    }

    if (pszKey)
    {
    	bAllocedKey = TRUE;
    	nKey = ulenDist + ulenConst;
    }
    else
    {
    	pszKey = szKey;
    	nKey = sizeof(szKey);
    }

    StrNCpy(pszKey, REGKEY_ACTIVESETUP_COMPONENTS, nKey);
    StrCatBuff(pszKey, "\\", nKey);
    StrCatBuff(pszKey, pszDist, nKey);

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, pszKey, 0, NULL, REG_OPTION_NON_VOLATILE, 
                    KEY_READ|KEY_SET_VALUE, NULL, &hKey, NULL) == ERROR_SUCCESS)
    {
        DWORD dwAdStateInit = SOFTDIST_ADSTATE_NONE;

        // Note Version
        wsprintf(pszKey, "%d,%d,%d,%d",
                (m_dwVersionMS & 0xffff0000)>>16,
                (m_dwVersionMS & 0xffff),
                (m_dwVersionLS & 0xffff0000)>>16,
                (m_dwVersionLS & 0xffff));
        lResult = ::RegSetValueEx(hKey, REGVAL_VERSION_AVAILABLE, NULL, REG_SZ, 
                            (unsigned char *)pszKey, lstrlen(pszKey)+1);

        if (bFullAdvt || IsAbstractDifferent(hKey, m_szAbstract)) {
                // (re)set the ad state
                lResult = ::RegSetValueEx(hKey, REGVAL_ADSTATE, NULL, REG_DWORD, 
                                (unsigned char *)&dwAdStateInit, sizeof(DWORD) );


            if( (lResult == ERROR_SUCCESS) && m_szTitle)
                lResult=RegSetValueEx(hKey,REGVAL_TITLE_AVAILABLE, NULL, REG_SZ, 
                            (unsigned char *)m_szTitle, lstrlen(m_szTitle)+1);

            if( (lResult == ERROR_SUCCESS) && m_szAbstract)
                lResult=RegSetValueEx(hKey,REGVAL_ABSTRACT_AVAILABLE, NULL,
                            REG_SZ, (unsigned char *)m_szAbstract, lstrlen(m_szAbstract)+1);

            if( (lResult == ERROR_SUCCESS) && m_szHREF) {
                //
                // Check if this is the IE4 GUID. If so, change IE's
                // First Home Page to point to this HREF.
    /*
                // This is no longer being used because we pop up a dialog instead

                if (lstrcmpi(pszDist, DISTUNIT_NAME_IE4) == 0) {
                    HKEY hKeyIE = 0;
                    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_IE_MAIN, 0, KEY_SET_VALUE, &hKeyIE) == ERROR_SUCCESS) {

                        RegSetValueEx(hKeyIE,REGVAL_FIRST_HOME_PAGE, NULL,
                            REG_SZ, (unsigned char *)m_szHREF, lstrlen(m_szHREF)+1);
                        RegCloseKey(hKeyIE);
                    }
                }
    */

                lResult =RegSetValueEx(hKey,REGVAL_HREF_AVAILABLE, NULL, REG_SZ, 
                                (unsigned char *)m_szHREF, lstrlen(m_szHREF)+1);
            }

        }

        if (lResult != ERROR_SUCCESS) 
        {
            hr = HRESULT_FROM_WIN32(lResult);
        }

        // new advertisement, remove old precache
        if (bFullAdvt)
            ::RegDeleteValue(hKey, szPrecache);

        RegCloseKey(hKey);

    }

Exit:

    if (bAllocedKey)
    {
    	 delete [] pszKey;
    }

    SAFEDELETE(pszDist);
    
    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT CSoftDist::IsActSetupAdvertised(LPBOOL lpfIsPrecached, LPBOOL lpfIsAuthorized)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSoftDist::IsActSetupAdvertised",
                "this=%#x, %#x, %#x",
                this, lpfIsPrecached, lpfIsAuthorized
                ));
                
    HKEY    hKey;

    LPSTR pszTmp = NULL;
    BOOL  bAllocedTmp = FALSE;
    int       nTmp;
    
    char    szTmp[2*MAX_PATH];
    DWORD   dwSize;
    DWORD   dwCurAdvMS = 0;
    DWORD   dwCurAdvLS = 0;
    HRESULT hr = S_FALSE, hr2;
    LPSTR   pszDist = NULL;
    LONG    lResult = ERROR_SUCCESS;
    
    const static char * szPrecache = "Precache";

    ASSERT(lpfIsPrecached && lpfIsAuthorized);
    if (!lpfIsPrecached || !lpfIsAuthorized) {
        hr = E_INVALIDARG;
        goto Exit;
    }

    *lpfIsPrecached = FALSE;
    *lpfIsAuthorized = TRUE;

    if (FAILED((hr2=::Unicode2Ansi(m_szDistUnit, &pszDist))))
    {
        hr = hr2;
        goto Exit;
    }

    hr = S_FALSE;   // reset: assume not advertised

    ULONG ulenDist = lstrlenA(pszDist);
    //sizeof counts terminating NULL also, so subtract 2, and add 1 for the final NULL
    ULONG ulenConst = sizeof(REGKEY_ACTIVESETUP_COMPONENTS)/sizeof(CHAR) + sizeof("\\")/sizeof(CHAR) - 2 + 1;
    
    if ((ulenDist+ulenConst)  > sizeof(szTmp))
    {
    	pszTmp = new CHAR[ulenDist+ulenConst];
    }

    if (pszTmp)
    {
    	bAllocedTmp = TRUE;
    	nTmp = ulenDist + ulenConst;
    }
    else
    {
    	pszTmp = szTmp;
    	nTmp = sizeof(szTmp);
    }

    StrNCpy(pszTmp, REGKEY_ACTIVESETUP_COMPONENTS, nTmp);
    StrCatBuff(pszTmp, "\\", nTmp);
    StrCatBuff(pszTmp, pszDist, nTmp);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszTmp, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        *lpfIsAuthorized = IsAuthorizedCDF(hKey);

        dwSize = sizeof(szTmp);
        if (RegQueryValueEx( hKey, REGVAL_VERSION_AVAILABLE, NULL, NULL, (LPBYTE)szTmp, &dwSize) == ERROR_SUCCESS)
        {
            DWORD Size;
            DWORD dwType;
            char  szVersionAdvertised[MAX_PATH];
            DWORD SizeDword = sizeof(DWORD);

            // check for precache registry key
            if (RegQueryValueEx(hKey, szPrecache, 0, &dwType, 
                (unsigned char *)&lResult, &SizeDword) == ERROR_SUCCESS) {

                // check for success or common error conditions which indicate we have bits.
                if (SUCCEEDED(lResult)) {
                    *lpfIsPrecached = TRUE;
                } else {
                    *lpfIsPrecached = FALSE;
                }

            }
            
            dwSize = sizeof(szVersionAdvertised);
            m_dwVersionAdvertisedMS = 0;
            m_dwVersionAdvertisedLS = 0;
            // read in the advertised version, if any
            if (RegQueryValueEx( hKey, REGVAL_VERSION_ADVERTISED, NULL, NULL,
                                 (LPBYTE)szVersionAdvertised, &dwSize) == ERROR_SUCCESS)
            {
                if ( SUCCEEDED(GetVersionFromString(szTmp, &dwCurAdvMS, &dwCurAdvLS)))
                {
                    m_dwVersionAdvertisedMS = dwCurAdvMS;
                    m_dwVersionAdvertisedLS = dwCurAdvLS;
                }
                SizeDword = sizeof(DWORD);
                RegQueryValueEx( hKey, REGVAL_ADSTATE, NULL, NULL, (LPBYTE)&m_dwAdState, &SizeDword);
            }

            dwCurAdvMS = 0;
            dwCurAdvLS = 0;

            // save away the advt info like Title, href, abstract
            // if called from GetDistributionUnitAdvt()
            if (!m_szHREF) {
                if (RegQueryValueEx(hKey, REGVAL_HREF_AVAILABLE, NULL, &dwType, 
                    NULL, &Size) == ERROR_SUCCESS) {

                    m_szHREF = new char[Size];

                    if (!m_szHREF) {
                        hr = E_OUTOFMEMORY;
                        goto Exit;
                    }
                    if (RegQueryValueEx(hKey, REGVAL_HREF_AVAILABLE, NULL, &dwType, 
                        (unsigned char *)m_szHREF, &Size) != ERROR_SUCCESS) {

                        hr = HRESULT_FROM_WIN32(GetLastError());
                        goto Exit;
                    }

                }
            }
            if (!m_szTitle) {
                if (RegQueryValueEx(hKey, REGVAL_TITLE_AVAILABLE, NULL, &dwType, 
                    NULL, &Size) == ERROR_SUCCESS) {

                    m_szTitle = new char[Size];

                    if (!m_szTitle) {
                        hr = E_OUTOFMEMORY;
                        goto Exit;
                    }
                    if (RegQueryValueEx(hKey, REGVAL_TITLE_AVAILABLE, NULL, &dwType, 
                        (unsigned char *)m_szTitle, &Size) != ERROR_SUCCESS) {

                        hr = HRESULT_FROM_WIN32(GetLastError());
                        goto Exit;
                    }

                }
            }
            if (!m_szAbstract) {
                if (RegQueryValueEx(hKey, REGVAL_ABSTRACT_AVAILABLE, NULL, &dwType, 
                    NULL, &Size) == ERROR_SUCCESS) {

                    m_szAbstract = new char[Size];

                    if (!m_szAbstract) {
                        hr = E_OUTOFMEMORY;
                        goto Exit;
                    }
                    if (RegQueryValueEx(hKey, REGVAL_ABSTRACT_AVAILABLE, NULL, &dwType, 
                        (unsigned char *)m_szAbstract, &Size) != ERROR_SUCCESS) {

                        hr = HRESULT_FROM_WIN32(GetLastError());
                        goto Exit;
                    }

                }
            }
            // If we have a Version available, we are done.
            if ( SUCCEEDED(GetVersionFromString(szTmp, &dwCurAdvMS, &dwCurAdvLS)))
            {
                if (!(m_dwVersionMS|m_dwVersionLS)) {
                    m_dwVersionMS = dwCurAdvMS;
                    m_dwVersionLS = dwCurAdvLS;
                }   

                if (IsCDFNewerVersion(dwCurAdvMS, dwCurAdvLS)) {
                    hr = S_FALSE;
                } else {
                    hr = S_OK;
                }
            }
        }
    }
Exit:

    if (bAllocedTmp)
    {
    	delete [] pszTmp;
    }
    
    SAFEDELETE(pszDist);
    
    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT
CSoftDist::GetSoftwareUpdateInfo( LPCWSTR szDistUnit, LPSOFTDISTINFO psdi )
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSoftDist::GetSoftwareUpdateInfo",
                "this=%#x, %.80wq, %#x",
                this, szDistUnit, psdi
                ));
                
    HRESULT hr = S_OK;
    DWORD dwStyle = STYLE_MSICD;
    BOOL bIsPrecached = FALSE;
    BOOL bIsAuthorized = FALSE;

    if ( psdi != NULL )
    {
        psdi->szTitle = NULL;
        psdi->szAbstract = NULL;
        psdi->szHREF = NULL;
    }

    hr = PrepSoftwareUpdate( szDistUnit, &dwStyle );
    if ( FAILED(hr) )
        goto Exit;

    if (dwStyle == STYLE_MSICD) {
        hr = IsICDAdvertised(&bIsPrecached, &bIsAuthorized);
    } else if (dwStyle == STYLE_LOGO3) {
        hr = IsLogo3Advertised(&bIsPrecached, &bIsAuthorized);
    } else {
        hr = IsActSetupAdvertised(&bIsPrecached, &bIsAuthorized);
    }

    if ( hr == S_OK ) {
        BOOL bUpdateIsNewer = IsCDFNewerVersion(m_distunitinst.dwInstalledVersionMS, m_distunitinst.dwInstalledVersionLS);
 
        if ( psdi != NULL )
        {
            psdi->dwFlags = 0;
            psdi->dwInstalledVersionMS = m_distunitinst.dwInstalledVersionMS;
            psdi->dwInstalledVersionLS = m_distunitinst.dwInstalledVersionLS;
            psdi->dwUpdateVersionMS = m_dwVersionMS;
            psdi->dwUpdateVersionLS = m_dwVersionLS;
            psdi->dwAdvertisedVersionMS = m_dwVersionAdvertisedMS;
            psdi->dwAdvertisedVersionLS = m_dwVersionAdvertisedLS;
            psdi->dwAdState = m_dwAdState;
            // conjure up the flags
            // Note: we never set the e-mail flag.
            if ( bIsPrecached )
                psdi->dwFlags |= SOFTDIST_FLAG_USAGE_PRECACHE;

            // REVIEW: Is this true?
            // If we're precached and the update version matches the installed version,
            // then we've already auto-installed, or close enough for the purposes of
            // advertisement.
            if ( psdi->dwInstalledVersionMS == psdi->dwUpdateVersionMS &&
                 psdi->dwInstalledVersionLS == psdi->dwUpdateVersionLS )
                psdi->dwFlags |= SOFTDIST_FLAG_USAGE_AUTOINSTALL;

            if (m_szTitle)
            {
                hr = Ansi2Unicode( m_szTitle, &psdi->szTitle );
                if (FAILED(hr))
                    goto Exit;
            }
    
            if (m_szAbstract)
            {
                hr = Ansi2Unicode( m_szAbstract, &psdi->szAbstract );
                if (FAILED(hr))
                    goto Exit;
            }
    
            if (m_szHREF)
            {
                hr = Ansi2Unicode( m_szHREF,  &psdi->szHREF );
                if (FAILED(hr))
                    goto Exit;
            }
        } // if caller wants SOFTDISTINFO

        if ( bUpdateIsNewer )
            hr = S_OK;
        else
            hr = S_FALSE;
    }
    else
    {
        // return at least the current version in this situation
        if ( psdi != NULL )
        {
            psdi->dwFlags = 0;
            psdi->dwInstalledVersionMS = m_distunitinst.dwInstalledVersionMS;
            psdi->dwInstalledVersionLS = m_distunitinst.dwInstalledVersionLS;
            psdi->dwUpdateVersionMS = 0;
            psdi->dwUpdateVersionLS = 0;
            psdi->dwAdvertisedVersionMS = 0;
            psdi->dwAdvertisedVersionLS = 0;
            psdi->dwAdState = 0;
        }

        hr = E_INVALIDARG; // szDistUnit has no advertising data, not subscribed?
    // BUGBUG: we want to be able to populate the SOFTDISTINFO before the first 
    //         advertised update, but this class won't scoop up the necessary goo
    //         prior.

    }

Exit:

    if ( FAILED(hr) && psdi != NULL )
    {
        SAFEDELETE(psdi->szTitle);
        SAFEDELETE(psdi->szAbstract);
        SAFEDELETE(psdi->szHREF);
    }
    
    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT
CSoftDist::SetSoftwareUpdateAdvertisementState( LPCWSTR szDistUnit,
                                                 DWORD dwAdState,
                                                 DWORD dwAdvertisedVersionMS,
                                                 DWORD dwAdvertisedVersionLS )
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSoftDist::SetSoftwareUpdateAdvertisementState",
                "this=%#x, %.80wq, %#x, %#x, %#x",
                this, szDistUnit, dwAdState, dwAdvertisedVersionMS, dwAdvertisedVersionLS
                ));
                
    HRESULT hr = S_OK;
    DWORD dwStyle;
    TCHAR *pszDU = NULL;

    hr = Unicode2Ansi( szDistUnit, &pszDU );

    // code around assumes that MAX_PATH is MAX size of dist unit
    // we try to make a key name with the distunit and that limit is
    // now MAX_PATH. Hence the reasoning to limit this to MAX_PATH
    if (FAILED(hr) || (lstrlenW(szDistUnit) > MAX_PATH)) {
        if (SUCCEEDED(hr)) {
            hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
        }
        goto Exit;
    }


    // BUFFER OVERRUN : limit size in of distunit
    hr = PrepSoftwareUpdate( szDistUnit, &dwStyle );

    if ( SUCCEEDED(hr) )
    {
        if (dwStyle == STYLE_MSICD)
        {
            LONG lResult = ERROR_SUCCESS;
            HKEY hkeyDist =0;
            HKEY hkeyThisDist = 0;
            HKEY hkeyAdvertisedVersion = 0;

            char szTmp[2*MAX_PATH];
            wnsprintf( szTmp, sizeof(szTmp)-1, "%s\\%s\\%s", REGSTR_PATH_DIST_UNITS, pszDU, REGKEY_MSICD_ADVERTISED_VERSION );

            if (RegCreateKey(HKEY_LOCAL_MACHINE, szTmp, &hkeyAdvertisedVersion) == ERROR_SUCCESS)
            {
                // Note Version
                wsprintf(szTmp, "%d,%d,%d,%d",
                        (dwAdvertisedVersionMS & 0xffff0000)>>16,
                        (dwAdvertisedVersionMS & 0xffff),
                        (dwAdvertisedVersionLS & 0xffff0000)>>16,
                        (dwAdvertisedVersionLS & 0xffff));
                lResult = ::RegSetValueEx(hkeyAdvertisedVersion, NULL, NULL, REG_SZ, 
                                    (unsigned char *)szTmp, lstrlen(szTmp)+1);
                if ( lResult == ERROR_SUCCESS )
                {
                    lResult = ::RegSetValueEx(hkeyAdvertisedVersion, REGVAL_ADSTATE, NULL, REG_DWORD, 
                                              (unsigned char *)&dwAdState, sizeof(DWORD) );
                    if ( lResult != ERROR_SUCCESS )
                        hr = HRESULT_FROM_WIN32( lResult );
                }
                else
                    hr = HRESULT_FROM_WIN32( lResult );

                RegCloseKey( hkeyAdvertisedVersion );
            }
        }
        else if (dwStyle == STYLE_LOGO3)
        {
            LONG lResult = ERROR_SUCCESS;
            HKEY hkeyDist =0;
            HKEY hkeyThisDist = 0;
            HKEY hkeyAvailableVersion = 0;

            char szTmp[2*MAX_PATH];
            wnsprintf( szTmp, sizeof(szTmp)-1, "%s\\%s\\%s", REGSTR_PATH_LOGO3_SETTINGS, pszDU, REGKEY_LOGO3_AVAILABLE_VERSION );

            if (RegCreateKey(HKEY_LOCAL_MACHINE, szTmp, &hkeyAvailableVersion) == ERROR_SUCCESS)
            {
                // Note Version
                wsprintf(szTmp, "%d,%d,%d,%d",
                        (dwAdvertisedVersionMS & 0xffff0000)>>16,
                        (dwAdvertisedVersionMS & 0xffff),
                        (dwAdvertisedVersionLS & 0xffff0000)>>16,
                        (dwAdvertisedVersionLS & 0xffff));
                lResult = ::RegSetValueEx(hkeyAvailableVersion, REGSTR_LOGO3_ADVERTISED_VERSION, NULL, REG_SZ,
                                    (unsigned char *)szTmp, lstrlen(szTmp)+1);
                if ( lResult == ERROR_SUCCESS )
                {
                    lResult = ::RegSetValueEx(hkeyAvailableVersion, REGVAL_ADSTATE, NULL, REG_DWORD,
                                              (unsigned char *)&dwAdState, sizeof(DWORD) );
                    if ( lResult != ERROR_SUCCESS )
                        hr = HRESULT_FROM_WIN32( lResult );
                }
                else
                    hr = HRESULT_FROM_WIN32( lResult );

                RegCloseKey( hkeyAvailableVersion );
            }
        }
        else
        {
            LPSTR    pszKey = NULL;
            BOOL     bAllocedKey = FALSE;
            int         nKey;
            
            CHAR   szKey[2*MAX_PATH];  
            HKEY    hKey;
            LONG    lResult = ERROR_SUCCESS;

	    ULONG ulenDist = lstrlenA(pszDU);
	    //sizeof counts terminating NULL also, so subtract 2, and add 1 for the final NULL
	    ULONG ulenConst = sizeof(REGKEY_ACTIVESETUP_COMPONENTS)/sizeof(CHAR) + sizeof("\\")/sizeof(CHAR) - 2 + 1;
	    
	    if ((ulenDist+ulenConst)  > sizeof(szKey))
	    {
	    	pszKey = new CHAR[ulenDist+ulenConst];
	    }

	    if (pszKey)
	    {
	    	bAllocedKey = TRUE;
	    	nKey = ulenDist + ulenConst;
	    }
	    else
	    {
	    	pszKey = szKey;
	    	nKey = sizeof(szKey);
	    }

            StrNCpy(pszKey, REGKEY_ACTIVESETUP_COMPONENTS, nKey);
            StrCatBuff(pszKey, "\\", nKey);
            StrCatBuff(pszKey, pszDU, nKey);
            if (RegOpenKeyEx( HKEY_LOCAL_MACHINE, pszKey, 0, KEY_WRITE , &hKey ) == ERROR_SUCCESS)
            {
                // Note Version
                wsprintf(pszKey, "%d,%d,%d,%d",
                        (dwAdvertisedVersionMS & 0xffff0000)>>16,
                        (dwAdvertisedVersionMS & 0xffff),
                        (dwAdvertisedVersionLS & 0xffff0000)>>16,
                        (dwAdvertisedVersionLS & 0xffff));
                lResult = ::RegSetValueEx(hKey, REGVAL_VERSION_ADVERTISED, NULL, REG_SZ, 
                                    (unsigned char *)pszKey, lstrlen(pszKey)+1);
                if ( lResult == ERROR_SUCCESS )
                {
                    lResult = ::RegSetValueEx(hKey, REGVAL_ADSTATE, NULL, REG_DWORD, 
                                              (unsigned char *)&dwAdState, sizeof(DWORD) );
                    if ( lResult != ERROR_SUCCESS )
                        hr = HRESULT_FROM_WIN32( lResult );
                }
                else
                    hr = HRESULT_FROM_WIN32( lResult );

                RegCloseKey( hKey );
            }

            if (bAllocedKey)
            {
            	delete [] pszKey;
            }
        }
    }

Exit:

    SAFEDELETE(pszDU);

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT
CSoftDist::PrepSoftwareUpdate( LPCWSTR szDistUnit, DWORD *pdwStyle )
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSoftDist::PrepSoftwareUpdate",
                "this=%#x, %.80wq, %#x",
                this, szDistUnit, pdwStyle
                ));
                
    HRESULT hr = S_OK;
    *pdwStyle = STYLE_MSICD;

    hr = CDLDupWStr( &m_szDistUnit, szDistUnit );
    if ( FAILED(hr) )
        goto Exit;

    hr = IsICDLocallyInstalled(m_szDistUnit, m_dwVersionMS, m_dwVersionLS, m_szLanguages);
    if (FAILED(hr))
        goto Exit;

    if (!IsAnyInstalled()) {

        hr = IsActSetupLocallyInstalled(m_szDistUnit, m_dwVersionMS, m_dwVersionLS, m_szLanguages);
        if (FAILED(hr))
        {
            goto Exit;
        }
        else if (hr == S_OK)
        {
            *pdwStyle = STYLE_ACTIVE_SETUP;
            goto Exit;
        }

        if (!IsAnyInstalled()) {
            hr = IsLogo3LocallyInstalled(m_szDistUnit, m_dwVersionMS, m_dwVersionLS, m_szLanguages);

            if (FAILED(hr))
            {
                if (!IsAnyInstalled()) {
                    // some prev version must be installed for this to succeed
                    hr = HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND);
                    goto Exit;
                }
            }
            else if (hr == S_OK)
            {
                *pdwStyle = STYLE_LOGO3;
            }
        }

    }

Exit:
    
    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CSoftDist::Logo3DownloadNext()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSoftDist::Logo3DownloadNext",
                "this=%#x",
                this
                ));
                
    HRESULT                        hr = S_FALSE;
    FILETIME                       ftExpireTime;
    FILETIME                       ftTime;
    LPWSTR                         wszCodeBase = NULL;
    LPSTR                          szDownloadedCodeBase = NULL;
    LPSTR                          szMainCodeBase = NULL;
    LPSTR                          szDownloadedFile = NULL;
    LPSTR                          pszExtn = NULL;
    DWORD                          dwSize = 0;
    DWORD                          dwBytes;
    CCodeBaseHold                 *pcbhPrev = NULL;
    CCodeBaseHold                 *pcbhCur = NULL;
    LISTPOSITION                   lpos = 0, lposOld = 0;
    BOOL                           bFound = FALSE;
    BOOL                           bFakeCacheEntry;
    TCHAR                          achFileName[MAX_PATH];
    LPINTERNET_CACHE_ENTRY_INFO    lpCacheEntryInfo = NULL;
    char                           achBuffer[MAX_CACHE_ENTRY_INFO_SIZE];
    
    pcbhPrev = m_cbh.GetAt(m_curPos);
    Assert(pcbhPrev);

    if (FAILED(hr = Unicode2Ansi(pcbhPrev->wszCodeBase, &szDownloadedCodeBase))) {
        goto Exit;
    }


    lpCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)achBuffer;
    dwSize = MAX_CACHE_ENTRY_INFO_SIZE;
    if (!GetUrlCacheEntryInfo(szDownloadedCodeBase, lpCacheEntryInfo, &dwSize)) {
        // this should never happen
        hr = E_FAIL;
        goto Exit;
    }

    szDownloadedFile = new char[lstrlen(lpCacheEntryInfo->lpszLocalFileName) + 1];
    if (szDownloadedFile == NULL) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    lstrcpy(szDownloadedFile, lpCacheEntryInfo->lpszLocalFileName);

    GetSystemTimeAsFileTime(&ftTime);
    ftExpireTime.dwLowDateTime = (DWORD)0;
    ftExpireTime.dwHighDateTime = (DWORD)0;

    // Mark all CCodeBaseHold's with same group as downloaded and find
    // main codebase

    bFakeCacheEntry = TRUE;
    szMainCodeBase = NULL;
    lpos = m_cbh.GetHeadPosition();
    while (lpos) {
        pcbhCur = m_cbh.GetNext(lpos);

        if (pcbhCur->dwFlags & CBH_FLAGS_MAIN_CODEBASE) {
            Assert(szMainCodeBase == NULL); // we should only get here once
            if (FAILED(Unicode2Ansi(pcbhCur->wszCodeBase, &szMainCodeBase))) {
                hr = E_FAIL;
                goto Exit;
            }
            if (pcbhCur == pcbhPrev || StrCmpW(pcbhCur->wszDLGroup, pcbhPrev->wszDLGroup)) {
                bFakeCacheEntry = FALSE;
            }
        }
        
        if (pcbhCur == pcbhPrev) {
            continue;
        }
        if (!StrCmpW(pcbhPrev->wszDLGroup, pcbhCur->wszDLGroup)) {
            pcbhCur->dwFlags |= CBH_FLAGS_DOWNLOADED;
        }
    }

    // Fake a cache entry for this
    if (bFakeCacheEntry) {
        Assert(szMainCodeBase != NULL);

        lpCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)achBuffer;
        dwSize = MAX_CACHE_ENTRY_INFO_SIZE;
        if (!GetUrlCacheEntryInfo(szMainCodeBase, lpCacheEntryInfo, &dwSize)) {
            pszExtn = PathFindExtension(szMainCodeBase) + 1;
            if (CreateUrlCacheEntry((LPCSTR)szMainCodeBase, 0, pszExtn,
                                    achFileName, 0)) {
                CopyFile(szDownloadedFile, achFileName, FALSE);
                CommitUrlCacheEntry(szMainCodeBase, achFileName, ftExpireTime,
                                    ftTime, NORMAL_CACHE_ENTRY, NULL, 0,
                                    pszExtn, szDownloadedCodeBase);
            }
        }
    }

    // Iterate list until we get a new group

    pcbhCur = NULL;
    lpos = m_cbh.GetHeadPosition();
    while (lpos) {
        lposOld = lpos;
        pcbhCur = m_cbh.GetNext(lpos);

        if (!(pcbhCur->dwFlags & CBH_FLAGS_DOWNLOADED)) {
            m_curPos = lposOld;
            bFound = TRUE;
            pcbhCur->dwFlags |= CBH_FLAGS_DOWNLOADED;
            hr = CDLDupWStr(&wszCodeBase, pcbhCur->wszCodeBase);
            break;
        }
    }

    hr = (bFound) ? (Logo3Download(wszCodeBase)) : (S_FALSE);

Exit:

    SAFEDELETE(szDownloadedCodeBase);
    SAFEDELETE(szDownloadedFile);
    SAFEDELETE(szMainCodeBase);
    
    DEBUG_LEAVE(hr);
    return hr;    
}

STDMETHODIMP CSoftDist::Logo3DownloadRedundant()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSoftDist::Logo3DownloadRedundant",
                "this=%#x",
                this
                ));
                
    HRESULT                        hr = S_FALSE;
    LPWSTR                         szCodeBase = NULL;
    DWORD                          dwSize = 0;
    CCodeBaseHold                 *pcbhPrev = NULL;
    CCodeBaseHold                 *pcbhCur = NULL;
    LISTPOSITION                   lpos = 0, lposOld = 0;
    BOOL                           bFound = FALSE;
    
    pcbhPrev = m_cbh.GetAt(m_curPos);
    Assert(pcbhPrev);

    // Find first undownloaded codebase of the same group

    lpos = m_cbh.GetHeadPosition();
    while (lpos) {
        lposOld = lpos;
        pcbhCur = m_cbh.GetNext(lpos);
        if (!(pcbhCur->dwFlags & CBH_FLAGS_DOWNLOADED) &&
            !StrCmpW(pcbhCur->wszDLGroup, pcbhPrev->wszDLGroup)) {
            bFound = TRUE;
            m_curPos = lposOld;
            pcbhCur->dwFlags |= CBH_FLAGS_DOWNLOADED;
            hr = CDLDupWStr(&szCodeBase, pcbhCur->wszCodeBase);
            dwSize = pcbhCur->dwSize;
            break;
        }
    }

    hr = (bFound) ? (Logo3Download(szCodeBase)) : (S_FALSE);
    
    DEBUG_LEAVE(hr);
    return hr;    
}

STDMETHODIMP CSoftDist::Logo3Download(LPWSTR szCodeBase)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CSoftDist::Logo3Download",
                "this=%#x, %.80wq",
                szCodeBase
                ));
                
    HRESULT                   hr = S_OK;
    DWORD                     dwLen = 0;
    char                      achCodeBase[INTERNET_MAX_PATH_LENGTH];
    IMoniker                 *pmk = NULL;
    Logo3CodeDLBSC           *pCDLBSC = NULL;
    IBindCtx                 *pabc = NULL;
    IBindStatusCallback      *pbscOld = NULL;
    IUnknown                 *pUnk = NULL;

    hr = CreateURLMoniker(NULL, szCodeBase, &pmk);
    if (SUCCEEDED(hr))
    {
        dwLen = INTERNET_MAX_PATH_LENGTH;
        WideCharToMultiByte(CP_ACP, 0, szCodeBase , -1, achCodeBase,
                            dwLen, NULL, NULL);

        Assert(m_pClientBSC);

        pCDLBSC = new Logo3CodeDLBSC(this, m_pClientBSC, achCodeBase,
                                     m_szDistUnit);
    if (pCDLBSC == NULL)
        {
            hr = E_OUTOFMEMORY;
            SAFERELEASE(pmk);
            m_pClientBSC->Release();
            goto Exit;
        }
        

        hr = CreateBindCtx(0, &pabc);
        if (SUCCEEDED(hr))
        {
            hr = RegisterBindStatusCallback(pabc, pCDLBSC, &pbscOld, 0);
        }

        if (SUCCEEDED(hr))
        {
            pCDLBSC->SetBindCtx(pabc);
            hr = pmk->BindToStorage(pabc, NULL, IID_IUnknown, (void **)&pUnk);
            if (FAILED(hr) && hr != E_PENDING)
            {
                RevokeBindStatusCallback(pabc, pCDLBSC);
            }
        }

        if (pUnk) {
            pUnk->Release();
        }
    }
    
Exit:

    SAFERELEASE(pCDLBSC);
    SAFERELEASE(pabc);
    SAFERELEASE(pbscOld);
    SAFERELEASE(pmk);
    
    DEBUG_LEAVE(hr);
    return hr;
}

// Replace the ';' separator with '\0' and count the number of languages in the string.
void PrepareLanguage(LPSTR lpLang)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "PrepareLanguage",
                "%.80q",
                lpLang
                ));
                
    LPSTR lpTmp;
    int index = 0;

    if (lpLang)
    {
        index = 1;
        lpTmp = lpLang;
        while (*lpTmp)
        {
            if (*lpTmp == ';')
            {
                *lpTmp = '\0';
                index++;
            }
            lpTmp = CharNext(lpTmp);
        }
    }
    
    DEBUG_LEAVE(0);
    return;
}

// Checks if all languages in the semicolon separated list of lpszLang1 are also in lpszLang2
BOOL AreAllLanguagesPresent(LPCSTR lpszLang1, LPCSTR lpszLang2)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Bool,
                "AreAllLanguagesPresent",
                "%.80q, %.80q",
                lpszLang1, lpszLang2
                ));
                
    LPSTR lpLang1 = NULL;
    LPSTR lpLang2 = NULL;
    LPSTR lpTmp1;           // Pointer into lpLang1
    LPSTR lpTmp2;           // pointer into lpLang2
    BOOL  bAllPresent = FALSE;
    BOOL  bFoundOne = TRUE;

    if (lpszLang2 == NULL)      // No language in the CDF, assume all languages are OK
    {
        DEBUG_LEAVE(TRUE);
        return TRUE;
    }
    
    // Make a copy of the language strings
    lpLang1 = new char[lstrlen(lpszLang1) + 2];
    lpLang2 = new char[lstrlen(lpszLang2) + 2];

    if ((lpLang1) && (lpLang2))
    {
        strcpy(lpLang1, lpszLang1);
        strcpy(lpLang2, lpszLang2);
        PrepareLanguage(lpLang1);
        PrepareLanguage(lpLang2);
        lpTmp1 = lpLang1;
        while ((*lpTmp1) && (bFoundOne))
        {
            lpTmp2 = lpLang2;
            bFoundOne = FALSE;
            while ((*lpTmp2) && !bFoundOne)
            {
                bFoundOne = (lstrcmpi(lpTmp1, lpTmp2) == 0);
                lpTmp2 += lstrlen(lpTmp2) + 1;
            }
            lpTmp1 += lstrlen(lpTmp1) + 1;
        }
        bAllPresent = bFoundOne;
    }

    SAFEDELETE(lpLang1);
    SAFEDELETE(lpLang2);
    
    DEBUG_LEAVE(bAllPresent);
    return bAllPresent;
}

STDAPI GetSoftwareUpdateInfo( LPCWSTR szDistUnit, LPSOFTDISTINFO psdi )
{
    DEBUG_ENTER_API((DBG_DOWNLOAD,
                    Hresult,
                    "GetSoftwareUpdateInfo",
                    "%.80wq, %#x",
                    szDistUnit, psdi
                    ));

    HRESULT hr = S_OK;

    if ( psdi == NULL ||
         (psdi->cbSize == sizeof(SOFTDISTINFO) && psdi->dwReserved == 0) )
    {
        CSoftDist *pSoftDist = new CSoftDist();

        if (!pSoftDist) {
            hr = E_OUTOFMEMORY;
            goto Exit;
        }

        hr = pSoftDist->GetSoftwareUpdateInfo(szDistUnit, psdi);

        SAFERELEASE(pSoftDist);

    }
    else
        hr = E_INVALIDARG;

Exit:
    
    DEBUG_LEAVE_API(hr);
    return hr;
}


STDAPI SetSoftwareUpdateAdvertisementState( LPCWSTR szDistUnit,
                                             DWORD dwAdState,
                                             DWORD dwAdvertisedVersionMS,
                                             DWORD dwAdvertisedVersionLS )
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "SetSoftwareUpdateAdvertisementState",
                "%.80wq, %#x, %#x, %#x",
                szDistUnit, dwAdState, dwAdvertisedVersionMS, dwAdvertisedVersionLS
                ));

    HRESULT hr = S_OK;
    CSoftDist *pSoftDist = new CSoftDist();

    if (!pSoftDist) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = pSoftDist->SetSoftwareUpdateAdvertisementState( szDistUnit,
                                                        dwAdState,
                                                        dwAdvertisedVersionMS,
                                                        dwAdvertisedVersionLS );
    SAFERELEASE(pSoftDist);

Exit:
    
    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT GetStyleFromString(LPSTR szStyle, LPDWORD lpdwStyle)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "GetStyleFromString",
                "%.80q, %#x",
                szStyle, lpdwStyle
                ));
                
    HRESULT hr = S_OK;
  
    if (szStyle == NULL || lpdwStyle == NULL) {
        hr = E_INVALIDARG;
    } else if (lstrcmpi(szStyle,DU_STYLE_MSICD) == 0) {
        *lpdwStyle = STYLE_MSICD;
    } else if (lstrcmpi(szStyle,DU_STYLE_ACTIVE_SETUP) == 0) {
        *lpdwStyle = STYLE_ACTIVE_SETUP;
    } else if (lstrcmpi(szStyle,DU_STYLE_MSINSTALL) == 0) {
        *lpdwStyle = STYLE_MSINSTALL;
    } else if (lstrcmpi(szStyle,DU_STYLE_LOGO3) == 0 ) {
        *lpdwStyle = STYLE_LOGO3;
    } else {
        *lpdwStyle = STYLE_UNKNOWN;
        hr = E_UNEXPECTED;
    }
    
    DEBUG_LEAVE(hr);
    return hr;
}

//*******************************************************************************************
// CActiveSetupBinding : Wrapper class to simulate control over client binding operation when
//                       we are actually dealing with an EXE.
//*******************************************************************************************
DWORD WINAPI StartActiveSetup(void *dwArg)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Dword,
                "StartActiveSetup",
                "%#x",
                dwArg
                ));
                
    CActiveSetupBinding *pasb = (CActiveSetupBinding *)dwArg;
    
    ASSERT(pasb);
    pasb->StartActiveSetup();

    // Should never return.
    ASSERT(FALSE);
    
    DEBUG_LEAVE(-1);
    return -1;
}

CActiveSetupBinding::CActiveSetupBinding(IBindCtx *pbc, 
           IBindStatusCallback *pbsc, LPWSTR szCodeBase, 
           LPWSTR szDistUnit, HRESULT *phr)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CActiveSetupBinding::CActiveSetupBinding",
                "this=%#x, %#x, %#x, %.80wq, %.80wq, %#x",
                this, pbc, pbsc, szCodeBase, szDistUnit, phr
                ));
                
    HKEY hkAppPath = NULL;

    ASSERT(pbc);
    ASSERT(pbsc);
    ASSERT(phr);

    *phr = S_OK;
    fSilent = FALSE;
    
    m_pbc = pbc;
    m_pbc->AddRef();
    m_pbsc = pbsc;
    m_pbsc->AddRef();

    m_dwRef = 1;
    m_hWaitThread = NULL;
    memset(&m_piChild, 0, sizeof(m_piChild));

    if (FAILED(Unicode2Ansi(szCodeBase, &m_szCodeBase)))
        goto Exit;
    
    if (FAILED(Unicode2Ansi(szDistUnit, &m_szDistUnit)))
        goto Exit;

    ASSERT(m_szCodeBase);
  
    // Get actsetup.exe path.
    if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, 
                     "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE",
                     0, KEY_READ, &hkAppPath) == ERROR_SUCCESS)  {
    
        long dwSize = MAX_PATH;
        m_szActSetupPath[0] = '\0';

        if (RegQueryValueA(hkAppPath, NULL, (LPSTR)m_szActSetupPath, &dwSize) == ERROR_SUCCESS) {
           
            if ((dwSize <= 1)  || (m_szActSetupPath[0] == '\0'))
                goto Exit;
            
            LPSTR szCur = &m_szActSetupPath[dwSize-2];      // points to last character
            while (szCur>m_szActSetupPath) {
                if (*szCur == '\\')
                    break;
                szCur--;
            }

            *(++szCur) = '\0';      // Prematurely truncate string (chop off IEXPLORE.EXE)

        } else
            goto Exit;
        
    } else 
        goto Exit;
    
    // Create thread to monitor status of Active Setup executable.
    m_hWaitThread = CreateThread(NULL, 0, &(::StartActiveSetup), (LPVOID)this, 0, &dwThreadID);

Exit:
    *phr = (m_hWaitThread != NULL) ? S_OK : E_FAIL;

    SAFEREGCLOSEKEY(hkAppPath);

    DEBUG_LEAVE(0);
}

CActiveSetupBinding::~CActiveSetupBinding() 
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CActiveSetupBinding::~CActiveSetupBinding",
                "this=%#x",
                this
                ));
                
    ASSERT(m_dwRef == 0);

    SAFERELEASE(m_pbsc);
    SAFERELEASE(m_pbc);
    SAFEDELETE(m_szCodeBase);
    SAFEDELETE(m_szDistUnit);

    if (m_hWaitThread)
        CloseHandle(m_hWaitThread);

    if (m_piChild.hProcess)
        CloseHandle(m_piChild.hProcess);
    
    if (m_piChild.hThread)
        CloseHandle(m_piChild.hThread);

    DEBUG_LEAVE(0);
}

void CActiveSetupBinding::StartActiveSetup(void)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CActiveSetupBinding::StartActiveSetup",
                "this=%#x",
                this
                ));
                
    CHAR szCmdLine[2*MAX_PATH];
    STARTUPINFO si;
    DWORD dwResult;
    LPSTR szSite;

    //REVIEW: Change to some other suitable value?
    const DWORD dwTimeOut = 100*60*5;   // every 5 minutes

    memset(&si, 0, sizeof(si));
    si.cb = sizeof(STARTUPINFO);    // ActSetup.Exe can take care of itself.

    BINDINFO bi;
    DWORD dwBindf = 0;
    memset(&bi, 0, sizeof(BINDINFO));
    bi.cbSize = sizeof(BINDINFO);

    m_pbsc->GetBindInfo(&dwBindf, &bi);
    fSilent = (dwBindf & BINDF_SILENTOPERATION) ? TRUE : FALSE;

    szSite = StrChr(m_szCodeBase, ';');
    if (szSite) {
        *szSite = '\0';
        szSite++;
        SetDefaultDownloadSite(szSite);
    }

    // compose the pathname for actsetup.exe and then check for
    // file existence before spawning process
    wnsprintfA(szCmdLine, sizeof(szCmdLine)-1, "%sactsetup.exe", m_szActSetupPath);

    if (GetFileAttributes(szCmdLine) == -1) {
        DoCleanUp(E_NOTIMPL); // auto install or pre download not impl
        delete this;
        goto Exit;
    }

    // Create proper command line

    // /r:n   - no reboot
    // /d     - download only
    // /q     - silent mode (does not require user input)

    wnsprintfA(szCmdLine, sizeof(szCmdLine)-1, "\"%sactsetup.exe\" /J:job.ie4 /r:n /q %s /s:\"%s\" ", 
        m_szActSetupPath, fSilent ? "/d" : "", m_szCodeBase);

    // Use ansi version since Win95 doesn't support unicode version.

    if (!CreateProcessA(NULL,           // lpApplicationName
                  szCmdLine,            // lpCommandLine
                  NULL,                 // lpProcessAttributes
                  NULL,                 // lpThreadAttributes
                  FALSE,                // Inherit Handles
                  0,                    // dwCreationFlags
                  NULL,                 // Environment block (inherit callers)
                  NULL,                 // Current directory
                  &si,                  // STARTUPINFO record
                  &m_piChild)) {        // PROCESSINFOMRATION record

        delete this;
        goto Exit;
    }

    // REVIEW: Localize status messages?  Messages aren't currently used for anything useful.

    if (FAILED(m_pbsc->OnStartBinding(0,(IBinding *)this)))
        goto Exit;

    while ((dwResult = WaitForSingleObject(m_piChild.hProcess, dwTimeOut)) == WAIT_TIMEOUT) {

        (void) m_pbsc->OnProgress(0,0,BINDSTATUS_DOWNLOADINGDATA, L"ActiveSetup Running");

    }
    ASSERT(dwResult == WAIT_OBJECT_O);

    if (GetExitCodeProcess(m_piChild.hProcess, &dwResult)) {

        //REVIEW: Check for partial return codes.

        SaveHresult(dwResult);

        if (SUCCEEDED(dwResult)) {

            (void) m_pbsc->OnStopBinding(S_OK, NULL);
            
        } else {

            DoCleanUp(dwResult);
            goto Exit;

        }
        
    } else {

        // Install failed, abort process.
        DoCleanUp(E_FAIL);
        goto Exit;
    }

    delete this;

Exit:
    //  BINDINFO_FIX(LaszloG) 8/15/96
    ReleaseBindInfo(&bi);

    DEBUG_LEAVE(0);
    ExitThread(-1);
}

STDMETHODIMP CActiveSetupBinding::QueryInterface(REFIID riid,void ** ppv)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CActiveSetupBinding::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppv
                ));
                
    if ((riid == IID_IUnknown) || (riid == IID_IBinding))
    {
        *ppv = (IBinding *) this;
        AddRef();
    
        DEBUG_LEAVE(S_OK);
        return S_OK;
    }
    else
    {
        DEBUG_LEAVE(E_NOINTERFACE);
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG) CActiveSetupBinding::AddRef()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Dword,
                "CActiveSetupBinding::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    ULONG ulRet = m_dwRef++;
    
    DEBUG_LEAVE(ulRet);
    return ulRet;
}

STDMETHODIMP_(ULONG) CActiveSetupBinding::Release()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Dword,
                "CActiveSetupBinding::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    if (--m_dwRef == 0) {
        delete this;
    
        DEBUG_LEAVE(0);
        return 0;
    }

    DEBUG_LEAVE(m_dwRef);
    return m_dwRef;
}

HRESULT CActiveSetupBinding::SetDefaultDownloadSite(LPSTR szSite)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CActiveSetupBinding::SetDefaultDownloadSite",
                "this=%#x, %.80q",
                this, szSite
                ));
                
    HRESULT hr = S_OK;
    const static char * szRegion = "DownloadSiteRegion";
    CHAR szTmp[MAX_PATH];
    DWORD dwSize = 0, dwType = REG_SZ, dwResult;
    HKEY hKey = 0;

    //static known sizes of buffers.
    
    lstrcpy(szTmp, REGKEY_ACTIVESETUP);
    lstrcat(szTmp, "\\Jobs\\Job.IE4");

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTmp, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
    {

        if (RegQueryValueEx(hKey, szRegion, 0, &dwType, NULL, &dwSize) != ERROR_SUCCESS)
        {
            hr = RegSetValueEx(hKey, szRegion, 0, REG_SZ, (LPBYTE)szSite, strlen(szSite));
        }

        ::RegCloseKey(hKey);
    }
    
    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CActiveSetupBinding::Abort(void)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CActiveSetupBinding::IBinding::Abort",
                "this=%#x",
                this
                ));
                
    HRESULT hr = E_FAIL;
    DWORD dwSize, dwResult;
    HKEY hKey = 0;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_ACTIVESETUP, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
    {
        hr = RegSetValueEx(hKey, szControlSetup, 0, REG_DWORD, (LPBYTE)&dwStatusAbort, sizeof(DWORD));
        
        ::RegCloseKey(hKey);
    }

    if (SUCCEEDED(hr) && m_hWaitThread)
    {
        // The child thread will terminate when Active Setup finishes and post message
        // to tray agent to terminate.
    }
    else
    {
        // terminate waiting thread
        TerminateThread(m_hWaitThread, E_ABORT);

        // terminate active setup process
        TerminateProcess(m_piChild.hProcess, E_ABORT);

        DoCleanUp(E_ABORT);
    }
    
    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT CActiveSetupBinding::SaveHresult(HRESULT hrResult)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CActiveSetupBinding::SaveHresult",
                "this=%#x, %#x",
                this, hrResult
                ));
                
    HRESULT hr = S_OK;
    const static char * szPrecache = "Precache";
    HKEY hKey = 0;
    LPSTR pszTmp = NULL;
    BOOL  bAllocedTmp = FALSE;
    int       nTmp;
    CHAR szTmp[2*MAX_PATH];
    DWORD dwSize;
    HWND hwnd = 0;

    ULONG ulenDist = lstrlenA(m_szDistUnit);
    //sizeof counts terminating NULL also, so subtract 2, and add 1 for the final NULL
    ULONG ulenConst = sizeof(REGKEY_ACTIVESETUP_COMPONENTS)/sizeof(CHAR) + sizeof("\\")/sizeof(CHAR) - 2 + 1;
    
    if ((ulenDist+ulenConst)  > sizeof(szTmp))
    {
    	pszTmp = new CHAR[ulenDist+ulenConst];
    }

    if (pszTmp)
    {
    	bAllocedTmp = TRUE;
    	nTmp = ulenDist + ulenConst;
    }
    else
    {
    	pszTmp = szTmp;
    	nTmp = sizeof(szTmp);
    }

    StrNCpy(pszTmp, REGKEY_ACTIVESETUP_COMPONENTS, nTmp);
    StrCatBuff(pszTmp, "\\", nTmp);
    StrCatBuff(pszTmp, m_szDistUnit, nTmp);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszTmp, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
    {
        // if silent mode or autoinstall / failed then record as precache attempt

        if (fSilent || (!fSilent && FAILED(hrResult)))
        {
            // for silent (download only), record precache result
            hr = RegSetValueEx(hKey, szPrecache, 0, REG_DWORD, (LPBYTE)&hrResult, sizeof(HRESULT));
        }
        else
        {
            // for non-silent (autoinstall), kill the precache key
            hr = RegDeleteValue(hKey, szPrecache);
        }

        ::RegCloseKey(hKey);
    }

    // if reboot required, post a message to tray agent message pump if we can find it.
    if (hrResult == ERROR_SUCCESS_REBOOT_REQUIRED)
    {
        hwnd = FindWindow(c_szTrayUI, NULL);
        if (hwnd)
        {
             (void) SendNotifyMessage(hwnd, WM_USER, 0, UM_NEEDREBOOT);
        }
    }

    if (bAllocedTmp)
    {
    	delete [] pszTmp;
    }
    
    DEBUG_LEAVE(hr);
    return hr;
}

void CActiveSetupBinding::DoCleanUp(DWORD dwExitCode)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CActiveSetupBinding::DoCleanUp",
                "this=%#x, %#x",
                this, dwExitCode
                ));
                
    m_pbsc->OnStopBinding(dwExitCode, NULL);

    SAFERELEASE(m_pbsc);
    SAFERELEASE(m_pbc);

    // at this point, BindCtx loses all references, deletes itself and
    // its reference to BindStatusCallback.  BSC loses all references are
    // deletes its reference to us, so we have no more references &
    // this invokes our destructor which cleans up by closing handles,
    // then do returns on stack to calling point.

    // we should be implicitly history at this point.

    DEBUG_LEAVE(0);
}


STDMETHODIMP CActiveSetupBinding::Suspend(void)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CActiveSetupBinding::IBinding::Suspend",
                "this=%#x",
                this
                ));
                
    HRESULT hr = S_OK;
    DWORD dwSize;
    HKEY hKey = 0;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_ACTIVESETUP, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
    {
        hr = RegSetValueEx(hKey, szControlSetup, 0, REG_DWORD, (LPBYTE)&dwStatusSuspend, sizeof(DWORD));

        ::RegCloseKey(hKey);
    }
    
    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CActiveSetupBinding::Resume(void)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CActiveSetupBinding::IBinding::Resume",
                "this=%#x",
                this
                ));
                
    HRESULT hr = S_OK;
    DWORD dwSize;
    HKEY hKey = 0;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGKEY_ACTIVESETUP, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
    {
        hr = RegSetValueEx(hKey, szControlSetup, 0, REG_DWORD, (LPBYTE)&dwStatusResume, sizeof(DWORD));

        ::RegCloseKey(hKey);
    }
    
    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CActiveSetupBinding::SetPriority(LONG nPriority)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CActiveSetupBinding::IBinding::SetPriority",
                "this=%#x, %#x",
                this, nPriority
                ));
    
    DEBUG_LEAVE(E_NOTIMPL);               
    return E_NOTIMPL;
}

STDMETHODIMP CActiveSetupBinding::GetPriority(LONG *pnPriority)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CActiveSetupBinding::IBinding::GetPriority",
                "this=%#x, %#x",
                this, pnPriority
                ));

    DEBUG_LEAVE(E_NOTIMPL);
    return E_NOTIMPL;
}

STDMETHODIMP CActiveSetupBinding::GetBindResult(CLSID *pclsidProtocol, 
                    DWORD *pdwResult, LPWSTR *pszResult,DWORD *pdwReserved)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CActiveSetupBinding::IBinding::GetBindResult",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, pclsidProtocol, pdwResult, pszResult, pdwReserved
                ));
                
    HRESULT hr = NOERROR;

    if (!pdwResult || !pszResult || pdwReserved)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *pdwResult = NOERROR;
        *pszResult = NULL;
    }
    
    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\unixfile.h ===
#ifndef __UNXFILE__
#define __UNXFILE__

#include <windows.h>

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */

void UnixEnsureDir( char* pszFile );
void UnixifyFileName( char* lpszName);

HRESULT CheckIEFeatureOnUnix(LPCWSTR pwszIEFeature, DWORD* dwInstalledVerHi, DWORD* dwInstalledVerLo, DWORD dwFlags);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* __UNXFILE__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\peldr.cxx ===
//  PELDR.CXX kernel32
//
//      (C) Copyright Microsoft Corp., 1988-1994
//
//      Swiped without thanks from the Win32 loader
//

#include <cdlpch.h>

extern int g_CPUType;

HRESULT
GetMachineTypeOfFile(const char *szName, LPDWORD pdwMachine)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "GetMachineTypeOfFile",
                "%.80q, %#x",
                szName, pdwMachine
                ));
                
    IMAGE_DOS_HEADER idh;
    IMAGE_NT_HEADERS nth;
    DWORD       cbT;
    DWORD       size;
    DWORD dwBytesRead = 0;
    HANDLE dfhFile = INVALID_HANDLE_VALUE;
    HRESULT hr = S_OK;

    *pdwMachine = IMAGE_FILE_MACHINE_UNKNOWN;

    if ( (dfhFile = CreateFile(szName, GENERIC_READ, FILE_SHARE_READ,
                    NULL, OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, 0)) == INVALID_HANDLE_VALUE) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    // Read DOS header
    if ((!ReadFile(dfhFile, &idh, sizeof(idh), &dwBytesRead, NULL)) ||
        (idh.e_magic != 0x5a4d)) {

        // not PE file!
        hr = HRESULT_FROM_WIN32(GetLastError());

        if (SUCCEEDED(hr)) {
            // not enough bytes read
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_EXE_SIGNATURE);
        }
        goto Exit;
    }

    // Read PE header
    SetFilePointer (dfhFile, idh.e_lfanew, NULL, FILE_BEGIN);


    if ((!ReadFile(dfhFile, &nth, sizeof(IMAGE_NT_HEADERS), &dwBytesRead, NULL))) {
        hr = HRESULT_FROM_WIN32(GetLastError());

        if (SUCCEEDED(hr)) {
            // not enough bytes read
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_EXE_SIGNATURE);
        }

        goto Exit;
    }

    cbT = dwBytesRead;

    // Valid PE header?
    if ((cbT != sizeof(IMAGE_NT_HEADERS)) || (nth.Signature != 0x00004550)) {

        // not PE file!
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_EXE_SIGNATURE);
        goto Exit;
    }

    *pdwMachine = nth.FileHeader.Machine;

Exit:

    if (dfhFile != INVALID_HANDLE_VALUE)
        CloseHandle(dfhFile);

    DEBUG_LEAVE(hr);
    return hr ;

}

HRESULT
IsCompatibleType(DWORD dwBinaryType)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "IsCompatibleType",
                "%#x",
                dwBinaryType
                ));
                
    int CPUType = PROCESSOR_ARCHITECTURE_UNKNOWN;

    switch (dwBinaryType) {

    case IMAGE_FILE_MACHINE_AMD64:
        
        CPUType = PROCESSOR_ARCHITECTURE_AMD64;
        break;

    case IMAGE_FILE_MACHINE_I386:
        
#ifdef WX86
        if (g_fWx86Present) {
            // Wx86 is installed - I386 images are OK.

            DEBUG_LEAVE(S_OK);
            return S_OK;
        }
#endif
        CPUType = PROCESSOR_ARCHITECTURE_INTEL;
        break;

    case IMAGE_FILE_MACHINE_IA64:

        CPUType = PROCESSOR_ARCHITECTURE_IA64;
        break;
    }

    DEBUG_ENTER((DBG_DOWNLOAD,
        Hresult,
        "IsCompatibleType:comparing",
        "%#x Vs %#x (PROCESSOR_ARCHITECTURE_UNKNOWN)=%#x, (PROCESSOR_ARCHITECTURE_INTEL)=%#x, (IMAGE_FILE_MACHINE_I386)=%#x ",
        g_CPUType, CPUType, PROCESSOR_ARCHITECTURE_UNKNOWN, PROCESSOR_ARCHITECTURE_INTEL, IMAGE_FILE_MACHINE_I386
        ));
                
    HRESULT hr = (g_CPUType == CPUType)?S_OK:HRESULT_FROM_WIN32(ERROR_EXE_MACHINE_TYPE_MISMATCH);

    DEBUG_LEAVE(hr);

    DEBUG_LEAVE(hr);
    return hr;
}

// IsCompatibleFile(const char *szFileName, LPDWORD lpdwMachineType=NULL);
// returns:
//      S_OK: file is compatible install it and LoadLibrary it
//      S_FALSE: file is not a PE
//      ERROR_EXE_MACHINE_TYPE_MISMATCH: not compatible
HRESULT
IsCompatibleFile(const char *szFileName, LPDWORD lpdwMachineType)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "IsCompatibleFile",
                "%.80q, %#x",
                szFileName, lpdwMachineType
                ));
                
    DWORD dwMachine = 0;

    HRESULT hr = GetMachineTypeOfFile(szFileName, &dwMachine);

    if (SUCCEEDED(hr)) {

        hr = IsCompatibleType(dwMachine);

    } else {

        hr = S_FALSE;
    }

    if (lpdwMachineType)
        *lpdwMachineType = dwMachine;

    DEBUG_LEAVE(hr);
    return hr;

}

// IsRegisterableDLL(const char *szFileName)
// returns:
//      S_OK: file is registerable, LoadLibrary and call GetProcAddress
//      S_FALSE: file is not registerable
HRESULT 
IsRegisterableDLL(const char *szFileName)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "IsRegisterableDLL",
                "%.80q",
                szFileName
                ));
                
    HRESULT hr = S_FALSE;

    HINSTANCE hinst = LoadLibraryEx (szFileName, NULL, 
        DONT_RESOLVE_DLL_REFERENCES | LOAD_WITH_ALTERED_SEARCH_PATH);
    if (hinst)
    {
        FARPROC pfn = GetProcAddress (hinst, "DllRegisterServer");
        if (pfn)
            hr = S_OK;
        FreeLibrary (hinst);
    }

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\verp.h ===
#ifdef __cplusplus

// VERSION.DLL delay load

class CVersion
{
    public:
#define DELAYVERAPI(_fn, _args, _nargs) \
    DWORD _fn _args { \
        HRESULT hres = Init(); \
        DWORD dwRet = 0; \
        if (SUCCEEDED(hres)) { \
            dwRet = _pfn##_fn _nargs; \
        } \
        return dwRet;    } \
    DWORD (STDAPICALLTYPE* _pfn##_fn) _args;

    HRESULT     Init(void);
    CVersion();
    ~CVersion();

    BOOL    m_fInited;
    HMODULE m_hMod;

    DELAYVERAPI( VerInstallFileA,
        (DWORD uFlags,
        LPSTR szSrcFileName,
        LPSTR szDestFileName,
        LPSTR szSrcDir,
        LPSTR szDestDir,
        LPSTR szCurDir,
        LPSTR szTmpFile,
        PUINT lpuTmpFileLen),
        (uFlags, szSrcFileName, szDestFileName, szSrcDir, szDestDir,
        szCurDir, szTmpFile, lpuTmpFileLen));


    DELAYVERAPI( VerQueryValueA,
        (const LPVOID pBlock,
        LPSTR lpSubBlock,
        LPVOID * lplpBuffer,
        PUINT puLen),
        (pBlock, lpSubBlock, lplpBuffer, puLen));

    DELAYVERAPI( GetFileVersionInfoA,
        (LPSTR lptstrFilename, 
        DWORD dwHandle,         
        DWORD dwLen,            
        LPVOID lpData),
        (lptstrFilename, dwHandle, dwLen, lpData));                      

    DELAYVERAPI( GetFileVersionInfoSizeA,
        (LPSTR lptstrFilename,
        LPDWORD lpdwHandle),
        (lptstrFilename, lpdwHandle));


};

inline
CVersion::CVersion()
{
    m_fInited = FALSE;
}

inline
CVersion::~CVersion()
{
    if (m_fInited) {
        FreeLibrary(m_hMod);
    }
}

inline
HRESULT 
CVersion::Init(void)
{
    if (m_fInited) {
        return S_OK;
    }

    m_hMod = LoadLibrary( "VERSION.DLL" );

    if (!m_hMod) {
        return HRESULT_FROM_WIN32(GetLastError());
    }

#define CHECKAPI(_fn) \
    *(FARPROC*)&(_pfn##_fn) = GetProcAddress(m_hMod, #_fn); \
    if (!(_pfn##_fn)) return E_UNEXPECTED;

    CHECKAPI(VerInstallFileA);
    CHECKAPI(VerQueryValueA);
    CHECKAPI(GetFileVersionInfoSizeA);
    CHECKAPI(GetFileVersionInfoA);

    m_fInited = TRUE;
    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\strids.h ===
// no msg
#define ID_CDLDBG_NOMSG                              0

#define ID_CDLDBG_MISSING_DLLREGISTERSERVER          10000
#define ID_CDLDBG_INCOMPATIBLE_BINARY                10001
#define ID_CDLDBG_VERIFYTRUST_FAILED                 10002
#define ID_CDLDBG_ERR_PRIMARY_LANGUAGE               10003
#define ID_CDLDBG_ERR_NO_SECTION                     10004
#define ID_CDLDBG_SATELLITE_FOUND                    10005
#define ID_CDLDBG_PROCESSINF_FAILED                  10006
#define ID_CDLDBG_COMPLETEONE_IN                     10007
#define ID_CDLDBG_ONSTOPBINDING_CALLED               10008
#define ID_CDLDBG_FOUND_DUP                          10009
#define ID_CDLDBG_DOSETUP_FAILED                     10010
#define ID_CDLDBG_NO_IWINDOWFORBINDINGUI             10011
#define ID_CDLDBG_RUNSETUPHOOK_FAILED                10012
#define ID_CDLDBG_OBJ_TAG_MIXED_USAGE                10013
#define ID_CDLDBG_FAILED_OSD_OM                      10014
#define ID_CDLDBG_DU_REQUIRED_ATTRIB_MISSING         10015
#define ID_CDLDBG_NATIVECODE_SYNTAX                  10016
#define ID_CDLDBG_CODEBASE_SYNTAX                    10017
#define ID_CDLDBG_BAD_INF_FROM_OSD                   10018
#define ID_CDLDBG_JAVAPACKAGE_SYNTAX                 10019
#define ID_CDLDBG_DEPENDENCY_SYNTAX                  10020
#define ID_CDLDBG_DEPENDENCY_SOFTDIST_SYNTAX         10021
#define ID_CDLDBG_CDL_HANDLER_MISSING                10022

#define ID_CDLDBG_FILE_INUSE                         10023
#define ID_CDLDBG_SETUP_COMPLETE                     10024
#define ID_CDLDBG_HOOK_COMPLETE                      10025
#define ID_CDLDBG_DLL_REGISTERED                     10026
#define ID_CDLDBG_ITEM_PROCESSED                     10027
#define ID_CDLDBG_JAVA_PKG_SETUP                     10028
#define ID_CDLDBG_JAVA_PKG_FAILED                    10029
#define ID_CDLDBG_DL_REDUNDANT                       10030
#define ID_CDLDBG_DL_REDUNDANT_FAILED                10031
#define ID_CDLDBG_DL_ON_STOP_BINDING                 10032
#define ID_CDLDBG_DL_UPDATE_DU_NO_VERS               10033
#define ID_CDLDBG_DETAILS                            10034
#define ID_CDLDBG_FAILED_CONVERT_CLSID               10035
#define ID_CDLDBG_FAILED_STRING_FROM_CLSID           10036
#define ID_CDLDBG_ERROR_STRING                       10037
#define ID_CDLDBG_DETAILS_STRING                     10038
#define ID_CDLDBG_UNKNOWN_ERROR                      10039
#define ID_CDLDBG_UNKNOWN_SETUP_ERROR                10040

#define ID_CDLDBG_WX86_REQUIRE_PRIMARY_ARCH          10041
#define ID_CDLDBG_WX86_REQUIRE_ALTERNATE_ARCH        10042
#define ID_CDLDBG_CANNOT_REPLACE_SFP_FILE            10043
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\unixfile.cxx ===
#include "unixfile.h"

void UnixEnsureDir(char *pszFile)
{
    char szDirPath[MAX_PATH];
    int iLen;

    lstrcpy(szDirPath, pszFile);
    iLen = lstrlen(szDirPath);

    while (szDirPath[iLen] != '/')
    {
    iLen--;
    }
    szDirPath[iLen] = '\0';

    CreateDirectory(szDirPath, NULL);
}

void UnixifyFileName(char* lpszName)
{
    while(*lpszName)
    {
        if(*lpszName == '\\')
            *lpszName = '/';
        lpszName++;
    }
}

const GUID CLSID_JAVA_VM =
{
   0x08b0e5c0, 0x4fcb, 0x11cf, {0xaa, 0xa5, 0x00, 0x40, 0x1c, 0x60, 0x85, 0x00}
};
#define JAVA_DLL      TEXT("msjava.dll")
#define szVMInstalled TEXT("IsVMInstalled")

HRESULT CheckIEFeatureOnUnix(LPCWSTR pwszIEFeature,
                             DWORD* dwInstalledVerHi,
                             DWORD* dwInstalledVerLo,
                             DWORD  dwFlags)
{
   HRESULT hr = E_FAIL;
   CLSID   curCLSID;

   if (dwInstalledVerHi)
      memset(dwInstalledVerHi, 0, sizeof(DWORD));

   if (dwInstalledVerLo)
      memset(dwInstalledVerLo, 0, sizeof(DWORD));

   if (CLSIDFromString((LPOLESTR)pwszIEFeature, &curCLSID) != ERROR_SUCCESS)
   {
      hr = S_FALSE;
      goto Cleanup;
   }

   if (IsEqualCLSID(curCLSID, CLSID_JAVA_VM))
   {
      HMODULE hLibJava = NULL;

      typedef BOOL (WINAPI *LPISVMINSTALLED)();
      LPISVMINSTALLED lpfnIsVMInstalled;

      hr = ERROR_PRODUCT_UNINSTALLED; /* We are handling it in any case */
      if ((hLibJava = LoadLibrary(JAVA_DLL)) != NULL)
      {
         lpfnIsVMInstalled = (LPISVMINSTALLED)GetProcAddress(hLibJava, szVMInstalled);
         if (lpfnIsVMInstalled)
         {
            if (lpfnIsVMInstalled())
               hr = S_OK;
         }

         FreeLibrary(hLibJava);
      }
   }

Cleanup:
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\webjit.cpp ===
#include <cdlpch.h>
#include <windows.h>
#include <objbase.h>
#include <winbase.h>
#include <softpub.h>
#include "capi.h"
//#include <stdlib.h>
#include <stdio.h>
//#include <stdlib.h>
//#include <string.h>
//#include <tchar.h>
#include <crtdbg.h>
#include <urlmon.h>
#include <wininet.h>
#include <shellapi.h>
#include <commctrl.h>
#include <shlwapi.h>
#include <shfusion.h>
#include "webjitres.h"
#include "webjit.h"
#include "mluisupp.h"

#undef SAFERELEASE
#define SAFERELEASE(p) if ((p) != NULL) { (p)->Release(); (p) = NULL; };
#undef SAFEDELETE
#define SAFEDELETE(p) if ((p) != NULL) { delete (p); (p) = NULL; };
#undef ARRAY_ELEMENTS
#define ARRAY_ELEMENTS(array) \
    (sizeof(array)/sizeof(array[0]))

BOOL IsUIRestricted();
BOOL IsWin32X86();
BOOL IsNTAdmin();
extern BOOL g_bLockedDown;
extern HMODULE g_hInst;

HRESULT EnsureSecurityManager ();

CWebJit::CWebJit(WEBJIT_PARAM* pWebJitParam)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CWebJit::CWebJit",
                "this=%#x, %.200q, %.200wq, %#x, %#x",
                this, pWebJitParam->lpszResource, pWebJitParam->pwszComponentId, pWebJitParam->dwFlags, pWebJitParam->hWndParent
                ));
                
    m_fInited = FALSE;
    m_hWintrustMod = NULL;
    m_fInitedCC = FALSE;
    m_hComCtlMod = NULL;

    m_szResource = pWebJitParam->lpszResource;
    m_dwFlags = pWebJitParam->dwFlags;
    m_pwszComponentId = pWebJitParam->pwszComponentId;
    m_hWndParent = pWebJitParam->hWndParent;
    m_pQueryInstalled = pWebJitParam->pQueryInstalled;
    m_pwszUrl = NULL;
    m_cRef = 1;
    m_dwTotal = m_dwCurrent = 0;
    m_hDialog = NULL;
    m_hProcess = 0;
    m_pBinding = NULL;
    m_pStm = NULL;
    m_pMk = NULL;
    m_pbc = NULL;
    m_hCacheFile = NULL;
    m_dwRetVal = 0;
    m_dwDownloadSpeed = 0;

    m_hDownloadResult = S_OK;
    m_fResultIn = FALSE;

    m_fAborted = FALSE;
    m_fCalledAbort = FALSE;
    
    m_State = WJSTATE_INIT;

    m_hrInternal = S_OK;
    m_pwszMimeType = NULL;
    m_pwszRedirectUrl = NULL;
    m_pwszCacheFile = NULL;
    m_fHtml = FALSE;
    m_fDownloadInited = FALSE;
    m_pTempBuffer = NULL;
    m_bReading = FALSE;
    m_bStartedReadTimer = FALSE;

    DEBUG_LEAVE(0);
}

CWebJit::~CWebJit()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CWebJit::~CWebJit",
                "this=%#x, aborted?=%B, result=%#x, redirect=%.200wq, m_hProcess=%#x (%d)",
                this, m_fAborted, m_hDownloadResult, (m_pwszRedirectUrl ? m_pwszRedirectUrl : L"NONE"), m_hProcess, m_hProcess
                ));
                
    if (m_fInited) 
    {
        FreeLibrary(m_hWintrustMod);
    }
    if (m_fInitedCC)
    {
        FreeLibrary(m_hComCtlMod);
    }
    if (m_hProcess)
    {
        CloseHandle(m_hProcess);
    }

    ReleaseAll();
    if (m_pwszUrl)
        delete [] m_pwszUrl;
    if (m_pwszMimeType)
        delete [] m_pwszMimeType;
    if (m_pwszCacheFile)
        delete [] m_pwszCacheFile;
    if (m_pwszRedirectUrl)
        delete [] m_pwszRedirectUrl;
    if (m_pTempBuffer)
        delete [] m_pTempBuffer;

    DEBUG_LEAVE(0);
}

VOID CWebJit::ReleaseAll()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CWebJit::ReleaseAll",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, m_pStm, m_pMk, m_pBinding, m_pbc
                ));
                
    SAFERELEASE(m_pStm);
    SAFERELEASE(m_pMk);
    SAFERELEASE(m_pBinding);
    SAFERELEASE(m_pbc);

    DEBUG_LEAVE(0);
}

STDMETHODIMP CWebJit::QueryInterface(REFIID riid, void ** ppv)
{
    *ppv = NULL;

    if (riid == IID_IUnknown)
    {
        *ppv = (void*)this;
    }
    else if (riid == IID_IBindStatusCallback)
    {
        *ppv = (void*)(IBindStatusCallback*)this;
    }
    else if (riid == IID_IAuthenticate)
    {
        *ppv = (void*)(IAuthenticate*)this;
    }

    if (*ppv) 
    {
        ((IUnknown *)*ppv)->AddRef();
    
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CWebJit::AddRef()    
{
    return m_cRef++; 
}

STDMETHODIMP_(ULONG) CWebJit::Release()
{
    if (--m_cRef == 0) 
    { 
        delete this; 
        return 0; 
    }
    
    return m_cRef; 
}

// IBindStatusCallback methods
STDMETHODIMP CWebJit::OnStartBinding(DWORD dwReserved, IBinding* pbinding)
{
    if (m_fAborted)
    {
        goto abort;
    }
    
    m_pBinding = pbinding;
    m_pBinding->AddRef();
    
    return S_OK;

abort:
    return E_FAIL;
}

STDMETHODIMP CWebJit::OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR pwzStatusText)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CWebJit::OnProgress",
                "this=%#x, %#x, %#x, %d (%#x), %.200wq",
                this, ulProgress, ulProgressMax, ulStatusCode, ulStatusCode, pwzStatusText
                ));
                
    if (m_fAborted)
    {
        goto abort;
    }

    switch(ulStatusCode)
    {
    case BINDSTATUS_BEGINDOWNLOADDATA:
        {
            m_dwTotal = ulProgressMax;
            HWND hProgressBar = GetDlgItem(m_hDialog, IDC_PROGRESS1);
            if (m_dwTotal)
            {
                ShowWindow(hProgressBar, SW_SHOWNORMAL);
                ShowWindow(GetDlgItem(m_hDialog, IDC_REMAINING_SIZE), SW_SHOWNORMAL);
                ShowWindow(GetDlgItem(m_hDialog, IDC_REMAINING_TIME), SW_SHOWNORMAL);
                UpdateProgressUI();
            }
            SendMessage(hProgressBar, PBM_SETRANGE, 0, MAKELPARAM(0,65535));
        }
        break;
    case BINDSTATUS_CACHEFILENAMEAVAILABLE:
        {
            //ASSERT (pwzStatusText && (*pwzStatusText != L'\0'));
            int nWideLen = lstrlenW(pwzStatusText);
            m_pwszCacheFile = new WCHAR[nWideLen+1];
            if (!m_pwszCacheFile)
            {
                m_hrInternal = E_OUTOFMEMORY;
                goto abort;
            }
            StrCpyW(m_pwszCacheFile, pwzStatusText);
        }
        break;
    case BINDSTATUS_MIMETYPEAVAILABLE:
        {
            //ASSERT (pwzStatusText && (*pwzStatusText != L'\0'));
            int nWideLen = lstrlenW(pwzStatusText);
            m_pwszMimeType = new WCHAR[nWideLen+1];
            if (!m_pwszMimeType)
            {
                m_hrInternal = E_OUTOFMEMORY;
                goto abort;
            }
            StrCpyW(m_pwszMimeType, pwzStatusText);
        }
        break;
    case BINDSTATUS_REDIRECTING:
        {
            //ASSERT (pwzStatusText && (*pwzStatusText != L'\0'));
            int nWideLen = lstrlenW(pwzStatusText);
            if (m_pwszRedirectUrl)
            {
                delete [] m_pwszRedirectUrl;
            }
            m_pwszRedirectUrl = new WCHAR[nWideLen+1];
            if (!m_pwszRedirectUrl)
            {
                m_hrInternal = E_OUTOFMEMORY;
                goto abort;
            }
            StrCpyW(m_pwszRedirectUrl, pwzStatusText);
        }
        break;
    }

    DEBUG_LEAVE(S_OK);
    return S_OK;

abort:
    if (!m_fCalledAbort && m_pBinding)
    {
        m_pBinding->Abort();
        m_fCalledAbort = TRUE;
    }
    
    DEBUG_LEAVE(S_OK);
    return S_OK;
}

STDMETHODIMP CWebJit::OnStopBinding(HRESULT hrResult, LPCWSTR szError)
{
    UpdateDownloadResult(hrResult, TRUE);
    
    return S_OK;
}

STDMETHODIMP CWebJit::GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindInfo)
{
    // clear BINDINFO but keep its size
    DWORD cbSize = pbindInfo->cbSize;
    memset(pbindInfo, 0, cbSize);
    
    pbindInfo->cbSize = cbSize;
    *pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA | BINDF_RESYNCHRONIZE | BINDF_PREFERDEFAULTHANDLER | BINDF_NEEDFILE;
    pbindInfo->dwBindVerb = BINDVERB_GET;
    
    return S_OK;
}

STDMETHODIMP CWebJit::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pfmtetc, STGMEDIUM* pstgmed)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Dword,
                "CWebJit::OnDataAvailable",
                "this=%#x, %#x, %#x, %#x, %#x, %#x / %#x",
                this, grfBSCF, dwSize, pstgmed->pstm, pfmtetc->tymed, m_dwCurrent, m_dwTotal
                ));
                
    HRESULT hr;
    if (m_fAborted)
    {
        goto abort;
    }
    
    if (!m_pStm)
    {
        m_pStm = pstgmed->pstm;
        m_pStm->AddRef();
    }
    
    if (!m_hCacheFile && m_pBinding)
    {
        IWinInetHttpInfo* pHttpInfo = NULL;
        hr = QueryInterface(IID_IWinInetHttpInfo, (void**)&pHttpInfo);
        if (SUCCEEDED(hr))
        {
            DWORD dwSize = sizeof(m_hCacheFile);
            hr = pHttpInfo->QueryOption(WININETINFO_OPTION_LOCK_HANDLE, &m_hCacheFile, &dwSize);
            pHttpInfo->Release();
        }
    }   

    PostMessage(m_hDialog, WM_DATA_AVAILABLE, 0, 0);

    DEBUG_LEAVE(m_dwCurrent);
    return S_OK;

abort:
    if (!m_fCalledAbort && m_pBinding)
    {
        m_pBinding->Abort();
        m_fCalledAbort = TRUE;
    }

    DEBUG_LEAVE(E_ABORT);
    return S_OK;
}

VOID CWebJit::ReadData()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Dword,
                "CWebJit::ReadData",
                "this=%#x, %#x, %#x / %#x",
                this, m_pStm, m_dwCurrent, m_dwTotal
                ));

    HRESULT hr = E_FAIL;
    HRESULT hrAbort = S_OK;

    //reentrancy guard
    if (m_bReading)
    {
        goto leave;
    }
    m_bReading = TRUE;
    
    if (m_fAborted)
    {
        goto abort;
    }
    
    if (m_State >= WJSTATE_VERIFYING)
    {
        // redundant timer messages
        goto end;
    }
    
    HWND hProgressBar = GetDlgItem(m_hDialog, IDC_PROGRESS1);

    DWORD dwRead;
    hr = m_pStm->Read(m_pTempBuffer, TEMPREADBUFFERSIZE, &dwRead);
    if (SUCCEEDED(hr) 
        || ( (hr == E_PENDING) && (dwRead > 0) ) )
    {
        m_dwCurrent += dwRead;
        //UpdateProgressUI();
        if (m_dwTotal)
            SendMessage(hProgressBar, PBM_SETPOS, (WPARAM)((m_dwCurrent*1.00/m_dwTotal)*65535), 0);                 
    }
    
end:
    // if we are done reading OR we have been aborted
    if (((hr == S_FALSE)
        && (m_dwTotal ? (m_dwCurrent == m_dwTotal) : TRUE))
        || (hr == E_ABORT))
    {
        // handle cases where Abort failed to prevent leak.
        if ((hrAbort == INET_E_RESULT_DISPATCHED)
            || (hrAbort == E_FAIL)
            && m_pStm)
        {
            HRESULT hrTemp;
            do
            {
                hrTemp = m_pStm->Read(m_pTempBuffer, TEMPREADBUFFERSIZE, &dwRead);
                if (SUCCEEDED(hrTemp)
                    || ((hrTemp==E_PENDING) && (dwRead>0)))
                {
                    m_dwCurrent += dwRead;
                }
            }
            while ((hrTemp == NOERROR) && m_pStm);
        }
        
        // and have already received OnStopBinding
        if (m_State == WJSTATE_DOWNLOADED)
        {
            if (m_pMk)
            {
                if (hr == E_ABORT)
                {
                    m_hDownloadResult = E_ABORT;
                }
                //abort or finished read after osb.
                ReleaseAll();

                if (SUCCEEDED(m_hDownloadResult))
                {
                    PostMessage(m_hDialog, WM_DOWNLOAD_DONE, 0, 0);
                }
                else
                {
                    PostMessage(m_hDialog, WM_DOWNLOAD_ERROR, (WPARAM)m_hDownloadResult, 0);
                }
            }
        }
        m_State = WJSTATE_FINISHED_READ;
    }
    m_bReading = FALSE;

leave:
    DEBUG_LEAVE(m_dwCurrent);
    return;

abort:
    hr = E_ABORT;
    
    if (!m_fCalledAbort && m_pBinding)
    {
        m_fCalledAbort = TRUE;
        hrAbort = m_pBinding->Abort();
    }

    goto end;
}
    
STDMETHODIMP CWebJit::OnObjectAvailable(REFIID riid, IUnknown* punk)
{
    return S_OK;
}
    
STDMETHODIMP CWebJit::Authenticate(HWND* phwnd, LPWSTR *pszUsername,LPWSTR *pszPassword)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CWebJit::Authenticate",
                "this=%#x",
                this
                ));
                
    *phwnd = m_hDialog;
    *pszUsername = 0;
    *pszPassword = 0;

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

DWORD CWebJit::GetDownloadSpeed()
{
    //using iejit.htx guesstimates/logic
    DWORD dwDownloadSpeed = 120;  //default to 28.8kbps modem.
    DWORD dwFlags;
    if (InternetGetConnectedState(&dwFlags, NULL))
    {
        if (dwFlags & INTERNET_CONNECTION_LAN)
        {
            dwDownloadSpeed = 800; //KB/min
        }
        else if (dwFlags & INTERNET_CONNECTION_MODEM)
        {
            dwDownloadSpeed = 120; //based on 28.8kbps
        }
    }

    return dwDownloadSpeed;
}

BOOL CWebJit::UpdateProgressUI()
{
    DWORD dwDownloadTime;
    BOOL bRetVal = TRUE;
    CHAR szMsg[1000];
    int nRet;
    DWORD dwDownloadSize;
    
    if (!m_dwDownloadSpeed)
    {
        m_dwDownloadSpeed = GetDownloadSpeed();
    }
    if (!m_dwTotal)
    {
        // didn't get a total length - can't display progress.
        bRetVal = FALSE;
        goto exit;
    }

    dwDownloadSize = m_dwTotal - m_dwCurrent;
    
    dwDownloadTime = dwDownloadSize/m_dwDownloadSpeed/1024;
    nRet = MLLoadStringA(IDS_TIME, szMsg, ARRAY_ELEMENTS(szMsg));
    if (dwDownloadTime >= 60)
    {
        DWORD dwDownloadHr = dwDownloadTime / 60;
        DWORD dwDownloadMin = dwDownloadTime % 60;
        
        if(dwDownloadHr == 1)
        {
            nRet += MLLoadStringA(IDS_hr1_TEXT, szMsg+nRet, ARRAY_ELEMENTS(szMsg)-nRet);
        }
        else if ((sizeof(szMsg) - nRet) > 2)
        {
            wsprintfA(szMsg+nRet, "%2d", dwDownloadHr);
            nRet += 2;
            nRet += MLLoadStringA(IDS_hrs_TEXT, szMsg+nRet, ARRAY_ELEMENTS(szMsg)-nRet);
        }
        
        if((dwDownloadMin > 0)
        	&&  ((sizeof(szMsg) - nRet) > 3))
        {
            wsprintfA(szMsg+nRet, " %2d", dwDownloadMin);
            nRet += 3;
            nRet += MLLoadStringA(IDS_MINUTES_TEXT, szMsg+nRet, ARRAY_ELEMENTS(szMsg)-nRet);
        }
    }
    else if(dwDownloadTime < 60)
    {
        if((dwDownloadSize != 0) && (dwDownloadTime == 0))
        {
            nRet += MLLoadStringA(IDS_LessThanAMinute_TEXT, szMsg+nRet, ARRAY_ELEMENTS(szMsg)-nRet);
        }
        else if ((sizeof(szMsg) - nRet) > 2)
        {
            wsprintfA(szMsg+nRet, "%2d", dwDownloadTime);
            nRet += 2;
            nRet += MLLoadStringA(IDS_MINUTES_TEXT, szMsg+nRet, ARRAY_ELEMENTS(szMsg)-nRet);
        }
    }
    SetDlgItemTextA(m_hDialog, IDC_REMAINING_TIME, szMsg);
    
    nRet = MLLoadStringA(IDS_SIZE, szMsg, ARRAY_ELEMENTS(szMsg));
    if ((dwDownloadSize > (1024*1024))
    	&&  ((sizeof(szMsg) - nRet) > 3))
    {
        DWORD dwMbSize = dwDownloadSize/(1024*1024);
        wsprintfA(szMsg+nRet, "%d", dwMbSize);
        nRet += (dwMbSize<10) ? 1 : ((dwMbSize<100) ? 2 : 3);
        nRet += MLLoadStringA(IDS_MEGABYTE_TEXT, szMsg+nRet, ARRAY_ELEMENTS(szMsg)-nRet);
    }
    else if ((sizeof(szMsg) - nRet) > 3)
    {
        DWORD dwKbSize = dwDownloadSize/1024;
        wsprintfA(szMsg+nRet, "%d", dwKbSize);
        nRet += (dwKbSize<10) ? 1 : ((dwKbSize<100) ? 2 : 3);
        nRet += MLLoadStringA(IDS_KILOBYTES_TEXT, szMsg+nRet, ARRAY_ELEMENTS(szMsg)-nRet);
    }
    SetDlgItemTextA(m_hDialog, IDC_REMAINING_SIZE, szMsg);

    SendMessage(GetDlgItem(m_hDialog, IDC_PROGRESS1), PBM_SETPOS, (WPARAM)((m_dwCurrent*1.00/m_dwTotal)*65535), 0);

exit:
    return bRetVal;
}

BOOL CWebJit::IsConnected(BOOL* pfIsOffline)
{
    BOOL bRetVal = TRUE;
    DWORD dwFlags = 0;

    bRetVal = InternetGetConnectedState(&dwFlags, NULL);
    
    if (dwFlags & INTERNET_CONNECTION_OFFLINE)
    {
        *pfIsOffline = TRUE;
    }
    else
    {
        *pfIsOffline = FALSE;
    }

    return bRetVal;
}

VOID CWebJit::UpdateDownloadResult(HRESULT hr, BOOL fFromOnStopBinding)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CWebJit::UpdateDownloadResult",
                "this=%#x, hr=%#x, OnStopBinding?=%B, fResultIn?=%B, previous hr=%#x",
                this, hr, fFromOnStopBinding, m_fResultIn, m_hDownloadResult
                ));
                
    if (fFromOnStopBinding)
    {
        if (m_fResultIn)
        {
            // If the result from BindToStorage was successful, use this one.
            if ((SUCCEEDED(m_hDownloadResult))
                || (m_hDownloadResult == E_PENDING))
            {
                m_hDownloadResult = hr;
            }
            goto NextStep;
        }
        else
        {
            m_hDownloadResult = hr;
            m_fResultIn = TRUE;
        }
    }
    else
    {
        if (m_fResultIn)
        {
            if (SUCCEEDED(m_hDownloadResult)
                && !((hr == MK_S_ASYNCHRONOUS) || (hr == E_PENDING)))
            {
                m_hDownloadResult = hr;
            }
            goto NextStep;
        }
        else
        {
            m_hDownloadResult = hr;
            m_fResultIn = TRUE;

            if (!((hr == MK_S_ASYNCHRONOUS) || (hr == E_PENDING)))
            {
                goto NextStep;
            }
        }
    }

exit:
    DEBUG_LEAVE(m_hDownloadResult);
    return;

NextStep:
    if (m_fAborted)
    {
        m_hDownloadResult = E_ABORT;
    }
    else if (m_State < WJSTATE_FINISHED_READ)
    {
        m_State = WJSTATE_DOWNLOADED;
    }

    if ((m_State == WJSTATE_FINISHED_READ)
        || m_fAborted
        || FAILED(m_hDownloadResult))
    {
        // if we either aborted or 
        // if all the data has been read
        
        if (m_pMk)
        {
            ReleaseAll();

            if (SUCCEEDED(m_hDownloadResult))
            {
                PostMessage(m_hDialog, WM_DOWNLOAD_DONE, 0, 0);
            }
            else
            {
                PostMessage(m_hDialog, WM_DOWNLOAD_ERROR, (WPARAM)m_hDownloadResult, 0);
            }
        }
    }
    
    //Release(); //balanced by Release in UpdateDownloadResult
    goto exit;
}    

HRESULT CWebJit::VerifyMimeAndExtension()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CWebJit::VerifyMimeAndExtension",
                "this=%#x, cache file=%.200wq, mime type=%.80wq",
                this, m_pwszCacheFile, m_pwszMimeType
                ));
                
    HRESULT hr = S_OK;
    
    if (m_pwszMimeType)
    {
        if (!StrCmpIW(m_pwszMimeType, L"text/html"))
        {
            m_fHtml = TRUE;
        }
        else if (StrCmpIW(m_pwszMimeType, L"application/x-msdownload")
                && StrCmpIW(m_pwszMimeType, L"application/octet-stream"))
        {
            hr = NO_MIME_MATCH;
        }
    }

    //disable .exe check for now
    /*
    int dwStrlen = lstrlenW(m_pwszCacheFile);

    if ((dwStrlen < 4)
        || (StrCmpIW(m_pwszCacheFile+dwStrlen-4, L".exe")))
    {
        hr = NO_EXT_MATCH;
    }
exit:
     */
    DEBUG_LEAVE(hr);
    return hr;
}

BOOL CWebJit::NeedHostSecMgr()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Bool,
                "CWebJit::NeedHostSecMgr",
                "this=%#x",
                this
                ));
    BOOL fNeed = FALSE;
    BOOL fWhistler = FALSE;

    OSVERSIONINFO VerInfo;
    VerInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    if (GetVersionEx(&VerInfo))
    {
        if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            if ((VerInfo.dwMajorVersion >= 5) 
            && (VerInfo.dwMinorVersion >= 1))
            {
                fWhistler = TRUE;
            }
        }
    }
    
    if (fWhistler
        && !StrCmpIW(m_pwszComponentId, L"JAVAVMJIT"))
    {
        //if installed VM older than 5.00.2752.0
        const static char * szRequiredVersion = "5,00,2752,0";
        DWORD dwHi;
        DWORD dwLo;
        if (m_pQueryInstalled
            && (m_pQueryInstalled->dwVersionHi || m_pQueryInstalled->dwVersionLo)
            && (SUCCEEDED(GetVersionFromString(szRequiredVersion, &dwHi, &dwLo)))
            && ((m_pQueryInstalled->dwVersionHi < dwHi)
                || ((m_pQueryInstalled->dwVersionHi == dwHi)
                    && (m_pQueryInstalled->dwVersionLo < dwLo))))
        {
            fNeed = TRUE;
        }
    }

    DEBUG_LEAVE(fNeed);
    return fNeed;
}

VOID CWebJit::ProcessFile()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CWebJit::ProcessFile",
                "this=%#x",
                this
                ));
                
    HRESULT hr = VerifyMimeAndExtension();

    if (hr == S_OK)
    {
        if (!m_fHtml)
        {
            hr = VerifyTrust(FALSE);

            if (FAILED(hr) && NeedHostSecMgr())
            {
                HRESULT hrTemp = VerifyTrust(TRUE);

                // use the hrTemp from the second call only if the call actually succeeds.
                if (hrTemp == S_OK)
                {
                    hr = hrTemp;
                }
            }
        }
        if (SUCCEEDED(hr))
        {
            if ((hr = ExecFile()) == S_OK)
            {
//enable this code if we need to exit the dialog while navigating browser to error html page
//because the error page has been execed into the same process.
                if (m_fHtml && (NULL == GetProcessHandle()))
                {
                    SendMessage(m_hDialog, WM_DONT_WAIT, 0, 0);
                }
                else
                {
                    SendMessage(m_hDialog, WM_START_TIMER, (WPARAM)1, 0);
                }
                
                goto success;
            }
        }
    }
    
    SendMessage(m_hDialog, WM_PROCESS_ERROR, hr, 0);
    
success:
    DEBUG_LEAVE(hr);
    return;
}

HRESULT CWebJit::CanWebJit()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CWebJit::CanWebJit",
                "this=%#x",
                this
                ));
                
    HRESULT hr = S_OK;
    
#define REGSTR_PATH_NT5_LOCKDOWN_TEST    "Software\\Microsoft\\Code Store Database\\NT5LockDownTest"

    if (g_bNT5OrGreater)
    {
        HKEY hkeyLockedDown = 0;

        // Test for lock-down. If we cannot write to HKLM, then we are in
        // a locked-down environment, and should abort right away.

        if (RegCreateKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_NT5_LOCKDOWN_TEST,
                         &hkeyLockedDown) != ERROR_SUCCESS) 
        {
            // We are in lock-down mode; abort.
            g_bLockedDown = TRUE;
            hr = E_ACCESSDENIED;
        }
        else 
        {
            // Not locked-down. Delete the key, and continue
            RegCloseKey(hkeyLockedDown);
            RegDeleteKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_NT5_LOCKDOWN_TEST);
            g_bLockedDown = FALSE;
        }
    }

    //JAVA VM specific checks.. If we have too many component specific checks eventually,
    // make function pointers and key off those.
    if (SUCCEEDED(hr) && g_bNT5OrGreater
        && !StrCmpIW(m_pwszComponentId, L"JAVAVMJIT"))
    {
        if (!IsWin32X86())
        {
            hr = HRESULT_FROM_WIN32(ERROR_INSTALL_PLATFORM_UNSUPPORTED);
        }
        else if(!IsNTAdmin())
        {
            hr = E_ACCESSDENIED;
        }
    }

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT CWebJit::SetupDownload()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CWebJit::SetupDownload",
                "this=%#x",
                this
                ));
                
    int cchWideChar;
    HRESULT hr;

    if (FAILED(hr = CanWebJit()))
    {
        goto exit;
    }

    m_pTempBuffer = new CHAR[TEMPREADBUFFERSIZE];
    if (!m_pTempBuffer)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    
    cchWideChar = MultiByteToWideChar(CP_ACP, 0, m_szResource, -1, NULL, 0);
    if (!cchWideChar)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    m_pwszUrl = new WCHAR[cchWideChar+1];
    if (!m_pwszUrl)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    cchWideChar = MultiByteToWideChar(CP_ACP, 0, m_szResource, -1, m_pwszUrl, cchWideChar);
    if (!cchWideChar)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }
    
    hr = CreateAsyncBindCtx(NULL, (IBindStatusCallback *)this, NULL, &m_pbc );
    if (FAILED(hr))
    {
        goto exit;
    }
    
    hr = CreateURLMoniker(NULL, m_pwszUrl, &m_pMk);
    if (FAILED(hr))
    {
        goto exit;
    }

exit:
    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT CWebJit::StartDownload()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CWebJit::StartDownload",
                "this=%#x",
                this
                ));

    //AddRef(); //balanced by Release in UpdateDownloadResult
    m_State = WJSTATE_BINDING;
    UpdateStatusString();

    BOOL bRetVal = FALSE;
    HRESULT hr;

    hr = m_pMk->BindToStorage(m_pbc, 0, IID_IStream, (void**)&m_pStm);

    DEBUG_LEAVE(hr);
    return hr;
}
    
HRESULT CWebJit::ExecFile()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CWebJit::ExecFile",
                "this=%#x",
                this
                ));
                
    HRESULT hr = S_OK;
    
    if (m_fAborted)
    {
        hr = E_ABORT;
        goto exit;
    }
    else
    {
        m_State = WJSTATE_READY_TO_EXEC;
    }
    
    SHELLEXECUTEINFOW shExecInfo;

    memset(&shExecInfo, 0, sizeof(SHELLEXECUTEINFOW));
    
    shExecInfo.cbSize = sizeof(shExecInfo);
    shExecInfo.fMask  =     SEE_MASK_FLAG_DDEWAIT /*don't need in urlmon*/
                        |   SEE_MASK_FLAG_NO_UI 
                        |   SEE_MASK_NOCLOSEPROCESS
                        |   SEE_MASK_NO_CONSOLE
                        |   SEE_MASK_UNICODE /* ?? */;
    shExecInfo.lpVerb = L"open";
    //ASSERT (m_pwszCacheFile && (*m_pwszCacheFile != L'\0'))
    if (m_fHtml)
    {
        if (!m_pwszRedirectUrl)
        {   hr = EXEC_ERROR;
            goto exit;
        }
        shExecInfo.lpFile = m_pwszRedirectUrl;
    }
    else
        shExecInfo.lpFile = m_pwszCacheFile;
    shExecInfo.nShow  = SW_SHOWNORMAL;
                
    if (!ShellExecuteExWrapW(&shExecInfo))
    {
        hr = EXEC_ERROR;
        goto exit;
    }
    
    m_hProcess = shExecInfo.hProcess;
    
exit:
    if (m_hCacheFile && !InternetUnlockRequestFile(m_hCacheFile))
    {
        //nothing.
    }

    DEBUG_LEAVE(hr);
    return hr;
}

#define MAX_ERROR_SIZE 2000
#define START_ERROR_STRING(ERROR_IDS) \
    nRet = MLLoadStringW(ERROR_IDS, wszError, MAX_ERROR_SIZE);
#define APPEND_ERROR_STRING(ERROR_IDS) \
    StrCatW(wszError, L" "); \
    nRet += MLLoadStringW(ERROR_IDS, wszError+nRet+1, MAX_ERROR_SIZE-nRet-1)+1;
    
HRESULT CWebJit::DisplayError(HRESULT hr, UINT nMsgError)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CWebJit::DisplayError",
                "this=%#x, %#x, %#x",
                this, hr, nMsgError
                ));
                
    int nRet = 0;
    BOOL fIsOffline;
    WCHAR wszError[MAX_ERROR_SIZE];
    WCHAR wszTitle[200];
    ULONG_PTR uCookie = 0;
    
    if (m_fAborted)
        goto exit;
        
    if (m_hrInternal)
    {
        hr = m_hrInternal;
        nMsgError = WM_INTERNAL_ERROR;
    }

    START_ERROR_STRING(IDS_ERROROCCURED);
    if (nRet)
    {
        *(wszError+nRet) = L'\0';
        SetDlgItemTextWrapW(m_hDialog, IDC_TEXT, wszError);
    }
    ShowWindow(GetDlgItem(m_hDialog, IDCANCEL), SW_HIDE);

    if (!IsConnected(&fIsOffline))
    {
        fIsOffline = TRUE;
    }

    nRet = 0;
    switch(nMsgError)
    {
    case WM_INTERNAL_ERROR:
        {
            START_ERROR_STRING(IDS_INTERNAL);
            APPEND_ERROR_STRING(IDS_PRODUCTUPDATES);
        }
        break;
    case WM_SETUP_ERROR:
        {
            if (hr == E_ACCESSDENIED)
            {
                START_ERROR_STRING(IDS_INSTALLFAIL);
                APPEND_ERROR_STRING(IDS_ADMINRIGHTS);
            }
            else if (hr == HRESULT_FROM_WIN32(ERROR_INSTALL_PLATFORM_UNSUPPORTED))
            {
                START_ERROR_STRING(IDS_PLATFORMNOT);
                APPEND_ERROR_STRING(IDS_PRODUCTUPDATES);
            }
            else
            {
                START_ERROR_STRING(IDS_SETUP);
                APPEND_ERROR_STRING(IDS_PRODUCTUPDATES);
            }
        }
        break;
    case WM_DOWNLOAD_ERROR:
        {
            switch(hr)
            {
            case E_ABORT:
                {
                    hr = CANCELLED;
                }
                break;
            case INET_E_OBJECT_NOT_FOUND:
                {
                    if (fIsOffline)
                    {
                        START_ERROR_STRING(IDS_OFFLINEALERT);
                        APPEND_ERROR_STRING(IDS_OFFLINEALERT2);
                    }
                    else
                    {
                        START_ERROR_STRING(IDS_DLFAIL);
                        APPEND_ERROR_STRING(IDS_PRODUCTUPDATES);
                    }
                }
                break;
            case INET_E_RESOURCE_NOT_FOUND:
                {
                    START_ERROR_STRING(IDS_SERVERERROR);
                    APPEND_ERROR_STRING(IDS_IBUSY);
                    APPEND_ERROR_STRING(IDS_NOTCONNECTED);
                }
                break;
            case INET_E_DOWNLOAD_FAILURE:
                {
                    if (fIsOffline)
                    {
                        START_ERROR_STRING(IDS_OFFLINEALERT);
                        APPEND_ERROR_STRING(IDS_OFFLINEALERT2);
                    }
                    else
                    {
                        START_ERROR_STRING(IDS_DLFAIL);
                        APPEND_ERROR_STRING(IDS_PRODUCTUPDATES);
                    }
                }
                break;
            }
            if (!nRet
                && (hr >= INET_E_ERROR_FIRST)
                && (hr <= INET_E_ERROR_LAST))
            {
                START_ERROR_STRING(IDS_DLFAIL);
                APPEND_ERROR_STRING(IDS_IBUSY);
                APPEND_ERROR_STRING(IDS_NOTCONNECTED);
            }
        }
        break;
    case WM_PROCESS_ERROR:
        {
            switch(hr)
            {
            case TRUST_E_SUBJECT_NOT_TRUSTED:
                {
                    START_ERROR_STRING(IDS_CERTREFUSE);
                    APPEND_ERROR_STRING(IDS_PRODUCTUPDATES);
                }
                break;
            case TRUST_E_FAIL:
                {
                    START_ERROR_STRING(IDS_SECURITYHIGH);
                    APPEND_ERROR_STRING(IDS_SECURITYHIGH1);
                    APPEND_ERROR_STRING(IDS_SECURITYHIGH2);
                    APPEND_ERROR_STRING(IDS_SECURITYHIGH3);
                }
                break;
            case E_ACCESSDENIED:
                {
                    START_ERROR_STRING(IDS_INSTALLFAIL);
                    APPEND_ERROR_STRING(IDS_ADMINRIGHTS);
                }
                break;
            }
            if (!nRet)
            {
                START_ERROR_STRING(IDS_PROCESS);
                APPEND_ERROR_STRING(IDS_PRODUCTUPDATES);
                hr = HRESULT_FROM_WIN32(ERROR_INSTALL_FAILURE);
            }
        }
        break;
    }

    if (!nRet)
    {
        START_ERROR_STRING(IDS_UNKNOWNERROR);
        APPEND_ERROR_STRING(IDS_PRODUCTUPDATES);
    }

    *(wszError+nRet) = L'\0';
    
    nRet = MLLoadStringW(IDS_ERRORTITLE, wszTitle, ARRAY_ELEMENTS(wszTitle));

    SHActivateContext(&uCookie);

    MessageBoxW(m_hDialog, wszError, nRet ? wszTitle : NULL, MB_OK);
    
    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }
   
exit:
    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT CWebJit::VerifyTrust(BOOL fUseHostSecMgr)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "CWebJit::VerifyTrust",
                "this=%#x, %B",
                this, fUseHostSecMgr
                ));
                
    HRESULT hr = E_FAIL;
    LPWSTR pwszUnescapedUrl = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    
#define COR_POLICY_PROVIDER_DOWNLOAD \
    { 0xd41e4f1d, 0xa407, 0x11d1, {0x8b, 0xc9, 0x0, 0xc0, 0x4f, 0xa3, 0xa, 0x41 } }

    GUID guidCor = COR_POLICY_PROVIDER_DOWNLOAD;

    if (m_fAborted)
    {
        hr = E_ABORT;
        goto exit;
    }
    else
    {
        m_State = WJSTATE_VERIFYING;
    }
    
    UpdateStatusString();
    
    hFile = CreateFileWrapW(m_pwszCacheFile, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
    if (!hFile)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }

    DWORD dwWideChar = lstrlenW(m_pwszUrl)+1;
    pwszUnescapedUrl = new WCHAR[dwWideChar];
    if (pwszUnescapedUrl)
    {
        hr = UrlUnescapeW(m_pwszUrl, pwszUnescapedUrl, &dwWideChar, 0);
    }

    LPCWSTR pwszDisplayUrl = (hr == S_OK) ? pwszUnescapedUrl : m_pwszUrl;

    if(!SUCCEEDED(hr = EnsureSecurityManager()))
    {
        goto exit;
    }
        
    WINTRUST_DATA WintrustData;
    ZeroMemory(&WintrustData, sizeof(WINTRUST_DATA));
    WintrustData.cbStruct = sizeof(WINTRUST_DATA);
    if ((m_hDialog == INVALID_HANDLE_VALUE) || IsUIRestricted()) //urlmon only
        WintrustData.dwUIChoice = WTD_UI_NONE;
    else
        WintrustData.dwUIChoice = WTD_UI_ALL;
    WintrustData.dwUnionChoice = WTD_CHOICE_FILE;

    JAVA_POLICY_PROVIDER javaPolicyData;
    ZeroMemory(&javaPolicyData, sizeof(JAVA_POLICY_PROVIDER));
    javaPolicyData.cbSize = sizeof(JAVA_POLICY_PROVIDER);
    javaPolicyData.VMBased = FALSE;
    javaPolicyData.fNoBadUI = FALSE;

    javaPolicyData.pwszZone = pwszDisplayUrl;
    javaPolicyData.pZoneManager = fUseHostSecMgr ? ((LPVOID)(IInternetHostSecurityManager *)this) : NULL;
    WintrustData.pPolicyCallbackData = &javaPolicyData;
    
    WINTRUST_FILE_INFO WintrustFileInfo;
    ZeroMemory(&WintrustFileInfo, sizeof(WINTRUST_FILE_INFO));
    WintrustFileInfo.cbStruct = sizeof(WINTRUST_FILE_INFO);
    WintrustFileInfo.pcwszFilePath = pwszDisplayUrl;
    WintrustFileInfo.hFile = hFile;
    WintrustData.pFile = &WintrustFileInfo;

    hr = WinVerifyTrust(m_hDialog, &guidCor, &WintrustData);
    if (hr == TRUST_E_PROVIDER_UNKNOWN)
    {
        GUID guidJava = JAVA_POLICY_PROVIDER_DOWNLOAD;
        hr = WinVerifyTrust(m_hDialog, &guidJava, &WintrustData);
    }

    if (hr == S_OK)
    {
        DWORD dwZone;
        if ((javaPolicyData.pbJavaTrust == NULL) 
            || (!javaPolicyData.pbJavaTrust->fAllActiveXPermissions) 
            || (g_pSecurityManager 
                && (SUCCEEDED(g_pSecurityManager->MapUrlToZone(m_pwszUrl, &dwZone, 0))) 
                && (dwZone == URLZONE_LOCAL_MACHINE)
                && (FAILED(javaPolicyData.pbJavaTrust->hVerify))))
        {
            hr = TRUST_E_FAIL;
        }
    }
    else if (SUCCEEDED(hr)) 
    {
        // BUGBUG: this works around a wvt bug that returns 0x57 (success) when
        // you hit No to an usigned control
        hr = TRUST_E_FAIL;
    }
    else if (hr == TRUST_E_SUBJECT_NOT_TRUSTED && WintrustData.dwUIChoice == WTD_UI_NONE) 
    {
        // if we didn't ask for the UI to be out up there has been no UI
        // work around WVT bvug that it returns us this special error code
        // without putting up UI.
        hr = TRUST_E_FAIL; // this will put up mshtml ui after the fact
                           // that security settings prevented us
    }

    if (javaPolicyData.pbJavaTrust)
        CoTaskMemFree(javaPolicyData.pbJavaTrust);

exit:
    if (pwszUnescapedUrl)
        delete [] pwszUnescapedUrl;
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    DEBUG_LEAVE(hr);
    return hr;
}

VOID CWebJit::ProcessAbort()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CWebJit::ProcessAbort",
                "this=%#x, currentState=%d",
                this, m_State
                ));
                
    ShowWindow(m_hDialog, SW_HIDE);
    
    m_fAborted = TRUE;
    switch (m_State)
    {
    case WJSTATE_INIT:                
        Terminate(CANCELLED);
        break;
    case WJSTATE_BINDING:
        if (m_pBinding && !m_fCalledAbort)
        {
            m_fCalledAbort = TRUE;
            m_pBinding->Abort();
        }
        break;
    case WJSTATE_DOWNLOADED:
    case WJSTATE_FINISHED_READ:
    case WJSTATE_VERIFYING:
    case WJSTATE_READY_TO_EXEC:
    case WJSTATE_WAITING_PROCESS:
    case WJSTATE_DONE:
    default:
        break;
    }

    DEBUG_LEAVE(0);
}

VOID CWebJit::Terminate(DWORD dwRetVal)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "CWebJit::Terminate",
                "this=%#x, dwRetVal=%#x, currentState=%d",
                this, dwRetVal, m_State
                ));
                
    m_dwRetVal = dwRetVal;
    //Release();
    if (m_fAborted)
        m_dwRetVal = CANCELLED;
    else if (m_hrInternal)
        m_dwRetVal = m_hrInternal;
    EndDialog(m_hDialog, (INT_PTR)m_dwRetVal);

    DEBUG_LEAVE(0);
    return;
}

HRESULT CWebJit::Init(void)
{
    HRESULT hr = S_OK;
    
    if (m_fInited) 
    {
        goto exit;
    }

#define WINTRUST TEXT("wintrust.dll")

    m_hWintrustMod = LoadLibrary( WINTRUST );

    if (NULL == m_hWintrustMod) 
    {
        hr = ERROR_MOD_NOT_FOUND;
        goto exit;
    }

#define CHECKAPI(_fn) \
    *(FARPROC*)&(_pfn##_fn) = GetProcAddress(m_hWintrustMod, #_fn); \
    if (!(_pfn##_fn)) \
    { \
        FreeLibrary(m_hWintrustMod); \
        \
        hr = ERROR_MOD_NOT_FOUND;\
        goto exit;\
    }

    CHECKAPI(WinVerifyTrust);
    
    m_fInited = TRUE;

exit:
    return hr;
}

HRESULT CWebJit::InitCC(void)
{
    HRESULT hr = S_OK;
    
    if (m_fInitedCC)
    {
        goto exit;
    }

#define COMCTL TEXT("comctl32.dll")

    m_hComCtlMod = LoadLibrary( COMCTL );

    if (NULL == m_hComCtlMod) 
    {
        hr = ERROR_MOD_NOT_FOUND;
        goto exit;
    }

#define CHECKCCAPI(_fn) \
    *(FARPROC*)&(_pfn##_fn) = GetProcAddress(m_hComCtlMod, #_fn); \
    if (!(_pfn##_fn)) \
    { \
        FreeLibrary(m_hComCtlMod); \
        \
        hr = ERROR_MOD_NOT_FOUND;\
        goto exit;\
    }

    CHECKCCAPI(InitCommonControlsEx);
    
    m_fInitedCC = TRUE;

exit:
    return hr;
}

BOOL CWebJit::InitCommonControlsForWebJit()
{ 
    INITCOMMONCONTROLSEX sInitComm;
    sInitComm.dwSize = sizeof(INITCOMMONCONTROLSEX);
    sInitComm.dwICC = ICC_PROGRESS_CLASS;

    return InitCommonControlsEx(&sInitComm);
}

UINT MapComponentToResourceId(LPCWSTR pwszComponentId)
{
    typedef struct 
    {
        LPCWSTR pwszComponentId;
        UINT nResource;
    } 
    ComponentToResourceType;

    ComponentToResourceType MapComponentToResource[] = 
    {
        { L"JAVAVMJIT",         IDS_JAVAVMJIT },
        { L"WMPLAYER",          IDS_MEDIAPLAYER }
    };
    UINT nRet = (UINT)-1;

    for (DWORD i = 0; i < ARRAY_ELEMENTS(MapComponentToResource); i++ )
    {
        if (!StrCmpIW(pwszComponentId, MapComponentToResource[i].pwszComponentId))
        {
            nRet = MapComponentToResource[i].nResource;
            break;
        }
    }

    return nRet;
}

UINT MapComponentToHelpId(LPCWSTR pwszComponentId)
{
    typedef struct 
    {
        LPCWSTR pwszComponentId;
        UINT nResource;
    } 
    ComponentToHelpId;

    ComponentToHelpId MapComponentToHelpIds[] = 
    {
        { L"JAVAVMJIT",         50464 },
        { L"WMPLAYER",          50475 }
    };
    UINT nRet = 0;

    for (DWORD i = 0; i < ARRAY_ELEMENTS(MapComponentToHelpIds); i++ )
    {
        if (!StrCmpIW(pwszComponentId, MapComponentToHelpIds[i].pwszComponentId))
        {
            nRet = MapComponentToHelpIds[i].nResource;
            break;
        }
    }

    return nRet;
}

BOOL CenterWindow(HWND hwndChild, HWND hwndParent)
{
    RECT    rChild, rParent;
    int     wChild, hChild, wParent, hParent;
    int     wScreen, hScreen, xNew, yNew;
    HDC     hdc;

    // Get the Height and Width of the child window
    GetWindowRect (hwndChild, &rChild);
    wChild = rChild.right - rChild.left;
    hChild = rChild.bottom - rChild.top;

    // Get the Height and Width of the parent window
    GetWindowRect (hwndParent, &rParent);
    wParent = rParent.right - rParent.left;
    hParent = rParent.bottom - rParent.top;

    // Get the display limits
    hdc = GetDC (hwndChild);
    wScreen = GetDeviceCaps (hdc, HORZRES);
    hScreen = GetDeviceCaps (hdc, VERTRES);
    ReleaseDC (hwndChild, hdc);

    // Calculate new X position, then adjust for screen
    xNew = rParent.left + ((wParent - wChild) /2);
    if (xNew < 0) 
    {
        xNew = 0;
    }
    else if ((xNew+wChild) > wScreen)
    {
        xNew = wScreen - wChild;
    }

    // Calculate new Y position, then adjust for screen
    yNew = rParent.top  + ((hParent - hChild) /2);
    if (yNew < 0) 
    {
        yNew = 0;
    }
    else if ((yNew+hChild) > hScreen)
    {
        yNew = hScreen - hChild;
    }

    // Set it, and return
    return SetWindowPos (hwndChild, NULL,
        xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
}

VOID CWebJit::UpdateStatusString()
{
    CHAR szFormat[400];
    CHAR szMessage[800];
    CHAR szComponent[400];
    int nRet;
    UINT id;

    nRet = MLLoadStringA(MapComponentToResourceId(m_pwszComponentId), szComponent, ARRAY_ELEMENTS(szComponent));
    if (!nRet)
        goto exit;
    
    switch(m_State)
    {
    case WJSTATE_BINDING:
        id = IDS_DOWNLOADING;
        break;
    case WJSTATE_VERIFYING:
        id = IDS_CHECKTRUST;
        break;
    case WJSTATE_WAITING_PROCESS:
        id = IDS_INSTALLING;
        break;
    }
    
    nRet = MLLoadStringA(id, szFormat, ARRAY_ELEMENTS(szFormat));
    if (!nRet)
        goto exit;

    if (wsprintfA(szMessage, szFormat, szComponent))
    {
        SetDlgItemTextA(m_hDialog, IDC_TEXT, szMessage);
    }

exit:
    return;
}

BOOL CWebJit::SetupWindow()
{
    WCHAR szMsg[1000];
    BOOL bRet = FALSE;

    int nRet = MLLoadStringW(IDS_DOWNLOAD_MSG, szMsg, ARRAY_ELEMENTS(szMsg));
    if (nRet)
    {
        StrCatW(szMsg, L"\n\n");
        int nRet2;
        nRet2 = MLLoadStringW(MapComponentToResourceId(m_pwszComponentId), szMsg+nRet+2, ARRAY_ELEMENTS(szMsg)-nRet-2);

        if (nRet2)
        {
            *(szMsg+nRet+nRet2+2) = L'\0';
            
            bRet = TRUE;
            
            if (!SetDlgItemTextWrapW(m_hDialog, IDC_TEXT, szMsg))
            {
                bRet = FALSE;
            }
        }
    }

    if (!(m_dwFlags & FIEF_FLAG_FORCE_JITUI))
    {
        EnableWindow(GetDlgItem(m_hDialog, IDC_CHECK1), TRUE);
    }

    CenterWindow(m_hDialog, m_hWndParent);
    
    return bRet;
}

DWORD mapIDCsToIDHs[] =
{
    IDC_TEXT,               0, //This value is changed depending on component being WebJited
    IDDOWNLOAD,             50621,
    IDCANCEL,               50462,
    IDOK,                   50510,
    IDC_CHECK1,             50620,
    IDC_REMAINING_SIZE,     50457,
    IDC_REMAINING_TIME,     50458,
    0,0
};

DWORD* GetMapArray(CWebJit* pWebJit)
{
    DWORD* pdwMapArray = new DWORD[ARRAY_ELEMENTS(mapIDCsToIDHs)];
    if (pdwMapArray)
    {
        memcpy(pdwMapArray, mapIDCsToIDHs, sizeof(mapIDCsToIDHs));
        pdwMapArray[1] = MapComponentToHelpId(pWebJit->GetComponentIdName());
    }
    return pdwMapArray;
}

INT_PTR CALLBACK WebJitProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    CWebJit* pWebJit = (CWebJit *)GetWindowLongPtr(hDlg, DWLP_USER);
    DWORD* pdwMapArray;
    HRESULT hr;
    //ASSERT (pWebJit || (message == WM_INITDIALOG));
    
    switch(message)
    {
    case WM_INITDIALOG:
        pWebJit = ((WEBJIT_PARAM*)lParam)->pWebJit;
        if (pWebJit)
        {
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pWebJit);
            pWebJit->SetWindowHandle(hDlg);
            pWebJit->SetupWindow();
            return TRUE;
        }
        else
        {
            return FALSE;
        }

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_CHECK1:
        {
            if (SendDlgItemMessage(hDlg, IDC_CHECK1, BM_GETCHECK, 0, 0) == BST_CHECKED)
            {
                EnableWindow(GetDlgItem(hDlg, IDDOWNLOAD), FALSE);
                ShowWindow(GetDlgItem(hDlg, IDDOWNLOAD), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDOK), SW_SHOWNORMAL);
                EnableWindow(GetDlgItem(hDlg, IDOK), TRUE);
            }
            else
            {
                EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
                ShowWindow(GetDlgItem(hDlg, IDOK), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDDOWNLOAD), SW_SHOWNORMAL);
                EnableWindow(GetDlgItem(hDlg, IDDOWNLOAD), TRUE);
            }
            return TRUE;
        } 
        case IDOK:
        {
            if (SendDlgItemMessage(hDlg, IDC_CHECK1, BM_GETSTATE, 0, 0) == BST_CHECKED)
            {
                //Never download any of these components.
                pWebJit->Terminate(NEVERASK);
            }
            return TRUE;
        }
        case IDDOWNLOAD:
        {
            if (SendDlgItemMessage(hDlg, IDC_CHECK1, BM_GETSTATE, 0, 0) == BST_CHECKED)
            {
                //Never download any of these components.
                pWebJit->Terminate(NEVERASK);
                return TRUE;
            }
            
            if (!pWebJit->IsDownloadInited())
            {
                pWebJit->SetDownloadInited();
            }
            else
            {
                return TRUE;
            }
            
            EnableWindow(GetDlgItem(hDlg, IDDOWNLOAD), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_CHECK1), FALSE);
            SetFocus(GetDlgItem(hDlg, IDCANCEL));
            
            HRESULT hr;
            hr = pWebJit->SetupDownload();
            if (FAILED(hr))
            {
                //synchronous failure.
                SendMessage(hDlg, WM_SETUP_ERROR, (WPARAM)hr, 0);
                return TRUE;
            }
            
            hr = pWebJit->StartDownload();
            
            pWebJit->UpdateDownloadResult(hr, FALSE);
            return TRUE;
        }
        case IDCANCEL:
            pWebJit->ProcessAbort();
            return TRUE;
        }
        break;
        
    case WM_DATA_AVAILABLE:
        if (!pWebJit->IsReadTimerStarted())
        {
            pWebJit->SetReadTimerStarted();
            SetTimer(hDlg, TIMER_DOWNLOAD, TIMER_DOWNLOAD_INTERVAL, NULL);
        }
        
        pWebJit->ReadData();
        return TRUE;
        
    case WM_DOWNLOAD_DONE:
        KillTimer(hDlg, TIMER_DOWNLOAD);
        ShowWindow(GetDlgItem(hDlg, IDC_PROGRESS1), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_REMAINING_TIME), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_REMAINING_SIZE), SW_HIDE);
        pWebJit->ProcessFile();
        return TRUE;

    case WM_START_TIMER:
        if (wParam == 1)
        {
            pWebJit->SetState(WJSTATE_WAITING_PROCESS);
            pWebJit->UpdateStatusString();
            SetTimer(hDlg, TIMER_EXEC_POLL, TIMER_EXEC_POLL_INTERVAL, NULL);
        }
        return TRUE;
            
    case WM_SETUP_ERROR:
    case WM_DOWNLOAD_ERROR:
    case WM_PROCESS_ERROR:
        KillTimer(hDlg, TIMER_DOWNLOAD);
        hr = pWebJit->DisplayError((HRESULT)wParam, message);
        pWebJit->Terminate(hr);
        return TRUE;

    case WM_DONT_WAIT:
        pWebJit->SetState(WJSTATE_DONE);
        pWebJit->Terminate(SUCCESS);
        return TRUE;
        
    case WM_TIMER:
        if (wParam == TIMER_EXEC_POLL)
        {
            if (pWebJit->GetProcessHandle()
                && (WAIT_OBJECT_0 == WaitForSingleObject(pWebJit->GetProcessHandle(), 0)))
            {
                KillTimer(hDlg, TIMER_EXEC_POLL);
                pWebJit->SetState(WJSTATE_DONE);
                pWebJit->Terminate(SUCCESS);
            }
            else if (pWebJit->IsAborted())
            {
                KillTimer(hDlg, TIMER_EXEC_POLL);
                pWebJit->Terminate(CANCELLED);
            }
        }
        else if (wParam == TIMER_DOWNLOAD)
        {
            pWebJit->ReadData();
        }    
        return TRUE;
        
    case WM_HELP:// F1
        pdwMapArray = pWebJit ? GetMapArray(pWebJit) : NULL;
        if (pdwMapArray)
        {
            ResWinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle,
                 IDS_WEBJITHELPFILE,
                 HELP_WM_HELP,
                 (ULONG_PTR)(LPSTR)pdwMapArray);
            delete [] pdwMapArray;
        }

        break;

    case WM_CONTEXTMENU:// right mouse click
        pdwMapArray = pWebJit ? GetMapArray(pWebJit) : NULL;
        if (pdwMapArray)
        {
            ResWinHelp(hDlg,
                IDS_WEBJITHELPFILE,
                HELP_CONTEXTMENU,
                (ULONG_PTR)(LPSTR)pdwMapArray);
            delete [] pdwMapArray;
        }

        break;
    }
    return FALSE;
}

//from setup/iexpress/wextract/wextract.c

typedef HRESULT (*CHECKTOKENMEMBERSHIP)(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember);

BOOL CheckToken(BOOL *pfIsAdmin)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Bool,
                "CWebJit::CheckToken",
                NULL
                ));
                
    BOOL bNewNT5check = FALSE;
    HINSTANCE hAdvapi32 = NULL;
    CHECKTOKENMEMBERSHIP pf;
    PSID AdministratorsGroup;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    hAdvapi32 = LoadLibrary("advapi32.dll");
    if (hAdvapi32)
    {
        pf = (CHECKTOKENMEMBERSHIP)GetProcAddress(hAdvapi32, "CheckTokenMembership");
        if (pf)
        {
            bNewNT5check = TRUE;
            *pfIsAdmin = FALSE;
            if(AllocateAndInitializeSid( &NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &AdministratorsGroup) )
            {
                pf(NULL, AdministratorsGroup, pfIsAdmin);
                FreeSid(AdministratorsGroup);
            }
        }
        FreeLibrary(hAdvapi32);
    }

    DEBUG_LEAVE(bNewNT5check);
    return bNewNT5check;
}

// IsNTAdmin();
// Returns true if our process has admin priviliges.
// Returns false otherwise.
BOOL IsNTAdmin()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Bool,
                "CWebJit::IsNTAdmin",
                NULL
                ));
                
    static int    fIsAdmin = 2;
    HANDLE        hAccessToken;
    PTOKEN_GROUPS ptgGroups;
    DWORD         dwReqSize;
    UINT          i;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup;
    BOOL bRet;
    OSVERSIONINFO osvi;

    //
    // If we have cached a value, return the cached value. Note I never
    // set the cached value to false as I want to retry each time in
    // case a previous failure was just a temp. problem (ie net access down)
    //

    bRet = FALSE;
    ptgGroups = NULL;

    if( fIsAdmin != 2 )
    {
        DEBUG_LEAVE(fIsAdmin);
        return (BOOL)fIsAdmin;
    }
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx(&osvi);
    if (osvi.dwPlatformId != VER_PLATFORM_WIN32_NT) 
    {
        fIsAdmin = TRUE;      // If we are not running under NT return TRUE.
        
        DEBUG_LEAVE(fIsAdmin);
        return (BOOL)fIsAdmin;
    }

    if (!CheckToken(&bRet))
    {
        if(!OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hAccessToken ) )
        {
            DEBUG_LEAVE(FALSE);
            return FALSE;
        }
        // See how big of a buffer we need for the token information
        if(!GetTokenInformation( hAccessToken, TokenGroups, NULL, 0, &dwReqSize))
        {
            // GetTokenInfo should the buffer size we need - Alloc a buffer
            if(GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                ptgGroups = (PTOKEN_GROUPS) LocalAlloc(LMEM_FIXED, dwReqSize);

        }

        // ptgGroups could be NULL for a coupla reasons here:
        // 1. The alloc above failed
        // 2. GetTokenInformation actually managed to succeed the first time (possible?)
        // 3. GetTokenInfo failed for a reason other than insufficient buffer
        // Any of these seem justification for bailing.

        // So, make sure it isn't null, then get the token info
        if(ptgGroups && GetTokenInformation(hAccessToken, TokenGroups, ptgGroups, dwReqSize, &dwReqSize))
        {
            if(AllocateAndInitializeSid( &NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &AdministratorsGroup) )
            {
                // Search thru all the groups this process belongs to looking for the
                // Admistrators Group.

                for( i=0; i < ptgGroups->GroupCount; i++ )
                {
                    if( EqualSid(ptgGroups->Groups[i].Sid, AdministratorsGroup) )
                    {
                        // Yea! This guy looks like an admin
                        fIsAdmin = TRUE;
                        bRet = TRUE;
                        break;
                    }
                }
                FreeSid(AdministratorsGroup);
            }
        }
        if(ptgGroups)
            LocalFree(ptgGroups);

        // BUGBUG: Close handle here? doc's aren't clear whether this is needed.
        CloseHandle(hAccessToken);
    }
    else if (bRet)
        fIsAdmin = TRUE;

    DEBUG_LEAVE(bRet);
    return bRet;
}

BOOL IsWin32X86()
{
    OSVERSIONINFO   osvi;
    SYSTEM_INFO   sysinfo;
    GetSystemInfo(&sysinfo);

    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx(&osvi);
    if (((osvi.dwPlatformId == VER_PLATFORM_WIN32_NT)
        || (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS))
        && (sysinfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL))
    {
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\webjit.h ===
#ifndef _WEBJIT_H_
#define _WEBJIT_H_

#include <commctrl.h>

#define WM_DOWNLOAD_DONE    WM_USER + 11
#define WM_SETUP_ERROR      WM_USER + 12
#define WM_DOWNLOAD_ERROR   WM_USER + 13
#define WM_PROCESS_ERROR    WM_USER + 14
#define WM_INTERNAL_ERROR   WM_USER + 15
#define WM_START_TIMER      WM_USER + 16
#define WM_DONT_WAIT        WM_USER + 17
#define WM_DATA_AVAILABLE   WM_USER + 18

#define SUCCESS     0   // Component successfully downloaded and installed
#define CANCELLED   2   // User canceled dialog 
#define NEVERASK    3   // User requested never to be asked to d/l this component again

#define NO_MIME_MATCH 11
#define NO_EXT_MATCH  12
#define EXEC_ERROR    13

#define TIMER_EXEC_POLL             1
#define TIMER_EXEC_POLL_INTERVAL    1000
#define TIMER_DOWNLOAD              2
#define TIMER_DOWNLOAD_INTERVAL     10

typedef enum
{
    WJSTATE_INIT,                  // obj constructed
    WJSTATE_BINDING,               // download in progress
    WJSTATE_DOWNLOADED,            // OnStopBinding called
    WJSTATE_FINISHED_READ,         // all data read
    WJSTATE_VERIFYING,             // into VerifyTrust call
    WJSTATE_READY_TO_EXEC,         // read to shell exec.
    WJSTATE_WAITING_PROCESS,       // Start DoSetup
    WJSTATE_DONE,                  // all done, ready to free obj
} WJSTATE;

class CWebJit;
typedef struct _WebJitParam
{
    LPCSTR lpszResource;
    DWORD  dwFlags;
    LPCWSTR pwszComponentId;
    CWebJit* pWebJit;
    HWND hWndParent;
    QUERYCONTEXT *pQueryInstalled;
} 
WEBJIT_PARAM;

extern IInternetSecurityManager* g_pSecurityManager;
class CWebJit : public IBindStatusCallback
              , public IAuthenticate
              , public IInternetHostSecurityManager
{
    private:
    
    // data members
    BOOL m_fInited;
    HMODULE m_hWintrustMod;
    BOOL m_fInitedCC;
    HMODULE m_hComCtlMod;
    DWORD m_dwFlags;
    LPCWSTR m_pwszComponentId;
    HWND m_hWndParent;
    QUERYCONTEXT* m_pQueryInstalled;
    
    DWORD m_cRef;
    DWORD m_dwTotal;
    DWORD m_dwCurrent;
    LPCSTR m_szResource; //don't own: don't free.
    LPWSTR m_pwszUrl;
    DWORD m_dwDownloadSpeed;

    IBindCtx* m_pbc;
    IMoniker* m_pMk;
    IStream* m_pStm;
    IBinding* m_pBinding;

    HWND m_hDialog;
    HANDLE m_hProcess;
    HANDLE m_hCacheFile;
    DWORD m_dwRetVal;

    HRESULT m_hDownloadResult;
    BOOL m_fResultIn;
    WJSTATE m_State;
    BOOL m_fAborted;
    BOOL m_fCalledAbort;
    
    HRESULT m_hrInternal;
    LPWSTR m_pwszMimeType;
    LPWSTR m_pwszRedirectUrl;
    LPWSTR m_pwszCacheFile;
    BOOL m_fHtml;
    BOOL m_fDownloadInited;
    
    #define TEMPREADBUFFERSIZE 8192
    CHAR* m_pTempBuffer;

    BOOL m_bReading;
    BOOL m_bStartedReadTimer;
    
  public:
    // constructors/destructors
    CWebJit(WEBJIT_PARAM* pWebJitParam);
    ~CWebJit();
    VOID ReleaseAll();
    
    // IUnknown methods
    STDMETHODIMP    QueryInterface(REFIID riid, void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef();
    STDMETHODIMP_(ULONG)    Release();
    
    // IBindStatusCallback methods
    STDMETHODIMP    OnStartBinding(DWORD dwReserved, IBinding* pbinding);
    STDMETHODIMP    GetPriority(LONG* pnPriority)
    {
        return S_OK;
    }
    STDMETHODIMP    OnLowResource(DWORD dwReserved)
    {
        return S_OK;
    }
    STDMETHODIMP    OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR pwzStatusText);
    STDMETHODIMP    OnStopBinding(HRESULT hrResult, LPCWSTR szError);
    STDMETHODIMP    GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindInfo);
    STDMETHODIMP    OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pfmtetc, STGMEDIUM* pstgmed);
    STDMETHODIMP    OnObjectAvailable(REFIID riid, IUnknown* punk);
    
    // IAuthenticate methods
    STDMETHODIMP Authenticate(HWND* phwnd, LPWSTR *pszUsername,LPWSTR *pszPassword);

    // IInternetHostSecurityManager
    
    STDMETHODIMP GetSecurityId( BYTE *pbSecurityId, 
                                DWORD *pcbSecurityId,
                                DWORD_PTR dwReserved)
    {
        DEBUG_ENTER((DBG_DOWNLOAD,
                    Hresult,
                    "CWebJit::GetSecurityId",
                    "this=%#x",
                    this
                    ));
                    
        HRESULT hr = E_FAIL;

        IInternetSecurityManager *pSecMgr = g_pSecurityManager;

        if (pSecMgr) 
        {
            hr = pSecMgr->GetSecurityId(m_pwszUrl, pbSecurityId,
                                         pcbSecurityId, dwReserved);
        }

        DEBUG_LEAVE(hr);
        return hr;
    }

    STDMETHODIMP ProcessUrlAction(  DWORD dwAction,
                                    BYTE *pPolicy, 
                                    DWORD cbPolicy,
                                    BYTE *pContext, 
                                    DWORD cbContext,
                                    DWORD dwFlags,
                                    DWORD dwReserved)
    {
        DEBUG_ENTER((DBG_DOWNLOAD,
                    Hresult,
                    "CWebJit::ProcessUrlAction",
                    "this=%#x, %d(%#x)",
                    this, dwAction, dwAction
                    ));
                    
        HRESULT hr = E_FAIL;

        IInternetSecurityManager *pSecMgr = g_pSecurityManager;
        
        if (pSecMgr) 
        {
            hr = pSecMgr->ProcessUrlAction(m_pwszUrl, dwAction, pPolicy,
                                            cbPolicy, pContext, cbContext,
                                            dwFlags, dwReserved);
        }

        DEBUG_LEAVE(hr);
        return hr;
    }

    STDMETHODIMP QueryCustomPolicy( REFGUID guidKey,
                                    BYTE **ppPolicy,
                                    DWORD *pcbPolicy,
                                    BYTE *pContext,
                                    DWORD cbContext,
                                    DWORD dwReserved)
    {
        DEBUG_ENTER((DBG_DOWNLOAD,
                    Hresult,
                    "CWebJit::ProcessUrlAction",
                    "this=%#x",
                    this
                    ));
                    
        HRESULT hr = E_FAIL;

        IInternetSecurityManager *pSecMgr = g_pSecurityManager;

        if (pSecMgr) 
        {
            hr = pSecMgr->QueryCustomPolicy(m_pwszUrl, guidKey, ppPolicy,
                                             pcbPolicy, pContext, cbContext,
                                             dwReserved);
        }

        DEBUG_LEAVE(hr);
        return hr;
    }

    VOID UpdateDownloadResult(HRESULT hr, BOOL fFromOnStopBinding);
    VOID ProcessFile();
    HRESULT SetupDownload();
    HRESULT StartDownload();
    HRESULT ExecFile();
    HRESULT DisplayError(HRESULT hr, UINT nMsgError);
    HRESULT VerifyMimeAndExtension();
    BOOL NeedHostSecMgr();
    HRESULT VerifyTrust(BOOL fUseHostSecMgr);
    BOOL IsConnected(BOOL* pfIsOffline);
    VOID ProcessAbort();
    VOID Terminate(DWORD iRetVal);
    HRESULT CanWebJit();
    BOOL SetupWindow();
    DWORD GetDownloadSpeed();
    BOOL UpdateProgressUI();
    VOID UpdateStatusString();
    VOID ReadData();

    BOOL IsReadTimerStarted()
    {
        return m_bStartedReadTimer;
    }

    VOID SetReadTimerStarted()
    {
        m_bStartedReadTimer = TRUE;
    }
    
    VOID SetState(WJSTATE state)
    {
        m_State = state;
    }

    WJSTATE GetState()
    {
        return m_State;
    }

    HANDLE GetProcessHandle()
    {
        return m_hProcess;
    }

    VOID SetWindowHandle(HWND hDlg)
    {
        m_hDialog = hDlg;
    }

    DWORD GetResult()
    {
        return m_dwRetVal;
    }

    LPCWSTR GetComponentIdName()
    {
        return m_pwszComponentId;
    }

    BOOL IsDownloadInited()
    {
        return m_fDownloadInited;
    }

    VOID SetDownloadInited()
    {
        m_fDownloadInited = TRUE;
    }

    BOOL IsAborted()
    {
        return m_fAborted;
    }
    
// to delayload InitCommonControlsEx
    HRESULT InitCC(void);
#define DELAYCCAPI(_fn, _args, _nargs, ret) \
    ret _fn _args \
    { \
        HRESULT hres; \
        ret retval = 0; \
        hres = InitCC(); \
        if (SUCCEEDED(hres) && (_pfn##_fn)) \
        { \
            retval = _pfn##_fn _nargs; \
        } \
        return retval; \
    } \
    ret (STDAPICALLTYPE* _pfn##_fn) _args;

    DELAYCCAPI(InitCommonControlsEx,
    (LPINITCOMMONCONTROLSEX lpInitCtrls),
    (lpInitCtrls),
    BOOL);
    BOOL CWebJit::InitCommonControlsForWebJit();

// to delayload WinVerifyTrust
    HRESULT Init(void);
#define DELAYWVTAPI(_fn, _args, _nargs) \
    HRESULT _fn _args { \
        HRESULT hres = Init(); \
        if (SUCCEEDED(hres)) { \
            hres = _pfn##_fn _nargs; \
        } \
        return hres;    } \
    HRESULT (STDAPICALLTYPE* _pfn##_fn) _args;

    DELAYWVTAPI(WinVerifyTrust,
    (HWND hwnd, GUID * ActionID, LPVOID ActionData),
    (hwnd, ActionID, ActionData));
};

INT_PTR CALLBACK WebJitProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

#endif _WEBJIT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\cdllogvw\cdlids.h ===
#define IDD_CDLLOGVIEW            10500
#define IDC_CB_VIEWLOG            10501
#define IDC_CB_REFRESH            10502
#define IDC_CB_DELETE             10503
#define IDC_LB_LOGMESSAGES        10504
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\wvtp.h ===
#ifdef __cplusplus

#include "capi.h"

// WinVerifyTrust delay load modelled on shell's urlmonp.h

#define DELAY_LOAD_WVT
extern BOOL  g_bNT5OrGreater;

class CDownload;

class Cwvt
{
    public:
#ifdef DELAY_LOAD_WVT
#define DELAYWVTAPI(_fn, _args, _nargs) \
    HRESULT _fn _args { \
        HRESULT hres = Init(); \
        if (SUCCEEDED(hres)) { \
            hres = _pfn##_fn _nargs; \
        } \
        return hres;    } \
    HRESULT (STDAPICALLTYPE* _pfn##_fn) _args;

/*
 * Should be called only for NT5 or greater for catalog verification and installation.
 */
#define DELAYNT5API(_fn, _args, _nargs, ret) \
    ret _fn _args \
    { \
        HRESULT hres; \
        ret retval = 0; \
        if (g_bNT5OrGreater) \
        { \
            hres = Init(); \
            if (SUCCEEDED(hres) && (_pfn##_fn)) \
            { \
                retval = _pfn##_fn _nargs; \
            } \
        } \
        return retval; \
    } \
    ret (STDAPICALLTYPE* _pfn##_fn) _args;
    
    HRESULT     Init(void);
    Cwvt();
    ~Cwvt();

    BOOL    m_fInited;
    HMODULE m_hMod;
#else
#define DELAYWVTAPI(_fn, _args, _nargs) \
    HRESULT _fn _args { \
            HRESULT hr = ::#_fn _nargs; \
            }
#endif

    private:
    DELAYWVTAPI(WinVerifyTrust,
    (HWND hwnd, GUID * ActionID, LPVOID ActionData),
    (hwnd, ActionID, ActionData));
    
    DELAYNT5API(IsCatalogFile,
    (HANDLE hFile, WCHAR* pwszFileName),
    (hFile, pwszFileName),
    BOOL);
    DELAYNT5API(CryptCATAdminAcquireContext,
    (HCATADMIN* phCatAdmin, GUID* pgSubsystem, DWORD dwFlags),
    (phCatAdmin, pgSubsystem, dwFlags),
    BOOL);
    DELAYNT5API(CryptCATAdminReleaseContext,
    (HCATADMIN hCatAdmin, DWORD dwFlags),
    (hCatAdmin, dwFlags),
    BOOL);
    DELAYNT5API(CryptCATAdminReleaseCatalogContext,
    (HCATADMIN hCatAdmin, HCATINFO hCatInfo, DWORD dwFlags),
    (hCatAdmin, hCatInfo, dwFlags),
    BOOL);
    DELAYNT5API(CryptCATAdminEnumCatalogFromHash,
    (HCATADMIN hCatAdmin, BYTE* pbHash, DWORD cbHash, DWORD dwFlags, HCATINFO* phPrevCatInfo),
    (hCatAdmin, pbHash, cbHash, dwFlags, phPrevCatInfo),
    HCATINFO);
    DELAYNT5API(CryptCATAdminCalcHashFromFileHandle,
    (HANDLE hFile, DWORD* pcbHash, BYTE* pbHash, DWORD dwFlags),
    (hFile, pcbHash, pbHash, dwFlags),
    BOOL);
    DELAYNT5API(CryptCATAdminAddCatalog,
    (HCATADMIN hCatAdmin, WCHAR* pwszCatalogFile, WCHAR* pwszSelectBaseName, DWORD dwFlags),
    (hCatAdmin, pwszCatalogFile, pwszSelectBaseName, dwFlags),
    HCATINFO);
    DELAYNT5API(CryptCATAdminRemoveCatalog,
    (HCATADMIN hCatAdmin, WCHAR* pwszCatalogFile, DWORD dwFlags),
    (hCatAdmin, pwszCatalogFile, dwFlags),
    BOOL);
    DELAYNT5API(CryptCATCatalogInfoFromContext,
    (HCATINFO hCatInfo, CATALOG_INFO* psCatInfo, DWORD dwFlags),
    (hCatInfo, psCatInfo, dwFlags),
    BOOL);
    DELAYNT5API(CryptCATAdminResolveCatalogPath,
    (HCATADMIN hCatAdmin, WCHAR* pwszCatalogFile, CATALOG_INFO* psCatInfo, DWORD dwFlags),
    (hCatAdmin, pwszCatalogFile, psCatInfo, dwFlags),
    BOOL);
     
    public:
    HRESULT VerifyTrust(HANDLE hFile, HWND hWnd, PJAVA_TRUST *ppJavaTrust,
                        LPCWSTR szStatusText, 
                        IInternetHostSecurityManager *pHostSecurityManager,
                        LPSTR szFilePath, LPSTR szCatalogFile,
                        CDownload *pdl);

    /*
        return value:
        S_OK - all ok.
        S_FALSE - failed to get full path back but file verified.
        E_FAIL - all other.
     */
     HRESULT Cwvt::VerifyFileAgainstSystemCatalog(LPCSTR pcszFile, LPWSTR pwszFullPathCatalogFile, DWORD* pdwBuffer);

    /*
        return value:
        from WinVerifyTrust
     */
    HRESULT VerifyTrustOnCatalogFile(LPCWSTR pwszCatalogFile);
    
    /*
        return value:
        S_OK - all ok.
        E_FAIL - either not valid catalog file or failed trust
     */
    HRESULT IsValidCatalogFile(LPCWSTR pwszCatalogFile);
    
    /*
        return value:
        S_OK - all ok.
        S_FALSE - failed to remove catalog.
     */
    HRESULT UninstallCatalogFile(LPWSTR pwszFullPathCatalogFile);
    
    /*
        return value:
        S_OK - all ok.
        S_FALSE - AddCatalog succeeded, but getting fullPathofCatfile failed.
        E_FAIL - any other failure
     */
    HRESULT InstallCatalogFile(LPSTR pszCatalogFile);

    HRESULT WinVerifyTrust_Wrap(HWND hwnd, GUID * ActionID, WINTRUST_DATA* ActionData);
    private:
    BOOL                     m_bHaveWTData;
    WINTRUST_CATALOG_INFO    m_wtCatalogInfo;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\wvt.cxx ===
#include <cdlpch.h>
#include <softpub.h>

#define WINTRUST TEXT("wintrust.dll")

#ifdef DELAY_LOAD_WVT

#ifndef _WVTP_NOCODE_
Cwvt::Cwvt()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "Cwvt::Cwvt",
                "this=%#x",
                this
                ));
                
    m_fInited = FALSE;
    m_bHaveWTData = FALSE;

    DEBUG_LEAVE(0);
}

Cwvt::~Cwvt()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "Cwvt::~Cwvt",
                "this=%#x",
                this
                ));
                
    if (m_fInited) {
        FreeLibrary(m_hMod);
    }

    DEBUG_LEAVE(0);
}

HRESULT 
Cwvt::Init(void)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "Cwvt::Init",
                "this=%#x",
                this
                ));
                
    GUID PublishedSoftware = WIN_SPUB_ACTION_PUBLISHED_SOFTWARE;
    GUID *ActionID = &PublishedSoftware;


    if (m_fInited) {
    
        DEBUG_LEAVE(S_OK);
        return S_OK;
    }

    m_hMod = LoadLibrary( WINTRUST );

    if (NULL == m_hMod) {
    
        DEBUG_LEAVE(HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND));
        return (HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND));
    }


#define CHECKAPI(_fn) \
    *(FARPROC*)&(_pfn##_fn) = GetProcAddress(m_hMod, #_fn); \
    if (!(_pfn##_fn)) { \
        FreeLibrary(m_hMod); \
        \
        DEBUG_LEAVE(HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND)); \
        return (HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND)); \
    }

    CHECKAPI(WinVerifyTrust);

    if (g_bNT5OrGreater)
    {
#define CHECKNT5API(_fn) \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(m_hMod, #_fn);
        
        CHECKNT5API(IsCatalogFile);
        CHECKNT5API(CryptCATAdminAcquireContext);
        CHECKNT5API(CryptCATAdminReleaseContext);
        CHECKNT5API(CryptCATAdminReleaseCatalogContext);
        CHECKNT5API(CryptCATAdminEnumCatalogFromHash);
        CHECKNT5API(CryptCATAdminCalcHashFromFileHandle);
        CHECKNT5API(CryptCATAdminAddCatalog);
        CHECKNT5API(CryptCATAdminRemoveCatalog);
        CHECKNT5API(CryptCATCatalogInfoFromContext);
        CHECKNT5API(CryptCATAdminResolveCatalogPath);
    }

    m_fInited = TRUE;
    
    DEBUG_LEAVE(S_OK);
    return S_OK;
}

BOOL
IsUIRestricted()
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Bool,
                "IsUIRestricted",
                NULL
                ));

    HKEY hkeyRest = 0;
    BOOL bUIRest = FALSE;
    DWORD dwValue = 0;
    DWORD dwLen = sizeof(DWORD);

    // per-machine UI off policy
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_INFODEL_REST, 0, KEY_READ, &hkeyRest) == ERROR_SUCCESS) {

        if (RegQueryValueEx( hkeyRest, REGVAL_UI_REST, NULL, NULL,
                      (LPBYTE)&dwValue, &dwLen) == ERROR_SUCCESS && dwValue)
            bUIRest = TRUE;

        RegCloseKey(hkeyRest);
    }
    
    DEBUG_LEAVE(bUIRest);
    return bUIRest;
}

#endif // _WVTP_NOCODE_
#endif // DELAY_LOAD_WVT

// {D41E4F1D-A407-11d1-8BC9-00C04FA30A41}
#define COR_POLICY_PROVIDER_DOWNLOAD \
{ 0xd41e4f1d, 0xa407, 0x11d1, {0x8b, 0xc9, 0x0, 0xc0, 0x4f, 0xa3, 0xa, 0x41 } }

#define ZEROSTRUCT(arg)  memset( &arg, 0, sizeof(arg))

void PrintHash(BYTE* pbHash, DWORD cbHash)
{
    LPSTR pszHash = NULL;
    
    if (cbHash)
    {
        char* pHexTable = "0123456789ABCDEF";
        pszHash = new CHAR[2*cbHash+1];

        if (!pszHash)
            goto End;

        for (DWORD i=0; i<cbHash; i++)
        {
            pszHash[2*i] = pHexTable[(pbHash[i]&0xf0)>>4];
            pszHash[2*i+1] = pHexTable[pbHash[i]&0x0f];
        }
        pszHash[2*i] = '\0';
    }
    
    DEBUG_ENTER((DBG_DOWNLOAD,
                None,
                "PrintHash",
                "%d, %.80q",
                cbHash, (pszHash?pszHash:"NULL")
                ));

    DEBUG_LEAVE(0);

    if(pszHash)
        delete [] pszHash;
    
End:
    return;
}

HRESULT Cwvt::WinVerifyTrust_Wrap(HWND hwnd, GUID * ActionID, WINTRUST_DATA* ActionData)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "EXTERNAL::WinVerifyTrust",
                "%#x, %#x, %#x",
                hwnd, ActionID, ActionData
                ));
    HRESULT hr;

    hr = WinVerifyTrust(hwnd, ActionID, ActionData);

    DEBUG_LEAVE(hr);
    return hr;
}
#ifdef DBG
#define PRINT_HASH(pbHash, cbHash) PrintHash((pbHash),(cbHash))
#else
#define PRINT_HASH(pbHash, cbHash) {}
#endif


HRESULT Cwvt::VerifyTrust(HANDLE hFile, HWND hWnd, PJAVA_TRUST *ppJavaTrust,
                          LPCWSTR szStatusText,
                          IInternetHostSecurityManager *pHostSecurityManager,
                          LPSTR szFilePath, LPSTR szCatalogFile,
                          CDownload *pdl) 
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "Cwvt::VerifyTrust",
                "this=%#x, %#x, %#x, %#x, %.80wq, %#x, %.80q, %#x=%.80q, %#x",
                this, hFile, hWnd, ppJavaTrust, szStatusText, pHostSecurityManager,
                szFilePath, szCatalogFile, szCatalogFile, pdl
                ));
                
    LPWSTR                   wzFileName = NULL;
    LPWSTR                   wzFilePath = NULL;
    LPWSTR                   wzCatalogFile = NULL;
    GUID                     guidJava = JAVA_POLICY_PROVIDER_DOWNLOAD;
    GUID                     guidCor = COR_POLICY_PROVIDER_DOWNLOAD;
    GUID                     guidAuthenticode = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    GUID                    *pguidActionIDJava = &guidJava;
    GUID                    *pguidActionIDCor = &guidCor;
    WINTRUST_DATA            wintrustData;
    WINTRUST_DATA            wtdAuthenticode;
    WINTRUST_FILE_INFO       fileData;
    JAVA_POLICY_PROVIDER     javaPolicyData;
    WCHAR                    wpath [MAX_PATH];
    PJAVA_TRUST              pbJavaTrust = NULL;
    IServiceProvider        *pServProv = NULL;
    LPCATALOGFILEINFO        pcfi = NULL;
    HRESULT                  hr = S_OK;

    ZEROSTRUCT(wintrustData);
    ZEROSTRUCT(fileData);
    ZEROSTRUCT(javaPolicyData);

    javaPolicyData.cbSize = sizeof(JAVA_POLICY_PROVIDER);
    javaPolicyData.VMBased = FALSE;
    javaPolicyData.fNoBadUI = FALSE;

    javaPolicyData.pwszZone = szStatusText;
    javaPolicyData.pZoneManager = (LPVOID)pHostSecurityManager;


    fileData.cbStruct = sizeof(WINTRUST_FILE_INFO);
    fileData.pcwszFilePath = szStatusText;
    fileData.hFile = hFile;

    wintrustData.cbStruct = sizeof(WINTRUST_DATA);
    wintrustData.pPolicyCallbackData = &javaPolicyData;

    if ( (hWnd == INVALID_HANDLE_VALUE) || IsUIRestricted())
        wintrustData.dwUIChoice = WTD_UI_NONE;
    else
        wintrustData.dwUIChoice = WTD_UI_ALL;

    wintrustData.dwUnionChoice = WTD_CHOICE_FILE;
    wintrustData.pFile = &fileData;

    if (szCatalogFile) {
        ::Ansi2Unicode(szCatalogFile, &wzCatalogFile);
        ::Ansi2Unicode(szFilePath, &wzFilePath);
        wzFileName = PathFindFileNameW(szStatusText);

        if (!m_bHaveWTData) {
            memset(&m_wtCatalogInfo, 0x0, sizeof(m_wtCatalogInfo));
            m_wtCatalogInfo.cbStruct = sizeof(WINTRUST_CATALOG_INFO);
            m_bHaveWTData = TRUE;
        }
        m_wtCatalogInfo.pcwszCatalogFilePath = wzCatalogFile;
        m_wtCatalogInfo.pcwszMemberTag = wzFileName;
        m_wtCatalogInfo.pcwszMemberFilePath = wzFilePath;

        wtdAuthenticode = wintrustData;
        wtdAuthenticode.pCatalog = &m_wtCatalogInfo;
        wtdAuthenticode.dwUnionChoice = WTD_CHOICE_CATALOG;
        wtdAuthenticode.dwStateAction = WTD_STATEACTION_VERIFY;
        wtdAuthenticode.dwUIChoice = WTD_UI_NONE;

        hr = WinVerifyTrust_Wrap(hWnd, &guidAuthenticode, &wtdAuthenticode);
        if (FAILED(hr)) {
            hr = WinVerifyTrust_Wrap(hWnd, pguidActionIDCor, &wintrustData);

            if (hr == TRUST_E_PROVIDER_UNKNOWN)
                hr = WinVerifyTrust_Wrap(hWnd, pguidActionIDJava, &wintrustData);
        }
        else {
            // Clone Java permissions
            pbJavaTrust = pdl->GetCodeDownload()->GetJavaTrust();
            if (!pbJavaTrust) {
                hr = pdl->GetBSC()->QueryInterface(IID_IServiceProvider, (void **)&pServProv);
                if (SUCCEEDED(hr)) {
                    hr = pServProv->QueryService(IID_ICatalogFileInfo, IID_ICatalogFileInfo, (void **)&pcfi);
                    if (SUCCEEDED(hr)) {
                        pcfi->GetJavaTrust((void **)&pbJavaTrust);
                    }
                }
                SAFERELEASE(pServProv);
                SAFERELEASE(pcfi);
                pdl->SetMainCABJavaTrustPermissions(pbJavaTrust);
            }
        }
            
    }
    else {
        hr =  WinVerifyTrust_Wrap(hWnd, pguidActionIDCor, &wintrustData);
        if (hr == TRUST_E_PROVIDER_UNKNOWN)
            hr = WinVerifyTrust_Wrap(hWnd, pguidActionIDJava, &wintrustData);

        if (SUCCEEDED(hr)) {
            pdl->SetMainCABJavaTrustPermissions(javaPolicyData.pbJavaTrust);
        }
    }

    SAFEDELETE(wzCatalogFile);
    SAFEDELETE(wzFilePath);

    // BUGBUG: this works around a wvt bug that returns 0x57 (success) when
    // you hit No to an usigned control
    if (SUCCEEDED(hr) && hr != S_OK) {
        hr = TRUST_E_FAIL;
    }

    if (FAILED(hr)) {
        // display original hr intact to help debugging
//        CodeDownloadDebugOut(DEB_CODEDL, TRUE, ID_CDLDBG_VERIFYTRUST_FAILED, hr);
    } else {
        *ppJavaTrust = javaPolicyData.pbJavaTrust;
    }
    if (hr == TRUST_E_SUBJECT_NOT_TRUSTED && wintrustData.dwUIChoice == WTD_UI_NONE) {
        // if we didn't ask for the UI to be out up there has been no UI
        // work around WVT bvug that it returns us this special error code
        // without putting up UI.

        hr = TRUST_E_FAIL; // this will put up mshtml ui after the fact
                           // that security settings prevented us
    }

    if (FAILED(hr) && (hr != TRUST_E_SUBJECT_NOT_TRUSTED)) {

        // trust system has failed without UI

        // map error to this generic error that will falg our client to put
        // up additional info that this is a trust system error if reqd.
        hr = TRUST_E_FAIL;
    }

    if (hr == TRUST_E_SUBJECT_NOT_TRUSTED) {

        pdl->GetCodeDownload()->SetUserDeclined();
    }

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT
Cwvt::VerifyTrustOnCatalogFile(IN LPCWSTR pwszCatalogFile)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "Cwvt::VerifyTrustOnCatalogFile",
                "this=%#x, %.200wq",
                this, pwszCatalogFile
                ));
                
    HRESULT hr = NOERROR;
    WINTRUST_DATA WintrustData;
    WINTRUST_FILE_INFO WintrustFileInfo;
    GUID guidDriverActionVerify = DRIVER_ACTION_VERIFY;

    ZeroMemory(&WintrustData, sizeof(WINTRUST_DATA));
    WintrustData.cbStruct = sizeof(WINTRUST_DATA);
    WintrustData.dwUIChoice = WTD_UI_NONE;
    WintrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
    WintrustData.dwUnionChoice = WTD_CHOICE_FILE;
    WintrustData.pFile = &WintrustFileInfo;
    WintrustData.dwProvFlags = WTD_REVOCATION_CHECK_NONE;
    
    ZeroMemory(&WintrustFileInfo, sizeof(WINTRUST_FILE_INFO));
    WintrustFileInfo.cbStruct = sizeof(WINTRUST_FILE_INFO);

    WintrustFileInfo.pcwszFilePath = pwszCatalogFile;

    hr = WinVerifyTrust_Wrap(NULL, &guidDriverActionVerify, &WintrustData);

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT Cwvt::IsValidCatalogFile(LPCWSTR pwszCatalogFile)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "Cwvt::IsValidCatalogFile",
                "this=%#x, %.200wq",
                this, pwszCatalogFile
                ));    
                
    HRESULT hr = E_FAIL;

    DWORD cbLen = lstrlenW(pwszCatalogFile);
    WCHAR* pwszCatalogFileCopy = new WCHAR[cbLen+1];

    if (pwszCatalogFileCopy)
    {
        StrCpyW(pwszCatalogFileCopy, pwszCatalogFile);

        // IsCatalogFile doesn't take LPCWSTR, only a LPWSTR - may mangle url.
        if(IsCatalogFile(NULL, pwszCatalogFileCopy))
        {
            StrCpyW(pwszCatalogFileCopy, pwszCatalogFile);
            hr = VerifyTrustOnCatalogFile(pwszCatalogFile);
        }
    }

    delete [] pwszCatalogFileCopy;
    
    DEBUG_LEAVE(hr);
    return hr;
}

/*
    return value:
    S_OK - all ok.
    S_FALSE - AddCatalog succeeded, but getting Cataloginfo failed.
    E_FAIL - any other failure
 */
HRESULT Cwvt::InstallCatalogFile(LPSTR pszCatalogFile)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "Cwvt::InstallCatalogFile",
                "this=%#x, %.200q",
                this, pszCatalogFile
                ));
                
    WCHAR* pwszCatalogFile = NULL;
    HRESULT hr;
    HCATADMIN hCatAdmin;	
    GUID guidDriverActionVerify = DRIVER_ACTION_VERIFY;

    hr = Ansi2Unicode(pszCatalogFile, &pwszCatalogFile);
    
    if(SUCCEEDED(hr) 
        && SUCCEEDED(hr = IsValidCatalogFile(pwszCatalogFile))
        && CryptCATAdminAcquireContext(&hCatAdmin, &guidDriverActionVerify, 0))
    {
        HCATINFO hCatInfo;
        CATALOG_INFO CatalogInfo;

        hCatInfo = CryptCATAdminAddCatalog(hCatAdmin, pwszCatalogFile, NULL, 0);

        if (hCatInfo)
        {
            CatalogInfo.cbStruct = sizeof(CATALOG_INFO);
            if (CryptCATCatalogInfoFromContext(hCatInfo, &CatalogInfo, 0))
            {
#ifdef DBG
                DEBUG_PRINT(DOWNLOAD, 
                            INFO,
                            ("Cwvt::InstallCatalogFile: cat_filename: %.200wq \n",
                            (CatalogInfo.wszCatalogFile ? CatalogInfo.wszCatalogFile : L"NULL")
                            ));
#endif

             /* can get name and full path of catalog file if need be
                StrCpyW(pwszFullPathCatalogFile, CatalogInfo.wszCatalogFile);
              */
                hr = S_OK;
            }
            else
            {
                hr = S_FALSE;
            }
            
            CryptCATAdminReleaseCatalogContext(hCatAdmin, hCatInfo, 0);
        }
        else
        {
            hr = E_FAIL;
        }
        
        CryptCATAdminReleaseContext(hCatAdmin, 0);
    }
    else
    {
        hr = E_FAIL;
    }

    if (pwszCatalogFile)
        delete [] pwszCatalogFile;
    
    DEBUG_LEAVE(hr);
    return hr;
}

// This function verifies the specified file against the database in the 
// specified subsystem.
// NOTE: *pdwBuffer = count of *WIDECHARs* in pwszFullPathCatalogFile.
HRESULT Cwvt::VerifyFileAgainstSystemCatalog(LPCSTR pcszFile, LPWSTR pwszFullPathCatalogFile, DWORD* pdwBuffer)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "Cwvt::VerifyFileAgainstSystemCatalog",
                "this=%#x, %.90q, %.90wq, %#x[%d]",
                this, pcszFile, pwszFullPathCatalogFile, pdwBuffer, (pdwBuffer?*pdwBuffer:0)
                ));

    HCATADMIN hAdmin = NULL ;
    HRESULT hr = E_FAIL;
    BOOL fOK = FALSE;
    HANDLE hFile = NULL ;
    DWORD cbHash;
    BYTE* pbHash = NULL;
    HCATINFO hCatInfo = NULL ;
    GUID guidDriverActionVerify = DRIVER_ACTION_VERIFY;

    DEBUG_ENTER((DBG_DOWNLOAD,
                Dword,
                "EXTERNAL::CreateFile",
                "%.80q",
                pcszFile
                ));

    // Open the file for read-only access
    hFile = CreateFile(
                    pcszFile,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    ) ;

    DEBUG_LEAVE(hFile);

    if (INVALID_HANDLE_VALUE != hFile)
    {
        // Acquire a catalog context
        fOK = CryptCATAdminAcquireContext(
                                        &hAdmin,
                                        &guidDriverActionVerify,
                                    	0
                                    	) ;
        if (fOK)
        {
            // Determine the hash of the file
            fOK  = CryptCATAdminCalcHashFromFileHandle(
                                                    hFile,
                                                    &cbHash,
                                                    NULL,
                                                    0
                                                    );

            DEBUG_ENTER((DBG_DOWNLOAD,
                        Bool,
                        "CryptCATAdminCalcHashFromFileHandle",
                        "%d",
                        cbHash)
                        );

            DEBUG_LEAVE(fOK);

            if (fOK && (pbHash = new BYTE[cbHash]))
            {
                fOK  = CryptCATAdminCalcHashFromFileHandle(
                                                        hFile,
                                                        &cbHash,
                                                        pbHash,
                                                        0
                                                        ) ;

                PRINT_HASH(pbHash, cbHash);

                if (fOK)
                {
                    // Find the first catalog that contains this hash
                    hCatInfo = CryptCATAdminEnumCatalogFromHash(
                                                            hAdmin,
                                                            pbHash,
                                                            cbHash,
                                                            0,
                                                            NULL
                                                            ) ;

                    if (hCatInfo)	// A catalog was found
                    {
                        hr = S_OK;
                        CATALOG_INFO CatalogInfo;

                        if (pwszFullPathCatalogFile)
                        {
                            CatalogInfo.cbStruct = sizeof(CATALOG_INFO);
                            DWORD dwLen = 0;

                            if (CryptCATCatalogInfoFromContext(hCatInfo, &CatalogInfo, 0)
                                && pdwBuffer)
                            {
                                if (CatalogInfo.wszCatalogFile
                                    && ((dwLen = lstrlenW(CatalogInfo.wszCatalogFile)) <= *pdwBuffer))
                                {
                                    StrCpyW(pwszFullPathCatalogFile, CatalogInfo.wszCatalogFile);
                                }
                                else
                                {
                                    hr = S_FALSE;
                                    *pdwBuffer = dwLen+1;
                                }
                            }
                        }
#ifdef DBG
                        {
                            CatalogInfo.cbStruct = sizeof(CATALOG_INFO);

                            if (CryptCATCatalogInfoFromContext(hCatInfo, &CatalogInfo, 0))
                            {
                                DEBUG_PRINT(DOWNLOAD, 
                                            INFO,
                                            ("Cwvt::VerifyFileAgainstSystemCatalog: cat_filename: %.200wq \n",
                                            (CatalogInfo.wszCatalogFile ? CatalogInfo.wszCatalogFile : L"NULL")
                                            ));
                            }
                            
                        }
#endif

                        CryptCATAdminReleaseCatalogContext(
                                                        hAdmin,
                                                        hCatInfo,
                                                        0
                                                        ) ;
                    }//hCatInfo
                }//fOK
            }//(fOK && (pbHash = new BYTE[cbHash]))

            CryptCATAdminReleaseContext( hAdmin, 0 ) ;
        }//fOK

        CloseHandle( hFile ) ;
    }//(INVALID_HANDLE_VALUE != hFile)

    if (pbHash)
        delete [] pbHash;

    DEBUG_LEAVE(hr);
    return hr ;
}

/*
    return value:
    S_OK - all ok.
    S_FALSE - failed to remove catalog.
 */
HRESULT Cwvt::UninstallCatalogFile(LPWSTR pwszCatalogFile)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "Cwvt::UninstallCatalogFile",
                "this=%#x, %.90wq",
                this, pwszCatalogFile
                ));
                
    HRESULT hr = S_FALSE;
    HCATADMIN hCatAdmin;
    GUID guidDriverActionVerify = DRIVER_ACTION_VERIFY;

    if (CryptCATAdminAcquireContext(&hCatAdmin, &guidDriverActionVerify, 0))
    {
        if(CryptCATAdminRemoveCatalog(hCatAdmin, pwszCatalogFile, 0))
        {
            hr = S_OK;
        }
        
        CryptCATAdminReleaseContext(hCatAdmin, 0);
    }

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT GetActivePolicy(IInternetHostSecurityManager* pZoneManager, 
                        LPCWSTR pwszZone,
                        DWORD  dwUrlAction,
                        DWORD& dwPolicy,
                        BOOL fEnforceRestricted)
{
    DEBUG_ENTER((DBG_DOWNLOAD,
                Hresult,
                "GetActivePolicy",
                "%#x, %.80wq, %#x, %#x, #B",
                pZoneManager, pwszZone, dwUrlAction, &dwPolicy, fEnforceRestricted
                ));
                
    HRESULT hr = TRUST_E_FAIL;
    HRESULT hr2 = TRUST_E_FAIL;
    DWORD cbPolicy = sizeof(DWORD);

    // Policy are ordered such that high numbers are the most conservative 
    // and the lower numbers are less conservative

    DWORD dwDocumentPolicy = URLPOLICY_ALLOW;
    DWORD dwUrlPolicy = URLPOLICY_ALLOW;
    
    // We are going for the most conservative so lets set the 
    // value to the least conservative
    dwPolicy = URLPOLICY_ALLOW;

    IInternetSecurityManager* iSM = NULL;
    DWORD dwPUAflags = fEnforceRestricted ? PUAF_ENFORCERESTRICTED : 0;

    // Ask the document base for its policy
    if(pZoneManager) { //  Given a IInternetHostSecurityManager
        hr = pZoneManager->ProcessUrlAction(dwUrlAction,
                                            (PBYTE) &dwDocumentPolicy,
                                            cbPolicy,
                                            NULL,
                                            0,
                                            dwPUAflags | PUAF_NOUI,
                                            0);
    }
    
    // Get the policy for the URL 
    if(pwszZone) { // Create an IInternetSecurityManager
        hr2 = CoInternetCreateSecurityManager(NULL,
                                              &iSM,
                                              0);
        if(hr2 == S_OK) { // We got the manager so get the policy info
            hr2 = iSM->ProcessUrlAction(pwszZone,
                                        dwUrlAction,
                                        (PBYTE) &dwUrlPolicy,
                                        cbPolicy,
                                        NULL,
                                        0,
                                        dwPUAflags | PUAF_NOUI,
                                        0);
            iSM->Release();
        }
        else 
            iSM = NULL;
    }

    // if they both failed and we have zones then set it to deny and return an error
    if(FAILED(hr) && FAILED(hr2)) {
        // If we failed because there are on zones then lets QUERY
        // BUGBUG: we should actually try to get the IE30 security policy here.
        if(iSM == NULL && pZoneManager == NULL) {
            dwPolicy = URLPOLICY_QUERY;
            hr = S_OK;
        }
        else {
            dwPolicy = URLPOLICY_DISALLOW;
            hr = TRUST_E_FAIL;
        }
    }
    else {
        if(SUCCEEDED(hr))
            dwPolicy = dwDocumentPolicy;
        if(SUCCEEDED(hr2))
            dwPolicy = dwPolicy > dwUrlPolicy ? dwPolicy : dwUrlPolicy;

        if (dwPolicy == URLPOLICY_DISALLOW)
            hr = TRUST_E_FAIL;
        else
            hr = S_OK;
    }

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\webjitres.h ===
/*
 *
 *  IMPORTANT IMPORTANT IMPORTANT
 *
 */
//inetcore\urlmon\download\webjitres.h and shell\cpls\inetcpl\webjitres.h need to be IDENTICAL.

#ifndef IDC_STATIC
#define IDC_STATIC                      -1
#endif
#define IDC_PROGRESS1                   20000
#define IDC_CHECK1                      20001
#define IDC_TEXT                        20002
#define IDB_BITMAP1                     20003
#define IDC_ICON1                       20004
#define IDC_REMAINING_SIZE              20005
#define IDC_REMAINING_TIME              20006

#define IDS_DOWNLOAD_MSG                20201
#define IDS_ERROROCCURED                20202
#define IDS_JAVAVMJIT                   20203
#define IDS_MEDIAPLAYER                 20204

#define IDS_MISSINGCOMPONENTNAME        20301
#define IDS_REINSTALL                   20302
#define IDS_DIALOGERROR                 20303
#define IDS_DIALOGERROR2                20304
#define IDS_WARNINGINSTALLING           20305
#define IDS_ALTWARNINGDOWNLOAD          20306
#define IDS_ALTLANGUAGEDOWNLOAD         20307
#define IDS_DLFAIL                      20308
#define IDS_INSTALLFAIL                 20309
#define IDS_SERVERERROR                 20310
#define IDS_UNKNOWNERROR                20311
#define IDS_PRODUCTUPDATES              20312
#define IDS_NOTCONNECTED                20313
#define IDS_CERTREFUSE                  20314
#define IDS_IBUSY                       20315
#define IDS_SECURITYHIGH                20316
#define IDS_SECURITYHIGH1               20317
#define IDS_SECURITYHIGH2               20318
#define IDS_SECURITYHIGH3               20319
#define IDS_OFFLINEALERT                20320
#define IDS_OFFLINEALERT2               20321
#define IDS_ADMINRIGHTS                 20322
#define IDS_PLATFORMNOT                 20323
#define IDS_INTERNAL                    20324
#define IDS_SETUP                       20325
#define IDS_PROCESS                     20326
#define IDS_KILOBYTES_TEXT              20327
#define IDS_MEGABYTE_TEXT               20328
#define IDS_MINUTES_TEXT                20329
#define IDS_LessThanAMinute_TEXT        20330
#define IDS_hr1_TEXT                    20331
#define IDS_hrs_TEXT                    20332
#define IDS_SIZE                        20333
#define IDS_TIME                        20334
#define IDS_DOWNLOADING                 20335
#define IDS_INSTALLING                  20336
#define IDS_CHECKTRUST                  20337
#define IDS_ERRORTITLE                  20338
#define IDS_WEBJITHELPFILE              20339

#define IDD_WEBJIT                      20440

#define IDDOWNLOAD                      20441
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\download\cdllogvw\cdllogvw.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cdllogvw.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    25 Mar 97   t-alans (Alan Shi)   Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <shlwapi.h>
#include <shellapi.h>
#include <wininet.h>
#include "cdlids.h"
#include "wininet.h"

#define URL_SEARCH_PATTERN             "?CodeDownloadErrorLog"
#define DELIMITER_CHAR                 '!'
#define MAX_CACHE_ENTRY_INFO_SIZE      2048

LRESULT CALLBACK DlgProc( HWND, UINT, WPARAM, LPARAM );
void ViewLogEntry( HWND hwnd );
void RefreshLogView( HWND hwnd );
void DeleteLogEntry( HWND hwnd );

HINSTANCE hInst;

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow )
{
    hInst = hInstance;
    DialogBox( hInstance, MAKEINTRESOURCE(IDD_CDLLOGVIEW), NULL, DlgProc );

    return( 0 );
}

LRESULT CALLBACK DlgProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam )
{
    switch( iMsg ) {
        case WM_INITDIALOG:
            RefreshLogView( hwnd );
            return TRUE;

        case WM_COMMAND:
            switch( LOWORD( wParam ) ) {
                case IDCANCEL:
                    EndDialog( hwnd, 0 );
                    break;
                case IDC_CB_VIEWLOG:
                    ViewLogEntry( hwnd );
                    break;
                case IDC_CB_REFRESH:
                    RefreshLogView( hwnd );
                    break;
                case IDC_CB_DELETE:
                    DeleteLogEntry( hwnd );
                    break;
                case IDC_LB_LOGMESSAGES:
                    switch( HIWORD( wParam ) ) {
                        case LBN_DBLCLK:
                            ViewLogEntry( hwnd );
                            break;
                    }                                                

            }
            return( TRUE );
    }

    return( FALSE );
}

void DeleteLogEntry( HWND hwnd )
{
    static char                     szUrlBuffer[INTERNET_MAX_URL_LENGTH];
    char                            szUrl[INTERNET_MAX_URL_LENGTH];
    LPINTERNET_CACHE_ENTRY_INFO     pCacheEntryInfo = NULL;
    DWORD                           dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
    static char                     pBuffer[MAX_CACHE_ENTRY_INFO_SIZE];
    int                             iIndex = 0;
    int                             iLength = 0;

    iIndex = SendDlgItemMessage( hwnd, IDC_LB_LOGMESSAGES,
                                 LB_GETCURSEL, 0, 0 );
    iLength = SendDlgItemMessage( hwnd, IDC_LB_LOGMESSAGES,
                                  LB_GETTEXTLEN, iIndex, 0 );                                                        
    SendDlgItemMessage( hwnd, IDC_LB_LOGMESSAGES,
                        LB_GETTEXT, iIndex, (LPARAM)szUrl );
    
    pCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)pBuffer;
    dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
    wnsprintf( szUrlBuffer, sizeof(szUrlBuffer)-1, "%s%c%s", URL_SEARCH_PATTERN, DELIMITER_CHAR, szUrl );
    if( DeleteUrlCacheEntry( szUrlBuffer ) ) {
        RefreshLogView( hwnd );
    } else {
        MessageBox( hwnd, "Error: Unable to delete cache file!",
                    "Log View Error", MB_OK | MB_ICONERROR );
    }
}

void ViewLogEntry( HWND hwnd )
{
    int                             iIndex = 0;
    int                             iLength = 0;
    static char                     pBuffer[MAX_CACHE_ENTRY_INFO_SIZE];
    DWORD                           dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
    LPINTERNET_CACHE_ENTRY_INFO     pCacheEntryInfo = NULL;
    char                            szUrl[INTERNET_MAX_URL_LENGTH];
    static char                     szUrlBuffer[INTERNET_MAX_URL_LENGTH];

    iIndex = SendDlgItemMessage( hwnd, IDC_LB_LOGMESSAGES,
                                 LB_GETCURSEL, 0, 0 );
    iLength = SendDlgItemMessage( hwnd, IDC_LB_LOGMESSAGES,
                                  LB_GETTEXTLEN, iIndex, 0 );                                                        
    SendDlgItemMessage( hwnd, IDC_LB_LOGMESSAGES,
                        LB_GETTEXT, iIndex, (LPARAM)szUrl );
    
    pCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)pBuffer;
    dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
    wnsprintf( szUrlBuffer, sizeof(szUrlBuffer)-1, "%s%c%s", URL_SEARCH_PATTERN, DELIMITER_CHAR, szUrl );
    if( GetUrlCacheEntryInfo( szUrlBuffer, pCacheEntryInfo, &dwBufferSize ) ) {
        if( pCacheEntryInfo->lpszLocalFileName != NULL ) {
            if( ShellExecute( NULL, "open",  pCacheEntryInfo->lpszLocalFileName,
                              NULL, NULL, SW_SHOWNORMAL ) <= (HINSTANCE)32 ) {
                // ShellExecute returns <= 32 if error occured
                MessageBox( hwnd, "Error: Unable to open cache file!",
                            "Log View Error", MB_OK | MB_ICONERROR );
            }
        } else {
                MessageBox( hwnd, "Error: No file name available!",
                            "Log View Error", MB_OK | MB_ICONERROR );
        }
    }
        
}

void RefreshLogView( HWND hwnd )
{
    HANDLE                          hUrlCacheEnum;
    DWORD                           dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
    LPINTERNET_CACHE_ENTRY_INFO     pCacheEntryInfo = NULL;
    static char                     pBuffer[MAX_CACHE_ENTRY_INFO_SIZE];
    char                           *szPtr = NULL;

    SendDlgItemMessage( hwnd, IDC_LB_LOGMESSAGES, LB_RESETCONTENT, 0, 0);
    pCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)pBuffer;
    hUrlCacheEnum = FindFirstUrlCacheEntry( URL_SEARCH_PATTERN,
                                            pCacheEntryInfo,
                                            &dwBufferSize );
    if( hUrlCacheEnum != NULL ) {
        if( pCacheEntryInfo->lpszSourceUrlName != NULL ) {
            if( StrStrI( pCacheEntryInfo->lpszSourceUrlName, URL_SEARCH_PATTERN ) ) {
                SendDlgItemMessage( hwnd, IDC_LB_LOGMESSAGES, LB_ADDSTRING, 0,
                                   (LPARAM)pCacheEntryInfo->lpszSourceUrlName );
            }
        }
        dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
        while( FindNextUrlCacheEntry( hUrlCacheEnum, pCacheEntryInfo,
                                      &dwBufferSize ) ) {
            if( pCacheEntryInfo->lpszSourceUrlName != NULL ) {
                if( StrStrI( pCacheEntryInfo->lpszSourceUrlName, URL_SEARCH_PATTERN ) ) {
                    szPtr = pCacheEntryInfo->lpszSourceUrlName;
                    while( *szPtr != '\0' && *szPtr != DELIMITER_CHAR ) {
                        szPtr++;
                    }
                    szPtr++;
                    if( szPtr != NULL ) {
                        SendDlgItemMessage( hwnd, IDC_LB_LOGMESSAGES, LB_ADDSTRING, 0,
                                            (LPARAM)szPtr);
                    }
                }
            }

            dwBufferSize = MAX_CACHE_ENTRY_INFO_SIZE;
        }
    }
}

int 
_stdcall 
ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPTSTR pszCmdLine = GetCommandLine();

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMain(GetModuleHandle(NULL), 
                NULL, 
                pszCmdLine,
                (si.dwFlags & STARTF_USESHOWWINDOW) ? si.wShowWindow : SW_SHOWDEFAULT);

    ExitProcess(i);
    return i;           // We never come here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\eapp\ccodeft.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       CCodeFt.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    04-29-97   DanpoZ (Danpo Zhang)   Created
//
//----------------------------------------------------------------------------
#include <eapp.h>

PerfDbgTag(tagDft,     "Pluggable MF", "Log CDataFt", DEB_PROT)
    DbgTag(tagDftErr,  "Pluggable MF", "Log CDataFtErrors", DEB_PROT|DEB_ERROR)
#define SZDFILTERROOT  "PROTOCOLS\\Filter\\Data Filter\\"


//+---------------------------------------------------------------------------
//
//  Method:     CStdZFilter::QueryInterface
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    06-26-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CStdZFilter::QueryInterface(REFIID riid, void **ppvObj)
{
    PerfDbgLog(tagDft, this, "+CStdFilter::QueryInterface");

    VDATEPTROUT(ppvObj, void*);
    VDATETHIS(this);

    HRESULT hr = NOERROR;
    if( riid == IID_IUnknown || 
        riid == IID_IDataFilter )
    {
        *ppvObj = this;
        AddRef();
    }
    else
        hr = E_NOINTERFACE;

    PerfDbgLog1(
        tagDft, this, "-CStdZFilter::QueryInterface(hr:%1x)", hr);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CStdZFilter::AddRef
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    06-26-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) 
CStdZFilter::AddRef()
{
    PerfDbgLog(tagDft, this, "+CStdZFilter::AddRef");
    LONG lRet = ++_CRefs;
    DllAddRef();
    PerfDbgLog1(tagDft, this, "-CStdZFilter::AddRef(cRef:%1d)", lRet);

    return lRet;
}


//+---------------------------------------------------------------------------
//
//  Method:     CStdZFilter::Release
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    06-26-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) 
CStdZFilter::Release()
{
    PerfDbgLog(tagDft, this, "+CStdZFilter::Release");
    LONG lRet = --_CRefs;
    if(!lRet)
        delete this;
    DllRelease();
    PerfDbgLog1(tagDft, this, "-CStdZFilter::Release(cRef:%1d)", lRet);

    return lRet;
}


//+---------------------------------------------------------------------------
//
//  Method:     CStdZFilter::DoEncode
//
//  Synopsis:
//
//  Arguments:  [dwFlags]           - flags
//              [lInBufferSize]     - Input Buffer Size
//              [pbInBuffer]        - Input Buffer
//              [lOutBufferSize]    - Output Buffer Size  
//              [pbOutBuffer]       - Output Buffer
//              [lInBytesAvailable] - Data available in Input Buffer
//              [plInBytesRead]     - Total data read from input buffer
//              [plOutBytesWritten] - Total data written to output buffer
//              [dwReserved]        - currently not used 
//
//  Returns:    NOERROR or E_FAIL
//
//  History:    06-27-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CStdZFilter::DoEncode(
        DWORD dwFlags,
        LONG  lInBufferSize,
        BYTE* pbInBuffer,
        LONG  lOutBufferSize,  
        BYTE* pbOutBuffer,
        LONG  lInBytesAvailable,
        LONG* plInBytesRead,
        LONG* plOutBytesWritten,
        DWORD dwReserved
)
{
    PerfDbgLog(tagDft, this, "+CStdZFilter::DoEncode");
    HRESULT hr = NOERROR;

    if( !_pEncodeCtx )
        hr = CreateCompression(&_pEncodeCtx, _ulSchema);

    if( _pEncodeCtx && !FAILED(hr) )
    {
        PProtAssert( pbInBuffer && pbOutBuffer && 
                     plInBytesRead && plOutBytesWritten);

        hr = Compress(
            _pEncodeCtx,
            pbInBuffer,
            lInBytesAvailable,
            pbOutBuffer, 
            lOutBufferSize,
            plInBytesRead,
            plOutBytesWritten, 
            _cEncLevel
        );
    }

    PerfDbgLog1(tagDft, this, "-CStdZFilter::DoEncode(hr:%1x)", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CStdZFilter::DoDecode
//
//  Synopsis:
//
//  Arguments:  [dwFlags]           - flags
//              [lInBufferSize]     - Input Buffer Size
//              [pbInBuffer]        - Input Buffer
//              [lOutBufferSize]    - Output Buffer Size  
//              [pbOutBuffer]       - Output Buffer
//              [lInBytesAvailable] - Data available in Input Buffer
//              [plInBytesRead]     - Total data read from input buffer
//              [plOutBytesWritten] - Total data written to output buffer
//              [dwReserved]        - reserved 
//
//  Returns:    NOERROR or E_FAIL
//
//  History:    06-27-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CStdZFilter::DoDecode(
        DWORD dwFlags,
        LONG  lInBufferSize,
        BYTE* pbInBuffer,
        LONG  lOutBufferSize,  
        BYTE* pbOutBuffer,
        LONG  lInBytesAvailable,
        LONG* plInBytesRead,
        LONG* plOutBytesWritten,
        DWORD dwReserved
)
{
    PerfDbgLog(tagDft, this, "+CStdZFilter::DoDecode");
    HRESULT hr = NOERROR;

    if( !_pDecodeCtx )
        hr = CreateDecompression(&_pDecodeCtx, _ulSchema);

    if( _pDecodeCtx && !FAILED(hr) )
    {
        PProtAssert( pbInBuffer && pbOutBuffer && 
                     plInBytesRead && plOutBytesWritten);

        hr = Decompress(
            _pDecodeCtx,
            pbInBuffer,
            lInBytesAvailable,
            pbOutBuffer, 
            lOutBufferSize,
            plInBytesRead,
            plOutBytesWritten
        );
    }

    PerfDbgLog1(tagDft, this, "-CStdZFilter::DoDecode(hr:%1x)", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CStdZFilter::SetEncodingLevel
//
//  Synopsis:
//
//  Arguments:  [cEncLevel]     - encoding level (between 1-100) 
//
//  Returns:    NOERROR or E_FAIL
//
//  History:    06-27-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CStdZFilter::SetEncodingLevel(DWORD dwEncLevel)
{
    PerfDbgLog(tagDft, this, "+CStdZFilter::SetEncodingLevel");
    HRESULT hr = NOERROR;
    
    if( dwEncLevel >= 1 && dwEncLevel <= 100 )
    {
        // input value should be between 1 - 100] 
        // our formula is _cEncLevel = dwEncLevel * 10 / 100
        _cEncLevel = (dwEncLevel * 10) / 100;
        if( !_cEncLevel )
            ++_cEncLevel;
    }
    else
        hr = E_INVALIDARG;

    PerfDbgLog1(
        tagDft, this, "-CStdZFilter::SetEncodingLevel(hr:%1x)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CStdZFilter::InitFilter
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:    NOERROR or E_FAIL (dll init failed)
//
//  History:    06-27-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CStdZFilter::InitFilter()
{
    PerfDbgLog(tagDft, this, "+CStdZFilter::InitFilter");
    HRESULT hr = NOERROR;


	// init the compressor
	if (FAILED(InitCompression()))
        hr = E_FAIL;

    // init the decompressor
    if (FAILED(InitDecompression()))
        hr = E_FAIL;

    PerfDbgLog(tagDft, this, "-CStdZFilter::InitFilter");
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Method:     CStdZFilter::CStdZFilter
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    06-26-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CStdZFilter::CStdZFilter(ULONG ulSchema)
    : _CRefs()
{
    PerfDbgLog(tagDft, this, "+CStdZFilter::CStdZFilter");
    _pEncodeCtx = NULL;
    _pDecodeCtx = NULL;

    // accepts the number between 1[fastest] - 10[most compres]
    // the formula is _cEncLevel/10 = 50/100 
    _cEncLevel= 5; 

    _ulSchema = ulSchema;

    PerfDbgLog(tagDft, this, "-CStdZFilter::CStdZFilter");
}

//+---------------------------------------------------------------------------
//
//  Method:     CStdZFilter::~CStdZFilter
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    06-26-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CStdZFilter::~CStdZFilter()
{
    PerfDbgLog(tagDft, this, "+CStdZFilter::~CStdZFilter");
    if( _pEncodeCtx )
        DestroyCompression(_pEncodeCtx);
    if( _pDecodeCtx )
        DestroyDecompression(_pDecodeCtx);
    PerfDbgLog(tagDft, this, "-CStdZFilter::~CStdZFilter");
}


//+---------------------------------------------------------------------------
//
//  Method:     CEncodingFilterFactory::QueryInterface
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    04-29-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CEncodingFilterFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    PerfDbgLog(tagDft, this, "+CEncodingFilterFactory::QueryInterface");
    VDATEPTROUT(ppvObj, void*);
    VDATETHIS(this);

    HRESULT hr = NOERROR;
    if( riid == IID_IUnknown ||
        riid == IID_IEncodingFilterFactory )
    {
        *ppvObj = this;
        AddRef();
    }
    else
        hr = E_NOINTERFACE;

    PerfDbgLog1(
        tagDft, this, "-CEncodingFilterFactory::QueryInterface(hr:%1x)", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CEncodingFilterFactory::AddRef
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    04-29-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) 
CEncodingFilterFactory::AddRef()
{
    PerfDbgLog(tagDft, this, "+CEncodingFilterFactory::AddRef");
    LONG lRet = ++_CRefs;
    PerfDbgLog1( 
        tagDft, this, "-CEncodingFilterFactory::AddRef(cRef:%1d)", lRet);
    return lRet;
} 

//+---------------------------------------------------------------------------
//
//  Method:     CEncodingFilterFactory::Release
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    04-29-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) 
CEncodingFilterFactory::Release()
{
    PerfDbgLog(tagDft, this, "+CEncodingFilterFactory::Release");
    LONG lRet = --_CRefs;
    if(!lRet)
        delete this;

    PerfDbgLog1( 
        tagDft, this, "-CEncodingFilterFactory::Release(cRef:%1d)", lRet);
    return lRet;
}


//+---------------------------------------------------------------------------
//
//  Method:     CEncodingFilterFactory::FindBestFilter
//
//  Synopsis:
//
//  Arguments:  [grfETYPEIn]  - input encoding type
//              [grfETYPEOut] - output encoding type
//              [info]        - DATAINFO (what the data looks like)
//              [ppDF]        - output DataFilter pointer  
//
//  Returns:
//
//  History:    04-29-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:      currently it calls FindDefaultFilter()
//
//----------------------------------------------------------------------------
STDMETHODIMP
CEncodingFilterFactory::FindBestFilter(
        LPCWSTR         pwzCodeIn,
        LPCWSTR         pwzCodeOut,
        DATAINFO        info,
        IDataFilter**   ppDF 
) 
{
    PerfDbgLog(tagDft, this, "+CEncodingFilterFactory::FindBestFilter");
    HRESULT hr = NOERROR;
    hr = GetDefaultFilter(pwzCodeIn, pwzCodeOut, ppDF);
    PerfDbgLog1(
        tagDft, this, "-CEncodingFilterFactory::FindBestFilter(hr:%1x)", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CEncodingFilterFactory::GetDefaultFilter
//
//  Synopsis:
//
//  Arguments:  [tIn]       - input encoding type
//              [tOut]      - output encoding type
//              [ppDF]      - output DataFilter pointer  
//
//  Returns:
//
//  History:    04-29-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------
STDMETHODIMP
CEncodingFilterFactory::GetDefaultFilter(
        LPCWSTR         pwzCodeIn,
        LPCWSTR         pwzCodeOut,
        IDataFilter**   ppDF
)
{
    PerfDbgLog(tagDft, this, "+CEncodingFilterFactory::GetDefaultFilter");
    VDATEPTROUT(ppDF, void*);
    *ppDF = NULL;

    HRESULT hr = E_FAIL;
    BOOL fBuiltIn = FALSE;

    if( (!_wcsicmp(pwzCodeIn, L"gzip") && !_wcsicmp(pwzCodeOut, L"text")) ||  
        (!_wcsicmp(pwzCodeIn, L"text") && !_wcsicmp(pwzCodeOut, L"gzip") ) ) 
    {
        // GZIP 
        *ppDF = new CStdZFilter(COMPRESSION_FLAG_GZIP); 
        fBuiltIn = TRUE;
        if( !(*ppDF) )
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else 
    if((!_wcsicmp(pwzCodeIn, L"deflate") && !_wcsicmp(pwzCodeOut, L"text"))||        (!_wcsicmp(pwzCodeIn, L"text") && !_wcsicmp(pwzCodeOut, L"deflate")) ) 
    {
        // deflate
        *ppDF = new CStdZFilter(COMPRESSION_FLAG_DEFLATE); 
        fBuiltIn = TRUE;
        if( !(*ppDF) )
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        // lookup reg to find out the class
        CLSID   clsid = CLSID_NULL;
        hr = LookupClsIDFromReg(pwzCodeIn, pwzCodeOut, &clsid, 0);
        if( hr == NOERROR )
        {   // Get Clsid
            IClassFactory*  pCF = NULL;
            hr = CoGetClassObject(
                clsid, CLSCTX_INPROC_SERVER, NULL, 
                IID_IClassFactory, (void**)&pCF );

            if( hr == NOERROR )
            {   // Get Class Fac
                IUnknown*   pUnk = NULL;
                hr = pCF->CreateInstance(NULL, IID_IUnknown, (void**)&pUnk);

                if( hr == NOERROR )
                {   // Created Instance
                    hr = pUnk->QueryInterface(IID_IDataFilter, (void**)ppDF); 

                    pUnk->Release();
                }   // Created Instance
            
                pCF->Release();

            }   // Get Class Fac
        }   // Get Clsid
    }   // lookup reg to find out the class

    // only do this for built-in filter (this is not universal)
    if( (*ppDF) && fBuiltIn )
    {
        hr = ((CStdZFilter*)(*ppDF))->InitFilter();
    }

    PerfDbgLog1(
        tagDft, this, "-CEncodingFilterFactory::GetDefaultFilter(hr:%1x)",hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEncodingFilterFactory::LookupClsIDFromReg
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    08-20-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------
STDMETHODIMP
CEncodingFilterFactory::LookupClsIDFromReg(
        LPCWSTR         pwzCodeIn, 
        LPCWSTR         pwzCodeOut, 
        CLSID*          pclsid,
        DWORD           dwFlags
)
{
    HRESULT hr = E_FAIL;

    CHAR szCodeIn[ULPROTOCOLLEN];
    CHAR szCodeOut[ULPROTOCOLLEN];
    CHAR szCodeKey[2*ULPROTOCOLLEN+1];
    DWORD dwLen = 256;
    CHAR szDFilterKey[MAX_PATH];
    BOOL fFoundKey = FALSE;
    HKEY hDFKey = NULL;
    DWORD dwType;

    W2A(pwzCodeIn, szCodeIn, ULPROTOCOLLEN);
    W2A(pwzCodeOut, szCodeOut, ULPROTOCOLLEN);

    // check buffer overrun
    if( (strlen(szCodeIn) + strlen(szCodeOut) + 2)
        <= MAX_PATH )
    {
    
        // try key#1
        strcpy(szDFilterKey, SZDFILTERROOT);
        strcat(szDFilterKey, szCodeIn);
        strcat(szDFilterKey, "#");
        strcat(szDFilterKey, szCodeOut);

        if( RegOpenKeyEx(
            HKEY_CLASSES_ROOT, szDFilterKey, 0, 
            KEY_QUERY_VALUE, &hDFKey ) == ERROR_SUCCESS)
        {
            if( RegQueryValueEx(
                hDFKey, SZCLASS, NULL, &dwType, (LPBYTE)szDFilterKey, &dwLen
                ) == ERROR_SUCCESS
            )
            {
                hr = CLSIDFromStringA(szDFilterKey, pclsid);
                fFoundKey = TRUE;
            }

            RegCloseKey(hDFKey);
        }


        // try key#2
        if( !fFoundKey )
        {
            strcpy(szDFilterKey, SZDFILTERROOT);
            strcat(szDFilterKey, szCodeOut);
            strcat(szDFilterKey, "#");
            strcat(szDFilterKey, szCodeIn);

            if( RegOpenKeyEx(
                HKEY_CLASSES_ROOT, szDFilterKey, 0, 
                KEY_QUERY_VALUE, &hDFKey ) == ERROR_SUCCESS )
            {
                if( RegQueryValueEx(
                        hDFKey, SZCLASS, NULL, &dwType, 
                        (LPBYTE)szDFilterKey, &dwLen
                    ) == ERROR_SUCCESS
                )
                {
                    hr = CLSIDFromStringA(szDFilterKey, pclsid);
                }

                RegCloseKey(hDFKey);
            }
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEncodingFilterFactory::CEncodingFilterFactory
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    04-29-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------
CEncodingFilterFactory::CEncodingFilterFactory()
    : _CRefs()
{
    PerfDbgLog(
        tagDft, this, "+CEncodingFilterFactory::CEncodingFilterFactory");

    PerfDbgLog(
        tagDft, this, "-CEncodingFilterFactory::CEncodingFilterFactory");
}

//+---------------------------------------------------------------------------
//
//  Method:     CEncodingFilterFactory::~CEncodingFilterFactory
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    04-29-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------
CEncodingFilterFactory::~CEncodingFilterFactory()
{
    PerfDbgLog(
        tagDft, this, "+CEncodingFilterFactory::~CEncodingFilterFactory");

    PerfDbgLog(
        tagDft, this, "-CEncodingFilterFactory::~CEncodingFilterFactory");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\eapp\cdlbsc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cdlbsc.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    01-27-97   t-alans (Alan Shi)   Created
//
//----------------------------------------------------------------------------

#include <eapp.h>
#include "cdlbsc.hxx"

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDLBSC::CCodeDLBSC
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CCodeDLBSC::CCodeDLBSC(IOInetProtocolSink *pIOInetProtocolSink,
                       IOInetBindInfo *pIOInetBindInfo,
                       CCdlProtocol *pCDLProtocol,
                       BOOL fGetClassObject)
{
    _cRef = 1;
    _pIBinding = NULL;
    _pOInetProtocolSink = pIOInetProtocolSink;
    _fGetClassObject = fGetClassObject;

    if (_pOInetProtocolSink != NULL)
    {
        _pOInetProtocolSink->AddRef();
    }
    _pIOInetBindInfo = pIOInetBindInfo;
    if (_pIOInetBindInfo != NULL)
    {
        _pIOInetBindInfo->AddRef();
    }
    _pCDLProtocol = pCDLProtocol;
    if (_pCDLProtocol != NULL)
    {
        _pCDLProtocol->AddRef();
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDLBSC::~CCodeDLBSC
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CCodeDLBSC::~CCodeDLBSC()
{
    if (_pOInetProtocolSink != NULL)
    {
        _pOInetProtocolSink->Release();
    }
    if (_pIOInetBindInfo != NULL)
    {
        _pIOInetBindInfo->Release();
    }
    if (_pCDLProtocol != NULL)
    {
        _pCDLProtocol->ClearCodeDLBSC();
        _pCDLProtocol->Release();
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDLBSC::Abort
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

HRESULT CCodeDLBSC::Abort()
{
    if (_pIBinding)
    {
        return _pIBinding->Abort();
    }
    else
    {
        return S_OK;
    }
}

/*
 *
 * IUnknown Methods
 *
 */

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDLBSC::QueryInterface
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCodeDLBSC::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT          hr = E_NOINTERFACE;

    *ppv = NULL;
    if (riid == IID_IUnknown || riid == IID_IBindStatusCallback)
    {
        *ppv = (IBindStatusCallback *)this;
    }
    else if (riid == IID_IServiceProvider)
    {
        *ppv = (IServiceProvider *)this;
    }
    if (*ppv != NULL)
    {
        ((IUnknown *)*ppv)->AddRef();
        hr = S_OK;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDLBSC::AddRef
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CCodeDLBSC::AddRef()
{
    return ++_cRef;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDLBSC::Release
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CCodeDLBSC::Release()
{
    if (--_cRef)
    {
        return _cRef;
    }
    delete this;

    return 0;
}

/*
 *
 * IBindStatusCallback Methods
 *
 */

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDLBSC::OnStartBinding
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCodeDLBSC::OnStartBinding(DWORD grfBSCOption, IBinding *pib)
{
    if (_pIBinding != NULL)
    {
        _pIBinding->Release();
    }
    _pIBinding = pib;

    if (_pIBinding != NULL)
    {
        _pIBinding->AddRef();
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDLBSC::OnStopBinding
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCodeDLBSC::OnStopBinding(HRESULT hresult, LPCWSTR szError)
{
    HRESULT                   hr = S_OK;
    DWORD                     dwError = 0;
    DWORD                     grfBINDF = 0;
    BINDINFO                  bindinfo;

    _pCDLProtocol->SetDataPending(FALSE);

    if (SUCCEEDED(hresult))
    {
        if (_fGetClassObject)
        {
            EProtAssert(_pUnk);

            // put _pUnk into the bind context for CBinding to retrieve

            hresult = _pCDLProtocol->RegisterIUnknown(_pUnk);

            // no need for _pUnk anymore, release it

            _pUnk->Release();
            _pUnk = NULL;

            if (SUCCEEDED(hresult))
            {
                _pOInetProtocolSink->ReportProgress(BINDSTATUS_IUNKNOWNAVAILABLE,
                                                    NULL);
            }
        }
        else
        {
            if (!IsEqualGUID(_pCDLProtocol->GetClsid() , CLSID_NULL))
            {
                LPOLESTR pwzStrClsId;
                StringFromCLSID(_pCDLProtocol->GetClsid(), &pwzStrClsId);
                _pOInetProtocolSink->ReportProgress(BINDSTATUS_CLSIDCANINSTANTIATE, pwzStrClsId);
        
                delete [] pwzStrClsId;
            }
        }
    }

    hr = _pOInetProtocolSink->ReportResult(hresult, dwError, szError);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDLBSC::OnObjectAvailable
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCodeDLBSC::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
    EProtAssert(!_pUnk && punk);

    _pUnk = punk;
    _pUnk->AddRef();

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDLBSC::GetPriority
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCodeDLBSC::GetPriority(LONG *pnPriority)
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDLBSC::OnLowResource
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCodeDLBSC::OnLowResource(DWORD dwReserved)
{
    return S_OK;
}  

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDLBSC::OnProgress
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCodeDLBSC::OnProgress(ULONG ulProgress, ULONG ulProgressMax,
                                    ULONG ulStatusCode,
                                    LPCWSTR szStatusText)
{
    EProtAssert(_pOInetProtocolSink != NULL);
    return _pOInetProtocolSink->ReportProgress(ulStatusCode, szStatusText);
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDLBSC::GetBindInfo
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCodeDLBSC::GetBindInfo(DWORD *pgrfBINDF, BINDINFO *pbindInfo)
{
    EProtAssert(_pIOInetBindInfo != NULL);
    return _pIOInetBindInfo->GetBindInfo(pgrfBINDF, pbindInfo);
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDLBSC::OnDataAvailable
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCodeDLBSC::OnDataAvailable(DWORD grfBSCF, DWORD dwSize,
                                         FORMATETC *pformatetc,
                                         STGMEDIUM *pstgmed)
{
    return S_OK;
}

/*
 *
 * IWindowForBindingUI Methods
 *
 */

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDLBSC::QueryService
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCodeDLBSC::QueryService(REFGUID rsid, REFIID riid, void ** ppvObj)
{
    HRESULT     hr = NOERROR;
    IServiceProvider        *pIServiceProvider = NULL;

    EProtAssert(ppvObj);
    if (!ppvObj)
        return E_INVALIDARG;

    *ppvObj = 0;

    hr = _pOInetProtocolSink->QueryInterface(IID_IServiceProvider,
                                             (LPVOID *)&pIServiceProvider);

    if (SUCCEEDED(hr))
    {
        hr = pIServiceProvider->QueryService(rsid, riid, (LPVOID *)ppvObj);
        pIServiceProvider->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\eapp\cdlprot.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cdlprot.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    02-06-1997   t-alans (Alan Shi)   Created
//
//----------------------------------------------------------------------------

#include <eapp.h>
#include <tchar.h>
#ifdef unix
#include "../download/cdl.h"
#else
#include "..\download\cdl.h"
#endif /* !unix */


// From shlwapip.h
LWSTDAPI_(HRESULT) CLSIDFromStringWrap(LPOLESTR lpsz, LPCLSID pclsid);


#define VALUE_EQUAL_CHAR            '='
#define VALUE_SEPARATOR_CHAR        ';'


//+---------------------------------------------------------------------------
//
//  Method:     CCdlProtocol::CCdlProtocol
//
//  Synopsis:
//
//  Arguments:
//
//
//
//  Returns:
//
//  History:    02-06-1997   t-alans (Alan Shi)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CCdlProtocol::CCdlProtocol(REFCLSID rclsid, IUnknown *pUnkOuter,
                           IUnknown **ppUnkInner)
: CBaseProtocol(rclsid, pUnkOuter, ppUnkInner)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CCdlProtocol::CCdlProtocol \n", this));

    DllAddRef();

    _clsidReport = CLSID_NULL;
    _pCodeDLBSC = NULL;
    _fDataPending = TRUE;
    _fNotStarted = TRUE;
    _iid = IID_IUnknown;
    _pbc = NULL;
    _fGetClassObject = FALSE;
    EProtDebugOut((DEB_PLUGPROT, "%p OUT CCdlProtocol::CCdlProtocol \n", this));
}

//+---------------------------------------------------------------------------
//
//  Method:     CCdlProtocol::~CCdlProtocol
//
//  Synopsis:
//
//  Arguments:
//
//
//
//  Returns:
//
//  History:    02-06-1997   t-alans (Alan Shi)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CCdlProtocol::~CCdlProtocol()
{
    if (_pbc)
    {
        _pbc->Release();
    }

    DllRelease();
    EProtDebugOut((DEB_PLUGPROT, "%p _IN/OUT CCdlProtocol::~CCdlProtocol \n", this));
}

//+---------------------------------------------------------------------------
//
//  Method:     CCdlProtocol::Start
//
//  Synopsis:
//
//  Arguments:
//
//
//
//  Returns:
//
//  History:    02-06-1997   t-alans (Alan Shi)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

#ifdef _WIN64
LWSTDAPI_(BOOL)     StrToInt64ExW(LPCWSTR pszString, DWORD dwFlags, LONGLONG * pllRet);
#endif

STDMETHODIMP CCdlProtocol::Start(LPCWSTR pwzUrl,
                                 IOInetProtocolSink *pIOInetProtocolSink,
                                 IOInetBindInfo *pIOInetBindInfo,
                                 DWORD grfSTI,
                                 DWORD_PTR dwReserved)
{
    DWORD                     cElFetched = 0;
    LPOLESTR                  pwzIID = NULL;
    BINDINFO                  bindinfo;
    DWORD                     grfBINDF = 0;

    EProtDebugOut((DEB_PLUGPROT, "%p _IN CCdlProtocol::Start\n", this));
    HRESULT hr = NOERROR;
    WCHAR    wzURL[MAX_URL_SIZE];

    EProtAssert((!_pProtSink && pIOInetBindInfo && pIOInetProtocolSink));
    EProtAssert((_pwzUrl == NULL));

    bindinfo.cbSize = sizeof(BINDINFO);
    pIOInetBindInfo->GetBindInfo(&grfBINDF, &bindinfo);

    if (grfBINDF & BINDF_GETCLASSOBJECT)
    {
        LPWSTR                  pwzBC = NULL;
        DWORD                   cElFetched = 0;

        hr = pIOInetBindInfo->GetBindString(BINDSTRING_PTR_BIND_CONTEXT,
                                            &pwzBC, 0,
                                            &cElFetched);
        if (SUCCEEDED(hr))
        {
#ifdef _WIN64
            StrToInt64ExW(pwzBC, 0, (LONGLONG *)&_pbc);
#else
            _pbc = (IBindCtx *)StrToIntW(pwzBC);
#endif

            EProtAssert(_pbc);

            delete [] pwzBC;
            pwzBC = NULL;
        }
        else
        {
            hr = E_UNEXPECTED;
            goto Exit;
        }

        _fGetClassObject = TRUE;
    }

    grfSTI |= PI_FORCE_ASYNC;
    hr = CBaseProtocol::Start(pwzUrl, pIOInetProtocolSink, pIOInetBindInfo, grfSTI, dwReserved);

    if (SUCCEEDED(hr))
    {
        hr = pIOInetBindInfo->GetBindString(BINDSTRING_IID, &pwzIID, 0,
                                            &cElFetched);
    }

    if (hr == S_OK)
    {
        hr = CLSIDFromString(pwzIID, &_iid);
        delete [] pwzIID;
    }

    if (SUCCEEDED(hr))
    {
        hr =  ParseURL();
    }

Exit:

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CCdlProtocol::Start (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCdlProtocol::Continue
//
//  Synopsis:
//
//  Arguments:
//
//
//
//  Returns:
//
//  History:    02-06-1997   t-alans (Alan Shi)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CCdlProtocol::Continue(PROTOCOLDATA *pStateInfoIn)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CCdlProtocol::Continue\n", this));
    HRESULT hr = E_FAIL;

    if (_fNotStarted && pStateInfoIn->dwState == CDL_STATE_BIND)
    {
        _fNotStarted = FALSE;
        hr =  ParseURL();
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CCdlProtocol::Continue (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCdlProtocol::Read
//
//  Synopsis:
//
//  Arguments:
//
//
//
//  Returns:
//
//  History:    02-06-1997   t-alans (Alan Shi)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CCdlProtocol::Read(void *pv,ULONG cb,ULONG *pcbRead)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CCdlProtocol::Read\n", this));
    HRESULT           hr;

    hr = (_fDataPending) ? (E_PENDING) : (S_FALSE);
    *pcbRead = (_fDataPending) ? (0x0) : (0x100);

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CCdlProtocol::Read\n", this));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCdlProtocol::Abort
//
//  Synopsis:
//
//  Arguments:
//
//
//
//  Returns:
//
//  History:    02-06-1997   t-alans (Alan Shi)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CCdlProtocol::Abort(HRESULT hrReason, DWORD dwOptions)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CCdlProtocol::Abort\n", this));
    HRESULT           hr = E_UNEXPECTED;

    EProtAssert( _pCodeDLBSC != NULL );
    if (_pCodeDLBSC != NULL)
    {
        hr = _pCodeDLBSC->Abort();
    }

#if 0
    if (_pProtSink)
    {
        hr = CBaseProtocol::Abort(hrReason, dwOptions);
    }
#endif

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CCdlProtocol::Abort\n", this));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCdlProtocol::Seek
//
//  Synopsis:
//
//  Arguments:
//
//
//
//  Returns:
//
//  History:    02-06-1997   t-alans (Alan Shi)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CCdlProtocol::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin,
                                ULARGE_INTEGER *plibNewPosition)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CCdlProtocol::Seek\n", this));
    EProtDebugOut((DEB_PLUGPROT, "%p OUT CCdlProtocol::Seek\n", this));
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCdlProtocol::LockRequest
//
//  Synopsis:
//
//  Arguments:
//
//
//
//  Returns:
//
//  History:    02-06-1997   t-alans (Alan Shi)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CCdlProtocol::LockRequest(DWORD dwOptions)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CCdlProtocol::LockRequest\n", this));
    EProtDebugOut((DEB_PLUGPROT, "%p OUT CCdlProtocol::LockRequest\n", this));
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCdlProtocol::UnlockRequest
//
//  Synopsis:
//
//  Arguments:
//
//
//
//  Returns:
//
//  History:    02-06-1997   t-alans (Alan Shi)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CCdlProtocol::UnlockRequest()
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CCdlProtocol::UnlockRequest\n", this));
    EProtDebugOut((DEB_PLUGPROT, "%p OUT CCdlProtocol::UnlockRequest\n", this));
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCdlProtocol::ParseURL
//
//  Synopsis:
//
//  Arguments:
//
//
//
//  Returns:
//
//  History:    02-06-1997   t-alans (Alan Shi)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CCdlProtocol::ParseURL()
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CCdlProtocol::ParseURL\n", this));
    HRESULT            hr = MK_E_SYNTAX;
    WCHAR              wzlURL[MAX_URL_SIZE];
    LPWSTR             pwz = NULL;
    LPWSTR             pwzValue = NULL;
    LPWSTR             pwzTag = NULL;
    LPWSTR             pwzPound = NULL;
    BOOL               fGotRequiredField = FALSE;
    CodeDownloadData   cdldata;
    CHAR               szValue[MAX_PATH];

    cdldata.szDistUnit = NULL;
    cdldata.szClassString = NULL;
    cdldata.szURL = NULL;
    cdldata.szMimeType = NULL;
    cdldata.szExtension = NULL;
    cdldata.szDll = NULL;
    cdldata.dwFileVersionMS = 0;
    cdldata.dwFileVersionLS = 0;
    cdldata.dwFlags = 0;


// URL is of the form:
// (1)  cdl://[unused]?[clsid=xxx|codebase=xxx|mimetype=xxx|extension=xxx];
//                     [clsid=xxx|codebase=xxx|mimetype=xxx|extension=xxx];
//                     [clsid=xxx|codebase=xxx|mimetype=xxx|extension=xxx];...
//
//     OR
//
// (2)  cdl:[clsid=xxx|codebase=xxx|mimetype=xxx|extension=xxx];
//          [clsid=xxx|codebase=xxx|mimetype=xxx|extension=xxx];...
//
//
// NOTE: [distunit=xxx] added to support AsyncInstallDistributionUnit
//       [flags=xxx] added flags (as an integer so that we can dictate
//                   silent mode, async. etc.

    wcscpy(wzlURL, _wzFullURL);

    // ensure correct format: "cdl://[stuff]?"

    pwz = wcschr(wzlURL, ':');
    pwz++;
    if (!(wcsnicmp(pwz, L"//", 2) && wcsnicmp(pwz, L"\\\\", 2)))
    {
        // URL is of form (1)
        pwz = wcschr(pwz, '?');
        if( pwz == NULL ) {
            // error, no '?' found
            hr = MK_E_SYNTAX;
            goto Exit;
        }
        pwz++; // pwz now points to the start of the param list (start boundry)
    }

    pwzValue = pwz + wcslen( pwz ); // points to NULL


    // If there is a pound, NULL terminate there instead

    pwzPound = pwzValue - 1;

    while (pwzPound >= pwz)
    {
        if (*pwzPound == VALUE_POUND_CHAR)
        {
            *pwzPound = NULL;
            pwzValue = pwzPound;
            break;
        }
        pwzPound--;
    }

    for ( ;; )
    {
        while (pwzValue >= pwz && *pwzValue != VALUE_EQUAL_CHAR &&
               *pwzValue != VALUE_SEPARATOR_CHAR)
        {
            pwzValue--;
        }
        if (pwzValue < pwz || *pwzValue == VALUE_SEPARATOR_CHAR)
        {
            // error, expected '='
            hr = MK_E_SYNTAX;
            goto Exit;
        }

        // pwzValue now points to '='
        *pwzValue = NULL;
        pwzTag = pwzValue;
        pwzValue++;

        while (pwzTag >= pwz && *pwzTag != VALUE_EQUAL_CHAR &&
                                *pwzTag != VALUE_SEPARATOR_CHAR)
        {
            pwzTag--;
        }
        if (*pwzTag == VALUE_EQUAL_CHAR)
        {
            // error, expected either a separator, or the beginning
            hr = MK_E_SYNTAX;
            goto Exit;
        }
        pwzTag++;

        if (!wcsicmp(L"codebase", pwzTag))
        {
            cdldata.szURL = pwzValue;
        }
        else if (!wcsicmp(L"clsid", pwzTag))
        {
            cdldata.szClassString = pwzValue;
            fGotRequiredField = TRUE;
        }
        else if (!wcsicmp(L"mimetype", pwzTag))
        {
            cdldata.szMimeType = pwzValue;
            fGotRequiredField = TRUE;
        }
        else if (!wcsicmp(L"extension", pwzTag))
        {
            cdldata.szExtension = pwzValue;
            fGotRequiredField = TRUE;
        }
        else if (!wcsicmp(L"verMS", pwzTag))
        {
            //cdldata.dwFileVersionMS = _wtol(pwzValue);
            W2A(pwzValue, szValue, MAX_PATH);
            cdldata.dwFileVersionMS = atol(szValue);

        }
        else if (!wcsicmp(L"verLS", pwzTag))
        {
            //cdldata.dwFileVersionLS = _wtol(pwzValue);
            W2A(pwzValue, szValue, MAX_PATH);
            cdldata.dwFileVersionLS = atol(szValue);
        }
        else if (!wcsicmp(L"distunit", pwzTag))
        {
            cdldata.szDistUnit = pwzValue;
            fGotRequiredField = TRUE;
        }
        else if (!wcsicmp(L"flags", pwzTag))
        {
            cdldata.dwFlags = StrToIntW(pwzValue);
        }
        else if (!wcsicmp(L"version", pwzTag))
        {
            W2A(pwzValue, szValue, MAX_PATH);
            GetVersionFromString(szValue, &(cdldata.dwFileVersionMS), &(cdldata.dwFileVersionLS));
        }
        else if (!wcsicmp(L"dllname",pwzTag))
        {
            cdldata.szDll = pwzValue;
        }

        if (pwzTag <= pwz)
        {
            break; // we are done
        }
        else
        {
            pwzValue = pwzTag;
            pwzValue--;
            *pwzValue = NULL;
            pwzTag = NULL;
        }
    }

    // backwards compatability with clsid can be dist unit
    if(cdldata.szClassString && ! cdldata.szDistUnit)
    {
        cdldata.szDistUnit = cdldata.szClassString;
    }
    if(cdldata.szDistUnit && ! cdldata.szClassString)
    {
        cdldata.szClassString = cdldata.szDistUnit;
    }

    if (fGotRequiredField)
    {
        // The client must provide a host security manager for
        // CDL:// protocol bindings. Otherwise, a file:// URL codebase
        // will be executed without WVT UI.

        IInternetHostSecurityManager *phsm = NULL;
        IServiceProvider *psp = NULL;

        hr = _pProtSink->QueryInterface(IID_IServiceProvider,
                                        (void **)&psp);
        if (FAILED(hr)) {
            hr = TRUST_E_FAIL;
            goto Exit;
        }

        hr = psp->QueryService(IID_IInternetHostSecurityManager,
                               IID_IInternetHostSecurityManager, (void **)&phsm);

        if (FAILED(hr)) {
            hr = TRUST_E_FAIL;
            goto Exit;
        }

        psp->Release();
        phsm->Release();

        if (IsEqualGUID(_clsidReport , CLSID_NULL))
            CLSIDFromString((LPOLESTR)cdldata.szClassString, &_clsidReport);
        hr = StartDownload(cdldata);
    }
    else
    {
        hr = MK_E_SYNTAX;
    }

Exit:

    // if we error for any reason here, then CodeDL BSC was never initiated and we will
    // never get an BSC::OSB to shut up sink.

    if (hr != E_PENDING)
    {
        _fDataPending = FALSE;

        if (_pProtSink)
        {
            if (!IsEqualGUID(_clsidReport, CLSID_NULL))
            {
                LPOLESTR pwzStrClsId;
                StringFromCLSID(_clsidReport, &pwzStrClsId);
                _pProtSink->ReportProgress(BINDSTATUS_CLSIDCANINSTANTIATE, pwzStrClsId);

                delete [] pwzStrClsId;
            }

            _pProtSink->ReportResult(hr, 0, 0);
        }
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CCdlProtocol::ParseURL\n", this));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCdlProtocol::StartDownload
//
//  Synopsis:
//
//  Arguments:
//
//
//
//  Returns:
//
//  History:    02-06-1997   t-alans (Alan Shi)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CCdlProtocol::StartDownload(CodeDownloadData &cdldata)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CCdlProtocol::StartDownload\n", this));
    HRESULT               hr  = S_OK;
    IBindCtx             *pbc = NULL;
    IUnknown             *pUnk = NULL;

// Kick off the download

    _pCodeDLBSC = new CCodeDLBSC(_pProtSink, _pOIBindInfo, this, _fGetClassObject);
    if (_pCodeDLBSC == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    hr = CreateBindCtx(0, &pbc);
    if (SUCCEEDED(hr))
    {
        hr = RegisterBindStatusCallback(pbc, _pCodeDLBSC, NULL, 0);
        if (_pCodeDLBSC != NULL)
        {
            _pCodeDLBSC->Release();
        }
        if (FAILED(hr))
        {
            goto Exit;
        }
    }

    cdldata.dwFlags = (_fGetClassObject) ? (CD_FLAGS_NEED_CLASSFACTORY) : (0);

    hr = AsyncInstallDistributionUnitEx(&cdldata, pbc, _iid, &pUnk, NULL);

    if (hr == MK_S_ASYNCHRONOUS)
    {
        hr = E_PENDING;
    }
    else
    {
        if (_fGetClassObject)
        {
            if (pUnk && SUCCEEDED(hr))
            {
                hr = RegisterIUnknown(pUnk);
                pUnk->Release();

                if (SUCCEEDED(hr))
                {
                    hr = _pProtSink->ReportProgress(BINDSTATUS_IUNKNOWNAVAILABLE, NULL);
                }
            }
            _pProtSink->ReportResult(hr, 0, 0);
        }
    }

Exit:
    if (pbc != NULL)
    {
        // NOTE: This instruction can cause deletion of this object,
        // referencing "this" afterwords may be a bad idea.
        pbc->Release();
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CCdlProtocol::StartDownload\n", this));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCdlProtocol::SetDataPending
//
//  Synopsis:
//
//  Arguments:
//
//
//
//  Returns:
//
//  History:    02-06-1997   t-alans (Alan Shi)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void CCdlProtocol::SetDataPending(BOOL fPending)
{
    _fDataPending = fPending;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCdlProtocol::RegisterIUnknown
//
//  Synopsis:
//
//  Arguments:
//
//
//
//  Returns:
//
//  History:    11-12-1998   AlanShi (Alan Shi)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT CCdlProtocol::RegisterIUnknown(IUnknown *pUnk)
{
    EProtAssert(_pbc);

    return _pbc->RegisterObjectParam(SZ_IUNKNOWN_PTR, pUnk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\eapp\guids.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       GUIDS.C
//
//  Contents:   Defines GUIDS used in this DLL.
//
//  Classes:
//
//  Functions:
//
//  History:    11-02-95   JoeS (Joe Souza)     Created
//
//----------------------------------------------------------------------------
//#include <urlint.h>


#ifdef __cplusplus
extern "C" {
#endif


#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} GUID;
#endif // GUID_DEFINED

const GUID CLSID_UMkSrvDll =
{
    0x79ead9d0, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b }
};

const GUID IID_IDebugRegister       = { 0xc733e4f0, 0x576e, 0x11d0, {0xb2, 0x8c, 0x00, 0xc0, 0x4f, 0xd7, 0xcd, 0x22} };
const GUID IID_IDebugOut            = { 0xc733e4f1, 0x576e, 0x11d0, {0xb2, 0x8c, 0x00, 0xc0, 0x4f, 0xd7, 0xcd, 0x22} };

// Notification sink texs class ids
const GUID CLSID_NotificaitonTest1  = {0xc733e501, 0x576e, 0x11d0, {0xb2, 0x8c, 0x00, 0xc0, 0x4f, 0xd7, 0xcd, 0x22}};
const GUID CLSID_NotificaitonTest2  = {0xc733e502, 0x576e, 0x11d0, {0xb2, 0x8c, 0x00, 0xc0, 0x4f, 0xd7, 0xcd, 0x22}};
const GUID CLSID_NotificaitonTest3  = {0xc733e503, 0x576e, 0x11d0, {0xb2, 0x8c, 0x00, 0xc0, 0x4f, 0xd7, 0xcd, 0x22}};
const GUID CLSID_NotificaitonTest4  = {0xc733e504, 0x576e, 0x11d0, {0xb2, 0x8c, 0x00, 0xc0, 0x4f, 0xd7, 0xcd, 0x22}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\eapp\clshndlr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       cldhndlr.cxx
//
//  Contents:   Performs download of class object and its handler concurrently
//
//  Classes:
//
//  Functions:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//----------------------------------------------------------------------------
#include <eapp.h>

PerfDbgTag(tagClassInstallFilter,    "Urlmon", "Log ClassInstallFilter",        DEB_TRANS)
    DbgTag(tagClassInstallFilterErr, "Urlmon", "Log ClassInstallFilter Errors", DEB_TRANS|DEB_ERROR)
   
//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilterSink::CClassInstallFilterSink
//
//  Synopsis:
//
//  Arguments:  [CClassInstallFilter] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CClassInstallFilterSink::CClassInstallFilterSink(CClassInstallFilter *pInstallFilter)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilterSink::CClassInstallFilterSink\n");
    
    TransAssert(pInstallFilter);

    _pInstallFilter = pInstallFilter;

    _dwRef = 1;
    _bDone = FALSE;

    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilterSink::CClassInstallFilterSink (end)\n");
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilterSink::~CClassInstallFilterSink
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CClassInstallFilterSink::~CClassInstallFilterSink()
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilterSink::~CClassInstallFilterSink\n");
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilterSink::~CClassInstallFilterSink (end)\n");
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilterSink::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CClassInstallFilterSink::QueryInterface(REFIID iid, void **ppvObj)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilterSink::QueryInterface\n");
    HRESULT hr = E_FAIL;

    if (!ppvObj)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *ppvObj = NULL;
    
        if ((iid == IID_IOInetProtocolSink)
            || (iid == IID_IUnknown)) 
        {
            *ppvObj = (IOInetProtocolSink *) this;
            AddRef();
            hr = S_OK;   
        }
        else if (iid == IID_IServiceProvider)
        {
            *ppvObj = (IServiceProvider *) this;
            AddRef();
            hr = S_OK;
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilterSink::QueryInterface (hr:%lx)\n", hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilterSink::AddRef
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
ULONG CClassInstallFilterSink::AddRef(void)
{
    PerfDbgLog(tagClassInstallFilter, this, "-CClassInstallFilterSink::AddRef\n");

    {
        _dwRef++;
    }
    
    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilterSink::AddRef (_dwRef=%ld)\n", _dwRef);
    return _dwRef;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilterSink::Release
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
ULONG CClassInstallFilterSink::Release(void)
{
    PerfDbgLog(tagClassInstallFilter, this, "-CClassInstallFilterSink::Release\n");

    {
        _dwRef--;
        if (!_dwRef)
        {
            delete this;
            return 0;
        }
    }

  
    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilterSink::Release (_dwRef:%ld)\n", _dwRef);
    return _dwRef;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilterSink::Switch
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CClassInstallFilterSink::Switch(PROTOCOLDATA *pStateInfo)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilterSink::Switch\n");
    HRESULT hr = NOERROR;

    TransAssert(pStateInfo);

    if (_bDone)
    {
        hr = E_FAIL;
    }
 
    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::Switch (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilterSink::ReportProgress
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CClassInstallFilterSink::ReportProgress(ULONG ulStatusCode, LPCWSTR szStatusText)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilterSink::ReportProgress\n");
    HRESULT hr = NOERROR;
    ULONG ulNewStatus = 0;

    if (ulStatusCode == BINDSTATUS_BEGINDOWNLOADDATA)
    {
        ulNewStatus = BINDSTATUS_BEGINDOWNLOADCOMPONENTS;
    }
    else if (ulStatusCode == BINDSTATUS_DOWNLOADINGDATA)
    {
        ulNewStatus = BINDSTATUS_INSTALLINGCOMPONENTS;
    }
    else if (ulStatusCode == BINDSTATUS_ENDDOWNLOADCOMPONENTS)
    {
        ulNewStatus = BINDSTATUS_ENDDOWNLOADCOMPONENTS;
    }

    // report progress on this

    if (ulNewStatus && _pInstallFilter)
    {
        _pInstallFilter->ReportProgress(ulNewStatus, szStatusText);
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::ReportProgress (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilterSink::ReportData
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CClassInstallFilterSink::ReportData(DWORD grfBSCF, ULONG ulProgress, ULONG ulProgressMax)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilterSink::ReportData\n");
    HRESULT hr = NOERROR;

    if (_bDone)
    {
        hr = E_FAIL;
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::ReportData (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilterSink::ReportResult
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CClassInstallFilterSink::ReportResult(HRESULT hrResult, DWORD dwError, LPCWSTR wzResult)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilterSink::ReportResult\n");
    HRESULT hr = NOERROR;

    if (_bDone)
    {
        hr = E_FAIL;
    }
    else 
    {
        _bDone = TRUE;
     
        hr = _pInstallFilter->InstallerReportResult(hrResult, dwError, wzResult);
    }
    
    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::ReportResult (hr:%lx)\n", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilterSink::QueryService
//
//  Synopsis:
//
//  Arguments:  [rsid] --
//              [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilterSink::QueryService(REFGUID rsid, REFIID riid, void ** ppvObj)
{
    PerfDbgLog(tagClassInstallFilter, this, "-CClassInstallFilterSink::QueryService\n");
    HRESULT hr = NOERROR;

    if (!_pInstallFilter)
    {
        hr = E_NOINTERFACE;
    }
    else
    {
        hr = _pInstallFilter->QueryService(rsid,riid,ppvObj);
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilterSink::QueryService (hr:%xd)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::CClassInstallFilter
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CClassInstallFilter::CClassInstallFilter() 
{
    PerfDbgLog(tagClassInstallFilter, this, "-CClassInstallFilter::CClassInstallFilter\n");

    DllAddRef();

    _pwzCDLURL = 0;
    _pwzClsId = 0;
    _pwzMime = 0;
    _pInstallSink = 0;
    
    _bAddRef = FALSE;

    _grfBSCF = 0;
    _ulProgress = 0;
    _ulProgressMax = 0;

    _hrResult = 0;
    _dwError = 0;
    _wzResult = NULL;
    _fReportResult = FALSE;
    _pwzDocBase[0] = L'\0';
    _pSecMgr = NULL;

    _CRefs = 1;

    SetInstallState(installingNone);

    PerfDbgLog(tagClassInstallFilter, this, "-CClassInstallFilter::CClassInstallFilter (end)\n");
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::~CClassInstallFilter
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CClassInstallFilter::~CClassInstallFilter()
{
    PerfDbgLog(tagClassInstallFilter, this, "-CClassInstallFilter::~CClassInstallFilter\n");

    DllRelease();

    TransAssert((GetInstallState() == installingNone) 
             || (GetInstallState() == installingDone));
 
    if (_wzResult)
    {
        delete [] _wzResult;
    }

    if (_pwzCDLURL)
    {
        delete [] _pwzCDLURL;
    }
    
    if (_pwzClsId)
    {
        delete [] _pwzClsId;
    }
    
    if (_pwzMime)
    {
        delete [] _pwzMime;
    }

    if (_pInstallSink)
    {
        _pInstallSink->Release();
    }

    if (_pCDLnetProtocol)
    {
        _pCDLnetProtocol->Release();
        _pCDLnetProtocol = NULL;
    }

    if (_pSecMgr) {
        _pSecMgr->Release();
    }
 
    PerfDbgLog(tagClassInstallFilter, this, "-CClassInstallFilter::~CClassInstallFilter (end)\n");
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::QueryInterface
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::QueryInterface(REFIID riid, void **ppvObj)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::QueryInterface\n");
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    *ppvObj = NULL;

    {
        if (   (riid == IID_IUnknown)
            || (riid == IID_IOInetProtocol))
        {
            *ppvObj = (IOInetProtocol *) this;
            AddRef();
        }
        else if (riid == IID_IOInetProtocolSink)
        {
            *ppvObj = (IOInetProtocolSink *) this;
            AddRef();
        }
        else if (riid == IID_IServiceProvider)
        {
            *ppvObj = (IServiceProvider *) this;
            AddRef();
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }


    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::QueryInterface (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CClassInstallFilter::AddRef
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassInstallFilter::AddRef(void)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::AddRef\n");

    LONG lRet;
  
    {
        lRet = ++_CRefs;
    }
    
    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::AddRef (cRefs:%ld)\n", lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CClassInstallFilter::Release
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassInstallFilter::Release(void)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::Release\n");

    LONG lRet;
    {
        lRet = --_CRefs;
        if (_CRefs == 0)
        {
            delete this;
        }
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::Release (cRefs:%ld)\n", lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CInstallBindInfo::CInstallBindInfo
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CInstallBindInfo::CInstallBindInfo() 
{
    PerfDbgLog(tagClassInstallFilter, this, "-CInstallBindInfo::CClassInstallFilter\n");

    _CRefs = 1;

    PerfDbgLog(tagClassInstallFilter, this, "-CInstallBindInfo::ClassInstallFilter (end)\n");
}

//+---------------------------------------------------------------------------
//
//  Method:     CInstallBindInfo::~CInstallBindInfo
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CInstallBindInfo::~CInstallBindInfo()
{
    PerfDbgLog(tagClassInstallFilter, this, "-CInstallBindInfo::~CInstallBindInfo\n");
    PerfDbgLog(tagClassInstallFilter, this, "-CInstallBindInfo::~CInstallBindInfo (end)\n");
}

//+---------------------------------------------------------------------------
//
//  Method:     CInstallBindInfo::QueryInterface
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CInstallBindInfo::QueryInterface(REFIID riid, void **ppvObj)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CInstallBindInfo::QueryInterface\n");
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    *ppvObj = NULL;

    {
        if (   (riid == IID_IUnknown)
            || (riid == IID_IOInetBindInfo))
        {
            *ppvObj = (IOInetBindInfo *) this;
            AddRef();
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }


    PerfDbgLog1(tagClassInstallFilter, this, "-CInstallBindInfo::QueryInterface (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CInstallBindInfo::AddRef
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CInstallBindInfo::AddRef(void)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CInstallBindInfo::AddRef\n");

    LONG lRet;
  
    {
        lRet = ++_CRefs;
    }
    
    PerfDbgLog1(tagClassInstallFilter, this, "-CInstallBindInfo::AddRef (cRefs:%ld)\n", lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CInstallBindInfo::Release
//
//  Synopsis:
//
//  Arguments:  
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CInstallBindInfo::Release(void)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CInstallBindInfo::Release\n");

    LONG lRet;
    {
        lRet = --_CRefs;
        if (_CRefs == 0)
        {
            delete this;
        }
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CInstallBindInfo::Release (cRefs:%ld)\n", lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CInstallBindInfo::GetBindInfo
//
//  Synopsis:
//
//  Arguments:  [grfBINDF] --
//              [pbindinfo] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CInstallBindInfo::GetBindInfo(
                                    DWORD *grfBINDF, BINDINFO * pbindinfo)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CInstallBindInfo::GetBindInfo\n");
    HRESULT hr = NOERROR;

    TransAssert(pbindinfo);
    if (!grfBINDF || !pbindinfo || !pbindinfo->cbSize) 
    {
        hr = E_INVALIDARG;
    }
    else
    {
        DWORD cbSize = pbindinfo->cbSize;
        memset(pbindinfo, 0, cbSize);
        pbindinfo->cbSize = cbSize;
    }

    PerfDbgLog1(tagClassInstallFilter, this, "+CInstallBindInfo::GetBindInfo (hr:%lx)\n",hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CInstallBindInfo::GetBindString
//
//  Synopsis:
//
//  Arguments:  [ulStringType] --
//              [ppwzStr] --
//              [cEl] --
//              [pcElFetched] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CInstallBindInfo::GetBindString(
                    ULONG ulStringType, LPOLESTR *ppwzStr, ULONG cEl, ULONG *pcElFetched)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CInstallBindInfo::GetBindString\n");
    HRESULT hr = NOERROR;

    TransAssert(ppwzStr);
    TransAssert(pcElFetched);

    if (ppwzStr && pcElFetched)
    {
        *ppwzStr = NULL;
        *pcElFetched = 0;
    }

    hr = S_FALSE;

    PerfDbgLog1(tagClassInstallFilter, this, "+CInstallBindInfo::GetBindString (hr:%lx)\n",hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::Start
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pTrans] --
//              [pOIBindInfo] --
//              [grfSTI] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::Start(LPCWSTR pwzUrl, 
                          IOInetProtocolSink *pOInetProtSnk, 
                          IOInetBindInfo *pOIBindInfo,
                          DWORD grfSTI, 
                          DWORD_PTR dwReserved)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::Start\n");
    HRESULT hr = NOERROR;
    IOInetSession *pOInetSession = NULL;
    PROTOCOLFILTERDATA *pFilterData = (PROTOCOLFILTERDATA *)dwReserved;
    static LPCWSTR pwzCDLFormatCDL = L"cdl:";
    static LPCWSTR pwzCDLFormatCodebase = L"codebase=";
    static LPCWSTR pwzCDLFormatClsId = L"clsid=";
    static LPCWSTR pwzCDLFormatMime = L"mimetype=";
    static LPCWSTR pwzCDLFormatVerMS = L";verMS=";
    static LPCWSTR pwzCDLFormatVerLS = L";verLS=";
    static LPCWSTR pwzCDLFormatSeparator = L";";
    IOInetBindInfo *pBindInfo = NULL;
    LPWSTR pwzTmp = NULL;
    LPWSTR pwzVerInfo = NULL, pwzVerMS = NULL, pwzVerLS = NULL;
    DWORD dwSize;
    WCHAR chType = L'\0';

    TransAssert((pOIBindInfo && pOInetProtSnk && pwzUrl));
    TransAssert(!_pCDLnetProtocol);
    
    //BUGBUG:
    // we engage in some trickery to get the URL & class ID.  The URL string
    // passed to us is actually "Class Install Handler", but after the NULL
    // terminator we expect the docbase the show up. After this, the real URL
    // info to occur.  This is because the pwzURL
    // is used by LoadHandler to find us in the registry and then calls us with it.

    // Get the docbase
    while (*pwzUrl)
    {
        pwzUrl++;
    }
    pwzUrl++;
    
    lstrcpyW(_pwzDocBase, pwzUrl);

    // Now get the cdl:// codebase

    while (*pwzUrl)
    {
        pwzUrl++;
    }
    pwzUrl++;

    if (pOInetProtSnk && pwzUrl && *pwzUrl) 
    {
        TransAssert(pwzUrl);
   
        //
        // expect url:   codebase?<type>[clsid|mimetype]?<verMS>,<verLS>
        // example:      http://msw/officehandler.cab?CABCD1234-...?1,2
        //

        delete [] _pwzUrl;
        pwzTmp = _pwzUrl = OLESTRDuplicate((LPCWSTR)pwzUrl);

        while (*pwzTmp && *pwzTmp != L'?')
        {
            pwzTmp++;
        }

        if (*pwzTmp)
        {
            *pwzTmp = L'\0';
            pwzTmp++;

            delete [] _pwzClsId;
            
            // extract version info.
            pwzVerInfo = pwzTmp;
            while (*pwzVerInfo && *pwzVerInfo != L'?')
            {
                pwzVerInfo++;
            }

            if (*pwzVerInfo == L'?')
            {
                pwzVerMS = pwzVerInfo + 1;
                pwzVerLS = pwzVerMS;

                while (*pwzVerLS && *pwzVerLS != L',')
                {
                    pwzVerLS++;
                }
                if (*pwzVerLS == L',')
                {
                    *pwzVerLS = L'\0';
                    pwzVerLS++;        
                }

                *pwzVerInfo = '\0';
            }
            else
            {
                pwzVerInfo = NULL;
            }

            if (*pwzTmp == L'{')
            {
                // handle CLSID string
                _pwzClsId = OLESTRDuplicate((LPCWSTR)pwzTmp);
                _pwzMime = NULL;
            }
            else
            {
                _pwzMime = OLESTRDuplicate((LPCWSTR)pwzTmp);
                _pwzClsId = NULL;
            }

            // compose cdl:// string
            dwSize = lstrlenW(pwzCDLFormatCDL) 
                    + (_pwzUrl ? lstrlenW(pwzCDLFormatCodebase) 
                                + lstrlenW(_pwzUrl)
                                + lstrlenW(pwzCDLFormatSeparator) : 0)
                    + (_pwzClsId ? lstrlenW(pwzCDLFormatClsId)
                                + lstrlenW(_pwzClsId) : 0)
                    + (_pwzMime ? lstrlenW(pwzCDLFormatMime) 
                                + lstrlenW(_pwzMime) : 0)
                    + (pwzVerMS ? lstrlenW(pwzCDLFormatVerMS)
                                + lstrlenW(pwzVerMS) : 0)
                    + (pwzVerLS ? lstrlenW(pwzCDLFormatVerLS)
                                + lstrlenW(pwzVerLS) : 0)
                    + 3;

            delete [] _pwzCDLURL;
            _pwzCDLURL = new WCHAR[dwSize];

            if (_pwzCDLURL)
            {
                StrCpyW(_pwzCDLURL, pwzCDLFormatCDL);
                
                // codebase is optional, but one of clsid or mimetype must exist.
                if (_pwzUrl)
                {
                    StrCatW(_pwzCDLURL, pwzCDLFormatCodebase);
                    StrCatW(_pwzCDLURL, _pwzUrl);
                    StrCatW(_pwzCDLURL, pwzCDLFormatSeparator);
                }
                
                if (_pwzClsId)
                {
                    StrCatW(_pwzCDLURL, pwzCDLFormatClsId);
                    StrCatW(_pwzCDLURL, _pwzClsId);
                }
                else if (_pwzMime)
                {
                    StrCatW(_pwzCDLURL, pwzCDLFormatMime);
                    StrCatW(_pwzCDLURL, _pwzMime);
                }
                else
                {
                    hr = E_UNEXPECTED;
                }

                if (pwzVerMS)
                {
                    StrCatW(_pwzCDLURL, pwzCDLFormatVerMS);
                    StrCatW(_pwzCDLURL, pwzVerMS);
                }
                if (pwzVerLS)
                {
                    StrCatW(_pwzCDLURL, pwzCDLFormatVerLS);
                    StrCatW(_pwzCDLURL, pwzVerLS);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

        }
        else
        {
            hr = E_INVALIDARG;
        }

        if (SUCCEEDED(hr) && _pwzCDLURL && pFilterData && pFilterData->pProtocol)
        {
            _pProt = pFilterData->pProtocol;
            _pProt->AddRef();

            _pProtSnk = pOInetProtSnk;
            _pProtSnk->AddRef();

            // Pass our IInternetProtocolSink out
            pFilterData->pProtocolSink = (IOInetProtocolSink *)this;

            hr = CoInternetGetSession(0, &pOInetSession, 0);

            if (SUCCEEDED(hr))
            {
                hr = pOInetSession->CreateBinding(NULL, _pwzCDLURL, NULL, NULL, 
                                         (IOInetProtocol **)&_pCDLnetProtocol, 
                                         OIBDG_APARTMENTTHREADED);
                pOInetSession->Release();

                if (SUCCEEDED(hr) && _pCDLnetProtocol)
                {
                    _pInstallSink = new CClassInstallFilterSink(this);
                    
                    if (_pInstallSink)
                    {

                        //hr = _CBindInfo.QueryInterface(IID_IOInetBindInfo, (void **)&pBindInfo);

                        pBindInfo = new CInstallBindInfo();

                        if (!pBindInfo) {
                            hr = E_OUTOFMEMORY;
                        }
        
                        if (SUCCEEDED(hr) && pBindInfo) 
                        {
                            hr = _pCDLnetProtocol->Start(_pwzCDLURL, 
                                    (IOInetProtocolSink *)_pInstallSink, 
                                    (IOInetBindInfo *)pBindInfo,
                                    PI_FORCE_ASYNC | PI_APARTMENTTHREADED, 0);
                            
                            // We add reference ourself so that if we are terminated before
                            // the cdl:// download we don't get deleted.

                            pBindInfo->Release();
                            pBindInfo = NULL;

                            if (hr == E_PENDING) {

                                AddRef();
                                _bAddRef = TRUE;

                                SetInstallState(installingHandler);
                            }
                        }

                    }
                    else 
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }

    }
    else
    {
        hr = E_FAIL;
    }

    // BUGBUG: when do we release if E_PENDING?
    if (hr != E_PENDING)
    {
        SetInstallState(installingDone);

        if (_pCDLnetProtocol)
        {
            _pCDLnetProtocol->Release();
            _pCDLnetProtocol = NULL;
        }

    }

    PerfDbgLog1(tagClassInstallFilter, this, "+CClassInstallFilter::Start (hr:%lx)\n",hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::Continue
//
//  Synopsis:
//
//  Arguments:  [pStateInfoIn] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::Continue(PROTOCOLDATA *pStateInfoIn)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::Continue\n");

    HRESULT hr = NOERROR;

    if (_pProt)
    {
         hr = _pProt->Continue(pStateInfoIn);
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::Continue (hr:%lx)\n",hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::Abort
//
//  Synopsis:
//
//  Arguments:  [hrReason] --
//              [dwOptions] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::Abort(HRESULT hrReason, DWORD dwOptions)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::Abort\n");
    HRESULT hr = NOERROR;

    if (_pCDLnetProtocol)
    { 
        hr = _pCDLnetProtocol->Abort(hrReason, dwOptions);
    }

    if (_pProt)
    {
        hr = _pProt->Abort(hrReason, dwOptions);        
    }

    // Release sink
    if (_pProtSnk)
    {
        _pProtSnk->Release();
        _pProtSnk = NULL;
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::Abort (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::Terminate
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::Terminate(DWORD dwOptions)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::Terminate\n");
    HRESULT hr = NOERROR;

    TransAssert((_pProt));

    if (_pCDLnetProtocol)
    {
        hr = _pCDLnetProtocol->Terminate(dwOptions);
    }

    if (_pProt)
    {
        hr = _pProt->Terminate(dwOptions);
    }

    // Release sink 
    if (_pProtSnk)
    {
        _pProtSnk->Release();
        _pProtSnk = NULL;
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::Terminate (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::Suspend
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::Suspend()
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::Suspend\n");
    HRESULT hr = NOERROR;
    
    if (_pProt) 
    {
         hr = _pProt->Suspend();
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::Suspend (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::Resume
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::Resume()
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::Resume\n");
    HRESULT hr = NOERROR;

    if (_pProt)
    {
        hr = _pProt->Resume();
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::Resume (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::Read
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::Read(void *pv,ULONG cb,ULONG *pcbRead)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::Read\n");
    HRESULT hr = NOERROR;

    if (_pProt)
    {
        hr = _pProt->Read(pv,cb,pcbRead);
    }
 
    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::Read (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::Seek
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

STDMETHODIMP CClassInstallFilter::Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,
                      ULARGE_INTEGER *plibNewPosition)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::Seek\n");
    HRESULT hr = NOERROR;

    if (_pProt)
    {
        hr = _pProt->Seek(dlibMove, dwOrigin, plibNewPosition);
    } 

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::Seek (hr:%lx)\n", hr);
    return hr;

}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::LockRequest
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::LockRequest(DWORD dwOptions)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::LockRequest\n");

    HRESULT hr = NOERROR;

    if (_pProt)
    {    
        hr = _pProt->LockRequest(dwOptions);
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::LockRequest (hr:%lx)\n",hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::UnlockRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::UnlockRequest()
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::UnlockRequest\n");
    HRESULT hr = NOERROR;

    if (_pProt)
    {
         hr = _pProt->UnlockRequest();
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::UnlockRequest (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::Switch
//
//  Synopsis:
//
//  Arguments:  [pStateInfo] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::Switch(PROTOCOLDATA *pStateInfo)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::Switch\n");
    HRESULT hr = NOERROR;

    if (_pProtSnk)
    {
        hr = _pProtSnk->Switch(pStateInfo);
    }
 
    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::Switch (hr:%lx)\n", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::ReportProgress
//
//  Synopsis:
//
//  Arguments:  [NotMsg] --
//              [szStatusText] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::ReportProgress(ULONG NotMsg, LPCWSTR pwzStatusText)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::ReportProgress\n");
    HRESULT hr = NOERROR;

    if (_pProtSnk)
    {
        hr = _pProtSnk->ReportProgress(NotMsg, pwzStatusText);
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::ReportProgress (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::ReportData
//
//  Synopsis:
//
//  Arguments:  [grfBSCF] --
//              [ULONG] --
//              [ulProgressMax] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::ReportData(DWORD grfBSCF, ULONG ulProgress, ULONG ulProgressMax)
{
    PerfDbgLog3(tagClassInstallFilter, this, "+CClassInstallFilter::ReportData(grfBSCF:%lx, ulProgress:%ld, ulProgressMax:%ld)\n",
                                       grfBSCF, ulProgress, ulProgressMax);
    HRESULT hr = NOERROR;

    _grfBSCF = grfBSCF;
    _ulProgress = ulProgress;
    _ulProgressMax = ulProgressMax;

    if (_pProtSnk)
    {
        hr = _pProtSnk->ReportData( grfBSCF, ulProgress, ulProgressMax);
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::ReportData (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::ReportResult
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [dwError] --
//              [wzResult] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::ReportResult(HRESULT hrResult, DWORD dwError, LPCWSTR wzResult)
{
    PerfDbgLog(tagClassInstallFilter, this, "+CClassInstallFilter::ReportResult\n");
    HRESULT hr = NOERROR;

    // record any failure, unless overwriting previous failure
    if (FAILED(hrResult) && SUCCEEDED(_hrResult) ) {

        _hrResult = hrResult;
        _dwError = dwError;
        _wzResult = NULL;

        if (_wzResult)
        {
            _wzResult = new WCHAR[lstrlenW(wzResult)+1];
            StrCpyW(_wzResult, wzResult);
        }
    }


    if (GetInstallState() != installingDone)
    {

        // data (docfile) completed download

        _fReportResult = TRUE;
    } 
    else if (_fReportResult)
    {
        // all complete
        if (_pProtSnk)
        {
            // always report recorded results
            hr = _pProtSnk->ReportResult(_hrResult, _dwError, _wzResult);

        }

    } else {

        // data (docfile) completed download
        _fReportResult = TRUE;
    }

    PerfDbgLog1(tagClassInstallFilter, this, "-CClassInstallFilter::ReportResult (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::CClassInstallFilter
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [dwError] --
//              [wzResult] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CClassInstallFilter::InstallerReportResult(HRESULT hrResult, DWORD dwError, LPCWSTR wzResult)
{
    HRESULT hr = NOERROR;

    SetInstallState(installingDone);

    if (_pProtSnk)
    {
        // tell sink to stop waiting on handler to install
        _pProtSnk->ReportProgress(BINDSTATUS_ENDDOWNLOADCOMPONENTS,NULL);

        // repeat last report data to kick start binding operation
        _pProtSnk->ReportData(_grfBSCF, _ulProgress, _ulProgressMax);
    }


    ReportResult(hrResult, dwError, wzResult);

    if (_bAddRef)
    {
        _bAddRef = FALSE;
        Release();
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CClassInstallFilter::QueryService
//
//  Synopsis:
//
//  Arguments:  [rsid] --
//              [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    06-27-97   EricV (Eric VandenBerg)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CClassInstallFilter::QueryService(REFGUID rsid, REFIID riid, void ** ppvObj)
{
    HRESULT     hr = NOERROR;
    IServiceProvider        *pIServiceProvider = NULL;

    EProtAssert(ppvObj);
    if (!ppvObj)
        return E_INVALIDARG;

    *ppvObj = 0;

    if (IsEqualGUID(rsid, IID_IInternetHostSecurityManager) &&
        IsEqualGUID(riid, IID_IInternetHostSecurityManager)) {

        if (_pSecMgr == NULL) {
            hr = CoInternetCreateSecurityManager(NULL, &_pSecMgr, NULL);
        }
        
        if (_pSecMgr) {
            *ppvObj = (IInternetHostSecurityManager *)this;
            AddRef();
        }
        else {
            hr = E_NOINTERFACE;
        }
    }
    else {
        hr = _pProtSnk->QueryInterface(IID_IServiceProvider,
                                                 (LPVOID *)&pIServiceProvider);
    
        if (SUCCEEDED(hr))
        {
            hr = pIServiceProvider->QueryService(rsid, riid, (LPVOID *)ppvObj);
            pIServiceProvider->Release();
        }
    }

    return hr;
}

// IInternetHostSecurityManager
STDMETHODIMP CClassInstallFilter::GetSecurityId(BYTE *pbSecurityId, DWORD *pcbSecurityId,
                                                DWORD_PTR dwReserved)
{
    HRESULT                    hr = E_FAIL;

    if (_pSecMgr) {
        hr = _pSecMgr->GetSecurityId(_pwzDocBase, pbSecurityId,
                                     pcbSecurityId, dwReserved);
    }

    return hr;
}

STDMETHODIMP CClassInstallFilter::ProcessUrlAction(DWORD dwAction, BYTE *pPolicy, DWORD cbPolicy,
                                                   BYTE *pContext, DWORD cbContext, DWORD dwFlags,
                                                   DWORD dwReserved)
{
    HRESULT                    hr = E_FAIL;

    if (_pSecMgr) {
        hr = _pSecMgr->ProcessUrlAction(_pwzDocBase, dwAction, pPolicy,
                                        cbPolicy, pContext, cbContext,
                                        dwFlags, dwReserved);
    }

    return hr;
}

STDMETHODIMP CClassInstallFilter::QueryCustomPolicy(REFGUID guidKey, BYTE **ppPolicy,
                                                    DWORD *pcbPolicy, BYTE *pContext,
                                                    DWORD cbContext, DWORD dwReserved)
{
    HRESULT                    hr = E_FAIL;

    if (_pSecMgr) {
        hr = _pSecMgr->QueryCustomPolicy(_pwzDocBase, guidKey, ppPolicy,
                                         pcbPolicy, pContext, cbContext,
                                         dwReserved);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\eapp\mimehndl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       mimehndl.cxx
//
//  Contents:   Class that performs the download of a particular request.
//
//  Classes:
//
//  Functions:
//
//  History:    12-04-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <eapp.h>


PerfDbgTag(tagCTransaction,    "Urlmon", "Log CTransaction",        DEB_TRANS)
    DbgTag(tagCTransactionErr, "Urlmon", "Log CTransaction Errors", DEB_TRANS|DEB_ERROR)
   
typedef struct _tagPROTOCOLFILTERDATA
{
    DWORD               cbSize;
    IOInetProtocolSink *pProtocolSink;  // out parameter
    IOInetProtocol     *pProtocol;      // in parameter
    IUnknown           *pUnk;
    DWORD               dwFilterFlags;  
} PROTOCOLFILTERDATA;


CMimeHandlerTest1::CMimeHandlerTest1(REFCLSID rclsid, IUnknown *pUnkOuter, IUnknown **ppUnkInner) : CBaseProtocol(rclsid, pUnkOuter, ppUnkInner)
{
    _pUnk = 0;
    _pProt = 0;
    _pProtSnk = 0;
    _dwMode = 0;
    _dwOInetBdgFlags = 0;
    _pBuffer = 0;           // DNLD_BUFFER_SIZE  size buffer
    _cbBufferSize = 0;
    _cbTotalBytesRead = 0;
    _cbBufferFilled = 0;    //how much of the buffer is in use
    _cbDataSniffMin = 0;
    _cbBytesReported = 0;
    _fDocFile = 0;
    _fMimeVerified = 0;
    _pwzFileName = 0;
    _pwzMimeSuggested = 0;
    _fDelete = 0;

}


//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::QueryInterface");

    *ppvObj = NULL;

    {
        if (   (riid == IID_IUnknown)
            || (riid == IID_IOInetProtocol))
        {
            *ppvObj = (IOInetProtocol *) this;
            AddRef();
        }
        else if (riid == IID_IOInetProtocolSink)
        {
            *ppvObj = (IOInetProtocolSink *) this;
            AddRef();
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }


    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::QueryInterface (hr:%lx)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CMimeHandlerTest1::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeHandlerTest1::AddRef(void)
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::AddRef");

    LONG lRet;
  
    {
        lRet = ++_CRefs;
    }
    
    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::AddRef (cRefs:%ld)", lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CMimeHandlerTest1::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMimeHandlerTest1::Release(void)
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::Release");

    LONG lRet;
    {
        lRet = --_CRefs;
        if (_CRefs == 0 && _fDelete)
        {
            delete this;
        }
    }

    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::Release (cRefs:%ld)", lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::Start
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pTrans] --
//              [pOIBindInfo] --
//              [grfSTI] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::Start(LPCWSTR pwzUrl, IOInetProtocolSink *pOInetProtSnk, IOInetBindInfo *pOIBindInfo,
                          DWORD grfSTI, DWORD dwReserved)
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::Start\n");
    HRESULT hr = NOERROR;
    PROTOCOLFILTERDATA *pFilterData = 0;

    TransAssert((pOIBindInfo && pOInetProtSnk));
    if (dwReserved)
    {
        pFilterData = (PROTOCOLFILTERDATA *)dwReserved;
    }
    if (pFilterData && pOInetProtSnk)
    {
        TransAssert((pOIBindInfo && pOInetProtSnk));
        _pProt = pFilterData->pProtocol;
        if (_pProt)
        {
            _pProt->AddRef();
        }
        else
        {
            hr = E_FAIL;
        }
        _pProtSnk = pOInetProtSnk;
        _pProtSnk->AddRef();
    }
    else
    {
        hr = E_FAIL;
    }

    PerfDbgLog1(tagCTransaction, this, "+CMimeHandlerTest1::Start (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::Continue
//
//  Synopsis:
//
//  Arguments:  [pStateInfoIn] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::Continue(PROTOCOLDATA *pStateInfoIn)
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::Continue\n");

    HRESULT hr = _pProt->Continue(pStateInfoIn);

    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::Continue (hr:%lx)\n",hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::Abort
//
//  Synopsis:
//
//  Arguments:  [hrReason] --
//              [dwOptions] --
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::Abort(HRESULT hrReason, DWORD dwOptions)
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::Abort\n");
    HRESULT hr = NOERROR;

    hr = _pProt->Abort(hrReason, dwOptions);

    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::Abort (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::Terminate
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::Terminate(DWORD dwOptions)
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::Terminate\n");
    HRESULT hr = NOERROR;

    TransAssert((_pProt));
    //IOInetProtocol *pProt = _pProt;
    
    hr = _pProt->Terminate(dwOptions);
    //pProt->Release();
    //_pProt = 0;

    _pProtSnk->Release();
    _pProtSnk = 0;
    
    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::Terminate (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::Suspend
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::Suspend()
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::Suspend\n");

    HRESULT hr = _pProt->Suspend();

    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::Suspend (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::Resume
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::Resume()
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::Resume\n");

    HRESULT hr = _pProt->Resume();

    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::Resume (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::Read
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//              [ULONG] --
//              [pcbRead] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::Read(void *pBuffer, ULONG cbBuffer,ULONG *pcbRead)
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::Read\n");
    HRESULT     hr = E_FAIL;

    BOOL fRead = TRUE;
    DWORD dwCopy = 0;
    DWORD dwCopyNew = 0;

    if (   (_dwOInetBdgFlags & (PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP))
        && (_cbBufferFilled))
    {
        fRead = FALSE;

        // copy data form the local buffer to the provide buffer
        if (cbBuffer < _cbBufferFilled)
        {
            dwCopy = cbBuffer;
            memcpy(pBuffer, _pBuffer, cbBuffer);
            // move the memory to the front
            memcpy(_pBuffer, _pBuffer + cbBuffer, _cbBufferFilled - cbBuffer);
            _cbBufferFilled -= cbBuffer;
            hr = S_OK;
        }
        else if (cbBuffer == _cbBufferFilled)
        {
            dwCopy = _cbBufferFilled;
            memcpy(pBuffer, _pBuffer, _cbBufferFilled);
            _cbBufferFilled = 0;
            hr = S_OK;
        }
        else
        {
            //
            // user buffer is greater than what is available in
            //
            dwCopy = _cbBufferFilled;
            memcpy(pBuffer, _pBuffer, _cbBufferFilled);
            _cbBufferFilled = 0;
            fRead = TRUE;
            hr = E_PENDING;
        }
    }

    if (fRead)
    {
        if (_pProt)
        {
            hr = _pProt->Read( ((LPBYTE)pBuffer) + dwCopy, cbBuffer - dwCopy, &dwCopyNew);
            _cbTotalBytesRead += dwCopyNew;
        }
        else
        {
            hr = S_FALSE;
        }
    }

    if (pcbRead)
    {
        *pcbRead = dwCopy + dwCopyNew;
    }
 

    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::Read (hr:%lx)\n",hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::Seek
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [ULARGE_INTEGER] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::Seek\n");

    HRESULT hr = _pProt->Seek(dlibMove, dwOrigin, plibNewPosition);

    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::Seek (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::LockRequest
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::LockRequest(DWORD dwOptions)
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::LockRequest\n");

    HRESULT hr = hr = _pProt->LockRequest(dwOptions);

    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::LockRequest (hr:%lx)\n",hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::UnlockRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::UnlockRequest()
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::UnlockRequest\n");
    HRESULT hr = NOERROR;

    hr = _pProt->UnlockRequest();

    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::UnlockRequest (hr:%lx)\n", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CTransaction::OnDataReceived
//
//  Synopsis:
//
//  Arguments:  [grfBSC] --
//              [cbBytesAvailable] --
//              [dwTotalSize] --
//              [pcbNewAvailable] --
//
//  Returns:
//
//  History:    4-15-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
#if 0
STDMETHODIMP CMimeHandlerTest1::OnDataReceived(DWORD *pgrfBSC, DWORD *pcbBytesAvailable, DWORD *pdwTotalSize) //, DWORD *pcbNewAvailable)
{
    PerfDbgLog3(tagCTransaction, this, "+CMimeHandlerTest1::OnDataReceived (grfBSC:%lx,  cbBytesAvailable:%ld, _cbTotalBytesRead:%ld)",
                                    *pgrfBSC, *pcbBytesAvailable, _cbTotalBytesRead);
    HRESULT hr = NOERROR;
    DWORD grfBSC = *pgrfBSC;
    DWORD cbBytesAvailable = *pcbBytesAvailable; 
    DWORD dwTotalSize = *pdwTotalSize;
    DWORD *pcbNewAvailable = &cbBytesAvailable;
    
    *pcbNewAvailable = cbBytesAvailable;

    if (_dwOInetBdgFlags & (PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP))
    {
        DWORD dwNewData = 0;
        TransAssert((_pProt && _cbDataSniffMin));

        // _cbTotalBytesRead = # of bytes read so far
        if (_cbTotalBytesRead < _cbDataSniffMin)
        {
            // no bytes read so far
            TransAssert((_cbTotalBytesRead < _cbDataSniffMin));
            // read data into buffer and report progess
            do
            {
                hr = _pProt->Read(_pBuffer + _cbBufferFilled, _cbBufferSize - _cbBufferFilled, &dwNewData);
                _cbTotalBytesRead += dwNewData;
                _cbBufferFilled += dwNewData;
            } while ((hr == S_OK) && (_cbTotalBytesRead < _cbDataSniffMin));

            // now check if this is docfile
            // if so download at least 2k
            if (!_fDocFile && _cbBufferFilled && (IsDocFile(_pBuffer, _cbBufferFilled) == S_OK))
            {
                _fDocFile = TRUE;
                _cbDataSniffMin =  (dwTotalSize && dwTotalSize < DATASNIFSIZEDOCFILE_MIN) ? dwTotalSize : DATASNIFSIZEDOCFILE_MIN;
            }

            if ((hr == E_PENDING) && (_cbTotalBytesRead < _cbDataSniffMin))
            {
                // do not report anything - wait until we get more data
                // a request is pending at this time
                // need more data to sniff properly
                hr  = S_NEEDMOREDATA;
            }
            else if (hr == NOERROR || hr == E_PENDING)
            {
                TransAssert((_cbTotalBytesRead != 0));

                // report the data we have in the buffer or
                // the available #
                DWORD cbBytesReport =  (cbBytesAvailable > _cbTotalBytesRead) ? cbBytesAvailable : _cbTotalBytesRead + 1;

                if (dwTotalSize && ((cbBytesReport > dwTotalSize)))
                {
                    cbBytesReport =  dwTotalSize;
                }
                *pcbNewAvailable = cbBytesReport;
            }
            else if (hr == S_FALSE)
            {
                // end of stream
                *pgrfBSC |=  (BSCF_LASTDATANOTIFICATION & BSCF_DATAFULLYAVAILABLE);
                *pcbBytesAvailable = *pdwTotalSize =  _cbTotalBytesRead;
            }
            
            if (   (!_fMimeVerified)
                && (   (*pcbNewAvailable >= _cbDataSniffMin)
                    || (hr == S_FALSE)) )
            {
                // enough data or end of stream
                _fMimeVerified = TRUE;
                LPCWSTR  pwzStr = FindMimeFromDataIntern(_pwzFileName,_pBuffer, _cbBufferFilled, _pwzMimeSuggested, 0);
                _pProtSnk->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, pwzStr);
                
                if (_pwzMimeSuggested != pwzStr)
                {
                    if (_pwzMimeSuggested)
                    {
                        delete [] _pwzMimeSuggested;
                    }
                    if (pwzStr)
                    {
                        _pwzMimeSuggested = OLESTRDuplicate((LPWSTR)pwzStr);
                    }
                }

                if (   _fDocFile
                    && (_dwOInetBdgFlags & PI_DOCFILECLSIDLOOKUP))
                {
                    // find the class id and send it on
                    CLSID clsid;

                    HRESULT hr1 = GetClassDocFileBuffer(_pBuffer, _cbBufferFilled, &clsid);
                    if (hr1 == NOERROR)
                    {
                        LPOLESTR pwzStrClsId;
                        StringFromCLSID(clsid, &pwzStrClsId);
                        _pProtSnk->ReportProgress(BINDSTATUS_CLASSIDAVAILABLE, pwzStrClsId);

                        delete [] pwzStrClsId;
                    }
                }
            }
            hr = NOERROR;
        }
        //TransAssert((cbBytesAvailable <= *pcbNewAvailable));
        if (cbBytesAvailable > *pcbNewAvailable)
        {
            *pcbNewAvailable = cbBytesAvailable;
        }
        if (dwTotalSize && (dwTotalSize < *pcbNewAvailable))
        {
            *pcbNewAvailable = dwTotalSize;
        }
    }
    
    {
        CLock lck(_mxs);
        _cbBytesReported = *pcbNewAvailable;
        *pdwTotalSize = dwTotalSize;
    }


    PerfDbgLog2(tagCTransaction, this, "-CMimeHandlerTest1::OnDataReceived (hr:%lx, _cbBufferFilled:%lx)", hr, _cbBufferFilled);
    return hr;
}
#endif // 0
//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::Switch
//
//  Synopsis:
//
//  Arguments:  [pStateInfo] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::Switch(PROTOCOLDATA *pStateInfo)
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::Switch");
    HRESULT hr = NOERROR;

    hr = _pProtSnk->Switch(pStateInfo);
   
    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::Switch (hr:%lx)", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::ReportProgress
//
//  Synopsis:
//
//  Arguments:  [NotMsg] --
//              [szStatusText] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::ReportProgress(ULONG NotMsg, LPCWSTR pwzStatusText)
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::ReportProgress");
    HRESULT hr = NOERROR;

    switch (NotMsg)
    {
    case BINDSTATUS_MIMETYPEAVAILABLE:
        if (_dwOInetBdgFlags & (PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP))
        {
            // report the mime later after sniffing data
            _pwzMimeSuggested = OLESTRDuplicate(pwzStatusText);
        }
        else
        {
            hr = _pProtSnk->ReportProgress(NotMsg, pwzStatusText);
        }

    break;

    case BINDSTATUS_CACHEFILENAMEAVAILABLE :
        _pwzFileName = OLESTRDuplicate(pwzStatusText);

    default:
    {
        hr = _pProtSnk->ReportProgress(NotMsg, pwzStatusText);
        
    }

    } // end switch
    
    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::ReportProgress (hr:%lx)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::ReportData
//
//  Synopsis:
//
//  Arguments:  [grfBSCF] --
//              [ULONG] --
//              [ulProgressMax] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::ReportData(DWORD grfBSCF, ULONG ulProgress,ULONG ulProgressMax)
{
    PerfDbgLog3(tagCTransaction, this, "+CMimeHandlerTest1::ReportData(grfBSCF:%lx, ulProgress:%ld, ulProgressMax:%ld)",
                                       grfBSCF, ulProgress, ulProgressMax);
    HRESULT hr = NOERROR;
    /*
    if (   (_dwOInetBdgFlags & (PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP)
        && (OnDataReceived(&grfBSCF, &ulProgress, &ulProgressMax) == NOERROR)) )
    {
        hr = _pProtSnk->ReportData( grfBSCF, ulProgress, ulProgressMax);
    }
    else
    */
    {
        hr = _pProtSnk->ReportData( grfBSCF, ulProgress, ulProgressMax);
    }

    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::ReportData (hr:%lx)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMimeHandlerTest1::ReportResult
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [dwError] --
//              [wzResult] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMimeHandlerTest1::ReportResult(HRESULT hrResult, DWORD dwError, LPCWSTR wzResult)
{
    PerfDbgLog(tagCTransaction, this, "+CMimeHandlerTest1::ReportResult");
    HRESULT hr = NOERROR;

    hr = _pProtSnk->ReportResult(hrResult, dwError, wzResult);
    
    PerfDbgLog1(tagCTransaction, this, "-CMimeHandlerTest1::ReportResult (hr:%lx)", hr);
    return hr;
}

STDMETHODIMP CMimeHandlerTest1::Initialize(DWORD dwMode, DWORD dwOptions, IUnknown *pUnk, IOInetProtocol *pProt, IOInetProtocolSink *pProtSnk)
{
    HRESULT hr = NOERROR;
    _dwMode = dwMode;
    _pUnk = pUnk;
    _pProt = pProt;
    _pProtSnk = pProtSnk;
    if (_pProtSnk)
    {
        _pProtSnk->AddRef();
    }
    if (_pUnk)
    {
        _pUnk->AddRef();
    }
    
    _dwOInetBdgFlags = dwOptions;
    if (_dwOInetBdgFlags & (PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP))
    {
        _cbBufferSize = DATASNIFSIZEDOCFILE_MIN; 
        _pBuffer = (LPBYTE) new BYTE[_cbBufferSize];

        if (!_pBuffer)
        {
            _cbBufferSize = 0;
            hr = E_OUTOFMEMORY;
        }
        _cbDataSniffMin = _cbBufferSize;
    }
    TransAssert((_pUnk && _pProt && _pProtSnk));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\eapp\knownhnd.cxx ===
#include <eapp.h>

typedef struct tagHandlerInfo
{
    LPWSTR          pwzHandler;
    DWORD           dwId;
    CLSID           *pClsID;
} HandlerInfo;


HandlerInfo rgKnownHandlers[] =
{
     { L"gzip" ,                    1,  (CLSID *) &CLSID_DeCompMimeFilter }
    ,{ L"deflate",                  2,  (CLSID *) &CLSID_DeCompMimeFilter }
    ,{ L"Class Install Handler",    3,  (CLSID *) &CLSID_ClassInstallFilter }
    ,{ L"cdl",                      4,  (CLSID *) &CLSID_CdlProtocol }
};


//+---------------------------------------------------------------------------
//
//  Function:   IsKnownHandler
//
//  Synopsis:   looks up if the Known Handler 
//
//  Arguments:  [wzHandler] --
//
//  Returns:    
//
//  History:    07-17-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD IsKnownHandler(LPCWSTR wzHandler)
{
    DWORD dwRet = 0;
    int i = 0;
    int cSize = sizeof(rgKnownHandlers)/sizeof(HandlerInfo);

    for (i = 0; i < cSize; ++i)
    {
        if (!_wcsicmp(wzHandler, rgKnownHandlers[i].pwzHandler) )
        {
            dwRet = rgKnownHandlers[i].dwId;
            i = cSize;
        }
    }
    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetKnownHandlerClsID
//
//  Synopsis:
//
//  Arguments:  [dwId] --
//
//  Returns:
//
//  History:    07-17-1997   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CLSID *GetKnownHandlerClsID(DWORD dwId)
{
    CLSID *pclsid = 0;
    int cSize = sizeof(rgKnownHandlers)/sizeof(HandlerInfo);

    for (int i = 0; i < cSize; ++i)
    {
        if (dwId == rgKnownHandlers[i].dwId )
        {
            pclsid = rgKnownHandlers[i].pClsID;
            i = cSize;
        }
    }

    return pclsid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\eapp\cmimeft.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       CMimeFt.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    04-16-97   DanpoZ (Danpo Zhang)   Created
//
//----------------------------------------------------------------------------
#include <eapp.h>

PerfDbgTag(tagMft,   "Pluggable MF ", "Log CMimeFt", DEB_PROT)
    DbgTag(tagMftErr,"Pluggable MF", "Log CMimeFt Errors", DEB_PROT|DEB_ERROR)

PerfDbgTag(tagPF,   "Pluggable MF ", "Log Perf", DEB_PROT)



#ifndef unix

#define JOB_MINS_PER_HOUR               60i64
#define JOB_HOURS_PER_DAY               24i64
#define JOB_MILLISECONDS_PER_SECOND     1000i64
#define JOB_MILLISECONDS_PER_MINUTE     (60i64 * JOB_MILLISECONDS_PER_SECOND)
#define FILETIMES_PER_MILLISECOND       10000i64
#define FILETIMES_PER_MINUTE            (FILETIMES_PER_MILLISECOND * JOB_MILLISECONDS_PER_MINUTE)
#define FILETIMES_PER_DAY               (FILETIMES_PER_MINUTE * JOB_MINS_PER_HOUR * JOB_HOURS_PER_DAY)

#else
#define JOB_MINS_PER_HOUR               60LL
#define JOB_HOURS_PER_DAY               24LL
#define JOB_MILLISECONDS_PER_SECOND     1000LL
#define JOB_MILLISECONDS_PER_MINUTE     (60LL * JOB_MILLISECONDS_PER_SECOND)
#define FILETIMES_PER_MILLISECOND       10000LL
#define FILETIMES_PER_MINUTE            (FILETIMES_PER_MILLISECOND * JOB_MILLISECONDS_PER_MINUTE)
#define FILETIMES_PER_DAY               (FILETIMES_PER_MINUTE * JOB_MINS_PER_HOUR * JOB_HOURS_PER_DAY)

#endif /* unix */

#define GZIPHACK    8624

void
AddDaysToFileTime(LPFILETIME pft, WORD Days)
{
    if (!Days)
    {
        return; // Nothing to do.
    }

    //
    // ft = ft + Days * FILETIMES_PER_DAY;
    //
    ULARGE_INTEGER uli, uliSum;
    uli.LowPart  = pft->dwLowDateTime;
    uli.HighPart = pft->dwHighDateTime;
#ifndef unix
    uliSum.QuadPart = uli.QuadPart + (__int64)Days * FILETIMES_PER_DAY;
#else
    U_QUAD_PART(uliSum) = U_QUAD_PART(uli) + (__int64)Days * FILETIMES_PER_DAY;
#endif /* unix */
    pft->dwLowDateTime  = uliSum.LowPart;
    pft->dwHighDateTime = uliSum.HighPart;
}

// helper from transapi.cxx
HRESULT GetMimeFileExtension(LPSTR, LPSTR, DWORD);

//+---------------------------------------------------------------------------
//
//  Method:     CMimeFt::QueryInterface
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    04-16-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CMimeFt::QueryInterface(REFIID riid, void **ppvObj)
{
    PerfDbgLog(tagMft, this, "+CMimeFt::QueryInterface");

    VDATEPTROUT(ppvObj, void*);
    VDATETHIS(this);

    HRESULT hr = NOERROR;
    *ppvObj = NULL;

    if( (riid == IID_IUnknown) ||
        (riid == IID_IOInetProtocol) || 
        (riid == IID_IOInetProtocolRoot)) 
    { 
        *ppvObj = (IOInetProtocol*) this;
        AddRef();
    }
    else if (riid == IID_IOInetProtocolSink ) 
    {
        *ppvObj = (IOInetProtocolSink*) this;
        AddRef();
    }
    else if (riid == IID_IOInetProtocolSinkStackable ) 
    {
        *ppvObj = (IOInetProtocolSinkStackable*) this;
        AddRef();
    }
    else
        hr = E_NOINTERFACE;

    PerfDbgLog1(tagMft, this, "-CMimeFt::QueryInterface(hr:%1x)", hr);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMimeFt::AddRef
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    04-16-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) 
CMimeFt::AddRef(void) 
{
    PerfDbgLog(tagMft, this, "+CMimeFt::AddRef");

    LONG lRet = ++_CRefs;

    PerfDbgLog1(tagMft, this, "-CMimeFt::AddRef (cRef:%1d)", lRet);
    return lRet;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMimeFt::Release
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    04-16-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) 
CMimeFt::Release(void) 
{
    PerfDbgLog(tagMft, this, "+CMimeFt::Release");
    LONG lRet = --_CRefs;
    if( !lRet )
        delete this;

    PerfDbgLog1(tagMft, this, "-CMimeFt::Release (cRef:%1d)", lRet);
    return lRet;    
}


//+---------------------------------------------------------------------------
//
//  Method:     CMimeFt::Start
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pProtSink] --
//              [pOIBindInfo] --
//              [grfSTI] --
//              [dwReserved] --
//
//  Returns:    E_PENDING indicating the current filter is not empty
//
//  History:    04-16-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CMimeFt::Start(
    LPCWSTR pwzUrl,
    IOInetProtocolSink *pProtSink,
    IOInetBindInfo *pOIBindInfo,
    DWORD grfPI,
    DWORD_PTR dwReserved)
{
    PerfDbgLog(tagMft, this, "+CMimeFt::Start");
    PerfDbgLog(tagPF, this, "*************CMimeFt::Start");
    PProtAssert( pwzUrl && (!_pProtSink) && pProtSink && dwReserved );
    HRESULT hr = NOERROR;

    PProtAssert((grfPI & PI_FILTER_MODE));
    if( !(grfPI & PI_FILTER_MODE) )
        hr = E_INVALIDARG;

    // download or upload? from the rrfPI flag...

    if( !hr )
    {
        //get the Prot pointer here
        PROTOCOLFILTERDATA* FiltData = (PROTOCOLFILTERDATA*) dwReserved;
        _pProt = FiltData->pProtocol;
        _pProt->AddRef();
    
        //get the sink pointer here 
        _pProtSink = pProtSink;
        _pProtSink->AddRef();

        // create or reload the data filter 
        if( _pDF )
        {
            _pDF->Release(); 
            _pDF = NULL;
        }

        //
        // this piece needs some more work 
        // 1. pEFtFac will be CoCreated according to reg setting 
        // 2. We will keep a linked list for existing EFFactory
        //
        IEncodingFilterFactory* pEFtFac = new CEncodingFilterFactory;
        if( pEFtFac )
        {
            // should we use enum or string value?
            hr = pEFtFac->GetDefaultFilter( pwzUrl, L"text", &_pDF);
            PProtAssert(_pDF);

            // don't need the factory anymore, 
            // but later, we will keep it on the list
            pEFtFac->Release(); 
    
            // reset all internal counter
            _ulCurSizeFmtIn = 0;
            _ulCurSizeFmtOut = 0;
            _ulTotalSizeFmtIn = 0;
            _ulTotalSizeFmtOut = 0;
            _ulOutAvailable = 0;
            _ulContentLength = 0;


            hr = _pProtSink->ReportProgress(BINDSTATUS_DECODING, pwzUrl);
        }
        else
            hr = E_OUTOFMEMORY;

        BOOL fNeedCache = TRUE;

        if( hr == NOERROR )
        {
            DWORD       dwBINDF;
            BINDINFO    bindInfo;
            bindInfo.cbSize = sizeof(BINDINFO);
            hr = pOIBindInfo->GetBindInfo(&dwBINDF, &bindInfo);

            // not generate cache file if user specifies BINDF_NOWRITECACHE
            if( hr == NOERROR)
            {
                if( dwBINDF & BINDF_NOWRITECACHE )
                {
                    fNeedCache = FALSE;
                }
                //  BINDINFO_FIX(LaszloG) 8/15/96
                ReleaseBindInfo(&bindInfo);
            }
        }

        if( hr == NOERROR && fNeedCache )
        {
            // Create cache file entry

            // 1. get url name
            ULONG ulCount;
            LPWSTR rgwzStr[1] = {NULL};
            LPSTR pszURL = NULL;
            

            hr = pOIBindInfo->GetBindString(
                BINDSTRING_URL, (LPWSTR*)rgwzStr, 1, &ulCount);
            if( hr == NOERROR && ulCount == 1 )
            {
                pszURL = DupW2A(rgwzStr[0]);        
                if( pszURL )
                {
                    strncpy(_szURL, pszURL, MAX_PATH);
                }
                else
                {
                    _szURL[0] = '\0';
                }
            }

            delete [] rgwzStr[0];
            delete [] pszURL;

            /******** move to ::Read to get accurate file ext ******
            // 2. get cache file name and create file handle
            if( hr == NOERROR && _szURL[0] != '\0' )
            {
                LPSTR pszExt = NULL;
                pszExt = FindFileExtension(_szURL); 
                if( pszExt && *pszExt == '.' )
                {
                    // FindFileExtion will return ".htm" but wininet is
                    // expecting "htm", so remove the extra "." 
                    pszExt++; 
                }
                if( CreateUrlCacheEntry(_szURL, 0, pszExt, _szFileName, 0) )
                {
                    if( _szFileName[0] != '\0' )
                    {
                        _hFile = CreateFile(_szFileName, 
                            GENERIC_WRITE, FILE_SHARE_WRITE | FILE_SHARE_READ,
                            NULL,CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
                        if( _hFile == INVALID_HANDLE_VALUE )
                        {
                            _hFile = NULL;
                        }
                    }
                }   
            }

            // Report the CACHE file name
            LPWSTR pwzFileName = NULL;
            if( _szFileName[0] != '\0' )
            {
                pwzFileName = DupA2W(_szFileName);
            }

            if( pwzFileName )
            {
                ReportProgress(
                    BINDSTATUS_CACHEFILENAMEAVAILABLE, pwzFileName);

                delete [] pwzFileName;
            }
            ******** move to ::Read to get accurate file ext ******/

        }
    }

    PerfDbgLog1(tagMft, this, "-CMimeFt::Start (hr:%1x)", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMimeFt::Continue
//
//  Synopsis:
//
//  Arguments:  [pStateInfo] --
//
//  Returns:
//
//  History:    04-16-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CMimeFt::Continue( PROTOCOLDATA *pStateInfo) 
{
    PerfDbgLog(tagMft, this, "+CMimeFt::Continue");
    PProtAssert( _pProt );
    HRESULT hr = _pProt->Continue(pStateInfo);

    PerfDbgLog1(tagMft, this, "-CMimeFt::Continue(hr:%1x)", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMimeFt::Abort
//
//  Synopsis:
//
//  Arguments:  [hrReason] --
//              [dwOptions] --
//
//  Returns:
//
//  History:    04-16-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CMimeFt::Abort( HRESULT hrReason, DWORD dwOptions)
{
    PerfDbgLog(tagMft, this, "+CMimeFt::Abort");
    PProtAssert( _pProt );

    HRESULT hr = _pProt->Abort(hrReason, dwOptions);

    PerfDbgLog1(tagMft, this, "-CMimeFt::Abort(hr:%1x)", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMimeFt::Terminate
//
//  Synopsis:
//
//  Arguments: [dwOptions] --
//
//  Returns:
//
//  History:    04-16-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CMimeFt::Terminate( DWORD dwOptions)
{
    PerfDbgLog(tagMft, this, "+CMimeFt::Terminate");
    PProtAssert( _pProt );
    HRESULT hr = NOERROR;

    // release the sink
    if( _pProtSink )
    {
        _pProtSink->Release();
        //_pProtSink = NULL;
    }

    // unload the data filter 
    if( _pDF )
    {
        _pDF->Release(); 
        _pDF = NULL;
    }

    
    // get expire and lastmodified time from wininet
    INTERNET_CACHE_TIMESTAMPS   st;
    DWORD cbSt = sizeof(st);
    memset(&st, 0, cbSt);
    if (_pProt)
    {
        IWinInetHttpInfo* pWin = NULL;
        hr = _pProt->QueryInterface(IID_IWinInetHttpInfo, (void**)&pWin);
        if( hr == NOERROR && pWin )
        {
            pWin->QueryOption( INTERNET_OPTION_CACHE_TIMESTAMPS, &st, &cbSt);
            pWin->Release();
        }
    }

    // close the file handle
    if( _hFile )
    {
        CloseHandle(_hFile);
        _hFile = NULL;
    }

    // Commit ( or delete) cache file entry
    if( _szFileName[0] != '\0' && _szURL[0] != '\0' )
    {
        char szHeader[256];
        char szMime[64];

        W2A(_pwzMimeSuggested, szMime, 64); 
        wsprintf(szHeader, "HTTP/1.0 200 OK\r\nContent-Length: %d\r\nContent-Type: %s\r\n\r\n", 
                 _ulContentLength, szMime);          
 
        DWORD dwLen = strlen(szHeader);
        CommitUrlCacheEntry( _szURL, _szFileName, st.ftExpires, 
            st.ftLastModified, NORMAL_CACHE_ENTRY, 
            (LPBYTE)szHeader, dwLen, NULL, 0);

    }

    if (_pProt)
    {
        hr = _pProt->Terminate(dwOptions);
    }

    PerfDbgLog1(tagMft, this, "-CMimeFt::Terminate(hr:%1x)", hr);
    PerfDbgLog(tagPF, this, "*************CMimeFt::Terminate");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMimeFt::Suspend
//
//  Synopsis:
//
//  Arguments: [none]
//
//  Returns:
//
//  History:    04-16-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CMimeFt::Suspend()
{
    PerfDbgLog(tagMft, this, "+CMimeFt::Suspend");
    PProtAssert( _pProt );
    HRESULT hr = _pProt->Suspend();

    PerfDbgLog1(tagMft, this, "-CMimeFt::Suspend(hr:%1x)", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMimeFt::Resume
//
//  Synopsis:
//
//  Arguments:  [none]
//
//  Returns:
//
//  History:    04-16-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CMimeFt::Resume()
{
    PerfDbgLog(tagMft, this, "+CMimeFt::Resume");
    PProtAssert( _pProt );

    HRESULT hr = _pProt->Resume();
    PerfDbgLog1(tagMft, this, "-CMimeFt::Suspend(hr:%1x)", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMimeFt::Read
//
//  Synopsis:   The real read is implemented in SmartRead, which also
//              serves as a data sniffer
//
//  Arguments:
//
//  Returns:
//
//  History:    04-16-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:         
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CMimeFt::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
    HRESULT hr = NOERROR;

    _fReadInProgress = TRUE;
    hr = SmartRead(pv, cb, pcbRead, FALSE);
    _fReadInProgress = FALSE;

    // do delay report result
    if( hr == S_FALSE && _fDelayReport )
    {
        ReportResult(_hrResult, _dwError, _wzResult);
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMimeFt::SmartRead
//
//  Synopsis:   implementation of ::Read, we add one parameter indicating 
//              if this read is for data sniffing purpose, 
//              (the goal datasniff read is to ReportProgress(MIME), 
//               data is not returned to the user buffer, this is to overcome
//               the problem that if you do data sniffing in the real Read and
//               report progress from a free thread, the message won't get 
//               to the apartment thread until it finishs the read, which 
//               might be too late for BindToObject)  
//
//  Arguments:
//
//  Returns:
//
//  History:    11-24-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:         
//
//----------------------------------------------------------------------------
HRESULT
CMimeFt::SmartRead(void *pv, ULONG cb, ULONG *pcbRead, BOOL fSniff)
{
    PerfDbgLog(tagMft, this, "+CMimeFt::Read");
    if(fSniff)
    {
        PerfDbgLog(tagMft, this, "+CMimeFt::Read - sniffing");
    }
    else
    {
        PProtAssert( pv && _pOutBuf && pcbRead );
    }
    HRESULT hr = NOERROR;
    
    LONG    lRead = 0;
    HRESULT hrRead = E_FAIL;
    HRESULT hrCode = NOERROR;
    BOOL    fPullData = FALSE;

    // no data, I have to pull more
    if( _ulOutAvailable == 0 ) 
    {
        if( _ulInBufferLeft == 0) 
        {
            hrRead = _pProt->Read(_pInBuf, FT_IBUF_SIZE-2, (ULONG*)&lRead);  
            PerfDbgLog2(tagMft, this, " CMimeFt::Read-Pull %u bytes (hr %1x)", 
                lRead, hrRead);
            fPullData = TRUE;
        }
        else
        {
            lRead = _ulInBufferLeft;
        }        

    }

    if( lRead ) 
    {
        LONG    lInUsed = 0;
        LONG    lOutUsed = 0;
        BYTE*   pInBuf = _pInBuf; 

        if( _bEncoding )
            hrCode = _pDF->DoEncode(
                        0,
                        FT_IBUF_SIZE,
                        pInBuf, 
                        FT_OBUF_SIZE,
                        _pOutBuf, 
                        lRead,
                        &lInUsed,
                        &lOutUsed,
                        0);
        else
        {
            hrCode = _pDF->DoDecode(
                        0,
                        FT_IBUF_SIZE,
                        pInBuf,
                        FT_OBUF_SIZE,
                        _pOutBuf,
                        lRead,
                        &lInUsed, 
                        &lOutUsed,
                        0); 
        }

        if( hrCode != NOERROR )
        {
            // error msg from winerr.h
            _pProtSink->ReportResult(hr, CRYPT_E_BAD_ENCODE, NULL);

            // make sure we clean up the filter
            _ulOutAvailable = 0;
            _ulInBufferLeft = 0;

            PerfDbgLog(tagMft, this, " CMimeFt::Read-Encode/Decode Failed");
        }
        else
        {

            // update 
            _ulCurSizeFmtOut += lOutUsed;
            _ulOutAvailable = lOutUsed;

            // do we get all the data?
            if( lInUsed < lRead )
            {
                // move mem to front
                memcpy(_pInBuf, _pInBuf+lInUsed, lRead-lInUsed);
                _ulInBufferLeft = lRead - lInUsed;
            }
            else
            {
                _ulInBufferLeft = 0;
            }


            if( !_bMimeVerified )
            {
                _bMimeVerified = TRUE;
                LPWSTR pwzStr = NULL;
                LPWSTR pwzFileName = NULL;
                if( _szFileName[0] != '\0' )
                {
                    pwzFileName = DupA2W(_szFileName);
                }

                FindMimeFromData(NULL, pwzFileName, _pOutBuf, lOutUsed, 
                        _pwzMimeSuggested, 0, &pwzStr, 0);

                pwzFileName = NULL;

                if( !_bMimeReported && !_bEncoding ) 
                {
                    _bMimeReported = TRUE;
                    if( pwzStr )
                    {
                        hr = _pProtSink->ReportProgress(
                            BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE, pwzStr);
                    }
                    else
                    {
                        hr = _pProtSink->ReportProgress(
                            BINDSTATUS_MIMETYPEAVAILABLE, L"text/html");
                    }
                }
                
                if( pwzStr )
                {
                    delete [] _pwzMimeSuggested;
                    _pwzMimeSuggested = pwzStr;
                    pwzStr = NULL;
                }


                //------- moved from ::Start to get accurate file ext
                if( hr == NOERROR && _szURL[0] != '\0' && _bCanCache)
                {
                    LPSTR pszExt = NULL;
                    TCHAR szExt[MAX_PATH + 1];
                    szExt[0] = TEXT('\0');    // Initialize

                    if(_szSuggestedFileName[0])
                    {
                        pszExt = FindFileExtension(_szSuggestedFileName);
                        lstrcpy(_szFileName, _szSuggestedFileName);
                    }
                    else
                    {
                        if(pszExt = FindFileExtension(_szURL))
                        {
                            StrNCpy(szExt, pszExt, MAX_PATH);
                            szExt[MAX_PATH] = '\0';
                            pszExt = StrChr(szExt, '?');
                            if(pszExt)
                            {
                                *pszExt = '\0';
                            }
                            pszExt = szExt;
                        }
                    }

                    // HACK... need some API to tell if ext is valid...
                    // here we assume ext with 3 chars 
                    // including the ".", it will be 4 char
                    if( pszExt && strlen(pszExt) > 5 )
                    {
                        LPSTR pszMime = DupW2A(_pwzMimeSuggested);
                        GetMimeFileExtension( pszMime, pszExt, 20);
                        delete [] pszMime;
                    }


                    if( pszExt && *pszExt == '.' )
                    {
                        // FindFileExtion will return ".htm" but wininet is
                        // expecting "htm", so remove the extra "." 
                        pszExt++; 
                    }


                    if( CreateUrlCacheEntry(_szURL, 0, pszExt, _szFileName, GZIPHACK) )
                    {
                        if( _szFileName[0] != '\0' )
                        {
                            _hFile = CreateFile(_szFileName, 
                                GENERIC_WRITE, 
                                FILE_SHARE_WRITE | FILE_SHARE_READ,
                                NULL,CREATE_ALWAYS, 
                                FILE_ATTRIBUTE_NORMAL, NULL);
                            if( _hFile == INVALID_HANDLE_VALUE )
                            {
                                _hFile = NULL;
                            }
                        }
                    }
                    

                }

                // Report the CACHE file name
                if( _szFileName[0] != '\0' )
                {
                    pwzFileName = DupA2W(_szFileName);
                }

                if( pwzFileName )
                {
                    ReportProgress(
                        BINDSTATUS_CACHEFILENAMEAVAILABLE, pwzFileName);

                    delete [] pwzFileName;
                }
                //------- moved from ::Start to get accurate file ext
            }

            // write to the file
            if( _hFile )
            {
                DWORD dwBytesWritten;
                WriteFile(_hFile, _pOutBuf, lOutUsed, &dwBytesWritten, NULL);
                if( lOutUsed != (LONG)dwBytesWritten )
                {
                    // write failed, clean up everything
                    CloseHandle(_hFile);
                    _hFile = NULL;
                    DeleteUrlCacheEntryA( _szURL );
                    _szFileName[0] = '\0';
                    _szURL[0] = '\0';
                }
                
            }

            PerfDbgLog2(tagMft, this, 
                " CMimeFt::Read-Encode/Decode %u bytes-> %u bytes", 
                lInUsed, lOutUsed);
        }   
    }
    else
        PerfDbgLog(tagMft, this, " CMimeFt::Read-in buffer empty"); 


    // copy over (only for the purpose of non-sniffing)
    if( !fSniff && (hrCode == NOERROR) && _ulOutAvailable )
    {
        if(  cb >= _ulOutAvailable )
        {
            // client has bigger buffer
            memcpy(pv, _pOutBuf, _ulOutAvailable);
            *pcbRead = _ulOutAvailable;
            _ulOutAvailable = 0;
            hr = S_OK;

            PerfDbgLog1(tagMft, this, 
                " CMimeFt::Read-enough buffer copied %u bytes", *pcbRead);

        }
        else
        {
            // client have smaller buffer
            memcpy(pv, _pOutBuf, cb);
            *pcbRead = cb;

            // move mem to front
            memcpy(_pOutBuf, _pOutBuf+cb, _ulOutAvailable-cb);

            _ulOutAvailable -= cb;
            hr = S_OK;

            PerfDbgLog1(tagMft, this, 
                " CMimeFt::Read-not enough buffer copied %u bytes", cb);
        }

        // keep the total (content-length)
        _ulContentLength  += *pcbRead;    
    }


    // If we pulled the data, we should report that hr
    if( fPullData )
        hr = hrRead;

    // if encode-decode error occurs, we report it 
    if( hrCode != NOERROR )
        hr = hrCode;

    // if all data are gone and LASTNOTIFICATION, we should return S_FALSE 
    if(_grfBSCF & BSCF_LASTDATANOTIFICATION && (_ulOutAvailable == 0) ) 
    {
        PerfDbgLog(tagMft, this, 
            " CMimeFt::Read-Last Notification, set hr --> 1" );
        hr = S_FALSE;
    }

    PerfDbgLog1(tagMft, this, "-CMimeFt::Read (hr:%1x)", hr);

    return hr;
}

 
//+---------------------------------------------------------------------------
//
//  Method:     CMimeFt::Seek
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    04-16-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CMimeFt::Seek( 
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER *plibNewPosition)
{
    PerfDbgLog(tagMft, this, "+CMimeFt::Seek");

    // Seek will be available later
    HRESULT hr = E_NOTIMPL;

    PerfDbgLog1(tagMft, this, "-CMimeFt::Seek (hr:%1x)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMimeFt::LockRequest
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    04-16-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CMimeFt::LockRequest(DWORD dwOptions)
{
    PerfDbgLog(tagMft, this, "+CMimeFt::LockRequest");
    PProtAssert(_pProt);

    HRESULT hr = _pProt->LockRequest(dwOptions);

    PerfDbgLog1(tagMft, this, "-CMimeFt::LockRequest(hr:%1x)", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMimeFt::UnlockRequest
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    04-16-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CMimeFt::UnlockRequest()
{
    PerfDbgLog(tagMft, this, "+CMimeFt::UnLockRequest");
    PProtAssert(_pProt);
    HRESULT hr = _pProt->UnlockRequest();

    PerfDbgLog1(tagMft, this, "-CMimeFt::UnLockRequest(hr:%1x)", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMimeFt::Switch
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    04-16-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CMimeFt::Switch(PROTOCOLDATA *pStateInfo)
{
    PerfDbgLog(tagMft, this, "+CMimeFt::Switch");
    PProtAssert(_pProtSink);

    HRESULT hr = _pProtSink->Switch(pStateInfo);

    PerfDbgLog1(tagMft, this, "-CMimeFt::Switch (hr:%1x)", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMimeFt::ReportProgress
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    04-16-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CMimeFt::ReportProgress( ULONG ulStatusCode, LPCWSTR szStatusText)
{
    PerfDbgLog(tagMft, this, "+CMimeFt::ReportProgress");
    PProtAssert(_pProtSink);     
    HRESULT hr = NOERROR;


    if( ulStatusCode == BINDSTATUS_MIMETYPEAVAILABLE )
    {
        delete [] _pwzMimeSuggested;
        _pwzMimeSuggested = OLESTRDuplicate(szStatusText);
        if( !_pwzMimeSuggested )
        {
            hr = E_OUTOFMEMORY;    
        }
    }
    else if( ulStatusCode == BINDSTATUS_CACHECONTROL )
    {
        if(!lstrcmpiW(szStatusText, L"no-cache"))
        {
            _bCanCache = FALSE;
        }
    }
    else if( ulStatusCode == BINDSTATUS_CONTENTDISPOSITIONATTACH )
    {
        W2A(szStatusText, _szSuggestedFileName, sizeof(_szSuggestedFileName));
        PathUndecorate(_szSuggestedFileName);
    }
    else
    {
        hr = _pProtSink->ReportProgress(ulStatusCode, szStatusText);
    }

    PerfDbgLog1(tagMft, this, "-CMimeFt::ReportProgress(hr:%1x)", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMimeFt::ReportData
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    04-16-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:      E_PENDING returned if the filter is not empty   
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CMimeFt::ReportData( DWORD grfBSCF, ULONG ulProgress, ULONG ulProgressMax)
{
    PerfDbgLog(tagMft, this, "+CMimeFt::ReportData");
    HRESULT hr = NOERROR;
    // Do a data sniffing Read to get the mime type out of the buffer
    // reason for _fSniffed, _fSniffInProgress  and _fDelayReport 
    // is that if the data sniffing SmartRead() reaches EOF, the protocol
    // will do ReportResult() which we want to delay until the Real Read
    // finishs
    if( !_fSniffed && !_fSniffInProgress && !_fReadInProgress )
    {
        _fSniffInProgress = TRUE;
        hr = SmartRead( NULL, 0, 0, TRUE);
        _fSniffInProgress = FALSE;
        if(SUCCEEDED(hr))
            _fSniffed = TRUE;
    }

    if(_fSniffed)
    {
        hr = _pProtSink->ReportData(grfBSCF, ulProgress, ulProgressMax);
    }

    PerfDbgLog1(tagMft, this, "-CMimeFt::ReportData(hr:%1x)", hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMimeFt::ReportResult
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    04-16-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CMimeFt::ReportResult(HRESULT hrResult, DWORD dwError, LPCWSTR wzResult)
{
    PerfDbgLog(tagMft, this, "+CMimeFt::ReportResult");

    // REVISIT 
    PProtAssert(_pProtSink);     
    HRESULT hr = NOERROR;

    if( _fSniffInProgress || _fReadInProgress )
    {
        // keep it and report it after read completes
        _hrResult = hrResult;
        _dwError = dwError;
        _wzResult = wzResult; // should be OLEDuplicateStr()
    
        _fDelayReport = TRUE;
    }
    else
    {
        hr = _pProtSink->ReportResult(hrResult, dwError, wzResult);
    }

    PerfDbgLog1(tagMft, this, "-CMimeFt::ReportResult(hr:%1x)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMimeFt::SwitchSink
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    11-24-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CMimeFt::SwitchSink(IOInetProtocolSink* pSink)
{
    PerfDbgLog(tagMft, this, "+CMimeFt::SwitchSink");

    // REVISIT 
    PProtAssert(_pProtSink && pSink);     
    HRESULT hr = NOERROR;

    // keep track the existing sink (support for Commit/Rollback)
    // the release of the old sink will be done at the Commit time
    _pProtSinkOld = _pProtSink;
 
    // -----------------------------------------------------------
    // BUG: remove this block once enable the Commit-Rollback func
    // release the old sink
    //
    if( _pProtSinkOld )
    {
        _pProtSinkOld->Release();
    }
    // -----------------------------------------------------------

    // Change the sink
    _pProtSink = pSink;
    _pProtSink->AddRef();

    PerfDbgLog1(tagMft, this, "-CMimeFt::SwitchSink(hr:%1x)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMimeFt::CommitSwitch
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    11-24-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:      Commit the sink switch, what we are doing here is
//              Release the old sink (old sink is coming from the
//              Start method and AddRef'ed there
//
//----------------------------------------------------------------------------
STDMETHODIMP 
CMimeFt::CommitSwitch()
{
    PerfDbgLog(tagMft, this, "+CMimeFt::CommitSwitch");

    // release the old sink
    //if( _pProtSinkOld )
    //{
    //    _pProtSinkOld->Release();
    //}

    // reset
    //_pProtSinkOld = NULL;

    PerfDbgLog(tagMft, this, "-CMimeFt::CommitSwitch");
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMimeFt::RollbackSwitch
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    11-24-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:      Error occured (most possibly the StackFilter() call failed, 
//              we have to rollback the  sink switch, what we are doing 
//              here is releasing the switched sink (AddRef'ed at SwitchSink
//              time), and set the original sink back, no ref count work on
//              the original sink 
//
//----------------------------------------------------------------------------
STDMETHODIMP
CMimeFt::RollbackSwitch()
{
    PerfDbgLog(tagMft, this, "+CMimeFt::RollbackSwitch");

    // copy the old sink back, release the new sink
    // (new sink is AddRef'ed at SwitchSink time)
    //if( _pProtSink )
    //{
    //    _pProtSink->Release();
    //} 
    //_pProtSink = _pProtSinkOld;

    // reset
    //_pProtSinkOld = NULL;
    PerfDbgLog(tagMft, this, "-CMimeFt::RollbackSwitch");

    return NOERROR;
}





//+---------------------------------------------------------------------------
//
//  Method:     CMimeFt::Create
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    04-16-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CMimeFt::Create(CMimeFt** ppv)
{
    PerfDbgLog(tagMft, NULL, "+CMimeFt::Create");
    HRESULT hr = NOERROR;

    // pProt can not be NULL
    PProtAssert(ppv);     
    *ppv = NULL;

    *ppv = new CMimeFt;
    if( *ppv == NULL )
        hr = E_OUTOFMEMORY;
    else
        hr = (*ppv)->CreateBuffer();

    PerfDbgLog1(tagMft, NULL, "-CMimeFt::Create(hr:%1x)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMimeFt::CMimeFt
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    04-16-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CMimeFt::CMimeFt()
    : _CRefs()
{
    PerfDbgLog(tagMft, this, "+CMimeFt::CMimeFt");

    _pProtSink = NULL;
    _pProt = NULL;
    _pProtSinkOld = NULL;
    _pDF = NULL;
    _ulCurSizeFmtIn = 0;
    _ulCurSizeFmtOut = 0;
    _ulTotalSizeFmtIn = 0;
    _ulTotalSizeFmtOut = 0;
    _ulOutAvailable = 0;
    _ulInBufferLeft = 0;
    _pInBuf = NULL;
    _pOutBuf = NULL;

    _grfBSCF = 0x00;
    _bMimeReported = FALSE;
    _bMimeVerified = FALSE;
    _bCanCache = TRUE;
    _szFileName[0] = '\0';
    _szSuggestedFileName[0] = '\0';
    _szURL[0] = '\0';
    _hFile = NULL;
    _pwzMimeSuggested = NULL;

    _fDelayReport = FALSE;
    _fSniffed = FALSE;
    _fSniffInProgress = FALSE;
    _hrResult = NOERROR;
    _dwError = 0;
    _wzResult = NULL;
    _fReadInProgress = FALSE;

    DllAddRef();

    PerfDbgLog(tagMft, this, "-CMimeFt::CMimeFt");
}


//+---------------------------------------------------------------------------
//
//  Method:     CMimeFt::CreateBuffer
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    04-30-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CMimeFt::CreateBuffer()
{
    PerfDbgLog(tagMft, this, "+CMimeFt::CreateBuffer");
    HRESULT hr = NOERROR;
    _pInBuf  = new BYTE[FT_IBUF_SIZE]; 	        
    _pOutBuf = new BYTE[FT_OBUF_SIZE];

    PProtAssert(_pInBuf && _pOutBuf);     
    if( !_pInBuf || !_pOutBuf )
        hr = E_OUTOFMEMORY;

    PerfDbgLog1(tagMft, this, "-CMimeFt::CreateBuffer(hr:%1x)", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMimeFt::~CMimeFt
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    04-16-97   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CMimeFt::~CMimeFt()
{
    PerfDbgLog(tagMft, this, "+CMimeFt::~CMimeFt");

    if( _pInBuf )
        delete [] _pInBuf;

    if( _pOutBuf )
        delete [] _pOutBuf;

    delete [] _pwzMimeSuggested;

    if( _pProt )
        _pProt->Release(); 

    if( _pDF)
        _pDF->Release();
    
    if( _hFile )
        CloseHandle(_hFile);
    

    DllRelease();

    PerfDbgLog(tagMft, this, "-CMimeFt::~CMimeFt");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\eapp\multicst.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       resprot.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <eapp.h>
#include <tchar.h>

#define MAX_ID 10000

#define WITH_TAGS

//+---------------------------------------------------------------------------
//
//  Method:     CMulticastProtocol::Start
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pTrans] --
//              [pOIBindInfo] --
//              [grfSTI] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMulticastProtocol::Start(LPCWSTR pwzUrl, IOInetProtocolSink *pTrans, IOInetBindInfo *pOIBindInfo,
                          DWORD grfSTI, DWORD dwReserved)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CMulticastProtocol::Start\n", this));
    HRESULT hr = NOERROR;
    WCHAR    wzURL[MAX_URL_SIZE];

    EProtAssert((!_pProtSink && pOIBindInfo && pTrans));
    EProtAssert((_pwzUrl == NULL));

    hr = CBaseProtocol::Start(pwzUrl,pTrans, pOIBindInfo, grfSTI, dwReserved);

    if ( (grfSTI & PI_PARSE_URL) )
    {
        hr =  ParseAndBind(FALSE);
    }
    else if (hr == NOERROR)
    {
        // asked to go async as soon as possible
        // use the switch mechanism which will \
        // call back later on ::Continue
        if (grfSTI & PI_FORCE_ASYNC)
        {
            hr = E_PENDING;
            PROTOCOLDATA protdata;
            protdata.grfFlags = PI_FORCE_ASYNC;
            protdata.dwState = RES_STATE_BIND;
            protdata.pData = 0;
            protdata.cbData = 0;

            _pProtSink->Switch(&protdata);
        }
        else
        {
            hr =  ParseAndBind(TRUE);
        }
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CMulticastProtocol::Start (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMulticastProtocol::Continue
//
//  Synopsis:
//
//  Arguments:  [pStateInfoIn] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMulticastProtocol::Continue(PROTOCOLDATA *pStateInfoIn)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CMulticastProtocol::Continue\n", this));
    HRESULT hr = E_FAIL;

    EProtAssert((!pStateInfoIn->pData && pStateInfoIn->cbData && (pStateInfoIn->dwState == RES_STATE_BIND)));

    if (pStateInfoIn->dwState == RES_STATE_BIND)
    {
        hr =  ParseAndBind();
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CMulticastProtocol::Continue (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMulticastProtocol::Read
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//              [ULONG] --
//              [pcbRead] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMulticastProtocol::Read(void *pv,ULONG cb,ULONG *pcbRead)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CMulticastProtocol::Read (cb:%ld)\n", this,cb));
    HRESULT hr = NOERROR;

    if (_cbBuffer > _cbPos)
    {
        ULONG cbCopy = (cb < (_cbBuffer - _cbPos)) ? cb :  _cbBuffer - _cbPos;

        memcpy((LPVOID)pv, ((LPBYTE)_pBuffer) + _cbPos, cbCopy);

        _cbPos += cbCopy;

        *pcbRead = cbCopy;

        hr =  (_cbPos < _cbBuffer) ? S_OK : S_FALSE;
    }
    else
    {
        hr = S_FALSE;
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CMulticastProtocol::Read (pcbRead:%ld, hr:%lx)\n",this,*pcbRead, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMulticastProtocol::Seek
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [ULARGE_INTEGER] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:      WORK: not done
//
//----------------------------------------------------------------------------
STDMETHODIMP CMulticastProtocol::Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CMulticastProtocol::Seek\n", this));
    HRESULT hr = NOERROR;

    if (dwOrigin == STREAM_SEEK_SET)
    {
        if (dlibMove.LowPart >= 0)
        {
            _cbPos = dlibMove.LowPart;

            if (plibNewPosition)
            {
                plibNewPosition->HighPart = 0;
                plibNewPosition->LowPart = _cbPos;
            }
        }
        else
        {
            hr = STG_E_INVALIDPOINTER;
        }
    }
    else
    {
        hr = E_NOTIMPL;
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CMulticastProtocol::Seek (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMulticastProtocol::LockRequest
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMulticastProtocol::LockRequest(DWORD dwOptions)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CMulticastProtocol::LockRequest\n", this));

    HRESULT hr = NOERROR;

    if (OpenTempFile())
    {
        DWORD dwWrite;
        if (!WriteFile(_hFile, _pBuffer, _cbBuffer, &dwWrite,NULL))
        {
            hr = E_FAIL;
        }
        CloseTempFile();
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CMulticastProtocol::LockRequest (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMulticastProtocol::UnlockRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMulticastProtocol::UnlockRequest()
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CMulticastProtocol::UnlockRequest\n", this));
    HRESULT hr = NOERROR;

    //CloseTempFile();

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CMulticastProtocol::UnlockRequest (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMulticastProtocol::CMulticastProtocol
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CMulticastProtocol::CMulticastProtocol(REFCLSID rclsid, IUnknown *pUnkOuter, IUnknown **ppUnkInner) : CBaseProtocol(rclsid, pUnkOuter, ppUnkInner)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CMulticastProtocol::CMulticastProtocol \n", this));

    _hInst = NULL;
    _cbBuffer = 0;
    _pBuffer = 0;
    _hgbl = 0;
    _cbPos = 0;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CMulticastProtocol::CMulticastProtocol \n", this));
}

//+---------------------------------------------------------------------------
//
//  Method:     CMulticastProtocol::~CMulticastProtocol
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CMulticastProtocol::~CMulticastProtocol()
{

    if (_hgbl)
    {
        UnlockResource(_hgbl);
    }
    if (_hInst)
    {
        FreeLibrary(_hInst);
    }

    EProtDebugOut((DEB_PLUGPROT, "%p _IN/OUT CMulticastProtocol::~CMulticastProtocol \n", this));
}

//+---------------------------------------------------------------------------
//
//  Method:     CMulticastProtocol::GetResource
//
//  Synopsis:
//
//  Arguments:  [pwzFileName] --
//              [pwzResName] --
//              [pwzResType] --
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMulticastProtocol::GetResource(LPCWSTR pwzFileName, LPCWSTR pwzResName, LPCWSTR pwzResType, LPCWSTR pwzMime)
{
    EProtDebugOut((DEB_PLUGPROT, "CMulticastProtocol::GetResource\n)"));
    HRESULT     hr = NOERROR;
    DWORD       dwError = 0;
    HRSRC       hrsrc;

    LPSTR pszFileName =  DupW2A(pwzFileName );
    LPSTR pszResName  =  DupW2A(pwzResName  );
    LPSTR pszResType  =  DupW2A(pwzResType  );


    if (!pszFileName || !pszResName || !pszResType)
    {
        hr = E_OUTOFMEMORY;
    }
    else do
    {
        _pProtSink->ReportProgress(BINDSTATUS_SENDINGREQUEST, pwzResName);

        _hInst = LoadLibraryEx(pszFileName, NULL, DONT_RESOLVE_DLL_REFERENCES);
        if (!_hInst)
        {
            hr = INET_E_RESOURCE_NOT_FOUND;
            dwError = GetLastError();
            break;
        }

        if (!wcscmp(pwzResName, L"?"))
        {
            for (int i = 0 ; i < MAX_ID; i++)
            {
                hrsrc = FindResource(_hInst, (LPSTR)MAKEINTRESOURCE(i), pszResType);

                if (hrsrc)
                {
                    EProtDebugOut((DEB_PLUGPROT, "CMulticastProtocol::GetResource (szResName:#%ld, wzRestype:%s\n)",i,pszResType));
                    i = MAX_ID;
                }
            }
        }
        else
        {
            hrsrc = FindResource(_hInst, pszResName, pszResType);
        }

        if (!hrsrc)
        {
            hr = INET_E_OBJECT_NOT_FOUND;
            dwError = GetLastError();
            break;
        }

        _hgbl = LoadResource(_hInst, hrsrc);
        if (!_hgbl)
        {
            hr = INET_E_DATA_NOT_AVAILABLE;
            dwError = GetLastError();
            break;
        }

        _pBuffer = LockResource(_hgbl);
        if (!_pBuffer)
        {
            hr = INET_E_DATA_NOT_AVAILABLE;
            dwError = GetLastError();
            break;
        }

        _cbBuffer = SizeofResource(_hInst, hrsrc);


        if (_grfBindF & INTERNET_FLAG_NEED_FILE)
        {
            LockRequest(0);
        }

#ifdef UNUSED
        if (OpenTempFile())
        {
            DWORD dwWrite;
            if (!WriteFile(_hFile, _pBuffer, _cbBuffer, &dwWrite,NULL))
            {
                dwError = GetLastError();
                break;
            }
            CloseTempFile();
        }
#endif //UNUSED

        hr = NOERROR;
        break;

    }  while (1);

    if (dwError || (hr != NOERROR))
    {
        _pProtSink->ReportResult(hr, dwError, 0);
    }
    else
    {
        if (pwzMime)
        {
            _pProtSink->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, pwzMime);
        }

        _bscf |= BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE;
        _pProtSink->ReportData(_bscf, _cbBuffer, _cbBuffer);
    }

    if (pszFileName)
    {
        delete pszFileName;
    }

    if (pszResName)
    {
        delete pszResName;
    }

    if (pszResType)
    {
        delete pszResType;
    }


    EProtDebugOut((DEB_PLUGPROT, "%p OUT CMulticastProtocol::GetResource (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMulticastProtocol::ParseAndBind
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMulticastProtocol::ParseAndBind(BOOL fBind)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CMulticastProtocol::ParseAndBind\n", this));

    HRESULT hr = MK_E_SYNTAX;

    WCHAR wzlURL[MAX_URL_SIZE];

    wcscpy(wzlURL, _wzFullURL);


    do
    {
        // check if protocol part
        LPWSTR pwz = wcschr(wzlURL, ':');

        pwz++;

        if (wcsnicmp(pwz, L"//", 2) && wcsnicmp(pwz, L"\\\\", 2))
        {
            break;
        }

        // find the file name and path
        LPWSTR pwzFileName = pwz + 2;

        EProtAssert((pwzFileName));

        // the file is
        LPWSTR pwz1 = wcsrchr(wzlURL, '/');

        if (!pwz1)
        {
            break;
        }

        *pwz1 = '\0';
        pwz1++;

        if (!*pwz1)
        {
            break;
        }
#ifdef WITH_TAGS
        LPWSTR pwzResDelimiter = wcschr(pwz1, '?');

        if (!pwzResDelimiter)
        {
            break;
        }

        LPWSTR pwzResTag = wcsstr(pwz1, L"name:");

        if (!pwzResTag)
        {
            break;
        }

        LPWSTR pwzTypeTag = wcsstr(pwz1, L"type:");

        if (!pwzTypeTag)
        {
            break;
        }

        LPWSTR pwzMimeTag = wcsstr(pwz1, L"mime:");

        // get the resource name
        LPWSTR pwzResName = wcschr(pwzResTag, ':');
        pwzResName++;

        //find the end of the resource name
        LPWSTR pwzResType = wcschr(pwzTypeTag, ':');
        pwzResType++;

        LPWSTR pwzMime = 0;
        if (pwzMimeTag)
        {
            pwzMime = wcschr(pwzMimeTag, ':');
            pwzMime++;
            *pwzMimeTag = 0;
        }

        *pwzResTag = 0;
        *pwzTypeTag = 0;


#else
        // find the delimiter for the private part
        LPWSTR pwzResName = wcschr(pwz1, '?');

        if (!pwzResName)
        {
            break;
        }

        // get the resource name
        pwzResName++;

        //find the end of the resource name
        LPWSTR pwzResType = wcschr(pwzResName, ' ');

        if (!pwzResType)
        {
            break;
        }

        *pwzResType = '\0';
        pwzResType++;
        EProtDebugOut((DEB_PLUGPROT, "CMulticastProtocol::GetResource (wzResName:%ws,pwzResType:%ws\n)",pwzResName,pwzResType));


        /*
        {
            pwzResType =  (LPWSTR)MAKEINTRESOURCE(RT_ICON);
            EProtDebugOut((DEB_PLUGPROT, "CMulticastProtocol::GetResource (wzResName:%ws,pwzResType:RT_ICON\n)",pwzResName));
        }
        */
#endif //WITH_TAGS


        EProtAssert(((WCHAR *)pwzFileName && (WCHAR *)pwzResName));
        if (fBind && pwzFileName && pwzResName && pwzResType)
        {
            hr = GetResource(pwzFileName, pwzResName, pwzResType, pwzMime);
        }

        break;

    }  while (1);


    if (hr == MK_E_SYNTAX)
    {
        _pProtSink->ReportResult(hr, 0, 0);
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CMulticastProtocol::ParseAndBind (hr:%lx)\n", this,hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\eapp\notfsink.cxx ===
#include <eapp.h>

extern "C" const GUID IID_IDebugRegister;
extern "C" const GUID IID_IDebugOut;

#if DBG==1
HRESULT DumpIID(REFIID riid)
{

    HRESULT hr;
    LPOLESTR pszStr = NULL;
    hr = StringFromCLSID(riid, &pszStr);
    EProtDebugOut((DEB_NOTFSINK, "API >>> DumpIID (riid:%ws) \n", pszStr));

    if (pszStr)
    {
        delete pszStr;
    }
    return hr;
}
#else
#define DumpIID(x)
#endif


HRESULT CreateNotificationTest(DWORD dwId, REFCLSID rclsid, IUnknown *pUnkOuter, REFIID riid, IUnknown **ppUnk)
{
    EProtDebugOut((DEB_NOTFSINK, "API _IN CreateKnownProtocolInstance\n"));
    HRESULT hr = NOERROR;

    EProtAssert(( (dwId == 0) && ppUnk));

    do
    {
        if (!ppUnk)
        {
            // Note: aggregation only works if asked for IUnknown
            EProtAssert((FALSE && "Dude, need out parameter"));
            hr = E_INVALIDARG;
            break;
        }

        if (pUnkOuter)
        {
            hr = CLASS_E_NOAGGREGATION;
            break;
        }

        CNotfSink *pNotfSink = new CNotfSink(L"Notificaion Sink");

        if (pNotfSink)
        {
            hr = pNotfSink->QueryInterface(riid, (void **)ppUnk);
            // remove extra refcount
            pNotfSink->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        break;
    } while (TRUE);



    EProtDebugOut((DEB_NOTFSINK, "API OUT CreateKnownProtocolInstance(hr:%lx)\n", hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CNotfSink::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    11-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CNotfSink::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    EProtDebugOut((DEB_NOTFSINK,  "%p _IN CNotfSink::QueryInterface\n", this));
    EProtAssert(( IsApartmentThread() ));

    *ppvObj = NULL;
    if ((riid == IID_IUnknown) || (riid == IID_INotificationSink) )
    {
        *ppvObj = this;
        AddRef();
    }
    else if ((riid == IID_IDebugRegister) )
    {
        *ppvObj = (IDebugRegister *) this;
        AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    EProtDebugOut((DEB_NOTFSINK,  "%p OUT CNotfSink::QueryInterface (hr:%lx\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CNotfSink::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    11-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CNotfSink::AddRef(void)
{
    EProtDebugOut((DEB_NOTFSINK,  "%p _IN CNotfSink::AddRef\n", this));
    EProtAssert(( IsApartmentThread() ));

    LONG lRet = ++_CRefs;

    EProtDebugOut((DEB_NOTFSINK,  "%p OUT CNotfSink::AddRef (cRefs:%ld)\n", this,lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CNotfSink::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    11-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CNotfSink::Release(void)
{
    EProtDebugOut((DEB_NOTFSINK,  "%p _IN CNotfSink::Release\n", this));
    EProtAssert(( IsApartmentThread() ));

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        delete this;
    }

    EProtDebugOut((DEB_NOTFSINK,  "%p OUT CNotfSink::Release (cRefs:%ld)\n",this,lRet));
    return lRet;
}


//+---------------------------------------------------------------------------
//
//  Method:     CNotfSink::OnNotification
//
//  Synopsis:
//
//  Arguments:  [itemtype] --
//              [pWChkItem] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    12-02-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CNotfSink::OnNotification(
                // the notification object itself
                LPNOTIFICATION          pNotification,
                // the cookie of the object the notification is targeted too
                //PNOTIFICATIONCOOKIE     pRunningNotfCookie,
                // flags how it was delivered and how it should
                // be processed
                //NOTIFICATIONFLAGS       grfNotification,
                // the report sink if - can be NULL
                LPNOTIFICATIONREPORT    pNotfctnReport,
                DWORD                   dwReserved
                )
{
    EProtDebugOut((DEB_NOTFSINK, "%p _IN CNotfSink::OnNotification\n", this));
    EProtAssert(( IsApartmentThread() ));
    EProtAssert((pNotification));
    HRESULT hr = NOERROR;
    LPOLESTR pszStr = NULL;
    NOTIFICATIONTYPE notfType;
    NOTIFICATIONCOOKIE notfCookie;

    PNOTIFICATIONCOOKIE     pRunningNotfCookie = 0;
    // flags how it was delivered and how it should
    // be processed
    NOTIFICATIONFLAGS       grfNotification = (NOTIFICATIONFLAGS)0;

    //hr = pNotification->GetNotificationType(&notfType);
    hr = pNotification->GetNotificationInfo(&notfType, &notfCookie, 0, 0, 0);

    if (hr == NOERROR)
    {
        hr = StringFromCLSID(notfType, &pszStr);
    }

    EProtDebugOut((DEB_NOTFSINK, "%p CNotfSink:%ws received pNotification:%p\n         with id:%ws\n", this, _pwzName, pNotification,pszStr));
    //EProtDebugOut((DEB_NOTFSINK, "%p CNotfSink:%ws received pNotification:%p \n", this, _pwzName, pNotification));
    MessageBeep(1000);

    if (pszStr)
    {
        delete pszStr;
    }

    /*
    if (pNotification->pCustomData != 0)
    {
        IDebugOut *pDbgOut = 0;
        char szOutBuffer[256];

        pDbgOut = (IDebugOut *) pNotification->pCustomData;

        sprintf(szOutBuffer, "%p CNotfSink:%ws received pNotification:%p with id:%ws\n", this, _pwzName, pNotification,  pNotification->pNotificationid);

        pDbgOut->SendEntry(GetCurrentThreadId(), 0, szOutBuffer, 0);
    }
    */

    // don't return an error!
    hr = NOERROR;

    EProtDebugOut((DEB_NOTFSINK,  "%p OUT CNotfSink::OnNotification (hr:%lx)\n",this, hr));
    return hr;
}

STDMETHODIMP CNotfSink::GetFacilities (LPCWSTR *ppwzNames, DWORD *pcNames, DWORD dwReserved)
{
    EProtDebugOut((DEB_NOTFSINK, "%p _IN CNotfSink::GetFacilities\n", this));
    EProtAssert(( IsApartmentThread() ));
    EProtAssert(( ppwzNames && pcNames ));

    HRESULT hr = NOERROR;

    ppwzNames = v_gDbgFacilitieNames;
    LONG x = sizeof(*v_gDbgFacilitieNames);
    LONG y = sizeof(LPCWSTR);

    *pcNames = (sizeof(*v_gDbgFacilitieNames)/sizeof(LPCWSTR));

    EProtDebugOut((DEB_NOTFSINK,  "%p OUT CNotfSink::GetFacilities (hr:%lx)\n",this, hr));
    return hr;
}

STDMETHODIMP CNotfSink::Register ( LPCWSTR pwzName, IDebugOut *pDbgOut, DWORD dwFlags, DWORD dwReserved)
{
    EProtDebugOut((DEB_NOTFSINK, "%p _IN CNotfSink::Register\n", this));
    EProtAssert(( IsApartmentThread() ));
    HRESULT hr = NOERROR;

    hr = RegisterDebugOut(pwzName, dwFlags, pDbgOut, dwReserved);

    EProtDebugOut((DEB_NOTFSINK,  "%p OUT CNotfSink::Register (hr:%lx)\n",this, hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\eapp\nspohsrv.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       resprot.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <eapp.h>


//+---------------------------------------------------------------------------
//
//  Method:     COhServNameSp::Start
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pTrans] --
//              [pOIBindInfo] --
//              [grfSTI] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COhServNameSp::Start(LPCWSTR pwzUrl, IOInetProtocolSink *pProt, IOInetBindInfo *pOIBindInfo,
                          DWORD grfSTI, DWORD dwReserved)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN COhServNameSp::Start\n", this));
    HRESULT hr = NOERROR;
    WCHAR    wzURL[MAX_URL_SIZE];

    EProtAssert((!_pProtSink && pOIBindInfo && pProt));
    EProtAssert((_pwzUrl == NULL));

    hr = CBaseProtocol::Start(pwzUrl,pProt, pOIBindInfo, grfSTI, dwReserved);

    if ( (grfSTI & PI_PARSE_URL) )
    {
        hr =  ParseAndStart(FALSE);
    }
    else if (hr == NOERROR)
    {
        // asked to go async as soon as possible
        // use the switch mechanism which will \
        // call back later on ::Continue
        if (grfSTI & PI_FORCE_ASYNC)
        {
            hr = E_PENDING;
            PROTOCOLDATA protdata;
            protdata.grfFlags = PI_FORCE_ASYNC;
            protdata.dwState = RES_STATE_BIND;
            protdata.pData = 0;
            protdata.cbData = 0;

            _pProtSink->Switch(&protdata);
        }
        else
        {
            hr =  ParseAndStart(TRUE);
        }
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT COhServNameSp::Start (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     COhServNameSp::Continue
//
//  Synopsis:
//
//  Arguments:  [pStateInfoIn] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COhServNameSp::Continue(PROTOCOLDATA *pStateInfoIn)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN COhServNameSp::Continue\n", this));
    HRESULT hr = E_FAIL;

    EProtAssert((!pStateInfoIn->pData && pStateInfoIn->cbData && (pStateInfoIn->dwState == RES_STATE_BIND)));

    if (pStateInfoIn->dwState == RES_STATE_BIND)
    {
        hr =  ParseAndStart();
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT COhServNameSp::Continue (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     COhServNameSp::Read
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//              [ULONG] --
//              [pcbRead] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COhServNameSp::Read(void *pv,ULONG cb,ULONG *pcbRead)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN COhServNameSp::Read (cb:%ld)\n", this,cb));
    HRESULT hr = NOERROR;

    if (_pProt)
    {
        hr = _pProt->Read(pv, cb, pcbRead);
    }
    else
    {
        hr = S_FALSE;
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT COhServNameSp::Read (pcbRead:%ld, hr:%lx)\n",this,*pcbRead, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COhServNameSp::Seek
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [ULARGE_INTEGER] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:      WORK: not done
//
//----------------------------------------------------------------------------
STDMETHODIMP COhServNameSp::Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN COhServNameSp::Seek\n", this));
    HRESULT hr = NOERROR;

    if (_pProt)
    {
        hr = _pProt->Seek(dlibMove, dwOrigin, plibNewPosition);
    }
    else
    {
        hr = S_FALSE;
    }


    EProtDebugOut((DEB_PLUGPROT, "%p OUT COhServNameSp::Seek (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COhServNameSp::LockRequest
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COhServNameSp::LockRequest(DWORD dwOptions)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN COhServNameSp::LockRequest\n", this));

    HRESULT hr = NOERROR;

    if (_pProt)
    {
        hr = _pProt->LockRequest(dwOptions);
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT COhServNameSp::LockRequest (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COhServNameSp::UnlockRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COhServNameSp::UnlockRequest()
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN COhServNameSp::UnlockRequest\n", this));
    HRESULT hr = NOERROR;

    if (_pProt)
    {
        hr = _pProt->UnlockRequest();
    }


    EProtDebugOut((DEB_PLUGPROT, "%p OUT COhServNameSp::UnlockRequest (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     COhServNameSp::COhServNameSp
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
COhServNameSp::COhServNameSp(REFCLSID rclsid, IUnknown *pUnkOuter, IUnknown **ppUnkInner) : CBaseProtocol(rclsid, pUnkOuter, ppUnkInner)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN/OUT     COhServNameSp::COhServNameSp \n", this));
}

//+---------------------------------------------------------------------------
//
//  Method:     COhServNameSp::~COhServNameSp
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
COhServNameSp::~COhServNameSp()
{

    EProtDebugOut((DEB_PLUGPROT, "%p _IN/OUT COhServNameSp::~COhServNameSp \n", this));
}


//+---------------------------------------------------------------------------
//
//  Method:     COhServNameSp::ParseAndStart
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COhServNameSp::ParseAndStart(BOOL fBind)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN COhServNameSp::ParseAndStart\n", this));

    HRESULT hr = INET_E_USE_DEFAULT_PROTOCOLHANDLER;

    WCHAR wzUrl[MAX_URL_SIZE];

    LPWSTR pwzOhservHttp = L"http://ohserv";
    LPWSTR pwzOhservFile = L"file://\\\\ohserv\\http";
    LPWSTR pwzOhservRoot = L"\\\\ohserv\\http";
    ULONG cServerLen = wcslen(pwzOhservHttp);

    do
    {
        if ( wcsnicmp(_wzFullURL, pwzOhservHttp, cServerLen) )
        {
            // not http://ohserv - return default error
            break;
        }

        // find the file name and path
        LPWSTR pwzRest = _wzFullURL + cServerLen;

        EProtAssert((pwzRest));

        wcscpy(wzUrl, pwzOhservRoot);
        wcscat(wzUrl, pwzRest);

        DWORD dwAttr = 0;
        {
            char szUrl[MAX_URL_SIZE];
            W2A(wzUrl, szUrl, MAX_URL_SIZE);

            dwAttr = GetFileAttributes(szUrl);
        }

        if (   (dwAttr == 0xffffffff)
            || (dwAttr & FILE_ATTRIBUTE_DIRECTORY)
           )
        {
            break;
        }


        wcscpy(wzUrl, pwzOhservFile);
        wcscat(wzUrl, pwzRest);

        // create an APP file
        {
            IClassFactory *pCF = 0;
            hr = CoCreateInstance(CLSID_FileProtocol, NULL, CLSCTX_INPROC_SERVER,IID_IClassFactory, (void**)&pCF);
            if (hr == NOERROR)
            {
                IUnknown *pUnk = 0;
                //IOInetProtocol *pProt = 0;


                EProtAssert((pCF));

                hr = pCF->CreateInstance((IOInetProtocol *)this, IID_IUnknown, (void **)&_pUnkInner);

                if (hr == NOERROR)
                {
                    EProtAssert((_pUnkInner));
                    hr = (_pUnkInner)->QueryInterface(IID_IOInetProtocol, (void **) &_pProt);
                }

                // create an instance without aggregation
                if (hr == CLASS_E_NOAGGREGATION)
                {
                    hr = pCF->CreateInstance(NULL, IID_IOInetProtocol, (void **) &_pProt);
                }

                pCF->Release();

                {
                    hr = _pProt->Start(wzUrl, _pProtSink, _pOIBindInfo, _grfSTI, 0);
                }

                if (hr != NOERROR)
                {
                    hr = INET_E_USE_DEFAULT_PROTOCOLHANDLER;
                }

           }
        }

        break;

    }  while (1);


    if (hr == MK_E_SYNTAX)
    {
        _pProtSink->ReportResult(hr, 0, 0);
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT COhServNameSp::ParseAndStart (hr:%lx)\n", this,hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\eapp\precomp1.inc ===
#//+---------------------------------------------------------------
#//
#//  File:      precomp1.inc
#//
#//  Contents:  directives for global precompiled include file when the
#//             sources file is two directories below com (or wherever
#//             this file is located).  We could easily have precomp3 and
#//             precomp4 for other areas.The urlint.* files should not
#//             otherwise be mentioned in the sources files.
#//
#//
#//----------------------------------------------------------------

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\..\inc\eapp.h
PRECOMPILED_TARGET=$(GPCH_BUILD)\$(_OBJ_DIR)\*\eapp.pch
PRECOMPILED_OPTION=/Yueapp.h /Fp$(GPCH_BUILD)\$(_OBJ_DIR)\*\eapp.pch
PRECOMPILED_OBJ=$(GPCH_BUILD)\$(_OBJ_DIR)\*\eapp.obj


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\eapp\urlcf.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       urlcf.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <eapp.h>

#ifdef EAPP_TEST
const GUID CLSID_ResProtocol =     {0x79eaca00, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}};
const GUID CLSID_OhServNameSp =    {0x79eaca01, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}};
const GUID CLSID_MimeHandlerTest1= {0x79eaca02, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}};

const GUID CLSID_NotificaitonTest1  = {0xc733e501, 0x576e, 0x11d0, {0xb2, 0x8c, 0x00, 0xc0, 0x4f, 0xd7, 0xcd, 0x22}};
const GUID CLSID_NotificaitonTest2  = {0xc733e502, 0x576e, 0x11d0, {0xb2, 0x8c, 0x00, 0xc0, 0x4f, 0xd7, 0xcd, 0x22}};
const GUID CLSID_NotificaitonTest3  = {0xc733e503, 0x576e, 0x11d0, {0xb2, 0x8c, 0x00, 0xc0, 0x4f, 0xd7, 0xcd, 0x22}};
const GUID CLSID_NotificaitonTest4  = {0xc733e504, 0x576e, 0x11d0, {0xb2, 0x8c, 0x00, 0xc0, 0x4f, 0xd7, 0xcd, 0x22}};
#endif // EAPP_TEST

const GUID CLSID_StdEncodingFilterFac= {0x54c37cd0, 0xd944, 0x11d0, {0xa9, 0xf4, 0x00, 0x60, 0x97, 0x94, 0x23, 0x11}};
const GUID CLSID_CdlProtocol  =    {0x3dd53d40, 0x7b8b, 0x11d0, {0xb0, 0x13, 0x00, 0xaa, 0x00, 0x59, 0xce, 0x02}};
const GUID CLSID_DeCompMimeFilter   = {0x8f6b0360, 0xb80d, 0x11d0, {0xa9, 0xb3, 0x00, 0x60, 0x97, 0x94, 0x23, 0x11}};
const GUID CLSID_ClassInstallFilter = {0x32b533bb, 0xedae, 0x11d0, {0xbd, 0x5a, 0x0, 0xaa, 0x0, 0xb9, 0x2a, 0xf1}};

#ifdef EAPP_TEST
HRESULT CreateNotificationTest(DWORD dwId, REFCLSID rclsid, IUnknown *pUnkOuter, REFIID riid, IUnknown **ppUnk);
#endif

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::Create
//
//  Synopsis:
//
//  Arguments:  [clsid] --
//              [ppCF] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CUrlClsFact::Create(REFCLSID clsid, CUrlClsFact **ppCF)
{
    EProtDebugOut((DEB_PLUGPROT, "NULL _IN CUrlClsFact::Create\n"));
    HRESULT hr = NOERROR;
    CUrlClsFact * pCF =  NULL;

#ifdef EAPP_TEST
    if (   (clsid == CLSID_ResProtocol)
        || (clsid == CLSID_OhServNameSp)
       )
    {
        pCF = (CUrlClsFact *) new CUrlClsFact(clsid);
    }
    else if
        (
            (clsid == CLSID_NotificaitonTest1)
         || (clsid == CLSID_NotificaitonTest2)
         || (clsid == CLSID_NotificaitonTest3)
         || (clsid == CLSID_NotificaitonTest4)
         || (clsid == CLSID_DeCompMimeFilter )
         || (clsid == CLSID_MimeHandlerTest1)
         )
    {
        pCF = (CUrlClsFact *) new CUrlClsFact(clsid);
    }
#endif

    if(   (clsid == CLSID_DeCompMimeFilter )
       || (clsid == CLSID_StdEncodingFilterFac)
       || (clsid == CLSID_ClassInstallFilter)
       || (clsid == CLSID_CdlProtocol)
       )
    {
        pCF = (CUrlClsFact *) new CUrlClsFact(clsid);
    }


    if (pCF == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        *ppCF = pCF;
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CUrlClsFact::Create (hr:%lx\n", pCF,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::CUrlClsFact
//
//  Synopsis:   constructor
//
//  Arguments:  [clsid] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:      we need to keep a refcount on the dll if for each object given to
//              outside, including ClassFactories.
//              The corresponding DllRelease is in the destructor
//
//----------------------------------------------------------------------------
CUrlClsFact::CUrlClsFact(REFCLSID clsid) : _CRefs(), _CLocks(0)
{
    _ClsID =  clsid;
    DllAddRef();
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::~CUrlClsFact
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CUrlClsFact::~CUrlClsFact()
{
    DllRelease();
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::CreateInstance
//
//  Synopsis:   creates an instance of an Explode Object
//
//  Arguments:  [pUnkOuter] -- controlling unknown (must be NULL)
//              [riid] --      id of desired interface
//              [ppv] --       pointer to receive the interface
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:      S_OK - success
//              CLASS_E_NOAGGREATION - the caller tried to aggregate
//              CLASS_E_CLASSNOTAVAILABLE - couldn't initialize the class
//              E_OUTOFMEMORY - not enough memory to instantiate class
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlClsFact::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppv)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CUrlClsFact::CreateInstance\n", this));
    HRESULT hr = NOERROR;
    // Class factory init time, the pointer to the creation function of
    // the object is given.  Use that to create the object

    //DumpIID(riid);
    //DumpIID(_rClsID);

    if (riid == IID_IClassFactory)
    {
        *ppv = (IClassFactory *)this;
        AddRef();
    }

    else if (   (_ClsID == CLSID_CdlProtocol)
        )
    {
        hr = CreateAPP(_ClsID, pUnkOuter, riid, (IUnknown **)ppv);
    }

#ifdef EAPP_TEST
    else if (   (_ClsID == CLSID_ResProtocol)
             || (_ClsID == CLSID_OhServNameSp)
             || (_ClsID == CLSID_MimeHandlerTest1)
            )

    {
        hr = CreateAPP(_ClsID, pUnkOuter, riid, (IUnknown **)ppv);
    }
    else if(   (_ClsID == CLSID_NotificaitonTest1)
            || (_ClsID == CLSID_NotificaitonTest2)
            || (_ClsID == CLSID_NotificaitonTest3)
            || (_ClsID == CLSID_NotificaitonTest4))
    {

     //   hr = CreateNotificationTest(
     //       0, _ClsID, pUnkOuter, riid, (IUnknown **)ppv);

        hr = E_FAIL;
    }
#endif
    else if (_ClsID == CLSID_ClassInstallFilter)
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
        if (pUnkOuter)
            hr = CLASS_E_NOAGGREGATION;
        else
        {
            CClassInstallFilter *pCIF = NULL;
            pCIF = new CClassInstallFilter();
            *ppv = (LPVOID)(IOInetProtocol *)pCIF;
            if (!*ppv)
                hr = E_OUTOFMEMORY;
            else
                hr = S_OK;
        }
    }
    else if( _ClsID == CLSID_DeCompMimeFilter)
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
        if( pUnkOuter)
            hr = CLASS_E_NOAGGREGATION;
        else
        {
            CMimeFt*    pMft = NULL;
            hr = CMimeFt::Create(&pMft);
            if( (hr == NOERROR) && pMft )
            {
                hr = pMft->QueryInterface(riid, ppv);
                pMft->Release();
            }
        }
    }
    else if( _ClsID == CLSID_StdEncodingFilterFac)
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
        if( pUnkOuter)
            hr = CLASS_E_NOAGGREGATION;
        else
        {
            *ppv = NULL;
            *ppv = new CEncodingFilterFactory;
            if( *ppv == NULL )
                hr = E_OUTOFMEMORY;
            else
                hr = ((IEncodingFilterFactory*)(*ppv))->AddRef();                
        }
    
    }


    EProtDebugOut((DEB_PLUGPROT, "%p OUT CUrlClsFact::CreateInstance (hr:%lx)\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::LockServer
//
//  Synopsis:   locks the server, preventing it from being unloaded
//
//  Arguments:  [fLock] -- TRUE to lock, FALSE to unlock
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlClsFact::LockServer(BOOL fLock)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CUrlClsFact::LockServer\n", this));
    HRESULT hr = NOERROR;
    if (fLock)
    {
        if (++_CLocks == 1)
        {
            DllAddRef();
        }
    }
    else
    {
        EProtAssert((_CLocks > 0));
        if (_CLocks > 0)
        {
            if (--_CLocks == 0)
            {
                DllRelease();
            }
        }
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CUrlClsFact::LockServer (hr:%lx)\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlClsFact::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    HRESULT hr = NOERROR;
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CUrlClsFact::QueryInterface\n", this));

    if (   riid == IID_IUnknown
        || riid == IID_IClassFactory)
    {
        *ppvObj = this;
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }
    if (hr == NOERROR)
    {
        AddRef();
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CUrlClsFact::QueryInterface (hr:%lx\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CUrlClsFact::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CUrlClsFact::AddRef(void)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CUrlClsFact::AddRef\n", this));

    LONG lRet = ++_CRefs;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CUrlClsFact::AddRef (cRefs:%ld)\n", this,lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CUrlClsFact::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CUrlClsFact::Release(void)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CUrlClsFact::Release\n", this));

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        delete this;
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CUrlClsFact::Release (cRefs:%ld)\n", this,lRet));
    return lRet;
}

#if DBG==1
HRESULT DumpIID(REFIID riid)
{

    HRESULT hr;
    LPOLESTR pszStr = NULL;

#ifdef EAPP_TEST
    hr = StringFromCLSID(riid, &pszStr);
    EProtDebugOut((DEB_PLUGPROT, "API >>> DumpIID (riid:%ws) \n", pszStr));
#endif // EAPP_TEST

    if (pszStr)
    {
        delete pszStr;
    }
    return hr = NOERROR;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\iapp\cnet.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cnet.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-04-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <iapp.h>
#include <winineti.h>   // contains bogus INTERNET_FLAG_NO_UI
#include <shlwapip.h>

CMutexSem g_mxsSession; // single access to InternetOpen


PerfDbgTag(tagCINet,    "Urlmon", "Log CINet",         DEB_PROT);
PerfDbgTag(tagCINetErr, "Urlmon", "Log CINet Errors",  DEB_PROT|DEB_ERROR);
LONG UrlMonInvokeExceptionFilter( DWORD lCode, LPEXCEPTION_POINTERS lpep );
DWORD StrLenMultiByteWithMlang(LPCWSTR, DWORD);
BOOL  ConvertUnicodeUrl(LPCWSTR, LPSTR, INT, DWORD, BOOL, BOOL*);
DWORD CountUnicodeToUtf8(LPCWSTR, DWORD, BOOL);
extern BOOL g_bGlobalUTF8Enabled;

#define INTERNET_POLICIES_KEY    "SOFTWARE\\Policies\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"

typedef UINT (WINAPI *GetSystemWow64DirectoryPtr) (LPTSTR lpBuffer, UINT uSize);

// Need this in GetUserAgentString.
HRESULT CallRegInstall(LPSTR szSection);

HRESULT EnsureSecurityManager ();

class CInetState
{
    enum WHAT_STATE
    {
         INETSTATE_NONE      = 0
        ,INETSTATE_SET       = 1
        ,INETSTATE_HANDLED   = 2
    };

public:
    void SetState(DWORD dwState)
    {
        DEBUG_ENTER((DBG_APP,
                    None,
                    "CInetState::SetState",
                    "this=%#x, %#x",
                    this, dwState
                    ));
                    
        CLock lck(_mxs);
        _dwState = dwState;
        _What = INETSTATE_SET;

        DEBUG_LEAVE(0);
    }
    HRESULT HandleState()
    {
        DEBUG_ENTER((DBG_APP,
                    Hresult,
                    "CInetState::HandleState",
                    "this=%#x",
                    this
                    ));
                    
        HRESULT hr = NOERROR;
        DWORD dwStateNow;
        BOOL fPropagate;

        {
            CLock lck(_mxs);
            dwStateNow = _dwState;
            fPropagate = (_What == INETSTATE_SET) ? TRUE : FALSE;
            _What = INETSTATE_HANDLED;
        }

        if (fPropagate)
        {
            hr = PropagateStateChange(dwStateNow);
        }

        DEBUG_LEAVE(hr);
        return hr;
    }

    HRESULT PropagateStateChange(DWORD dwState);

    CInetState()
    {
        DEBUG_ENTER((DBG_APP,
                    None,
                    "CInetState::CInetState",
                    "this=%#x",
                    this
                    ));
                    
        _dwState = 0;
        _What = INETSTATE_NONE;

        DEBUG_LEAVE(0);
    }

    ~CInetState()
    {
        DEBUG_ENTER((DBG_APP,
                    None,
                    "CInetState::~CInetState",
                    "this=%#x",
                    this
                    ));
    
        DEBUG_LEAVE(0);
    }

private:
    CMutexSem   _mxs;
    DWORD       _dwState;
    WHAT_STATE  _What;
};

//+---------------------------------------------------------------------------
//
//  Method:     CInetState::PropagateStateChange
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-22-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CInetState::PropagateStateChange(DWORD dwWhat)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CInetState::PropagateStateChange",
                "this=%#x, %#x",
                this, dwWhat
                ));
                    
    PerfDbgLog(tagCINet, this, "+CInetState::PropagateStateChange");
    HRESULT hr = NOERROR;

//  BUGBUG: IE5 need to implement these!
#if 0
    if (dwWhat & INTERNET_STATE_CONNECTED)
    {
        NotfDeliverNotification(
                                NOTIFICATIONTYPE_CONNECT_TO_INTERNET  // REFNOTIFICATIONTYPE rNotificationType
                               ,CLSID_PROCESS_BROADCAST     // REFCLSID            rClsidDest
                               ,(DELIVERMODE)0              // DELIVERMODE         deliverMode
                               ,0                           // DWORD               dwReserved
                               );

    }
    if (dwWhat & INTERNET_STATE_DISCONNECTED)
    {
        NotfDeliverNotification(
                                NOTIFICATIONTYPE_DISCONNECT_FROM_INTERNET  // REFNOTIFICATIONTYPE rNotificationType
                               ,CLSID_PROCESS_BROADCAST     // REFCLSID            rClsidDest
                               ,(DELIVERMODE)0              // DELIVERMODE         deliverMode
                               ,0                           // DWORD               dwReserved
                               );
    }
    if (dwWhat & INTERNET_STATE_DISCONNECTED_BY_USER)
    {
        NotfDeliverNotification(
                                NOTIFICATIONTYPE_CONFIG_CHANGED  // REFNOTIFICATIONTYPE rNotificationType
                               ,CLSID_PROCESS_BROADCAST     // REFCLSID            rClsidDest
                               ,(DELIVERMODE)0              // DELIVERMODE         deliverMode
                               ,0                           // DWORD               dwReserved
                               );

    }

    #ifdef _with_idle_and_busy_
        //
        // NOTE: wininet will send idle with every state change
        //       will be fixed by RFirth
        if (dwWhat & INTERNET_STATE_IDLE)
        {
            NotfDeliverNotification(
                                    NOTIFICATIONTYPE_INET_IDLE  // REFNOTIFICATIONTYPE rNotificationType
                                   ,CLSID_PROCESS_BROADCAST     // REFCLSID            rClsidDest
                                   ,(DELIVERMODE)0              // DELIVERMODE         deliverMode
                                   ,0                           // DWORD               dwReserved
                                   );
        }
        if (dwWhat & INTERNET_STATE_BUSY)
        {
            NotfDeliverNotification(
                                    NOTIFICATIONTYPE_INET_BUSY  // REFNOTIFICATIONTYPE rNotificationType
                                   ,CLSID_PROCESS_BROADCAST     // REFCLSID            rClsidDest
                                   ,(DELIVERMODE)0              // DELIVERMODE         deliverMode
                                   ,0                           // DWORD               dwReserved
                                   );

        }
    #endif //_with_idle_and_busy_

#endif // 0
    PerfDbgLog1(tagCINet, this, "-CInetState:PropagateStateChange (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//
// REMOVE THIS joHANNP
//

extern  LPSTR               g_pszUserAgentString;
HINTERNET                   g_hSession;
CInetState                  g_cInetState;

char vszLocationTag[] = "Location: ";

static DWORD dwLstError;

typedef struct tagProtocolInfo
{
    LPWSTR          pwzProtocol;
    LPSTR           pszProtocol;
    DWORD           dwId;
    CLSID           *pClsID;
    int             protlen;
} ProtocolInfo;



extern IInternetSecurityManager* g_pSecurityManager; // to handle GetSecurityId for cookies fix.

/*
    This function is not heavy on error-checking:
    The ASSERTS in the code MUST be satisfied for this function to work

    NOTE: don't care about OPAQUE urls since they are NOT http by definition.
 */

enum ComparisonState
{
    seenZone=1,
    seen1Dot,
    seen2Dots,
    seen3Dots,
    domainSame
};

#define MAKELOWER(val) (((val) > 'a') ? (val) : ((val)-'A'+'a'))

BOOL IsKnown2ndSubstring(BYTE* pStart, BYTE* pEnd)
{
    static const char *s_pachSpecialDomains[] = {"COM",     "EDU",      "NET",      "ORG",      "GOV",      "MIL",      "INT"};
    static const DWORD s_padwSpecialDomains[] = {0x00636f6d, 0x00656475, 0x006e6574, 0x006f7267, 0x00676f76, 0x006d696c, 0x00696e74};
    BOOL bKnown = FALSE;
    int nLen = (int) (pEnd-pStart+1);

    if ((nLen==2) && !StrCmpNI((LPCSTR)pStart, "CO", nLen))
    {
        bKnown = TRUE;
    }
    else if (nLen==3)
    {
        DWORD dwExt, dwByte;

        dwByte = *pStart++;
        dwExt = MAKELOWER(dwByte);
        dwExt <<= 8;
        dwByte = *pStart++;
        dwExt |= MAKELOWER(dwByte);
        dwExt <<= 8;
        dwByte = *pStart++;
        dwExt |= MAKELOWER(dwByte);

        for (int i=0; i<sizeof(s_padwSpecialDomains);)
        {
            if (dwExt == s_padwSpecialDomains[i++])
            {
                bKnown = TRUE;
                break;
            }
        }
    }

    return bKnown;
}
    
BOOL SecurityIdsMatch(BYTE* pbSecurityId1, DWORD dwLen1, BYTE* pbSecurityId2, DWORD dwLen2)
{
    //ASSERT((pbSecurityId1 && pbSecurityId2 && (dwLen1 > 0) && (dwLen2 > 0)));

    ComparisonState currState;
    BOOL bRetval = FALSE;
    //BOOL bRetval = ((dwLen1 == dwLen2) && (0 == memcmp(pbSecurityId1, pbSecurityId2, dwLen1)));

    BYTE *pCurr1, *pCurr2;
    DWORD dwDomainLen1, dwDomainLen2; //sizes of securityId w/o protocol.
    
    pCurr1 = pbSecurityId1;
    while(*pCurr1++ != ':');
    dwDomainLen1 = (DWORD)(pCurr1-pbSecurityId1);

    pCurr2 = pbSecurityId2;
    while(*pCurr2++ != ':');
    dwDomainLen2 = (DWORD)(pCurr2-pbSecurityId2);
    
    DEBUG_ENTER((DBG_APP,
                Bool,
                "SecurityIdsMatch",
                "%#x, %d, domainLen=%d %#x, %d, domainLen=%d",
                pbSecurityId1, dwLen1, dwDomainLen1, pbSecurityId2, dwLen2, dwDomainLen2
                ));

    BYTE *pBase1, *pBase2;
    BYTE bLeftByte, bRightByte;
    DWORD cbSubstring1 = 0;
    BYTE *pSubstring2Start = NULL;
    BYTE *pSubstring2End = NULL;
    
    //pCurr1 is the shorter one
    if (dwDomainLen1 < dwDomainLen2)
    {
        pCurr1 = pbSecurityId1+dwLen1-1-sizeof(DWORD);
        pBase1 = pbSecurityId1;
        pCurr2 = pbSecurityId2+dwLen2-1-sizeof(DWORD);
        pBase2 = pbSecurityId2;
    }
    else
    {
        pCurr2 = pbSecurityId1+dwLen1-1-sizeof(DWORD);
        pBase2 = pbSecurityId1;
        pCurr1 = pbSecurityId2+dwLen2-1-sizeof(DWORD);
        pBase1 = pbSecurityId2;
    }
    
    /* compare zone dword 
    if (memcmp(pCurr1, pCurr2, sizeof(DWORD)))
        goto End;
     */
     
    /* compare domains */
    currState = seenZone;
    while ((pCurr1 > pBase1) && (pCurr2 > pBase2))
    {
        if ((bLeftByte=*pCurr1--) == (bRightByte=*pCurr2--))
        {
            /* valid assumption? no ':' in domain name */
            //ASSERT(((currState==seenZone) && (bLeftByte == ':')))
            
            if ((bLeftByte == '.') && (currState < seen3Dots))
            {
                currState = (ComparisonState)(currState+1);
                switch (currState)
                {
                case seen1Dot:
                    pSubstring2End = pCurr1;
                    break;
                case seen2Dots:
                    pSubstring2Start = pCurr1+2;
                    break;
                }
            }
            else if (bLeftByte == ':')
            {
                currState = domainSame;
                break;
            }
            else if (currState == seenZone)
                cbSubstring1++;
        }
        else
            break;
    }

    switch (currState)
    {
    case seenZone:
    /* NOTE: this rules out http:ieinternal and http:foo.ieinternal not to be INCLUDED */
    /* The alternative is to risk http:com and http:www.microsoft.com */
        goto End;
    case seen1Dot:
    /*  INCLUDE http:microsoft.com and http:www.microsoft.com, 
         ( http:a.micro.com and http:b.micro.com included by seen2Dots )
        
        EXCLUDE http:co.uk and http:www.microsoft.co.uk 
        and all else
        eg. http:amicrosoft.com and http:www.microsoft.com
            &
            http:microsoft.com and http:amicrosoft.com
     */
        if ((bLeftByte != ':') || (bRightByte != '.') || ((cbSubstring1 == 2) && IsKnown2ndSubstring(pCurr1+2, pSubstring2End)))
            goto End;
        break;
    case seen2Dots:
    /*  INCLUDE http:ood.microsoft.com and http:food.microsoft.com
        INCLUDE http:a.co.uk and http:b.a.co.uk
        
        EXCLUDE http:www.microsoft.co.uk and http:www.amicrosoft.co.uk
     */
        if ((cbSubstring1 == 2) && IsKnown2ndSubstring(pSubstring2Start, pSubstring2End) && ((bLeftByte != ':') || (bRightByte != '.')))
            goto End;
        break;
    case seen3Dots:
    /*  INCLUDES all cases including 
            http:food.microsoft.co.uk and http:drink.microsoft.co.uk */
    case domainSame:
    /*  INCLUDES all equal domain cases of all substring sizes, including intranet sites */
        break;
    }

    /* no longer compare the protocols.
       if we get to this point, then the SecurityId's match.
     */
    bRetval = TRUE;
    
End:    
    DEBUG_LEAVE(bRetval);

    return bRetval;
}

BOOL SecurityIdContainsScheme(BYTE* pbSecurityId, DWORD dwLen)
{
    BYTE* pCurr = pbSecurityId;
    BOOL fRet = TRUE;

    while ( (DWORD)(pCurr-pbSecurityId) < dwLen )
    {
        if (*pCurr++ == ':')
        {
            goto End;
            break;
        }
    }
    fRet = FALSE;

End:
    return fRet;
}
    
//returns S_OK if they match, 
//        S_FALSE if they don't ( i.e. THIRD PARTY )
STDAPI CompareSecurityIds(BYTE* pbSecurityId1, DWORD dwLen1, BYTE* pbSecurityId2, DWORD dwLen2, DWORD dwReserved)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CompareSecurityIds",
                "%#x, %#x, %#x, %#x, %#x",
                pbSecurityId1, dwLen1, pbSecurityId2, dwLen2, dwReserved
                ));
                
    HRESULT hr = E_INVALIDARG;
    BOOL fRet;

    //parameter validation
    if ((dwLen1 <= 0) || (!pbSecurityId1) || (dwLen2 <= 0) || (!pbSecurityId2))
        goto End;

    if (!SecurityIdContainsScheme(pbSecurityId1, dwLen1) ||
        !SecurityIdContainsScheme(pbSecurityId2, dwLen2))
            goto End;

    fRet = SecurityIdsMatch(pbSecurityId1, dwLen1, pbSecurityId2, dwLen2);

    if (fRet == TRUE)
        hr = S_OK;
    else
        hr = S_FALSE;
        
End:
    DEBUG_LEAVE(hr);
    return hr;
}

BOOL CINet::IsThirdPartyUrl(LPCWSTR pwszUrl)
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "CINet::IsThirdPartyUrl",
                "this=%#x, %.80wq",
                this, pwszUrl
                ));
                
    BOOL bRetval = TRUE; // be safe or sorry?
    HRESULT hr = NOERROR;
    BYTE            bSID[MAX_SIZE_SECURITY_ID];
    DWORD           cbSID = MAX_SIZE_SECURITY_ID;

    if(!SUCCEEDED(hr = EnsureSecurityManager()))
    {
        goto End;
    }

    if (_pbRootSecurityId == NULL)
    {
//        ASSERT(FALSE);
        goto End;
    }
    else if (_pbRootSecurityId == INVALID_P_ROOT_SECURITY_ID)
    {
        bRetval = FALSE;
        goto End;
    }
      
    hr = g_pSecurityManager->GetSecurityId( pwszUrl, bSID, &cbSID, 0 );

    if (FAILED(hr))
        goto End;

    bRetval = !SecurityIdsMatch(bSID, cbSID, _pbRootSecurityId, _cbRootSecurityId);

End:
    DEBUG_LEAVE(bRetval);
    return bRetval;

}
        
BOOL CINet::IsThirdPartyUrl(LPCSTR pszUrl)
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "CINet::IsThirdPartyUrl",
                "this=%#x, %.80q",
                this, pszUrl
                ));
                
    WCHAR pwszUrl[MAX_URL_SIZE];
    BOOL bRetval = TRUE; // be safe or sorry?

    if(MultiByteToWideChar(CP_ACP, 0, pszUrl, -1, pwszUrl, MAX_URL_SIZE))
        bRetval = IsThirdPartyUrl(pwszUrl);

    DEBUG_LEAVE(bRetval);
    return bRetval;
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateKnownProtocolInstance
//
//  Synopsis:
//
//  Arguments:  [dwProtId] --
//              [rclsid] --
//              [pUnkOuter] --
//              [riid] --
//              [ppUnk] --
//
//  Returns:
//
//  History:    11-01-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CreateKnownProtocolInstance(DWORD dwProtId, REFCLSID rclsid, IUnknown *pUnkOuter, REFIID riid, IUnknown **ppUnk)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CreateKnownProtocolInstance",
                "%#x, %#x, %#x, %#x, %#x",
                dwProtId, &rclsid, pUnkOuter, &riid, ppUnk
                ));
                
    PerfDbgLog(tagCINet, NULL, "+CreateKnownProtocolInstance");
    HRESULT hr = NOERROR;
    CINet *pCINet = NULL;

    PProtAssert((ppUnk));

    if (!ppUnk || (pUnkOuter && (riid != IID_IUnknown)) )
    {
        // Note: aggregation only works if asked for IUnknown
        PProtAssert((FALSE && "Dude, look up aggregation rules - need to ask for IUnknown"));
        hr = E_INVALIDARG;
    }
    #if 0
    else if (riid == IID_IOInetProtocolInfo)
    {
        PProtAssert((dwProtId != DLD_PROTOCOL_NONE));
        COInetProtocolInfo *pProtInfo = new COInetProtocolInfo(dwProtId);
        if (pProtInfo)
        {
            hr = pProtInfo->QueryInterface(IID_IOInetProtocolInfo, (void **)ppUnk);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    #endif // 0
    else if (dwProtId != DLD_PROTOCOL_NONE)
    {
        CINet *pCINet = NULL;

        switch (dwProtId)
        {
        case  DLD_PROTOCOL_LOCAL  :
        case  DLD_PROTOCOL_FILE   :
            pCINet = new CINetFile(CLSID_FileProtocol,pUnkOuter);
        break;
        case  DLD_PROTOCOL_HTTP   :
            pCINet = new CINetHttp(CLSID_HttpProtocol,pUnkOuter);
        break;
        case  DLD_PROTOCOL_FTP    :
            pCINet = new CINetFtp(CLSID_FtpProtocol,pUnkOuter);
        break;
        case  DLD_PROTOCOL_GOPHER :
            pCINet = new CINetGopher(CLSID_GopherProtocol,pUnkOuter);
        break;
        case  DLD_PROTOCOL_HTTPS  :
            pCINet = new CINetHttpS(CLSID_HttpSProtocol,pUnkOuter);
        break;
        case  DLD_PROTOCOL_STREAM :
            pCINet = new CINetStream(CLSID_MkProtocol,pUnkOuter);
        break;
        default:
            PProtAssert((FALSE));
            hr = E_FAIL;
        }

        if (hr == NOERROR)
        {
            if (pCINet)
            {
                if (riid == IID_IUnknown)
                {
                    // pCINet has refcount of 1 now

                    // get the pUnkInner
                    // pUnkInner does not addref pUnkOuter
                    if (pUnkOuter && ppUnk)
                    {
                        *ppUnk = pCINet->GetIUnkInner(TRUE);
                        // addref the outer object since releasing pCINet will go cause a release on pUnkOuter
                        TransAssert((*ppUnk));
                    }
                }
                else
                {
                    if (riid == IID_IOInetProtocol)
                    {
                        // ok, got the right interface already
                        *ppUnk = (IOInetProtocol *)pCINet;
                    }
                    else
                    {
                        hr = pCINet->QueryInterface(riid, (void **)ppUnk);
                        // remove extra refcount
                        pCINet->Release();
                    }
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

        }
    }
    else
    {
        //load the protocol by looking up the registry
        hr = E_FAIL;
    }


    PerfDbgLog1(tagCINet, NULL, "-CreateKnownProtocolInstance(hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

ProtocolInfo rgKnownProts[] =
{
     { L"http"  , "http"   , DLD_PROTOCOL_HTTP   , (CLSID *) &CLSID_HttpProtocol  , sizeof("http")   - 1 }
    ,{ L"file"  , "file"   , DLD_PROTOCOL_FILE   , (CLSID *) &CLSID_FileProtocol  , sizeof("file")   - 1 }
    ,{ L"ftp"   , "ftp"    , DLD_PROTOCOL_FTP    , (CLSID *) &CLSID_FtpProtocol   , sizeof("ftp")    - 1 }
    ,{ L"https" , "https"  , DLD_PROTOCOL_HTTPS  , (CLSID *) &CLSID_HttpSProtocol , sizeof("http")   - 1 }
    ,{ L"mk"    , "mk"     , DLD_PROTOCOL_STREAM , (CLSID *) &CLSID_MkProtocol    , sizeof("mk")     - 1 }
    ,{ L"gopher", "Gopher" , DLD_PROTOCOL_GOPHER , (CLSID *) &CLSID_GopherProtocol, sizeof("gopher") - 1 }
    ,{ L"local" , "local"  , DLD_PROTOCOL_LOCAL  , (CLSID *) &CLSID_FileProtocol  , sizeof("local")  - 1 }
};

typedef struct tagInterErrorToHResult
{
    DWORD   dwError;
    HRESULT hresult;
} InterErrorToHResult;

InterErrorToHResult INetError[] =
{
     0                                        ,NOERROR
    ,ERROR_INTERNET_OUT_OF_HANDLES            ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_TIMEOUT                   ,INET_E_CONNECTION_TIMEOUT
    ,ERROR_INTERNET_EXTENDED_ERROR            ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_INTERNAL_ERROR            ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_INVALID_URL               ,INET_E_INVALID_URL
    ,ERROR_INTERNET_UNRECOGNIZED_SCHEME       ,INET_E_UNKNOWN_PROTOCOL
    ,ERROR_INTERNET_NAME_NOT_RESOLVED         ,INET_E_RESOURCE_NOT_FOUND
    ,ERROR_INTERNET_PROTOCOL_NOT_FOUND        ,INET_E_UNKNOWN_PROTOCOL
    ,ERROR_INTERNET_INVALID_OPTION            ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_BAD_OPTION_LENGTH         ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_OPTION_NOT_SETTABLE       ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_SHUTDOWN                  ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_INCORRECT_USER_NAME       ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_INCORRECT_PASSWORD        ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_LOGIN_FAILURE             ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_INVALID_OPERATION         ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_OPERATION_CANCELLED       ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_INCORRECT_HANDLE_TYPE     ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_INCORRECT_HANDLE_STATE    ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_NOT_PROXY_REQUEST         ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_REGISTRY_VALUE_NOT_FOUND  ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_BAD_REGISTRY_PARAMETER    ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_NO_DIRECT_ACCESS          ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_NO_CONTEXT                ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_NO_CALLBACK               ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_REQUEST_PENDING           ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_INCORRECT_FORMAT          ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_ITEM_NOT_FOUND            ,INET_E_OBJECT_NOT_FOUND
    ,ERROR_INTERNET_CANNOT_CONNECT            ,INET_E_RESOURCE_NOT_FOUND
    ,ERROR_INTERNET_CONNECTION_ABORTED        ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_CONNECTION_RESET          ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_FORCE_RETRY               ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_INVALID_PROXY_REQUEST     ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_NEED_UI                   ,INET_E_DOWNLOAD_FAILURE
    ,0                                        ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_HANDLE_EXISTS             ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_SEC_CERT_DATE_INVALID     ,INET_E_SECURITY_PROBLEM
    ,ERROR_INTERNET_SEC_CERT_CN_INVALID       ,INET_E_SECURITY_PROBLEM
    ,ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR    ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR    ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_MIXED_SECURITY            ,INET_E_SECURITY_PROBLEM
    ,ERROR_INTERNET_CHG_POST_IS_NON_SECURE    ,INET_E_SECURITY_PROBLEM
    ,ERROR_INTERNET_POST_IS_NON_SECURE        ,INET_E_SECURITY_PROBLEM
    ,ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED   ,INET_E_SECURITY_PROBLEM
    ,ERROR_INTERNET_INVALID_CA                ,INET_E_SECURITY_PROBLEM
    ,ERROR_INTERNET_CLIENT_AUTH_NOT_SETUP     ,INET_E_SECURITY_PROBLEM
    ,ERROR_INTERNET_SEC_CERT_REV_FAILED       ,INET_E_SECURITY_PROBLEM
    ,ERROR_INTERNET_SEC_CERT_REVOKED          ,INET_E_SECURITY_PROBLEM
    ,ERROR_INTERNET_FORTEZZA_LOGIN_NEEDED     ,INET_E_SECURITY_PROBLEM
    ,ERROR_INTERNET_ASYNC_THREAD_FAILED       ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_REDIRECT_SCHEME_CHANGE    ,INET_E_DOWNLOAD_FAILURE
};

// list of non-sequential errors
InterErrorToHResult INetErrorExtended[] =
{
     ERROR_FTP_TRANSFER_IN_PROGRESS           ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_FTP_DROPPED                        ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_GOPHER_PROTOCOL_ERROR              ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_GOPHER_NOT_FILE                    ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_GOPHER_DATA_ERROR                  ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_GOPHER_END_OF_DATA                 ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_GOPHER_INVALID_LOCATOR             ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_GOPHER_INCORRECT_LOCATOR_TYPE      ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_GOPHER_NOT_GOPHER_PLUS             ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_GOPHER_ATTRIBUTE_NOT_FOUND         ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_GOPHER_UNKNOWN_LOCATOR             ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_HTTP_HEADER_NOT_FOUND              ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_HTTP_DOWNLEVEL_SERVER              ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_HTTP_INVALID_SERVER_RESPONSE       ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_HTTP_INVALID_HEADER                ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_HTTP_INVALID_QUERY_REQUEST         ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_HTTP_HEADER_ALREADY_EXISTS         ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_HTTP_REDIRECT_FAILED               ,INET_E_REDIRECT_FAILED
    ,ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION   ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_SECURITY_CHANNEL_ERROR    ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_UNABLE_TO_CACHE_FILE      ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_TCPIP_NOT_INSTALLED       ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_HTTP_NOT_REDIRECTED                ,INET_E_DOWNLOAD_FAILURE
    ,ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR   ,INET_E_DOWNLOAD_FAILURE
};

//+---------------------------------------------------------------------------
//
//  Function:   IsKnownOInetProtocolClass
//
//  Synopsis:
//
//  Arguments:  [pclsid] --
//
//  Returns:
//
//  History:    11-01-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD IsKnownOInetProtocolClass(CLSID *pclsid)
{
    DEBUG_ENTER((DBG_APP,
                Dword,
                "IsKnownOInetProtocolClass",
                "%#x",
                pclsid
                ));
                
    PProtAssert((pclsid));
    DWORD dwRet = DLD_PROTOCOL_NONE;
    int i = 0;
    int cSize = sizeof(rgKnownProts)/sizeof(ProtocolInfo);

    if (pclsid)
    {
        for (i = 0; i < cSize; ++i)
        {
            if (*pclsid == *rgKnownProts[i].pClsID)
            {
                dwRet = rgKnownProts[i].dwId;
                i = cSize;
            }
        }
    }

    DEBUG_LEAVE(dwRet);
    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsKnownProtocol
//
//  Synopsis:   looks up if an protocol handler exist for a given url
//
//  Arguments:  [wzProtocol] --
//
//  Returns:
//
//  History:    11-01-1996   JohannP (Johann Posch)   Created
//
//  Notes:      used at many place inside urlmon
//
//----------------------------------------------------------------------------
DWORD IsKnownProtocol(LPCWSTR wzProtocol)
{
    DEBUG_ENTER((DBG_APP,
                Dword,
                "IsKnownProtocol",
                "%#.80wq",
                wzProtocol
                ));
                
    DWORD dwRet = DLD_PROTOCOL_NONE;
    int i = 0;
    int cSize = sizeof(rgKnownProts)/sizeof(ProtocolInfo);

    for (i = 0; i < cSize; ++i)
    {
        if (!StrCmpNICW(wzProtocol, rgKnownProts[i].pwzProtocol, rgKnownProts[i].protlen))
        {
            dwRet = rgKnownProts[i].dwId;

            if ((DLD_PROTOCOL_HTTP == dwRet) &&
                ((wzProtocol[4] == L's') ||
                 (wzProtocol[4] == L'S')))

            {
                dwRet = DLD_PROTOCOL_HTTPS;
            }
            break;
        }
    }

    DEBUG_LEAVE(dwRet);
    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetKnownOInetProtocolClsID
//
//  Synopsis:
//
//  Arguments:  [dwProtoId] --
//
//  Returns:
//
//  History:    11-01-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CLSID *GetKnownOInetProtocolClsID(DWORD dwProtoId)
{
    DEBUG_ENTER((DBG_APP,
                Pointer,
                "GetKnownOInetProtocolClsID",
                "%#x",
                dwProtoId
                ));
                
    PerfDbgLog1(tagCINet, NULL, "GetKnownOInetProtocolClsID (dwProtoId:%lx)", dwProtoId);
    CLSID *pclsid = 0;

    int cSize = sizeof(rgKnownProts)/sizeof(ProtocolInfo);

    for (int i = 0; i < cSize; ++i)
    {
        if (dwProtoId == rgKnownProts[i].dwId )
        {
            pclsid = rgKnownProts[i].pClsID;
            i = cSize;
        }
    }

    DEBUG_LEAVE(pclsid);
    return pclsid;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::QueryInterface(REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppvObj
                ));
                
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    PerfDbgLog(tagCINet, this, "+CINet::QueryInterface");

    if (riid == IID_IOInetPriority)
    {
        *ppvObj = (IOInetPriority *) this;
        AddRef();
    }
    else
    {
        hr = _pUnkOuter->QueryInterface(riid, ppvObj);
    }

    PerfDbgLog1(tagCINet, this, "-CINet::QueryInterface (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CINet::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CINet::AddRef(void)
{
    DEBUG_ENTER((DBG_APP,
                Dword,
                "CINet::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::AddRef");

    LONG lRet = _pUnkOuter->AddRef();

    PerfDbgLog1(tagCINet, this, "-CINet::AddRef (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CINet::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CINet::Release(void)
{
    DEBUG_ENTER((DBG_APP,
                Dword,
                "CINet::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::Release");

    LONG lRet = _pUnkOuter->Release();

    PerfDbgLog1(tagCINet, this, "-CINet::Release (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::Start
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pTrans] --
//              [pOIBindInfo] --
//              [grfSTI] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::Start(LPCWSTR pwzUrl, IOInetProtocolSink *pTrans, IOInetBindInfo *pOIBindInfo,
                          DWORD grfSTI, DWORD_PTR dwReserved)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IInternetProtocolRoot::Start",
                "this=%#x, %.200wq, %#x, %#x, %#x, %#x",
                this, pwzUrl, pTrans, pOIBindInfo, grfSTI, dwReserved
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::Start");
    HRESULT hr = NOERROR;
    //char    szURL[MAX_URL_SIZE];
    DWORD   dwUrlSize = 0;
    DWORD dwMaxUTF8Len = 0;
    BOOL    fUTF8Enabled = FALSE;
    BOOL    fUTF8Required = FALSE;


    PProtAssert((!_pCTrans && pOIBindInfo && pTrans));
    PProtAssert((_pwzUrl == NULL));


    if ( !(grfSTI & PI_PARSE_URL))
    {
        _pCTrans = pTrans;
        _pCTrans->AddRef();

        _pOIBindInfo =  pOIBindInfo;
        _pOIBindInfo->AddRef();

        _pwzUrl = OLESTRDuplicate((LPWSTR)pwzUrl);
    }

    _BndInfo.cbSize = sizeof(BINDINFO);

    hr = pOIBindInfo->GetBindInfo(&_grfBindF, &_BndInfo);
    
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "EXTERNAL_CLIENT::GetBindInfo",
                "this=%#x, flags=%#x, pBindInfo=%#x",
                this, _grfBindF, pOIBindInfo
                ));

    DEBUG_LEAVE(hr);
    
    if( hr != NOERROR )
    {
        goto End;
    }

    /************************************************************************
    // szURL does not seem to be used, am I missing something?
    // szURL is 2K buffer on stack! Let's remove this code at all.
    // DanpoZ (98/02/20)

    // Do we need to append the extra data to the url?
    if (_BndInfo.szExtraInfo)
    {
        // append extra info at the end of the url
        // Make sure we don't overflow the URL
        if (CchWzLen(_BndInfo.szExtraInfo) + CchWzLen(pwzUrl) >= MAX_URL_SIZE)
        {
            hr = E_INVALIDARG;
            goto End;
        }

        W2A(pwzUrl, szURL, MAX_URL_SIZE, _BndInfo.dwCodePage);

        // Append the extra data to the url.  Note that we have already
        // checked for overflow, so we need not worry about it here.
        W2A(_BndInfo.szExtraInfo, szURL + CchSzLen(szURL), MAX_URL_SIZE, _BndInfo.dwCodePage);
    }
    else
    {
        // Make sure we don't overflow the URL
        if (CchWzLen(pwzUrl) + 1 > MAX_URL_SIZE)
        {
            hr = E_INVALIDARG;
            goto End;
        }
        W2A(pwzUrl, szURL, MAX_URL_SIZE, _BndInfo.dwCodePage);
    }
    ************************************************************************/

    // no need to check the length of pwzUrl, this has been done already
    if( !_BndInfo.dwCodePage )
        _BndInfo.dwCodePage = GetACP();


    // utf8 enabled?
    fUTF8Enabled = UTF8Enabled();

    if( fUTF8Enabled )
    {
        dwUrlSize = CountUnicodeToUtf8(pwzUrl, wcslen(pwzUrl), TRUE);
        DWORD dwMB = StrLenMultiByteWithMlang(pwzUrl, _BndInfo.dwCodePage);
        if( dwMB > dwUrlSize )
        {
            dwUrlSize = dwMB;
        }
    }
    else
    {
        dwUrlSize = StrLenMultiByteWithMlang(pwzUrl, _BndInfo.dwCodePage);
    }

    if( !dwUrlSize )
    {
        hr = E_INVALIDARG;
        goto End;
    }


    if( CUrlInitBasic(dwUrlSize) )
    {
        //W2A(pwzUrl, _pszBaseURL, dwUrlSize, _BndInfo.dwCodePage);
        ConvertUnicodeUrl(
                pwzUrl,                 // (IN)  unicode URL
                _pszBaseURL,            // (OUT) multibyte URL
                dwUrlSize,              // (IN)  multibyte URL length
                _BndInfo.dwCodePage,    // (IN)  codepage
                fUTF8Enabled,           // (IN)  UTF-8 conversion enabled?
                &fUTF8Required
                );
    }
    else
    {
        hr = E_OUTOFMEMORY;
        goto End;
    }

    {
        // Init the Embedded Filter
        if( _pEmbdFilter )
        {
            delete _pEmbdFilter;
            _pEmbdFilter = NULL;
        }
        _pEmbdFilter = new CINetEmbdFilter( this, _pCTrans );
        if( !_pEmbdFilter )
        {
            hr = E_OUTOFMEMORY;
            goto End;
        }
        if(!_pEmbdFilter->IsInited())
        {
            delete _pEmbdFilter;
            _pEmbdFilter = NULL;
            hr = E_OUTOFMEMORY;
            goto End;
        }

        // For sanity checks later via IsEmbdFilterOk():
        _dwEmbdFilter = *(DWORD *)_pEmbdFilter;
    }

    if (!ParseUrl(fUTF8Required, pwzUrl, _BndInfo.dwCodePage))
    {
        _hrError = INET_E_INVALID_URL;
        hr = MK_E_SYNTAX;
    }
    else if ( !(grfSTI & PI_PARSE_URL))
    {
        g_cInetState.HandleState();
        PProtAssert((_pCTrans));
        if( !(_grfBindF & BINDF_FROMURLMON) && IsEmbdFilterOk() )
        {
            _pEmbdFilter->ReportProgress(BINDSTATUS_DIRECTBIND, 0);
        }
        hr = INetAsyncStart();
    }
End:

    PerfDbgLog1(tagCINet, this, "-CINet::Start (hr:%lx)", hr);
    if( hr == E_PENDING )
    {
        // hack, CTransact will warp E_PENDING with NOERROR and return
        // it to client, if we do not have CTrans wrapper (not aggregrated)
        // we should return NOERROR.
        if( _pUnkOuter == &_Unknown )
        {
            hr = NOERROR;
        }
    }

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::Continue
//
//  Synopsis:
//
//  Arguments:  [pStateInfoIn] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::Continue(PROTOCOLDATA *pStateInfoIn)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IInternetProtocolRoot::Continue",
                "this=%#x, %#x",
                this, pStateInfoIn
                ));
                
    HRESULT hr = E_FAIL;
    if(IsEmbdFilterOk())
        hr = _pEmbdFilter->Continue(pStateInfoIn);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CINet::MyContinue(PROTOCOLDATA *pStateInfoIn)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::MyContinue",
                "this=%#x, %#x",
                this, pStateInfoIn
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::Continue");
    HRESULT hr = NOERROR;

    PProtAssert((pStateInfoIn->pData && !pStateInfoIn->cbData));

    // check if the inete state changed
    g_cInetState.HandleState();

    OnINetInternal((DWORD_PTR) pStateInfoIn->pData);

    if( !(_grfBindF & BINDF_FROMURLMON) )
    {
        //
        // if the BindInfo is created from heap by CINet
        // we need to delete it from here
        //
        delete pStateInfoIn;
    }

    PerfDbgLog1(tagCINet, this, "-CINet::Continue (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINet::Abort
//
//  Synopsis:
//
//  Arguments:  [hrReason] --
//              [dwOptions] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::Abort(HRESULT hrReason, DWORD dwOptions)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IInternetProtocolRoot::Abort",
                "this=%#x, %#x, %#x",
                this, hrReason, dwOptions
                ));
                
    HRESULT hr = NOERROR;
    if( _pEmbdFilter )
    {
        hr = _pEmbdFilter->Abort(hrReason, dwOptions);
    }

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CINet::MyAbort(HRESULT hrReason, DWORD dwOptions)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::MyAbort",
                "this=%#x, %#x, %#x",
                this, hrReason, dwOptions
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::Abort");
    HRESULT hr = NOERROR;

    PProtAssert((_pCTrans));

    hr = ReportResultAndStop(hrReason);

    PerfDbgLog1(tagCINet, this, "-CINet::Abort (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::Terminate
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::Terminate(DWORD dwOptions)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IInternetProtocolRoot::Terminate",
                "this=%#x, %#x",
                this, dwOptions
                ));
                
    // in case we failed on :Start, _pEmbdFilter is
    // not in place, however, Terminate might be
    // called so we have to call MyTerminate directly
    HRESULT hr = NOERROR;
    if( _pEmbdFilter )
    {
        hr = _pEmbdFilter->Terminate(dwOptions);
    }
    else
    {
        hr = MyTerminate(dwOptions);
    }

    DEBUG_LEAVE(hr);
    return hr;
}

/*
 * This function will only be called into after MyTerminate has been called -
 *  since only InternetCloseHandle called in MyTerminate should trigger a handle-closing callback.
 *
 *  No synchronization may be required because :
 *
 *  1. all operations at this point using the handle should have
        been done with since the handle has been destroyed ( hence no Reads in progress. )
    2. if we find that we need to synchronize access to this, we must correspondinly synchronize
        all access to the _pCTrans object from CINet.  Hopefully, this is not required because 
        we should get handleclosing callback from wininet only after we have exited all callbacks.
    3. the only other place _pCTrans can be touched from is Reads from above which shouldn't be 
        happening if this is closed as a result of being aborted or terminated cleanly.
 *
    The objective of this new function is to let the _pCTrans connection live until wininet is done
    with context use - else witness ugly race condition in bug 2270.

    ReleaseBindInfo() happening here to get around bug 19809, which again is triggered by IBinding::Abort
    situations in stress.
 */
 
VOID CINet::ReleaseTransAndBindInfo()
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINet::ReleaseTransAndBindInfo",
                "this=%#x, %#x",
                this, _pCTrans
                ));

    if (!_fHandlesRecycled)
    {
        PProtAssert((_pCTrans));
        PProtAssert((_dwState == INetState_DONE) || (_dwState == INetState_ERROR));
        PProtAssert((_dwIsA == DLD_PROTOCOL_HTTP) || (_dwIsA == DLD_PROTOCOL_HTTPS) || (_dwIsA == DLD_PROTOCOL_FILE) || (_dwIsA == DLD_PROTOCOL_GOPHER));
        // Hopefully, this stays an assert.
        //  scenario where abort is called before/during the OpenRequest/OpenUrl call.
        PProtAssert((_HandleStateRequest == HandleState_Closed)); 

        if (_pCTrans)
        {
            _pCTrans->Release();
            _pCTrans = NULL;
        }
        
        ReleaseBindInfo(&_BndInfo);
    }

    DEBUG_LEAVE(0);
}
    
STDMETHODIMP CINet::MyTerminate(DWORD dwOptions)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::MyTerminate",
                "this=%#x, %#x",
                this, dwOptions
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::Terminate");
    HRESULT hr = NOERROR;
    BOOL fReleaseBindInfo = FALSE;

    //should be called once
    PProtAssert((_pCTrans));

    if (_pOIBindInfo)
    {
        _pOIBindInfo->Release();
        _pOIBindInfo = NULL;
    }

    if (_pServiceProvider)
    {
        _pServiceProvider->Release();
        _pServiceProvider = NULL;
    }

    if (_pCTrans)
    {
        // release all the handles if unless
        // the request was locked
        if (!_fLocked && !_hLockHandle)
        {
            TerminateRequest();
        }

        // sync block
        {
            CLock lck(_mxs);    // only one thread should be in here

            if ((_dwState != INetState_DONE) && (_dwState != INetState_ERROR))
            {
                _dwState = INetState_DONE;
            }

            if (    (_dwIsA == DLD_PROTOCOL_FILE)
                ||  (_dwIsA == DLD_PROTOCOL_LOCAL)
                ||  (_dwIsA == DLD_PROTOCOL_STREAM)
                ||  _fHandlesRecycled
                ||  (_HandleStateServer == HandleState_Aborted))
            {
                fReleaseBindInfo = TRUE;
                _pCTrans->Release();
                _pCTrans = NULL;
            }
        }

    }

#if DBG == 1
    if ( _BndInfo.stgmedData.tymed != TYMED_NULL )
        PerfDbgLog1(tagCINet, this, "--- CINet::Stop ReleaseStgMedium (%lx)", _BndInfo.stgmedData);
#endif

    if (    fReleaseBindInfo
        ||  (_dwIsA == DLD_PROTOCOL_FILE)
        ||  (_dwIsA == DLD_PROTOCOL_LOCAL)
        ||  (_dwIsA == DLD_PROTOCOL_STREAM)
        ||  _fHandlesRecycled
        ||  (_HandleStateServer == HandleState_Aborted))
    {
        ReleaseBindInfo(&_BndInfo);
    }

    PerfDbgLog1(tagCINet, this, "-CINet::Terminate (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::Suspend
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::Suspend()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IInternetProtocolRoot::Suspend",
                "this=%#x",
                this
                ));
                
    HRESULT hr = _pEmbdFilter->Suspend();

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CINet::MySuspend()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::MySuspend",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::Suspend");

    HRESULT hr = E_NOTIMPL;

    PerfDbgLog1(tagCINet, this, "-CINet::Suspend (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::Resume
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::Resume()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IInternetProtocolRoot::Resume",
                "this=%#x",
                this
                ));
                
    HRESULT hr = _pEmbdFilter->Resume();

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CINet::MyResume()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::MyResume",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::Resume");

    HRESULT hr = E_NOTIMPL;

    PerfDbgLog1(tagCINet, this, "-CINet::Resume (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::SetPriority
//
//  Synopsis:
//
//  Arguments:  [nPriority] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::SetPriority(LONG nPriority)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IInternetPriority::SetPriority",
                "this=%#x, %#x",
                this, nPriority
                ));
                
    PerfDbgLog1(tagCINet, this, "+CINet::SetPriority (%ld)", nPriority);

    HRESULT hr = S_OK;

    _nPriority = nPriority;

    PerfDbgLog1(tagCINet, this, "-CINet::SetPriority (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::GetPriority
//
//  Synopsis:
//
//  Arguments:  [pnPriority] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::GetPriority(LONG * pnPriority)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IInternetPriority::GetPriority",
                "this=%#x, %#x",
                this, pnPriority
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::GetPriority");

    HRESULT hr = S_OK;

    *pnPriority = _nPriority;

    PerfDbgLog1(tagCINet, this, "-CINet::GetPriority (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::Read
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//              [ULONG] --
//              [pcbRead] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::Read(void *pv,ULONG cb,ULONG *pcbRead)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IInternetProtocol::Read",
                "this=%#x, %#x, %#x, %#x",
                this, pv, cb, pcbRead
                ));
                
    HRESULT hr =  _pEmbdFilter->Read(pv, cb, pcbRead);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CINet::MyRead(void *pv,ULONG cb,ULONG *pcbRead)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::MyRead",
                "this=%#x, %#x, %#x, %#x",
                this, pv, cb, pcbRead
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::Read");
    HRESULT hr = NOERROR;

    if(GetBindFlags() & BINDF_DIRECT_READ)
    {
        hr = ReadDirect((BYTE *)pv, cb, pcbRead);
    }
    else
    {
        hr = ReadDataHere((BYTE *)pv, cb, pcbRead);
    }

    PerfDbgLog1(tagCINet, this, "-CINet::Read (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::Seek
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [ULARGE_INTEGER] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IInternetProtocol::Seek",
                "this=%#x, %#x, %#x, %#x",
                this, dlibMove, dwOrigin, plibNewPosition
                ));
                
    HRESULT hr = _pEmbdFilter->Seek(dlibMove, dwOrigin, plibNewPosition);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CINet::MySeek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::MySeek",
                "this=%#x, %#x, %#x, %#x",
                this, dlibMove, dwOrigin, plibNewPosition
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::Seek");
    HRESULT hr;

    hr = INetSeek(dlibMove, dwOrigin,plibNewPosition);

    PerfDbgLog1(tagCINet, this, "-CINet::Seek (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::LockRequest
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::LockRequest(DWORD dwOptions)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IInternetProtocol::LockRequest",
                "this=%#x, %#x",
                this, dwOptions
                ));
                
    HRESULT hr = _pEmbdFilter->LockRequest(dwOptions);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CINet::MyLockRequest(DWORD dwOptions)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::MyLockRequest",
                "this=%#x, %#x",
                this, dwOptions
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::LockRequest");
    HRESULT hr = NOERROR;

    hr = LockFile(FALSE);

    PerfDbgLog1(tagCINet, this, "-CINet::LockRequest (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::UnlockRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::UnlockRequest()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IInternetProtocol::UnlockRequest",
                "this=%#x",
                this
                ));
                
    HRESULT hr = _pEmbdFilter->UnlockRequest();

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CINet::MyUnlockRequest()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::MyUnlockRequest",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::UnlockRequest");
    HRESULT hr = NOERROR;

    TerminateRequest();
    hr = UnlockFile();

    PerfDbgLog1(tagCINet, this, "-CINet::UnlockRequest (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINet::QueryOption
//
//  Synopsis:
//
//  Arguments:  [dwOption] --
//              [pBuffer] --
//              [pcbBuf] --
//
//  Returns:
//
//  History:    4-16-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::QueryOption(DWORD dwOption, LPVOID pBuffer, DWORD *pcbBuf)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IWininetInfo::QueryOption",
                "this=%#x, %#x, %#x, %#x",
                this, dwOption, pBuffer, pcbBuf
                ));
                
    PerfDbgLog1(tagCINet, this, "+CINet::QueryOptions dwOption:%ld", dwOption);
    HRESULT hr;

    if (!pcbBuf || (*pcbBuf == 0))
    {
        hr = E_INVALIDARG;
    }
    else if (!_hRequest)
    {
        *pcbBuf = 0;
        hr = E_FAIL;
    }
    else if (dwOption == WININETINFO_OPTION_LOCK_HANDLE)
    {
        if (    *pcbBuf >= sizeof(HANDLE)
            &&  InternetLockRequestFile(_hRequest, (HANDLE *)pBuffer))
        {
            *pcbBuf = sizeof(HANDLE);
            hr = S_OK;
        }
        else
        {
            *pcbBuf = 0;
            hr = E_FAIL;
        }
    }
    else
    {
        if (InternetQueryOption(_hRequest, dwOption, pBuffer, pcbBuf))
        {
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }

    PerfDbgLog2(tagCINet, this, "-CINet::QueryOptions (hr:%lx,szStr:%s)", hr, pBuffer);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::QueryInfo
//
//  Synopsis:
//
//  Arguments:  [dwOption] --
//              [pBuffer] --
//              [pcbBuf] --
//              [pdwFlag] --
//
//  Returns:
//
//  History:    4-16-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::QueryInfo(DWORD dwOption, LPVOID pBuffer, DWORD *pcbBuf, DWORD *pdwFlags, DWORD *pdwReserved)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IWininetHttpInfo::QueryInfo",
                "this=%#x, %#x, %#x, %#x, %#x, %#x",
                this, dwOption, pBuffer, pcbBuf, pdwFlags, pdwReserved
                ));
                
    PerfDbgLog1(tagCINet, this, "+CINet::QueryInfo dwOption:%ld", dwOption);
    HRESULT hr;

    if (!pcbBuf)
    {
        hr = E_INVALIDARG;
    }
    else if (!_hRequest)
    {
        *pcbBuf = 0;
        hr = E_FAIL;
    }
    else
    {
        if (HttpQueryInfo(_hRequest, dwOption, pBuffer, pcbBuf, pdwFlags))
        {
            hr = S_OK;
        }
        else
        {
            if (pBuffer  && (*pcbBuf >= sizeof(HRESULT)) )
            {
                HRESULT *phr = (HRESULT *)pBuffer;
                *phr = HRESULT_FROM_WIN32(GetLastError());
                *pcbBuf = sizeof(HRESULT);
            }
            hr = S_FALSE;
        }
    }

    PerfDbgLog2(tagCINet, this, "-CINet::QueryInfo (hr:%lx,szStr:%s)", hr, XDBG(pBuffer&&!hr?pBuffer:"",""));

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CINet::Prepare()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IInternetThreadSwitch::Prepare",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::Prepare");
    HRESULT hr = NOERROR;

    PerfDbgLog1(tagCINet, this, "-CINet::Prepare (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CINet::Continue()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::IInternetThreadSwitch::Continue",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::Continue");
    HRESULT hr = NOERROR;

    _dwThreadID = GetCurrentThreadId();

    PerfDbgLog1(tagCINet, this, "-CINet::Continue (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::CINet
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CINet::CINet(REFCLSID rclsid, IUnknown *pUnkOuter) : _CRefs(), _CRefsHandles(0), _cReadCount(0), _pclsidProtocol(rclsid), _Unknown()
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINet::CINet",
                "this=%#x, %#x, %#x",
                this, &rclsid, pUnkOuter
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::CINet");
    _dwEmbdFilter = NULL;
    _pEmbdFilter = NULL;
    
    _dwState = INetState_START;
    _dwIsA = DLD_PROTOCOL_NONE;
    _fRedirected = FALSE;
    _fP2PRedirected = FALSE;
    _fLocked = FALSE;
    _fFilenameReported = FALSE;
    _fHandlesRecycled = FALSE;
    _fSendAgain = FALSE;
    _fSendRequestAgain = FALSE;
    _hLockHandle = NULL;
    _hFile = NULL;
    _dwThreadID = GetCurrentThreadId();
    _fDone = 0;
    _hwndAuth = NULL;
    _bscf = BSCF_FIRSTDATANOTIFICATION;
    _pOIBindInfo = 0;
    _pszUserAgentStr = 0;
    _nPriority = THREAD_PRIORITY_NORMAL;
    _cbSizeLastReportData = 0;
    _fForceSwitch = FALSE;
    _cbAuthenticate = 0;
    _cbProxyAuthenticate = 0;

    _fDoSimpleRetry = FALSE;

    if (!pUnkOuter)
    {
        pUnkOuter = &_Unknown;
    }
    _pUnkOuter = pUnkOuter;
    _pWindow = 0;

    _hServer = 0;
    _hRequest = 0;


    PerfDbgLog(tagCINet, this, "-CINet::CINet");

    DEBUG_LEAVE(0);
}

CINet::~CINet()
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINet::~CINet",
                "this=%#x",
                this
                ));
                
    delete _pwzUrl;
#if DBG == 1
    _pwzUrl = NULL;
#endif
    delete _pszUserAgentStr;

    // release Embedded Filter
    if( _pEmbdFilter )
    {
        CINetEmbdFilter* pEmbdFilter = _pEmbdFilter;
        _pEmbdFilter = NULL;
        delete pEmbdFilter;
    }

    PerfDbgLog(tagCINet, this, "CINet::~CINet");

    DEBUG_LEAVE(0);
}

// Helper function for _pEmbdFilter sanity check:
bool CINet::IsEmbdFilterOk()
{
    if(_pEmbdFilter && !::IsBadReadPtr(_pEmbdFilter, sizeof(DWORD)) && *(DWORD *)_pEmbdFilter == _dwEmbdFilter)
        return true;

    // Shouldn't happen, but is happening in rare cases.
    // Filter got released because someone likely deleted an incorrect offset. 
    PProtAssert((FALSE));
    PerfDbgLog(tagCINet, this, "+CINet::IsEmbdFilterOk: EmbedFilter missing, recreating.");
    
    if(_pCTrans)
    {
        CLock lck(_mxs);    // only one thread should be in here
        // Do the check again just in case we have two threads entering:
        if(_pEmbdFilter && !::IsBadReadPtr(_pEmbdFilter, sizeof(DWORD)) && *(DWORD *)_pEmbdFilter == _dwEmbdFilter)
            return true;

        // Release _pCTrans to compensate for the AddRef in 
        // the CINetEmbdFilter constructor, since the CINetEmbdFilter destructor would not have been called:
        _pCTrans->Release();

        // Recreate the filter here if possible:
        _pEmbdFilter = new CINetEmbdFilter( this, _pCTrans );
        if( !_pEmbdFilter || !_pEmbdFilter->IsInited())
        {
            // Something failed (deleting NULL is fine): 
            delete _pEmbdFilter;
            goto End;
        }
        // For sanity checks later via IsEmbdFilterOk():
        _dwEmbdFilter = *(DWORD *)_pEmbdFilter;
        return true;
    }

End:
    PerfDbgLog(tagCINetErr, this, "+CINet::IsEmbdFilterOk: Unable to recreate EmbedFilter, possibly out of memory.");
    SetINetState(INetState_ERROR);
    // Null out and return false:
    _pEmbdFilter = NULL; 
    return false;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::ReportResultAndStop
//
//  Synopsis:   Post the termination package
//
//  Arguments:  [hr] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::ReportResultAndStop(HRESULT hr, ULONG ulProgress,ULONG ulProgressMax, LPWSTR pwzStr)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::ReportResultAndStop",
                "this=%#x, %#x, %#x, %#x, %.80wq",
                this, hr, ulProgress, ulProgressMax, pwzStr
                ));
                
    PerfDbgLog1(tagCINet, this, "+CINet::ReportResultAndStop (hr:%lx)", hr);

    HRESULT hrOut = NOERROR;
    BOOL fReportResult = FALSE;
    BOOL fReportData = FALSE;


    {
        CLock lck(_mxs);    // only one thread should be in here

        // set the state to error and report error
        // must go in queue since other messages might be ahead
        if ((_dwState != INetState_DONE) && (_dwState != INetState_ERROR))
        {
            _hrINet = hr;
            _dwState = (hr != NOERROR) ? INetState_ERROR : INetState_DONE;
            if (_dwState == INetState_DONE)
            {
                if (ulProgress == 0)
                {
                    ulProgress = _cbTotalBytesRead;
                    ulProgressMax = _cbDataSize;
                }
                if ( ( (ulProgress != _cbSizeLastReportData ) ||
                       (!ulProgress && !ulProgressMax)           ) &&
                     ( _grfBindF & BINDF_FROMURLMON ) )
                {
                    //
                    // last notification
                    // NOTE: we need to report data for empty page
                    //       we might have report this data already,
                    //       so check for the _cbSizeLastReportData
                    //       if they are same, do not report data
                    //       again. (this might give hard time for
                    //       IEFeatuer handler )
                    //
                    _bscf |= BSCF_LASTDATANOTIFICATION;
                    fReportData = TRUE;
                }

                //
                // HACK: for prodegy's ocx
                // if we have not send out ReportData(BSCF_LAST...) and
                // we are doing BindToStorage but the data has been
                // reported, we have to report it again with LAST flag
                // tuned on
                //
                if( !fReportData &&
                    !(_bscf & BSCF_LASTDATANOTIFICATION ) &&
                    !(_BndInfo.dwOptions & BINDINFO_OPTIONS_BINDTOOBJECT) )
                {
                    // need to send out last notifiation for whatever
                    // client depend on it...
                    _bscf |= BSCF_LASTDATANOTIFICATION;
                    fReportData = TRUE;
                }
            }
            else if (_dwState == INetState_ERROR)
            {
                SetINetState(INetState_ERROR);
            }

            PProtAssert((_pCTrans));
            fReportResult = TRUE;
        }
    }

    if (_pCTrans)
    {
        if (fReportData)
        {
            _cbSizeLastReportData = ulProgress;
            _pEmbdFilter->ReportData(_bscf, ulProgress, ulProgressMax);
        }
        // teminate might have occured on ReportData
        if (fReportResult && _pCTrans)
        {
            _pEmbdFilter->ReportResult(hr,_dwResult,pwzStr);
        }

        if( !fReportResult )
        {
            hrOut = INET_E_RESULT_DISPATCHED;
        }
    }

    PerfDbgLog1(tagCINet, this, "-CINet::ReportResultAndStop (hrOut:%lx)", hrOut);

    DEBUG_LEAVE(hrOut);
    return hrOut;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::ReportNotification
//
//  Synopsis:
//
//  Arguments:  [NMsg] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::ReportNotification(BINDSTATUS NMsg, LPCSTR szStr)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::ReportNotification",
                "this=%#x, %#x, %.80q",
                this, NMsg, szStr
                ));
                
    PerfDbgLog1(tagCINet, this, "+CINet::ReportNotification (NMsg:%lx)", NMsg);
    HRESULT hr = E_FAIL;

    BOOL fReport = FALSE;
    LPWSTR pwzStr = 0;

    { // ssync block begin
        CLock lck(_mxs);    // only one thread should be in here

        if ((_dwState != INetState_DONE) && (_dwState != INetState_ERROR))
        {
            if (szStr)
            {
                pwzStr = DupA2W((const LPSTR)szStr);
            }
            if (szStr && !pwzStr)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                fReport = TRUE;
            }
        }
    } // sync block end

    if (fReport)
    {
        if ( _pCTrans && IsEmbdFilterOk() )
        {
            hr = _pEmbdFilter->ReportProgress((ULONG)NMsg, pwzStr);
        }
    }

    delete pwzStr;

    PerfDbgLog(tagCINet, this, "-CINet::ReportNotification");

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT CINet::ReportNotificationW(BINDSTATUS NMsg, LPCWSTR wzStr)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::ReportNotificationW",
                "this=%#x, %#x, %.80q",
                this, NMsg, wzStr
                ));
                
    PerfDbgLog1(tagCINet, this, "+CINet::ReportNotificationW (NMsg:%lx)", NMsg);
    HRESULT hr = E_FAIL;

    BOOL fReport = FALSE;

    { // ssync block begin
        CLock lck(_mxs);    // only one thread should be in here

        if ((_dwState != INetState_DONE) && (_dwState != INetState_ERROR))
            fReport = TRUE;

    } // sync block end

    if (fReport)
    {
        if ( _pCTrans && _pEmbdFilter )
        {
            hr = _pEmbdFilter->ReportProgress((ULONG)NMsg, wzStr);
        }
    }

    PerfDbgLog(tagCINet, this, "-CINet::ReportNotificationW");

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::SetPending
//
//  Synopsis:
//
//  Arguments:  [hrNew] --
//
//  Returns:
//
//  History:    3-28-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::SetStatePending(HRESULT hrNew)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::SetStatePending",
                "this=%#x, %#x",
                this, hrNew
                ));
                
    CLock lck(_mxs);    // only one thread should be in here
    HRESULT hr;

    PerfDbgLog2(tagCINet, this, "CINet::SetStatePending (hrOld:%lx, hrNew:%lx)", _hrPending, hrNew);

    //BUGBUG: turn this assertion on again
    PProtAssert(( (   ((_hrPending != E_PENDING) && (hrNew == E_PENDING))
                   || ((_hrPending == E_PENDING) && (hrNew != E_PENDING))) ));

    hr = _hrPending;
    _hrPending = hrNew;

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::GetStatePending
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    4-08-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::GetStatePending()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::GetStatePending",
                "this=%#x",
                this
                ));
                
    CLock lck(_mxs);    // only one thread should be in here
    //PerfDbgLog1(tagCINet, this, "CINet::GetStatePending (hr:%lx)", _hrPending);

    DEBUG_LEAVE(_hrPending);
    return _hrPending;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::SetByteCountReadyToRead
//
//  Synopsis:
//
//  Arguments:  [cbReadyReadNow] --
//
//  Returns:
//
//  History:    6-25-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CINet::SetByteCountReadyToRead(LONG cbReadyReadNow)
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINet::SetByteCountReadyToRead",
                "this=%#x, %#x",
                this, cbReadyReadNow
                ));
                
    CLock lck(_mxs);    // only one thread should be in here
    PerfDbgLog3(tagCINet, this, "CINet::SetByteCountReadyToRead (cbReadReturn:%ld, cbReadyRead:%ld, cbReadyLeft:%ld)",
                    _cbReadyToRead, cbReadyReadNow, _cbReadyToRead + cbReadyReadNow);
    _cbReadyToRead += cbReadyReadNow ;

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::GetByteCountReadyToRead
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    6-25-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
ULONG CINet::GetByteCountReadyToRead()
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINet::GetByteCountReadyToRead",
                "this=%#x",
                this
                ));
                
    CLock lck(_mxs);    // only one thread should be in here
    PerfDbgLog1(tagCINet, this, "CINet::GetByteCountReadyToRead (_cbReadyToRead:%ld)", _cbReadyToRead);

    DEBUG_LEAVE(_cbReadyToRead);
    return _cbReadyToRead;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::SetINetState
//
//  Synopsis:
//
//  Arguments:  [inState] --
//
//  Returns:
//
//  History:    2-25-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
INetState CINet::SetINetState(INetState inState)
{
    DEBUG_ENTER((DBG_APP,
                Dword,
                "CINet::SetINetState",
                "this=%#x, %#x",
                this, inState
                ));
                
    CLock lck(_mxs);    // only one thread should be in here
    PerfDbgLog1(tagCINet, this, "+CINet::SetINetState (State:%lx)", inState);

    INetState in = _INState;
    _INState = inState;

    PerfDbgLog1(tagCINet, this, "-CINet::SetINetState (hr:%lx)", in);

    DEBUG_LEAVE(in);
    return in;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::GetINetState
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-25-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
INetState CINet::GetINetState()
{
    DEBUG_ENTER((DBG_APP,
                Dword,
                "CINet::GetINetState",
                "this=%#x",
                this
                ));
                
    CLock lck(_mxs);    // only one thread should be in here
    PerfDbgLog(tagCINet, this, "+CINet::GetINetState");

    INetState in = _INState;

    PerfDbgLog1(tagCINet, this, "-CINet::GetINetState (hr:%lx)", in);

    DEBUG_LEAVE(in);
    return in;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetAsyncStart
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetAsyncStart()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetAsyncStart",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetAsyncStart");
    HRESULT hr = NOERROR;
    BOOL fAsyncStart = FALSE;

    // guard the object
    PrivAddRef();

    if (fAsyncStart)
    {
        // post notification for next step
        SetINetState(INetState_START);
        TransitState(INetState_START);
    }
    else
    {
        hr = INetAsyncOpen();
    }

    if (_hrError != INET_E_OK)
    {
        if (hr != S_OK && hr != E_PENDING && hr != INET_E_DONE)
        {
            PProtAssert((  (hr >= INET_E_ERROR_FIRST && hr <= INET_E_ERROR_LAST)
                         ||(hr == E_OUTOFMEMORY)
                         ||(hr == E_ABORT)
                         ));

            ReportResultAndStop(hr);
        }
        else
        {
            // he will do inetdone notifications
            ReportResultAndStop(NOERROR);
        }
    }

    PrivRelease();

    PerfDbgLog1(tagCINet, this, "-CINet::INetAsyncStart (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINet::OnINetStart
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::OnINetStart()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::OnINetStart",
                "this=%#x",
                this
                ));
                
    HRESULT hr;
    PerfDbgLog(tagCINet, this, "+CINet::OnINetStart");

    // nothing to do - just call
    hr = INetAsyncOpen();

    PerfDbgLog1(tagCINet, this, "-CINet::OnINetStart (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetAsyncOpen
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetAsyncOpen()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetAsyncOpen",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetAsyncOpen");
    PProtAssert((GetStatePending() == NOERROR));
    DWORD dwFlags = INTERNET_FLAG_ASYNC;
    DWORD dwBindF = 0;

    HRESULT hr = NOERROR;

    if (g_hSession == NULL)
    {
        // Only 1 thread should be in here, this is to protect
        // two global variables g_hSession and g_pszUserAgentString
        {
            CLock lck(g_mxsSession);
            if( g_hSession == NULL )
            {
                SetINetState(INetState_OPEN_REQUEST);

                PerfDbgLog1(tagCINet, this, "___ INetAysncOpen calling InternetOpen %ld", GetTickCount());
                SetStatePending(E_PENDING);

                g_hSession = InternetOpen(
                    GetUserAgentString()
                    , INTERNET_OPEN_TYPE_PRECONFIG
                    , NULL
                    , NULL
                    , dwFlags);
                PerfDbgLog1(tagCINet, this, "___ INetAysncOpen done InternetOpen %ld", GetTickCount());

                if (g_hSession == NULL)
                {
                    dwLstError = GetLastError();
                    if (dwLstError == ERROR_IO_PENDING)
                    {
                        hr = E_PENDING;
                    }
                    else
                    {
                        SetStatePending(NOERROR);
                        hr = _hrError = INET_E_NO_SESSION;
                        SetBindResult(dwLstError, hr);
                    }
                }
                else
                {
                    if (g_pszUserAgentString)
                    {
                        // Open was successful, so we don't need the replacement
                        // User Agent string anymore.

                        delete g_pszUserAgentString;
                        g_pszUserAgentString = NULL;
                    }

                    SetStatePending(NOERROR);
                    InternetSetStatusCallbackA(g_hSession, CINetCallback);
                    hr = INetAsyncConnect();
                }
            }
            else
            {
                hr = INetAsyncConnect();
            }
        } // single access block
    }
    else
    {
        hr = INetAsyncConnect();
    }

    PerfDbgLog1(tagCINet, this, "-CINet::INetAsyncOpen (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::OnINetAsyncOpen
//
//  Synopsis:
//
//  Arguments:  [dwResult] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::OnINetAsyncOpen(DWORD_PTR dwResult)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::OnINetAsyncOpen",
                "this=%#x, %#x",
                this, dwResult
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::OnINetAsyncOpen");
    HRESULT hr = NOERROR;

    PProtAssert((GetStatePending() == E_PENDING));
    // set state to normal - no pending transaction
    SetStatePending(NOERROR);

    if (dwResult)
    {
        // set the handle and the callback
        g_hSession = (HINTERNET) dwResult;
        InternetSetStatusCallbackA(g_hSession, CINetCallback);
    }
    // notification for next request
    TransitState(INetState_OPEN_REQUEST);

    PerfDbgLog1(tagCINet, this, "-CINet::OnINetAsyncOpen (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetAsyncConnect
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetAsyncConnect()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetAsyncConnect",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetAsyncConnect");
    PProtAssert((GetStatePending() == NOERROR));

    HRESULT hr = NOERROR;
    BOOL fRestarted;
    DWORD dwBindF = 0;
    DWORD dwService = INTERNET_SERVICE_HTTP;

    // get the open flags

    dwBindF = GetBindFlags();

    if (dwBindF & BINDF_GETNEWESTVERSION)
    {
        _dwOpenFlags |= INTERNET_FLAG_RELOAD;
        PerfDbgLog1(tagCINet, this, "***CINet::****RELOAD***** %lx", dwBindF);

    }
    else
    {
        PerfDbgLog1(tagCINet, this, "---CINet::----NO-RELOAD %lx --", dwBindF);
    }

    if (dwBindF & BINDF_NOWRITECACHE)
    {
        _dwOpenFlags |= INTERNET_FLAG_DONT_CACHE ;
    }

    if (dwBindF & BINDF_NEEDFILE)
    {
        PerfDbgLog(tagCINet, this, "CINet::INetAsyncConnect: turn on: INTERNET_FLAG_NEED_FILE");
        _dwOpenFlags |= INTERNET_FLAG_NEED_FILE;
    }

    if (dwBindF & (BINDF_NO_UI | BINDF_SILENTOPERATION))
    {
        _dwOpenFlags |= INTERNET_FLAG_NO_UI;
    }

    // BUGBUG OFFLINE, RELOAD, RESYNCHRONIZE and HYPERLINK are mutually
    // exclusive. But inside wininet there is priority, so
    // the priority is OFFLINE, RELOAD, RESYNCHRONIZE, HYPERLINK in that order

    if (dwBindF & BINDF_RESYNCHRONIZE)
    {
        // caller asking to do if-modified-since

        _dwOpenFlags |= INTERNET_FLAG_RESYNCHRONIZE;
    }

    if (dwBindF & BINDF_HYPERLINK)
    {
        // caller says this is a hyperlink access

        _dwOpenFlags |= INTERNET_FLAG_HYPERLINK;
    }

    if (dwBindF & BINDF_FORMS_SUBMIT)
    {
        // caller says this is a forms submit.
        _dwOpenFlags |= INTERNET_FLAG_FORMS_SUBMIT;
    }

    if (dwBindF & BINDF_OFFLINEOPERATION )
    {
        _dwOpenFlags |= INTERNET_FLAG_OFFLINE;
    }

    // connect flags
    if (dwBindF & BINDF_OFFLINEOPERATION )
    {
        _dwConnectFlags |= INTERNET_FLAG_OFFLINE;
    }

    if (dwBindF & BINDF_PRAGMA_NO_CACHE )
    {
        _dwOpenFlags |= INTERNET_FLAG_PRAGMA_NOCACHE;
    }

    if( dwBindF & BINDF_GETFROMCACHE_IF_NET_FAIL)
    {
        _dwOpenFlags |= INTERNET_FLAG_CACHE_IF_NET_FAIL;
    }

    if( dwBindF & BINDF_FWD_BACK )
    {
        _dwOpenFlags |= INTERNET_FLAG_FWD_BACK;
    }

    // additional wininet flags are passed with bindinfo
    if( _BndInfo.dwOptions == BINDINFO_OPTIONS_WININETFLAG )
    {
        _dwOpenFlags |= _BndInfo.dwOptionsFlags;
    }


    SetINetState(INetState_CONNECT_REQUEST);

    PrivAddRef(TRUE);

    _HandleStateServer = HandleState_Pending;
    SetStatePending(E_PENDING);

    HINTERNET hServerTmp = InternetConnect(
            g_hSession,                             // hInternetSession
            GetServerName(),                        // lpszServerName
            _ipPort,                                // nServerPort
            (_pszUserName[0])?_pszUserName:NULL,    // lpszUserName
            (_pszPassword[0])?_pszPassword:NULL,    // lpszPassword
            dwService,                              // INTERNET_SERVICE_HTTP
            _dwConnectFlags,                        // dwFlags
            (DWORD_PTR) this
    );
    //
    // Note: do not remove this state setting here!
    //       there is a timing window - needs to
    //       be fixed in wininet/urlmon!!!
    SetINetState(INetState_CONNECT_REQUEST);

    if ( hServerTmp == 0)
    {
        dwLstError = GetLastError();
        if (dwLstError == ERROR_IO_PENDING)
        {
            // wait async for the handle
            hr = E_PENDING;
        }
        else
        {
            PrivRelease(TRUE);
            SetStatePending(NOERROR);
            hr = _hrError = INET_E_CANNOT_CONNECT;
            SetBindResult(dwLstError, hr);
        }
    }
    else
    {
        _hServer = hServerTmp;
        SetStatePending(NOERROR);
        // wininet holds on to CINet - Release called on the callback on close handle
        _HandleStateServer = HandleState_Initialized;
        PerfDbgLog1(tagCINet, this, "=== CINet::INetAsyncConnect (hServer:%lx)", _hServer);
        PProtAssert((_hServer));
        hr = INetAsyncOpenRequest();
    }

    PerfDbgLog1(tagCINet, this, "-CINet::INetAsyncConnect (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::OnINetConnect
//
//  Synopsis:
//
//  Arguments:  [dwResult] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::OnINetConnect(DWORD_PTR dwResult)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::OnINetConnect",
                "this=%#x, %#x",
                this, dwResult
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::OnINetConnect");
    HRESULT hr = NOERROR;

    PProtAssert((GetStatePending() == E_PENDING));
    // set state to normal - no pending transaction
    SetStatePending(NOERROR);
    TransAssert((_hServer == 0));

    if (dwResult)
    {
        CLock lck(_mxs);    // only one thread should be in here
        if (_HandleStateServer == HandleState_Pending)
        {
            TransAssert((_hServer == 0));
            // set the server handle
            _HandleStateServer = HandleState_Initialized;
            _hServer = (HANDLE)dwResult;
        }

        // wininet holds on to CINet - Release called on the callback on close handle
        PerfDbgLog1(tagCINet, this, "=== CINet::OnINetConnect (hServer:%lx)", _hServer);
    }

    if (_hServer)
    {
        TransitState(INetState_CONNECT_REQUEST);
    }
    else
    {
        PProtAssert((_HandleStateServer == HandleState_Aborted));
        PrivRelease(TRUE);
    }

    PerfDbgLog1(tagCINet, this, "-CINet::OnINetConnect (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetAsyncOpenRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetAsyncOpenRequest()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetAsyncOpenRequest",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetAsyncOpenRequest");

    HRESULT hr = E_FAIL;

    PerfDbgLog1(tagCINet, this, "-CINet::INetAsyncOpenRequest (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::OnINetOpenRequest
//
//  Synopsis:
//
//  Arguments:  [dwResult] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::OnINetOpenRequest(DWORD_PTR dwResult)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::OnINetOpenRequest",
                "this=%#x, %#x",
                this, dwResult
                ));
                
    PerfDbgLog1(tagCINet, this, "+CINet::OnINetOpenRequest (dwResult:%lx)", dwResult);
    HRESULT hr = NOERROR;

    PProtAssert((GetStatePending() == E_PENDING));
    // set state to normal - no pending transaction
    SetStatePending(NOERROR);
    TransAssert((_hRequest == 0));

    if (dwResult)
    {
        CLock lck(_mxs);    // only one thread should be in here

        if (_HandleStateRequest == HandleState_Pending)
        {
            // set the request handle
            _HandleStateRequest = HandleState_Initialized;
            _hRequest = (HANDLE)dwResult;
            PProtAssert((_hServer != _hRequest));
        }
    }

    if (_hRequest)
    {
        if (_fUTF8hack)
        {
            DWORD dwSendUTF8 = 1;
            InternetSetOption(_hRequest, INTERNET_OPTION_SEND_UTF8_SERVERNAME_TO_PROXY, &dwSendUTF8, sizeof(DWORD));
        }
        
        hr = INetAsyncSendRequest();
    }
    else
    {
        PProtAssert((_HandleStateRequest == HandleState_Aborted));
        PrivRelease(TRUE);
    }

    PerfDbgLog1(tagCINet, this, "-CINet::OnINetOpenRequest (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;

}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetAsyncSendRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetAsyncSendRequest()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetAsyncSendRequest",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetAsyncSendRequest");

    HRESULT hr = E_FAIL;

    PerfDbgLog1(tagCINet, this, "-CINet::INetAsyncSendRequest (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::OnINetSendRequest
//
//  Synopsis:
//
//  Arguments:  [dwResult] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::OnINetSendRequest( DWORD dwResult)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::OnINetSendRequest",
                "this=%#x, %#x",
                this, dwResult
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::OnINetSendRequest");
    HRESULT hr = NOERROR;

    PProtAssert((GetStatePending() == E_PENDING));
    // set state to normal - no pending transaction
    SetStatePending(NOERROR);

    _dwSendRequestResult = dwResult;
    _lpvExtraSendRequestResult = NULL;

    if( dwResult == ERROR_INTERNET_FORCE_RETRY )
    {
        PerfDbgLog(tagCINet, this, "  --dwResult = FORCE_RETRY! ");
        _fSendRequestAgain = TRUE;
    }

    if (OperationOnAparmentThread(INetState_SEND_REQUEST))
    {
        // query for content-encoding header, if we find one,
        // we will have to force TransitState to do thread switching
        // since the compression filter can not be loaded on worker
        // thread
        char szEncType[SZMIMESIZE_MAX] = "";
        DWORD cbLen = sizeof(szEncType);
        if( _hRequest &&
            HttpQueryInfo(_hRequest, HTTP_QUERY_CONTENT_ENCODING,
                          szEncType, &cbLen, NULL) )
        {
            if( cbLen && szEncType[0] )
                _fForceSwitch = TRUE;
        }

        // if sec problem shows up on UI thread, we need to
        // force switch
        switch(_dwSendRequestResult)
        {
            case ERROR_INTERNET_SEC_CERT_DATE_INVALID     :
            case ERROR_INTERNET_SEC_CERT_CN_INVALID       :
            case ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR    :
            case ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR    :
            case ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR   :
            case ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION   :
            case ERROR_INTERNET_INVALID_CA                :
            case ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED   :
            case ERROR_INTERNET_FORTEZZA_LOGIN_NEEDED     :
            case ERROR_INTERNET_FORCE_RETRY               :
            case ERROR_INTERNET_SEC_CERT_ERRORS           :
            case ERROR_INTERNET_SEC_CERT_REV_FAILED       :
            case ERROR_INTERNET_SEC_CERT_REVOKED          :
                _fForceSwitch = TRUE;
        }


        TransitState(INetState_SEND_REQUEST);
    }
    else if (!IsUpLoad())
    {
        hr = INetQueryInfo();
    }
    else
    {
        if( _fSendRequestAgain )
        {
            _fCompleted = FALSE;
            _fSendAgain = TRUE;
            _fSendRequestAgain = FALSE;
            hr = INetAsyncSendRequest();
        }
    }

    PerfDbgLog1(tagCINet, this, "-CINet::OnINetSendRequest (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::OnINetSuspendSendRequest
//
//  Synopsis:   called on a wininet callback to indicate the suspentition
//               of request processing until UI is displayed to the user.
//
//  Arguments:  [dwResult] -- error code to generate dialog for
//              [lpvExtraResult] -- extra void pointer used pass dialog specific data
//
//  Returns:
//
//  History:    5-24-98   ArthurBi (Arthur Bierer)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::OnINetSuspendSendRequest(DWORD dwResult, LPVOID lpvExtraResult)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::OnINetSuspendSendRequest",
                "this=%#x, %#x, %#x",
                this, dwResult, lpvExtraResult
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::OnINetSuspendSendRequest");
    HRESULT hr = NOERROR;

    PProtAssert((GetStatePending() == E_PENDING));

    // set state to normal - no pending transaction
    SetStatePending(NOERROR);

    _dwSendRequestResult = dwResult;
    _lpvExtraSendRequestResult = lpvExtraResult;

    //if (OperationOnAparmentThread(INetState_SEND_REQUEST))

    // even though we're not doing auth, we need to do UI
    _hrINet = INET_E_AUTHENTICATION_REQUIRED;
    TransitState(INetState_DISPLAY_UI, TRUE);

    PerfDbgLog1(tagCINet, this, "-CINet::OnINetSuspendSendRequest (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetStateChange
//
//  Synopsis:   called on the apartment thread
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-22-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetStateChange()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetStateChange",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetStateChange");

    HRESULT hr = NOERROR;

    g_cInetState.HandleState();

    PerfDbgLog1(tagCINet, this, "-CINet::INetStateChange (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::OnINetStateChange
//
//  Synopsis:   called on the wininet worker thread whenever the
//              wininet state changes
//
//  Arguments:  [dwResult] --
//
//  Returns:
//
//  History:    1-22-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::OnINetStateChange( DWORD dwResult)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::OnINetStateChange",
                "this=%#x, %#x",
                this, dwResult
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::OnINetStateChange");
    HRESULT hr = NOERROR;

    // set the new state and ping the apartment thread
    g_cInetState.SetState(dwResult);

    TransitState(INetState_INETSTATE_CHANGE);

    PerfDbgLog1(tagCINet, this, "-CINet::OnINetStateChange (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetQueryInfo
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetQueryInfo()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetQueryInfo",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetQueryInfo");

    HRESULT hr = NOERROR;

    // Here we check if we need to do redirection, or
    // whether authentication is needed etc.
    if (!IsUpLoad())
    {
        hr = QueryInfoOnResponse();
    }
    if (hr == NOERROR)
    {
        // read more data from wininet
        hr = INetRead();
    }
    else if (hr == S_FALSE)
    {
        // S_FALSE means successful redirecting occured
        hr = NOERROR;
    }

    if (_hrError != INET_E_OK)
    {
        // we need to terminate here
        ReportResultAndStop(hr);
    }
    PerfDbgLog1(tagCINet, this, "-CINet::INetQueryInfo (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::OnINetRead
//
//  Synopsis:
//
//  Arguments:  [dwResult] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::OnINetRead(DWORD_PTR dwResult)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::OnINetRead",
                "this=%#x, %#x",
                this, dwResult
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::OnINetRead");
    HRESULT hr = NOERROR;

    PProtAssert((GetStatePending() == E_PENDING));
    // set state to normal - no pending transaction
    SetStatePending(NOERROR);

    if (OperationOnAparmentThread(INetState_SEND_REQUEST))
    {
        TransitState(INetState_READ);
    }
    else
    {
        hr = INetRead();
    }

    PerfDbgLog1(tagCINet, this, "-CINet::OnINetRead (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetRead
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetRead()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetRead",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetRead");
    HRESULT hr = NOERROR;
    
    if (IsUpLoad())
    {
        hr = INetWrite();
    }
    else if(GetBindFlags() & BINDF_DIRECT_READ)
    {
        hr = INetReadDirect();
    }
    else
    {
        // this is the no-copy case
        // read data to users buffer
        hr = INetDataAvailable();
    }

    if (_hrError != INET_E_OK)
    {
        // we need to terminate here
        ReportResultAndStop((_hrError == INET_E_DONE) ? NOERROR : _hrError);
    }

    PerfDbgLog1(tagCINet, this, "-CINet::INetRead (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetwrite
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetWrite()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetWrite",
                "this=%#x",
                this
                ));
                
    HRESULT hr = E_FAIL;

    TransAssert((FALSE && "HAS TO BE OVERWRITTEN"));

    DEBUG_LEAVE(hr);
    return hr;
}

#define COOKIES_BLOCKED_STRING "CookiesBlocked"

BINDSTATUS BindStatusFromCookieAction(DWORD dwCookieAction)
{
    BINDSTATUS nMsg;
    
    switch(dwCookieAction)
    {
        case COOKIE_STATE_PROMPT:
            nMsg = BINDSTATUS_COOKIE_STATE_PROMPT;
            break;
        case COOKIE_STATE_ACCEPT:
            nMsg = BINDSTATUS_COOKIE_STATE_ACCEPT;
            break;
        case COOKIE_STATE_REJECT:
            nMsg = BINDSTATUS_COOKIE_STATE_REJECT;
            break;
        case COOKIE_STATE_LEASH:
            nMsg = BINDSTATUS_COOKIE_STATE_LEASH;
            break;
        case COOKIE_STATE_DOWNGRADE:
            nMsg = BINDSTATUS_COOKIE_STATE_DOWNGRADE;
            break;
        default:
            nMsg = BINDSTATUS_COOKIE_STATE_UNKNOWN;
            break;
    }

    return nMsg;
}

HRESULT CINet::OnCookieNotification(DWORD dwStatus, IN LPVOID pvInfo)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::OnCookieNotification",
                "this=%#x, %#x, %#x",
                this, dwStatus, pvInfo
                ));

    HRESULT hr = ERROR_SUCCESS;

    BINDSTATUS nMsg;
    DWORD dwBlock = 0;

    switch (dwStatus)
    {
        case INTERNET_STATUS_P3P_HEADER:
        {
            TransAssert(pvInfo && "pvInfo should be a pointer to the P3P header");

            hr = ReportNotification(BINDSTATUS_P3P_HEADER, (LPSTR)pvInfo);
            break;
        }

        case INTERNET_STATUS_P3P_POLICYREF:
        {
            TransAssert(pvInfo && "pvInfo should be pointer to policy-ref URL");

            if (char *pszPolicyRef = (char*) pvInfo)
                hr = ReportNotification(BINDSTATUS_POLICY_HREF, (LPSTR)pszPolicyRef);

            break;
        }

        case INTERNET_STATUS_COOKIE_HISTORY:
        {
            InternetCookieHistory *pPastActions = (InternetCookieHistory*) pvInfo;

            if (!pPastActions)
                break;

            if (pPastActions->fAccepted)
                ReportNotification(BINDSTATUS_COOKIE_STATE_ACCEPT, NULL);

            if (pPastActions->fLeashed)
                ReportNotification(BINDSTATUS_COOKIE_STATE_LEASH, NULL);    

            if (pPastActions->fDowngraded)
                ReportNotification(BINDSTATUS_COOKIE_STATE_DOWNGRADE, NULL);

            if (pPastActions->fRejected)
                ReportNotification(BINDSTATUS_COOKIE_STATE_REJECT, NULL);

            break;
        }

        case INTERNET_STATUS_COOKIE_SENT:
        {
            OutgoingCookieState* pOutgoing = (OutgoingCookieState *)pvInfo;

            TransAssert(pOutgoing && "pvInfo should be OutgoingCookieState*");
            
            if (pOutgoing->cSent)
            {
                hr = ReportNotification(BINDSTATUS_COOKIE_SENT, pOutgoing->pszLocation);
            }
            if (pOutgoing->cSuppressed)
            {
                hr = ReportNotification(BINDSTATUS_COOKIE_SUPPRESSED, pOutgoing->pszLocation);
            }
            break;
        }
        
        case INTERNET_STATUS_COOKIE_RECEIVED:
        {
            IncomingCookieState* pIncoming = (IncomingCookieState *)pvInfo;

            TransAssert(pIncoming && "pvInfo should be OutgoingCookieState*");
            
            if (pIncoming->cAccepted)
                hr = ReportNotification(BINDSTATUS_COOKIE_STATE_ACCEPT, pIncoming->pszLocation);
            
            if (SUCCEEDED(hr) && pIncoming->cLeashed)
                hr = ReportNotification(BINDSTATUS_COOKIE_STATE_LEASH, pIncoming->pszLocation);
            
            if (SUCCEEDED(hr) && pIncoming->cDowngraded)
                hr = ReportNotification(BINDSTATUS_COOKIE_STATE_DOWNGRADE, pIncoming->pszLocation);

            if (SUCCEEDED(hr) && pIncoming->cBlocked)
                hr = ReportNotification(BINDSTATUS_COOKIE_STATE_REJECT, pIncoming->pszLocation);
               
            break;
        }

        default:
            TransAssert(FALSE);
            break;
    }
    
    DEBUG_LEAVE(hr);
    return hr;
}    
#define HRESULT_FROM_WININET(pv)     HRESULT_FROM_WIN32( (((LPINTERNET_ASYNC_RESULT) (pv) )->dwError) )

//+---------------------------------------------------------------------------
//
//  Method:     CINet::CINetCallback
//
//  Synopsis:
//
//  Arguments:  [hInternet] --
//              [dwContext] --
//              [dwStatus] --
//              [pvInfo] --
//              [dwStatusLen] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID CALLBACK CINet::CINetCallback(IN HINTERNET hInternet, IN DWORD_PTR dwContext,
                           IN DWORD dwStatus, IN LPVOID pvInfo, IN DWORD dwStatusLen)
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINet::CINetCallback",
                "%#x, %#x, %#x, %#x, %#x",
                hInternet, dwContext, dwStatus, pvInfo, dwStatusLen
                ));
                
    // If this is a request, then we know the cookie type
    CINet *pCINet = (CINet *) dwContext;
    HRESULT hrError = INET_E_OK;

    //
    // handle callback without a context
    if (!dwContext)
    {
        switch (dwStatus)
        {
        default:
            //PProtAssert((FALSE));
        break;

        case INTERNET_STATUS_STATE_CHANGE :
        {
            DWORD dwState = *(DWORD *) pvInfo;

            g_cInetState.SetState(dwState);
        }
        break;
        }   // end switch
    }
    else
    {
        PerfDbgLog2(tagCINet, pCINet, "+CINet::CINetCallback Status:%ld, State:%ld",
            dwStatus, pCINet->_INState);

        DWORD_PTR dwAsyncResult;

        // from here the original thread needs to be told of various things
        // such as errors, operation done etc.
        PProtAssert((pCINet));

        // guard this call - request might be aborted
        //pCINet->AddRef();

        DWORD dwFault;
#ifdef INET_CALLBACK_EXCEPTION
        _try
#endif // INET_CALLBACK_EXCEPTION
        {

            switch (dwStatus)
            {
            // the net connection state changed
            case INTERNET_STATUS_STATE_CHANGE :
            {
                DWORD dwState = *(DWORD *) pvInfo;
                pCINet->OnINetStateChange(dwState);
            }
            break;

            // callback to put up UI
            case INTERNET_STATUS_USER_INPUT_REQUIRED:
            {
                // guard this call - request might be aborted
                pCINet->PrivAddRef();

                PProtAssert(pCINet->_INState == INetState_SEND_REQUEST);
                //PProtAssert(!((LPINTERNET_ASYNC_RESULT)pvInfo)->dwResult);

                LPVOID lpvSendRequestResultData = (LPVOID) ((LPINTERNET_ASYNC_RESULT)pvInfo)->dwResult;
                DWORD dwSendRequestResult = ((LPINTERNET_ASYNC_RESULT) (pvInfo) )->dwError;

                // handle the error here in particular pass on info for zone crossing
                pCINet->OnINetSuspendSendRequest(dwSendRequestResult, lpvSendRequestResultData);

                // unguard - release
                pCINet->PrivRelease();
            }
            break;

            // request completed
            case INTERNET_STATUS_REQUEST_COMPLETE:
            {
                // guard this call - request might be aborted
                pCINet->PrivAddRef();
                if (pCINet->_INState != INetState_ERROR)
                {
                    PProtAssert((pCINet->GetStatePending() == E_PENDING));
                }

                switch (pCINet->_INState)
                {
                case INetState_OPEN_REQUEST:
                    // the internet session handle is supposed to be returned
                    dwAsyncResult = ((LPINTERNET_ASYNC_RESULT)pvInfo)->dwResult;
                    if (dwAsyncResult)
                    {
                        // got the internet session handle back
                        pCINet->OnINetAsyncOpen(dwAsyncResult);
                    }
                    else
                    {
                        hrError = pCINet->SetBindResult(((LPINTERNET_ASYNC_RESULT) (pvInfo))->dwError, INET_E_NO_SESSION);
                    }
                break;

                case INetState_CONNECT_REQUEST:
                    // the server handle is supposed to be returned
                    dwAsyncResult = ((LPINTERNET_ASYNC_RESULT)pvInfo)->dwResult;
                    if (dwAsyncResult)
                    {
                        pCINet->OnINetConnect(dwAsyncResult);
                    }
                    else
                    {
                        hrError = pCINet->SetBindResult(((LPINTERNET_ASYNC_RESULT) (pvInfo))->dwError,INET_E_CANNOT_CONNECT);
                    }
                break;

                case INetState_PROTOPEN_REQUEST:
                    // the request handle is suppost to be returned
                    dwAsyncResult = ((LPINTERNET_ASYNC_RESULT)pvInfo)->dwResult;
                    if (dwAsyncResult)
                    {
                        pCINet->OnINetOpenRequest(dwAsyncResult);
                    }
                    else
                    {
                        hrError = pCINet->SetBindResult(((LPINTERNET_ASYNC_RESULT) (pvInfo))->dwError,INET_E_OBJECT_NOT_FOUND);
                    }
                break;

                case INetState_SEND_REQUEST:
                {
                    // SendRequest returns a BOOL
                    dwAsyncResult = ((LPINTERNET_ASYNC_RESULT)pvInfo)->dwResult;
                    if (dwAsyncResult)
                    {
                        // pass on 0 and look up the status code with HttpQueryInfo
                        pCINet->OnINetSendRequest(0);
                    }
                    else
                    {
                        DWORD dwSendRequestResult = ((LPINTERNET_ASYNC_RESULT) (pvInfo) )->dwError;
                        // handle the error here in particular pass on info for zone crossing
                        if (dwSendRequestResult)
                        {
                            // handle the sendrequest result
                            // zone crossing
                            switch (dwSendRequestResult)
                            {
                            case ERROR_INTERNET_SEC_CERT_DATE_INVALID     :
                            case ERROR_INTERNET_SEC_CERT_CN_INVALID       :
                            case ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR    :
                            case ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR    :
                            case ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR   :
                            case ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION   :
                            case ERROR_INTERNET_INVALID_CA                :
                            case ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED   :
                            case ERROR_INTERNET_FORTEZZA_LOGIN_NEEDED     :
                            case ERROR_INTERNET_FORCE_RETRY               :
                            case ERROR_INTERNET_SEC_CERT_ERRORS           :
                            case ERROR_INTERNET_SEC_CERT_REV_FAILED       :
                            case ERROR_INTERNET_SEC_CERT_REVOKED          :
                            case ERROR_INTERNET_LOGIN_FAILURE_DISPLAY_ENTITY_BODY:

                                pCINet->OnINetSendRequest(dwSendRequestResult);
                            break;
                            default:
                                hrError = pCINet->SetBindResult(((LPINTERNET_ASYNC_RESULT) (pvInfo))->dwError);
                            break;
                            }
                        }
                        else
                        {
                            hrError = pCINet->SetBindResult(((LPINTERNET_ASYNC_RESULT) (pvInfo))->dwError);
                        }
                    }
                }
                break;

                case INetState_READ:
                    // InternetRead returns TRUE of FALSE
                    dwAsyncResult = ((LPINTERNET_ASYNC_RESULT)pvInfo)->dwResult;
                    if (dwAsyncResult)
                    {
                        pCINet->OnINetRead(dwAsyncResult);
                    }
                    else
                    {
                        hrError = pCINet->SetBindResult(((LPINTERNET_ASYNC_RESULT) (pvInfo))->dwError);
                    }
                break;

                case INetState_DATA_AVAILABLE:
                {
                    DWORD_PTR dwResult = ((LPINTERNET_ASYNC_RESULT)(pvInfo))->dwResult;

                    if (dwResult)
                    {
                        DWORD dwBytes = ((LPINTERNET_ASYNC_RESULT) (pvInfo) )->dwError;
                        pCINet->OnINetDataAvailable(dwBytes);
                    }
                    else
                    {
                        hrError = pCINet->SetBindResult(((LPINTERNET_ASYNC_RESULT) (pvInfo))->dwError);
                    }
                }
                break;

                case INetState_READ_DIRECT:
                {
                    pCINet->OnINetReadDirect(0);
                }
                break;

                case INetState_DATA_AVAILABLE_DIRECT:
                {
                    PProtAssert((FALSE));
                }
                break;

                default:
                break;
                }

                // unguard - release
                pCINet->PrivRelease();

            }
            break;

            case INTERNET_STATUS_RESOLVING_NAME          :
            {
                // get server name or proxy as string
                //pCINet->ReportNotification(Notify_FindingServer, (LPSTR) pvInfo);
                pCINet->ReportNotification(BINDSTATUS_FINDINGRESOURCE, (LPSTR) pvInfo);
            }
            break;

            case INTERNET_STATUS_DETECTING_PROXY         :
            {
                // indicate that auto-proxy detection is in progress
                pCINet->ReportNotification(BINDSTATUS_PROXYDETECTING, (LPSTR) NULL);
            }
            break;

            case INTERNET_STATUS_CONNECTING_TO_SERVER    :
            {
                // get ip address as string
                //pCINet->ReportNotification(Notify_Connecting, (LPSTR) pvInfo);
                pCINet->ReportNotification(BINDSTATUS_CONNECTING, (LPSTR) pvInfo);
            }
            break;

            case INTERNET_STATUS_SENDING_REQUEST         :
            {
                // no data passed back
                //pCINet->ReportNotification(Notify_SendingRequest);
                pCINet->ReportNotification(BINDSTATUS_SENDINGREQUEST);
            }
            break;

            case INTERNET_STATUS_REDIRECT                :
            {
                PerfDbgLog1(tagCINet, pCINet, "+CINet::CINetCallback Redirected by WinINet (szRedirectUrl:%s)", (LPSTR) pvInfo);

                // pvinfo contains the new url
                pCINet->OnRedirect((LPSTR) pvInfo);
            }
            break;

            case INTERNET_STATUS_HANDLE_CLOSING          :
            {
                if ((*(LPHINTERNET)pvInfo) == pCINet->_hServer)
                {
                    hrError = INET_E_OK;
                    PerfDbgLog1(tagCINet, pCINet, "=== CINet::CINetCallback (Close Service Handle:%lx)", (*(LPHINTERNET) pvInfo));
                    PProtAssert((pCINet->_HandleStateServer == HandleState_Closed));
                    // this is the connect handle - call Release
                    pCINet->_hServer = 0;
                    pCINet->PrivRelease(TRUE);

                }
                else if ((*(LPHINTERNET)pvInfo) == pCINet->_hRequest)
                {
                    hrError = INET_E_OK;
                    PerfDbgLog1(tagCINet, pCINet, "=== CINet::CINetCallback (Close Request Handle:%lx)", (*(LPHINTERNET) pvInfo));
                    PProtAssert(( pCINet->_HandleStateRequest == HandleState_Closed));
                    // this is the connect handle - call Release
                    pCINet->_hRequest = 0;
                    pCINet->ReleaseTransAndBindInfo();
                    pCINet->PrivRelease(TRUE);
                }

            }
            break;

            case INTERNET_STATUS_COOKIE_SENT:
            case INTERNET_STATUS_COOKIE_RECEIVED:
            case INTERNET_STATUS_COOKIE_HISTORY:
            case INTERNET_STATUS_PRIVACY_IMPACTED:
            case INTERNET_STATUS_P3P_HEADER:
            case INTERNET_STATUS_P3P_POLICYREF:
            {
                pCINet->OnCookieNotification(dwStatus, pvInfo);
            }
            break;
            
            case INTERNET_STATUS_HANDLE_CREATED          :
            case INTERNET_STATUS_NAME_RESOLVED           :
            case INTERNET_STATUS_CONNECTED_TO_SERVER     :
            case INTERNET_STATUS_REQUEST_SENT            :
            case INTERNET_STATUS_RECEIVING_RESPONSE      :
            case INTERNET_STATUS_RESPONSE_RECEIVED       :
            case INTERNET_STATUS_CTL_RESPONSE_RECEIVED   :
            case INTERNET_STATUS_PREFETCH                :
            case INTERNET_STATUS_CLOSING_CONNECTION      :
            case INTERNET_STATUS_CONNECTION_CLOSED       :

            default:
            {
                //handle other status here
            }

            } // end switch

            if (hrError != INET_E_OK)
            {
                PerfDbgLog2(tagCINet, pCINet, "=== CINet::CINetCallback _hrINet:%lx, ERROR: %lx",
                    pCINet->_hrINet, hrError);
                // we need to terminate here
                pCINet->ReportResultAndStop(pCINet->_hrINet);
            }
            // unguard - release
            //pCINet->Release();

        }
#ifdef INET_CALLBACK_EXCEPTION
        _except(UrlMonInvokeExceptionFilter(GetExceptionCode(), GetExceptionInformation()))
        {
            dwFault = GetExceptionCode();

            #if DBG == 1
            //
            // UrlMon catches exceptions when the client generates them. This is so we can
            // cleanup properly, and allow urlmon to continue.
            //
            if (   dwFault == STATUS_ACCESS_VIOLATION
                || dwFault == 0xC0000194 /*STATUS_POSSIBLE_DEADLOCK*/
                || dwFault == 0xC00000AA /*STATUS_INSTRUCTION_MISALIGNMENT*/
                || dwFault == 0x80000002 /*STATUS_DATATYPE_MISALIGNMENT*/ )
            {
                WCHAR iidName[256];
                iidName[0] = 0;
                char achProgname[256];
                achProgname[0] = 0;

                GetModuleFileNameA(NULL,achProgname,sizeof(achProgname));
                DbgLog2(tagCINetErr, NULL,
                               "NotificationMgr has caught a fault 0x%08x on behalf of application %s",
                               dwFault, achProgname);
                //TransAssert((!"The application has faulted processing. Check the kernel debugger for useful output.URLMon can continue but you probably want to stop and debug the application."));

            }
            #endif
        }
#ifdef unix
        __endexcept
#endif /* unix */
#endif INET_CALLBACK_EXCEPTION
    }

    PerfDbgLog1(tagCINet, pCINet, "-CINet::CINetCallback (hrError:%lx)", hrError);

    DEBUG_LEAVE(0);
}


//+---------------------------------------------------------------------------
//
//  Method:     CINet::TransitState
//
//  Synopsis:
//
//  Arguments:  [dwState] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CINet::TransitState(DWORD dwState, BOOL fAsync)
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINet::TransitState",
                "this=%#x, %#x, %B",
                this, dwState, fAsync
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::TransitState");

    if ((_dwState != INetState_DONE) && (_dwState != INetState_ERROR))
    {
        BINDSTATUS NMsg = (BINDSTATUS) ((fAsync) ? BINDSTATUS_INTERNALASYNC : BINDSTATUS_INTERNAL);
        DWORD dwFlags = 0;

        if (   NMsg == BINDSTATUS_INTERNALASYNC
            || NMsg == BINDSTATUS_ERROR
            || NMsg == BINDSTATUS_INTERNALASYNC)
        {
            dwFlags |= PI_FORCE_ASYNC;
        }
        if (   (dwState == INetState_AUTHENTICATE)
            || (dwState == INetState_DISPLAY_UI)
            || (_fForceSwitch))
        {
            dwFlags |= PD_FORCE_SWITCH;
        }


        if( _grfBindF & BINDF_FROMURLMON )
        {
            CStateInfo CSI = CStateInfo(NMsg, dwFlags, (LPVOID)(ULongToPtr((ULONG)dwState)));
            if( _pCTrans )
            {
                _pCTrans->Switch(&CSI);
            }
        }
        else
        {
            CStateInfo* pCSI = new CStateInfo(NMsg, dwFlags, (LPVOID)(ULongToPtr((ULONG)dwState)));
            if( !pCSI )
            {
                ReportResultAndStop(E_OUTOFMEMORY);
            }
            else
            {
                if( dwFlags & PD_FORCE_SWITCH || _fForceSwitch )
                {
                    if( _pCTrans )
                    {
                        _pCTrans->Switch(pCSI);
                    }
                }
                else
                {
                    Continue(pCSI);
                }
            }
        }
    }

    PerfDbgLog(tagCINet, this, "-CINet::TransitState");

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::OnINetInternal
//
//  Synopsis:
//
//  Arguments:  [dwState] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CINet::OnINetInternal(DWORD_PTR dwState)
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINet::OnINetInternal",
                "this=%#x, %#x",
                this, dwState
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::OnINetInternal");

    HRESULT hr = NOERROR;

    if ((_dwState != INetState_DONE) && (_dwState != INetState_ERROR))
    {
        switch (dwState)
        {
        case INetState_START           :
            // is requested
            hr = INetAsyncOpen();
            break;
        case INetState_OPEN_REQUEST    :
            hr = INetAsyncConnect();
            break;
        case INetState_CONNECT_REQUEST :
            hr = INetAsyncOpenRequest();
            break;
        case INetState_PROTOPEN_REQUEST:
            hr = INetAsyncSendRequest();
            break;
        case INetState_SEND_REQUEST    :
            if( _fSendRequestAgain )
            {
                _fCompleted = FALSE;
                _fSendAgain = TRUE;
                _fSendRequestAgain = FALSE;
                hr = INetAsyncSendRequest();
            }
            else
            {
                hr = INetQueryInfo();
            }
            break;
        case INetState_DISPLAY_UI      :
            hr = INetDisplayUI();
            break;
        case INetState_AUTHENTICATE    :
            hr = INetAuthenticate();
            break;
        case INetState_READ            :
            hr = INetRead();
            break;
        case INetState_READ_DIRECT     :
            hr = INetReadDirect();
            break;
        case INetState_DATA_AVAILABLE  :
            hr = INetReportAvailableData();
            break;
        case INetState_INETSTATE_CHANGE:
            hr = INetStateChange();
            break;
        case INetState_DONE            :
            break;
        default:
            break;
        }
    }
    /*
    else
    {
        PProtAssert((FALSE && "Unknown state"));
    }
    */

    if ((hr != NOERROR) && (hr != E_PENDING))
    {
        ReportResultAndStop(hr);
    }

    PerfDbgLog(tagCINet, this, "-CINet::OnINetInternal");

    DEBUG_LEAVE(0);
}


//+---------------------------------------------------------------------------
//
//  Method:     CINet::TerminateRequest
//
//  Synopsis:   Close the server and request handle - wininet will make a
//              callback on each handle closed
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CINet::TerminateRequest()
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINet::TerminateRequest",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::TerminateRequest");
    CLock lck(_mxs);    // only one thread should be in here

    if ((_HandleStateRequest == HandleState_Initialized))
    {
        PProtAssert((_hRequest));
        _HandleStateRequest = HandleState_Closed;
        InternetCloseHandle(_hRequest);
        //_hRequest = 0;
    }
    else if ((_HandleStateRequest == HandleState_Pending))
    {
        _HandleStateRequest = HandleState_Aborted;
    }

    if (_HandleStateServer == HandleState_Initialized)
    {
        PerfDbgLog1(tagCINet, this, "=== CINet::TerminateRequest InternetCloseHandle (hServer:%lx)", _hServer);
        _HandleStateServer = HandleState_Closed;

        if (_hServer)
        {
            // the handle can be NULL
            // in case we got aborted during the
            // pending open request
            InternetCloseHandle(_hServer);
        }
    }
    else if ((_HandleStateServer == HandleState_Pending))
    {
        _HandleStateServer = HandleState_Aborted;
    }

    PerfDbgLog(tagCINet, this, "-CINet::TerminateRequest");

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::FindTagInHeader
//
//  Synopsis:
//
//  Arguments:  [lpszBuffer] --
//              [lpszTag] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPSTR CINet::FindTagInHeader(LPCSTR lpszBuffer, LPCSTR lpszTag)
{
    DEBUG_ENTER((DBG_APP,
                String,
                "CINet::FindTagInHeader",
                "this=%#x, %.80q, %.80q",
                this, lpszBuffer, lpszTag
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::FindTagInHeader");
    LPCSTR p;
    int i, cbTagLen;

    cbTagLen = strlen(lpszTag);
    for (p = lpszBuffer; i = strlen(p); p += (i + 1))
    {
        if (!StrCmpNI(p, lpszTag, cbTagLen))
        {

            DEBUG_LEAVE((LPSTR)p);
            return (LPSTR)p;
        }
    }

    PerfDbgLog(tagCINet, this, "-CINet::FindTagInHeader");

    DEBUG_LEAVE(NULL);
    return NULL;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetDataAvailable
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetDataAvailable()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetDataAvailable",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetDataAvailable");

    HRESULT hr = NOERROR;
    BOOL fRet = FALSE;

    PProtAssert((GetStatePending() == NOERROR));
    SetINetState(INetState_DATA_AVAILABLE);

    if (!_fFilenameReported)
    {
        char szFilename[MAX_PATH];

        HRESULT hr1 = GetUrlCacheFilename(szFilename, MAX_PATH);

        if (hr1 == NOERROR && szFilename[0] != '\0' )
        {
            ReportNotification(BINDSTATUS_CACHEFILENAMEAVAILABLE, (LPSTR) szFilename);
            _fFilenameReported = TRUE;
        }
    }

    // check if all data were read of the current buffer
    SetStatePending(E_PENDING);

    fRet = InternetQueryDataAvailable(_hRequest, &_cbReadReturn, 0, 0);

    if (fRet == FALSE)
    {
        dwLstError = GetLastError();
        if (dwLstError == ERROR_IO_PENDING)
        {
            hr = E_PENDING;
        }
        else
        {
            SetStatePending(NOERROR);
            hr = _hrError = INET_E_DATA_NOT_AVAILABLE;
        }
    }
    else
    {
        SetByteCountReadyToRead(_cbReadReturn);
        SetStatePending(NOERROR);

        if (_cbReadReturn == 0)
        {
            // done
            _fDone = 1;
        }

        hr = INetReportAvailableData();
    }

    PerfDbgLog1(tagCINet, this, "-CINet::INetDataAvailable (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::OnINetDataAvailable
//
//  Synopsis:
//
//  Arguments:  [dwResult] --
//
//  Returns:
//
//  History:    2-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::OnINetDataAvailable( DWORD dwResult)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::OnINetDataAvailable",
                "this=%#x, %#x",
                this, dwResult
                ));
                
    PerfDbgLog1(tagCINet, this, "+CINet::OnINetDataAvailable (dwAvailable:%ld)", dwResult);
    HRESULT hr = NOERROR;

    PProtAssert((GetStatePending() == E_PENDING));

    SetByteCountReadyToRead(dwResult);

    if (dwResult == 0)
    {
        // done
        _fDone = 1;
    }

    // set state to normal - no pending transaction
    SetStatePending(NOERROR);

    // notification for next request
    TransitState(INetState_DATA_AVAILABLE);


    PerfDbgLog1(tagCINet, this, "-CINet::OnINetDataAvailable (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetReportAvailableData
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetReportAvailableData()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetReportAvailableData",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetReportAvailableData");
    HRESULT hr = NOERROR;
    DWORD dwError;
    ULONG cbBytesAvailable = 0;

    //BUGBUG: we hit this assertion sometimes.
    //PProtAssert((GetStatePending() == NOERROR));

    _hrError = INET_E_OK;

    if ((GetStatePending() == E_PENDING))
    {
        // nothing to do - data for this notfication
        // already received
    }
    else if ((cbBytesAvailable = GetByteCountReadyToRead()) != 0)
    {
        if (   _fDone
            || (   _cbTotalBytesRead
                  && _cbDataSize
                  && (_cbTotalBytesRead == _cbDataSize)))
        {

            _hrError = INET_E_DONE;
        }
        else
        {
            if(_cbDataSize && (_cbDataSize < (cbBytesAvailable + _cbTotalBytesRead)))
            {
                _cbDataSize = cbBytesAvailable + _cbTotalBytesRead;
            }

            if (_bscf & BSCF_DATAFULLYAVAILABLE)
            {
                _bscf |= BSCF_LASTDATANOTIFICATION;
                _bscf &= ~BSCF_FIRSTDATANOTIFICATION;
            }
            // BUG-WORK pCTrans migh be gone by now
            _cbSizeLastReportData = cbBytesAvailable + _cbTotalBytesRead;
            hr = _pEmbdFilter->ReportData(_bscf, cbBytesAvailable + _cbTotalBytesRead, _cbDataSize);

            if (_bscf & BSCF_FIRSTDATANOTIFICATION)
            {
                _bscf &= ~BSCF_FIRSTDATANOTIFICATION;
                _bscf |= BSCF_INTERMEDIATEDATANOTIFICATION;
            }
        }

    }
    else if (   _fDone
             || (   _cbTotalBytesRead
                 && _cbDataSize
                 && (_cbTotalBytesRead == _cbDataSize)))
    {
        if (_cbDataSize == 0)
        {
            _cbDataSize = _cbTotalBytesRead;
        }

        PerfDbgLog2(tagCINet, this, "=== CINet::INetReportAvailableData DONE! (cbTotalBytesRead:%ld, cbDataSize:%ld)", _cbTotalBytesRead, _cbDataSize);
        // now we should have all data
        PProtAssert(( (   ( _cbDataSize == 0)
                       || ((_cbDataSize != 0) && (_cbTotalBytesRead == _cbDataSize)))
                     && "Did not get all data!!"));


        _hrError = INET_E_DONE;
    }

    if (_hrError != INET_E_OK)
    {
        _bscf |= BSCF_LASTDATANOTIFICATION;
        if (_pCTrans )
        {
            _cbSizeLastReportData = _cbTotalBytesRead;
            hr = _pEmbdFilter->ReportData(_bscf, _cbTotalBytesRead, _cbDataSize);

        }
        hr = NOERROR;
    }

    PerfDbgLog2(tagCINet, this, "-CINet::INetReportAvailableData (_hrError:%lx, hr:%lx)", _hrError, hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINet::ReadDataHere
//
//  Synopsis:
//
//  Arguments:  [pBuffer] --
//              [cbBytes] --
//              [pcbBytes] --
//
//  Returns:
//
//  History:    2-13-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::ReadDataHere(BYTE *pBuffer, DWORD cbBytes, DWORD *pcbBytes)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::ReadDataHere",
                "this=%#x, pBuffer, cbBytes, pcbBytes",
                this, pBuffer, cbBytes, pcbBytes
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::ReadDataHere");
    HRESULT hr = NOERROR;
    DWORD dwError;

    *pcbBytes = 0;
    ULONG cbReadReturn = 0;
    ULONG dwReturned = 0;
    ULONG dwReturnedTotal = 0;
    ULONG dwBytesLeft = cbBytes;

    //BUGBUG: turn this assertion on again
    //PProtAssert((GetStatePending() == NOERROR));

    if (_hrError == INET_E_DONE)
    {
        // means end of file
        hr = S_FALSE;
    }
    else if (GetStatePending() != NOERROR)
    {
        hr = E_PENDING;
    }
    else
    {
        _hrError = INET_E_OK;
        do
        {
            if ((cbReadReturn = GetByteCountReadyToRead()) == 0)
            {
                BOOL fRet;

                PerfDbgLog(tagCINet, this, "CINet::ReadDataHere -> InternetQueryDataAvailable");
                PProtAssert((GetStatePending() == NOERROR));
                SetStatePending(E_PENDING);
                fRet = InternetQueryDataAvailable(_hRequest, &_cbReadReturn,0 ,0);

                if (fRet == FALSE)
                {
                    dwLstError = GetLastError();
                    if (dwLstError == ERROR_IO_PENDING)
                    {
                        hr = E_PENDING;
                    }
                    else
                    {
                        SetStatePending(NOERROR);
                        hr = _hrError = INET_E_DATA_NOT_AVAILABLE;
                    }
                }
                else
                {
                    SetByteCountReadyToRead(_cbReadReturn);
                    SetStatePending(NOERROR);
                    if (_cbReadReturn == 0)
                    {
                        // download completed - no more data available
                        hr = _hrError = INET_E_DONE;
                    }
                }

                PerfDbgLog2(tagCINet, this, "CINet::ReadDataHere == InternetQueryDataAvailable (fRet:%d, _cbReadReturn:%ld)", fRet, _cbReadReturn);
            }

            // in case of noerror read the bits
            if ((hr == NOERROR) && (_hrError == INET_E_OK))
            {
                cbReadReturn = GetByteCountReadyToRead();
                PProtAssert((GetStatePending() == NOERROR));

                // get the read buffer from the trans data object
                PProtAssert(((pBuffer != NULL) && (cbBytes > 0)));
                PProtAssert((cbReadReturn > 0));

                dwBytesLeft = cbBytes - dwReturnedTotal;
                if (dwBytesLeft > cbReadReturn)
                {
                    dwBytesLeft = cbReadReturn;
                }

                PProtAssert(( dwBytesLeft <= (cbBytes - dwReturnedTotal) ));

                dwReturned = 0;
                PerfDbgLog1(tagCINet, this, "CINet::ReadDataHere -> InternetReadFile (dwBytesLeft:%ld)", dwBytesLeft);
                if (!InternetReadFile(_hRequest, pBuffer + dwReturnedTotal, dwBytesLeft, &dwReturned))
                {
                    dwError = GetLastError();
                    if (dwError != ERROR_IO_PENDING)
                    {
                        hr = _hrError = INET_E_DOWNLOAD_FAILURE;
                        DbgLog3(tagCINetErr, this, "CINet::ReadDataHere failed: (dwError:%lx, hr:%lx, hrError:%lx)",
                                                    dwError, hr, _hrError);

                    }
                    else
                    {
                        // Note: BIG ERROR - we need to shut down now
                        // wininet is using the client buffer and the client is not
                        // aware that the buffer is used during the pending time
                        //
                        DbgLog(tagCINetErr, this, "CINet::ReadDataHere - InternetReadFile returned E_PENDING!!!");
                        PProtAssert((FALSE &&  "CINet::ReadDataHere - InternetReadFile returned E_PENDING!!!"));

                        hr = _hrError = INET_E_DOWNLOAD_FAILURE;
                    }

                    PerfDbgLog1(tagCINet, this, "CINet::ReadDataHere == InternetReadFile (dwError:%lx)", dwError);

                }
                else
                {
                    PerfDbgLog3(tagCINet, this, "CINet::ReadDataHere == InternetReadFile ==> (cbBytes:%ld, dwReturned:%ld,_cbReadReturn:%ld)",
                        cbBytes, dwReturned,_cbReadReturn);

                    PProtAssert((  (cbBytes + dwReturnedTotal) >= dwReturned ));

                    if (dwReturned == 0)
                    {
                        hr = _hrError = INET_E_DONE;
                    }
                    else
                    {
                        hr = NOERROR;
                    }

                    dwReturnedTotal += dwReturned;
                    cbReadReturn -= dwReturned;
                    SetByteCountReadyToRead(-(LONG)dwReturned);
                    _cbTotalBytesRead += dwReturned;
                }
            }  // read case - bits available

            PerfDbgLog4(tagCINet, this, "CINet::ReadDataHere ooo InternetReadFile ==>(cbBytes:%ld, dwReturned:%ld,cbReadReturn:%ld,dwReturnedTotal:%ld)",
                cbBytes, dwReturned,cbReadReturn,dwReturnedTotal);

        } while ((hr == NOERROR) && (dwReturnedTotal < cbBytes));

        PProtAssert((dwReturnedTotal <= cbBytes));
        *pcbBytes = dwReturnedTotal;

        if (hr == INET_E_DONE)
        {
            hr = (dwReturnedTotal) ? S_OK : S_FALSE;
        }
    }

    // Note: stop the download in case of DONE or ERROR!
    if (_hrError != INET_E_OK)
    {
        ReportResultAndStop((hr == S_FALSE) ? NOERROR : hr,  _cbTotalBytesRead, _cbDataSize);
    }

    PerfDbgLog4(tagCINet, this, "-CINet::ReadDataHere (_hrError:%lx, [hr:%lx,cbBytesAsked:%ld,cbBytesReturned:%ld])",
        _hrError, hr, cbBytes, *pcbBytes);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINet::OperationOnAparmentThread
//
//  Synopsis:
//
//  Arguments:  [dwState] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CINet::OperationOnAparmentThread(DWORD dwState)
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "CINet::OperationOnAparmentThread",
                "this=%#x, %#x",
                this, dwState
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::OperationOnAparmentThread");
    BOOL fRet = FALSE;
    switch (dwState)
    {
    case INetState_OPEN_REQUEST:
        break;
    case INetState_CONNECT_REQUEST:
        break;
    case INetState_PROTOPEN_REQUEST:
        break;
    case INetState_SEND_REQUEST:
        break;
    case INetState_READ:
    case INetState_READ_DIRECT:
        fRet = TRUE;
        break;
    default:
        fRet = TRUE;
        break;
    }
    //return fRet;

    PerfDbgLog(tagCINet, this, "-CINet::OperationOnAparmentThread");

    DEBUG_LEAVE(TRUE);
    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::OperationOnAparmentThread
//
//  Synopsis:
//
//  Returns:
//
//  History:    10-27-98   DanpoZ (Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CINet::UTF8Enabled()
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "CINet::UTF8Enabled",
                "this=%#x",
                this
                ));
                
    BOOL bRet = FALSE;
    // do not enable utf8 on file or ftp protocol
    if( _dwIsA == DLD_PROTOCOL_FILE ||
        _dwIsA == DLD_PROTOCOL_FTP  )
    {
        goto exit;
    }

    // default to per-machine utf-8 setting
    bRet = g_bGlobalUTF8Enabled;

    // per-binding flag
    if( _BndInfo.dwOptions & BINDINFO_OPTIONS_ENABLE_UTF8)
    {
        bRet = TRUE;
    }

    if( _BndInfo.dwOptions & BINDINFO_OPTIONS_DISABLE_UTF8)
    {
        bRet = FALSE;
    }

    if( _BndInfo.dwOptions & BINDINFO_OPTIONS_USE_IE_ENCODING)
    {
        DWORD dwIE;
        DWORD dwOutLen = sizeof(DWORD);
        HRESULT hr = UrlMkGetSessionOption(
            URLMON_OPTION_URL_ENCODING,
            &dwIE,
            sizeof(DWORD),
            &dwOutLen,
            NULL );

        if( hr == NOERROR )
        {
            if( dwIE == URL_ENCODING_ENABLE_UTF8 )
            {
                bRet = TRUE;
            }
            else if( dwIE == URL_ENCODING_DISABLE_UTF8 )
            {
                bRet = FALSE;
            }
        }
    }

exit:

    DEBUG_LEAVE(bRet);
    return bRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::QueryInfoOnResponse
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::QueryInfoOnResponse()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::QueryInfoOnResponse",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::QueryInfoOnResponse");
    HRESULT hr = NOERROR;

    DWORD dwFlags;
    DWORD cbLen = sizeof(dwFlags);

    // See if it is from the cache
    if (InternetQueryOption(_hRequest, INTERNET_OPTION_REQUEST_FLAGS, &dwFlags, &cbLen))
    {
        if (dwFlags & INTERNET_REQFLAG_FROM_CACHE)
        {
            _dwCacheFlags |= INTERNET_REQFLAG_FROM_CACHE;
            // set flag that data are from cache
            _bscf |= BSCF_DATAFULLYAVAILABLE;
        }
    }

    hr =  QueryStatusOnResponse();
    if (hr == NOERROR)
    {
        hr = QueryHeaderOnResponse();
    }

    if (_hrError != INET_E_OK)
    {
        SetINetState(INetState_DONE);
    }

    PerfDbgLog1(tagCINet, this, "-CINet::QueryInfoOnResponse (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::QueryStatusOnResponse
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::QueryStatusOnResponse()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::QueryStatusOnResponse",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::QueryStatusOnResponse");

    PProtAssert((FALSE));

    PerfDbgLog1(tagCINet, this, "-CINet::QueryStatusOnResponse hr:%lx", E_FAIL);

    DEBUG_LEAVE(E_FAIL);
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::QueryStatusOnResponseDefault
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::QueryStatusOnResponseDefault(DWORD dwStat)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::QueryStatusOnResponseDefault",
                "this=%#x, %#x",
                this, dwStat
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::QueryStatusOnResponseDefault");

    PProtAssert((FALSE));

    PerfDbgLog1(tagCINet, this, "-CINet::QueryStatusOnResponseDefault hr:%lx", E_FAIL);

    DEBUG_LEAVE(E_FAIL);
    return E_FAIL;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINet::QueryHeaderOnResponse
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::QueryHeaderOnResponse()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::QueryHeaderOnResponse",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::QueryHeaderOnResponse");

    PProtAssert((FALSE));

    PerfDbgLog1(tagCINet, this, "-CINet::QueryHeaderOnResponse hr:%lx", E_FAIL);

    DEBUG_LEAVE(E_FAIL);
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::RedirectRequest
//
//  Synopsis:
//
//  Arguments:  [lpszBuffer] --
//              [pdwBuffSize] --
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::RedirectRequest(LPSTR lpszBuffer, DWORD *pdwBuffSize, DWORD dwStatus)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::RedirectRequest",
                "this=%#x, %#x, %#x, %d",
                this, lpszBuffer, pdwBuffSize, dwStatus
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::RedirectRequest");

    PProtAssert((FALSE));

    PerfDbgLog1(tagCINet, this, "-CINet::RedirectRequest(fRet:%ld)", FALSE);

    DEBUG_LEAVE(E_FAIL);
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::AuthenticationRequest
//
//  Synopsis:
//
//  Arguments:  [lpszBuffer] --
//              [pdwBuffSize] --
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::AuthenticationRequest()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::AuthenticationRequest",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::AuthenticationRequest");
    HRESULT hr = NOERROR;
    DWORD dwError;

    LPWSTR pwzUsername = NULL;
    LPWSTR pwzPassword = NULL;

    DWORD  dwBindF = GetBindFlags();


    PerfDbgLog2(tagCINet, this, "<1> _cbProxyAuthenticate:%d _cbAuthenticate:%d",
               _cbProxyAuthenticate, _cbAuthenticate);
    if (_fProxyAuth ?  (_cbProxyAuthenticate >= AUTHENTICATE_MAX):(_cbAuthenticate >= AUTHENTICATE_MAX))
    {
        // NOTE: set the error to noerror and
        // continue reading data and show the 401 contained
        _hrINet = hr = NOERROR;
    }
    else
    {
        if (_hwndAuth == NULL)
        {
            IAuthenticate *pPInfo;
            DbgLog(tagCINetErr, this, "+CINet::AuthenticationRequest: QS for IAuthenticate");
            hr = QueryService(IID_IAuthenticate, (void **)&pPInfo);
            if (hr == NOERROR)
            {
                PProtAssert((pPInfo));
                hr = pPInfo->Authenticate(&_hwndAuth, &pwzUsername, &pwzPassword);
                pPInfo->Release();
            }
        }

        if (hr == NOERROR)
        {
            _hrINet = hr = E_ACCESSDENIED;

            if (pwzUsername && pwzPassword)
            {
                // set the username and password
                // and retry sendrequest

                LPSTR pszUsername = DupW2A(pwzUsername);
                LPSTR pszPassword = DupW2A(pwzPassword);

                if (pszUsername)
                {
                    InternetSetOption(_hRequest, INTERNET_OPTION_USERNAME, pszUsername, strlen(pszUsername)+1);
                    delete pszUsername;
                }
                if (pszPassword)
                {
                    InternetSetOption(_hRequest, INTERNET_OPTION_PASSWORD, pszPassword, strlen(pszPassword)+1);
                    delete pszPassword;
                }

                // if we got username & pwd, only try once
                _fProxyAuth ?  _cbProxyAuthenticate = AUTHENTICATE_MAX :
                                _cbAuthenticate = AUTHENTICATE_MAX;
                _hrINet = hr = RPC_E_RETRY;
                PerfDbgLog2(tagCINet, this, "<2> _cbProxyAuthenticate:%d _cbAuthenticate:%d",
                       _cbProxyAuthenticate, _cbAuthenticate);
        }

            if (   (_hwndAuth || (_hwndAuth == (HWND)-1) )
                && (_pCAuthData == NULL)
                && (hr != RPC_E_RETRY) )

            {
                PProtAssert((_pCAuthData == NULL));
                _pCAuthData = new CAuthData(this);
            }

            if (   (_hwndAuth || (_hwndAuth == (HWND)-1) )
                && _pCAuthData
                && (hr != RPC_E_RETRY) )
            {
                BOOL fRetry = FALSE;
                BOOL fDeleteAuthData = TRUE;
                DWORD dwFlags = (  FLAGS_ERROR_UI_FILTER_FOR_ERRORS | FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS
                                 | FLAGS_ERROR_UI_FLAGS_GENERATE_DATA | FLAGS_ERROR_UI_SERIALIZE_DIALOGS);

                if ((dwBindF & BINDF_NO_UI) || (dwBindF & BINDF_SILENTOPERATION))
                {
                    dwFlags |= FLAGS_ERROR_UI_FLAGS_NO_UI;
                }

                if (_hwndAuth == (HWND)-1)
                {
                    _hwndAuth = 0;
                }

                do
                {
                    _fProxyAuth ? _cbProxyAuthenticate++ : _cbAuthenticate++;
                    PerfDbgLog2(tagCINet, this, "<3> _cbProxyAuthenticate:%d _cbAuthenticate:%d",
                               _cbProxyAuthenticate, _cbAuthenticate);

                    dwError = InternetErrorDlg(_hwndAuth,_hRequest,ERROR_SUCCESS,dwFlags,(LPVOID *)&_pCAuthData);

                    switch (dwError)
                    {
                    case ERROR_CANCELLED :
                        // wininet should never return cancelled here
                        PProtAssert((FALSE));
                    case ERROR_SUCCESS  :
                        // NOTE: succes and cancel means display the content according to ArthurBi
                        // continue reading data and show the 401 contained
                        _hrINet = hr = NOERROR;
                        break;

                    case ERROR_INTERNET_FORCE_RETRY :
                        _hrINet = hr = RPC_E_RETRY;
                        break;

                    case ERROR_INTERNET_DIALOG_PENDING :
                        // a dialog is up on another thread
                        // start wating on the callback
                        SetINetState(INetState_AUTHENTICATE);
                        SetStatePending(E_PENDING);
                        _fProxyAuth ? _cbProxyAuthenticate-- : _cbAuthenticate--;
                        PerfDbgLog2(tagCINet, this, "<4> _cbProxyAuthenticate:%d _cbAuthenticate:%d",
                                   _cbProxyAuthenticate, _cbAuthenticate);
                        fDeleteAuthData = FALSE;
                        _hrINet = hr = E_PENDING;
                        break;

                    case ERROR_INTERNET_RETRY_DIALOG:
                        _fProxyAuth ? _cbProxyAuthenticate-- : _cbAuthenticate--;
                        PerfDbgLog2(tagCINet, this, "<5> _cbProxyAuthenticate:%d _cbAuthenticate:%d",
                                   _cbProxyAuthenticate, _cbAuthenticate);
                        fRetry = TRUE;
                        break;

                    default:
                        _hrINet = hr = E_ACCESSDENIED;
                        break;
                    }

                } while (fRetry);

                if (fDeleteAuthData)
                {
                    delete _pCAuthData;
                    _pCAuthData = NULL;
                }

            }
        }
        else
        {
            _hrINet = hr = E_ACCESSDENIED;
        }

        if (hr == RPC_E_RETRY)
        {
            _hrINet = NOERROR;
            _fCompleted = FALSE;
            _fSendAgain = TRUE;
            if (IsA() == DLD_PROTOCOL_FTP || IsA() == DLD_PROTOCOL_GOPHER)
            {
                // Retry InternetOpenUrl using the updated auth info.
                _fDoSimpleRetry = TRUE;
                hr = INetAsyncOpenRequest();
            }
            else
            {
                hr = INetAsyncSendRequest();
            }
        }
        else if (hr == E_PENDING)
        {
            // do nothing and wait for async completion
        }
        else if (   (hr != HRESULT_FROM_WIN32(ERROR_CANCELLED))
                 && (hr != NOERROR))
        {
            // set the error to access denied
            _hrINet = hr = E_ACCESSDENIED;
        }
    }

    if (pwzUsername)
    {
        delete pwzUsername;
    }
    if (pwzPassword)
    {
        delete pwzPassword;
    }

    PerfDbgLog1(tagCINet, this, "-CINet::AuthenticationRequest(hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::GetUrlCacheFilename
//
//  Synopsis:
//
//  Arguments:  [szFilename] --
//              [dwSize] --
//
//  Returns:
//
//  History:    2-28-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::GetUrlCacheFilename(LPSTR szFilename, DWORD dwSize)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::GetUrlCacheFilename",
                "this=%#x, %#x, %#x",
                this, szFilename, dwSize
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::GetUrlCacheFilename");
    HRESULT hr = NOERROR;
    BOOL fRet = FALSE;
    DWORD dwSizeLocal = dwSize;
    DWORD dwError = 0;

    if (dwSize)
    {
        szFilename[0] = '\0';
    }

    if (   !(GetBindFlags() & BINDF_NOWRITECACHE)
        ||  (GetBindFlags() & BINDF_NEEDFILE))
    {
        fRet = InternetQueryOption(_hRequest, INTERNET_OPTION_DATAFILE_NAME, szFilename, &dwSizeLocal);

        if (!fRet && (GetBindFlags() & BINDF_NEEDFILE))
        {
            dwError = GetLastError();
            hr = INET_E_DATA_NOT_AVAILABLE;
            SetBindResult(dwError, hr);
            if (dwSize)
            {
                szFilename[0] = '\0';
            }
        }
    }

    PerfDbgLog3(tagCINet, this, "-CINet::GetUrlCacheFilename (hr:%lx,fRet%d; szFilename:%s)", hr, fRet, szFilename);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::LockFile
//
//  Synopsis:
//
//  Arguments:  [szFilename] --
//              [dwSize] --
//
//  Returns:
//
//  History:    8-13-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::LockFile(BOOL fRetrieve)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::LockFile",
                "this=%#x, %B",
                this, fRetrieve
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::LockFile");
    HRESULT hr = NOERROR;
    BOOL fRet = FALSE;

    if (fRetrieve)
    {
        DWORD dwCacheEntryInfoBufferSize = MAX_URL_SIZE + MAX_PATH + sizeof(INTERNET_CACHE_ENTRY_INFO) + 2;
        INTERNET_CACHE_ENTRY_INFO *pCacheEntryInfo = (INTERNET_CACHE_ENTRY_INFO *)new CHAR [dwCacheEntryInfoBufferSize];
        DWORD dwError = 0;
        if (   (_fLocked == FALSE)
            && (pCacheEntryInfo != NULL)
            && (RetrieveUrlCacheEntryFileA( _pszFullURL, pCacheEntryInfo, &dwCacheEntryInfoBufferSize, 0)))
        {
            _fLocked = TRUE;
        }

        if (pCacheEntryInfo != NULL)
        {
            delete pCacheEntryInfo;
        }
    }
    else if ((_hLockHandle == NULL) && _hRequest)
    {
        if (InternetLockRequestFile(_hRequest, &_hLockHandle))
        {
            PProtAssert((_hLockHandle));
        }
    }

    PerfDbgLog2(tagCINet, this, "-CINet::LockFile (hr:%lx,fRet%d)", hr, fRet);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::UnlockFile
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    8-13-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::UnlockFile()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::UnlockFile",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "IN CINet::UnlockFile");
    HRESULT hr = NOERROR;

    if (_fLocked)
    {
        UnlockUrlCacheEntryFileA(_pszFullURL, 0);
        _fLocked = FALSE;
    }
    else if (_hLockHandle)
    {
        if (InternetUnlockRequestFile(_hLockHandle))
        {
            _hLockHandle = NULL;
        }
    }

    PerfDbgLog1(tagCINet, this, "-CINet::UnlockFile (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::HResultFromInternetError
//
//  Synopsis:   maps the dwStatus ERROR_INTERNET_XXX do an hresult
//
//  Arguments:  [dwStatus] --
//
//  Returns:
//
//  History:    3-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::HResultFromInternetError(DWORD dwStatus)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::HResultFromInternetError",
                "this=%#x, %#x",
                this, dwStatus
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::HResultFromInternetError");
    // dwResult is out of our know table
    HRESULT hr = INET_E_DOWNLOAD_FAILURE;
    ULONG   ulIndex = dwStatus - INTERNET_ERROR_BASE;

    PProtAssert((ulIndex > 0));
    BOOL fTable1 = (ulIndex > 0 && ulIndex < sizeof(INetError)/sizeof(InterErrorToHResult));
    DWORD dwTable2Size = sizeof(INetErrorExtended)/sizeof(InterErrorToHResult);
    BOOL fTable2 = FALSE;

    if (!fTable1)
    {
        fTable2 = (dwStatus <= INetErrorExtended[dwTable2Size].dwError);
    }
    if (fTable1)
    {
        // sequential table
        hr = INetError[ulIndex].hresult;
    }
    else if (fTable2)
    {
        // walk the table
        for (DWORD i = 0; i < dwTable2Size; i++)
        {
            if (INetErrorExtended[i].dwError == dwStatus)
            {
                hr = INetErrorExtended[i].hresult;
                break;
            }
        }
    }

    PerfDbgLog1(tagCINet, this, "-CINet::HResultFromInternetError (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Function:   SetBindResult
//
//  Synopsis:
//
//  Arguments:  [dwResult] --
//
//  Returns:
//
//  History:    5-10-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::SetBindResult(DWORD dwResult, HRESULT hrSuggested)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::SetBindResult",
                "this=%#x, %#x, %#x",
                this, dwResult, hrSuggested
                ));
                
    PerfDbgLog2(tagCINet, this, "+CINet::SetBindResult(dwResult:%ld, hrSuggested:%lx)", dwResult, hrSuggested);
    HRESULT hr = NOERROR;

    PProtAssert((_pszResult == NULL));
    _pszResult = NULL;
    _dwResult = dwResult;

    // only find hresult in the mapping table
    // if no erro was suggested
    if (hrSuggested == NOERROR)
    {
        hr = _hrINet = HResultFromInternetError(_dwResult);
    }
    else
    {
         hr = _hrINet = hrSuggested;
    }

    PerfDbgLog3(tagCINet, this, "-CINet::SetBindResult (dwResult:%ld, _hrINet:%lx,  hr:%lx)", dwResult, _hrINet, hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::GetBindResult
//
//  Synopsis:   returns the protocol specific error
//
//  Arguments:  [pclsidProtocol] --
//              [pdwResult] --
//              [DWORD] --
//              [pdwReserved] --
//
//  Returns:
//
//  History:    4-16-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::GetBindResult(CLSID *pclsidProtocol, DWORD *pdwResult, LPWSTR *pszResult, DWORD *pdwReserved)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::GetBindResult",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, pclsidProtocol, pdwResult, pszResult, pdwReserved
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::GetBindResult");
    HRESULT hr = NOERROR;

    PProtAssert((pclsidProtocol && pdwResult && pszResult));

    *pclsidProtocol = _pclsidProtocol;
    *pdwResult = _dwResult;
    if (_pszResult)
    {
        // the client is supposted to free the string
        *pszResult = new WCHAR [strlen(_pszResult) + 1];
        if (*pszResult)
        {
            A2W(_pszResult, *pszResult, strlen(_pszResult));
        }
    }
    else
    {
        *pszResult = NULL;
    }

    PerfDbgLog2(tagCINet, this, "-CINet::GetBindResult (dwResult:%lx, szStr:%ws)", _dwResult, pszResult);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::OnRedirected
//
//  Synopsis:   Called on wininet worker thread when wininet does a redirect.
//              Sends notification to apartment thread.
//
//  Arguments:  [szNewUrl] --
//
//  Returns:
//
//  History:    4-17-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::OnRedirect(LPSTR szNewUrl)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::OnRedirect",
                "this=%#x, %.80q",
                this, szNewUrl
                ));
                
    PerfDbgLog1(tagCINet, this, "+CINet::OnRedirect (szNewUrl:%s)",szNewUrl);
    HRESULT hr = NOERROR;

    PProtAssert((szNewUrl && "WinINet reports redirect with redirect URL"));

    if (szNewUrl)
    {
        _fRedirected = TRUE;
        ReportNotification(BINDSTATUS_REDIRECTING, szNewUrl);
    }

    LONG lThirdParty;
    if (IsThirdPartyUrl(szNewUrl))
    {
        lThirdParty = 1;
        //MessageBoxA( 0, szNewUrl, "redirect: THIRDPARTY!", 0 );
        InternetSetOption(_hRequest, INTERNET_OPTION_COOKIES_3RD_PARTY, &lThirdParty, sizeof(LONG));
    }
    else
    {
        lThirdParty = 0;
        //MessageBoxA( 0, szNewUrl, "redirect: NOT THIRDPARTY!", 0 );
        InternetSetOption(_hRequest, INTERNET_OPTION_COOKIES_3RD_PARTY, &lThirdParty, sizeof(LONG));
    }
    
    PerfDbgLog1(tagCINet, this, "-CINet::OnRedirect(hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   AppendToString
//
//  Synopsis:   Fast append of src to dest, reallocing of dest if necessary.
//
//
//  Arguments:  [IN/OUT] pszDest
//              [IN/OUT] pcbDest
//              [IN/OUT] pcbAlloced
//              [IN]     szSrc
//              [IN]     cbSrc
//
//  Returns:    TRUE/FALSE
//
//  History:    6-2-97   Adriaan Canter (AdriaanC)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL AppendToString(LPSTR* pszDest, LPDWORD pcbDest,
                    LPDWORD pcbAlloced, LPSTR szSrc, DWORD cbSrc)
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "AppendToString",
                "%#x, %#x, %#x, %.80q, %#x",
                pszDest, pcbDest, pcbAlloced, szSrc, cbSrc
                ));
                
    DWORD cbNew = *pcbDest + cbSrc;

    if (cbNew > *pcbAlloced)
    {
        DWORD cbNewAlloc  = *pcbAlloced + (cbSrc < MAX_PATH ? MAX_PATH : cbSrc);
        LPSTR szNew = (LPSTR) new CHAR[cbNewAlloc];
        if (!szNew)
        {

            DEBUG_LEAVE(FALSE);
            return FALSE;
        }
        memcpy(szNew, *pszDest, *pcbDest);
        delete [] *pszDest;
        *pszDest = szNew;
        *pcbAlloced = cbNewAlloc;
    }

     memcpy(*pszDest + *pcbDest, szSrc, cbSrc);
    *pcbDest = cbNew;

    DEBUG_LEAVE(TRUE);
    return TRUE;
}

#ifdef unix
#include <sys/utsname.h>
#endif /* unix */
//+---------------------------------------------------------------------------
//
//  Function:   GetUserAgentString
//
//  Synopsis:   Gets the user agent string from the registry. If entry is
//              the default string is returned.
//
//  Arguments:  (none)
//
//  Returns:    Allocated user agent string.
//
//  History:    5-13-96   JohannP (Johann Posch)   Created
//              6-02-97   AdriaanC (Adriaan Canter) Mods for mult reg entries.
//
//              6-25-97   AdriaanC (Adriaan Canter) Further mods described below.
//
//              12-18-98  Adriaanc (Adriaan Canter) - Versioned base values for
//                        IE5 and added a versioned IE5 location for token values
//                        which will get read in addition to common (IE4) location.
//
//  Notes:      User Agent string madness: We now generate the User Agent string
//              from diverse entries in the registry. We first scan HKCU for base
//              keys, falling back to HKLM if not found, or finally, defaults.
//              For Pre and Post platform we now pickup all entries in both HKCU
//              and HKLM. Finally, for back compatibility we enumerate a list of
//              tokens (such as MSN 2.0, MSN 2.1, etc) from UA Tokens in the HKLM
//              registry under Internet Settings, and if any of these tokens are
//              found in the *old* HKCU location User Agent String we insert them
//              into the pre platform portion of the generated user agent string.
//              This was specifically done for MSN which has been fixing up the old
//              registry location and depends on these tokens being found in the
//              User Agent string.
//
//----------------------------------------------------------------------------
LPCSTR GetUserAgentString()
{
    DEBUG_ENTER((DBG_APP,
                String,
                "GetUserAgentString",
                NULL
                ));
                
    // Reg keys.
    #define INTERNET_SETTINGS_KEY_SZ  "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"
    #define USER_AGENT_KEY_SZ         "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\User Agent"
    #define USER_AGENT_KEY5_SZ        "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\5.0\\User Agent"
    #define USER_AGENT_SZ             "User Agent"
    #define PRE_PLATFORM_KEY_SZ       "Pre Platform"
    #define POST_PLATFORM_KEY_SZ      "Post Platform"
    #define UA_TOKENS_KEY_SZ          "UA Tokens"

    // Base UA key strings.
    #define UA_KEY_SZ NULL
    #define COMPATIBLE_KEY_SZ   "Compatible"
    #define VERSION_KEY_SZ      "Version"
    #define PLATFORM_KEY_SZ     "Platform"

    // Base UA value strings.
    #define UA_VAL_SZ           "Mozilla/4.0"
    #define COMPATIBLE_VAL_SZ   "compatible"
    #define VERSION_VAL_SZ      "MSIE 6.0"

    // Their lengths.
    #define UA_VAL_LEN           (sizeof(UA_VAL_SZ) - 1)
    #define COMPATIBLE_VAL_LEN   (sizeof(COMPATIBLE_VAL_SZ) - 1)
    #define VERSION_VAL_LEN      (sizeof(VERSION_VAL_SZ) - 1)


    // If we encounter a failure in constructing the string, send this.
    #ifdef _WIN64
    #define DEFAULT_UA_STRING UA_VAL_SZ" ("COMPATIBLE_VAL_SZ"; "VERSION_VAL_SZ"; Win64)"
    #else
    #define DEFAULT_UA_STRING UA_VAL_SZ" ("COMPATIBLE_VAL_SZ"; "VERSION_VAL_SZ")"
    #endif

    // Used for backing up user agent string.
    #define IE4_UA_BACKUP_FLAG     "IE5_UA_Backup_Flag"
    #define BACKUP_USER_AGENT_SZ    "BackupUserAgent"

    #define COMPAT_MODE_TOKEN      "compat"
    #define NUM_UA_KEYS            4

    BOOL bSuccess = TRUE;
    INT i, nBaseKeys;
    DWORD dwIndex, dwType, cbBuf, cbUA, cbTotal;
    LPSTR szUA, szBuf, pszWinVer;
    OSVERSIONINFO osVersionInfo;

    // Reg handles.
    HKEY hHKCU_ISKey;
    HKEY hHKCU_UAKey;
    HKEY hHKLM_UAKey;
    HKEY hHKCU_UA5Key;
    HKEY hHKLM_UA5Key;
    HKEY hPreKey;
    HKEY hPostKey;
    HKEY hTokensKey;

    // Set all regkeys to invalid handle.
    hHKCU_ISKey = hHKLM_UAKey = hHKCU_UAKey = hHKLM_UA5Key = hHKCU_UA5Key
        = hPreKey = hPostKey = hTokensKey = (HKEY) INVALID_HANDLE_VALUE;

    // The UA keys are iterated in loops below; Keep an array
    // of pointers to the HKLMUA, HKCUUA, HKLMUA5 and HKCUUA5 locations
    // to use as alias in the loop. NOTE!! - Do not change the ordering.
    HKEY *phUAKeyArray[NUM_UA_KEYS];
    phUAKeyArray[0] = &hHKLM_UAKey;
    phUAKeyArray[1] = &hHKCU_UAKey;
    phUAKeyArray[2] = &hHKLM_UA5Key;
    phUAKeyArray[3] = &hHKCU_UA5Key;

    // Platform strings.
    LPSTR szWin32 = "Win32";
    LPSTR szWin95 = "Windows 95";
    LPSTR szWin98 = "Windows 98";
    LPSTR szMillennium = "Windows 98; Win 9x 4.90";
    LPSTR szWinNT = "Windows NT";
    //for WinNT appended with version numbers
    //Note: Limitation on total# of digits in Major+Minor versions=8.
    //length = sizeof("Windows NT"+" "+majorverstring+"."+minorverstring
    //Additional allowance is made for Win64 token. 
    #define WINNT_VERSION_STRING_MAX_LEN     32

    char szWinNTVer[WINNT_VERSION_STRING_MAX_LEN];

#ifdef unix
    CHAR szUnixPlatformName[SYS_NMLN*4+3+1]; // 4 substrings,3 spaces, 1 NULL
#endif /* unix */

    // Arrays of base keys, values and lengths.
    LPSTR szBaseKeys[] =   {UA_KEY_SZ,  COMPATIBLE_KEY_SZ,  VERSION_KEY_SZ};
    LPSTR szBaseValues[] = {UA_VAL_SZ,  COMPATIBLE_VAL_SZ,  VERSION_VAL_SZ};
    DWORD cbBaseValues[] = {UA_VAL_LEN, COMPATIBLE_VAL_LEN, VERSION_VAL_LEN};

    nBaseKeys = sizeof(szBaseKeys) / sizeof(LPSTR);

    cbUA = 0;
    cbTotal = cbBuf = MAX_PATH;
    szBuf = szUA = 0;

    // User agent string already exists.
    if (g_pszUserAgentString != NULL)
    {
        szUA = g_pszUserAgentString;
        goto End;
    }

    // Max size for any one field from registry is MAX_PATH.
    szUA = new CHAR[MAX_PATH];
    szBuf = new CHAR[MAX_PATH];
    if (!szUA || !szBuf)
    {
        bSuccess = FALSE;
        goto End;
    }

    // Open all 4 User Agent reg keys (HKLMUA, HKCUUA, HKLMUA5, HKCUUA5).
    if (RegOpenKeyEx(HKEY_CURRENT_USER, USER_AGENT_KEY_SZ, 0, KEY_QUERY_VALUE, &hHKCU_UAKey) != ERROR_SUCCESS)
        hHKCU_UAKey = (HKEY)INVALID_HANDLE_VALUE;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, USER_AGENT_KEY_SZ, 0, KEY_QUERY_VALUE, &hHKLM_UAKey) != ERROR_SUCCESS)
        hHKLM_UAKey = (HKEY)INVALID_HANDLE_VALUE;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, USER_AGENT_KEY5_SZ, 0, KEY_QUERY_VALUE, &hHKCU_UA5Key) != ERROR_SUCCESS)
        hHKCU_UA5Key = (HKEY)INVALID_HANDLE_VALUE;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, USER_AGENT_KEY5_SZ, 0, KEY_QUERY_VALUE, &hHKLM_UA5Key) != ERROR_SUCCESS)
        hHKLM_UA5Key = (HKEY)INVALID_HANDLE_VALUE;

    // Get user agent, compatible and version strings from IE 5.0 location.
    // IE6 and on must revise this location.
    for (i = 0; i < nBaseKeys; i++)
    {
        if ((hHKCU_UA5Key != INVALID_HANDLE_VALUE) && RegQueryValueEx(hHKCU_UA5Key, szBaseKeys[i],
            NULL, &dwType, (LPBYTE) szBuf, &(cbBuf = MAX_PATH)) == ERROR_SUCCESS
            && cbBuf > 1)
        {
            // Got from HKCU registry.
            if (!(bSuccess = AppendToString(&szUA, &cbUA,
                &cbTotal, szBuf, cbBuf - 1)))
                goto End;
        }
        else if ((hHKLM_UA5Key != INVALID_HANDLE_VALUE) && RegQueryValueEx(hHKLM_UA5Key, szBaseKeys[i],
            NULL, &dwType, (LPBYTE) szBuf, &(cbBuf = MAX_PATH)) == ERROR_SUCCESS
            && cbBuf > 1)
        {
            // Got from HKLM registry.
            if (!(bSuccess = AppendToString(&szUA, &cbUA,
                &cbTotal, szBuf, cbBuf - 1)))
                goto End;
        }
        else
        {
            // Got from defaults.
            if (!(bSuccess = AppendToString(&szUA, &cbUA, &cbTotal,
                szBaseValues[i], cbBaseValues[i])))
                goto End;
        }

        // Formating.
        if (!(bSuccess = AppendToString(&szUA, &cbUA,
            &cbTotal, (i == 0 ? " (" : "; "), 2)))
            goto End;
    }

    // Leave the four UA keys open; Proceed to open HKLM tokens key to scan
    // to scan and open Internet Settings HKCU key to read legacy UA string.

    // Tokens to scan for from the old registry location to include
    // in the user agent string: These are enumerated from UA Tokens,
    // scanned for in the old location and added to the pre platform.
    if (hHKLM_UAKey != INVALID_HANDLE_VALUE)
        RegOpenKeyEx(hHKLM_UAKey, UA_TOKENS_KEY_SZ, 0, KEY_QUERY_VALUE, &hTokensKey);

    if (hTokensKey != INVALID_HANDLE_VALUE)
    {
        CHAR szOldUserAgentString[MAX_PATH];

        // Read in the old user agent string from HKCU
        RegOpenKeyEx(HKEY_CURRENT_USER, INTERNET_SETTINGS_KEY_SZ, 0, KEY_QUERY_VALUE, &hHKCU_ISKey);

        if ((hHKCU_ISKey != INVALID_HANDLE_VALUE) && RegQueryValueEx(hHKCU_ISKey, USER_AGENT_SZ,
            NULL, &dwType, (LPBYTE) szOldUserAgentString, &(cbBuf = MAX_PATH)) == ERROR_SUCCESS
            && cbBuf > 1)
        {
            // Close the HKCU Internet Settings key.
            RegCloseKey(hHKCU_ISKey);
            hHKCU_ISKey = (HKEY) INVALID_HANDLE_VALUE;

            // Got old user agent string from HKCU registry. Enumerate the values in UA Tokens
            // and see if any exist in the old string and if so, add them to the current string.
            dwIndex = 0;
#ifndef unix
            while (RegEnumValue(hTokensKey, dwIndex++, szBuf, &(cbBuf = MAX_PATH - 4),  /* sizeof(' ' + "; ") */
                    NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
            {
                // eg; find a token enumerated from UA Tokens
                // Mozilla/4.0 (compatible; MSIE 4.0b2; MSN2.5; Windows NT)
                //                                     ^
                //                                     szBuf
                if (cbBuf)
                {
                    // Fix up token to include leading
                    // space and trailing semi-colon before strstr.
                    CHAR szToken[MAX_PATH];
                    szToken[0] = ' ';
                    memcpy(szToken+1, szBuf, cbBuf);
                    memcpy(szToken + 1 + cbBuf, "; ", sizeof("; "));

                    // Found a match - insert this token into user agent string.
                    if (strstr(szOldUserAgentString, szToken))
                    {
                        if (!(bSuccess = AppendToString(&szUA, &cbUA, &cbTotal, szBuf, cbBuf)))
                            goto End;

                        if (!(bSuccess = AppendToString(&szUA, &cbUA, &cbTotal, "; ", 2)))
                            goto End;
                    }
                }
            }
#endif /* !unix */
        }

        RegCloseKey(hTokensKey);
        hTokensKey = (HKEY) INVALID_HANDLE_VALUE;
    }


    // Pre platform strings - get from HKCUUA, HKLMUA,
    // HKLMUA5 and HKCUUA5 locations. These are additive;
    // order is not important.
    for (i = 0; i < NUM_UA_KEYS; i++)
    {
        if (*(phUAKeyArray[i]) == INVALID_HANDLE_VALUE)
            continue;

        RegOpenKeyEx(*(phUAKeyArray[i]),
            PRE_PLATFORM_KEY_SZ, 0, KEY_QUERY_VALUE, &hPreKey);

        if (hPreKey != INVALID_HANDLE_VALUE)
        {
            dwIndex = 0;
            while (RegEnumValue(hPreKey, dwIndex++, szBuf, &(cbBuf = MAX_PATH),
                                NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
            {
                if (cbBuf)
                {
                    // Got from registry and non null.
                    if (!(bSuccess = AppendToString(&szUA, &cbUA, &cbTotal, szBuf, cbBuf)))
                        goto End;
                    if (!(bSuccess = AppendToString(&szUA, &cbUA, &cbTotal, "; ", 2)))
                        goto End;
                }
                cbBuf = MAX_PATH;
            }

            // Close pre platform key; User agent keys still open.
            RegCloseKey(hPreKey);
            hPreKey = (HKEY) INVALID_HANDLE_VALUE;
        }
    }


    // Platform string. This is read from the IE 5.0 location only. IE6 and later
    // must revise this. If no platform value read from registry, get from OS.
    if (hHKCU_UA5Key != INVALID_HANDLE_VALUE && RegQueryValueEx(hHKCU_UA5Key, PLATFORM_KEY_SZ,
        NULL, &dwType, (LPBYTE) szBuf, &(cbBuf = MAX_PATH)) == ERROR_SUCCESS)
    {
        // Got from HKCU.
        if (!(bSuccess = AppendToString(&szUA, &cbUA, &cbTotal, szBuf, cbBuf -1)))
            goto End;
    }
    else if (hHKLM_UA5Key != INVALID_HANDLE_VALUE && RegQueryValueEx(hHKLM_UA5Key, PLATFORM_KEY_SZ,
             NULL, &dwType, (LPBYTE) szBuf, &(cbBuf = MAX_PATH)) == ERROR_SUCCESS)
    {
        // Got from HKLM
        if (!(bSuccess = AppendToString(&szUA, &cbUA, &cbTotal, szBuf, cbBuf -1)))
            goto End;
    }
    else
    {
        // Couldn't get User Agent value from registry.
        // Set the default value.
        osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx(&osVersionInfo))
        {
#ifndef unix
            // Platform ID is either Win95 or WinNT.
            if(VER_PLATFORM_WIN32_NT == osVersionInfo.dwPlatformId)
            {
                Assert(osVersionInfo.dwMajorVersion < 10000 &&
                       osVersionInfo.dwMinorVersion < 10000);
                /* Check for WIN64, adding another token if necessary */
                LPSTR szWin64Token = "; Win64";
                LPSTR szWow64Token = "; WOW64";

                SYSTEM_INFO SysInfo;

                GetSystemInfo(&SysInfo);
                bool fWin64 = ((SysInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) ||
                               (SysInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64));
                bool fWow64 = FALSE;

                // There is no easy way to determine whether a 32-bit app is running on a 32-bit OS
                // or Wow64.  The recommended approach (Q275217) to determine this is to see if
                // GetSystemWow64DirectoryA is implemented in kernel32.dll and to see if the function
                // succeeds.  If it succeeds, then we're running on a 64-bit processor.
                if (!fWin64 && SysInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL)
                {
                    char directoryPath[MAX_PATH];
                    HMODULE hModule;
                    GetSystemWow64DirectoryPtr func;

                    hModule = GetModuleHandle("kernel32.dll");
                    func = (GetSystemWow64DirectoryPtr) GetProcAddress(hModule, "GetSystemWow64DirectoryA");
                    if (func && func(directoryPath, sizeof(directoryPath)))
                    {
                        fWow64 = TRUE;
                    }
                }

                LPSTR sz64Str = NULL;
                if( fWin64)
                    sz64Str = szWin64Token;
                else if( fWow64)
                    sz64Str = szWow64Token;
                else
                    sz64Str = "";

                memset(szWinNTVer, 0, WINNT_VERSION_STRING_MAX_LEN);
                wsprintfA(szWinNTVer, 
                          "%s %u.%u%s",
                          szWinNT,
                          osVersionInfo.dwMajorVersion,
                          osVersionInfo.dwMinorVersion,
                          sz64Str);

                pszWinVer = szWinNTVer;
            }
            else
            {
                if(osVersionInfo.dwMinorVersion >= 10)
                {
                    if(osVersionInfo.dwMinorVersion >= 90)
                    {
                        // Millennium
                        pszWinVer = szMillennium;
                    }
                    else
                    {
                        // Win98
                        pszWinVer = szWin98;
                    }
                }
                else
                {
                    // Win95
                    pszWinVer = szWin95;
                }
            }
#else
            struct utsname uName;
            if(uname(&uName) > -1)
            {
                strcpy(szUnixPlatformName,uName.sysname);
                strcat(szUnixPlatformName," ");
                strcat(szUnixPlatformName,uName.release);
                strcat(szUnixPlatformName," ");
                strcat(szUnixPlatformName,uName.machine);
                strcat(szUnixPlatformName,"; X11");
                pszWinVer = &szUnixPlatformName[0];
            }
            else
                pszWinVer = "Generic Unix";
#endif /* unix */
        }
        else
        {
            // GetVersionEx failed! - set Platform to Win32.
            pszWinVer = szWin32;
        }
        if (!(bSuccess = AppendToString(&szUA, &cbUA, &cbTotal,
            pszWinVer, strlen(pszWinVer))))
            goto End;
    }

    // Post platform strings - get from HKCUUA, HKLMUA,
    // HKLMUA5 and HKCUUA5 locations. These are additive;
    // order is not important. Special case the IE4
    // compat token. IE6 and later must do this also.
    for (i = 0; i < NUM_UA_KEYS; i++)
    {
        if (*(phUAKeyArray[i]) == INVALID_HANDLE_VALUE)
            continue;

        RegOpenKeyEx(*(phUAKeyArray[i]),
            POST_PLATFORM_KEY_SZ, 0, KEY_QUERY_VALUE, &hPostKey);

        if (hPostKey != INVALID_HANDLE_VALUE)
        {
            dwIndex = 0;
            while (RegEnumValue(hPostKey, dwIndex++, szBuf, &(cbBuf = MAX_PATH),
                            NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
            {
                // We need to special case the IE4 compat mode token in the
                // first two keys in phUAKeyArray[];
                if (cbBuf && ((i > 1) || strcmp(szBuf, COMPAT_MODE_TOKEN)))
                {
                    // Got from registry and non null.
                    if (!(bSuccess = AppendToString(&szUA, &cbUA, &cbTotal, "; ", 2)))
                        goto End;
                    if (!(bSuccess = AppendToString(&szUA, &cbUA, &cbTotal, szBuf, cbBuf)))
                        goto End;
                }
                cbBuf = MAX_PATH;
            }

            // Close post platform key; User agent keys still open.
            RegCloseKey(hPostKey);
            hPostKey = (HKEY) INVALID_HANDLE_VALUE;
        }
    }
    // Terminate with ")\0"
    if (!(bSuccess = AppendToString(&szUA, &cbUA, &cbTotal, ")", 2)))
        goto End;

    for (i = 0; i < NUM_UA_KEYS; i++)
    {
        if (*(phUAKeyArray[i]) != INVALID_HANDLE_VALUE)
        {
            RegCloseKey(*(phUAKeyArray[i]));
            *(phUAKeyArray[i]) = (HKEY) INVALID_HANDLE_VALUE;
        }
    }

    // Finally, write out the generated user agent string in the old location.
    if (bSuccess)
    {
        // Remember the computed user agent string for later.
        g_pszUserAgentString = szUA;
    }

End:

    // Cleanup.

    delete [] szBuf;

    if (!bSuccess)
    {
        delete [] szUA;

        DEBUG_LEAVE(DEFAULT_UA_STRING);
        return DEFAULT_UA_STRING;
    }

    DEBUG_LEAVE(szUA);
    return szUA;
}


//+---------------------------------------------------------------------------
//
//  Method:     ObtainUserAgentString
//
//  Synopsis:
//
//  Returns:
//
//  History:   08-07-1997   DanpoZ (Danpo Zhang) Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI ObtainUserAgentString(DWORD dwOption, LPSTR pszUAOut, DWORD *cbSize )
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "ObtainUserAgentString",
                    "%#x, %#x, %#x",
                    dwOption, pszUAOut, cbSize
                    ));
                
    // since GetUserAgentString may change some global variable,
    // this API needs to add a global mutex to protect them
    CLock lck(g_mxsSession);

    HRESULT hr = NOERROR;
    if( pszUAOut && cbSize )
    {
        LPSTR   pcszUA = (LPSTR)GetUserAgentString();
        DWORD   cbLen = strlen(pcszUA);

        if( *cbSize <= cbLen )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            strcpy(pszUAOut, pcszUA);
        }
        *cbSize = cbLen + 1;

    }
    else
    {
        hr = E_INVALIDARG;
    }

    DEBUG_LEAVE_API(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINet::InternetAuthNotifyCallback
//
//  Synopsis:
//
//  Arguments:  [dwContext] --
//              [dwAction] --
//              [lpReserved] --
//
//  Returns:
//
//  History:    10-10-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CALLBACK CINet::InternetAuthNotifyCallback(DWORD_PTR dwContext, DWORD dwAction, LPVOID lpReserved)
{
    DEBUG_ENTER((DBG_APP,
                Dword,
                "CINet::InternetAuthNotifyCallback",
                "%#x, %#x, %#x",
                dwContext, dwAction, lpReserved
                ));
                
    // If this is a request, then we know the cookie type
    CINet *pCINet = (CINet *) dwContext;
    PerfDbgLog2(tagCINet, pCINet, "+CINet::InternetAuthNotifyCallback Action:%ld, State:%ld",
        dwAction, pCINet->_INState);

    PProtAssert((lpReserved == NULL));

    DWORD dwRes = ERROR_SUCCESS;

    switch (dwAction)
    {
    case ERROR_SUCCESS  :
        // should never be returned here
        PProtAssert((FALSE));

    case ERROR_CANCELLED :
        // NOTE: succes and cancel means display the content according to ArthurBi
        // continue reading data and show the 401 contained
        pCINet->_hrINet = NOERROR;
        // Why do we inc the count here??
        pCINet->_fProxyAuth ? pCINet->_cbProxyAuthenticate++ : pCINet->_cbAuthenticate++;
        break;

    case ERROR_INTERNET_RETRY_DIALOG:
        pCINet->_hrINet = INET_E_AUTHENTICATION_REQUIRED;
        break;

    case ERROR_INTERNET_FORCE_RETRY :
        pCINet->_hrINet = RPC_E_RETRY;
        pCINet->_fProxyAuth ? pCINet->_cbProxyAuthenticate++ : pCINet->_cbAuthenticate++;
        break;

    default:
        pCINet->_hrINet = E_ACCESSDENIED;
        break;
    }

    pCINet->OnINetAuthenticate(dwAction);

    PerfDbgLog2(tagCINet, pCINet, "-CINet::InternetAuthNotifyCallback (pCINet->_hrINet:%lx, dwResult:%lx)", pCINet->_hrINet,dwRes);

    DEBUG_LEAVE(dwRes);
    return dwRes;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::OnINetAuthenticate
//
//  Synopsis:
//
//  Arguments:  [dwResult] --
//
//  Returns:
//
//  History:    10-10-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::OnINetAuthenticate(DWORD dwResult)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::OnINetAuthenticate",
                "this=%#x, %#x",
                this, dwResult
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::OnINetAuthenticate");
    HRESULT hr = NOERROR;

    PProtAssert((GetStatePending() == E_PENDING));
    // set state to normal - no pending transaction
    SetStatePending(NOERROR);
    PProtAssert((_INState == INetState_AUTHENTICATE));

    if (dwResult)
    {
        TransitState(INetState_AUTHENTICATE, TRUE);
    }

    PerfDbgLog1(tagCINet, this, "-CINet::OnINetAuthenticate (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetAuthenticate
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-10-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetAuthenticate()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetAuthenticate",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetAuthenticate");
    PProtAssert((GetStatePending() == NOERROR));

    HRESULT hr = NOERROR;
    DWORD dwOperation;

    PProtAssert((GetStatePending() == NOERROR));


    if (_hrINet == INET_E_AUTHENTICATION_REQUIRED)
    {
        // bring up the internet errro dialog
        hr = AuthenticationRequest();

        if ((hr != NOERROR) && (hr != E_PENDING))
        {
            _hrError = INET_E_AUTHENTICATION_REQUIRED;
        }
        else
        {
            _hrError = INET_E_OK;
        }

    }

    if (hr == NOERROR)
    {
        if (_hrINet == RPC_E_RETRY)
        {
            // retry the send/request
            _hrINet = NOERROR;
            _fCompleted = FALSE;
            _fSendAgain = TRUE;
            hr = INetAsyncSendRequest();
        }
        else if (_hrINet == NOERROR)
        {
            hr = QueryStatusOnResponseDefault(0);
            if( hr == NOERROR )
            {
                hr = QueryHeaderOnResponse();
                if (hr == NOERROR)
                {
                    // read more data from wininet
                    hr = INetRead();
                }
            }
        }
        else
        {
            // this will report the hresult return from the dialog
            hr = _hrINet;
        }
    }

    PerfDbgLog1(tagCINet, this, "-CINet::INetAuthenticate (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetResumeAsyncRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetResumeAsyncRequest(DWORD dwResultCode)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetResumeAsyncRequest",
                "this=%#x, %#x",
                this, dwResultCode
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetResumeAsyncRequest");

    HRESULT hr = NOERROR;
    BOOL fRestarted;
    BOOL fRet;
    PProtAssert((GetStatePending() == NOERROR));

    SetINetState(INetState_SEND_REQUEST);
    {
        SetStatePending(E_PENDING);

        fRet = ResumeSuspendedDownload(_hRequest,
                        dwResultCode
                        );

        if (fRet == FALSE)
        {
            dwLstError = GetLastError();
            if (dwLstError == ERROR_IO_PENDING)
            {
                // wait async for the handle
                hr = E_PENDING;
            }
            else
            {
                SetStatePending(NOERROR);
                hr = _hrError = INET_E_DOWNLOAD_FAILURE;
                SetBindResult(dwLstError,hr);
                PerfDbgLog3(tagCINet, this, "CINet::INetResumeAsyncRequest (fRet:%d, _hrError:%lx, LstError:%ld)", fRet, _hrError, dwLstError);
            }
        }
        else
        {
            SetStatePending(NOERROR);
        }
    }

    if (_hrError != INET_E_OK)
    {
        // we need to terminate here
        ReportResultAndStop(hr);
    }

    PerfDbgLog1(tagCINet, this, "-CINet::INetResumeAsyncRequest (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetDisplayUI
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-10-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetDisplayUI()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetDisplayUI",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetDisplayUI");
    PProtAssert((GetStatePending() == NOERROR));

    HRESULT hr = NOERROR;
    DWORD dwOperation;
    DWORD dwResultCode = ERROR_SUCCESS;

    PProtAssert((GetStatePending() == NOERROR));
    DWORD  dwBindF = GetBindFlags();


    if (_hrINet == INET_E_AUTHENTICATION_REQUIRED)
    {
        HWND hwnd = 0;
        hr = NOERROR;
        // Get a window handle. QueryService on IWindowForBindingUI
        // to get a window object first if necessary.
        if (_pWindow == NULL)
        {
            hr = QueryService(IID_IWindowForBindingUI, (void **) &_pWindow);
        }
        // If we don't already have a window handle, get one from the interface.
        if (!hwnd && _pWindow)
        {
            hr = _pWindow->GetWindow(IID_IHttpSecurity, &hwnd);
            PProtAssert((   (hr == S_FALSE) && (hwnd == NULL)
                         || (hr == S_OK) && (hwnd != NULL)));
        }

        if (hwnd && (hr == S_OK))
        {
            DWORD dwFlags = FLAGS_ERROR_UI_SERIALIZE_DIALOGS;
            if ((dwBindF & BINDF_NO_UI) || (dwBindF & BINDF_SILENTOPERATION))
            {
                dwFlags |= FLAGS_ERROR_UI_FLAGS_NO_UI;
            }

            dwResultCode =
                InternetErrorDlg( hwnd, _hRequest, _dwSendRequestResult, dwFlags, &_lpvExtraSendRequestResult);


            if ( dwResultCode == ERROR_CANCELLED || dwResultCode == ERROR_SUCCESS )
            {
                // hack-hack alert, if _lpvExtraSendRequestResult non-null we change behavior
                if ( !(dwResultCode == ERROR_SUCCESS && _lpvExtraSendRequestResult != NULL) )
                {
                    dwResultCode = ERROR_INTERNET_OPERATION_CANCELLED;
                }
            }

            _hrINet = RPC_E_RETRY;
            hr = NOERROR;
        }
        else if (_dwSendRequestResult == ERROR_HTTP_COOKIE_NEEDS_CONFIRMATION ||
                 _dwSendRequestResult == ERROR_HTTP_COOKIE_NEEDS_CONFIRMATION_EX)
        {
            //fix to prevent heap trashing in wininet.b#86959
            dwResultCode = ERROR_HTTP_COOKIE_DECLINED;
            _hrINet = RPC_E_RETRY;
            hr = NOERROR;
        }

        if ((hr != NOERROR) && (hr != E_PENDING))
        {
            _hrError = INET_E_AUTHENTICATION_REQUIRED;
        }
        else
        {
            _hrError = INET_E_OK;
        }
    }

    if (hr == NOERROR)
    {
        if (_hrINet == RPC_E_RETRY)
        {
            // retry the send/request
            _hrINet = NOERROR;

            // hack-arama around to allow CD-ROM dialog to still work
            if ( _dwSendRequestResult == ERROR_INTERNET_INSERT_CDROM )
            {
                hr = INetAsyncSendRequest();
            }
            else
            {
                hr = INetResumeAsyncRequest(dwResultCode);
            }
        }
        else
        {
            // this will report the hresult return from the dialog
            hr = _hrINet;
        }
    }

    PerfDbgLog1(tagCINet, this, "-CINet::INetDisplayUI (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetSeek
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [ULARGE_INTEGER] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetSeek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetSeek",
                "this=%#x, %#x, %#x, %#x",
                this, dlibMove, dwOrigin, plibNewPosition
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetSeek");
    HRESULT hr = E_FAIL;

    // each protocol has to overwrite this method if
    // seek is supported

    DWORD dwResult = InternetSetFilePointer(
                                      _hRequest
                                     ,dlibMove.LowPart
                                     ,0
                                     ,dwOrigin
                                     ,0
                                     );

    PerfDbgLog1(tagCINet, this, "-CINet::INetSeek (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::IsUpLoad
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    4-28-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CINet::IsUpLoad()
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "CINet::IsUpLoad",
                "this=%#x",
                this
                ));
                
    BINDINFO *pBndInfo = GetBindInfo();
    BOOL fRet = (   (pBndInfo->dwBindVerb != BINDVERB_GET)
            && (pBndInfo->stgmedData.tymed == TYMED_ISTREAM)
            && !_fCompleted
            && !_fRedirected);

    DEBUG_LEAVE(fRet);
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::CPrivUnknown::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINet::CPrivUnknown::QueryInterface(REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::CPrivUnknown::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppvObj
                ));
                
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    PerfDbgLog(tagCINet, this, "+CINet::CPrivUnknown::QueryInterface");
    CINet *pCINet = GETPPARENT(this, CINet, _Unknown);

    *ppvObj = NULL;

    if ((riid == IID_IUnknown) || (riid == IID_IOInetProtocol) || (riid == IID_IOInetProtocolRoot) )
    {
        *ppvObj = (IOInetProtocol *) pCINet;
        pCINet->AddRef();
    }
    else if ( ( IsEqualIID(riid, IID_IWinInetInfo)||
                IsEqualIID(riid, IID_IWinInetHttpInfo) ) &&
              ( !IsEqualIID(CLSID_FileProtocol, pCINet->_pclsidProtocol) ) )

    {
        *ppvObj = (void FAR *) (IWinInetHttpInfo *)pCINet;
        pCINet->AddRef();
    }
    else if (riid == IID_IOInetThreadSwitch)
    {
        *ppvObj = (IOInetThreadSwitch *)pCINet;
        pCINet->AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    PerfDbgLog1(tagCINet, this, "-CINet::CPrivUnknown::QueryInterface (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CINet::CPrivUnknown::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CINet::CPrivUnknown::AddRef(void)
{
    DEBUG_ENTER((DBG_APP,
                Dword,
                "CINet::CPrivUnknown::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::CPrivUnknown::AddRef");

    LONG lRet = ++_CRefs;

    PerfDbgLog1(tagCINet, this, "-CINet::CPrivUnknown::AddRef (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}
//+---------------------------------------------------------------------------
//
//  Function:   CINet::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CINet::CPrivUnknown::Release(void)
{
    DEBUG_ENTER((DBG_APP,
                Dword,
                "CINet::CPrivUnknown::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::CPrivUnknown::Release");

    CINet *pCINet = GETPPARENT(this, CINet, _Unknown);

    LONG lRet = --_CRefs;

    if (lRet == 0)
    {
        delete pCINet;
    }

    PerfDbgLog1(tagCINet, this, "-CINet::CPrivUnknown::Release (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINet::OnINetReadDirect
//
//  Synopsis:
//
//  Arguments:  [dwResult] --
//
//  Returns:
//
//  History:    4-28-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::OnINetReadDirect(DWORD dwResult)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::OnINetReadDirect",
                "this=%#x, %#x",
                this, dwResult
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::OnINetReadDirect");
    HRESULT hr = NOERROR;

    PProtAssert((GetStatePending() == E_PENDING));
    // set state to normal - no pending transaction
    SetStatePending(NOERROR);

    if (OperationOnAparmentThread(INetState_SEND_REQUEST))
    {
        TransitState(INetState_READ_DIRECT);
    }
    else
    {
        hr = INetReadDirect();
    }

    PerfDbgLog1(tagCINet, this, "-CINet::OnINetReadDirect (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::INetReadDirect
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    4-28-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::INetReadDirect()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::INetReadDirect",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::INetReadDirect");
    HRESULT hr = NOERROR;
    DWORD dwError;
    ULONG cbBytesAvailable = 1;
    ULONG cbBytesReport = 0;
    SetINetState(INetState_READ_DIRECT);

    //BUGBUG: we hit this assertion sometimes.
    //PProtAssert((GetStatePending() == NOERROR));

    _hrError = INET_E_OK;

    if (!_fFilenameReported)
    {
        char szFilename[MAX_PATH];

        HRESULT hr1 = GetUrlCacheFilename(szFilename, MAX_PATH);

        if (hr1 == NOERROR && szFilename[0] != '\0')
        {
            ReportNotification(BINDSTATUS_CACHEFILENAMEAVAILABLE, (LPSTR) szFilename);
            _fFilenameReported = TRUE;
        }
    }

    if ((GetStatePending() == E_PENDING))
    {
        // nothing to do - data for this notfication
        // already received
        DbgLog(tagCINetErr, this, "CINet::INetReadDirect E_PENIDNG");

    }
    else
    {
        if (   _fDone
            || (   _cbTotalBytesRead
                  && _cbDataSize
                  && (_cbTotalBytesRead == _cbDataSize)))
        {

            _hrError = INET_E_DONE;
            _pEmbdFilter->ReportData(_bscf, cbBytesAvailable, _cbDataSize);
            ReportResultAndStop(NOERROR, _cbTotalBytesRead, _cbDataSize);
            hr = NOERROR;
        }
        else
        {

            if (_bscf & BSCF_DATAFULLYAVAILABLE)
            {
                _bscf |= BSCF_LASTDATANOTIFICATION;
                _bscf &= ~BSCF_FIRSTDATANOTIFICATION;
                cbBytesReport = cbBytesAvailable + _cbTotalBytesRead;
                if (IsEmbdFilterOk() )
                {
                    _pEmbdFilter->ReportData(_bscf, cbBytesReport, _cbDataSize);
                }
                ReportResultAndStop(NOERROR, cbBytesReport, _cbDataSize);
            }
            else
            {
                _bscf |= BSCF_AVAILABLEDATASIZEUNKNOWN;
                cbBytesReport = cbBytesAvailable + _cbTotalBytesRead;
                if (_pCTrans && IsEmbdFilterOk() )
                {
                    _cbSizeLastReportData = cbBytesReport;
                    hr = _pEmbdFilter->ReportData(_bscf, cbBytesReport, _cbDataSize);
                }
            }

            if (_bscf & BSCF_FIRSTDATANOTIFICATION)
            {
                _bscf &= ~BSCF_FIRSTDATANOTIFICATION;
                _bscf |= BSCF_INTERMEDIATEDATANOTIFICATION;
            }
        }
    }

    PerfDbgLog2(tagCINet, this, "-CINet::INetReadDirect (_hrError:%lx, hr:%lx)", _hrError, hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::ReadDirect
//
//  Synopsis:
//
//  Arguments:  [pBuffer] --
//              [cbBytes] --
//              [pcbBytes] --
//
//  Returns:
//
//  History:    4-28-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINet::ReadDirect(BYTE *pBuffer, DWORD cbBytes, DWORD *pcbBytes)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINet::ReadDirect",
                "this=%#x, %#x, %#x, %#x",
                this, pBuffer, cbBytes, pcbBytes
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::ReadDirect");
    HRESULT hr = NOERROR;
    DWORD dwError;

    *pcbBytes = 0;
    ULONG dwReturned = 0;

    //BUGBUG: turn this assertion on again
    //PProtAssert((GetStatePending() == NOERROR));

    if (_hrError == INET_E_DONE)
    {
        // means end of file
        hr = S_FALSE;
    }
    else if (GetStatePending() != NOERROR)
    {
        hr = E_PENDING;
    }
    else
    {
        _hrError = INET_E_OK;
        PProtAssert(((pBuffer != NULL) && (cbBytes > 0)));
        //PerfDbgLog1(tagCINet, this, "CINet::ReadDirect -> InternetReadFile (dwBytesLeft:%ld)", dwBytesLeft);

        LPINTERNET_BUFFERSA pIB = &_inetBufferSend;
        pIB->dwStructSize = sizeof (INTERNET_BUFFERSA);
        pIB->Next = 0;
        pIB->lpcszHeader = 0;
        pIB->dwHeadersLength = 0;
        pIB->dwHeadersTotal = 0;
        pIB->lpvBuffer = pBuffer;
        pIB->dwBufferLength = cbBytes;
        pIB->dwBufferTotal = 0;
        pIB->dwOffsetLow = 0;
        pIB->dwOffsetHigh = 0;


        dwReturned = 0;
        PProtAssert((GetStatePending() == NOERROR));
        SetStatePending(E_PENDING);

        if (!InternetReadFileExA(
                             _hRequest       //IN HINTERNET hFile,
                            ,pIB             // OUT LPINTERNET_BUFFERSA lpBuffersOut,
                            ,IRF_NO_WAIT     //    IN DWORD dwFlags,
                            ,0               //    IN DWORD dwContext
                            ))
        {
            //
            // async completion
            //
            dwError = GetLastError();
            if (dwError != ERROR_IO_PENDING)
            {
                hr = _hrError = INET_E_DOWNLOAD_FAILURE;
                DbgLog3(tagCINetErr, this, "CINet::ReadDirect failed: (dwError:%lx, hr:%lx, hrError:%lx)",
                                            dwError, hr, _hrError);
            }
            else
            {
                hr = E_PENDING;
            }
        }
        else
        {
            //
            // sync completion
            //
            SetStatePending(NOERROR);
            //
            dwReturned = pIB->dwBufferLength;
            _cbTotalBytesRead += dwReturned;
            *pcbBytes = dwReturned;

            PerfDbgLog3(tagCINet, this, "CINet::ReadDirect == InternetReadFileEx ==> (cbBytes:%ld, dwReturned:%ld,_cbTotalBytesRead:%ld)",
                cbBytes, dwReturned,_cbTotalBytesRead);


            if (dwReturned == 0)
            {
                // eof
                hr = _hrError = INET_E_DONE;
                //TransDebugOut((DEB_TRACE, "%p _IN CINetStream::INetSeek\n", this));
                PProtAssert(( (   (_cbDataSize && (_cbDataSize == _cbTotalBytesRead))
                               || (!_cbDataSize)) &&  "WinInet returned incorrent amount of data!!" ));
            }
            else
            {
                hr = NOERROR;
            }

        }  // read case - bits available

        *pcbBytes = dwReturned;

        if (hr == INET_E_DONE)
        {
            hr = (dwReturned) ? S_OK : S_FALSE;
        }
    }

    // Note: stop the download in case of DONE or ERROR!
    if (_hrError != INET_E_OK)
    {
        ReportResultAndStop((hr == S_FALSE) ? NOERROR : hr);
    }

    PerfDbgLog4(tagCINet, this, "-CINet::ReadDirect (_hrError:%lx, [hr:%lx,cbBytesAsked:%ld,cbBytesReturned:%ld])",
        _hrError, hr, cbBytes, *pcbBytes);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::GetUserAgentString
//
//  Synopsis:
//
//  Arguments:  [pBuffer] --
//              [cbBytes] --
//              [pcbBytes] --
//
//  Returns:
//
//  History:    4-28-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPSTR CINet::GetUserAgentString()
{
    DEBUG_ENTER((DBG_APP,
                String,
                "CINet::GetUserAgentString",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINet, this, "+CINet::GetUserAgentString");
    HRESULT hr = NOERROR;
    ULONG ulCount = 0;
    LPWSTR pwzStr = 0;
    LPSTR pszStr = 0;


    hr = _pOIBindInfo->GetBindString(BINDSTRING_USER_AGENT, (LPWSTR *)&pwzStr, 1, &ulCount);

    if ((hr == NOERROR) && ulCount)
    {
        PProtAssert((pwzStr));
        delete _pszUserAgentStr;
        pszStr = _pszUserAgentStr  = DupW2A(pwzStr);
    }
    else
    {
        pszStr = (LPSTR)::GetUserAgentString();
    }


    PerfDbgLog1(tagCINet, this, "-CINet::GetUserAgentString (pszStr:%s)", pszStr);

    DEBUG_LEAVE(pszStr);
    return pszStr;
}


BOOL GlobalUTF8Enabled()
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "GlobalUTF8Enabled",
                NULL
                ));
                
    // read the IE5 B2 global reg key
    DWORD dwErr = ERROR_SUCCESS;
    BOOL  fRet = FALSE;
    HKEY  hKeyClient;
    DWORD dwUTF8 = 0;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType;

    dwErr = RegOpenKeyEx(
                HKEY_CURRENT_USER,
                INTERNET_POLICIES_KEY,
                0,
                KEY_QUERY_VALUE,
                &hKeyClient
            );
    if( dwErr == ERROR_SUCCESS )
    {
        dwErr = RegQueryValueEx(
                hKeyClient,
                "EnableUTF8",
                0,
                &dwType,
                (LPBYTE)&dwUTF8,
                &dwSize
        );

        if( dwErr == ERROR_SUCCESS && dwUTF8 )
        {
            fRet = TRUE;
        }
        RegCloseKey(hKeyClient);
    }

    DEBUG_LEAVE(fRet);
    return fRet;
}

// Enabled by adding a DWORD value "MBCSServername" with non=zero value under POLICY key
BOOL GlobalUTF8hackEnabled()
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "GlobalUTF8hackEnabled",
                NULL
                ));
                
    DWORD dwErr = ERROR_SUCCESS;
    BOOL  fRet = TRUE;
    HKEY  hKeyClient;
    DWORD dwUTF8 = 0;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType;

    dwErr = RegOpenKeyEx(
                HKEY_CURRENT_USER,
                INTERNET_POLICIES_KEY,
                0,
                KEY_QUERY_VALUE,
                &hKeyClient
            );
    if( dwErr == ERROR_SUCCESS )
    {
        dwErr = RegQueryValueEx(
                hKeyClient,
                "MBCSServername",
                0,
                &dwType,
                (LPBYTE)&dwUTF8,
                &dwSize
        );

        if( dwErr == ERROR_SUCCESS && !dwUTF8 )
        {
            fRet = FALSE;
        }
        RegCloseKey(hKeyClient);
    }

    DEBUG_LEAVE(fRet);
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\eapp\resprot.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       resprot.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <eapp.h>
#include <tchar.h>

#define MAX_ID 10000

#define WITH_TAGS

//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::Start
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pTrans] --
//              [pOIBindInfo] --
//              [grfSTI] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CResProtocol::Start(LPCWSTR pwzUrl, IOInetProtocolSink *pTrans, IOInetBindInfo *pOIBindInfo,
                          DWORD grfSTI, DWORD dwReserved)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CResProtocol::Start\n", this));
    HRESULT hr = NOERROR;
    WCHAR    wzURL[MAX_URL_SIZE];

    EProtAssert((!_pProtSink && pOIBindInfo && pTrans));
    EProtAssert((_pwzUrl == NULL));

    hr = CBaseProtocol::Start(pwzUrl,pTrans, pOIBindInfo, grfSTI, dwReserved);

    if ( (grfSTI & PI_PARSE_URL) )
    {
        hr =  ParseAndBind(FALSE);
    }
    else if (hr == NOERROR)
    {
        // asked to go async as soon as possible
        // use the switch mechanism which will \
        // call back later on ::Continue
        if (grfSTI & PI_FORCE_ASYNC)
        {
            hr = E_PENDING;
            PROTOCOLDATA protdata;
            protdata.grfFlags = PI_FORCE_ASYNC;
            protdata.dwState = RES_STATE_BIND;
            protdata.pData = 0;
            protdata.cbData = 0;

            _pProtSink->Switch(&protdata);
        }
        else
        {
            hr =  ParseAndBind(TRUE);
        }
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CResProtocol::Start (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::Continue
//
//  Synopsis:
//
//  Arguments:  [pStateInfoIn] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CResProtocol::Continue(PROTOCOLDATA *pStateInfoIn)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CResProtocol::Continue\n", this));
    HRESULT hr = E_FAIL;

    EProtAssert((!pStateInfoIn->pData && pStateInfoIn->cbData && (pStateInfoIn->dwState == RES_STATE_BIND)));

    if (pStateInfoIn->dwState == RES_STATE_BIND)
    {
        hr =  ParseAndBind();
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CResProtocol::Continue (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::Read
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//              [ULONG] --
//              [pcbRead] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CResProtocol::Read(void *pv,ULONG cb,ULONG *pcbRead)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CResProtocol::Read (cb:%ld)\n", this,cb));
    HRESULT hr = NOERROR;

    if (_cbBuffer > _cbPos)
    {
        ULONG cbCopy = (cb < (_cbBuffer - _cbPos)) ? cb :  _cbBuffer - _cbPos;

        memcpy((LPVOID)pv, ((LPBYTE)_pBuffer) + _cbPos, cbCopy);

        _cbPos += cbCopy;

        *pcbRead = cbCopy;

        hr =  (_cbPos < _cbBuffer) ? S_OK : S_FALSE;
    }
    else
    {
        hr = S_FALSE;
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CResProtocol::Read (pcbRead:%ld, hr:%lx)\n",this,*pcbRead, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::Seek
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [ULARGE_INTEGER] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:      WORK: not done
//
//----------------------------------------------------------------------------
STDMETHODIMP CResProtocol::Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CResProtocol::Seek\n", this));
    HRESULT hr = NOERROR;

    if (dwOrigin == STREAM_SEEK_SET)
    {
        if (dlibMove.LowPart >= 0)
        {
            _cbPos = dlibMove.LowPart;

            if (plibNewPosition)
            {
                plibNewPosition->HighPart = 0;
                plibNewPosition->LowPart = _cbPos;
            }
        }
        else
        {
            hr = STG_E_INVALIDPOINTER;
        }
    }
    else
    {
        hr = E_NOTIMPL;
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CResProtocol::Seek (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::LockRequest
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CResProtocol::LockRequest(DWORD dwOptions)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CResProtocol::LockRequest\n", this));

    HRESULT hr = NOERROR;

    if (OpenTempFile())
    {
        DWORD dwWrite;
        if (!WriteFile(_hFile, _pBuffer, _cbBuffer, &dwWrite,NULL))
        {
            hr = E_FAIL;
        }
        CloseTempFile();
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CResProtocol::LockRequest (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::UnlockRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CResProtocol::UnlockRequest()
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CResProtocol::UnlockRequest\n", this));
    HRESULT hr = NOERROR;

    //CloseTempFile();

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CResProtocol::UnlockRequest (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::CResProtocol
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CResProtocol::CResProtocol(REFCLSID rclsid, IUnknown *pUnkOuter, IUnknown **ppUnkInner) : CBaseProtocol(rclsid, pUnkOuter, ppUnkInner)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CResProtocol::CResProtocol \n", this));

    _hInst = NULL;
    _cbBuffer = 0;
    _pBuffer = 0;
    _hgbl = 0;
    _cbPos = 0;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CResProtocol::CResProtocol \n", this));
}

//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::~CResProtocol
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CResProtocol::~CResProtocol()
{

    if (_hgbl)
    {
        UnlockResource(_hgbl);
    }
    if (_hInst)
    {
        FreeLibrary(_hInst);
    }

    EProtDebugOut((DEB_PLUGPROT, "%p _IN/OUT CResProtocol::~CResProtocol \n", this));
}

//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::GetResource
//
//  Synopsis:
//
//  Arguments:  [pwzFileName] --
//              [pwzResName] --
//              [pwzResType] --
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CResProtocol::GetResource(LPCWSTR pwzFileName, LPCWSTR pwzResName, LPCWSTR pwzResType, LPCWSTR pwzMime)
{
    EProtDebugOut((DEB_PLUGPROT, "CResProtocol::GetResource\n)"));
    HRESULT     hr = NOERROR;
    DWORD       dwError = 0;
    HRSRC       hrsrc;

    LPSTR pszFileName =  DupW2A(pwzFileName );
    LPSTR pszResName  =  DupW2A(pwzResName  );
    LPSTR pszResType  =  DupW2A(pwzResType  );


    if (!pszFileName || !pszResName || !pszResType)
    {
        hr = E_OUTOFMEMORY;
    }
    else do
    {
        _pProtSink->ReportProgress(BINDSTATUS_SENDINGREQUEST, pwzResName);

        _hInst = LoadLibraryEx(pszFileName, NULL, DONT_RESOLVE_DLL_REFERENCES);
        if (!_hInst)
        {
            hr = INET_E_RESOURCE_NOT_FOUND;
            dwError = GetLastError();
            break;
        }

        if (!wcscmp(pwzResName, L"?"))
        {
            for (int i = 0 ; i < MAX_ID; i++)
            {
                hrsrc = FindResource(_hInst, (LPSTR)MAKEINTRESOURCE(i), pszResType);

                if (hrsrc)
                {
                    EProtDebugOut((DEB_PLUGPROT, "CResProtocol::GetResource (szResName:#%ld, wzRestype:%s\n)",i,pszResType));
                    i = MAX_ID;
                }
            }
        }
        else
        {
            hrsrc = FindResource(_hInst, pszResName, pszResType);
        }

        if (!hrsrc)
        {
            hr = INET_E_OBJECT_NOT_FOUND;
            dwError = GetLastError();
            break;
        }

        _hgbl = LoadResource(_hInst, hrsrc);
        if (!_hgbl)
        {
            hr = INET_E_DATA_NOT_AVAILABLE;
            dwError = GetLastError();
            break;
        }

        _pBuffer = LockResource(_hgbl);
        if (!_pBuffer)
        {
            hr = INET_E_DATA_NOT_AVAILABLE;
            dwError = GetLastError();
            break;
        }

        _cbBuffer = SizeofResource(_hInst, hrsrc);


        if (_grfBindF & INTERNET_FLAG_NEED_FILE)
        {
            LockRequest(0);
        }

#ifdef UNUSED
        if (OpenTempFile())
        {
            DWORD dwWrite;
            if (!WriteFile(_hFile, _pBuffer, _cbBuffer, &dwWrite,NULL))
            {
                dwError = GetLastError();
                break;
            }
            CloseTempFile();
        }
#endif //UNUSED

        hr = NOERROR;
        break;

    }  while (1);

    if (dwError || (hr != NOERROR))
    {
        _pProtSink->ReportResult(hr, dwError, 0);
    }
    else
    {
        if (pwzMime)
        {
            _pProtSink->ReportProgress(BINDSTATUS_MIMETYPEAVAILABLE, pwzMime);
        }

        _bscf |= BSCF_LASTDATANOTIFICATION | BSCF_DATAFULLYAVAILABLE;
        _pProtSink->ReportData(_bscf, _cbBuffer, _cbBuffer);
    }

    if (pszFileName)
    {
        delete pszFileName;
    }

    if (pszResName)
    {
        delete pszResName;
    }

    if (pszResType)
    {
        delete pszResType;
    }


    EProtDebugOut((DEB_PLUGPROT, "%p OUT CResProtocol::GetResource (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::ParseAndBind
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CResProtocol::ParseAndBind(BOOL fBind)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CResProtocol::ParseAndBind\n", this));

    HRESULT hr = MK_E_SYNTAX;

    WCHAR wzlURL[MAX_URL_SIZE];

    wcscpy(wzlURL, _wzFullURL);


    do
    {
        // check if protocol part
        LPWSTR pwz = wcschr(wzlURL, ':');

        pwz++;

        if (wcsnicmp(pwz, L"//", 2) && wcsnicmp(pwz, L"\\\\", 2))
        {
            break;
        }

        // find the file name and path
        LPWSTR pwzFileName = pwz + 2;

        EProtAssert((pwzFileName));

        // the file is
        LPWSTR pwz1 = wcsrchr(wzlURL, '/');

        if (!pwz1)
        {
            break;
        }

        *pwz1 = '\0';
        pwz1++;

        if (!*pwz1)
        {
            break;
        }
#ifdef WITH_TAGS
        LPWSTR pwzResDelimiter = wcschr(pwz1, '?');

        if (!pwzResDelimiter)
        {
            break;
        }

        LPWSTR pwzResTag = wcsstr(pwz1, L"name:");

        if (!pwzResTag)
        {
            break;
        }

        LPWSTR pwzTypeTag = wcsstr(pwz1, L"type:");

        if (!pwzTypeTag)
        {
            break;
        }

        LPWSTR pwzMimeTag = wcsstr(pwz1, L"mime:");

        // get the resource name
        LPWSTR pwzResName = wcschr(pwzResTag, ':');
        pwzResName++;

        //find the end of the resource name
        LPWSTR pwzResType = wcschr(pwzTypeTag, ':');
        pwzResType++;

        LPWSTR pwzMime = 0;
        if (pwzMimeTag)
        {
            pwzMime = wcschr(pwzMimeTag, ':');
            pwzMime++;
            *pwzMimeTag = 0;
        }

        *pwzResTag = 0;
        *pwzTypeTag = 0;


#else
        // find the delimiter for the private part
        LPWSTR pwzResName = wcschr(pwz1, '?');

        if (!pwzResName)
        {
            break;
        }

        // get the resource name
        pwzResName++;

        //find the end of the resource name
        LPWSTR pwzResType = wcschr(pwzResName, ' ');

        if (!pwzResType)
        {
            break;
        }

        *pwzResType = '\0';
        pwzResType++;
        EProtDebugOut((DEB_PLUGPROT, "CResProtocol::GetResource (wzResName:%ws,pwzResType:%ws\n)",pwzResName,pwzResType));


        /*
        {
            pwzResType =  (LPWSTR)MAKEINTRESOURCE(RT_ICON);
            EProtDebugOut((DEB_PLUGPROT, "CResProtocol::GetResource (wzResName:%ws,pwzResType:RT_ICON\n)",pwzResName));
        }
        */
#endif //WITH_TAGS


        EProtAssert(((WCHAR *)pwzFileName && (WCHAR *)pwzResName));
        if (fBind && pwzFileName && pwzResName && pwzResType)
        {
            hr = GetResource(pwzFileName, pwzResName, pwzResType, pwzMime);
        }

        break;

    }  while (1);


    if (hr == MK_E_SYNTAX)
    {
        _pProtSink->ReportResult(hr, 0, 0);
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CResProtocol::ParseAndBind (hr:%lx)\n", this,hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\eapp\plugdll.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       plugdll.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <eapp.h>


#define SZFILTERROOT        "PROTOCOLS\\Filter\\"
#define SZPROTOCOLROOT      "PROTOCOLS\\Handler\\"
#define SZCLASS             "CLSID"
#define SZHANDLER           "HANDLER"

#ifdef EAPP_TEST
const GUID CLSID_ResProtocol        = {0x79eaca00, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}};
const GUID CLSID_OhServNameSp       = {0x79eaca01, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}};
const GUID CLSID_MimeHandlerTest1   = {0x79eaca02, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}};


const GUID CLSID_NotificaitonTest1  = {0xc733e501, 0x576e, 0x11d0, {0xb2, 0x8c, 0x00, 0xc0, 0x4f, 0xd7, 0xcd, 0x22}};
const GUID CLSID_NotificaitonTest2  = {0xc733e502, 0x576e, 0x11d0, {0xb2, 0x8c, 0x00, 0xc0, 0x4f, 0xd7, 0xcd, 0x22}};
const GUID CLSID_NotificaitonTest3  = {0xc733e503, 0x576e, 0x11d0, {0xb2, 0x8c, 0x00, 0xc0, 0x4f, 0xd7, 0xcd, 0x22}};
const GUID CLSID_NotificaitonTest4  = {0xc733e504, 0x576e, 0x11d0, {0xb2, 0x8c, 0x00, 0xc0, 0x4f, 0xd7, 0xcd, 0x22}};
#endif // EAPP_TEST

//****************************** CLSID for pluggable protocols and filters
const GUID CLSID_StdEncodingFilterFac= {0x54c37cd0, 0xd944, 0x11d0, {0xa9, 0xf4, 0x00, 0x60, 0x97, 0x94, 0x23, 0x11}};
const GUID CLSID_DeCompMimeFilter   = {0x8f6b0360, 0xb80d, 0x11d0, {0xa9, 0xb3, 0x00, 0x60, 0x97, 0x94, 0x23, 0x11}};
const GUID CLSID_CdlProtocol        = {0x3dd53d40, 0x7b8b, 0x11d0, {0xb0, 0x13, 0x00, 0xaa, 0x00, 0x59, 0xce, 0x02}};
const GUID CLSID_ClassInstallFilter = {0x32b533bb, 0xedae, 0x11d0, {0xbd, 0x5a, 0x0, 0xaa, 0x0, 0xb9, 0x2a, 0xf1}};

DECLARE_INFOLEVEL(EProt)
HINSTANCE g_hInst = NULL;

HINSTANCE g_hInst_LZDHtml = NULL;
HINSTANCE g_hInst_Deflate = NULL;
HINSTANCE g_hInst_GZIP = NULL;

// global variables
CRefCount g_cRef(0);        // global dll refcount

#define DLL_NAME      "plugprot.dll"

STDAPI_(BOOL) TlsDllMain(HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved);

#ifdef EAPP_TEST
#define HANDLER_RES                            SZPROTOCOLROOT"res"
#define PROTOCOL_RES_CLSID                     "{79eaca00-baf9-11ce-8c82-00aa004ba90b}"
#define PROTOCOL_RES_CLSID_REGKEY              "CLSID\\"PROTOCOL_RES_CLSID
#define PROTOCOL_RES_DESCRIP                   "res: Asychronous Pluggable Protocol Handler"

// protocols
//***** PROTOCOL_RES ENTRIES *****
const REGENTRY rgClassesRes[] =
{
    STD_ENTRY(PROTOCOL_RES_CLSID_REGKEY, PROTOCOL_RES_DESCRIP),
    STD_ENTRY(PROTOCOL_RES_CLSID_REGKEY"\\InprocServer32", "%s"DLL_NAME),
        { KEYTYPE_STRING, PROTOCOL_RES_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

const REGENTRY rgHandlerRes   [] = { STD_ENTRY(HANDLER_RES  , PROTOCOL_RES_DESCRIP  ), { KEYTYPE_STRING, HANDLER_RES  , "CLSID", REG_SZ, (BYTE*)PROTOCOL_RES_CLSID   } };

#define NAMESPACE_OHSERV                SZNAMESPACEROOT"http\\ohserv"
#define NAMESPACE_OHSERV_DESCRIP       "Asychronous Pluggable NameSpace Handler for http to ohserv"
#define NAMESPACE_OHSERV_CLSID         "{79eaca01-baf9-11ce-8c82-00aa004ba90b}"
#define NAMESPACE_OHSERV_CLSID_REGKEY  "CLSID\\"NAMESPACE_OHSERV_CLSID
#define NAMESPACE_OHSERV_PROTOCOL       NAMESPACE_OHSERV

const REGENTRY rgClassesOhserv[] =
{
    STD_ENTRY(NAMESPACE_OHSERV_CLSID_REGKEY, NAMESPACE_OHSERV_DESCRIP),
    STD_ENTRY(NAMESPACE_OHSERV_CLSID_REGKEY"\\InprocServer32", "%s"DLL_NAME),
        { KEYTYPE_STRING, NAMESPACE_OHSERV_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

const REGENTRY rgNameSpaceOhserv  [] = 
{ 
    STD_ENTRY(NAMESPACE_OHSERV , NAMESPACE_OHSERV_DESCRIP  ), 
    { KEYTYPE_STRING, NAMESPACE_OHSERV , "CLSID", REG_SZ, (BYTE*)NAMESPACE_OHSERV_CLSID   } 
};


#define PROT_FILTER_TEST1               SZFILTERROOT"text/html"
#define PROT_FILTER_TEST1_DESCRIP       "Asychronous Pluggable Mime Handler for text/mhtml"
#define PROT_FILTER_TEST1_CLSID         "{79eaca02-baf9-11ce-8c82-00aa004ba90b}"
#define PROT_FILTER_TEST1_CLSID_REGKEY  "CLSID\\"PROT_FILTER_TEST1_CLSID
#define PROT_FILTER_TEST1_PROTOCOL      PROT_FILTER_TEST1

const REGENTRY rgClassesMimeHandlerTest1[] =
{
    STD_ENTRY(PROT_FILTER_TEST1_CLSID_REGKEY, PROT_FILTER_TEST1_DESCRIP),
    STD_ENTRY(PROT_FILTER_TEST1_CLSID_REGKEY"\\InprocServer32", "%s"DLL_NAME),
        { KEYTYPE_STRING, PROT_FILTER_TEST1_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

const REGENTRY rgMimeHandlerTest1  [] = 
{ 
    STD_ENTRY(PROT_FILTER_TEST1 , PROT_FILTER_TEST1_DESCRIP  ), 
    { KEYTYPE_STRING, PROT_FILTER_TEST1 , "CLSID", REG_SZ, (BYTE*)PROT_FILTER_TEST1_CLSID   } 
};
#endif // EAPP_TEST

//*************************** Registry keys for CDL protocol handler

#define HANDLER_CDL                            SZPROTOCOLROOT"cdl"
#define PROTOCOL_CDL_CLSID                     "{3dd53d40-7b8b-11D0-b013-00aa0059ce02}"
#define PROTOCOL_CDL_CLSID_REGKEY              "CLSID\\"PROTOCOL_CDL_CLSID
#define PROTOCOL_CDL_DESCRIP                   "CDL: Asychronous Pluggable Protocol Handler"

const REGENTRY rgHandlerCdl[] = 
{ 
    STD_ENTRY(HANDLER_CDL  , PROTOCOL_CDL_DESCRIP  ), 
        { KEYTYPE_STRING, HANDLER_CDL  , "CLSID", REG_SZ, (BYTE*)PROTOCOL_CDL_CLSID   } 
};

const REGENTRY rgClassesCdl[] =
{
    STD_ENTRY(PROTOCOL_CDL_CLSID_REGKEY, PROTOCOL_CDL_DESCRIP),
    STD_ENTRY(PROTOCOL_CDL_CLSID_REGKEY"\\InprocServer32", "%s"DLL_NAME),
        { KEYTYPE_STRING, PROTOCOL_CDL_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

//*************************** Registry keys for Class Install Handler protocol filter

#define PROT_FILTER_CLASS               SZFILTERROOT"Class Install Handler"
#define PROT_FILTER_CLASS_DESCRIP       "AP Class Install Handler filter"
#define PROT_FILTER_CLASS_CLSID         "{32B533BB-EDAE-11d0-BD5A-00AA00B92AF1}"
#define PROT_FILTER_CLASS_CLSID_REGKEY  "CLSID\\"PROT_FILTER_CLASS_CLSID
#define PROT_FILTER_CLASS_PROTOCOL      PROT_FILTER_CLASS

const REGENTRY rgClassesMimeInstallHandler[] =
{
    STD_ENTRY(PROT_FILTER_CLASS_CLSID_REGKEY, PROT_FILTER_CLASS_DESCRIP),
    STD_ENTRY(PROT_FILTER_CLASS_CLSID_REGKEY"\\InprocServer32", "%s"DLL_NAME),
        { KEYTYPE_STRING, PROT_FILTER_CLASS_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

const REGENTRY rgMimeInstallHandler[] = 
{ 
    STD_ENTRY(PROT_FILTER_CLASS , PROT_FILTER_CLASS_DESCRIP  ), 
        { KEYTYPE_STRING, PROT_FILTER_CLASS, "CLSID", REG_SZ, (BYTE*)PROT_FILTER_CLASS_CLSID   } 
};

//*************************** Registry keys for ENC & Deflate protocol filters

#define PROT_FILTER_ENC                 SZFILTERROOT"lzdhtml"
#define PROT_FILTER_ENC_DESCRIP         "AP lzdhtml encoding/decoding Filter"
#define PROT_FILTER_ENC_CLSID           "{8f6b0360-b80d-11d0-a9b3-006097942311}"
#define PROT_FILTER_ENC_CLSID_REGKEY    "CLSID\\"PROT_FILTER_ENC_CLSID
#define PROT_FILTER_ENC_PROTOCOL        PROT_FILTER_ENC

const REGENTRY rgClassesMimeHandlerEnc[] =
{
    STD_ENTRY(PROT_FILTER_ENC_CLSID_REGKEY, PROT_FILTER_ENC_DESCRIP),
    STD_ENTRY(PROT_FILTER_ENC_CLSID_REGKEY"\\InprocServer32", "%s"DLL_NAME),
        { KEYTYPE_STRING, PROT_FILTER_ENC_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

const REGENTRY rgMimeHandlerEnc  [] = 
{ 
    STD_ENTRY(PROT_FILTER_ENC , PROT_FILTER_ENC_DESCRIP  ), 
    { KEYTYPE_STRING, PROT_FILTER_ENC , "CLSID", REG_SZ, (BYTE*)PROT_FILTER_ENC_CLSID   } 
};

#define PROT_FILTER_DEFLATE            SZFILTERROOT"deflate"
#define PROT_FILTER_DEFLATE_DESCRIP    "AP Deflate Encoding/Decoding Filter "
#define PROT_FILTER_DEFLATE_CLSID      "{8f6b0360-b80d-11d0-a9b3-006097942311}"

const REGENTRY rgDeflateEnc  [] = 
{ 
    STD_ENTRY(PROT_FILTER_DEFLATE , PROT_FILTER_DEFLATE_DESCRIP  ), 
    { KEYTYPE_STRING, PROT_FILTER_DEFLATE , "CLSID", REG_SZ, (BYTE*)PROT_FILTER_DEFLATE_CLSID   } 
};

#define PROT_FILTER_GZIP               SZFILTERROOT"gzip"
#define PROT_FILTER_GZIP_DESCRIP       "AP GZIP Encoding/Decoding Filter "
#define PROT_FILTER_GZIP_CLSID         "{8f6b0360-b80d-11d0-a9b3-006097942311}"

const REGENTRY rgGZIPEnc  [] = 
{ 
    STD_ENTRY(PROT_FILTER_GZIP , PROT_FILTER_GZIP_DESCRIP  ), 
    { KEYTYPE_STRING, PROT_FILTER_GZIP , "CLSID", REG_SZ, (BYTE*)PROT_FILTER_GZIP_CLSID   } 
};

#define STD_ENC_FAC_CLSID           "{54c37cd0-d944-11d0-a9f4-006097942311}" 
#define STD_ENC_FAC_CLSID_REGKEY    "CLSID\\"STD_ENC_FAC_CLSID
const REGENTRY rgClassesStdEncFac[] =
{
    STD_ENTRY(STD_ENC_FAC_CLSID_REGKEY"\\InprocServer32", "%s"DLL_NAME),
        { KEYTYPE_STRING, STD_ENC_FAC_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};




#ifdef EAPP_TEST
// notificaition sink

#define NOTIFICATION_SINK_TEST1_DESCRIP                      "Notification Sink Test1"
#define NOTIFICATION_SINK_TEST1_CLSID                        "{c733e501-576e-11d0-b28c-00c04fd7cd22}"
#define NOTIFICATION_SINK_TEST1_CLSID_REGKEY                 "CLSID\\"NOTIFICATION_SINK_TEST1_CLSID
#define NOTIFICATION_SINK_TEST1_CLSID_REGKEY                 "CLSID\\"NOTIFICATION_SINK_TEST1_CLSID

const REGENTRY rgNotSinkTest1[] =
{
    //***** NOTIFICATION_SINK_TEST1 ENTRIES *****
    STD_ENTRY(NOTIFICATION_SINK_TEST1_CLSID_REGKEY, NOTIFICATION_SINK_TEST1_DESCRIP),
    STD_ENTRY(NOTIFICATION_SINK_TEST1_CLSID_REGKEY"\\InprocServer32", "%s"DLL_NAME),
        { KEYTYPE_STRING, NOTIFICATION_SINK_TEST1_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};


#define NOTIFICATION_SINK_TEST2_DESCRIP                      "Notification Sink Test2"
#define NOTIFICATION_SINK_TEST2_CLSID                        "{c733e502-576e-11d0-b28c-00c04fd7cd22}"
#define NOTIFICATION_SINK_TEST2_CLSID_REGKEY                 "CLSID\\"NOTIFICATION_SINK_TEST2_CLSID
#define NOTIFICATION_SINK_TEST2_CLSID_REGKEY                 "CLSID\\"NOTIFICATION_SINK_TEST2_CLSID

const REGENTRY rgNotSinkTest2[] =
{
    //***** NOTIFICATION_SINK_TEST2 ENTRIES *****
    STD_ENTRY(NOTIFICATION_SINK_TEST2_CLSID_REGKEY, NOTIFICATION_SINK_TEST2_DESCRIP),
    STD_ENTRY(NOTIFICATION_SINK_TEST2_CLSID_REGKEY"\\InprocServer32", "%s"DLL_NAME),
        { KEYTYPE_STRING, NOTIFICATION_SINK_TEST2_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};


#define NOTIFICATION_SINK_TEST3_DESCRIP                      "Notification Sink Test3"
#define NOTIFICATION_SINK_TEST3_CLSID                        "{c733e503-576e-11d0-b28c-00c04fd7cd22}"
#define NOTIFICATION_SINK_TEST3_CLSID_REGKEY                 "CLSID\\"NOTIFICATION_SINK_TEST3_CLSID
#define NOTIFICATION_SINK_TEST3_CLSID_REGKEY                 "CLSID\\"NOTIFICATION_SINK_TEST3_CLSID

const REGENTRY rgNotSinkTest3[] =
{
    //***** NOTIFICATION_SINK_TEST3 ENTRIES *****
    STD_ENTRY(NOTIFICATION_SINK_TEST3_CLSID_REGKEY, NOTIFICATION_SINK_TEST3_DESCRIP),
    STD_ENTRY(NOTIFICATION_SINK_TEST3_CLSID_REGKEY"\\InprocServer32", "%s"DLL_NAME),
        { KEYTYPE_STRING, NOTIFICATION_SINK_TEST3_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};


#define NOTIFICATION_SINK_TEST4_DESCRIP                      "Notification Sink Test4"
#define NOTIFICATION_SINK_TEST4_CLSID                        "{c733e504-576e-11d0-b28c-00c04fd7cd22}"
#define NOTIFICATION_SINK_TEST4_CLSID_REGKEY                 "CLSID\\"NOTIFICATION_SINK_TEST4_CLSID
#define NOTIFICATION_SINK_TEST4_CLSID_REGKEY                 "CLSID\\"NOTIFICATION_SINK_TEST4_CLSID

const REGENTRY rgNotSinkTest4[] =
{
    //***** NOTIFICATION_SINK_TEST4 ENTRIES *****
    STD_ENTRY(NOTIFICATION_SINK_TEST4_CLSID_REGKEY, NOTIFICATION_SINK_TEST4_DESCRIP),
    STD_ENTRY(NOTIFICATION_SINK_TEST4_CLSID_REGKEY"\\InprocServer32", "%s"DLL_NAME),
        { KEYTYPE_STRING, NOTIFICATION_SINK_TEST4_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};
#endif // EAPP_TEST



const REGENTRYGROUP rgRegEntryGroups[] = {

#ifdef EAPP_TEST
    { HKEY_CLASSES_ROOT, rgClassesRes,      ARRAYSIZE(rgClassesRes) },
    { HKEY_CLASSES_ROOT, rgHandlerRes  ,    ARRAYSIZE(rgHandlerRes) },

    { HKEY_CLASSES_ROOT, rgClassesOhserv,   ARRAYSIZE(rgClassesOhserv) },
    { HKEY_CLASSES_ROOT, rgNameSpaceOhserv, ARRAYSIZE(rgNameSpaceOhserv) },

    { HKEY_CLASSES_ROOT, rgMimeHandlerTest1,        ARRAYSIZE(rgMimeHandlerTest1) },
    { HKEY_CLASSES_ROOT, rgClassesMimeHandlerTest1, ARRAYSIZE(rgClassesMimeHandlerTest1) },

    { HKEY_CLASSES_ROOT, rgNotSinkTest1  ,  ARRAYSIZE(rgNotSinkTest1) },
    { HKEY_CLASSES_ROOT, rgNotSinkTest2  ,  ARRAYSIZE(rgNotSinkTest2) },
    { HKEY_CLASSES_ROOT, rgNotSinkTest3  ,  ARRAYSIZE(rgNotSinkTest3) },
    { HKEY_CLASSES_ROOT, rgNotSinkTest4  ,  ARRAYSIZE(rgNotSinkTest4) },
#endif //EAPP_TEST

    { HKEY_CLASSES_ROOT, rgMimeHandlerEnc,        ARRAYSIZE(rgMimeHandlerEnc) },
    { HKEY_CLASSES_ROOT, rgClassesMimeHandlerEnc, ARRAYSIZE(rgClassesMimeHandlerEnc) },

    { HKEY_CLASSES_ROOT, rgDeflateEnc,        ARRAYSIZE(rgDeflateEnc) },
    { HKEY_CLASSES_ROOT, rgGZIPEnc,  ARRAYSIZE(rgGZIPEnc) },
    { HKEY_CLASSES_ROOT, rgClassesStdEncFac,  ARRAYSIZE(rgClassesStdEncFac) },
    
    { HKEY_CLASSES_ROOT, rgClassesMimeInstallHandler,      ARRAYSIZE(rgClassesMimeInstallHandler) },
    { HKEY_CLASSES_ROOT, rgMimeInstallHandler,             ARRAYSIZE(rgMimeInstallHandler) },

    { HKEY_CLASSES_ROOT, rgClassesCdl,      ARRAYSIZE(rgClassesCdl) },
    { HKEY_CLASSES_ROOT, rgHandlerCdl  ,    ARRAYSIZE(rgHandlerCdl) },

    { NULL, NULL, 0 }       // terminator
};


//+---------------------------------------------------------------------------
//
//  Function:   DllAddRef
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void DllAddRef(void)
{
    g_cRef++;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllRelease
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void DllRelease(void)
{
    EProtAssert((g_cRef > 0));
    if (g_cRef > 0)
    {
        g_cRef--;
    }
}

//+---------------------------------------------------------------------------
//
//  Operator:   new
//
//  Synopsis:
//
//  Arguments:  [size] --
//
//  Returns:
//
//  History:    11-07-96   JohannP (Johann Posch)   Created
//
//  Notes:      BUBUG: get and use IMalloc
//
//----------------------------------------------------------------------------
void * _cdecl operator new(size_t size)
{
    void * pBuffer;
    pBuffer = CoTaskMemAlloc(size);
    if (pBuffer)
    {
        memset(pBuffer,0, size);
    }
    return pBuffer;
}

//+---------------------------------------------------------------------------
//
//  Operator:   delete
//
//  Synopsis:
//
//  Arguments:  [lpv] --
//
//  Returns:
//
//  History:    2-14-96   JohannP (Johann Posch)   Created
//
//  Notes:      BUBUG: get and use IMalloc
//
//----------------------------------------------------------------------------
void _cdecl operator delete(void *lpv)
{
    if (lpv == NULL)
    {
        return;
    }

    CoTaskMemFree(lpv);
}

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Dll entry point
//
//  Arguments:  [clsid] - class id for new class
//              [iid] - interface required of class
//              [ppv] - where to put new interface
//
//  Returns:    S_OK - class object created successfully created.
//
//  History:    11-07-96   JohannP (Johann Posch)   Created
//
//--------------------------------------------------------------------------
STDAPI DllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv)
{
    EProtDebugOut((DEB_PLUGPROT, "API _IN DllGetClassObject\n"));

    HRESULT hr = E_FAIL;

#ifdef EAPP_TEST
    if (   (clsid == CLSID_ResProtocol)
        || (clsid == CLSID_OhServNameSp)
        || (clsid == CLSID_NotificaitonTest1)
        || (clsid == CLSID_NotificaitonTest2)
        || (clsid == CLSID_NotificaitonTest3)
        || (clsid == CLSID_NotificaitonTest4)
        || (clsid == CLSID_CdlProtocol)
        || (clsid == CLSID_DeCompMimeFilter)
        || (clsid == CLSID_MimeHandlerTest1)
        || (clsid == CLSID_StdEncodingFilterFac)
        || (clsid == CLSID_ClassInstallFilter) )
#else
    if(    (clsid == CLSID_DeCompMimeFilter)
        || (clsid == CLSID_StdEncodingFilterFac)
        || (clsid == CLSID_CdlProtocol)
        || (clsid == CLSID_ClassInstallFilter) )
#endif // EAPP_TEST
    {
        CUrlClsFact *pCF = NULL;
        hr = CUrlClsFact::Create(clsid, &pCF);
        if (hr == NOERROR)
        {
            EProtAssert((pCF != NULL));
            hr = pCF->QueryInterface(iid, ppv);
            pCF->Release();
        }
    }

    EProtDebugOut((DEB_PLUGPROT, "API OUT DllGetClassObject (hr:%lx, ppv:%p)\n",hr,*ppv));
    return hr;
}
//+-------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:
//
//  Arguments:  [hDll]          - a handle to the dll instance
//              [dwReason]      - the reason LibMain was called
//              [lpvReserved]   - NULL - called due to FreeLibrary
//                              - non-NULL - called due to process exit
//
//  Returns:    TRUE on success, FALSE otherwise
//
//  Notes:
//
//              The officially approved DLL entrypoint name is DllMain. This
//              entry point will be called by the CRT Init function.
//
//  History:    11-07-96   JohannP (Johann Posch)   Created
//
//--------------------------------------------------------------------------
BOOL WINAPI DllMain(HINSTANCE hInstance,DWORD dwReason,LPVOID lpvReserved)
{
    BOOL fResult = TRUE;
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
#if DBG==1
        {
            EProtInfoLevel = (DWORD) GetProfileIntA("UrlMon","EProt", (DEB_ERROR | DEB_WARN));
        }
#endif //DBG==1
        g_hInst = hInstance;
        //tsaMain.InitApp(NULL);

        //fResult = TlsDllMain(hInstance, dwReason, lpvReserved);
        break;

    case DLL_PROCESS_DETACH:
        if(g_hInst_LZDHtml) 
        {
            FreeLibrary(g_hInst_LZDHtml);
        }
        if(g_hInst_Deflate)
        {
            FreeLibrary(g_hInst_Deflate);
        }
        if(g_hInst_GZIP)
        {
            FreeLibrary(g_hInst_GZIP);
        }

        // Fall through

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        //fResult = TlsDllMain(hInstance, dwReason, lpvReserved);
        break;

    }
    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
    return (g_cRef ? S_FALSE : S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI DllRegisterServer()
{
    EProtDebugOut((DEB_PLUGPROT, "API _IN DllRegisterServer\n"));
    HRESULT hr;


    hr = HrDllRegisterServer(rgRegEntryGroups, g_hInst, NULL /*pfnLoadString*/);


    EProtDebugOut((DEB_PLUGPROT, "API OUT DllRegisterServer (hr:%lx)\n",hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllUnregisterServer
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI DllUnregisterServer()
{
    EProtDebugOut((DEB_PLUGPROT, "API _IN DllUnregisterServer\n"));
    HRESULT hr;

    hr = HrDllUnregisterServer(rgRegEntryGroups, g_hInst, NULL /*pfnLoadString*/);

    EProtDebugOut((DEB_PLUGPROT, "API OUT DllUnregisterServer (hr:%lx)\n",hr));
    return hr;
}


#if DBG==1

#include <sem.hxx>
CMutexSem   mxs;

IDebugOut *v_pEProtDbgOut = NULL;

LPCWSTR v_gDbgFacilitieNames[] =
{
     L"*/*"
    ,L"EProt"
    ,NULL
};

void EProtUrlSpy(int iOption, const char *pscFormat, ...)
{
    static char szOutBuffer[2048];
    CLock       lck(mxs);
    DWORD tid = GetCurrentThreadId();
    DWORD cbBufLen;
    sprintf(szOutBuffer,"%08x> ", tid );
    cbBufLen = strlen(szOutBuffer);

    va_list args;
    if (iOption & EProtInfoLevel)
    {
        va_start(args, pscFormat);
        wvsprintf(szOutBuffer + cbBufLen, pscFormat, args);
        va_end(args);
        UrlSpySendEntry(v_pEProtDbgOut, szOutBuffer, tid, iOption, 0);
    }
}

void UrlSpySendEntry(IDebugOut *pDbgOut, LPSTR szOutBuffer, DWORD ThreadId, DWORD dwFlags, DWORD dwReserved)
{
    if (pDbgOut)
    {
        pDbgOut->SendEntry(ThreadId, dwFlags, szOutBuffer, dwReserved);
    }
    else
    {
        OutputDebugString(szOutBuffer);
    }
}

HRESULT RegisterDebugOut(LPCWSTR pwzName, DWORD dwOptions, IDebugOut *pDbgOut, DWORD dwReserved)
{
    if (pwzName)
    {

        if (   (!wcsicmp(pwzName, L"*/*"))
            || (!wcsicmp(pwzName, L"EProt")) )
        {
            EProtInfoLevel = dwOptions;
            if (v_pEProtDbgOut)
            {
                v_pEProtDbgOut->Release();
                v_pEProtDbgOut = NULL;
            }
            if (pDbgOut)
            {

                v_pEProtDbgOut = pDbgOut;
                pDbgOut->AddRef();
            }

        }

    }

    return NOERROR;
}



void PerfDbgLogFn(int tag, void * pvObj, const char * pchFmt, ...)
{
    static char szOutBuffer[2048];
    static DWORD * apiLevel[] = { &EProtInfoLevel };
    static IDebugOut ** apDbgOut[] = { &v_pEProtDbgOut };
    int iIndex = min(tag >> DEB_LEVEL_SHIFT, 0);
    int iLevel = *apiLevel[iIndex];

    if ((tag & iLevel) == 0)
        return;

    CLock lck(mxs);
    DWORD tid = GetCurrentThreadId();
    DWORD cbBufLen;
    IDebugOut * pDbgOut = *apDbgOut[iIndex];

    sprintf(szOutBuffer, "%08x> %p %s", tid, pvObj,
        *pchFmt == '+' ? "_IN " : (*pchFmt == '-' ? "OUT " : ""));
    cbBufLen = strlen(szOutBuffer);

    if (*pchFmt == '+' || *pchFmt == '-')
        pchFmt += 1;

    va_list args;
    va_start(args, pchFmt);
    vsprintf(szOutBuffer + cbBufLen, pchFmt, args);
    lstrcat(szOutBuffer, "\n");
    va_end(args);
    UrlSpySendEntry(pDbgOut, szOutBuffer, tid, tag & DEB_LEVEL_MASK, 0);
}

#endif //DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\eapp\selfreg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       selfreg.cxx
//
//  Contents:   Taken from Office96
//              Source file for the common self registration code used by all the
//              sub projects of Sweeper project. They are
//              UrlMon
//              UrlMnPrx
//
//  Exports:    HrDllRegisterServer()
//              HrDllUnregisterServer()
//
//  Classes:
//
//  Functions:
//
//  History:    5-03-96   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <eapp.h>

HINSTANCE g_hinstDll = NULL;
PFNLOADSTRING g_pfnLoadString = NULL;

//+---------------------------------------------------------------------------
//
//  Function:   GetDllFullPath
//
//  Synopsis:
//
//  Arguments:  [lpszExeName] --
//              [cch] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL GetDllFullPath( LPSTR lpszExeName, DWORD cch )
{
    if ( NULL == g_hinstDll )
    {
        EProtAssert(( FALSE && "NULL hInst"));
        return FALSE;
    }

    *lpszExeName = NULL;

    if ( GetModuleFileName( g_hinstDll, lpszExeName, cch ) == 0)
    {
        EProtAssert(( FALSE && "GetModuleFileName Failed"));
        return FALSE;
    }

    return TRUE;
}


inline BOOL IsASeparator( char ch )
{
    return (ch == '\\' || ch == '/' || ch == ':');
}

//+---------------------------------------------------------------------------
//
//  Function:   ParseAFileName
//
//  Synopsis:
//
//  Arguments:  [szFileName] --
//              [piRetLen] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
LPSTR ParseAFileName( LPSTR szFileName, int *piRetLen)
{
    LPSTR pszFile;

    // Start at the end of the filename.
    pszFile = szFileName + ( lstrlen(szFileName) - 1 );

    // Back up to a '\\' or beginning or something!! We just want a file
    // name!. Whatever comes first.
    while ( pszFile > szFileName && !IsASeparator(*pszFile ) )
        pszFile = CharPrev(szFileName, pszFile);

    if ( pszFile != szFileName )
        pszFile = CharNext(pszFile);

    if ( piRetLen )
        *piRetLen = lstrlen(pszFile);

    return pszFile;
}


//+---------------------------------------------------------------------------
//
//  Function:   FRegisterEntries
//
//  Synopsis:   FRegisterEntries: Register a group of reg entries off a base key.
//
//  Arguments:  [hkRoot] --
//              [rgEntries] --
//              [dwEntries] --
//              [pszPath] --
//              [pszBinderName] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL FRegisterEntries(HKEY hkRoot, const REGENTRY rgEntries[],
                    DWORD dwEntries, char *pszPath, char *pszBinderName)
{
    HKEY    hkey = NULL;
    LONG    lRet;
    char    szValue[1024];
    char    szResString[1024];
    char    szKeyName[1024];
    BOOL    fRet = FALSE;
    int         i;

    for (i = 0; i < (int)dwEntries; i++)
    {
        // We work with a copy of the entry, since we might modify it
        REGENTRY reCurrentEntry = rgEntries[i];

        if (reCurrentEntry.iKeyType ==  KEYTYPE_RESID)
        {
            int cch;
            if (g_pfnLoadString == NULL)
                return FALSE;
            cch = g_pfnLoadString(g_hinstDll, (UINT)reCurrentEntry.pszKey, szKeyName,
                    sizeof(szKeyName));
            if (cch > 0 && cch <= 1024)
            {
                reCurrentEntry.pszKey = szKeyName;
            }
            else
            {
                EProtAssert(( FALSE && "LoadString Failed ( 1)"));
                continue;
            }
        }

        lRet = RegCreateKey(hkRoot, reCurrentEntry.pszKey, &hkey);

        if (lRet != ERROR_SUCCESS)
        {
            EProtAssert(( FALSE && "RegCreateKey Failed ( 1)"));
            continue;
        }

         // If the type is REG_RESID, then pbData holds the resource ID.  We
         // load the resource string, then modify our reCurrentEntry to point
         // to it.

        if (reCurrentEntry.dwType == REG_RESID)
        {
            int cch;
            if (g_pfnLoadString == NULL)
                return FALSE;

            cch = g_pfnLoadString(g_hinstDll, (UINT)reCurrentEntry.pbData, szResString,
                    sizeof(szResString));
            if (cch > 0 && cch <= 1024)
            {
                reCurrentEntry.dwType = REG_SZ;
                reCurrentEntry.pbData = (BYTE*) szResString;
            }
            else
            {
                EProtAssert(( FALSE && "LoadString Failed (2)"));
                reCurrentEntry.pbData = NULL;
            }
        }


        // Set the value if there is one
        if (reCurrentEntry.pbData != NULL || reCurrentEntry.dwType != REG_SZ)
        {
            switch (reCurrentEntry.dwType)
            {
                case REG_SZ:
                    // Replace the first %s with the path, and the second
                    // %s with the name of the binder app (may not do anything).
                    if (pszPath != NULL && pszBinderName != NULL)
                    {
                        wsprintf(szValue, (char*)reCurrentEntry.pbData, pszPath,
                            pszBinderName);

                        lRet = RegSetValueEx(hkey, reCurrentEntry.pszValueName, 0,
                            REG_SZ, (BYTE*)szValue, lstrlen(szValue)+1);
#if DBG == 1
                        if ( ERROR_SUCCESS != lRet )
                            EProtAssert(( FALSE && "RegSetValueEx Failed ( 1)"));
#endif
                    }
                    break;

                case REG_DWORD:
                    lRet = RegSetValueEx(hkey, reCurrentEntry.pszValueName, 0,
                        REG_DWORD,  (BYTE*)&reCurrentEntry.pbData, sizeof(DWORD));

#if DBG == 1
                    if ( ERROR_SUCCESS != lRet )
                        EProtAssert(( FALSE && "RegSetValueEx Failed (2)"));
#endif
                    break;

                default:
                    EProtAssert(( FALSE && "Unexpected reg entry type"));
                    // Unexpected type: ignore
                    break;
            }
        }

        // Close the subkey
        RegCloseKey(hkey);
        hkey = NULL;
    }

    fRet = TRUE;

    // Close the base key if it was open
    if (hkey)
        RegCloseKey(hkey);

    return fRet;
}


/*
 * FRegisterEntryGroups: Register several groups of reg entries.
 */
BOOL FRegisterEntryGroups(const REGENTRYGROUP *rgRegEntryGroups,
    char *pszPath, char *pszBinderName)
{
    BOOL fError = FALSE;
    int i;

    // Keep going even if we get some errors
    for (i=0; rgRegEntryGroups[i].hkRoot != NULL; i++)
    {
        if (!FRegisterEntries(rgRegEntryGroups[i].hkRoot, rgRegEntryGroups[i].rgEntries,
            rgRegEntryGroups[i].dwEntries,pszPath, pszBinderName))
        {
            fError = TRUE;
        }
    }

    return !fError;
}

//+---------------------------------------------------------------------------
//
//  Function:   FDeleteEntries
//
//  Synopsis:   Delete a group of reg entries off a base key.
//
//  Arguments:  [hkRoot] --
//              [rgEntries] --
//              [dwEntries] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL FDeleteEntries(HKEY hkRoot, const REGENTRY rgEntries[], DWORD dwEntries)
{
    LONG    lRet;
    int         i;
    char    szKeyName[1024];
    PSTR    pKey;

    // Delete in reverse order, to kill children before parent
    for (i = (int)dwEntries - 1; i >= 0; i--)
    {
        pKey = NULL;

        if (rgEntries[i].iKeyType ==  KEYTYPE_RESID)
        {
            int cch;
            cch = g_pfnLoadString(g_hinstDll, (UINT)rgEntries[i].pszKey, szKeyName,
                    sizeof(szKeyName));
            if (cch > 0 && cch <= 1024)
            {
                pKey = szKeyName;
            }
        else
            {
                EProtAssert(( FALSE && "LoadString Failed (FDeleteEntries)"));
                continue;
            }
        }
        else
        {
            if ( KEYTYPE_STRING != rgEntries[i].iKeyType )
            {
                EProtAssert(( FALSE && "Unknown Key Type"));
                continue;
            }
            pKey = rgEntries[i].pszKey;
        }

        if (pKey != NULL)
        {
            // Delete the current key if it has no subkeys.
            // Ignore the return value.
            lRet = RegDeleteKey(hkRoot, pKey);
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   FDeleteEntryGroups
//
//  Synopsis:   Delete the base keys of all the given groups.

//
//  Arguments:  [rgRegEntryGroups] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL FDeleteEntryGroups(const REGENTRYGROUP *rgRegEntryGroups)
{
    BOOL fError = FALSE;

    // Keep going even if we get some errors
    for (int i=0; rgRegEntryGroups[i].hkRoot != NULL; i++)
    {
        if (!FDeleteEntries(rgRegEntryGroups[i].hkRoot,
            rgRegEntryGroups[i].rgEntries,
            rgRegEntryGroups[i].dwEntries))
        {
            fError = TRUE;
        }
    }

    return !fError;
}


#ifdef NOT_USED
/*
 * FDeleteSubtree - Delete given key and all subkeys
 */
BOOL FDeleteSubtree(HKEY hkRoot, char *pszKey)
{
    HKEY        hkey = NULL;
    LONG        lRet;
    char        szSubKey[MAX_PATH];

    lRet = RegOpenKey(hkRoot, pszKey, &hkey);
    if (lRet != ERROR_SUCCESS)
        goto End;

    // remove all subkeys
    for (;;)
{
        lRet = RegEnumKey(hkey, 0, szSubKey, sizeof szSubKey);

        if (lRet == ERROR_NO_MORE_ITEMS)
            break;

        if (lRet != ERROR_SUCCESS)
            goto End;

        if (!FDeleteSubtree(hkey, szSubKey))
            goto End;
}

End:
    if (hkey != NULL)
        RegCloseKey (hkey);

    lRet = RegDeleteKey(hkRoot, pszKey);

    return (lRet == ERROR_SUCCESS);
}
#endif // NOT_USED



//+---------------------------------------------------------------------------
//
//  Function:   HrDllRegisterServer
//
//  Synopsis:   registers an entrygroup
//
//  Arguments:  [HINSTANCE] --
//              [hinstDll] --
//              [pfnLoadString] --
//              [pszAppName] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT HrDllRegisterServer(const REGENTRYGROUP *rgRegEntryGroups,HINSTANCE hinstDll,
                            PFNLOADSTRING pfnLoadString, char *pszAppName)
{
    // REVIEW: for Windows dll, do we want to register full path?
    BOOL    fRet = TRUE;
    char    szFullPath[MAX_PATH];
    char    szFileName[MAX_PATH];
    char    *pszFileName;

    g_hinstDll = hinstDll;
    if ((g_pfnLoadString = pfnLoadString) == NULL)
        // set the pointer to windows LoadString() api
        g_pfnLoadString = (PFNLOADSTRING) LoadString;

    if (!GetDllFullPath(szFullPath, MAX_PATH))
        return E_FAIL;

    pszFileName = ParseAFileName(szFullPath, NULL);

    if (pszAppName != NULL)
        lstrcpy(szFileName, pszAppName);
    else
        lstrcpy(szFileName, pszFileName);

    // Terminate the path at the file name
    *pszFileName = '\0';
    fRet = FRegisterEntryGroups(rgRegEntryGroups, szFullPath, szFileName);

    g_hinstDll = NULL;
    g_pfnLoadString = NULL;
    return fRet ? NOERROR : E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrDllUnregisterServer
//
//  Synopsis:   unregisters an entrygroup
//
//  Arguments:  [HINSTANCE] --
//              [hinstDll] --
//              [pfnLoadString] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT HrDllUnregisterServer(const REGENTRYGROUP *rgRegEntryGroups,HINSTANCE hinstDll, PFNLOADSTRING pfnLoadString)
{
    g_hinstDll = hinstDll;
    if ((g_pfnLoadString = pfnLoadString) == NULL)
        // set the pointer to windows LoadString() api
        g_pfnLoadString = (PFNLOADSTRING) LoadString;

    FDeleteEntryGroups(rgRegEntryGroups);

    g_hinstDll = NULL;
    g_pfnLoadString = NULL;

    return NOERROR;
}




=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\eapp\protbase.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       protbase.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <eapp.h>

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::QueryInterface\n", this));

    hr = _pUnkOuter->QueryInterface(riid, ppvObj);

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::QueryInterface (hr:%lx\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CBaseProtocol::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBaseProtocol::AddRef(void)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::AddRef\n", this));

    LONG lRet = _pUnkOuter->AddRef();

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::AddRef (cRefs:%ld)\n", this,lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CBaseProtocol::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBaseProtocol::Release(void)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::Release\n", this));

    LONG lRet = _pUnkOuter->Release();

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::Release (cRefs:%ld)\n",this,lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Start
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pTrans] --
//              [pOIBindInfo] --
//              [grfSTI] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Start(LPCWSTR pwzUrl, IOInetProtocolSink *pTrans, IOInetBindInfo *pOIBindInfo,
                          DWORD grfSTI, DWORD_PTR dwReserved)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::Start\n", this));
    HRESULT hr = NOERROR;

    EProtAssert((!_pProtSink && pOIBindInfo && pTrans));
    EProtAssert((_pwzUrl == NULL));


    if ( !(grfSTI & PI_PARSE_URL))
    {
        _pProtSink = pTrans;
        _pProtSink->AddRef();

        _pOIBindInfo =  pOIBindInfo;
        _pOIBindInfo->AddRef();
    }

    _BndInfo.cbSize = sizeof(BINDINFO);
    hr = pOIBindInfo->GetBindInfo(&_grfBindF, &_BndInfo);

    // Do we need to append the extra data to the url?
    if (_BndInfo.szExtraInfo)
    {
        // append extra info at the end of the url
        // Make sure we don't overflow the URL
        if (wcslen(_BndInfo.szExtraInfo) + wcslen(pwzUrl) >= MAX_URL_SIZE)
        {
            hr = E_INVALIDARG;
            goto End;
        }

        wcscpy(_wzFullURL, pwzUrl);

        // Append the extra data to the url.  Note that we have already
        // checked for overflow, so we need not worry about it here.
        wcscat(_wzFullURL + wcslen(_wzFullURL), _BndInfo.szExtraInfo);
    }
    else
    {
        // Make sure we don't overflow the URL
        if (wcslen(pwzUrl) + 1 > MAX_URL_SIZE)
        {
            hr = E_INVALIDARG;
            goto End;
        }
        wcscpy(_wzFullURL, pwzUrl);
    }

    if ( !(grfSTI & PI_PARSE_URL))
    {
        // save the URL
        _pwzUrl = OLESTRDuplicate((LPCWSTR)pwzUrl);
    }

    _grfSTI = grfSTI;

End:

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::Start (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Continue
//
//  Synopsis:
//
//  Arguments:  [pStateInfoIn] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Continue(PROTOCOLDATA *pStateInfoIn)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::Continue\n", this));

    HRESULT hr = E_FAIL;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::Continue (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Abort
//
//  Synopsis:
//
//  Arguments:  [hrReason] --
//              [dwOptions] --
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Abort(HRESULT hrReason, DWORD dwOptions)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::Abort\n", this));
    HRESULT hr = NOERROR;

    EProtAssert((_pProtSink));

    hr = _pProtSink->ReportResult(E_ABORT, 0, 0);

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::Abort (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Terminate
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Terminate(DWORD dwOptions)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::Terminate\n", this));
    HRESULT hr = NOERROR;

    EProtAssert((_pProtSink));

    if (_pProt)
    {
        _pProt->Terminate(dwOptions);
        _pProt->Release();
        _pProt = NULL;
    }

    if (_pOIBindInfo)
    {
        _pOIBindInfo->Release();
        _pOIBindInfo = NULL;
    }
    if (_pProtSink)
    {
        _pProtSink->Release();
        _pProtSink = NULL;
    }

#if DBG == 1
    if ( _BndInfo.stgmedData.tymed != TYMED_NULL )
        EProtDebugOut((DEB_PLUGPROT, "%p --- CBaseProtocol::Terminate ReleaseStgMedium (%p)\n", this,_BndInfo.stgmedData));
#endif

    ReleaseBindInfo(&_BndInfo);

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::Terminate (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Suspend
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Suspend()
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::Suspend\n", this));

    HRESULT hr = E_NOTIMPL;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::Suspend (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Resume
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Resume()
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::Resume\n", this));

    HRESULT hr = E_NOTIMPL;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::Resume (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::SetPriority
//
//  Synopsis:
//
//  Arguments:  [nPriority] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::SetPriority(LONG nPriority)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::SetPriority\n", this));

    HRESULT hr = E_NOTIMPL;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::SetPriority (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::GetPriority
//
//  Synopsis:
//
//  Arguments:  [pnPriority] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::GetPriority(LONG * pnPriority)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::GetPriority\n", this));

    HRESULT hr = E_NOTIMPL;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::GetPriority (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Read
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//              [ULONG] --
//              [pcbRead] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Read(void *pv,ULONG cb,ULONG *pcbRead)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::Read\n", this));

    HRESULT hr = E_FAIL;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::Read (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Seek
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [ULARGE_INTEGER] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::Seek\n", this));

    HRESULT hr = E_FAIL;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::Seek (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::LockRequest
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::LockRequest(DWORD dwOptions)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::LockRequest\n", this));

    HRESULT hr = NOERROR;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::LockRequest (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::UnlockRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::UnlockRequest()
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::UnlockRequest\n", this));
    HRESULT hr = NOERROR;

    CloseTempFile();

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::UnlockRequest (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Prepare
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Prepare()
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::Prepare\n", this));
    HRESULT hr = NOERROR;

    EProtAssert((  IsApartmentThread() ));


    EProtDebugOut((DEB_PLUGPROT,"%p OUT CBaseProtocol::Prepare (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Continue
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Continue()
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::Continue\n", this));
    HRESULT hr = NOERROR;

    EProtAssert((  !IsApartmentThread() ));

    _dwThreadID = GetCurrentThreadId();

    EProtDebugOut((DEB_PLUGPROT,"%p OUT CBaseProtocol::Continue (hr:%lx)\n",this, hr));
    return hr;
}

STDMETHODIMP CBaseProtocol::QueryService(REFGUID rsid, REFIID riid, void ** ppvObj)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::QueryService \n", this));
    HRESULT     hr = NOERROR;
    VDATETHIS(this);
    EProtAssert((ppvObj));

    *ppvObj = 0;

    if (riid == IID_IHttpNegotiate)
    {
        IServiceProvider *pServProv = 0;

        if ((hr = _pUnkInner->QueryInterface(IID_IServiceProvider, (void **)&pServProv)) == NOERROR)
        {
            // hand back oo
            if ((hr = pServProv->QueryService(rsid, riid, ppvObj)) == NOERROR)
            {
                _pHttpNeg = new CHttpNegotiate((IHttpNegotiate *)*ppvObj);
                if (_pHttpNeg)
                {
                    *ppvObj = _pHttpNeg;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }

            pServProv->Release();
        }

    }
    else
    {
        IServiceProvider *pServProv = 0;

        if ((hr = _pUnkInner->QueryInterface(IID_IServiceProvider, (void **)&pServProv)) == NOERROR)
        {
            hr = pServProv->QueryService(rsid, riid, ppvObj);

            pServProv->Release();
        }
    }

    EProtAssert(( (hr == E_NOINTERFACE) || ((hr == NOERROR) && *ppvObj) ));

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::QueryService (hr:%lx) \n", this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::CBaseProtocol
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CBaseProtocol::CBaseProtocol(REFCLSID rclsid, IUnknown *pUnkOuter, IUnknown **ppUnkInner) : _CRefs(), _pclsidProtocol(rclsid), _Unknown()
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::CBaseProtocol \n", this));
    _dwThreadID = GetCurrentThreadId();
    _bscf = BSCF_FIRSTDATANOTIFICATION;
    _pOIBindInfo = 0;


    if (!pUnkOuter)
    {
        pUnkOuter = &_Unknown;
    }
    else
    {
        EProtAssert((ppUnkInner));
        if (ppUnkInner)
        {
            *ppUnkInner =  &_Unknown;
            _CRefs = 0;
        }
    }

    _pUnkOuter = pUnkOuter;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::CBaseProtocol \n", this));
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::~CBaseProtocol
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CBaseProtocol::~CBaseProtocol()
{

    if (_pUnkInner)
    {
        _pUnkInner->Release();
    }
    if (_pwzUrl)
    {
        delete _pwzUrl;
    }

    EProtAssert(( _hFile == NULL));

    if (_szTempFile[0] != '\0')
    {
        DeleteFile(_szTempFile);
    }

    EProtDebugOut((DEB_PLUGPROT, "%p _IN/OUT CBaseProtocol::~CBaseProtocol \n", this));
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::CPrivUnknown::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::CPrivUnknown::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::CPrivUnknown::QueryInterface\n", this));
    CBaseProtocol *pCBaseProtocol = GETPPARENT(this, CBaseProtocol, _Unknown);

    *ppvObj = NULL;

    if ((riid == IID_IUnknown) || (riid == IID_IOInetProtocol) || (riid == IID_IOInetProtocolRoot) )
    {
        *ppvObj = (IOInetProtocol *) pCBaseProtocol;
        pCBaseProtocol->AddRef();
    }
    else if (riid == IID_IOInetThreadSwitch)
    {
        *ppvObj = (IOInetThreadSwitch *)pCBaseProtocol;
        pCBaseProtocol->AddRef();
    }
    else if (riid == IID_IServiceProvider)
    {
        *ppvObj = (IServiceProvider *)pCBaseProtocol;
        pCBaseProtocol->AddRef();
    }
    else if (pCBaseProtocol->_pUnkInner)
    {
        hr = pCBaseProtocol->_pUnkInner->QueryInterface(riid, ppvObj);
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::CPrivUnknown::QueryInterface (hr:%lx\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CBaseProtocol::CPrivUnknown::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBaseProtocol::CPrivUnknown::AddRef(void)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::CPrivUnknown::AddRef\n", this));

    LONG lRet = ++_CRefs;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::CPrivUnknown::AddRef (cRefs:%ld)\n", this,lRet));
    return lRet;
}
//+---------------------------------------------------------------------------
//
//  Function:   CBaseProtocol::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBaseProtocol::CPrivUnknown::Release(void)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::CPrivUnknown::Release\n", this));

    CBaseProtocol *pCBaseProtocol = GETPPARENT(this, CBaseProtocol, _Unknown);

    LONG lRet = --_CRefs;

    if (lRet == 0)
    {
        delete pCBaseProtocol;
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::CPrivUnknown::Release (cRefs:%ld)\n",this,lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::OpenTempFile
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CBaseProtocol::OpenTempFile()
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::OpenTempFile\n", this));

    HANDLE hTempFile;
    BOOL fRet = FALSE;

    static char szTempPath[MAX_PATH+32] = {0};


    if (!szTempPath[0])
    {
        GetTempPath(MAX_PATH, szTempPath);
    }

    if (GetTempFileName(szTempPath, "Res", 0, _szTempFile))
    {
        // the file should be delete
        DWORD dwFileAtr = FILE_ATTRIBUTE_TEMPORARY;

        EProtDebugOut((DEB_PLUGPROT, "%p +++ CBaseProtocol::OpenTempFile (szFile:%s)\n",this, _szTempFile));
        hTempFile = CreateFile(_szTempFile, GENERIC_WRITE,FILE_SHARE_READ, NULL,CREATE_ALWAYS,dwFileAtr, NULL);

        if (hTempFile == INVALID_HANDLE_VALUE)
        {
            _hFile = NULL;
        }
        else
        {
            WCHAR    wzTempFile[MAX_PATH];
            A2W(_szTempFile,wzTempFile,MAX_PATH);

            _pProtSink->ReportProgress(BINDSTATUS_CACHEFILENAMEAVAILABLE, wzTempFile);
            _hFile = hTempFile;
            fRet = TRUE;
        }
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::OpenTempFile (_szTempFile:%s, fRet:%d)\n",this, _szTempFile, fRet));
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::CloseTempFile
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CBaseProtocol::CloseTempFile()
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::CloseTempFile\n", this));

    BOOL fRet = FALSE;

    if (_hFile)
    {
        CloseHandle(_hFile);
        _hFile = 0;
        fRet = TRUE;
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::CloseTempFile (fRet:%d)\n",this, fRet));
    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateAPP
//
//  Synopsis:
//
//  Arguments:  [rclsid] --
//              [pUnkOuter] --
//              [riid] --
//              [ppUnk] --
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CreateAPP(REFCLSID rclsid, IUnknown *pUnkOuter, REFIID riid, IUnknown **ppUnk)
{
    EProtDebugOut((DEB_PLUGPROT, "API _IN CreateKnownProtocolInstance\n"));
    HRESULT hr = NOERROR;

    EProtAssert((ppUnk));

    if (!ppUnk || (pUnkOuter && (riid != IID_IUnknown)) )
    {
        // Note: aggregation only works if asked for IUnknown
        EProtAssert((FALSE && "Dude, look up aggregation rules - need to ask for IUnknown"));
        hr = E_INVALIDARG;
    }
    else
    {
        CBaseProtocol *pCBaseProtocol = NULL;

        if (rclsid == CLSID_CdlProtocol)
        {
            pCBaseProtocol = new CCdlProtocol(CLSID_CdlProtocol,pUnkOuter, ppUnk);
        }

#ifdef TEST_EAPP
        else if (rclsid == CLSID_OhServNameSp)
        {
            pCBaseProtocol = new COhServNameSp(CLSID_OhServNameSp,pUnkOuter, ppUnk);
        }
        else if (rclsid == CLSID_MimeHandlerTest1)
        {
            pCBaseProtocol = new CMimeHandlerTest1(CLSID_MimeHandlerTest1,pUnkOuter, ppUnk);
        }
        else if (rclsid == CLSID_ResProtocol)
        {
            pCBaseProtocol = new CResProtocol(CLSID_ResProtocol,pUnkOuter, ppUnk);
        }
#endif

        if (pCBaseProtocol)
        {
            if (riid == IID_IUnknown)
            {

            }
            else if (riid == IID_IOInetProtocol)
            {
                // ok, got the right interface already
                *ppUnk = (IOInetProtocol *)pCBaseProtocol;
            }
            else
            {
                hr = pCBaseProtocol->QueryInterface(riid, (void **)ppUnk);
                // remove extra refcount
                pCBaseProtocol->Release();
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    EProtDebugOut((DEB_PLUGPROT, "API OUT CreateKnownProtocolInstance(hr:%lx)\n", hr));
    return hr;
}

HRESULT CBaseProtocol::ObtainService(REFGUID rsid, REFIID riid, void ** ppvObj)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CBaseProtocol::ObtainService \n", this));
    HRESULT     hr = NOERROR;
    VDATETHIS(this);
    LPVOID pvLocal = NULL;

#ifdef unusedXXX
    CBSCNode   *pNode;
    pNode = _pCBSCNode;

    if (riid == IID_IHttpNegotiate)
    {
        *ppvObj = (void*)(IHttpNegotiate *) this;
        AddRef();

        // loop once to get all interfaces
        if (!_fHttpNegotiate)
        {
            while (pNode)
            {
                if (   (pNode->GetBSCB()->QueryInterface(riid, &pvLocal) == NOERROR)
                    || (   pNode->GetServiceProvider()
                        && (pNode->GetHttpNegotiate() == NULL)
                        && (pNode->GetServiceProvider()->QueryService(riid, riid, &pvLocal)) == NOERROR)
                    )
                {
                    // Note: the interface is addref'd by QI or QS
                    pNode->SetHttpNegotiate((IHttpNegotiate *)pvLocal);
                }

                pNode = pNode->GetNextNode();
            }

            _fHttpNegotiate = TRUE;
        }
    }
    else if (riid == IID_IAuthenticate)
    {
        *ppvObj = (void*)(IAuthenticate *) this;
        AddRef();

        if (!_fAuthenticate)
        {
            while (pNode)
            {
                if (   (pNode->GetBSCB()->QueryInterface(riid, &pvLocal) == NOERROR)
                    || (   pNode->GetServiceProvider()
                        && (pNode->GetAuthenticate() == NULL)
                        && (pNode->GetServiceProvider()->QueryService(riid, riid, &pvLocal)) == NOERROR)
                    )
                {
                    // Note: the interface is addref'd by QI or QS
                    pNode->SetAuthenticate((IAuthenticate *)pvLocal);
                }

                pNode = pNode->GetNextNode();
            }

            _fAuthenticate = TRUE;
        }

    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;

        while (pNode)
        {
            if (   (pNode->GetBSCB()->QueryInterface(riid, &pvLocal) == NOERROR)
                || (   pNode->GetServiceProvider()
                    && (pNode->GetServiceProvider()->QueryService(riid, riid, &pvLocal)) == NOERROR)
                )
            {
                *ppvObj = pvLocal;
                hr = NOERROR;
                // Note: the interface is addref'd by QI or QS
                // stop looking at other nodes for this service
                pNode = NULL;
            }

            if (pNode)
            {
                pNode = pNode->GetNextNode();
            }
        }
    }
#endif //unused

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CBaseProtocol::ObtainService (hr:%lx) \n", this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CHttpNegotiate::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CHttpNegotiate::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    EProtDebugOut((DEB_PLUGPROT, "%p _IN CHttpNegotiate::QueryInterface\n", this));

    if ((riid == IID_IUnknown) || (riid == IID_IHttpNegotiate))
    {
        *ppvObj = (IHttpNegotiate *) this;
        AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CHttpNegotiate::QueryInterface (hr:%lx\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CHttpNegotiate::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CHttpNegotiate::AddRef(void)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CHttpNegotiate::AddRef\n", this));

    LONG lRet = ++_CRefs;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CHttpNegotiate::AddRef (cRefs:%ld)\n", this,lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CHttpNegotiate::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CHttpNegotiate::Release(void)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CHttpNegotiate::Release\n", this));

    LONG lRet = --_CRefs;

    if (lRet == 0)
    {
        delete this;
    }

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CHttpNegotiate::Release (cRefs:%ld)\n",this,lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CHttpNegotiate::BeginningTransaction
//
//  Synopsis:
//
//  Arguments:  [szURL] --
//              [szHeaders] --
//              [dwReserved] --
//              [pszAdditionalHeaders] --
//
//  Returns:
//
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CHttpNegotiate::BeginningTransaction(LPCWSTR szURL, LPCWSTR szHeaders,
            DWORD dwReserved, LPWSTR *pszAdditionalHeaders)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CHttpNegotiate::BeginningTransaction (szURL:%ws, szHeaders:%ws)\n", this, szURL, szHeaders));
    VDATETHIS(this);
    HRESULT    hr = NOERROR;
    LPWSTR     szTmp = NULL, szNew = NULL, szRunning = NULL;

    EProtAssert((szURL));


    EProtDebugOut((DEB_PLUGPROT, "%p OUT CHttpNegotiate::BeginningTransaction (pszAdditionalHeaders:%ws )\n", this, *pszAdditionalHeaders));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CHttpNegotiate::OnResponse
//
//  Synopsis:
//
//  Arguments:  [LPCWSTR] --
//              [szResponseHeaders] --
//              [LPWSTR] --
//              [pszAdditionalRequestHeaders] --
//
//  Returns:
//
//  History:    4-05-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CHttpNegotiate::OnResponse(DWORD dwResponseCode,LPCWSTR wzResponseHeaders,
                        LPCWSTR wzRequestHeaders,LPWSTR *pszAdditionalRequestHeaders)
{
    EProtDebugOut((DEB_PLUGPROT, "%p _IN CHttpNegotiate::OnResponse\n", this));
    VDATETHIS(this);
    HRESULT    hr;
    LPWSTR     szTmp = NULL, szNew = NULL, szRunning = NULL;

    hr = IsStatusOk(dwResponseCode) ? S_OK : S_FALSE;

    EProtDebugOut((DEB_PLUGPROT, "%p OUT CHttpNegotiate::OnResponse\n", this));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\iapp\cnethttp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cnethttp.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <iapp.h>
#include "shlwapip.h"
#ifndef unix
#include "..\trans\transact.hxx"
#include "..\trans\oinet.hxx"
#else
#include "../trans/transact.hxx"
#include "../trans/oinet.hxx"
#endif /* unix */

PerfDbgTag(tagCINetHttp, "Urlmon", "Log CINetHttp", DEB_PROT);

extern LPSTR g_pszUAInfoString;
static CHAR  gszAcceptEncHeaders[] = "Accept-Encoding: gzip, deflate";

// http specifics
static char vszGet[]    = "GET";
static char vszPost[]   = "POST";
static char vszPut[]    = "PUT";
static char vszAttachment[] = "attachment";
static char vszFileName[] = "filename";
static DWORD dwLstError;
DWORD GetRedirectSetting();

// list of content-type we should not apply content-encoding onto it.
static LPSTR  vszIgnoreContentEnc[] =
{
     "application/x-tar"
    ,"x-world/x-vrml"
    ,"application/zip"
    ,"application/x-gzip"
    ,"application/x-zip-compressed"
    ,"application/x-compress"
    ,"application/x-compressed"
    ,"application/x-spoon"
    , 0
};

BOOL IgnoreContentEncoding(LPSTR szContentType, LPSTR szEnc, LPSTR szAccept)
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "IgnoreContentEncoding",
                "%.80q, %.80q, %.80q",
                szContentType, szEnc, szAccept
                ));
                
    BOOL bRet = FALSE;

    if( szEnc && szAccept && !StrStrI(szAccept, szEnc) )
    {
        //
        // some of the old web server will ignore the schemas indicated at
        // Accept-Endocing: header, we need to add another check here
        // to make sure the server returned content-encoding is the
        // one we supported, otherwise, we will not init the decoder
        //
        bRet = TRUE;
    }

    if( !bRet )
    {
        for( int i = 0; vszIgnoreContentEnc[i]; i++)
        {
            if(!StrCmpI(szContentType, vszIgnoreContentEnc[i]) )
            {
                bRet = TRUE;
                break;
            }
        }
    }

    DEBUG_LEAVE(bRet);
    return bRet;
}




//+---------------------------------------------------------------------------
//
//  Function:   GetRedirectSetting
//
//  Synopsis:   Reads the registry UrlMon Setting of Redirect
//
//  Arguments:  (none)
//
//  Returns:    0 if redirect should be done by WinINet,
//              1 if should be done by UrlMon
//
//  History:    4-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD GetRedirectSetting()
{
    DEBUG_ENTER((DBG_APP,
                Dword,
                "GetRedirectSetting",
                NULL
                ));
                
    HKEY hUrlMonKey = NULL;
    DWORD dwType;
    static DWORD dwValue = 0xffffffff;

    if (dwValue == 0xffffffff)
    {
        DWORD dwValueLen = sizeof(DWORD);
        dwValue = 0;

        #define szUrlMonKey "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\UrlMon Settings"
        #define szRedirect  "Redirect"

        if (RegOpenKeyEx(HKEY_CURRENT_USER, szUrlMonKey, 0, KEY_QUERY_VALUE, &hUrlMonKey) == ERROR_SUCCESS)
        {
            if (RegQueryValueEx(hUrlMonKey, szRedirect, NULL, &dwType, (LPBYTE)&dwValue, &dwValueLen) != ERROR_SUCCESS)
            {
                dwValue = 0;
            }
            RegCloseKey(hUrlMonKey);
        }
    }

    DEBUG_LEAVE(dwValue);
    return dwValue;
}

// max version strlen = (5)"HTTP/" + (4)digits + (1)'.' + (4)digits + (1)'\0'
#define MAXVERSIONLEN 15
BOOL RequestUsedHttp10( 
    IN HINTERNET hHttpRequest
)
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "RequestUsedHttp10",
                "%#x",
                hHttpRequest
                ));
                
    char lpszHttpVersion[MAXVERSIONLEN];
    DWORD dwLen = MAXVERSIONLEN;
    BOOL fRet = FALSE;

    if (HttpQueryInfo(
            hHttpRequest, 
            HTTP_QUERY_FLAG_REQUEST_HEADERS | HTTP_QUERY_VERSION,
            (LPVOID)lpszHttpVersion,
            &dwLen,
            NULL))
    {
        if (0 == StrCmpNI("HTTP/1.0", lpszHttpVersion, dwLen))
            fRet = TRUE;
    }

    DEBUG_LEAVE(fRet);
    return fRet;
}
               
//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::CINetHttp
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetHttp::CINetHttp(REFCLSID rclsid, IUnknown *pUnkOuter) : CINet(rclsid,pUnkOuter)
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINetHttp::CINetHttp",
                "this=%#x, %#x, %#x",
                this, &rclsid, pUnkOuter
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::CINetHttp");

    _pHttpNeg = NULL;
    _pHttpNeg2 = NULL;
    _dwIsA = DLD_PROTOCOL_HTTP;
    _dwBufferSize = 0;
    _pBuffer = 0;
    _pszVerb = 0;
    _f2ndCacheKeySet = FALSE;


    PerfDbgLog(tagCINetHttp, this, "-CINetHttp::CINetHttp");

    DEBUG_LEAVE(0);
}

//----------------------------------------------------------------------------
//
//  Method:     CINetHttp::~CINetHttp
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetHttp::~CINetHttp()
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINetHttp::~CINetHttp",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::~CINetHttp");
    PProtAssert(( !_hRequest ));
    PProtAssert(( !_hServer ));

    delete [] _pBuffer;
    delete [] _pszHeader;
    delete [] _pszSendHeader;
    delete [] _pwzAddHeader;
    delete [] _pszVerb;
    if (_pbRootSecurityId != INVALID_P_ROOT_SECURITY_ID)
        delete [] _pbRootSecurityId;
    
    PProtAssert((_pHttpNeg == NULL));
    PProtAssert((_pHttpNeg2 == NULL));
    PProtAssert((_pWindow == NULL));
    PProtAssert(( _pHttSecurity == NULL));

    PerfDbgLog(tagCINetHttp, this, "-CINetHttp::~CINetHttp");

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::INetAsyncOpenRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::INetAsyncOpenRequest()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::INetAsyncOpenRequest",
                "this=%#x",
                this
                ));
                
    PerfDbgLog1(tagCINetHttp, this, "+CINetHttp::INetAsyncOpenRequest (_szObject:%s)", GetObjectName());
    HRESULT hr = NOERROR;
    DWORD dwBindF = 0;
    const ULONG culSize = 256;
    ULONG ulSize = culSize;
    LPCSTR rgszAcceptStr[culSize] = { 0 };
    LPWSTR rgwzStr[culSize];

    SetINetState(INetState_PROTOPEN_REQUEST);
    PProtAssert((g_hSession != NULL));
    PProtAssert((GetStatePending() == NOERROR));

    if (_pOIBindInfo)
    {
        LPWSTR *pwzStr;
        IEnumString *pEnumString = NULL;
        ULONG ulCount = culSize;

        hr = _pOIBindInfo->GetBindString(BINDSTRING_ACCEPT_MIMES, (LPWSTR *)rgwzStr, ulSize, &ulCount);

        if (hr == NOERROR)
        {
            ULONG c = 0;

            for (c = 0; c < ulCount; c++)
            {
                rgszAcceptStr[c] = (LPCSTR) DupW2A(rgwzStr[c]);
                delete rgwzStr[c];
                rgwzStr[c] = 0;
            }
            rgszAcceptStr[c] = 0;
        }
        else
        if( hr == INET_E_USE_DEFAULT_SETTING )
        {
            rgszAcceptStr[0] = (LPCSTR) DupW2A(L"*/*");
            rgszAcceptStr[1] = NULL;
            hr = NOERROR;
        }

    }
    if (hr != NOERROR)
    {
        hr = INET_E_NO_VALID_MEDIA;
        _hrError = INET_E_NO_VALID_MEDIA;
    }
    else if (!_hServer)
    {
        // the download was probably aborted
        if (_hrError == NOERROR)
        {
            SetBindResult(ERROR_INVALID_HANDLE, hr);
            hr = _hrError = INET_E_CANNOT_CONNECT;
        }
        else
        {
            hr = _hrError;
        }
    }
    else
    {
        PProtAssert((_hServer));

        //PProtAssert((ppszAcceptStr && *ppszAcceptStr));

        #if DBG==1
        {
            LPSTR *pszMime = (LPSTR *) &rgszAcceptStr;
            while (*pszMime)
            {
                PerfDbgLog1(tagCINetHttp, this, "=== CTransData::GetAcceptStr (szMime:%s)", *pszMime);
                pszMime++;
            }
        }
        #endif


        dwBindF = GetBindFlags();

        if (dwBindF & BINDF_IGNORESECURITYPROBLEM)
        {
            _dwOpenFlags |= INTERNET_FLAG_IGNORE_CERT_CN_INVALID;
            _dwOpenFlags |= INTERNET_FLAG_IGNORE_CERT_DATE_INVALID;
            _dwOpenFlags |= INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTPS;
            _dwOpenFlags |= INTERNET_FLAG_IGNORE_REDIRECT_TO_HTTP;
        }

        if (dwBindF & BINDF_ENFORCERESTRICTED)
        {
            _dwOpenFlags |= INTERNET_FLAG_RESTRICTED_ZONE;
        }
      

        if (GetRedirectSetting() != 0)
        {
            DbgLog(tagCINetHttp, this, "=== CINet::INetAsyncOpenRequest redirect done by UrlMon!");
            _dwOpenFlags |= INTERNET_FLAG_NO_AUTO_REDIRECT;
        }
        else
        {
            DbgLog(tagCINetHttp, this, "=== CINet::INetAsyncOpenRequest redirect done by WinINet!");
        }

        //
        // we always request keep-alive
        //
        _dwOpenFlags |= INTERNET_FLAG_KEEP_CONNECTION;

        //
        // Notify wininet if this is a multipart upload so it doesn't
        // add a terminating 0x0d 0x0a to the first send
        //
	    BINDINFO *pBndInfo = GetBindInfo();
        if (IsUpLoad()
			// Add in extra check to make TYMED_ISTREAM work the same as 
			// TYMED_HGLOBAL for verbs that require a body, other than POST.
			// We might consider doing away with this IF statement in the future:
			&& (pBndInfo->dwBindVerb == BINDVERB_POST))
        
        {
            _dwOpenFlags |= INTERNET_FLAG_NO_AUTO_REDIRECT;
            //BUGBUG: is the flag below needed?
            //_dwOpenFlags |= INTERNET_FLAG_MULTIPART;
        }



        PrivAddRef(TRUE);
        SetStatePending(E_PENDING);

        _HandleStateRequest = HandleState_Pending;
        HINTERNET hRequestTmp = HttpOpenRequest(
                        _hServer,                   // hHttpSession
                        GetVerb(),                  // lpszVerb
                        GetObjectName(),            // lpszObjectName
                        NULL, //HTTP_VERSION,       // lpszVersion
                        NULL,                       // lpszReferer
                        rgszAcceptStr,              // lplpszAcceptTypes
                        _dwOpenFlags,               // flag
                        (DWORD_PTR) this            // context
                        );
        if ( hRequestTmp == 0)
        {
            dwLstError = GetLastError();
            if (dwLstError == ERROR_IO_PENDING)
            {
                // wait async for the handle
                hr = E_PENDING;
            }
            else
            {
                PrivRelease(TRUE);
                SetStatePending(NOERROR);
                hr = _hrError = INET_E_RESOURCE_NOT_FOUND;
                SetBindResult(dwLstError,hr);
            }
        }
        else
        {
            _hRequest = hRequestTmp; 
            SetStatePending(NOERROR);
            _HandleStateRequest = HandleState_Initialized;

            if (_fUTF8hack)
            {
                DWORD dwSendUTF8 = 1;
                InternetSetOption(_hRequest, INTERNET_OPTION_SEND_UTF8_SERVERNAME_TO_PROXY, &dwSendUTF8, sizeof(DWORD));
                InternetSetOption(_hRequest, INTERNET_OPTION_CODEPAGE, &_dwServerCodePage, sizeof(DWORD));
            }

            hr = INetAsyncSendRequest();
        }

        {
            LPSTR  *pszMime = (LPSTR *) &rgszAcceptStr;
            while (*pszMime)
            {
                LPSTR pszDel = *pszMime;
                delete pszDel;
                pszMime++;
            }
        }
    }

    PerfDbgLog1(tagCINetHttp, this, "-CINetHttp::INetAsyncOpenRequest (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::INetAsyncSendRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::INetAsyncSendRequest()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::INetAsyncSendRequest",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::INetAsyncSendRequest");

    HRESULT hr = NOERROR;
    BOOL fRestarted;
    BOOL fRet;
    PProtAssert((GetStatePending() == NOERROR));

    SetINetState(INetState_SEND_REQUEST);

    LPVOID pBuffer = 0;
    DWORD  dwBufferSize = 0;
    LPSTR szVerb = GetVerb();

    //
    // BUGBUG: move this into GetAdditionalHeader
    //
    if (_fRedirected == TRUE || (_cbProxyAuthenticate + _cbAuthenticate))
    {
        if (_pszSendHeader)
        {
            delete _pszSendHeader;
            _pszSendHeader = NULL;
        }

    }

    if (_fRedirected == FALSE && !(_cbProxyAuthenticate + _cbAuthenticate))
    {
        GetAdditionalHeader();
    }

    if (_fRedirected == FALSE || _fP2PRedirected )
    {
        // Note: the buffer returned here will be freed
        // by the destructor
        GetDataToSend(&pBuffer, &dwBufferSize);
        _fP2PRedirected = FALSE;
    }

    // Call HttpNeg only the first time in case of authentication
    // i.e. both Auth counts == 0 ?
    if (!(_cbAuthenticate || _cbProxyAuthenticate))     {
        //BUGBUG: does BeginingTrans need to be called for
        // redirect and authentication resends?
        if (_fRedirected == FALSE)
            hr = HttpNegBeginningTransaction();
        // Note: the header is appended to the AddHeader
    }

    HttpNegGetRootSecurityId();
    LONG lThirdParty;
    if (IsThirdPartyUrl(GetUrl()))
    {
        lThirdParty = 1;
        //MessageBoxW( 0, GetUrl(), L"cnethttp: THIRDPARTY!", 0 );
        InternetSetOption(_hRequest, INTERNET_OPTION_COOKIES_3RD_PARTY, &lThirdParty, sizeof(LONG));
    }
    else
    {
        lThirdParty = 0;
        //MessageBoxW( 0, GetUrl(), L"cnethttp: NOT THIRDPARTY!", 0 );
        InternetSetOption(_hRequest, INTERNET_OPTION_COOKIES_3RD_PARTY, &lThirdParty, sizeof(LONG));
    }    
    
    if (hr == E_ABORT)
    {
        _hrError = hr;
        SetBindResult(ERROR_CANCELLED,hr);
    }
    else
    {
        PerfDbgLog1(tagCINetHttp, this, "+CINetHttp::INetAsyncSendRequest HttpSendRequest (_pszSendHeader:%s)", XDBG(_pszSendHeader,""));

        if (GetBindInfo()->dwBindVerb == BINDVERB_POST && !_f2ndCacheKeySet)
        {
            // WININET request: send SECONDARY_CACHE_KEY only once
            ULONG ulCount = 0;
            LPWSTR pwzPostCookieStr = 0;
            HRESULT hr1 = _pOIBindInfo->GetBindString(BINDSTRING_POST_COOKIE, (LPWSTR *)&pwzPostCookieStr, 1, &ulCount);
            if ((hr1 == NOERROR) && pwzPostCookieStr)
            {
                // BUGBUG: trident return s_ok and no string
                PProtAssert((pwzPostCookieStr));
                LPSTR pszStr = DupW2A(pwzPostCookieStr);
                if (pszStr)
                {
                    _f2ndCacheKeySet = TRUE;
                    InternetSetOption(_hRequest, INTERNET_OPTION_SECONDARY_CACHE_KEY, pszStr, strlen(pszStr));
                    delete pszStr;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    _hrError = INET_E_DOWNLOAD_FAILURE;
                    SetBindResult(hr,hr);
                }
                delete pwzPostCookieStr;
            }

        }

        /************ enable this after wininet sniff checked in *******
        // set option for data sniff
        DWORD dwDataSniff = 1;
        InternetSetOption(_hRequest, INTERNET_OPTION_DATASNIFF, &dwDataSniff, sizeof(DWORD));
        ****************************************************************/

        InternetSetOption(_hRequest, INTERNET_OPTION_REQUEST_PRIORITY, &_nPriority, sizeof(LONG));

        if (_fRedirected || !_fUTF8hack)
        {
            /*
                This is used in wininet now only to convert the MBCS servername supplied to UTF8
                to send to the proxy if needed
             */
            InternetSetOption(_hRequest, INTERNET_OPTION_CODEPAGE, &_BndInfo.dwCodePage, sizeof(DWORD));
        }
        
        SetStatePending(E_PENDING);

        if (hr == NOERROR)
        {
            if (IsUpLoad())
            {
                // post verb
                // DWORD dwSendFlags = HSR_ASYNC | HSR_CHUNKED | HSR_INITIATE;
                DWORD dwSendFlags = HSR_CHUNKED | HSR_INITIATE;
                DWORD dwSendContext = 0;

                if (!_pStm)
                {
                    BINDINFO *pBI = GetBindInfo();
                    if (pBI && pBI->stgmedData.tymed == TYMED_ISTREAM)
                            {
                        _pStm = pBI->stgmedData.pstm;
                    }
                }
                if (_pStm)
                {
                    hr = GetNextSendBuffer(&_inetBufferSend,_pStm, TRUE);
                }

                fRet = HttpSendRequestExA(
                          _hRequest               // IN HINTERNET hRequest,
                         ,&_inetBufferSend         // IN LPINTERNET_BUFFERSA lpBuffersIn OPTIONAL,
                         , NULL                   // OUT lpBuffersOut not used
                         ,dwSendFlags             // IN DWORD dwFlags,
                         ,dwSendContext           // IN DWORD dwContext
                            );
            }
            else
            {
                DWORD dwError;

                // Allow ERROR_INTERNET_INSERT_CDROM to be returned from HttpSendRequest
#ifdef MSNJIT
                DWORD dwErrorMask = INTERNET_ERROR_MASK_INSERT_CDROM | INTERNET_ERROR_MASK_COMBINED_SEC_CERT | INTERNET_ERROR_MASK_NEED_MSN_SSPI_PKG;
#else                
                DWORD dwErrorMask = INTERNET_ERROR_MASK_INSERT_CDROM | INTERNET_ERROR_MASK_COMBINED_SEC_CERT;
#endif                
                dwErrorMask = dwErrorMask | INTERNET_ERROR_MASK_LOGIN_FAILURE_DISPLAY_ENTITY_BODY;

                InternetSetOption(_hRequest, INTERNET_OPTION_ERROR_MASK, &dwErrorMask, sizeof(DWORD));

                fRet = HttpSendRequest(_hRequest,
                       _pszSendHeader,                     // additional headers
                       (_pszSendHeader) ? (ULONG)-1L : 0L, // size of additional headers data
                       pBuffer,                            // Optional data (POST or put)
                       dwBufferSize);                      // optional data length

                PerfDbgLog(tagCINetHttp, this, "-CINetHttp::INetAsyncSendRequest HttpSendRequest");

            }   // end else

            if (fRet == FALSE)
            {
                dwLstError = GetLastError();
                if (dwLstError == ERROR_IO_PENDING)
                {
                    // wait async for the handle
                    hr = E_PENDING;
                }
                else if (dwLstError == ERROR_INTERNET_INSERT_CDROM)
                {
                    _hrINet = INET_E_AUTHENTICATION_REQUIRED;
                    _dwSendRequestResult = ERROR_INTERNET_INSERT_CDROM;
                    _lpvExtraSendRequestResult = NULL;
                    TransitState(INetState_DISPLAY_UI, TRUE);
                    hr = E_PENDING;
                    fRet = TRUE;
                }
                else
                {
                    SetStatePending(NOERROR);
                    hr = _hrError = INET_E_DOWNLOAD_FAILURE;
                    SetBindResult(dwLstError,hr);
                    PerfDbgLog3(tagCINetHttp, this, "CINetHttp::INetAsyncSendRequest (fRet:%d, _hrError:%lx, LstError:%ld)", fRet, _hrError, dwLstError);
                }
            }
            else
            {
                SetStatePending(NOERROR);

                // in case of redirect, we need to reset all the
                // _dwSendRequestResult from previous callback
                _dwSendRequestResult = 0;
                _lpvExtraSendRequestResult = NULL;
                hr = INetQueryInfo();
            }
        }
    }


    if (_hrError != INET_E_OK)
    {
        // we need to terminate here
        ReportResultAndStop(hr);
    }

    PerfDbgLog1(tagCINetHttp, this, "-CINetHttp::INetAsyncSendRequest (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::QueryStatusOnResponse
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::QueryStatusOnResponse()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::QueryStatusOnResponse",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::QueryStatusOnResponse");
    HRESULT hr = NOERROR;

    DWORD dwStatus;
    char szBuffer[max(2 * MAX_URL_SIZE, 400)];
    DWORD cbBufferLen = sizeof(szBuffer);
    DWORD cbLen = cbBufferLen;

    if (_dwSendRequestResult)
    {
        // handle the sendrequest result
        // zone crossing
        switch (_dwSendRequestResult)
        {
        case ERROR_INTERNET_SEC_CERT_DATE_INVALID     :
        case ERROR_INTERNET_SEC_CERT_CN_INVALID       :
        case ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR    :
        case ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR    :
        case ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR   :
        case ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION   :
        case ERROR_INTERNET_INVALID_CA                :
        case ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED   :
        case ERROR_INTERNET_FORTEZZA_LOGIN_NEEDED     :
        case ERROR_INTERNET_SEC_CERT_ERRORS           :
        case ERROR_INTERNET_SEC_CERT_REV_FAILED       :
        case ERROR_INTERNET_SEC_CERT_REVOKED          :
        {
            hr = HttpSecurity(_dwSendRequestResult);

            if ((hr != NOERROR) && (hr != E_PENDING))
            {
                _hrError = INET_E_AUTHENTICATION_REQUIRED;
            }
            else
            {
                _hrError = INET_E_OK;
            }

        }
        break;

        case ERROR_INTERNET_LOGIN_FAILURE_DISPLAY_ENTITY_BODY :
        {
            _hrError = INET_E_OK;
            hr = NOERROR; 
        }
        break;

#ifdef MSNJIT        
        case ERROR_INTERNET_NEED_MSN_SSPI_PKG     :
        {
            const GUID MSN_AUTH_GUID = 
            { 0x6fab99d0, 0xbab8, 0x11d1, {0x99, 0x4a, 0x00, 0xc0, 0x4f, 0x98, 0xbb, 0xc9} };

            HWND hWnd = NULL;
            DWORD dwJITFlags = 0;
            
            uCLSSPEC classpec;
            classpec.tyspec=TYSPEC_TYPELIB;
            classpec.tagged_union.typelibID = (GUID)MSN_AUTH_GUID;

            QUERYCONTEXT qc;
            memset(&qc, 0, sizeof(qc));

            // fill in the minimum version number of the component you need
            //qc.dwVersionHi = 
            //qc.dwVersionLo = 
            hr = FaultInIEFeature(hWnd, &classpec, &qc, dwJITFlags);

            if (hr == S_OK)
            {
                hr = INET_E_AUTHENTICATION_REQUIRED;
            }
            else 
            {
                hr = E_ABORT;
            }
        }

        break;
#endif
        default:
        break;
        }

    }
    else if (HttpQueryInfo(_hRequest, HTTP_QUERY_STATUS_CODE, szBuffer,&cbLen, NULL))
    {
        dwStatus = atoi(szBuffer);
        _fProxyAuth = FALSE;
        switch (dwStatus)
        {
        case HTTP_STATUS_DENIED:
        {
            _hrINet = INET_E_AUTHENTICATION_REQUIRED;
            TransitState(INetState_AUTHENTICATE, TRUE);
            hr = E_PENDING;
        }
        break;
        case HTTP_STATUS_PROXY_AUTH_REQ :
        {
            _hrINet = INET_E_AUTHENTICATION_REQUIRED;
            TransitState(INetState_AUTHENTICATE, TRUE);
            _fProxyAuth = TRUE;
            hr = E_PENDING;
        }
        break;
        case HTTP_STATUS_MOVED:
        case HTTP_STATUS_REDIRECT:
        case HTTP_STATUS_REDIRECT_METHOD:
        case HTTP_STATUS_REDIRECT_KEEP_VERB:
        {
            cbLen = cbBufferLen;
            hr = RedirectRequest(szBuffer, &cbLen, dwStatus);
            if ((hr != S_FALSE) &&  (hr != NOERROR) && (hr != E_PENDING))
            {
                _hrError = INET_E_INVALID_URL;
            }
            else
            {
                _hrError = INET_E_OK;
                hr = S_FALSE;
                SetINetState(INetState_DONE);
            }
        }
        break;
        case HTTP_STATUS_NO_CONTENT:
        {
            BINDINFO *pBndInfo = GetBindInfo();

            if (pBndInfo && pBndInfo->dwBindVerb != BINDVERB_CUSTOM)
            {
                hr = _hrError = E_ABORT;
                SetBindResult(ERROR_CANCELLED, hr);
            }
            else
            {
                hr = QueryStatusOnResponseDefault(dwStatus);
            }
        }
        break;
        default:
        {
            hr = QueryStatusOnResponseDefault(dwStatus);
        }
        break;
        }
    }

    if (_hrError != INET_E_OK)
    {
        SetINetState(INetState_DONE);
    }

    PerfDbgLog1(tagCINetHttp, this, "-CINetHttp::QueryStatusOnResponse (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::QueryStatusOnResponseDefault
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::QueryStatusOnResponseDefault(DWORD dwStat)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::QueryStatusOnResponseDefault",
                "this=%#x, %#x",
                this, dwStat
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::QueryStatusOnResponseDefault");
    HRESULT hr = NOERROR;

    DWORD dwStatus = 0;
    char szBuffer[max(2 * MAX_URL_SIZE, 400)];
    DWORD cbBufferLen = sizeof(szBuffer);
    DWORD cbLen = cbBufferLen;

    if( !dwStat )
    {
        if (HttpQueryInfo(_hRequest, HTTP_QUERY_STATUS_CODE, szBuffer,&cbLen, NULL))
        {
            dwStatus = atoi(szBuffer);
        }
    }
    else
    {
        dwStatus = dwStat;
    }

    if( dwStatus )
    {
        #if DBG==1
        if ( !((dwStatus >= HTTP_STATUS_OK) && (dwStatus <= HTTP_STATUS_GATEWAY_TIMEOUT)) )
        {
            DbgLog1(DEB_PROT|DEB_TRACE, this, "CINetHttp::QueryStatusOnResponse (dwStatus:%lx)", dwStatus);
        }
        PProtAssert((   (dwStatus >= HTTP_STATUS_BEGIN) && (dwStatus <= HTTP_STATUS_END)
                         && L"WinINet returned an invalid status code: please contact a WININET developer" ));
        #endif //DBG==1

        // check if we got redirected from a file to a directory
        {
            cbLen = cbBufferLen;
            InternetQueryOption(_hRequest, INTERNET_OPTION_URL, szBuffer, &cbLen);
            if (cbLen)
            {
                BOOL fRedirected;
                fRedirected = strcmp(szBuffer, _pszFullURL);

                if (fRedirected)
                {
                    cbLen = cbBufferLen;
                    hr = RedirectRequest(szBuffer, &cbLen, dwStatus);

                    if ((hr != NOERROR) && (hr != E_PENDING))
                    {
                        if (hr != INET_E_DOWNLOAD_FAILURE)
                        {
                            _hrError = INET_E_INVALID_URL;
                        }
                    // else set nothing
                    }
                    else
                    {
                        _hrError = INET_E_OK;
                    }
                }
            }
        }

        cbLen = cbBufferLen;
        
        BOOL fRet = HttpQueryInfo(_hRequest, HTTP_QUERY_RAW_HEADERS_CRLF, szBuffer,&cbLen, NULL);
        BOOL fDeleteBuffer = FALSE;
        LPSTR lpszBuffer;
        
        if (!fRet)
        {
            DWORD dwError = GetLastError();

            if (dwError == ERROR_INSUFFICIENT_BUFFER)
            {
                lpszBuffer = new char[cbLen];
                if (!lpszBuffer)
                {
                    hr = E_OUTOFMEMORY;
                    goto End;
                }
                fDeleteBuffer = TRUE;
                fRet = HttpQueryInfo(_hRequest, HTTP_QUERY_RAW_HEADERS_CRLF, lpszBuffer, &cbLen, NULL);
            }
        }
        else
            lpszBuffer = szBuffer;

        if (fRet)
        {
            if (IsStatusOk(dwStatus))
            {
                hr = HttpNegOnHeadersAvailable(dwStatus, lpszBuffer);
            }
            else
            {
                hr = ErrorHandlingRequest(dwStatus, lpszBuffer);
                if ((hr != NOERROR) && (hr != E_PENDING))
                {
                    _hrError = hr;
                }
                else
                {
                    _hrError = INET_E_OK;
                }
            }
            
            if (hr == E_ABORT)
            {
                SetBindResult(ERROR_CANCELLED,hr);
            }
        }

        if (fDeleteBuffer)
            delete lpszBuffer;
    }
    
End:
    PerfDbgLog1(tagCINetHttp, this, "-CINetHttp::QueryStatusOnResponseDefault (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::QueryHeaderOnResponse
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::QueryHeaderOnResponse()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::QueryHeaderOnResponse",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::QueryHeaderOnResponse");
    HRESULT hr = NOERROR;
    DWORD dwStatus;
    char szBuffer[max(2 * MAX_URL_SIZE, 400)];
    DWORD cbBufferLen = sizeof(szBuffer);
    DWORD dwFlags;
    char szMIMEType[SZMIMESIZE_MAX] = "";
    char szENCType[SZMIMESIZE_MAX] = "";
    BOOL fContentDisp = FALSE;

    // Get file length
    if(HttpQueryInfo(_hRequest, HTTP_QUERY_CONTENT_LENGTH, szBuffer,&cbBufferLen, NULL))
    {
        _cbDataSize = atoi(szBuffer);
    }

    // Get Content-Disposition
    szBuffer[0] = '\0';
    cbBufferLen = sizeof(szBuffer);

    if(HttpQueryInfo(
            _hRequest,
            HTTP_QUERY_CONTENT_DISPOSITION,
            szBuffer,
            &cbBufferLen,
            NULL) )
    {
        // Search for :Attachment, if found, report it
        if( StrStrI(szBuffer, vszAttachment) )
        {
            char  szName[MAX_PATH];
            char *pName = NULL;

            // propogate the filename if available
            if( StrStrI(szBuffer, vszFileName) )
            {
                DWORD cbNameLen;

                szName[0] = '\0';
                cbNameLen = sizeof(szName);

                if(InternetQueryOption(_hRequest, INTERNET_OPTION_DATAFILE_NAME, szName, &cbNameLen))
                    pName = PathFindFileName(szName);
            }

            ReportNotification(BINDSTATUS_CONTENTDISPOSITIONATTACH, (pName?pName:NULL));
        }
        
        if( StrStrI(szBuffer, vszFileName) )
        {
            fContentDisp = TRUE;
        }
    }

    // Get Accept-Ranges 
    szBuffer[0] = '\0';
    cbBufferLen = sizeof(szBuffer);
    if(HttpQueryInfo(
            _hRequest,
            HTTP_QUERY_ACCEPT_RANGES,
            szBuffer,
            &cbBufferLen,
            NULL) )
    {
        ReportNotification(BINDSTATUS_ACCEPTRANGES, NULL);
    }

    // mimetype
    cbBufferLen = sizeof(szMIMEType);
    szMIMEType[0] = 0;
    HttpQueryInfo(_hRequest, HTTP_QUERY_CONTENT_TYPE, szMIMEType, &cbBufferLen, NULL);
    if (cbBufferLen && (szMIMEType[0] != 0))
    {
        //BUG-WORK
        //_pCTransData->SetMimeType(szMIMEType);
        //_pCTrans->ReportProgress();
        DbgLog1(DEB_PROT|DEB_TRACE, this,
                "CINetHttp::QueryHeaderOnResponse MIME TYPE(szMime:%s)!",
                szMIMEType);

        // work around image display problem, turn off report mime type
        // for direct binding
        if( _grfBindF & BINDF_FROMURLMON)
        {
            ReportNotification(BINDSTATUS_MIMETYPEAVAILABLE,szMIMEType);
        }
        else
        {
            ReportNotification(BINDSTATUS_RAWMIMETYPE, szMIMEType);
        }

        /*** enable this block after wininet data sniff checked in ****
        if( _cbDataSize )
        {

            // datasniff enabled ?
            DWORD dwDataSniff = 0;
            DWORD dwSize = sizeof(DWORD);

            if( InternetQueryOption(
                    _hRequest,
                    INTERNET_OPTION_DATASNIFF,
                    &dwDataSniff,
                    &dwSize ) )

            {
                char szVCType[SZMIMESIZE_MAX] = "";
                cbBufferLen = SZMIMESIZE_MAX;

                InternetQueryOption(
                    _hRequest,
                    INTERNET_OPTION_VERIFIED_CONTENT_TYPE,
                    szVCType,
                    &cbBufferLen );

            }
        }
        ****************************************************************/
    }
    else
    {
        DbgLog1(DEB_PROT|DEB_TRACE, this,
                "CINetHttp::QueryHeaderOnResponse NO MIME TYPE (szUrl:%s)!",
                GetBaseURL());
        //BUGBUG: need data sniffing later on
        //_pCTransData->SetMimeType("text/html");
        // work around image display problem, turn off report mime type
        // for direct binding
        if( _grfBindF & BINDF_FROMURLMON)
        {
            ReportNotification(BINDSTATUS_MIMETYPEAVAILABLE,"text/html");
        }
    }

    // content encoding
    cbBufferLen = sizeof(szENCType);
    HttpQueryInfo(_hRequest, HTTP_QUERY_CONTENT_ENCODING, szENCType, &cbBufferLen, NULL);
    if (cbBufferLen && (szENCType[0] != 0))
    {
        DbgLog1(DEB_PROT|DEB_TRACE, this,
                "CINetHttp::QueryHeaderOnResponse ENCODING TYPE(szEnc :%s)!",
                szENCType);
        //
        // existing http servers may mishandle the content-encoding
        // header,  we have to taken care of the following cases:
        //
        // 1. we do not send Accept-Encoding header(http1.1 disabled),
        //    however, server sends back Content-Encoding: foo
        //    (_pszHeaders contains the accept-encoding info, so if
        //     this is null, we should not invoke the decoder )
        //
        // 2. we send Accept-Encoding: A, server sends back
        //    Content-Encoding: B, this is a protocol violation
        //    IgnoreContentEncoding() takes care of that, it compares
        //    the _pszHeader and szENCType, and we should not invoke
        //    the decoder if they are mis-matched
        //
        // 3. server sends out content-encoding, but what they really
        //    mean is that let the application (e.g. gunzip.exe) to
        //    handle the compressed file, we can add the check for
        //    content-type, for a list of content-type we do not
        //    understand (e.g. application/x-compress, x-world/x-vrml..)
        //    do not invoke the decoder
        //

        //    Wininet changes http version if http1.1 over proxy is disabled.
        //    This happens only after httpSendRequest is called, which is when
        //    Urlmon might have passed in the Accept-Encoding headers.
        //    If we did pass in the headers, we need to make sure that they 
        //    were not stripped out because wininet finally used Http 1.0.
        
        if( _pszHeader && !RequestUsedHttp10(_hRequest) &&    
            !IgnoreContentEncoding(szMIMEType, szENCType, _pszHeader) )
        {
            ReportNotification(BINDSTATUS_ENCODING, szENCType);

            // Load The decompression handler now...
            COInetSession       *pCOInetSession = NULL;
            IOInetProtocol      *pProtHandler = NULL;
            IOInetProtocolSink  *pProtSnkHandler = NULL;
            IOInetBindInfo      *pBindInfo = NULL;
            LPWSTR              pwzStr = DupA2W(szENCType);
            CLSID               clsid;

            hr = GetCOInetSession(0,&pCOInetSession,0);
            if( hr == NOERROR )
            {
                hr = pCOInetSession->CreateHandler(
                    pwzStr, 0, 0, &pProtHandler, &clsid);

                if( hr == NOERROR )
                {
                    hr = pProtHandler->QueryInterface(
                        IID_IOInetProtocolSink, (void **) &pProtSnkHandler);


                    //hr = QueryInterface(
                    //    IID_IOInetBindInfo, (void **) &pBindInfo);
                }

                if( hr == NOERROR )
                {
                    HRESULT hr2 = NOERROR;
                    hr2 = _pEmbdFilter->SwitchSink(pProtSnkHandler);
                    if( hr2 == NOERROR )
                    {
                        hr = _pEmbdFilter->StackFilter(
                            pwzStr, pProtHandler, pProtSnkHandler, _pOIBindInfo );
                    }
                }

                if( pBindInfo )
                {
                    pBindInfo->Release();
                }
            }

            if( szMIMEType[0] != '\0' )
            {
                ReportNotification(BINDSTATUS_MIMETYPEAVAILABLE,szMIMEType);
            }

            // Get Cache-Control 
            szBuffer[0] = '\0';
            cbBufferLen = sizeof(szBuffer);
            if(HttpQueryInfo(
                    _hRequest,
                    HTTP_QUERY_CACHE_CONTROL,
                    szBuffer,
                    &cbBufferLen,
                    NULL) )
            {
                ReportNotification(BINDSTATUS_CACHECONTROL, szBuffer);
            }


            if(fContentDisp)
            {
                // Get Content-Disposition
                szBuffer[0] = '\0';
                cbBufferLen = sizeof(szBuffer);

                if(InternetQueryOption(_hRequest, INTERNET_OPTION_DATAFILE_NAME, szBuffer, &cbBufferLen))
                {
                    ReportNotification(BINDSTATUS_CONTENTDISPOSITIONATTACH, PathFindFileName(szBuffer));
                }
            }
            // urlmon will create a decompressed cache-file, so we should not
            // report the compressed file name to the client.
            _fFilenameReported = TRUE;

            if (pwzStr)
            {
                delete pwzStr;
            }
        }
    }

#ifdef TEST_STACK_FILTER_ONE
    //test for stackable filter..
    //need to include mft.hxx for sample implementation of the filter
    {
        IOInetProtocol* pFilter = (IOInetProtocol*) new CMft;
        IOInetProtocolSink* pFilterSink = NULL;
        pFilter->QueryInterface(
            IID_IOInetProtocolSink, (void**)&pFilterSink);

        // connect the last filter sink with pFilter's Sink
        HRESULT hr2 = NOERROR;
        hr2 = _pEmbdFilter->SwitchSink(pFilterSink);

        if( hr2 == NOERROR )
        {
            hr = _pEmbdFilter->StackFilter(NULL, pFilter, NULL, NULL);
        }

        // this object gets created here, pFilter gets AddRef'd during
        // the StackFilter(), we should release the additional Ref Count
        // here
        // this does not apply to the first filter stacked
        if( _pEmbdFilter->FilterStacked() > 1 )
        {
            pFilter->Release();
        }
    }
#endif

#ifdef TEST_STACK_FILTER_TWO
    {
        // another one...
        IOInetProtocol* pFilter_2 = (IOInetProtocol*) new CMft;
        IOInetProtocolSink* pFilterSink_2 = NULL;
        pFilter_2->QueryInterface(
            IID_IOInetProtocolSink, (void**)&pFilterSink_2);

        // connect the last filter sink with pFilter's Sink
        HRESULT hr3 = NOERROR;
        hr3 = _pEmbdFilter->SwitchSink(pFilterSink_2);

        if( hr3 == NOERROR )
        {
            hr = _pEmbdFilter->StackFilter(NULL, pFilter_2, NULL, NULL);
        }

        // this object gets created here, pFilter gets AddRef'd during
        // the StackFilter(), we should release the additional Ref Count
        // here
        // this does not apply to the first filter stacked
        if( _pEmbdFilter->FilterStacked() > 1 )
        {
            pFilter_2->Release();
        }
    }
#endif

    if (_hrError != INET_E_OK)
    {
        SetINetState(INetState_DONE);
        hr = S_FALSE;
    }

    PerfDbgLog2(tagCINetHttp, this, "-CINetHttp::QueryHeaderOnResponse (hr:%lx, _cbDataSize:%ld)", hr, _cbDataSize);

    DEBUG_LEAVE(hr);
    return hr;

}

//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::RedirectRequest
//
//  Synopsis:
//
//  Arguments:  [lpszBuffer] --
//              [pdwBuffSize] --
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::RedirectRequest(LPSTR lpszBuffer, DWORD *pdwBuffSize, DWORD dwStatus)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::RedirectRequest",
                "this=%#x, %#x, %#x, %d",
                this, lpszBuffer, pdwBuffSize, dwStatus
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::RedirectRequest");
    HRESULT hr = INET_E_DOWNLOAD_FAILURE;

    char *pszHeader;
    DWORD cbBufferLen;
    BOOL fDeleteBuffer = FALSE;
    BOOL fRet = FALSE;
    
    // we assume when we get here that we have recieved a redirection
    // now we are going to see where we need to do the next send

    cbBufferLen = *pdwBuffSize;

    if (cbBufferLen <= strlen(vszLocationTag))
    {
        goto End;
    }
    strcpy(lpszBuffer, vszLocationTag);

    fRet = HttpQueryInfo(_hRequest, HTTP_QUERY_RAW_HEADERS, lpszBuffer,&cbBufferLen, NULL);

    if (!fRet)
    {
        DWORD dwError = GetLastError();

        if (dwError == ERROR_INSUFFICIENT_BUFFER)
        {
            lpszBuffer = new char[cbBufferLen];
            if (!lpszBuffer)
            {
                hr = E_OUTOFMEMORY;
                goto End;
            }
            fDeleteBuffer = TRUE;
            fRet = HttpQueryInfo(_hRequest, HTTP_QUERY_RAW_HEADERS, lpszBuffer, &cbBufferLen, NULL);
            dwError = GetLastError();
        }
    }    

    if (fRet)
    {
        LPSTR  pszRedirect = 0;
        pszHeader = FindTagInHeader(lpszBuffer, vszLocationTag);
        if (!pszHeader)
        {
            goto End;
        }

        //Bug 21294:  204 responses sometimes have Location: headers, which may not mean redirects.
        //To prevent a bogus redirection message, ensure that the comparison with wininet's url
        //is made after stripping username and password from the original url, since wininet returns
        //the url without these.
        //Don't make this check if it's one of the 3** or username/password not in url.
        if ((dwStatus < HTTP_STATUS_AMBIGUOUS) &&
            (_pszUserName[0] || _pszPassword[0]))
        {
            CHAR* szUrlmonUrl = new CHAR[INTERNET_MAX_URL_LENGTH];
            CHAR* szWininetUrl = new CHAR[INTERNET_MAX_URL_LENGTH];
            DWORD dwUrlmonSize = INTERNET_MAX_URL_LENGTH;
            DWORD dwWininetSize = INTERNET_MAX_URL_LENGTH;
            BOOL bIdentical = FALSE;
            URL_COMPONENTS url;
            
            if (!szUrlmonUrl || !szWininetUrl)
                goto deleteUrls;
                
            memset(&url, 0, sizeof(URL_COMPONENTS));
            
            url.dwStructSize = sizeof(url);
            url.lpszScheme = _pszProtocol;
            url.lpszHostName = _pszServerName;
            url.lpszUrlPath = _pszObject;
            url.nPort = _ipPort;

            if (InternetCreateUrl(&url, 0, szUrlmonUrl, &dwUrlmonSize) &&
                InternetQueryOption(_hRequest, INTERNET_OPTION_URL, szWininetUrl, &dwWininetSize))
            {
                if ((dwUrlmonSize == dwWininetSize)
                    && !strcmp(szUrlmonUrl, szWininetUrl))
                {
                    bIdentical = TRUE;
                }
                
                DEBUG_ENTER((DBG_APP,
                            Bool,
                            "CINetHttp::RedirectRequestComparison",
                            "this=%#x, %.80q, %d, %.80q, %d",
                            this, szUrlmonUrl, dwUrlmonSize, szWininetUrl, dwWininetSize
                            ));
                            
                DEBUG_LEAVE(bIdentical);
            }
            
            deleteUrls:
            if (szUrlmonUrl)
                delete [] szUrlmonUrl;
            if (szWininetUrl)
                delete [] szWininetUrl;

            if (bIdentical)
                goto End;
        }

        if (dwStatus < HTTP_STATUS_AMBIGUOUS)
        {
            //Bug 33662: Location: headers are only allowed to be absolute URIs
            //check for relative URI and, if found, pretend doesn't exist for 2** status codes.
            
            char* pszHostname = new char[MAX_URL_SIZE];
            DWORD dwHostname = MAX_URL_SIZE;
            HRESULT hrTemp;

            if (!pszHostname)
            {
                hr = E_OUTOFMEMORY;
                goto End;
            }
            hrTemp = UrlGetPartA(pszHeader + strlen(vszLocationTag), pszHostname, &dwHostname, URL_PART_HOSTNAME, 0);

            delete [] pszHostname;
            
            if (FAILED(hrTemp))
            {
                //this is a relative URI since hostname couldn't be found.
                //hr remains INET_E_DOWNLOAD_FAILURE
                goto End;
            }
        }
        
        //
        // _pszPartURL get allocated here!
        //
        if( _pszPartURL )
        {
            delete [] _pszPartURL;
            _pszPartURL = NULL;
        }

        DWORD dwPartUrlLen = strlen( (pszHeader + strlen(vszLocationTag) ) );
        if( dwPartUrlLen > MAX_URL_SIZE)
        {
            hr = INET_E_DOWNLOAD_FAILURE;
            goto End;
        }

        _pszPartURL = new char[dwPartUrlLen + 1];
        if( !_pszPartURL )
        {
            hr = E_OUTOFMEMORY;
            goto End;
        }

        strcpy(_pszPartURL, pszHeader + strlen(vszLocationTag));

        DbgLog1(DEB_PROT|DEB_TRACE, this, "=== CINetHttp::RedirectRequest (Location:%s)", _pszPartURL);

        _fRedirected = TRUE;
        hr = S_FALSE;

        if (!ParseUrl())
        {
            pszRedirect = _pszPartURL;
        }
        else
        {
            pszRedirect = _pszFullURL;
        }

        PProtAssert((pszRedirect));
        ReportResultAndStop(INET_E_REDIRECTING, 0, 0, DupA2W(pszRedirect));
    }
End:
    if (fDeleteBuffer)
        delete lpszBuffer;
        
    PerfDbgLog1(tagCINetHttp, this, "-CINetHttp::RedirectRequest(hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::ErrorHandlingRequest
//
//  Synopsis:
//
//  Arguments:  [dwstatus] --
//              [szBuffer] --
//
//  Returns:
//
//  History:    2-28-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::ErrorHandlingRequest(DWORD dwStatus, LPSTR szBuffer)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::ErrorHandlingRequest",
                "this=%#x, %#x, %.80q",
                this, dwStatus, szBuffer
                ));
                
    PerfDbgLog1(tagCINetHttp, this, "+CINetHttp::ErrorHandlingRequest (dwStatus:%ld)", dwStatus);
    HRESULT hr = NOERROR;

    PProtAssert((szBuffer));
    hr = HttpNegOnError(dwStatus,szBuffer);

    if (hr == E_RETRY)
    {
        _hrINet = NOERROR;
        hr = INetAsyncSendRequest();
    }
    else if (hr == E_ABORT)
    {
        _hrINet = E_ABORT;
    }
    else if (hr == S_FALSE)
    {
        // the error was not handled - stop download
        _hrINet = hr = HResultFromHttpStatus(dwStatus);
    }
    else
    {
        _hrINet = hr;
    }

    PerfDbgLog1(tagCINetHttp, this, "-CINetHttp::ErrorHandlingRequest(hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::GetVerb
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-05-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPSTR CINetHttp::GetVerb()
{
    DEBUG_ENTER((DBG_APP,
                String,
                "CINetHttp::GetVerb",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::GetVerb");
    LPSTR pszRes = vszGet;

    if (_fRedirected == TRUE)
    {
        // for HTTP 1.1, we have to check if this is an POST->POST redirect
        INTERNET_VERSION_INFO   httpVersion;
        DWORD                   dwBufferSize = sizeof(INTERNET_VERSION_INFO);
        if(    InternetQueryOption( _hRequest, INTERNET_OPTION_HTTP_VERSION, &httpVersion, &dwBufferSize )
            && httpVersion.dwMajorVersion >= 1
            && httpVersion.dwMinorVersion >= 1 )
        {
            CHAR    szVerb[16];
            DWORD   dwIndex;
            DWORD   dwLength = sizeof(szVerb);
            if(    HttpQueryInfo(_hRequest, HTTP_QUERY_REQUEST_METHOD, szVerb, &dwLength, &dwIndex)
                && !lstrcmp(szVerb, vszPost) )
            {
                // HACK HACK HACK !!
                // Double check the status code to see if this is a real POST
                // there is a HttpQueryInfo() bug which will send verb=POST
                // on a POST->GET Redirect
                //

                DWORD dwStatus = 0;
                if (   HttpQueryInfo(
                           _hRequest,
                           HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
                           &dwStatus ,&dwLength, NULL)
                    && dwStatus == HTTP_STATUS_REDIRECT_KEEP_VERB )
                {
                    _fP2PRedirected = TRUE;
                    pszRes = vszPost;
                }
            }
        }
    }
    else
    {
        BINDINFO *pBndInfo = GetBindInfo();

        if (pBndInfo)
        {
            switch (pBndInfo->dwBindVerb)
            {
            case BINDVERB_GET      :
                pszRes = vszGet;
                break;
            case BINDVERB_POST     :
                pszRes = vszPost;
                break;
            case BINDVERB_PUT      :
                pszRes = vszPut;
                break;
            case BINDVERB_CUSTOM   :
                {
                    //BUGBUG: custom verb support
                    if (!_pszVerb && pBndInfo->szCustomVerb)
                    {
                        pszRes = _pszVerb = DupW2A(pBndInfo->szCustomVerb);
                    }
                    else if(_pszVerb)
                    {
                        pszRes = _pszVerb;
                    }
                }
                break;
            }
        }
    }

    PerfDbgLog1(tagCINetHttp, this, "-CINetHttp::GetVerb (szRes:%s)", pszRes);

    DEBUG_LEAVE(pszRes);
    return pszRes;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::GetAdditionalHeader
//
//  Synopsis:
//
//  Arguments:  [ppszRes] --
//              [pdwSize] --
//
//  Returns:
//
//  History:    2-05-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::GetAdditionalHeader()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::GetAdditionalHeader",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::GetAdditionalHeader");

    DWORD dwSizeData = 0;
    DWORD dwSizeHeader = 0;
    LPSTR szLocal;

    szLocal = g_pszUAInfoString;

    dwSizeHeader += strlen(szLocal);

    ULONG   dwSizeEncHeader = 0;

    PProtAssert((_pOIBindInfo));
    // only send Accept-Encoding header with HTTP 1.1 or higher
    INTERNET_VERSION_INFO   httpVersion;
    DWORD                   dwBufferSize = sizeof(INTERNET_VERSION_INFO);
    if(     _hRequest
         && _pOIBindInfo
         && InternetQueryOption( _hRequest, INTERNET_OPTION_HTTP_VERSION, &httpVersion, &dwBufferSize )
         && httpVersion.dwMajorVersion >= 1
         && httpVersion.dwMinorVersion >= 1 )
    {
        dwSizeEncHeader = 1;
        dwSizeHeader += strlen(gszAcceptEncHeaders);
    }

    // delete the old header and allocate a new buffer
    if (_pszHeader)
    {
        delete _pszHeader;
        _pszHeader = 0;
    }

    if (dwSizeHeader || dwSizeEncHeader)
    {
        _pszHeader = new CHAR [dwSizeHeader + 1];
    }

    if (_pszHeader)
    {
        if (szLocal && szLocal[0] != 0)
        {
            strcat(_pszHeader, szLocal);
        }

        if( dwSizeEncHeader)
        {
            strcat(_pszHeader, gszAcceptEncHeaders);
        }
    }

    PerfDbgLog2(tagCINetHttp, this, "-CINetHttp::GetAdditionalHeader (pStr:>%s<, hr:%lx)", XDBG(_pszHeader,""), NOERROR);

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::GetDataToSend
//
//  Synopsis:
//
//  Arguments:  [ppBuffer] --
//              [pdwSize] --
//
//  Returns:
//
//  History:    2-05-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::GetDataToSend(LPVOID *ppBuffer, DWORD *pdwSize)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::GetDataToSend",
                "this=%#x, %#x, %#x",
                this, ppBuffer, pdwSize
                ));
                
    HRESULT hr = INET_E_DOWNLOAD_FAILURE;
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::GetDataToSend");

    *ppBuffer = NULL;
    *pdwSize  = 0;
    BINDINFO *pBndInfo = GetBindInfo();

    if (pBndInfo)
    {
        switch (pBndInfo->dwBindVerb)
        {
        default:
        case BINDVERB_CUSTOM   :
        case BINDVERB_POST     :
        case BINDVERB_PUT      :
        {
            if (pBndInfo->stgmedData.tymed == TYMED_HGLOBAL)
            {
                *ppBuffer = pBndInfo->stgmedData.hGlobal;
                *pdwSize = pBndInfo->cbstgmedData;
                hr = NOERROR;
            }
        }
        break;
        case BINDVERB_GET     :
        // nothing should be uploaded
        break;
        }
    }

    PerfDbgLog3(tagCINetHttp, this, "-CINetHttp::GetDataToSend (pBuffer:%lx, dwSize:%ld, hr:%lx)", *ppBuffer, *pdwSize, hr);

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT CINetHttp::HttpNegGetRootSecurityId()
{
    HRESULT hr = NOERROR;
    BYTE            bRootSID[MAX_SIZE_SECURITY_ID];

    if (_pbRootSecurityId == NULL)
    {
        if (_pHttpNeg2 == NULL)
        {
        /*
            if (_pHttpNeg == NULL)
                hr = QueryService(IID_IHttpNegotiate, (void **) &_pHttpNeg);
                
            if (!_pHttpNeg || (hr != NOERROR))
                goto End;
         */
            hr = QueryService(IID_IHttpNegotiate2, (void **) &_pHttpNeg2);
            if (!_pHttpNeg2)
            {
                _pbRootSecurityId = INVALID_P_ROOT_SECURITY_ID;
                goto End;
            }
        }

        _cbRootSecurityId = MAX_SIZE_SECURITY_ID;
        hr = _pHttpNeg2->GetRootSecurityId( bRootSID, &_cbRootSecurityId, 0 );

        if (FAILED(hr))
        {
            _pbRootSecurityId = INVALID_P_ROOT_SECURITY_ID;
            goto End;
        }
        
        if (_cbRootSecurityId <= 0)
            goto End;
            
        _pbRootSecurityId = new BYTE[_cbRootSecurityId];
        if (!_pbRootSecurityId)
            goto End;

        memcpy (_pbRootSecurityId, bRootSID, _cbRootSecurityId);
    }
    
End:
    return hr;
}    


//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::HttpNegBeginningTransaction
//
//  Synopsis:
//
//  Arguments:  [szURL] --
//              [DWORD] --
//              [dwReserved] --
//              [pszAdditionalHeaders] --
//
//  Returns:
//
//  History:    2-08-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::HttpNegBeginningTransaction()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::HttpNegBeginningTransaction",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::HttpNegBeginningTransaction");
    HRESULT hr = NOERROR;
    LPWSTR pwzAddHeaders = NULL;

    if (_pHttpNeg == NULL)
    {
        hr = QueryService(IID_IHttpNegotiate, (void **) &_pHttpNeg);
    }
    if (_pHttpNeg && (hr == NOERROR))
    {
        LPWSTR pwzUrl = GetUrl();
        LPWSTR pwzHeaders = NULL;
        DWORD dwlen = 0;
        if (_pszHeader)
        {
            dwlen = strlen(_pszHeader);
            pwzHeaders = new WCHAR [dwlen +1];
            if (pwzHeaders == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto End;

            }
            A2W(_pszHeader, pwzHeaders,dwlen + 1);

        }

        PProtAssert((pwzUrl));
        hr = _pHttpNeg->BeginningTransaction(pwzUrl, pwzHeaders, NULL, &pwzAddHeaders);

        if (SUCCEEDED(hr) )
        {
            if (pwzAddHeaders)
            {
                // add the additional length
                dwlen += wcslen(pwzAddHeaders) * sizeof(WCHAR);
            }

            if (dwlen)
            {

                if (_pszSendHeader)
                {
                    if (strlen(_pszSendHeader) < (dwlen + 1))
                    {
                        // delete the old header
                        delete _pszSendHeader;
                        // allocate a new one
                        _pszSendHeader = new CHAR [dwlen + 1];
                    }
                }
                else
                {
                    _pszSendHeader = new CHAR [dwlen + 1];
                }

                if (_pszSendHeader)
                {
                    if ( pwzAddHeaders )
                    {
                        W2A(pwzAddHeaders, _pszSendHeader, dwlen + 1);

                        // append the original header
                        if (_pszHeader)
                        {
                            strcat(_pszSendHeader,_pszHeader);
                        }
                    }
                    else
                    {
                        // no additional header
                        strcpy(_pszSendHeader, _pszHeader);
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                // delete the wchar header
                if (pwzHeaders)
                {
                    delete pwzHeaders;
                }
            }
        }


    }
    else
    {
        PProtAssert((_pHttpNeg == NULL));
    }

End:

    // delete this buffer
    if (pwzAddHeaders)
    {
        delete pwzAddHeaders;
    }

    PerfDbgLog(tagCINetHttp, this, "-CINetHttp::HttpNegBeginningTransaction");

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::HttpNegOnHeadersAvailable
//
//  Synopsis:
//
//  Arguments:  [dwResponseCode] --
//              [szHeaders] --
//
//  Returns:
//
//  History:    2-08-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::HttpNegOnHeadersAvailable(DWORD dwResponseCode, LPSTR szResponseHeader)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::HttpNegOnHeadersAvailable",
                "this=%#x, %#x, %.80q",
                this, dwResponseCode, szResponseHeader
                ));
                
    PerfDbgLog2(tagCINetHttp, this, "+CINetHttp::HttpNegOnHeadersAvailable (dwResponseCode:%lx) (szResponseHeader:%s)", dwResponseCode, XDBG(szResponseHeader,""));
    HRESULT hr = NOERROR;

    PProtAssert((szResponseHeader != NULL));

    if (_pHttpNeg)
    {

        LPWSTR pwzResponseHeader;
        DWORD dwlen = strlen(szResponseHeader);

        pwzResponseHeader = new WCHAR [dwlen +1];
        if (pwzResponseHeader == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            PProtAssert((pwzResponseHeader));
            A2W(szResponseHeader, pwzResponseHeader, dwlen + 1);
            if( _pHttpNeg )
            {
                hr = _pHttpNeg->OnResponse(dwResponseCode, pwzResponseHeader,NULL ,NULL);
            }

            // the only valid return code is NOERROR
            PProtAssert((hr == NOERROR && "HttpNegotiate::OnHeaders returned ivalid hresult"));
            PProtAssert((pwzResponseHeader));

            delete pwzResponseHeader;
        }
    }

    PerfDbgLog1(tagCINetHttp, this, "-CINetHttp::HttpNegOnHeadersAvailable (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::HttpNegOnError
//
//  Synopsis:
//
//  Arguments:  [dwResponseCode] --
//              [szResponseHeaders] --
//              [pszAdditionalRequestHeaders] --
//
//  Returns:
//
//  History:    2-08-96   JohannP (Johann Posch)   Created
//
//  Notes:      return S_FALSE as default - will stop download
//              and map to INET_E hresult
//----------------------------------------------------------------------------
HRESULT CINetHttp::HttpNegOnError(DWORD dwResponseCode, LPSTR szResponseHeader)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::HttpNegOnError",
                "this=%#x, %#x, %.80q",
                this, dwResponseCode, szResponseHeader
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::HttpNegOnError");
    HRESULT hr = S_FALSE;

    PProtAssert((szResponseHeader != NULL));

    if (_pHttpNeg)
    {
        LPWSTR pwzNewSendHeader = 0;
        LPWSTR pwzSendHeader = 0;
        LPWSTR pwzResponseHeader = 0;
        DWORD dwLenSendHeader = 0;
        DWORD dwLenResponseHeader = 0;

        if (_pszSendHeader)
        {
            dwLenSendHeader = strlen(_pszSendHeader);
            pwzSendHeader = new WCHAR [dwLenSendHeader + 1];
        }

        if (pwzSendHeader)
        {
            A2W(_pszSendHeader, pwzSendHeader, dwLenSendHeader + 1);
        }

        if (szResponseHeader)
        {
            dwLenResponseHeader = strlen(szResponseHeader);
            pwzResponseHeader = new WCHAR [dwLenResponseHeader + 1];
        }

        if (pwzResponseHeader)
        {
            A2W(szResponseHeader, pwzResponseHeader, dwLenResponseHeader + 1);
        }

        if( _pHttpNeg )
        {
            hr = _pHttpNeg->OnResponse(dwResponseCode, pwzResponseHeader,pwzSendHeader ,&pwzNewSendHeader);
        }

        if (pwzSendHeader)
        {
            delete pwzSendHeader;
            pwzSendHeader = 0;
        }

        if (pwzResponseHeader)
        {
            delete pwzResponseHeader;
            pwzResponseHeader = 0;
        }

        if ((hr == NOERROR) && (pwzNewSendHeader != NULL))
        {
            LPSTR pszNewSendHeader = 0;
            DWORD dwLen = wcslen(pwzNewSendHeader);
            DWORD dwLen1 = 0;
            if (_pszSendHeader)
            {
                dwLen1 = strlen(_pszSendHeader);
                PProtAssert((dwLen + dwLen1));

                pszNewSendHeader = new CHAR [dwLen + dwLen1 + 1];

                if (pszNewSendHeader)
                {
                    strcpy(pszNewSendHeader, _pszSendHeader);
                    W2A(pwzNewSendHeader,pszNewSendHeader + dwLen1, dwLen + 1);

                    // retry the call
                    hr = E_RETRY;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = S_FALSE;
            }
        }
        else
        {
            // we should not have headers
            PProtAssert((pwzNewSendHeader == NULL));
            if (pwzNewSendHeader)
            {
                delete pwzNewSendHeader;
            }
        }
    }
    else
    {
        // the error should be mapped to an INET_E hresult
        hr = S_FALSE;
    }

    PerfDbgLog1(tagCINetHttp, this, "-CINetHttp::HttpNegOnError (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::SecurityProblem
//
//  Synopsis:
//
//  Arguments:  [lpszBuffer] --
//              [pdwBuffSize] --
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::HttpSecurity(DWORD dwProblem)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::HttpSecurity",
                "this=%#x, %#x",
                this, dwProblem
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::HttpSecurity");
    HRESULT hr = NOERROR;
    HWND hwnd;

    hr = HttpSecurityProblem(&hwnd, dwProblem);

    if (hr == NOERROR)
    {
        if (hwnd)
        {
            DWORD  dwBindF = GetBindFlags();
            DWORD dwFlags = (FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS | FLAGS_ERROR_UI_FLAGS_GENERATE_DATA );

            if ((dwBindF & BINDF_NO_UI) || (dwBindF & BINDF_SILENTOPERATION))
            {
                dwFlags |= FLAGS_ERROR_UI_FLAGS_NO_UI;
            }


            DWORD dwError;

            if (SUCCEEDED(ZonesSecurityCheck(hwnd, dwProblem, &dwError)))
            {
                // dwError will be set by ZonesSecurityCheck.
            }
            else
            {
                dwError = InternetErrorDlg(hwnd, _hRequest, dwProblem, dwFlags,NULL);
            }

            switch (dwError)
            {
            case ERROR_CANCELLED :
                _hrINet = hr = E_ABORT;
                break;

            case ERROR_SUCCESS  :
                _hrINet = hr = E_RETRY;
                break;

            default:
                _hrINet = hr = E_ABORT;
                break;
            }
        }
        else
        {
            hr = INET_E_SECURITY_PROBLEM;
        }
    }
    else if (hr == E_ABORT)
    {
        _hrINet = E_ABORT;
    }

    if (hr == E_RETRY)
    {
        _hrINet = NOERROR;
        hr = INetAsyncSendRequest();
    }
    else if (hr == E_ABORT)
    {
        _hrINet = E_ABORT;
    }
    else if (hr != NOERROR )
    {
        // set the error to access denied
        _hrINet = hr = INET_E_SECURITY_PROBLEM;
    }

    PerfDbgLog1(tagCINetHttp, this, "-CINetHttp::HttpSecurity(hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINet::ZonesSecurityCheck
//
//  Synopsis:
//
//  Arguments:  [hwnd] --
//              [dwProblem] --
//              [pdwError] --
//
//  Returns:   SUCCESS if it was able to decide the action, INET_E_DEFAULT_ACTION otherwise.
//
//  History:    8-14-97   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT CINetHttp::ZonesSecurityCheck(HWND hWnd, DWORD dwProblem, DWORD *pdwError)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::ZonesSecurityCheck",
                "this=%#x, %#x, %#x, %#x",
                this, hWnd, dwProblem, pdwError
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::HttpSecurity");
    HRESULT hr = INET_E_DEFAULT_ACTION;

    if (pdwError == NULL)
    {
        TransAssert(FALSE);

        DEBUG_LEAVE(E_INVALIDARG);
        return E_INVALIDARG;
    }

    // Right now the only error we check for is the redirect confirmation error.
    if (dwProblem == ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION ||
        dwProblem == ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR)
    {
        IInternetSecurityManager *pSecMgr = NULL;

        if (SUCCEEDED(CoCreateInstance(CLSID_InternetSecurityManager, NULL,
                        CLSCTX_INPROC_SERVER, IID_IInternetSecurityManager, (void **)&pSecMgr)))
        {
            char szUrl[MAX_URL_SIZE];
            WCHAR wzUrl[MAX_URL_SIZE];
            DWORD cbLen = MAX_URL_SIZE;
            DWORD dwPolicy;

            TransAssert(pSecMgr != NULL);

            InternetQueryOption(_hRequest, INTERNET_OPTION_URL, szUrl, &cbLen);

            // First check if the redirect is to the same server. If that is the 
            // case we don't need to warn because we already did the first time around.

            if (dwProblem == ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION)
            {
                URL_COMPONENTS uc = { 0 };

                uc.dwStructSize = sizeof(uc);
                uc.dwHostNameLength = 1;     // So we get back the host name. 

                if ( InternetCrackUrl(szUrl, 0, 0, &uc) && 
                      (StrCmpNI(uc.lpszHostName, GetServerName(), uc.dwHostNameLength) == 0)
                   )
                {
                    *pdwError = ERROR_SUCCESS;
                    hr = S_OK;
                }
            }
            
            if (hr == INET_E_DEFAULT_ACTION)             
            {
                // Convert to widechar so we can call the security manager. 
                MultiByteToWideChar(CP_ACP, 0, szUrl, -1, wzUrl, MAX_URL_SIZE);

                PARSEDURL pu;
                pu.cbSize = sizeof(pu);

                DWORD dwPUAflags = (GetBindFlags() & BINDF_ENFORCERESTRICTED) ? PUAF_ENFORCERESTRICTED : 0;
                
                if (SUCCEEDED(ParseURLA(szUrl, &pu)) && pu.nScheme == URL_SCHEME_HTTPS)
                {
                    // The forms submit zones policies are only supposed to apply to
                    // unencrypted posts. We will allow these to be posted silently.
                    *pdwError = ERROR_SUCCESS;
                    hr = S_OK ;
                }
                else if (SUCCEEDED(pSecMgr->ProcessUrlAction(wzUrl, URLACTION_HTML_SUBMIT_FORMS_TO,
                                (BYTE *)&dwPolicy, sizeof(dwPolicy), NULL, 0, dwPUAflags | PUAF_NOUI, 0)))
                {
                    DWORD dwPermissions = GetUrlPolicyPermissions(dwPolicy);
                    // If it is allow or deny don't call InternetErrorDlg, unless it is a encrypted to
                    // unencrypted redir in which case we still need to warn the user..
                    if (dwPermissions == URLPOLICY_ALLOW && dwProblem != ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR)
                    {
                        *pdwError = ERROR_SUCCESS;
                        hr = S_OK;
                    }
                    else if (dwPermissions == URLPOLICY_DISALLOW)
                    {
                        *pdwError = ERROR_CANCELLED;
                        hr = S_OK;
                    }
                }
            }

            pSecMgr->Release();
        }
    }

    PerfDbgLog1(tagCINetHttp, this, "-CINetHttp::ZonesSecurityCheck(hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::HttpSecurityProblem
//
//  Synopsis:   QI's for HttpSecurity or IWindow
//
//  Arguments:  [phwnd] -- window handle for security dialog
//
//  Returns:    S_OK if dialog should be displayed
//
//  History:    2-08-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::HttpSecurityProblem(HWND* phwnd, DWORD dwProblem)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::HttpSecurityProblem",
                "this=%#x, %#x, %#x",
                this, phwnd, dwProblem
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::HttpSecurityProblem");
    HRESULT hr = NOERROR;
    *phwnd = 0;

    if (_pHttSecurity == NULL)
    {
        hr = QueryService(IID_IHttpSecurity, (void **) &_pHttSecurity);
    }

    if ((hr == NOERROR) && _pHttSecurity)
    {
         hr = _pHttSecurity->OnSecurityProblem(dwProblem);
         if (hr == S_OK)
         {
             // client wants to continue
         }
         else if (hr == S_FALSE)
         {
             // client does not care
             hr = _pHttSecurity->GetWindow(IID_IHttpSecurity, phwnd);
             UrlMkAssert((   ((hr == S_FALSE) && (*phwnd == NULL))
                          || ((hr == NOERROR) && (*phwnd != NULL)) ));
         }
         else if (hr != E_ABORT)
         {
             UrlMkAssert((FALSE && "Invalid result on IHttSecurity->OnSecurityProblem"));
         }
    }
    else
    {
        if (_pWindow == NULL)
        {
            hr = QueryService(IID_IWindowForBindingUI, (void **) &_pWindow);
        }
        else
            hr = NOERROR; //We need to reset this hr, since we cached _pWindow

        if ((hr == NOERROR) && _pWindow)
        {
             hr = _pWindow->GetWindow(IID_IHttpSecurity, phwnd);
             UrlMkAssert((   (hr == S_FALSE) && (*phwnd == NULL)
                          || (hr == S_OK) && (*phwnd != NULL)));
        }
    }

    PerfDbgLog2(tagCINetHttp, this, "-CINetHttp::HttpSecurityProblem (hr:%lx, hwnd:%lx)", hr, *phwnd);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::HResultFromInternetError
//
//  Synopsis:
//
//  Arguments:  [dwStatus] --
//
//  Returns:
//
//  History:    3-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::HResultFromHttpStatus(DWORD dwStatus)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::HResultFromHttpStatus",
                "this=%#x, %#x",
                this, dwStatus
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::HResultFromHttpStatus");
    HRESULT hr = NOERROR;
    switch(dwStatus)
    {
    case  HTTP_STATUS_OK                :
    case  HTTP_STATUS_NOT_MODIFIED      :
    case  HTTP_STATUS_RETRY_WITH        :
        hr = NOERROR;
    break;

    case  HTTP_STATUS_NOT_FOUND :
        hr = INET_E_OBJECT_NOT_FOUND;
    break;

    case  HTTP_STATUS_NONE_ACCEPTABLE   :
        // comes back if server can not handle mime type
        hr = INET_E_NO_VALID_MEDIA;
    break;

    case  HTTP_STATUS_SERVICE_UNAVAIL   :
        hr = INET_E_INVALID_REQUEST;
        break;

    case  HTTP_STATUS_GATEWAY_TIMEOUT  :
    case  HTTP_STATUS_REQUEST_TIMEOUT  :
        hr = INET_E_CONNECTION_TIMEOUT;
        break;

    case  HTTP_STATUS_CREATED           :
    case  HTTP_STATUS_ACCEPTED          :
    case  HTTP_STATUS_PARTIAL           :
    case  HTTP_STATUS_NO_CONTENT        :
    case  HTTP_STATUS_AMBIGUOUS         :
    case  HTTP_STATUS_MOVED             :
    case  HTTP_STATUS_REDIRECT          :
    case  HTTP_STATUS_REDIRECT_METHOD   :
    case  HTTP_STATUS_REDIRECT_KEEP_VERB:
    case  HTTP_STATUS_BAD_REQUEST       :
    case  HTTP_STATUS_DENIED            :
    case  HTTP_STATUS_PAYMENT_REQ       :
    case  HTTP_STATUS_FORBIDDEN         :
    case  HTTP_STATUS_BAD_METHOD        :
    case  HTTP_STATUS_PROXY_AUTH_REQ    :
    case  HTTP_STATUS_CONFLICT          :
    case  HTTP_STATUS_GONE              :
    case  HTTP_STATUS_LENGTH_REQUIRED   :
    case  HTTP_STATUS_SERVER_ERROR      :
    case  HTTP_STATUS_NOT_SUPPORTED     :
    case  HTTP_STATUS_BAD_GATEWAY       :
    default:
        //PProtAssert((FALSE && "Mapping Ineternet error to generic hresult!"));
        hr = INET_E_DOWNLOAD_FAILURE;
        DbgLog2(DEB_PROT|DEB_TRACE, this, "=== Mapping Internet error to generic hresult!(dwStatus:%ld, hr:%lx)", dwStatus, hr);
        break;
    }

    PerfDbgLog1(tagCINetHttp, this, "-CINetHttp::HResultFromHttpStatus (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::Terminate
//
//  Synopsis:   Close the server and request handle - wininet will make a
//              callback on each handle closed
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    07-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINetHttp::Terminate(DWORD dwOptions)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::Terminate",
                "this=%#x, %#x",
                this, dwOptions
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttp::Terminate");
    HRESULT hr = NOERROR;
    //PProtAssert(( IsApartmentThread() ));

    if (_pHttpNeg)
    {
        PerfDbgLog1(tagCINetHttp, this, "=== CINetHttp::Terminate Release on _pHttpNeg (%lx)", _pHttpNeg);
        _pHttpNeg->Release();
        _pHttpNeg = NULL;
    }
    
    if (_pHttpNeg2)
    {
        PerfDbgLog1(tagCINetHttp, this, "=== CINetHttp::Terminate Release on _pHttpNeg2 (%lx)", _pHttpNeg2);
        _pHttpNeg2->Release();
        _pHttpNeg2 = NULL;
    }
    
    if (_pWindow)
    {
        PerfDbgLog1(tagCINetHttp, this, "+CINetHttp::Terminate Release on _pWindow (%lx)", _pWindow);
        _pWindow->Release();
        _pWindow = NULL;
    }

    if (_pHttSecurity)
    {
        PerfDbgLog1(tagCINetHttp, this, "+CINetHttp::Terminate Release on _pHttSecurity (%lx)", _pHttSecurity);
        _pHttSecurity->Release();
        _pHttSecurity = NULL;
    }

    hr = CINet::Terminate(dwOptions);

    PerfDbgLog1(tagCINetHttp, this, "-CINetHttp::Terminate (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINetHttpS::CINetHttpS
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetHttpS::CINetHttpS(REFCLSID rclsid, IUnknown *pUnkOuter) : CINetHttp(rclsid,pUnkOuter)
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINetHttpS::CINetHttpS",
                "this=%#x, %#x, %#x",
                this, &rclsid, pUnkOuter
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttpS::CINetHttpS");

    _dwIsA = DLD_PROTOCOL_HTTPS;
    _dwConnectFlags = INTERNET_FLAG_SECURE;
    _dwOpenFlags = INTERNET_FLAG_SECURE;

    PerfDbgLog(tagCINetHttp, this, "-CINetHttpS::CINetHttpS");

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetHttpS::~CINetHttpS
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetHttpS::~CINetHttpS()
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINetHttpS::~CINetHttpS",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetHttp, this, "+CINetHttpS::~CINetHttpS");

    PerfDbgLog(tagCINetHttp, this, "-CINetHttpS::~CINetHttpS");

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::INetWrite
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::INetWrite()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::INetWrite",
                "this=%#x",
                this
                ));
                
    TransDebugOut((DEB_PROT, "%p OUT CINetHttp::INetWrite\n", this));
    HRESULT hr = NOERROR;

    BOOL fRet;
    DWORD dwSendFlags = HSR_CHUNKED | HSR_INITIATE;
    DWORD dwSendContext = 0;

    // If our caller gave us a TYMED_ISTREAM, then we need to pick it up
    // now.
    if (!_pStm)
    {
        BINDINFO *pBI = GetBindInfo();
        if (pBI && pBI->stgmedData.tymed == TYMED_ISTREAM)
        {
            _pStm = pBI->stgmedData.pstm;
        }
    }

    TransAssert((_pStm));
    if( _fSendAgain && _pStm )
    {
        LARGE_INTEGER        li;
        li.LowPart = 0;
        li.HighPart = 0;
        hr = _pStm->Seek(li, STREAM_SEEK_SET, NULL);
        if( SUCCEEDED(hr) )
        {
            _fSendEnd = FALSE;
        }
        else
        {
            _fCompleted = TRUE;
        }

        _fSendAgain = FALSE;
    }

    // loop until pending
    if (_fSendEnd)
    {
        _hrError = INET_E_DONE;
    }
    else do
    {
        _dwBytesSent = 0;

        SetStatePending(E_PENDING);

        hr = GetNextSendBuffer(&_inetBufferSend,_pStm);
        if (FAILED(hr))
        {
            break;
        }

        if (hr == S_FALSE)
        {
            // end of stream
            _fCompleted = TRUE;
        }

        if (!_fCompleted)
        {
            if (_inetBufferSend.dwBufferLength)
            {
                fRet = InternetWriteFile(
                            _hRequest           //IN HINTERNET hFile,
                            ,_inetBufferSend.lpvBuffer         //IN LPCVOID lpBuffer,
                            ,_inetBufferSend.dwBufferLength    //IN DWORD dwNumberOfBytesToWrite,
                            ,&_dwBytesSent       //OUT LPDWORD lpdwNumberOfBytesWritten
                            );
            }
            else
            {
                fRet = TRUE;
            }
        }
        else
        {
            fRet = HttpEndRequestA(
                         _hRequest              //IN HINTERNET hRequest,
                        ,NULL
                        ,dwSendFlags            //IN DWORD dwFlags,
                        ,dwSendContext          //IN DWORD dwContext

                        );

            _fSendEnd = TRUE;
        }

        //PerfDbgLog(tagCINetHttp, this, "-CINetHttp::INetAsyncSendRequest HttpSendRequest");

        if (fRet == FALSE)
        {
            DWORD dwLstError = GetLastError();
            if (dwLstError == ERROR_IO_PENDING)
            {
                // wait async for the handle
                hr = E_PENDING;
            }
            else
            {
                SetStatePending(NOERROR);
                hr = _hrError = INET_E_DOWNLOAD_FAILURE;
                SetBindResult(dwLstError,hr);
                //PerfDbgLog3(tagCINetHttp, this, "CINetHttp::INetAsyncSendRequest (fRet:%d, _hrError:%lx, LstError:%ld)", fRet, _hrError, dwLstError);
            }
        }
        else
        {
            SetStatePending(NOERROR);
        }

    } while ((fRet == TRUE) && (_fCompleted == FALSE));

    if (_hrError != INET_E_OK)
    {
        // we need to terminate here
        ReportResultAndStop((_hrError == INET_E_DONE) ? NOERROR : _hrError);
    }

    TransDebugOut((DEB_PROT, "%p OUT CINetHttp::INetWrite (hr:%lx)\n", this, hr));

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetHttp::GetNextSendBuffer
//
//  Synopsis:
//
//  Arguments:  [pIB] --
//              [pStm] --
//              [fFirst] --
//
//  Returns:
//
//  History:    4-28-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetHttp::GetNextSendBuffer(INTERNET_BUFFERS *pIB, IStream *pStm, BOOL fFirst)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetHttp::GetNextSendBuffer",
                "this=%#x, %#x, %#x, %B",
                this, pIB, pStm, fFirst
                ));
                
    TransDebugOut((DEB_PROT, "%p OUT CINetHttp::GetNextSendBuffer\n", this));
    HRESULT hr = NOERROR;

    TransAssert(pIB);

    do
    {
        BINDINFO *pBndInfo = GetBindInfo();
        DWORD dwBufferFilled = 0;

        if (!pStm)
        {
            hr = E_FAIL;
            break;
        }

        if (!fFirst)
        {
            TransAssert((_pBuffer));
            hr = pStm->Read(_pBuffer, _dwBufferSize, &dwBufferFilled);

            if (FAILED(hr))
            {
                break;
            }
            else if (!dwBufferFilled)
            {
            	hr = S_FALSE;
            }
        }
        else
        {
            LARGE_INTEGER        li;
            li.LowPart = 0;
            li.HighPart = 0;

            // We do not need to addref this here
            pStm->Seek(li, STREAM_SEEK_SET, NULL);

            if( !_pBuffer )
            {
                _pBuffer = new char [SENDBUFFER_MAX];

                if (!_pBuffer)
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }
                _dwBufferSize = SENDBUFFER_MAX;
            }
        }

        pIB->dwStructSize = sizeof (INTERNET_BUFFERSA);
        pIB->Next = 0;
        pIB->lpcszHeader = (fFirst) ? _pszSendHeader : 0;
        pIB->dwHeadersLength = (fFirst) ? ((_pszSendHeader) ? (ULONG)-1L : 0L) : 0;
        pIB->dwHeadersTotal = (fFirst) ? ((_pszSendHeader) ? (ULONG)-1L : 0L) : 0;
        pIB->lpvBuffer = (fFirst) ? 0 : _pBuffer;
        pIB->dwBufferLength = (fFirst) ? 0 : dwBufferFilled;
        pIB->dwBufferTotal = (fFirst) ? pBndInfo->cbstgmedData : 0; // :_dwBufferSize;
        pIB->dwOffsetLow = 0;
        pIB->dwOffsetHigh = 0;

        break;
    } while (TRUE);

    TransDebugOut((DEB_PROT, "%p OUT CINetHttp::GetNextSendBuffer (hr:%lx)\n", this, hr));

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\iapp\cnetsimp.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cnetftp.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <iapp.h>
#ifdef unix
#include <unistd.h>
#endif /* unix */

#include <shlwapip.h>

static DWORD dwLstError;

PerfDbgTag(tagCINetFile,    "Urlmon", "Log CINetFile",         DEB_PROT);
    DbgTag(tagCINetFileErr, "Urlmon", "Log CINetFile Errors",  DEB_PROT|DEB_ERROR);
PerfDbgTag(tagCINetSimple,  "Urlmon", "Log CINetSimple",       DEB_PROT);

#ifdef unix
extern "C" void unixForceAutoProxSync();
#endif /* unix */

LPWSTR FindFileExtensionW(LPWSTR pwzFileName)
{
    DEBUG_ENTER((DBG_APP,
                Pointer,
                "FindFileExtensionW",
                "%.80wq",
                pwzFileName
                ));
                
    LPWSTR pStr = NULL;
    LPWSTR lpF = pwzFileName + wcslen(pwzFileName); //Point to null

    if (lpF)
    {
        //Strip all trailing dots.
        for (lpF--; lpF >= pwzFileName && (*lpF == L'.' || *lpF == L' '); lpF --)
            *lpF = 0;

        for (; lpF >= pwzFileName && *lpF != L'.'; lpF --)
            if (*lpF == L'\\')
                return NULL;
    }

    if (lpF > pwzFileName)
    {
        pStr = lpF;
    }

    DEBUG_LEAVE(pStr);
    return pStr;

}

//+---------------------------------------------------------------------------
//
//  Method:     CINetFile::CINetFile
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetFile::CINetFile(REFCLSID rclsid, IUnknown *pUnkOuter) : CINet(rclsid,pUnkOuter)
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINetFile::CINetFile",
                "this=%#x, %#x, %#x",
                this, &rclsid, pUnkOuter
                ));
                
    PerfDbgLog(tagCINetFile, this, "+CINetFile::CINetFile");

    _dwIsA = DLD_PROTOCOL_FILE;
    _wzFileName[0] = '\0';
    
    PerfDbgLog(tagCINetFile, this, "-CINetFile::CINetFile");

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetFile::~CINetFile
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetFile::~CINetFile()
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINetFile::~CINetFile",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetFile, this, "+CINetFile::~CINetFile");

    if (_hFile && (_hFile != INVALID_HANDLE_VALUE))
    {
        CloseHandle(_hFile);
    }

    _wzFileName[0] = '\0';
    PerfDbgLog(tagCINetFile, this, "-CINetFile::~CINetFile");

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetFile::INetAsyncOpen
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetFile::INetAsyncOpen()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetFile::INetAsyncOpen",
                "this=%#x",
                this
                ));
                
    HRESULT hr = NOERROR;
    DWORD dwAttr;
    PerfDbgLog1(tagCINetFile, this, "+CINetFile::INetAsyncOpen(szObject:%ws)", GetObjectNameW());

    ReportNotification(BINDSTATUS_SENDINGREQUEST, GetServerName());

    // nothing to do - just call
    dwAttr = GetFileAttributesWrapW(GetObjectNameW());

#ifdef unix
    unixForceAutoProxSync();
    if(access(GetObjectName(),R_OK) == -1)
    {
        SetLastError(ERROR_ACCESS_DENIED);
        dwAttr = 0xffffffff;
    }
#endif /* unix */

    if (   (dwAttr != 0xffffffff)
        && !(dwAttr & FILE_ATTRIBUTE_DIRECTORY)
       )
    {
        HANDLE htemp = 0;
        DWORD dwSize = 0;
        {
            WIN32_FIND_DATAW finddata;

            htemp = FindFirstFileWrapW(GetObjectNameW(), &finddata);
            dwSize = finddata.nFileSizeLow;
        }
        _cbTotalBytesRead = dwSize;
        _cbDataSize = dwSize;

        if (htemp  && (htemp != INVALID_HANDLE_VALUE))
        {
            ReportNotificationW(BINDSTATUS_CACHEFILENAMEAVAILABLE, GetObjectNameW());
            
            // if the file has a file extension, try to
            // determine the MIME type that way...
            //
            LPWSTR pwsz = GetObjectNameW();
            pwsz = FindFileExtensionW(pwsz);
            if (pwsz)
            {
                char psz[MAX_PATH];
                psz[0] = '\0';

                W2A(pwsz, psz, MAX_PATH);
                char szMime[MAX_PATH];
                DWORD cb = MAX_PATH;

                if (SUCCEEDED(GetMimeFromExt(psz,szMime,&cb)))
                {
                    if( _grfBindF & BINDF_FROMURLMON )
                    {
                        ReportNotification(BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE, szMime);
                    }
                    else
                    {
                        ReportNotification(BINDSTATUS_MIMETYPEAVAILABLE, szMime);

                    }
    
                }
            }

            if (_pCTrans)
            {
                _bscf |= BSCF_LASTDATANOTIFICATION;
                _pCTrans->ReportData(_bscf, _cbTotalBytesRead, _cbDataSize);
                ReportResultAndStop(NOERROR, _cbTotalBytesRead, _cbDataSize );
            }                
         
            _hrError = INET_E_DONE;
            hr = NOERROR;
            FindClose(htemp);
        }
        else
        {
            SetCNetBindResult(GetLastError());
            hr = _hrError = INET_E_DATA_NOT_AVAILABLE;
        }
    }
    else if(   (dwAttr != 0xffffffff)
            && (dwAttr & FILE_ATTRIBUTE_DIRECTORY) )
    {
        hr = _hrError = INET_E_REDIRECT_TO_DIR;
    }
    else
    {
        // BUGBUG do authentication if this call failed due to
        // net permission being denied
        DbgLog2(tagCINetFileErr, this, "-CINetFile::INetAsyncOpen failed (dwAttr:%ld,filename:%ws)",dwAttr,GetObjectNameW());

        // If you pass \\servername to GetFileAttributesWrap, on NT4 it will return ERROR_FILE_NOT_FOUND
        // but ERROR_INVALID_NAME on all other platforms.
        // We remap this error so that iframes can navigate to \\servername on NT4
        // Reference: IE5/102590
        DWORD dwError = GetLastError();
        if ((dwError==ERROR_FILE_NOT_FOUND)  
            && PathIsUNCServer(GetObjectName()))
        {
            dwError = ERROR_INVALID_NAME;
        }
        // set the exact error for GetBindResult
        SetCNetBindResult(dwError);
        hr = _hrError = INET_E_RESOURCE_NOT_FOUND;
    }

    PerfDbgLog1(tagCINetFile, this, "-CINetFile::INetAsyncOpen (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetFile::Read
//
//  Synopsis:
//
//  Arguments:  [pBuffer] --
//              [cbBytes] --
//              [pcbBytes] --
//
//  Returns:
//
//  History:    2-13-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINetFile::Read(void *pBuffer, DWORD cbBytes, DWORD *pcbBytes)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetFile::IInternetProtocol::Read",
                "this=%#x, %#x, %#x, %#x",
                this, pBuffer, cbBytes, pcbBytes
                ));
                
    PerfDbgLog(tagCINetFile, this, "+CINetFile::Read");
    HRESULT hr = NOERROR;

    PProtAssert((cbBytes && pcbBytes));

    if (!_hFile)
    {
        LPWSTR wszFile = GetObjectNameW();

        PProtAssert((wszFile));

        if (wszFile)
        {
            // fill the internal buffer for data sniffing
            _hFile = CreateFileWrapW(wszFile, GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL, NULL);

        }

    }

    if (_hFile != INVALID_HANDLE_VALUE)
    {
        DWORD dwRead;
        if (ReadFile(_hFile, pBuffer, cbBytes, &dwRead, NULL))
        {
            *pcbBytes = dwRead;
            if (cbBytes != dwRead)
            {
                hr = S_FALSE;
            }
        }
        else
        {
            DbgLog2(tagCINetFileErr, this, " -CINetFile::Read could not read file (sniffing:%ld) (hr:%lx)", dwRead, hr);
            SetCNetBindResult(GetLastError());
            hr = _hrError = INET_E_DATA_NOT_AVAILABLE;
            ReportResultAndStop(hr);
        }
    }
    else
    {
        SetCNetBindResult(GetLastError());
        hr = _hrError = INET_E_DATA_NOT_AVAILABLE;
        ReportResultAndStop(hr);
        DbgLog2(tagCINetFileErr, this, "-CINetFile::Read could not open (file:%ws, hr:%lx)", GetObjectNameW(), hr);
    }

    PerfDbgLog4(tagCINetFile, this, "-CINetFile::Read (_hrError:%lx, [hr:%lx,cbBytesAsked:%ld,cbBytesReturned:%ld])",
                                    _hrError, hr, cbBytes, *pcbBytes);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetFile::LockFile
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    8-13-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetFile::LockFile(BOOL fRetrieve)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetFile::LockFile",
                "this=%#x, %B",
                this, fRetrieve
                ));
                
    PerfDbgLog(tagCINetFile, this, "+CINetFile::LockFile");
    HRESULT hr = NOERROR;

    if (!_hFile )
    {
        _hFile = CreateFileWrapW( GetObjectNameW(), GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL, NULL);
    }

    if (_hFile != INVALID_HANDLE_VALUE)
    {
        _fLocked = TRUE;
    }

    PerfDbgLog1(tagCINetFile, this, "-CINetFile::LockFile (hr:%lx,)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetFile::UnlockFile
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    8-13-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetFile::UnlockFile()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetFile::UnlockFile",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetFile, this, "IN CINetFile::UnlockFile");
    HRESULT hr = NOERROR;

    if (_fLocked)
    {
        PProtAssert((_hFile));
        CloseHandle(_hFile);
        _hFile = NULL;
        _fLocked = FALSE;
    }

    PerfDbgLog1(tagCINetFile, this, "-CINetFile::UnlockFile (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINetSimple::CINetSimple
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetSimple::CINetSimple(REFCLSID rclsid, IUnknown *pUnkOuter) : CINet(rclsid,pUnkOuter)
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINetSimple::CINetSimple",
                "this=%#x, %#x, %#x",
                this, &rclsid, pUnkOuter
                ));
                
    PerfDbgLog(tagCINetSimple, this, "+CINetSimple::CINetSimple");

    _dwState = INetState_START;
    _dwIsA = DLD_PROTOCOL_NONE;

    PerfDbgLog(tagCINetSimple, this, "-CINetSimple::CINetSimple");

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetSimple::~CINetSimple
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetSimple::~CINetSimple()
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINetSimple::~CINetSimple",
                "this=%#x",
                this
                ));

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetSimple::INetAsyncOpenRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetSimple::INetAsyncOpenRequest()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetSimple::INetAsyncOpenRequest",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetSimple, this, "+CINetSimple::INetAsyncOpenRequest");
    HRESULT hr = NOERROR;
    DWORD dwBindF = 0;

    SetINetState(INetState_PROTOPEN_REQUEST);
    PProtAssert((g_hSession != NULL));

    if (_hRequest && _fDoSimpleRetry)
    {
        // Abort the previous request if needed.
        // Note:  This is CINetSimple, so the behavior of closing the previous
        //        handle and retrying only applies to FTP and gopher requests.
        _fDoSimpleRetry = FALSE;
        _fHandlesRecycled = TRUE;
        TerminateRequest();
    }
 
    // get the open flags
    dwBindF = GetBindFlags();

    if (dwBindF & BINDF_GETNEWESTVERSION)
    {
        _dwOpenFlags |= INTERNET_FLAG_RELOAD;
    }

    if (   (dwBindF & BINDF_NOWRITECACHE)
        //BUG-WORK
        //&& !_pCTransData->IsFileRequired()
        )
    {
        _dwOpenFlags |= INTERNET_FLAG_DONT_CACHE ;
    }

    // BUGBUG OFFLINE, RELOAD, RESYNCHRONIZE and HYPERLINK are mutually
    // exclusive. But inside wininet there is priority, so
    // the priority is OFFLINE, RELOAD, RESYNCHRONIZE, HYPERLINK in that order

    if (dwBindF & BINDF_RESYNCHRONIZE)
    {
        // caller asking to do if-modified-since
        _dwOpenFlags |= INTERNET_FLAG_RESYNCHRONIZE;
    }

    if (dwBindF & BINDF_HYPERLINK)
    {
        // caller syas this is a hyperlink access
        _dwOpenFlags |= INTERNET_FLAG_HYPERLINK;
    }


    PrivAddRef();
    _HandleStateRequest = HandleState_Pending;

    // we always request keep-alive, use an existing connection (FTP) and
    // passive mode transfers (also FTP)
    _dwOpenFlags |= INTERNET_FLAG_KEEP_CONNECTION
                    | INTERNET_FLAG_EXISTING_CONNECT | INTERNET_FLAG_PASSIVE;

    HINTERNET hRequestTmp = InternetOpenUrl(g_hSession, _pszFullURL, NULL, 0, _dwOpenFlags, (DWORD_PTR) this);
    if ( hRequestTmp == 0)
    {
        dwLstError = GetLastError();
        if (dwLstError == ERROR_IO_PENDING)
        {
            // wait async for the handle
            hr = E_PENDING;
            SetStatePending(E_PENDING);

        }
        else
        {
            _hrError = INET_E_CANNOT_CONNECT;
            hr = E_FAIL;
        }
    }
    else
    {
        _hRequest = hRequestTmp;
        _HandleStateRequest = HandleState_Initialized;
        hr = INetAsyncSendRequest();
    }

    if (_hrError != INET_E_OK)
    {
        // we need to terminate here
        ReportResultAndStop(NOERROR);
    }

    PerfDbgLog1(tagCINetSimple, this, "-CINetSimple::INetAsyncOpenRequest (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetSimple::INetAsyncSendRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetSimple::INetAsyncSendRequest()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetSimple::INetAsyncSendRequest",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetSimple, this, "+CINetSimple::INetAsyncSendRequest");

    HRESULT hr = NOERROR;
    hr = QueryStatusOnResponse();
    
    if (! _fDoSimpleRetry && hr == NOERROR)
    {

        SetINetState(INetState_SEND_REQUEST);

        if (OperationOnAparmentThread(INetState_SEND_REQUEST))
        {
            TransitState(INetState_READ);
        }
        else
        {
            hr = INetRead();
        }
    }
    
    if (_hrError != INET_E_OK)
    {
        // we need to terminate here
        ReportResultAndStop(NOERROR);
    }

    PerfDbgLog1(tagCINetSimple, this, "-CINetSimple::INetAsyncSendRequest (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetSimple::INetAsyncConnect
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetSimple::INetAsyncConnect()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetSimple::INetAsyncConnect",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetSimple, this, "+CINetSimple::INetAsyncConnect");
    HRESULT hr = NOERROR;

    //just go into OpenRequest state
    hr = INetAsyncOpenRequest();

    PerfDbgLog1(tagCINetSimple, this, "-CINetSimple::INetAsyncConnect (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINetSimple::QueryStatusOnResponse
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-14-97   OliverW (Oliver Wallace)   Created
//              09-18-98   MeadH (Mead Himelstein) copy over to shipping code
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetSimple::QueryStatusOnResponse()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetSimple::QueryStatusOnResponse",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetSimple, this, "+CINetSimple::QueryStatusOnResponse");
    HRESULT hr = NOERROR;

    DWORD dwStatus = 0;
    DWORD cbLen = sizeof(DWORD);

    if (HttpQueryInfo(
            _hRequest,
            HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
            (LPVOID) &dwStatus,
            &cbLen,
            NULL
            ))
    {
        if (dwStatus == HTTP_STATUS_PROXY_AUTH_REQ)
        {
            _hrINet = INET_E_AUTHENTICATION_REQUIRED;
            TransitState(INetState_AUTHENTICATE, TRUE);
            hr = E_PENDING;
        }
    }

    PerfDbgLog1(tagCINetSimple, this, "-CINetSimple::QueryStatusOnResponse (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Method:     CINetSimple::QueryStatusOnResponseDefault
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-02-98   OliverW   Created
//              09-18-98   MeadH (Mead Himelstein) copy over to shipping code
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetSimple::QueryStatusOnResponseDefault(DWORD dwStat)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetSimple::QueryStatusOnResponseDefault",
                "this=%#x, %#x",
                this, dwStat
                ));
                
    PerfDbgLog(tagCINetSimple, this, "+CINetSimple::QueryStatusOnResponseDefault");
    PerfDbgLog1(tagCINetSimple, this, "-CINetSimple::QueryStatusOnResponseDefault (hr:%lx)", NOERROR);

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

    

//+---------------------------------------------------------------------------
//
//  Method:     CINetSimple::QueryHeaderOnResponse
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-02-98   OliverW   Created
//              09-18-98   MeadH (Mead Himelstein) copy over to shipping code
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetSimple::QueryHeaderOnResponse()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetSimple::QueryHeaderOnResponse",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetSimple, this, "+CINetSimple::QueryHeaderOnResponse");
    PerfDbgLog1(tagCINetSimple, this, "-CINetSimple::QueryHeaderOnResponse (hr:%lx)", NOERROR);

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}



//+---------------------------------------------------------------------------
//
//  Method:     CINetFtp::CINetFtp
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetFtp::CINetFtp(REFCLSID rclsid, IUnknown *pUnkOuter) : CINetSimple(rclsid, pUnkOuter)
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINetFtp::CINetFtp",
                "this=%#x, %#x, %#x",
                this, &rclsid, pUnkOuter
                ));
                
    PerfDbgLog(tagCINetSimple, this, "+CINetFtp::CINetFtp");

    _dwIsA = DLD_PROTOCOL_FTP;

    PerfDbgLog(tagCINetSimple, this, "-CINetFtp::CINetFtp");

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetFtp::INetAsyncSendRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    3-13-98   VincentR  Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetFtp::INetAsyncSendRequest()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetFtp::INetAsyncSendRequest",
                "this=%#x",
                this
                ));
                
    HRESULT hr = NOERROR;
    

    DWORD dwLowSize = 0;
    DWORD dwHighSize = 0;
    
    dwLowSize = FtpGetFileSize(_hRequest, &dwHighSize);
    if(dwLowSize != 0xffffffff)
        _cbDataSize = dwLowSize;

    hr = CINetSimple::INetAsyncSendRequest();

    DEBUG_LEAVE(hr);
    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetFtp::~CINetFtp
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetFtp::~CINetFtp()
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINetFtp::~CINetFtp",
                "this=%#x",
                this
                ));

    DEBUG_LEAVE(0);
}


//+---------------------------------------------------------------------------
//
//  Method:     CINetGopher::CINetGopher
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetGopher::CINetGopher(REFCLSID rclsid, IUnknown *pUnkOuter) : CINetSimple(rclsid,pUnkOuter)
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINetGopher::CINetGopher",
                "this=%#x, %#x, %#x",
                this, &rclsid, pUnkOuter
                ));
                
    PerfDbgLog(tagCINetSimple, this, "+CINetGopher::CINetGopher");

    _dwIsA = DLD_PROTOCOL_GOPHER;

    PerfDbgLog(tagCINetSimple, this, "-CINetGopher::CINetGopher");

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetGopher::~CINetGopher
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-06-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetGopher::~CINetGopher()
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINetGopher::~CINetGopher",
                "this=%#x",
                this
                ));

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\idl\makefile.inc ===
SDKINC = $(BASEDIR)\public\sdk\inc

$(SDKINC)\urlmon.idl: urlmon.idl
        copy urlmon.idl $(SDKINC)\urlmon.idl
        copy urlmon.idl $(SDKINC)\chicago\urlmon.idl

$(SDKINC)\chicago\urlmon.h: $(SDKINC)\urlmon.h
        copy $(SDKINC)\urlmon.h $(SDKINC)\chicago\urlmon.h

urlmki.idl: $(BASEDIR)\inetcore\published\inc\urlmki.idl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\iapp\precomp1.inc ===
#//+---------------------------------------------------------------
#//
#//  File:      precomp1.inc
#//
#//  Contents:  directives for global precompiled include file when the
#//             sources file is two directories below com (or wherever
#//             this file is located).  We could easily have precomp3 and
#//             precomp4 for other areas.The urlint.* files should not
#//             otherwise be mentioned in the sources files.
#//
#//
#//----------------------------------------------------------------

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\..\inc\iapp.h
PRECOMPILED_TARGET=$(GPCH_BUILD)\$(_OBJ_DIR)\*\iapp.pch
PRECOMPILED_OPTION=/Yuiapp.h /Fp$(GPCH_BUILD)\$(_OBJ_DIR)\*\iapp.pch
PRECOMPILED_OBJ=$(GPCH_BUILD)\$(_OBJ_DIR)\*\iapp.obj


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\idl\makeidl.inc ===
# DEST_TREE is set by the calling makefile

UMON_DEST=..\inc\$(DEST_TREE)

!ifndef MIDL
MIDL = midl.exe
!endif

#
# BUGBUG - We want to compile these IDL files /Oi but the interpretor
# cannot handle error_status_t parameters.  When it can, change /Os to /Oi
#
MIDL_FLAGS= \
 -Zp8 \
 -I$(INCLUDES) \
 -Os \
 -oldnames \
 -char unsigned \
 -error allocation \
 -ms_ext -c_ext \
 $(C_DEFINES) \
 -cpp_cmd $(TARGET_CPP)

CSWITCH=-prefix cstub _

urlmon.h:  ..\urlmon.idl
     $(MIDL) $(MIDL_FLAGS) \
        -cstub $(UMON_DEST)\umon_c.c    \
        -sstub $(UMON_DEST)\umon_s.c    \
        ..\urlmon.idl

allidl:   urlmon.h

clean:
          erase urlmon.h   >NUL 2>NUL

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\iapp\cnetstrm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cnetstrm.cxx
//
//  Contents:   Implements the stream: protocol
//
//  Classes:    CINetStream
//
//  Functions:
//
//  History:    5/3/96 Created Craig Critchley [craigc]
//
//----------------------------------------------------------------------------
#include <iapp.h>
#include <shlwapip.h>

PerfDbgTag(tagCINetStream, "Urlmon", "Log CINetStream", DEB_PROT);

//+---------------------------------------------------------------------------
//
//  Method:     CINetStream::CINetStream
//
//  Synopsis:   Constructs a stream protcol object
//
//  Arguments:  rclsid
//
//  Returns:
//
//  History:    5/3/96 Created Craig Critchley [craigc]
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetStream::CINetStream(REFCLSID rclsid, IUnknown *pUnkOuter) : CINet(rclsid,pUnkOuter)
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINetStream::CINetStream",
                "this=%#x, %#x, %#x",
                this, &rclsid, pUnkOuter
                ));
                
    PerfDbgLog(tagCINetStream, this, "CINetStream::CINetStream");
    _dwIsA = DLD_PROTOCOL_STREAM;
    _pstm = NULL;

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetStream::~CINetStream
//
//  Synopsis:   destroys a stream protocol object
//
//  Arguments:
//
//  Returns:
//
//  History:    5/3/96 Created Craig Critchley [craigc]
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetStream::~CINetStream()
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CINetStream::~CINetStream",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetStream, this, "CINetStream::~CInetStream");
    if (_pstm)
    {
        _pstm->Release();
    }

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetStream::INetAsyncOpen
//
//  Synopsis:   opens and synchronously downloads data from a stream
//
//  Arguments:  rclsid
//
//  Returns:
//
//  History:    5/3/96 Created Craig Critchley [craigc]
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetStream::INetAsyncOpen()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetStream::INetAsyncOpen",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetStream, this, "+CINetStream::INetAsyncOpen");
    IBindCtx * pbc = 0;
    IMoniker * pmk = 0;
    IStream * pstm = 0;
    IParseDisplayName * pParser = 0;
    STATSTG stat;
    CLSID clsid;
    CHAR szDisplayName[MAX_PATH];
    WCHAR wzDisplayName[MAX_PATH];
    WCHAR wzProgId[MAX_PATH];
    LPSTR pa, psz;
    LPWSTR pwz, pwzI;
    int cch;
    HRESULT hr = E_NOTIMPL;
    ULONG cchE;
    BOOL fGotMIMEType = FALSE;
    ULONG cchServerName, cchObjectName;

    ReportNotification(BINDSTATUS_SENDINGREQUEST);

    // need one of these
    //
    if (FAILED(hr = CreateBindCtx(0,&pbc)))
        goto End;

    //   form is mk:@progid:moniker
    //
    cchServerName = strlen(GetServerName());
    cchObjectName = strlen(GetObjectName());

    if ((cchServerName + cchObjectName) >= MAX_PATH)
    {
        hr = E_FAIL;
        goto End;
    }

    strcpy(szDisplayName,GetServerName());
    strcat(szDisplayName,psz = GetObjectName());

    // if the moniker has a file extension, try to
    // determine the MIME type that way...
    //
    psz = FindFileExtension(psz);
    if (psz)
    {
        char szMime[MAX_PATH];
        DWORD cb = MAX_PATH;

        if (SUCCEEDED(GetMimeFromExt(psz,szMime,&cb)))
        {
            ReportNotification(BINDSTATUS_MIMETYPEAVAILABLE, szMime);
            fGotMIMEType = TRUE;
        }
    }

    A2W(szDisplayName,wzDisplayName,MAX_PATH);

    //   find progid
    //
    for (pwz = wzDisplayName, pwzI = wzProgId; *pwz; pwz++)
    {
        if (*pwz == '@')
        {
            pwzI = wzProgId;
        }
        else if (*pwz == ':')
        {
            *pwzI = 0;

            // the remainder may have a filename with a useful
            // extension... just in case, set the filename...
            //
            LPSTR pszStr = DupW2A(pwz+1);
            if (pszStr)
            {
                ReportNotification(BINDSTATUS_CACHEFILENAMEAVAILABLE, pszStr);
                delete pszStr;
            }

            break;
        }
        else
        {
            *pwzI++ = *pwz;
        }
    }

#if 0
    if (FAILED(hr = MkParseDisplayName(pbc,wzDisplayName,&cchE,&pmk)) && pmk)
        goto End;
#else
    // BUGBUG
    //
    //   MkParseDisplayName was opening another instance of app
    //   force inproc server.  ick.
    //

    if (FAILED(hr = CLSIDFromProgID(wzProgId,&clsid)))
    {
        goto End;
    }

    if (FAILED(hr = CoCreateInstance(clsid,0,CLSCTX_INPROC_SERVER,
                                     IID_IParseDisplayName,(void**)&pParser)))
    {
        goto End;
    }

    PProtAssert((pParser));

    if (FAILED(hr = pParser->ParseDisplayName(pbc,wzDisplayName,&cchE,&pmk)))
    {
        goto End;
    }

    PProtAssert((pmk));

#endif

    if (FAILED(hr = pmk->BindToStorage(pbc,0,IID_IStream,(void**)&pstm)))
    {
        hr = INET_E_RESOURCE_NOT_FOUND;
        goto End;
    }

    PProtAssert((hr != MK_S_ASYNCHRONOUS));
    PProtAssert((pstm));

    _pstm = pstm;
    _pstm->AddRef();

    // now we have a stream - stuff it into the trans data
    //
    if (FAILED(hr = pstm->Stat(&stat,STATFLAG_NONAME)))
    {
        goto End;
    }

    _cbTotalBytesRead = stat.cbSize.LowPart;
    _cbDataSize = stat.cbSize.LowPart;

    ReportResultAndStop(NOERROR, _cbTotalBytesRead, _cbDataSize );

    _hrError = INET_E_DONE;

    End:

    if (FAILED(hr))
    {
        SetCNetBindResult(GetLastError());
        hr = _hrError = INET_E_RESOURCE_NOT_FOUND;
        ReportResultAndStop(_hrError);
    }

    // play nice, no leaks
    //
    if (pParser)
    {
        pParser->Release();
    }

    if (pmk)
    {
        pmk->Release();
    }
    if (pbc)
    {
        pbc->Release();
    }
    if (pstm)
    {
        pstm->Release();
    }

    // make sure I set this any way I get out
    //
    PProtAssert((hr != E_NOTIMPL));

    PerfDbgLog1(tagCINetStream, this, "-CINetStream::INetAsyncOpen (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetStream::Read
//
//  Synopsis:
//
//  Arguments:  [pBuffer] --
//              [cbBytes] --
//              [pcbBytes] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CINetStream::Read(void *pBuffer, DWORD cbBytes, DWORD *pcbBytes)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetStream::IInternetProtocol::Read",
                "this=%#x, %#x, %#x, %#x",
                this, pBuffer, cbBytes, pcbBytes
                ));
                
    PerfDbgLog(tagCINetStream, this, "+CINetStream::Read");
    HRESULT hr = E_FAIL;

    PProtAssert((cbBytes && pcbBytes));


    if (_pstm)
    {
        hr = _pstm->Read(pBuffer,cbBytes,pcbBytes);
    }

    PerfDbgLog4(tagCINetStream, this, "-CINetStream::Read (_hrError:%lx, [hr:%lx,cbBytesAsked:%ld,cbBytesReturned:%ld])",
        _hrError, hr, cbBytes, *pcbBytes);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINetStream::INetSeek
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [ULARGE_INTEGER] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetStream::INetSeek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetStream::INetSeek",
                "this=%#x",
                this, dlibMove, dwOrigin, plibNewPosition
                ));
                
    PerfDbgLog(tagCINetStream, this, "+CINetStream::INetSeek");
    HRESULT hr = E_FAIL;

    if (_pstm)
    {
        hr = _pstm->Seek(dlibMove, dwOrigin, plibNewPosition);
    }

    PerfDbgLog1(tagCINetStream, this, "-CINetStream::INetSeek (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetStream::LockFile
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    8-13-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetStream::LockFile(BOOL fRetrieve)
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetStream::LockFile",
                "this=%#x, %B",
                this, fRetrieve
                ));
                
    PerfDbgLog(tagCINetStream, this, "+CINetStream::LockFile");
    HRESULT hr = NOERROR;

    // nothing to do for now

    PerfDbgLog1(tagCINetStream, this, "-CINetStream::LockFile (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetStream::UnlockFile
//
//  Synopsis:   unlocks the file
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    8-13-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetStream::UnlockFile()
{
    DEBUG_ENTER((DBG_APP,
                Hresult,
                "CINetStream::UnlockFile",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCINetStream, this, "+CINetStream::UnlockFile");
    HRESULT hr = NOERROR;

    // nothing to do for now

    PerfDbgLog1(tagCINetStream, this, "-CINetStream::UnlockFile (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\iapp\curl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       curl.cxx
//
//  Contents:   handle url parsing and context urls parsing
//
//  Classes:
//
//  Functions:
//
//  History:    2-20-96   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <iapp.h>
#include <shlwapi.h>
#include <shlwapip.h>

PerfDbgTag(tagCUrl,    "Urlmon", "Log CUrl",     DEB_PROT);
PerfDbgTag(tagCUrlApi, "Urlmon", "Log CUrl API", DEB_ASYNCAPIS);

//+---------------------------------------------------------------------------
//
//  Function: IsStreamEnabled
//
//  Synopsis: returns TRUE iff the registry key for the mk: protocol is set
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:   6-7-96   craigc          Created
//
//  Notes:
//
//----------------------------------------------------------------------------
extern BOOL g_bGlobalUTF8hackEnabled;
BOOL StringContainsHighAnsiW(LPCWSTR);

BOOL IsStreamEnabled()
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "IsStreamEnabled",
                NULL
                ));
                
    HKEY    hk;
    char    szBuf[256];
    DWORD   dwType;
    DWORD   dwSize;
    const char    szKey[] = "SOFTWARE\\Microsoft\\Internet Explorer";
    const char    szValue[] = "MkEnabled";
    const char    szYes[] = "yes";

    static BOOL   fChecked = FALSE;
    static BOOL   fEnabled = FALSE;

    CMutexSem mxs;
    CLock lck(mxs);

    if (fChecked)
    {
        DEBUG_LEAVE(fEnabled);
        return fEnabled;
    }

    if (RegOpenKey(HKEY_LOCAL_MACHINE, szKey, &hk) != ERROR_SUCCESS)
    {
        DEBUG_LEAVE(FALSE);
        return( FALSE );
    }
    
    dwSize = sizeof(szBuf);
    if (RegQueryValueEx( hk, szValue, NULL, &dwType, (BYTE*)szBuf, &dwSize ) != ERROR_SUCCESS)
    {
        RegCloseKey( hk );

        DEBUG_LEAVE(FALSE);
        return( FALSE );
    }
    RegCloseKey( hk );

    fEnabled = (dwSize && (lstrcmpi( szYes, szBuf ) == 0));
    fChecked = TRUE;

    DEBUG_LEAVE(fEnabled);
    return fEnabled;
}

//
//  GetUrlScheme() returns one of the URL_SCHEME_* constants as
//  defined in shlwapip.h
//  example "http://foo" returns URL_SCHEME_HTTP
//
DWORD GetUrlScheme(IN LPCTSTR pcszUrl)
{
    DEBUG_ENTER((DBG_APP,
                Dword,
                "GetUrlScheme",
                "%#x",
                pcszUrl
                ));
                
    if(pcszUrl)
    {
        PARSEDURL pu;
        pu.cbSize = sizeof(pu);
        if(SUCCEEDED(ParseURL(pcszUrl, &pu)))
        {
            DEBUG_LEAVE(pu.nScheme);
            return pu.nScheme;
        }
    }

    DEBUG_LEAVE(URL_SCHEME_INVALID);
    return URL_SCHEME_INVALID;
}


//+---------------------------------------------------------------------------
//
//  Method:     CUrl::CUrl
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    2-20-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CUrl::CUrl()
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CUrl::CUrl",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCUrl, this, "+CUrl::CUrl");

    _pszBaseURL      = NULL;
    _pszPartURL      = NULL;
    _pszFullURL      = NULL;
    _pszProtocol     = NULL;
    _pszServerName   = NULL;
    _pszUserName     = NULL;
    _pszPassword     = NULL;
    _pszObject       = NULL;
    _pBasicAllocUnit = NULL;

    _ipPort = 0;
    _dwProto = 0;

    _fUTF8hack = FALSE;
    _pszUTF8ServerName = NULL;
    _dwServerCodePage = 0;
    
    PerfDbgLog(tagCUrl, this, "-CUrl::CUrl");

    DEBUG_LEAVE(0);
}

BOOL
CUrl::CUrlInitBasic(DWORD dwBaseUrlSize)
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "CUrl::CUrlInitBasic",
                "this=%#x, %#x",
                this, dwBaseUrlSize
                ));
                
    //
    // basic allocation contains the following fields:  
    //
    //  _pszServerName - URL_FIELD_SIZE
    //  _pszUserName   - URL_FIELD_SIZE
    //  _pszPassword   - URL_FIELD_SIZE
    //  _pszProtocol   - 12
    //  _pszBaseURL    - dwBaseUrlSize + 1
    //
    BOOL fRet = FALSE;
    DWORD dwBasicUnitSize = (3 * (URL_FIELD_SIZE)) + 12 + dwBaseUrlSize + 1;
    _pBasicAllocUnit = new char[dwBasicUnitSize];

    if( _pBasicAllocUnit )
    {
        _pszServerName = _pBasicAllocUnit;
        _pszUserName   = _pszServerName + URL_FIELD_SIZE;
        _pszPassword   = _pszUserName   + URL_FIELD_SIZE;
        _pszProtocol   = _pszPassword   + URL_FIELD_SIZE;
        _pszBaseURL    = _pszProtocol   + 12;

        *_pszServerName = '\0';
        *_pszUserName   = '\0';
        *_pszPassword   = '\0';
        *_pszProtocol   = '\0';
        *_pszBaseURL    = '\0';

        fRet = TRUE;
    }

    DEBUG_LEAVE(fRet);
    return fRet;
}

BOOL
CUrl::CUrlInitAll()
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "CUrl::CUrlInitAll",
                "this=%#x",
                this
                ));
                
    // backword compatibility init all with URL_MAX_LENGTH
    BOOL fRet = FALSE;
    fRet = CUrlInitBasic(MAX_URL_SIZE);

    if( fRet )
    { 
        _pszPartURL = new char[MAX_URL_SIZE + 1];
        _pszFullURL = new char[MAX_URL_SIZE + 1];
        _pszObject  = new char[MAX_URL_SIZE + 1];
    
        if( !_pszPartURL || !_pszFullURL || !_pszObject )
        {

            if (_pszPartURL)
                delete _pszPartURL;

            if (_pszFullURL)
                delete _pszFullURL;

            if (_pszObject)
                delete _pszObject;

            _pszPartURL = NULL;
            _pszFullURL = NULL;
            _pszObject  = NULL;

            fRet = FALSE; 
        }
        else
        {
            *_pszPartURL = '\0';
            *_pszFullURL = '\0';
            *_pszObject  = '\0';
        }
    }

    DEBUG_LEAVE(fRet);
    return fRet;
}

CUrl::~CUrl()
{
    DEBUG_ENTER((DBG_APP,
                None,
                "CUrl::~CUrl",
                "this=%#x",
                this
                ));
                
    if( _pBasicAllocUnit )
    {
        delete [] _pBasicAllocUnit;
    }
    if( _pszPartURL )
    {
        delete [] _pszPartURL;
    }
    if( _pszFullURL )
    {
        delete [] _pszFullURL;
    }
    if( _pszObject )
    {
        delete [] _pszObject;
    }
    if( _pszUTF8ServerName )
    {
        delete [] _pszUTF8ServerName;
    }

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Function:   ParseUrl
//
//  Synopsis:   Breaks down a URL and puts servername, objectname and port
//              into the download structure.
//
//  Arguments:
//
//
//  Returns:    TRUE if the URL was successfully parsed.
//
//  History:    Created    Unknown
//              02-20-95   JohannP (Johann Posch)   Created Class
//              03-20-95   JoeS    (Joe Souza)      Special FILE: syntaxes
//
//  Notes:      URL should have already been parsed earlier by ConstructURL.
//              This function will crack the URL.
//
//----------------------------------------------------------------------------
BOOL CUrl::ParseUrl(BOOL fUTF8Required, LPCWSTR pwzUrl, DWORD dwCodePage)
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "CUrl::ParseUrl",
                "this=%#x, %B",
                this, fUTF8Required
                ));
                
    PerfDbgLog1(tagCUrl, this, "+CUrl::ParseUrl Base:[%s]", _pszBaseURL);
    BOOL            fRet = TRUE;
    URL_COMPONENTS  url;
    DWORD           cchFullURL;
    LPSTR           szTemp;
    CHAR *          pch;
    DWORD           dwFullUrlLen;

    _fUTF8hack = FALSE; //possibly set true later in the function for non-redirect codepath.

    if (_pszPartURL && _pszPartURL[0] != '\0' )  // This string will be set for redirects.
    {
        //
        // we need re-alloc _pszFullURL and _pszObject, since
        // the the size can grow!
        //
        dwFullUrlLen = strlen(_pszBaseURL) + strlen(_pszPartURL) + 1;
        if(dwFullUrlLen > MAX_URL_SIZE)
        {
            dwFullUrlLen = MAX_URL_SIZE + 1;
        } 

        if( _pszFullURL )
        {
            delete [] _pszFullURL;
            _pszFullURL = NULL;
            _pszFullURL = new char[dwFullUrlLen];
        }

        if( _pszObject )
        {
            delete [] _pszObject;
            _pszObject = NULL;
            _pszObject = new char[dwFullUrlLen];
        }

        if( !_pszFullURL || !_pszObject  )
        {
            fRet = FALSE;
            goto Exit;
        }

        cchFullURL = dwFullUrlLen; 

        if(FAILED(UrlCombine(_pszBaseURL, _pszPartURL, _pszFullURL, &cchFullURL, URL_FILE_USE_PATHURL)))
        {
            fRet = FALSE;
            PProtAssert(FALSE && "Combine failed in ParseUrl!\n");

            goto Exit;
        }
    }
    else
    {
        // FullURL is BaseURL
        dwFullUrlLen = strlen(_pszBaseURL) + 1;
        if( !_pszFullURL )
        {
            _pszFullURL = new char[dwFullUrlLen];
        }

        if( !_pszObject )
        {
            _pszObject = new char[dwFullUrlLen];
        }

        if( !_pszFullURL || !_pszObject  )
        {
            fRet = FALSE;
            goto Exit;
        }

        lstrcpy(_pszFullURL, _pszBaseURL);
    }

    // Trim off intra-page link.
    //
    // NB: Don't use ExtraInfo below to do this because you will
    // also lose search string this way.
    //
    // Also, we need to do this before we decode the URL below,
    // so that we don't trim off the wrong '#' if there was one
    // encoded in the URL path.
    //
    //  UrlGetLocation() will intelligently find the fragment
    //  some schemes do not use the # as a fragment identifier.
    //  it returns a pointer to the #
    //

    if(pch = (CHAR *)UrlGetLocation(_pszFullURL))
    {
        *pch = TEXT('\0');
    }


    _dwProto = ProtoFromString(_pszFullURL);

    if (_dwProto == DLD_PROTOCOL_NONE)
    {
        fRet = FALSE;
        goto Exit;
    }

    
    if(DLD_PROTOCOL_FILE == _dwProto)
    {
        //
        // at this point, _pszFullURL and _pszObject should be all
        // allocated with size of dwFullUrlLen
        //
        DWORD cchObject = dwFullUrlLen;

        //do file stuff here
        fRet = SUCCEEDED(PathCreateFromUrl(_pszFullURL, _pszObject, &cchObject, 0));

    }
    else
    {
        //
        //  BUGBUG - InternetCrackUrl alters the original url - zekel - 25-JUL-97
        //  ICU is poorly behaved, and it unescapes the server and username
        //  components insitu regardless of whether it was requested or not
        //  this means that if you pass in http://host%76/, the url on return
        //  is http://hostv76/.  it happens that if you create the URL from the 
        //  components given, you will get the correct URL, but crack doesnt understand
        //  all URLs.  it is too late in the game to change the behavior of ICU,
        //  because wininet internally depends on the behavior.
        //  so our solution is to create a temp buffer that can be messed with
        //  and then throw it away after we are done.
        //
        LPSTR pszTemp = StrDup(_pszFullURL);

        if (pszTemp)
        {
            url.dwStructSize = sizeof(url);

            url.lpszScheme = _pszProtocol;
            url.dwSchemeLength =12;

            url.lpszHostName = _pszServerName;
            url.dwHostNameLength = URL_FIELD_SIZE;

            url.lpszUserName = _pszUserName;
            url.dwUserNameLength = URL_FIELD_SIZE;

            url.lpszPassword = _pszPassword;
            url.dwPasswordLength = URL_FIELD_SIZE;

            url.lpszUrlPath = _pszObject;
            url.dwUrlPathLength = dwFullUrlLen;

            url.lpszExtraInfo = NULL;
            url.dwExtraInfoLength = 0;

            fRet = InternetCrackUrl(pszTemp, 0, (_dwProto == DLD_PROTOCOL_STREAM ? ICU_DECODE : 0), &url);

            _ipPort = url.nPort;

        /*
            Code to pass in an MBCS servername to wininet always when this fix enabled 
            to get around the UTF8-servername bugs. - I-DNS fix.
         */

            if( fUTF8Required 
                && g_bGlobalUTF8hackEnabled
                && fRet
                && ((_dwProto == DLD_PROTOCOL_HTTP) 
                    || (_dwProto == DLD_PROTOCOL_HTTPS))
              )
            {
                DWORD dwHostname = MAX_URL_SIZE;
                WCHAR* pwzHostname = new WCHAR[MAX_URL_SIZE];
                char* pszHostname = new char[MAX_URL_SIZE];
                HRESULT hrTemp;
                BOOL bUsedDefaultChar;

                // This is NOT a loop - just an urlmon-style coding convention to avoid deep if-else-nesting.
                do
                {
                    fRet = FALSE;
                    
                    if (!pwzHostname || !pszHostname)
                    {
                        break;
                    }
                    
                    hrTemp = UrlGetPartW(pwzUrl, pwzHostname, &dwHostname, URL_PART_HOSTNAME, 0);
                    if (FAILED(hrTemp))
                    {
                        break;
                    }

                    if (!StringContainsHighAnsiW(pwzHostname))
                    {
                        // home free! - no high ansi in servername.
                        fRet = TRUE;
                        break;
                    }

                    if (dwCodePage == CP_UTF8)
                    {
                        dwCodePage = GetACP();
                    }
                   
                    //This fix cannot be ported to IE downlevel versions because WC_NO_BEST_FIT_CHARS is not
                    //supported on all OS versions.
                    if (0 == WideCharToMultiByte(dwCodePage, WC_NO_BEST_FIT_CHARS, pwzHostname, -1, 
                                pszHostname, MAX_URL_SIZE, NULL, &bUsedDefaultChar)
                        || bUsedDefaultChar)
                    {
                        fRet = false;
                        break;
                    }
                    
                    // Cache the UTF8 servername if we need it.
                    // This field is set only once ( not on redirects ),
                    // so release only in destructor.
                    
                    _pszUTF8ServerName = new char[url.dwHostNameLength+1];
                    if (!_pszUTF8ServerName)
                    {
                        break;
                    }
                    
                    lstrcpy(_pszUTF8ServerName, _pszServerName);
                    
                    // now clobber it with the MBCS servername
                    
                    //Compat: match side-effect of calling InternetCrackUrl
                    
                    dwHostname = URL_FIELD_SIZE;
                    hrTemp = UrlUnescapeA(pszHostname, _pszServerName, &dwHostname, 0);
                    if(FAILED(hrTemp))
                    {
                        break;
                    }

                    // now put the original _pszFullURL back together with the MBCS servername
                    // instead of the UTF8 servername since wininet will have this.

                    url.lpszHostName = _pszServerName;
                    url.dwHostNameLength = dwHostname;

                    url.lpszUserName = NULL;
                    url.dwUserNameLength = 0;

                    url.lpszPassword = NULL;
                    url.dwPasswordLength = 0;
                    
                    if (!InternetCreateUrl(&url, 0, _pszFullURL, &dwFullUrlLen))
                    {
                        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
                        {
                            break;
                        }
                        
                        delete [] _pszFullURL;
                        _pszFullURL = new char[++dwFullUrlLen];

                        if (!_pszFullURL || !InternetCreateUrl(&url, 0, _pszFullURL, &dwFullUrlLen))
                        {
                            break;
                        }
                    }

                    // At this point, everything is right.
                    // 1. _pszFullURL has the same url as wininet.
                    // 2. _pszServerName has the MBCS hostname
                    // 3. _pszUTF8ServerName has the UTF8 hostname that would have gone to the proxy (if needed)

                    _dwServerCodePage = dwCodePage;
                    _fUTF8hack = TRUE;

                    fRet = TRUE;
                    break;
                }
                while(TRUE);
                
                if (pwzHostname)
                    delete [] pwzHostname;
                if (pszHostname)
                    delete [] pszHostname;            
            }
                
            LocalFree(pszTemp);
        }
        else
            fRet = FALSE;
    }


Exit:

    PerfDbgLog1(tagCUrl, this, "-CUrl::ParseUrl Full:[%s]", _pszFullURL);

    DEBUG_LEAVE(fRet);
    return(fRet);
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrl::ProtoFromString
//
//  Synopsis:
//
//  Arguments:  [lpszProtocol] --
//
//  Returns:
//
//  History:    Created   Unknown
//              2-20-96   JohannP (Johann Posch)   Modified for class
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CUrl::ProtoFromString(LPSTR lpszProtocol)
{
    DEBUG_ENTER((DBG_APP,
                Dword,
                "CUrl::ProtoFromString",
                "this=%#x, %.80q",
                this, lpszProtocol
                ));

    DWORD dwRetVal = DLD_PROTOCOL_NONE;
    PerfDbgLog1(tagCUrl, this, "CUrl::ProtoFromString [%s]", lpszProtocol);

    switch (GetUrlScheme(lpszProtocol))
    {
    case URL_SCHEME_HTTPS:
        dwRetVal = DLD_PROTOCOL_HTTPS;
        break;
    
    case URL_SCHEME_HTTP:
        dwRetVal = DLD_PROTOCOL_HTTP;
        break;

    case URL_SCHEME_FTP:
        dwRetVal = DLD_PROTOCOL_FTP;
        break;

    case URL_SCHEME_GOPHER:
        dwRetVal = DLD_PROTOCOL_GOPHER;
        break;
    
    case URL_SCHEME_FILE:
        dwRetVal = DLD_PROTOCOL_FILE;
        break;

    case URL_SCHEME_LOCAL:
        dwRetVal = DLD_PROTOCOL_LOCAL;
        break;
        
    case URL_SCHEME_MK:
        if(IsStreamEnabled())
            dwRetVal = DLD_PROTOCOL_STREAM;
        break;

    }

    DEBUG_LEAVE(dwRetVal);
    return dwRetVal;
}


// Helper API's

//+---------------------------------------------------------------------------
//
//  Function:   ConstructURL
//
//  Synopsis:
//
//  Arguments:  [pBC] -- Pointer to BindCtx
//              [pURLBase] -- Pointer to Base URL [IN]
//              [pURLRelative] -- Pointer to Relative URL [IN]
//              [pURLFull] -- Pointer to resultant complete URL [OUT]
//
//  Returns:
//
//  History:    02-21-96    JoeS    (Joe Souza)     Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI ConstructURL(LPBC pBC, LPMONIKER pmkContext, LPMONIKER pmkToLeft,
            LPWSTR pwzURLRelative, LPWSTR pwzURLFull, DWORD cURLSize,
            DWORD dwFlags)
{
    DEBUG_ENTER_API((DBG_API,
                Hresult,
                "ConstructURL",
                "%#x, %#x, %#x, %.80wq, %.80wq, %#x, %#x",
                pBC, pmkContext, pmkToLeft, pwzURLRelative, pwzURLFull, cURLSize, dwFlags
                ));
                
    PerfDbgLog2(tagCUrlApi, NULL, "+ConstructURL (rel:%ws, pmk:%lx)", pwzURLRelative, pmkContext);
    HRESULT     hr = NOERROR;
    DWORD       dwMnk = 0;
    LPMONIKER   pmkCtx = NULL;
    LPWSTR      wzURLBase = NULL;
    WCHAR       wszURLFull[MAX_URL_SIZE + 1];
    DWORD       cchURLFull;
    DWORD       cbSize;
    BOOL        bParseOk = FALSE;
    DWORD       dwCUFlags = URL_FILE_USE_PATHURL;

    if (dwFlags & CU_STANDARD_FORM)
    {
        dwCUFlags = 0;
    }

    if (!pwzURLRelative || !pwzURLFull || !cURLSize)
    {
        hr = E_INVALIDARG;
        goto ConstructExit;
    }

    pwzURLFull[0] = 0;

    if (!pmkContext && pBC)
    {
        // No Context Moniker was specified, so try to get one of those.

        hr = pBC->GetObjectParam(SZ_URLCONTEXT, (IUnknown **)&pmkCtx);
        if (hr != NOERROR)
        {
            pmkCtx = NULL;
        }
    }
    else if (pmkContext)
    {
        pmkCtx = pmkContext;
    }
    else if (pmkToLeft)
    {
        pmkCtx = pmkToLeft;
    }

    if (pmkCtx)
    {
        // There is a Context Moniker.  Make sure it is a URL moniker and
        // if it is, get the base URL from it.

        pmkCtx->IsSystemMoniker(&dwMnk);
        if (dwMnk == MKSYS_URLMONIKER)
        {
            hr = pmkCtx->GetDisplayName(pBC, NULL, &wzURLBase);
        }
    }

    hr = NOERROR;

    if (wzURLBase)
    {
        DWORD dwSizeIn = MAX_URL_SIZE;
        cchURLFull = MAX_URL_SIZE;
        bParseOk = SUCCEEDED(OInetCombineUrl(wzURLBase, pwzURLRelative, dwCUFlags, pwzURLFull, dwSizeIn, &cchURLFull, 0));

    }
    else if (dwFlags & CU_CANONICALIZE)
    {
        DWORD dwSizeIn = MAX_URL_SIZE;
        cchURLFull = MAX_URL_SIZE;
        bParseOk = SUCCEEDED(OInetParseUrl(pwzURLRelative,PARSE_CANONICALIZE, dwCUFlags, pwzURLFull, dwSizeIn,&cchURLFull,0));
    }
    else
    {
        // We did not combine a relative and a base URL, and caller
        // does not want to canonicalize, so we just copy the given URL
        // into the return buffer.
#ifndef unix
        wcsncpy(pwzURLFull, pwzURLRelative, cURLSize / 2);
#else
        wcsncpy(pwzURLFull, pwzURLRelative, cURLSize / sizeof(wchar_t));
#endif /* unix */
        goto ConstructExit;
    }


    if (!bParseOk || !wcslen(pwzURLFull))
    {
        hr = MK_E_SYNTAX;
    }

ConstructExit:

    if (wzURLBase)
    {
        delete wzURLBase;
    }

    PerfDbgLog2(tagCUrlApi, NULL, "-ConstructURL [%ws], hr:%lx", pwzURLFull, hr);

    DEBUG_LEAVE_API(hr);
    return hr;
}



//+---------------------------------------------------------------------------
//
// UTF-8 code from wininet written by RFirth
//
//----------------------------------------------------------------------------
DWORD
CountUnicodeToUtf8(
    IN LPCWSTR pwszIn,
    IN DWORD dwInLen,
    IN BOOL bEncode
    )

/*++

Routine Description:

    Count number of BYTEs required for UTF-8 conversion of UNICODE string. Count
    is terminated after dwInLen characters

Arguments:

    pwszIn  - pointer to input wide-character string

    dwInLen - number of characters in pwszIn

    bEncode - TRUE if we are to hex encode characters >= 0x80

Return Value:

    DWORD   - number of BYTEs required for conversion

--*/

{
    DEBUG_ENTER((DBG_APP,
                Dword,
                "CountUnicodeToUtf8",
                "%.80wq, %#x, %B",
                pwszIn, dwInLen, bEncode
                ));
                
    PProtAssert(pwszIn != NULL);
    PProtAssert(dwInLen != 0);

    DWORD dwCount = 0;
    DWORD oneCharLen = bEncode ? 3 : 1;
    DWORD twoCharLen = 2 * oneCharLen;

    //
    // N.B. code arranged to reduce number of jumps in loop to 1 (while)
    //

    do {

        WORD wchar = *pwszIn++;

        dwCount += (wchar & 0xF800) ? oneCharLen : 0;
        dwCount += ((wchar & 0xFF80) ? 0xFFFFFFFF : 0) & (twoCharLen - 1);
        ++dwCount;
    } while (--dwInLen != 0);

    DEBUG_LEAVE(dwCount);
    return dwCount;
}

DWORD
ConvertUnicodeToUtf8(
    IN LPCWSTR pwszIn,
    IN DWORD dwInLen,
    OUT LPBYTE pszOut,
    IN DWORD dwOutLen,
    IN BOOL bEncode
    )

/*++

Routine Description:

    Convert a string of UNICODE characters to UTF-8:

        0000000000000000..0000000001111111: 0xxxxxxx
        0000000010000000..0000011111111111: 110xxxxx 10xxxxxx
        0000100000000000..1111111111111111: 1110xxxx 10xxxxxx 10xxxxxx

Arguments:

    pwszIn      - pointer to input wide-character string

    dwInLen     - number of CHARACTERS in pwszIn INCLUDING terminating NUL

    pszOut      - pointer to output narrow-character buffer

    dwOutLen    - number of BYTEs in pszOut

    bEncode     - TRUE if we are to hex encode characters >= 0x80

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    Not enough space in pszOut to store results

--*/

{
    DEBUG_ENTER((DBG_APP,
                Dword,
                "CountUnicodeToUtf8",
                "%.80wq, %#x, %#x, %#x, %B",
                pwszIn, dwInLen, pszOut, dwOutLen, bEncode
                ));
                
    PProtAssert(pwszIn != NULL);
    PProtAssert((int)dwInLen > 0);
    PProtAssert(pszOut != NULL);
    PProtAssert((int)dwOutLen > 0);

    DWORD outputSize = bEncode ? 3 : 1;
    static char hexArray[] = "0123456789ABCDEF";

    while (dwInLen-- && dwOutLen) {

        WORD wchar = *pwszIn++;
        BYTE bchar;

        if (wchar <= 0x007F) {
            *pszOut++ = (BYTE)(wchar);
            --dwOutLen;
            continue;
        }

        BYTE lead = ((wchar >= 0x0800) ? 0xE0 : 0xC0);
        int shift = ((wchar >= 0x0800) ? 12 : 6);

        bchar = lead | (BYTE)(wchar >> shift);
        if (bEncode) {
            *pszOut++ = '%';
            *pszOut++ = hexArray[bchar >> 4];
            bchar = hexArray[bchar & 0x0F];
        }
        *pszOut++ = bchar;

        if (wchar >= 0x0800) {
            bchar = 0x80 | (BYTE)((wchar >> 6) & 0x003F);
            if (bEncode) {
                *pszOut++ = '%';
                *pszOut++ = hexArray[bchar >> 4];
                bchar = hexArray[bchar & 0x0F];
            }
            *pszOut++ = bchar;
        }
        
        bchar = 0x80 | (BYTE)(wchar & 0x003F);
        if (bEncode) {
            *pszOut++ = '%';
            *pszOut++ = hexArray[bchar >> 4];
            bchar = hexArray[bchar & 0x0F];
        }
        *pszOut++ = bchar;
    }

    DEBUG_LEAVE(ERROR_SUCCESS);
    return ERROR_SUCCESS;
}

BOOL
StringContainsHighAnsi(
    IN LPSTR pszIn,
    IN DWORD dwInLen
    )

/*++

Routine Description:

    Determine if string contains ANSI characters in range 0x80..0xFF. Search is
    stopped when we hit the first high-ANSI character, when we hit the terminator
    or when we have decremented dwInLen to zero

Arguments:

    pszIn   - pointer to string to test

    dwInLen - length of pszIn

Return Value:

    BOOL
        TRUE    - pszIn contains one or more high-ANSI characters

        FALSE   - pszIn (or substring of length dwInLen) does not contain
                  high-ANSI characters

--*/

{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "StringContainsHighAnsi",
                "%.80q, %#x",
                pszIn, dwInLen
                ));
                
    PProtAssert(pszIn != NULL);
    PProtAssert(dwInLen != 0);

    // only need to search the base portion 
    while (dwInLen-- && *pszIn && *pszIn != '?') {
        if (*pszIn++ & 0x80) {

            DEBUG_LEAVE(TRUE);
            return TRUE;
        }
    }

    DEBUG_LEAVE(FALSE);
    return FALSE;
}


BOOL
StringContainsHighAnsiW(
    IN LPCWSTR pwzIn
    )
/*--
    Unicode version of StringContainsHighAnsi()
--*/
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "StringContainsHighAnsiW",
                "%.80wq",
                pwzIn
                ));
                
    PProtAssert(pwzIn != NULL);

    // only need to search the base portion 
    while (*pwzIn && *pwzIn != L'?') 
    {
        if (*pwzIn >= 0x80) 
        {
            DEBUG_LEAVE(TRUE);
            return TRUE;
        }
        pwzIn++;
    }

    DEBUG_LEAVE(FALSE);
    return FALSE;
}


BOOL
ConvertUnicodeUrl(
    LPCWSTR pwzFrom, 
    LPSTR   pszTo,
    INT     cchTo,
    DWORD   dwCodePage,
    BOOL    fUTF8Enabled,
    BOOL*   pfUTF8Required
    
    )
{
    DEBUG_ENTER((DBG_APP,
                Bool,
                "ConvertUnicodeUrl",
                "%.80wq, %.80q, %#x, %#x, %B",
                pwzFrom, pszTo, cchTo, dwCodePage, fUTF8Enabled
                ));
                
    BOOL fSuccess = FALSE;

    //
    // In multibyte string, if we have any bytes(in the base url portion)
    // over 0x80, we will have to convert the base portion to utf-8
    // (leave the query portion as multi-byte)
    //
    // S_FALSE from the conversion above indicates that some wide chars couldn't be
    // mapped to the destination code page

    *pfUTF8Required = FALSE;

    if( fUTF8Enabled && StringContainsHighAnsiW(pwzFrom))
    {
        *pfUTF8Required = TRUE;
        // utf-8 conversion

        //
        // do we have a query portion? (by searching the UNICODE URL string
        // for '?') also we can get the UNICODED string's BasePortion 
        // URL Length 
        // 
        DWORD  dwBaseUrlLen = 0;        // BasePortion length (in UNICODE)
        LPWSTR pBase = (LPWSTR) pwzFrom;
        while( *pBase && *pBase != '?')
        {
            pBase++;
            dwBaseUrlLen++;
        }

        DWORD  dwMBQryUrlLen  = 0;      // QueryPortion length (in Multibyte)
        LPSTR  pszQry = NULL;           // multibyte query string 
        if (*pBase)
        {
            //
            // we have a query portion, need to get length of
            // multi-byte query portion
            // In this case, we don't care whether or not pszTo is able to convert 
            // everything
            W2A(pBase, pszTo, cchTo, dwCodePage);
            dwMBQryUrlLen = strlen(pszTo);
            pszQry = pszTo;
        }
        
        //
        // we are converting the base portion of UNICODE URL to UTF-8 
        // count UTF-8 string length for base url
        //
        DWORD dwUTF8Len = CountUnicodeToUtf8(pwzFrom, dwBaseUrlLen, TRUE);

        //
        // allocate buffer for whole converted string 
        // Buffer size = UTF8_BaseURL_Len + MultiByte_Query_Len + '\0'
        //
        DWORD dwUTFBufferSize = dwUTF8Len + dwMBQryUrlLen + 1;

        // 
        // the size can not exceed incoming buffer size ccTo
        //
        if( dwUTFBufferSize > (DWORD)(cchTo + 1) )
        {
            //
            // fallback to IE4 behavior - sending multi-byte string
            //
            goto cleanup;
        }

        char* pszUTF8 = new char[dwUTFBufferSize];
        if( !pszUTF8 )
        {
            //
            // if we failed to allocate, we automatically
            // fallback to IE4 behavior - sending multi-byte string
            //
            goto cleanup;
        }
        memset(pszUTF8, 0, dwUTFBufferSize); 

        // Coverting UNICODE->UTF8
        DWORD dwError;
        dwError = ConvertUnicodeToUtf8( pwzFrom, 
                                        dwBaseUrlLen, 
                                        (LPBYTE)pszUTF8, 
                                        dwUTF8Len,
                                        TRUE );
        if( dwError != ERROR_SUCCESS )
        {
            //
            // if we failed, delete temp string and fallback to IE4
            // behavior - sending multi-byte string
            //
            delete [] pszUTF8;
            goto cleanup;
        } 

        //
        // copy over the Multi-byte query string to final buffer
        //
        if( pszQry )
        {
            LPSTR pszURL = pszUTF8 + dwUTF8Len;       
            while( dwMBQryUrlLen-- )
            {
                *pszURL = *pszQry;
                pszURL++;
                pszQry++;    
            }
        }

        //
        // we are done, copy the content from temp buffer to 
        // szTo 
        //
        StrCpyN(pszTo, pszUTF8, dwUTFBufferSize);

        // delete temp utf8 buffer 
        delete [] pszUTF8;
        fSuccess = TRUE;
    }
    
cleanup:
    if (!fSuccess)
    {
        // Unicode->Multibyte 
        // IE4 behaviour. Shoot.
        W2A(pwzFrom, pszTo, cchTo, dwCodePage);
    }

    DEBUG_LEAVE(TRUE);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\inc\agent.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       trans.h
//
//  Contents:   precompiled header file for the trans directory
//
//  Classes:
//
//  Functions:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

//#include <afx.h>
//#include <afxcoll.h>
#include "..\agent\stdafx.h"
#include <urlmon.hxx>
//#include "..\agent\agent.hxx"
#include "..\agent\courier.hxx"
//#include <tls.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\inc\compress.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       compress.h
//
//  Contents:   precompiled header file for compress directory
//
//  Classes:
//
//  Functions:
//
//  History:    07-14-97   DanpoZ (Danpo Zhang)   Created
//
//----------------------------------------------------------------------------
extern "C"
{
#ifdef unix
#include "../compress/gzip/api_int.h"
#else
#include "..\compress\gzip\api_int.h"
#endif /* !unix */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\inc\courier.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       trans.h
//
//  Contents:   precompiled header file for the trans directory
//
//  Classes:
//
//  Functions:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

//#include "..\courier\stdafx.h"
#include <urlmon.hxx>
#include "..\courier\courier.hxx"
#include <tls.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\inc\crtsubst.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    crtsubst.h

Abstract:

    Maps some CRT functions to Win32 calls

Author:

    Rajeev Dujari (rajeevd) 04-Apr-1996

Revision History:

    04-Apr-1997 vincentr
        Copied from wininet
    04-Apr-1996 rajeevd
        Created
--*/

#ifndef _CRTSUBSTR_H
#define _CRTSUBSTR_H

#include <shlwapi.h>

#ifndef unix 
/*
   On NT, kernel32 forwards RtlMoveMemory to ntdll.
   On 95, kernel32 has RtlMoveMemory but ntdll doesn't.
   Override the NT headers forwarding at compile time.
*/
#ifdef RtlMoveMemory
#undef RtlMoveMemory
#ifdef __cplusplus
extern "C" {
#endif
void RtlMoveMemory (void *, const void *, unsigned long);
#ifdef __cplusplus
}
#endif
#endif

/* WARNING: Be careful mapping CRT strncpy to Win32 lstrcpyn.

   strncpy  (dst, "bar", 2);  // dst will get 'b', 'a'
   lstrcpyn (dst, "bar" 2);   // dst will get 'b',  0

   strncpy  (dst, "bar", 6);  // dst will get 'b', 'a', 'r', 0, 0, 0
   lstrcpyn (dst, "bar", 6);  // dst will get 'b', 'a', 'r', 0
*/

#undef free
#undef malloc
#undef memmove
#undef strdup
#undef stricmp
#undef _stricmp
#undef strlwr
#undef _strlwr
#undef strupr
#undef tolower
#undef toupper
#undef wcslen
#undef wcscmp
#undef wcscpy
#undef wcsncpy
#undef wcscat
#undef wcschr
#undef wcsrchr
#undef wcsstr
#undef _wcsicmp
#undef _wcsnicmp
#undef _strstr
#undef strstr
#undef _strchr
#undef strchr
#undef _strrchr
#undef strrchr
#undef __atoi
#undef _atoi
#undef atoi
#undef atol
#undef _strncat
#undef strncat
#undef _strncpy
#undef strncpy
#undef _strnicmp
#undef strnicmp
#undef _strncmp
#undef strncmp
#undef sprintf
#undef vsprintf
#undef wvsprintf

#define free(ptr)         LocalFree((HLOCAL) ptr)
#define malloc(size)      ((PVOID)LocalAlloc(LMEM_FIXED, size))
#define memmove(m1,m2,n)  RtlMoveMemory (m1,m2,n)
#define strdup(s)         NewString(s)
#define stricmp(s1,s2)    lstrcmpi(s1,s2)
#define _stricmp(s1,s2)   lstrcmpi(s1,s2)
#define strlwr(s)         CharLower(s)
#define _strlwr(s)        CharLower(s)
#define strupr(s)         CharUpper(s)
#define tolower(c)        ((BYTE) CharLower((LPSTR) ((DWORD)((BYTE)(c) & 0xff))))
#define toupper(c)        ((BYTE) CharUpper((LPSTR) ((DWORD)((BYTE)(c) & 0xff))))
#define wcslen(s)         lstrlenW(s)
#define wcscmp            StrCmpW
#define wcscpy            StrCpyW
#define wcsncpy(s1, s2, n) StrCpyNW(s1, s2, n)
#define wcscat            StrCatW
#define wcschr            StrChrW
#define wcsrchr(s, c)     StrRChrW(s, NULL, c)
#define wcsstr            StrStrW
#define _wcsicmp          StrCmpIW
#define _wcsnicmp         StrCmpNIW
#define _strstr           StrStr
#define strstr            StrStr
#define _strchr           StrChr
#define strchr            StrChr
#define _strrchr(s, c)    StrRChr(s, NULL, c)
#define strrchr(s, c)     StrRChr(s, NULL, c)
#define __atoi            StrToInt
#define _atoi             StrToInt
#define atoi              StrToInt
#define atol              StrToInt
#define strncat           StrNCat
#define _strncat          StrNCat
#define strncpy           StrNCpy
#define _strncpy          StrNCpy
#define strnicmp          StrCmpNI
#define _strnicmp         StrCmpNI
#define strncmp           StrCmpN
#define _strncmp          StrCmpN
#define sprintf           w4sprintf
#define vsprintf          w4vsprintf
#define wvsprintf         w4vsprintf

#undef itoa
#undef ultoa

#define itoa(val,s,n)     _itoa(val,s,n)
#define ultoa(val,s,n)    _ultoa(val,s,n)

#endif /* unix */

#endif // _CRTSUBSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\inc\debug.h ===
//+----------------------------------------------------------------------------
//
//	File:
//		debug.h
//
//	Contents:
//		macros and declarations for debug support--all are appropriately
//		defined to nothing when not doing debug build
//
//	Classes:
//
//	Functions:
//
//	History:
//		12/30/93 - ChrisWe - added file prologue; defined _DEBUG when
//			DBG==1; added "const" to ASSERTDATA macro
//
//-----------------------------------------------------------------------------


#ifndef _DEBUG_H_
#define _DEBUG_H_

#include <debnot.h>

#ifndef RC_INVOKED
#ifdef _DEBUG
#define DBGSTATE " Debug is on"
#else
#define DBGSTATE " Debug is off"
#endif
#endif  /* RC_INVOKED */

#ifndef _CAIRO_
#include <ole2dbg.h>
#endif

//these are bogus APIs (they do nothing)
STDAPI_(BOOL) ValidateAllObjects( BOOL fSuspicious );
STDAPI_(void) DumpAllObjects( void );

#ifdef _DEBUG
BOOL InstallHooks(void);
BOOL UnInstallHooks(void);

#undef ASSERTDATA
#define ASSERTDATA

#undef AssertSz
#define AssertSz(a,b) ((a) ? NOERROR : FnAssert(#a, b, __FILE__, __LINE__))
#undef Puts
#define Puts(s) OutputDebugString(TEXT(s))

#else   //  !_DEBUG

#define ASSERTDATA
#define AssertSz(a, b) ((void)0)
#define Puts(s) ((void)0)

#endif  //  _DEBUG


// special Assert for asserts below (since the expression is so large)
// REVIEW, shouldn't these be in the debug.h file?
#ifdef _DEBUG
#define AssertOut(a, b) { if (!(a)) FnAssert(szCheckOutParam, b, __FILE__, __LINE__); }
#else
#define AssertOut(a, b) ((void)0)
#endif

#define AssertOutPtrParam(hr, p) \
	AssertOut(SUCCEEDED(hr) && IsValidPtrIn(p, sizeof(OLECHAR)) || \
	FAILED(hr) && (p) == NULL, \
	szBadOutParam)

#define AssertOutPtrIface(hr, p) \
	AssertOut(SUCCEEDED(hr) && IsValidInterface(p) || \
	FAILED(hr) && (p) == NULL, \
	szBadOutIface)

#define AssertOutPtrFailed(p) \
	AssertOut((p) == NULL, \
	szNonNULLOutPtr)

#define AssertOutStgmedium(hr, pstgm) \
	AssertOut(SUCCEEDED(hr) && (pstgm)->tymed != TYMED_NULL || \
	FAILED(hr) && (pstgm)->tymed == TYMED_NULL, \
	szBadOutStgm)


// assert data for above assert out macros; once per dll
// Note that since these are only used in asserts, we leave them as ANSI
#define ASSERTOUTDATA \
    char szCheckOutParam[] = "check out param"; \
    char szBadOutParam[] = "Out pointer param conventions not followed"; \
    char szBadOutIface[] = "Out pointer interface conventions not followed"; \
    char szNonNULLOutPtr[] = "Out pointer not NULL on error"; \
    char szBadOutStgm[] = "Out stgmed param conventions not followed";

extern char szCheckOutParam[];
extern char szBadOutParam[];
extern char szBadOutIface[];
extern char szNonNULLOutPtr[];
extern char szBadOutStgm[];


#ifdef __cplusplus

interface IDebugStream;

/*
 *  Class CBool wraps boolean values in such a way that they are
 *  readily distinguishable fron integers by the compiler so we can
 *  overload the stream << operator.
 */

class FAR CBool
{
    BOOL value;
public:
    CBool (BOOL& b) {value = b;}
    operator BOOL( void ) { return value; }
};


/*
 *  Class CHwnd wraps HWND values in such a way that they are
 *  readily distinguishable from UINTS by the compiler so we can
 *  overload the stream << operator
 */

class FAR CHwnd
{
	HWND m_hwnd;
	public:
		CHwnd (HWND hwnd) {m_hwnd = hwnd; }
		operator HWND( void ) {return m_hwnd;}
};

/*
 * Class CAtom wraps ATOM values in such a way that they are
 *  readily distinguishable from UINTS by the compiler so we can
 *  overload the stream << operator
 */

class FAR CAtom
{
	ATOM m_atom;
	public:
		CAtom (ATOM atom) {m_atom = atom; }
		operator ATOM( void ) {return m_atom; }
};

/*
 *  IDebugStream is a stream to be used for debug output.  One
 *  implementation uses the OutputDebugString function of Windows.
 *
 *  The style is modeled on that of AT&T streams, and so uses
 *  overloaded operators.  You can write to a stream in the
 *  following ways:
 *
 *    *pdbstm << pUnk;  // calls the IDebug::Dump function to
 *                      display the object, if IDebug is supported.
 *    int n;
 *    *pdbstm << n;     // writes n in decimal
 *
-
 *    *pdbstm << sz;    // writes a string
 *
 *    CBool b(TRUE);
 *    *pdbstm << b;     // writes True or False
 *
 *    void FAR * pv;
 *    *pdbstm << pv;    // writes the address pv in hex
 *
 *    TCHAR ch;
 *    *pdbstm << ch;    // writes the character
 *
 *    ATOM atom;
 *    *pdbstm << CAtom(atom);	// writes the string extracted from the atom
 *
 *    HWND hwnd;
 *    *pdbstm << CHwnd(hwnd);  // writes the info about a window handle
 *
 *  These can be chained together, as such (somewhat artificial
 *  example):
 *
 *    REFCLSID rclsid;
 *    pUnk->GetClass(&rclsid);
 *    *pdbstm << rclsid << " at " << (void FAR *)pUnk <<':' << pUnk;
 *
 *  This produces something like:
 *
 *    CFoo at A7360008: <description of object>
 *
 *  The other useful feature is the Indent and UnIndent functions
 *  which allow an object to print some information, indent, print
 *  the info on its member objects, and unindent.  This gives
 *  nicely formatted output.
 *
 *  WARNING:  do not (while implementing Dump) write
 *
 *    *pdbstm << pUnkOuter
 *
 *  since this will do a QueryInterface for IDebug, and start
 *  recursing!  It is acceptable to write
 *
 *    *pdbstm << (VOID FAR *)pUnkOuter
 *
 *  as this will simply write the address of pUnkOuter.
 *
 */


interface IDebugStream : public IUnknown
{
    STDMETHOD_(IDebugStream&, operator << ) ( IUnknown FAR * pDebug ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( REFCLSID rclsid ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( int n ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( long l ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( ULONG l ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( LPCTSTR sz ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( TCHAR ch ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( void FAR * pv ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( CBool b ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( CHwnd hwnd ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( CAtom atom ) = 0;
    STDMETHOD_(IDebugStream&, Tab )( void ) = 0;
    STDMETHOD_(IDebugStream&, Indent )( void ) = 0;
    STDMETHOD_(IDebugStream&, UnIndent )( void ) = 0;
    STDMETHOD_(IDebugStream&, Return )( void ) = 0;
    STDMETHOD_(IDebugStream&, LF )( void ) = 0;
};

STDAPI_(IDebugStream FAR*) MakeDebugStream( short margin=70, short tabsize=4, BOOL fHeader=1);


interface IDebug
{
    STDMETHOD_(void, Dump )( IDebugStream FAR * pdbstm ) = 0;
    STDMETHOD_(BOOL, IsValid )( BOOL fSuspicious = FALSE ) = 0;

#ifdef NEVER
    __export IDebug(void);
    __export ~IDebug(void);
private:

#ifdef _DEBUG
    IDebug FAR * pIDPrev;
    IDebug FAR * pIDNext;

    friend void STDAPICALLTYPE DumpAllObjects( void );
    friend BOOL STDAPICALLTYPE ValidateAllObjects( BOOL fSuspicious );
#endif // _DEBUG
#endif // NEVER
};

/*************************************************************************
** The following functions can be used to log debug messages to a file
**    and simutaneously write them to the dbwin debug window.
**    The CDebugStream implementation automatically writes to a debug
**    log file called "debug.log" in the current working directory.
**    NOTE: The functions are only intended for C programmers. C++
**    programmers should use the "MakeDebugStream" instead.
*************************************************************************/

// Open a log file.
STDAPI_(HFILE) DbgLogOpen(LPCTSTR lpszFile, LPCTSTR lpszMode);

// Close the log file.
STDAPI_(void) DbgLogClose(HFILE fh);

// Write to debug log and debug window (used with cvw.exe or dbwin.exe).
STDAPI_(void) DbgLogOutputDebugString(HFILE fh, LPCTSTR lpsz);

// Write to debug log only.
STDAPI_(void) DbgLogWrite(HFILE fh, LPCTSTR lpsz);

// Write the current Date and Time to the log file.
STDAPI_(void) DbgLogTimeStamp(HFILE fh, LPCTSTR lpsz);

// Write a banner separater to the log to separate sections.
STDAPI_(void) DbgLogWriteBanner(HFILE fh, LPCTSTR lpsz);




/*
 *  STDDEBDECL macro - helper for debug declaration
 *
 */

#ifdef _DEBUG

        #define STDDEBDECL(ignore, classname ) implement CDebug:public IDebug { public: \
            CDebug( C##classname FAR * p##classname ) { m_p##classname = p##classname;} \
            ~CDebug(void) {} \
            STDMETHOD_(void, Dump)(IDebugStream FAR * pdbstm ); \
            STDMETHOD_(BOOL, IsValid)(BOOL fSuspicious ); \
            private: C##classname FAR* m_p##classname; }; \
            DECLARE_NC(C##classname, CDebug) \
            CDebug m_Debug;

    #define CONSTRUCT_DEBUG m_Debug(this),

#else //        _DEBUG

//      no debugging
#define STDDEBDECL(cclassname,classname)
#define CONSTRUCT_DEBUG

#endif  //      _DEBUG

#endif // __cplusplus

#endif // !_DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\inc\iapp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       iapp.h
//
//  Contents:   precompiled header file for the trans directory
//
//  Classes:
//
//  Functions:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

#include <urlmon.hxx>
#ifndef unix
#include "..\iapp\curl.hxx"
#include "..\iapp\cnet.hxx"
#else
#include "../iapp/curl.hxx"
#include "../iapp/cnet.hxx"
#endif /* unix */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\inc\inetdbg.h ===
/*++

Module Name:

    inetdbg.h

Abstract:

    Manifests, macros, types and prototypes for Windows Internet client DLL
    debugging functions

Author:

    Venkatraman Kudallur (venkatk) 3-10-2000
    ( Ripped off from Wininet )

Revision History:

    3-10-2000 venkatk
        Created

--*/

#ifndef _INETDBG_H_
#define _INETDBG_H_ 1

#if defined(__cplusplus)
extern "C" {
#endif

//
// misc. debug manifests
//

#define DEBUG_WAIT_TIME     (2 * 60 * 1000)

//
// Checked builds get INET_DEBUG set by default; retail builds get no debugging
// by default
//

#if DBG

#if !defined(INET_DEBUG)

#define INET_DEBUG          1

#endif // INET_DEBUG

#else

#if !defined(INET_DEBUG)

#define INET_DEBUG          0

#endif // INET_DEBUG

#endif // DBG

//
// types
//

//
// DEBUG_FUNCTION_RETURN_TYPE - Type of result (scalar) that a function returns
//

#ifdef ENABLE_DEBUG

typedef enum {
    None,
    Bool,
    Int,
    Dword,
    Hresult,
    String,
    Handle,
    Pointer
} DEBUG_FUNCTION_RETURN_TYPE;


#define INTERNET_DEBUG_CONTROL_DEFAULT      (DBG_THREAD_INFO       \
                                            | DBG_CALL_DEPTH        \
                                            | DBG_ENTRY_TIME        \
                                            | DBG_PARAMETER_LIST    \
                                            | DBG_TO_FILE           \
                                            | DBG_INDENT_DUMP       \
                                            | DBG_SEPARATE_APIS     \
                                            | DBG_AT_ERROR_LEVEL    \
                                            | DBG_NO_ASSERT_BREAK   \
                                            | DBG_DUMP_LENGTH       \
                                            | DBG_NO_LINE_NUMBER    \
                                            | DBG_ASYNC_ID          \
                                            )
#define INTERNET_DEBUG_CATEGORY_DEFAULT     DBG_ANY
#define INTERNET_DEBUG_ERROR_LEVEL_DEFAULT  DBG_INFO

//
// options. These are the option values to use with InternetQueryOption()/
// InternetSetOption() to get/set the information described herein
//

#define INTERNET_OPTION_GET_DEBUG_INFO      1001
#define INTERNET_OPTION_SET_DEBUG_INFO      1002
#define INTERNET_OPTION_GET_HANDLE_COUNT    1003
#define INTERNET_OPTION_GET_TRIGGERS        1004
#define INTERNET_OPTION_SET_TRIGGERS        1005
#define INTERNET_OPTION_RESET_TRIGGERS      1006

#define INTERNET_FIRST_DEBUG_OPTION         INTERNET_OPTION_GET_DEBUG_INFO
#define INTERNET_LAST_DEBUG_OPTION          INTERNET_OPTION_RESET_TRIGGERS

//
// debug levels
//

#define DBG_INFO            0
#define DBG_WARNING         1
#define DBG_ERROR           2
#define DBG_FATAL           3
#define DBG_ALWAYS          99

//
// debug control flags - these flags control where the debug output goes (file,
// debugger, console) and how it is formatted
//

#define DBG_THREAD_INFO     0x00000001  // dump the thread id
#define DBG_CALL_DEPTH      0x00000002  // dump the call level
#define DBG_ENTRY_TIME      0x00000004  // dump the local time when the function is called
#define DBG_PARAMETER_LIST  0x00000008  // dump the parameter list
#define DBG_TO_DEBUGGER     0x00000010  // output via OutputDebugString()
#define DBG_TO_CONSOLE      0x00000020  // output via printf()
#define DBG_TO_FILE         0x00000040  // output via fprintf()
#define DBG_FLUSH_OUTPUT    0x00000080  // fflush() after every fprintf()
#define DBG_INDENT_DUMP     0x00000100  // indent dumped data to current level
#define DBG_SEPARATE_APIS   0x00000200  // empty line after leaving each API
#define DBG_AT_ERROR_LEVEL  0x00000400  // always output diagnostics >= InternetDebugErrorLevel
#define DBG_NO_ASSERT_BREAK 0x00000800  // don't call DebugBreak() in InternetAssert()
#define DBG_DUMP_LENGTH     0x00001000  // dump length information when dumping data
#define DBG_NO_LINE_NUMBER  0x00002000  // don't dump line number info
#define DBG_APPEND_FILE     0x00004000  // append to the log file (default is truncate)
#define DBG_LEVEL_INDICATOR 0x00008000  // dump error level indicator (E for Error, etc.)
#define DBG_DUMP_API_DATA   0x00010000  // dump data at API level (InternetReadFile(), etc.)
#define DBG_DELTA_TIME      0x00020000  // dump times as millisecond delta if DBG_ENTRY_TIME
#define DBG_CUMULATIVE_TIME 0x00040000  // dump delta time from start of trace if DBG_ENTRY_TIME
#define DBG_FIBER_INFO      0x00080000  // dump the fiber address if DBG_THREAD_INFO
#define DBG_THREAD_INFO_ADR 0x00100000  // dump INTERNET_THREAD_INFO address if DBG_THREAD_INFO
#define DBG_ARB_ADDR        0x00200000  // dump ARB address if DBG_THREAD_INFO
#define DBG_ASYNC_ID        0x00400000  // dump async ID
#define DBG_REQUEST_HANDLE  0x00800000  // dump request handle
#define DBG_TRIGGER_ON      0x10000000  // function is an enabling trigger
#define DBG_TRIGGER_OFF     0x20000000  // function is a disabling trigger
#define DBG_NO_DATA_DUMP    0x40000000  // turn off all data dumping
#define DBG_NO_DEBUG        0x80000000  // turn off all debugging

//
// debug category flags - these control what category of information is output
//

#define DBG_NOTHING         0x00000000  // internal
#define DBG_REGISTRY        0x00000001  //
#define DBG_TRANS           0x00000002  //
#define DBG_BINDING         0x00000004  //
#define DBG_STORAGE         0x00000008  //
#define DBG_TRANSDAT        0x00000010  //
#define DBG_API             0x00000020  //
#define DBG_DOWNLOAD        0x00000040  // 
#define DBG_APP             0x00000080  //
#define DBG_MONIKER         0x00000100  //
#define DBG_TRANSMGR        0x00000200  //
#define DBG_CALLBACK        0x00000400  //
#define DBG_19              0x00000800  //
#define DBG_18              0x00001000  //
#define DBG_17              0x00002000  //
#define DBG_16              0x00004000  //
#define DBG_15              0x00008000  //
#define DBG_14              0x00010000  //
#define DBG_13              0x00020000  //
#define DBG_12              0x00040000  //
#define DBG_11              0x00080000  //
#define DBG_10              0x00100000  //
#define DBG_9               0x00200000  //
#define DBG_8               0x00400000  //
#define DBG_7               0x00800000  //
#define DBG_6               0x01000000  //
#define DBG_5               0x02000000  //
#define DBG_4               0x04000000  //
#define DBG_3               0x08000000  //
#define DBG_2               0x10000000  //
#define DBG_1               0x20000000  //
#define DBG_ANY             0xFFFFFFFF  //

//
// _DEBUG_URLMON_FUNC_RECORD - for each thread, we maintain a LIFO stack of these,
// describing the functions we have visited
//

typedef struct _DEBUG_URLMON_FUNC_RECORD {

    //
    // Stack - a LIFO stack of debug records is maintained in the debug version
    // of the INTERNET_THREAD_INFO
    //

    struct _DEBUG_URLMON_FUNC_RECORD* Stack;

    //
    // Category - the function's category flag(s)
    //

    DWORD Category;

    //
    // ReturnType - type of value returned by function
    //

    DEBUG_FUNCTION_RETURN_TYPE ReturnType;

    //
    // Function - name of the function
    //

    LPCSTR Function;

    //
    // LastTime - if we are dumping times as deltas, keeps the last tick count
    //

    DWORD LastTime;

} DEBUG_URLMON_FUNC_RECORD, *LPDEBUG_URLMON_FUNC_RECORD;

//
// data
//

extern DWORD InternetDebugErrorLevel;
extern DWORD InternetDebugControlFlags;
extern DWORD InternetDebugCategoryFlags;
extern DWORD InternetDebugBreakFlags;

//
// prototypes
//

//
// inetdbg.cxx
//

VOID
InternetDebugInitialize(
    VOID
    );

VOID
InternetDebugTerminate(
    VOID
    );

BOOL
InternetOpenDebugFile(
    VOID
    );

BOOL
InternetReopenDebugFile(
    IN LPSTR Filename
    );

VOID
InternetCloseDebugFile(
    VOID
    );

VOID
InternetFlushDebugFile(
    VOID
    );

VOID
InternetDebugSetControlFlags(
    IN DWORD dwFlags
    );

VOID
InternetDebugResetControlFlags(
    IN DWORD dwFlags
    );

VOID
InternetDebugEnter(
    IN DWORD Category,
    IN DEBUG_FUNCTION_RETURN_TYPE ReturnType,
    IN LPCSTR Function,
    IN LPCSTR ParameterList,
    IN ...
    );

VOID
InternetDebugLeave(
    IN DWORD_PTR Variable,
    IN LPCSTR Filename,
    IN DWORD LineNumber
    );

VOID
InternetDebugError(
    IN DWORD Error
    );

VOID
InternetDebugPrint(
    IN LPSTR Format,
    ...
    );

VOID
InternetDebugPrintValist(
    IN LPSTR Format,
    IN va_list valist
    );

VOID
InternetDebugPrintf(
    IN LPSTR Format,
    IN ...
    );

VOID
InternetDebugOut(
    IN LPSTR Buffer,
    IN BOOL Assert
    );

VOID
InternetDebugDump(
    IN LPSTR Text,
    IN LPBYTE Address,
    IN DWORD Size
    );

DWORD
InternetDebugDumpFormat(
    IN LPBYTE Address,
    IN DWORD Size,
    IN DWORD ElementSize,
    OUT LPSTR Buffer
    );

VOID
InternetAssert(
    IN LPSTR Condition,
    IN LPSTR Filename,
    IN DWORD LineNumber
    );

VOID
InternetGetDebugVariable(
    IN LPSTR lpszVariableName,
    OUT LPDWORD lpdwVariable
    );

LPSTR
InternetMapError(
    IN DWORD Error
    );

int dprintf(char *, ...);

LPSTR
SourceFilename(
    LPSTR Filespec
    );

VOID
InitSymLib(
    VOID
    );

VOID
TermSymLib(
    VOID
    );

LPSTR
GetDebugSymbol(
    DWORD Address,
    LPDWORD Offset
    );

VOID
x86SleazeCallStack(
    OUT LPVOID * lplpvStack,
    IN DWORD dwStackCount,
    IN LPVOID * Ebp
    );

VOID
x86SleazeCallersAddress(
    LPVOID* pCaller,
    LPVOID* pCallersCaller
    );

#else  //ENABLE_DEBUG

#define dprintf (VOID)

#endif //ENABLE_DEBUG

//
// macros
//

#ifdef ENABLE_DEBUG

//
// INET_DEBUG_START - initialize debugging support
//

#define INET_DEBUG_START() \
    InternetDebugInitialize()

//
// INET_DEBUG_FINISH - terminate debugging support
//

#define INET_DEBUG_FINISH() \
    InternetDebugTerminate()

//
// INET_ASSERT - The standard assert, redefined here because Win95 doesn't have
// RtlAssert
//

#if defined(DISABLE_ASSERTS)

#define INET_ASSERT(test) \
    /* NOTHING */

#else // defined(DISABLE_ASSERTS)

#define INET_ASSERT(test) \
    do if (!(test)) { \
        InternetAssert(#test, __FILE__, __LINE__); \
    } while (0)

#endif // defined(DISABLE_ASSERTS)

#else // end #ifdef ENABLE_DEBUG

#define INET_DEBUG_START() \
    /* NOTHING */

#define INET_DEBUG_FINISH() \
    /* NOTHING */

#define INET_ASSERT(test) \
    do { } while(0) /* NOTHING */

#endif // end #ifndef ENABLE_DEBUG

//
// INET_DEBUG_ASSERT - assert only if INET_DEBUG is set
//

#if INET_DEBUG
#define INET_DEBUG_ASSERT(cond) INET_ASSERT(cond)
#else
#define INET_DEBUG_ASSERT(cond) /* NOTHING */
#endif

#if INET_DEBUG

//
// IF_DEBUG_CODE - always on if INET_DEBUG is set
//

#define IF_DEBUG_CODE() \
    if (1)

//
// IF_DEBUG - only execute following code if the specific flag is set
//

#define IF_DEBUG(x) \
    if (InternetDebugCategoryFlags & DBG_ ## x)

//
// IF_DEBUG_CONTROL - only execute if control flag is set
//

#define IF_DEBUG_CONTROL(x) \
    if (InternetDebugControlFlags & DBG_ ## x)

//
// DEBUG_ENTER - creates an INTERNET_DEBUG_RECORD for this function
//

#if defined(RETAIL_LOGGING)

#define DEBUG_ENTER(ParameterList) \
    /* NOTHING */

#define DEBUG_ENTER_API(ParameterList) \
    InternetDebugEnter ParameterList

#else // defined(RETAIL_LOGGING)

#define DEBUG_ENTER_API DEBUG_ENTER
#define DEBUG_ENTER(ParameterList) \
    InternetDebugEnter ParameterList

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_LEAVE - destroys this function's INTERNET_DEBUG_RECORD
//

#if defined(RETAIL_LOGGING)

#define DEBUG_LEAVE(Variable) \
    /* NOTHING */

#define DEBUG_LEAVE_API(Variable) \
    InternetDebugLeave((DWORD_PTR)Variable, __FILE__, __LINE__)

#else // defined(RETAIL_LOGGING)

#define DEBUG_LEAVE_API DEBUG_LEAVE
#define DEBUG_LEAVE(Variable) \
    InternetDebugLeave((DWORD_PTR)Variable, __FILE__, __LINE__)

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_ERROR - displays an error and its symbolic name
//

#define DEBUG_ERROR(Category, Error) \
    if (InternetDebugCategoryFlags & DBG_ ## Category) { \
        InternetDebugError(Error); \
    }

//
// DEBUG_PRINT - print debug info if we are at the correct level or we are
// requested to always dump information at, or above, InternetDebugErrorLevel
//

#if defined(RETAIL_LOGGING)

#define DEBUG_PRINT(Category, ErrorLevel, Args) \
    /* NOTHING */

#define DEBUG_PRINT_API(Category, ErrorLevel, Args) \
    if (((InternetDebugCategoryFlags & DBG_ ## Category) \
        && (DBG_ ## ErrorLevel >= InternetDebugErrorLevel)) \
    || ((InternetDebugControlFlags & DBG_AT_ERROR_LEVEL) \
        && (DBG_ ## ErrorLevel >= InternetDebugErrorLevel))) { \
        InternetDebugPrint Args; \
    }

#else // defined(RETAIL_LOGGING)

#define DEBUG_PRINT_API DEBUG_PRINT
#define DEBUG_PRINT(Category, ErrorLevel, Args) \
    if (((InternetDebugCategoryFlags & DBG_ ## Category) \
        && (DBG_ ## ErrorLevel >= InternetDebugErrorLevel)) \
    || ((InternetDebugControlFlags & DBG_AT_ERROR_LEVEL) \
        && (DBG_ ## ErrorLevel >= InternetDebugErrorLevel))) { \
        InternetDebugPrint Args; \
    }

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_PUT - prints formatted string to debug output stream
//

#if defined(RETAIL_LOGGING)

#define DEBUG_PUT(Args) \
    /* NOTHING */

#else // defined(RETAIL_LOGGING)

#define DEBUG_PUT(Args) \
    InternetDebugPrintf Args

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_DUMP - dump data
//

#if defined(RETAIL_LOGGING)

#define DEBUG_DUMP(Category, Text, Address, Length) \
    /* NOTHING */

#define DEBUG_DUMP_API(Category, Text, Address, Length) \
    if (InternetDebugCategoryFlags & DBG_ ## Category) { \
        InternetDebugDump(Text, (LPBYTE)Address, Length); \
    }

#else // defined(RETAIL_LOGGING)

#define DEBUG_DUMP_API DEBUG_DUMP
#define DEBUG_DUMP(Category, Text, Address, Length) \
    if (InternetDebugCategoryFlags & DBG_ ## Category) { \
        InternetDebugDump(Text, (LPBYTE)Address, Length); \
    }

#endif // defined(RETAIL_LOGGING)

//
// DEBUG_BREAK - break into debugger if break flag is set for this module
//

#define DEBUG_BREAK(Module) \
    if (InternetDebugBreakFlags & DBG_ ## Module) { \
        InternetDebugPrintf("Breakpoint. File %s Line %d\n", \
                            __FILE__, \
                            __LINE__ \
                            ); \
        DebugBreak(); \
    }

//
// WAIT_FOR_SINGLE_OBJECT - perform WaitForSingleObject and check we didn't
// get a timeout
//

#define WAIT_FOR_SINGLE_OBJECT(Object, Error) \
    Error = WaitForSingleObject((Object), DEBUG_WAIT_TIME); \
    if (Error == WAIT_TIMEOUT) { \
        InternetDebugPrintf("single object timeout\n"); \
        DebugBreak(); \
    }

//
// DEBUG_WAIT_TIMER - create DWORD variable for holding time
//

#define DEBUG_WAIT_TIMER(TimerVar) \
    DWORD TimerVar

//
// DEBUG_START_WAIT_TIMER - get current tick count
//

#define DEBUG_START_WAIT_TIMER(TimerVar) \
    TimerVar = GetTickCountWrap()

//
// DEBUG_CHECK_WAIT_TIMER - get the current number of ticks, subtract from the
// previous value recorded by DEBUG_START_WAIT_TIMER and break to debugger if
// outside the predefined range
//

#define DEBUG_CHECK_WAIT_TIMER(TimerVar, MilliSeconds) \
    TimerVar = (GetTickCountWrap() - TimerVar); \
    if (TimerVar > MilliSeconds) { \
        InternetDebugPrintf("Wait time (%d mSecs) exceeds acceptable value (%d mSecs)\n", \
                            TimerVar, \
                            MilliSeconds \
                            ); \
        DebugBreak(); \
    }

#define DEBUG_DATA(Type, Name, InitialValue) \
    Type Name = InitialValue

#define DEBUG_DATA_EXTERN(Type, Name) \
    extern Type Name

#define DEBUG_LABEL(label) \
    label:

#define DEBUG_GOTO(label) \
    goto label

#define DEBUG_ONLY(x) \
    x

#if defined(i386)

#define GET_CALLERS_ADDRESS(p, pp)  x86SleazeCallersAddress(p, pp)
#define GET_CALL_STACK(p)           x86SleazeCallStack((LPVOID *)&p, ARRAY_ELEMENTS(p), 0)

#else // defined(i386)

#define GET_CALLERS_ADDRESS(p, pp)
#define GET_CALL_STACK(p)

#endif // defined(i386)

#else // end #if INET_DEBUG

#define IF_DEBUG_CODE() \
    if (0)

#define IF_DEBUG(x) \
    if (0)

#define IF_DEBUG_CONTROL(x) \
    if (0)

#define DEBUG_ENTER(ParameterList) \
    /* NOTHING */

#define DEBUG_ENTER_API(ParameterList) \
    /* NOTHING */

#define DEBUG_LEAVE(Variable) \
    /* NOTHING */

#define DEBUG_LEAVE_API(Variable) \
    /* NOTHING */

#define DEBUG_ERROR(Category, Error) \
    /* NOTHING */

#define DEBUG_PRINT(Category, ErrorLevel, Args) \
    /* NOTHING */

#define DEBUG_PRINT_API(Category, ErrorLevel, Args) \
    /* NOTHING */

#define DEBUG_PUT(Args) \
    /* NOTHING */

#define DEBUG_DUMP(Category, Text, Address, Length) \
    /* NOTHING */

#define DEBUG_DUMP_API(Category, Text, Address, Length) \
    /* NOTHING */

#define DEBUG_BREAK(module) \
    /* NOTHING */

#define WAIT_FOR_SINGLE_OBJECT(Object, Error) \
    Error = WaitForSingleObject((Object), INFINITE)

#define DEBUG_WAIT_TIMER(TimerVar) \
    /* NOTHING */

#define DEBUG_START_WAIT_TIMER(TimerVar) \
    /* NOTHING */

#define DEBUG_CHECK_WAIT_TIMER(TimerVar, MilliSeconds) \
    /* NOTHING */

#define DEBUG_DATA(Type, Name, InitialValue) \
    /* NOTHING */

#define DEBUG_DATA_EXTERN(Type, Name) \
    /* NOTHING */

#define DEBUG_LABEL(label) \
    /* NOTHING */

#define DEBUG_GOTO(label) \
    /* NOTHING */

#define DEBUG_ONLY(x) \
    /* NOTHING */

#endif // INET_DEBUG

#if defined(__cplusplus)
}
#endif

#endif //ifndef _INETDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\inc\delaydll.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       delaydll.h
//
//  Contents:   precompiled headers for delayed dll 
//
//  Classes:
//
//  Functions:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#ifndef DELAY_DLL_H
#define DELAY_DLL_H

#include "oautdll.hxx"

extern COleAutDll   g_OleAutDll;

#pragma warning(disable:4005)
#define VariantClear            g_OleAutDll.VariantClear 
#define VariantInit             g_OleAutDll.VariantInit
#define VariantCopy             g_OleAutDll.VariantCopy
#define VariantChangeType       g_OleAutDll.VariantChangeType
#define SysAllocStringByteLen   g_OleAutDll.SysAllocStringByteLen
#define SysAllocString          g_OleAutDll.SysAllocString
#define SysStringByteLen        g_OleAutDll.SysStringByteLen
#define SysFreeString           g_OleAutDll.SysFreeString
#define LoadTypeLib             g_OleAutDll.LoadTypeLib
#pragma warning(default:4005)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\inc\eapp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       iapp.h
//
//  Contents:   precompiled header file for the trans directory
//
//  Classes:
//
//  Functions:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

#include <urlmon.hxx>
#include <compress.h>
#ifdef unix
#include "../eapp/cmimeft.hxx"
#include "../eapp/ccodeft.hxx"
#include "../eapp/protbase.hxx"
#include "../eapp/cdlbsc.hxx"
#include "../eapp/cdlprot.hxx"
#include "../eapp/clshndlr.hxx"
#else
#include "..\eapp\cmimeft.hxx"
#include "..\eapp\ccodeft.hxx"
#include "..\eapp\protbase.hxx"
#include "..\eapp\cdlbsc.hxx"
#include "..\eapp\cdlprot.hxx"
#include "..\eapp\clshndlr.hxx"
#endif /* unix */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\inc\mluisupp.h ===
#ifndef _INC_MLUISUPP
#define _INC_MLUISUPP

#include <shlwapi.h>
#include <shlwapip.h>

#ifdef __cplusplus
extern "C"
{
#endif

//+------------------------------------------------------------------
// Multilang Pluggable UI support
// inline functions defs (to centralize code)
// copied over from shell\inc\mluisupp.h with unneeded stuff removed.
//+------------------------------------------------------------------

#ifdef UNICODE
#define MLLoadString            MLLoadStringW
#define MLLoadShellLangString   MLLoadShellLangStringW
#define MLLoadResources         MLLoadResourcesW
#else
#define MLLoadString            MLLoadStringA
#define MLLoadShellLangString   MLLoadShellLangStringA
#define MLLoadResources         MLLoadResourcesA
#endif

void        MLFreeResources(HINSTANCE hinstParent);
HINSTANCE   MLGetHinst();
HINSTANCE   MLLoadShellLangResources();
void        ResWinHelp(HWND hwnd, int ids, int id2, DWORD_PTR dwp);

#ifdef MLUI_MESSAGEBOX
int         MLShellMessageBox(HWND hWnd, LPCTSTR pszMsg, LPCTSTR pszTitle, UINT fuStyle, ...);
#endif

//
// The following should be both A and W suffixed
//

int         MLLoadStringA(UINT id, LPSTR sz, UINT cchMax);
int         MLLoadStringW(UINT id, LPWSTR sz, UINT cchMax);

int         MLLoadShellLangStringA(UINT id, LPSTR sz, UINT cchMax);
int         MLLoadShellLangStringW(UINT id, LPWSTR sz, UINT cchMax);

void        MLLoadResourcesA(HINSTANCE hinstParent, LPSTR pszLocResDll);
void        MLLoadResourcesW(HINSTANCE hinstParent, LPWSTR pszLocResDll);

//
// End of: The following should be both A and W suffixed
//

#ifdef MLUI_INIT

// WARNING: do not attempt to access any of these members directly
// these members may not be initialized until appropriate accessors
// are called, for example hinstLocRes won't be intialized until
// you call MLGetHinst()... so just call the accessor.
struct tagMLUI_INFO
{
    HINSTANCE   hinstLocRes;
    HINSTANCE   hinstParent;
    WCHAR       szLocResDll[MAX_PATH];
    DWORD       dwCrossCodePage;
} g_mluiInfo;


// REARCHITECT: These aren't thread safe... Do they need to be?
//
void MLLoadResourcesA(HINSTANCE hinstParent, LPSTR pszLocResDll)
{
    if (g_mluiInfo.hinstLocRes == NULL)
    {
#ifdef MLUI_SUPPORT
        // plugUI: resource dll == ?
        // resource dll must be dynamically determined and loaded.
        // but we are NOT allowed to LoadLibrary during process attach.
        // therefore we cache the info we need and load later when
        // the first resource is requested.
        SHAnsiToUnicode(pszLocResDll, g_mluiInfo.szLocResDll, sizeof(g_mluiInfo.szLocResDll)/sizeof(g_mluiInfo.szLocResDll[0]));
        g_mluiInfo.hinstParent = hinstParent;
        g_mluiInfo.dwCrossCodePage = ML_CROSSCODEPAGE;
#else
        // non-plugUI: resource dll == parent dll
        g_mluiInfo.hinstLocRes = hinstParent;
#endif
    }
}

void MLLoadResourcesW(HINSTANCE hinstParent, LPWSTR pszLocResDll)
{
    if (g_mluiInfo.hinstLocRes == NULL)
    {
#ifdef MLUI_SUPPORT
        // plugUI: resource dll == ?
        // resource dll must be dynamically determined and loaded.
        // but we are NOT allowed to LoadLibrary during process attach.
        // therefore we cache the info we need and load later when
        // the first resource is requested.
        StrCpyNW(g_mluiInfo.szLocResDll, pszLocResDll, sizeof(g_mluiInfo.szLocResDll)/sizeof(g_mluiInfo.szLocResDll[0]));
        g_mluiInfo.hinstParent = hinstParent;
        g_mluiInfo.dwCrossCodePage = ML_CROSSCODEPAGE;
#else
        // non-plugUI: resource dll == parent dll
        g_mluiInfo.hinstLocRes = hinstParent;
#endif
    }
}

void
MLFreeResources(HINSTANCE hinstParent)
{
    if (g_mluiInfo.hinstLocRes != NULL &&
        g_mluiInfo.hinstLocRes != hinstParent)
    {
        MLClearMLHInstance(g_mluiInfo.hinstLocRes);
        g_mluiInfo.hinstLocRes = NULL;
    }
}

// this is a private internal helper.
// don't you dare call it from anywhere except at
// the beginning of new ML* functions in this file
__inline void
_MLResAssure()
{
#ifdef MLUI_SUPPORT
    if(g_mluiInfo.hinstLocRes == NULL)
    {
        g_mluiInfo.hinstLocRes = MLLoadLibraryW(g_mluiInfo.szLocResDll,
                                               g_mluiInfo.hinstParent,
                                               g_mluiInfo.dwCrossCodePage);

        // we're guaranteed to at least have resources in the install language
        ASSERT(g_mluiInfo.hinstLocRes != NULL);
    }
#endif
}

int
MLLoadStringA(UINT id, LPSTR sz, UINT cchMax)
{
    _MLResAssure();
    return LoadStringA(g_mluiInfo.hinstLocRes, id, sz, cchMax);
}

int
MLLoadStringW(UINT id, LPWSTR sz, UINT cchMax)
{
    _MLResAssure();
    return LoadStringWrapW(g_mluiInfo.hinstLocRes, id, sz, cchMax);
}

int
MLLoadShellLangStringA(UINT id, LPSTR sz, UINT cchMax)
{
    HINSTANCE   hinstShellLangRes;
    int         nRet;

    hinstShellLangRes = MLLoadShellLangResources();
    
    nRet = LoadStringA(hinstShellLangRes, id, sz, cchMax);

    MLFreeLibrary(hinstShellLangRes);

    return nRet;
}

int
MLLoadShellLangStringW(UINT id, LPWSTR sz, UINT cchMax)
{
    HINSTANCE   hinstShellLangRes;
    int         nRet;

    hinstShellLangRes = MLLoadShellLangResources();
    
    nRet = LoadStringWrapW(hinstShellLangRes, id, sz, cchMax);

    MLFreeLibrary(hinstShellLangRes);

    return nRet;
}

HINSTANCE
MLGetHinst()
{
    _MLResAssure();
    return g_mluiInfo.hinstLocRes;
}

HINSTANCE
MLLoadShellLangResources()
{
    HINSTANCE hinst;
    
    hinst = MLLoadLibraryW(g_mluiInfo.szLocResDll,
                           g_mluiInfo.hinstParent,
                           ML_SHELL_LANGUAGE);

    // we're guaranteed to at least have resources in the install language
    // unless we're 100% toasted

    return hinst;
}

BOOL
MLWinHelpWrap(HWND hwndCaller,
                   LPCTSTR lpszHelp,
                   UINT uCommand,
                   DWORD_PTR dwData)
{
    BOOL    fRet;

#ifdef MLUI_SUPPORT
    fRet = MLWinHelp(hwndCaller,
                     lpszHelp,
                     uCommand,
                     dwData);
#else
    fRet = WinHelp(hwndCaller,
                   lpszHelp,
                   uCommand,
                   dwData);
#endif

    return fRet;
}

LPTSTR LoadSz(UINT idString, LPTSTR lpszBuf, UINT cbBuf)
{
    // Clear the buffer and load the string
    if ( lpszBuf )
    {
        *lpszBuf = '\0';
        MLLoadString( idString, lpszBuf, cbBuf );
    }
    return lpszBuf;
}

void ResWinHelp(HWND hwnd, int ids, int id2, DWORD_PTR dwp)
{
    TCHAR szSmallBuf[50+1];
    MLWinHelpWrap((HWND)hwnd, LoadSz(ids,szSmallBuf,sizeof(szSmallBuf)),
            id2, (DWORD_PTR)dwp);
}
#endif  // MLUI_INIT

#ifdef __cplusplus
};
#endif

#endif  // _INC_MLUISUPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\inc\map_kv.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       map_kv.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-29-1996   JohannP (Johann Posch)   taken from OLE
//
//----------------------------------------------------------------------------
#ifndef __MAP_KV_H__
#define __MAP_KV_H__

typedef void FAR* POSITION;
#define BEFORE_START_POSITION ((POSITION)(ULONG_PTR)-1L)


/////////////////////////////////////////////////////////////////////////////
// class CMapKeyToValue - a mapping from 'KEY's to 'VALUE's, passed in as
// pv/cb pairs.  The keys can be variable length, although we optmizize the
// case when they are all the same.
//
/////////////////////////////////////////////////////////////////////////////

STDAPI_(UINT) MKVDefaultHashKey(LPVOID pKey, UINT cbKey);
DECLARE_HANDLE(HMAPKEY);
typedef UINT (STDAPICALLTYPE FAR* LPFNHASHKEY)(LPVOID, UINT);

class FAR CMapKeyToValue
{
public:
        CMapKeyToValue(UINT cbValue, UINT cbKey = 0,
                int nBlockSize=10,
                LPFNHASHKEY lpfnHashKey = NULL,
                UINT nHashSize = 17);
        ~CMapKeyToValue();

        // number of elements
        int     GetCount() const { return m_nCount; }
        BOOL    IsEmpty() const { return m_nCount == 0; }

        // Lookup; return FALSE if not found
        BOOL    Lookup(LPVOID pKey, UINT cbKey, LPVOID pValue) const;
        BOOL    LookupHKey(HMAPKEY hKey, LPVOID pValue) const;
        BOOL    LookupAdd(LPVOID pKey, UINT cbKey, LPVOID pValue) const;

        // add a new (key, value) pair; return FALSE if out of memory
        BOOL    SetAt(LPVOID pKey, UINT cbKey, LPVOID pValue);
        BOOL    SetAtHKey(HMAPKEY hKey, LPVOID pValue);

        // removing existing (key, ?) pair; return FALSE if no such key
        BOOL    RemoveKey(LPVOID pKey, UINT cbKey);
        BOOL    RemoveHKey(HMAPKEY hKey);
        void    RemoveAll();

        // iterating all (key, value) pairs
        POSITION GetStartPosition() const
                        { return (m_nCount == 0) ? (POSITION)NULL : BEFORE_START_POSITION; }
        void    GetNextAssoc(POSITION FAR* pNextPosition, LPVOID pKey,
                                UINT FAR* pcbKey, LPVOID pValue) const;

        // return HMAPKEY for given key; returns NULL if not currently in map
        HMAPKEY GetHKey(LPVOID pKey, UINT cbKey) const;

        void    AssertValid() const;
#ifndef unix
private:
#else
    // If this was not made public we get complier warnings
    // that CKeyWrap is not accessible from CAssoc declared below
    // which means global functions cant return CNode pointers
public:
#endif /* unix */
        // abstracts, somewhat, variable and fixed sized keys; size is really
        // m_cbKeyInAssoc.
        union CKeyWrap
        {
                BYTE rgbKey[sizeof(LPVOID) + sizeof(UINT)];
                struct
                {
                        LPVOID pKey;
                        UINT cbKey;
                }
#ifdef unix
                n 
#endif /* unix */
                ;
        };
        // Association of one key and one value; NOTE: even though in general
        // the size of the key and value varies, for any given map,
        // the size of an assoc is fixed.
        struct CAssoc
        {
                CAssoc  FAR* pNext;
                UINT    nHashValue; // needed for efficient iteration
                CKeyWrap key;           // size is really m_cbKeyInAssoc
                // BYTE rgbValue[m_cbValue];
        };
#ifdef unix
private:
#endif /* unix */
        UINT    SizeAssoc() const
                { return sizeof(CAssoc)-sizeof(CKeyWrap) + m_cbKeyInAssoc + m_cbValue; }
        CAssoc  FAR* NewAssoc(UINT hash, LPVOID pKey, UINT cbKey, LPVOID pValue);
        void    FreeAssoc(CAssoc FAR* pAssoc);
        BOOL    CompareAssocKey(CAssoc FAR* pAssoc, LPVOID pKey, UINT cbKey) const;
        CAssoc  FAR* GetAssocAt(LPVOID pKey, UINT cbKey, UINT FAR& nHash) const;

        BOOL    SetAssocKey(CAssoc FAR* pAssoc, LPVOID pKey, UINT cbKey) const;
        void    GetAssocKeyPtr(CAssoc FAR* pAssoc, LPVOID FAR* ppKey,UINT FAR* pcbKey) const;
        void    FreeAssocKey(CAssoc FAR* pAssoc) const;
        void    GetAssocValuePtr(CAssoc FAR* pAssoc, LPVOID FAR* ppValue) const;
        void    GetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const;
        void    SetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const;

        BOOL    InitHashTable();

        UINT    m_cbValue;
        UINT    m_cbKey;                        // variable length if 0
        UINT    m_cbKeyInAssoc;         // always non-zero

        CAssoc  FAR* FAR* m_pHashTable;
        UINT    m_nHashTableSize;
        LPFNHASHKEY m_lpfnHashKey;

        int     m_nCount;
        CAssoc  FAR* m_pFreeList;
        struct CPlex FAR* m_pBlocks;
        int     m_nBlockSize;
};


#endif // !__MAP_KV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\inc\trans.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       trans.h
//
//  Contents:   precompiled header file for the trans directory
//
//  Classes:
//
//  Functions:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

#include <urlmon.hxx>
#ifndef unix
#include "..\trans\transact.hxx"
#include "..\trans\bindctx.hxx"
#else
#include "../trans/transact.hxx"
#include "../trans/bindctx.hxx"
#endif /* unix */
#include <tls.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\inc\mon.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       iapp.h
//
//  Contents:   precompiled header file for the trans directory
//
//  Classes:
//
//  Functions:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

#include <urlmon.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\inc\tls.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       tls.h
//
//  Contents:   Manage thread local storage for UrlMon.
//              The non-inline routines are in ..\mon\tls.cxx
//  Classes:
//
//  Functions:
//
//  History:    12-02-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

#ifndef _TLS_H_
#define _TLS_H_

#include "clist.hxx"
#include "cookie.hxx"
#include "inetdbg.h"

class CTransactionMgr;
class CCDLPacketMgr;
class CCodeDownload;
class CDownload;
// notification/scheduler

//+---------------------------------------------------------------------------
//
// forward declarations (in order to avoid type casting when accessing
// data members of the SOleTlsData structure).
//
//+---------------------------------------------------------------------------

extern DWORD  gTlsIndex;                    // global Index for TLS

//+---------------------------------------------------------------------------
//
//  Enum:       URLMKTLSFLAGS
//
//  Synopsys:   bit values for dwFlags field of SUrlMkTlsData. If you just want
//              to store a BOOL in TLS, use this enum and the dwFlag field.
//
//+---------------------------------------------------------------------------
typedef enum tagURLMKTLSFLAGS
{
    URLMKTLS_LOCALTID        = 1,  // whether TID is in current process or not
    URLMKTLS_UUIDINITIALIZED = 2,  // whether logical thread was init'd
    URLMKTLS_INTHREADDETACH  = 4,  // Whether we are in thread detach. Needed
                                   // due to NT's special thread detach rules.
}  URLMKTLSFLAGS;


//+---------------------------------------------------------------------------
//
//  Structure:  SUrlMkTlsData
//
//  Synopsis:   structure holding per thread state needed by UrlMon
//
//+---------------------------------------------------------------------------
typedef struct tagSUrlMkTlsData
{
    DWORD               dwApartmentID;      // Per thread "process ID"
    DWORD               dwFlags;            // see URLMKTLSFLAGS above
    HWND                hwndUrlMkNotify;    // notification window
    LONG                cDispatchLevel;     // dispatch nesting level

    CTransactionMgr    *pCTransMgr;         // transaction manager

#ifdef PER_THREAD
    CMediaTypeHolder   *pCMediaHolder;      // media types register per apartment
#endif //PER_THREAD

    CList<CCodeDownload *,CCodeDownload *>*
                        pCodeDownloadList;  // linked list of pointers to
                                            // CCodeDownload objects ongoing on
                                            // this thread
    CCookie<CDownload*> *pTrustCookie;

                                            // only the cookie owner can do
                                            // setup/winverifytrust
                                            // Others wait for the
                                            // cookie to enter these phases
                                            // Cookie availabilty is posted
                                            // as a msg. We can't uses any
                                            // regular sync apis as this
                                            // is protecting execution by the
                                            // same thread in a diff msg.
    CCookie<CCodeDownload*>
                        *pSetupCookie;


    CCDLPacketMgr       *pCDLPacketMgr;     // per thread packet manager
                                            // A packet is a unit
                                            // of work that takes time eg.
                                            // trust verifcation of a piece
                                            // setup of a piece or INF
                                            // processing of one piece.
                                            // To be able to have the
                                            // client be responsive with UI
                                            // and abort capabilty we need
                                            // to split out work into as
                                            // small units as possible
                                            // and queue up these packets
                                            // Packets get run on a timer per
                                            // thread.
    CList<LPCWSTR ,LPCWSTR >*
                        pRejectedFeaturesList;
                                            // linked list of pointers to
                                            // features or code downloads that
                                            // the use has explicitly rejected
                                            // on this thread

#if DBG==1
    LONG                cTraceNestingLevel; // call nesting level for UrlMonTRACE
#endif

#ifdef ENABLE_DEBUG
    DWORD ThreadId;
    LPDEBUG_URLMON_FUNC_RECORD Stack;
    int CallDepth;
    int IndentIncrement;    

    DWORD StartTime;
    DWORD StopTime;

    DWORD MajorCategoryFlags;
    DWORD MinorCategoryFlags;
#endif //ENABLE_DEBUG

} SUrlMkTlsData;

//+---------------------------------------------------------------------------
//
//  class       CUrlMkTls
//
//  Synopsis:   class to abstract thread-local-storage in UrlMon.
//
//  Notes:      To use Tls in UrlMon, functions should define an instance of
//              this class on their stack, then use the -> operator on the
//              instance to access fields of the SOleTls structure.
//
//              There are two instances of the ctor. One just Assert's that
//              the SUrlMkTlsData has already been allocated for this thread. Most
//              internal code should use this ctor, since we can assert that if
//              the thread made it this far into our code, tls has already been
//              checked.
//
//              The other ctor will check if SUrlMkTlsData exists, and attempt to
//              allocate and initialize it if it does not. This ctor will
//              return an HRESULT. Functions that are entry points to UrlMon
//              should use this version.
//
//  History:    12-02-95   JohannP (Johann Posch)   Created
//
//+---------------------------------------------------------------------------
class CUrlMkTls
{
public:
    CUrlMkTls(HRESULT &hr);

    // to get direct access to the data structure
    SUrlMkTlsData * operator->(void);

private:

    HRESULT      TLSAllocData(); // allocates an SUrlMkTlsData structure

    SUrlMkTlsData * _pData;       // ptr to UrlMon TLS data
};

//+---------------------------------------------------------------------------
//
//  Method:     CUrlMkTls::CUrlMkTls
//
//  Synopsis:   ctor for UrlMon Tls object.
//
//  Notes:      Peripheral UrlMon code that can not assume that some outer-layer
//              function has already verified the existence of the SUrlMkTlsData
//              structure for the current thread should use this version of
//              the ctor.
//
//  History:    12-02-95   JohannP (Johann Posch)   Created
//
//+---------------------------------------------------------------------------
inline CUrlMkTls::CUrlMkTls(HRESULT &hr)
{
    _pData = (SUrlMkTlsData *) TlsGetValue(gTlsIndex);
    if (_pData)
        hr = S_OK;
    else
        hr = TLSAllocData();
}

//+---------------------------------------------------------------------------
//
//  Member:     CUrlMkTls::operator->(void)
//
//  Synopsis:   returns ptr to the data structure
//
//  History:    12-02-95   JohannP (Johann Posch)   Created
//
//+---------------------------------------------------------------------------
inline SUrlMkTlsData * CUrlMkTls::operator->(void)
{
    return _pData;
}



typedef struct URLMON_TS
{
    DWORD           _dwTID;
    HWND            _hwndNotify;
    URLMON_TS*      _pNext;
} URLMON_TS, *LPURLMON_TS;

#endif // _TLS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\inc\notiftn.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       trans.h
//
//  Contents:   precompiled header file for the trans directory
//
//  Classes:
//
//  Functions:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

#include <urlmon.hxx>
#include <tls.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\inc\urlb.h ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <io.h>

#include <ole2.h>
#include <shellapi.h>
#include <urlmon.h>
//#include <webchk.h>
#include <wininet.h>
#include "com.hxx"
//#include "urlint.h"

#include "urlmon.hxx"
#include "..\urlbind\urlbind.hxx"
#include "..\urlbind\threads.hxx"
#include "..\urlbind\acceptor.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\inc\verurlmk.h ===
#ifdef RC_INVOKED

#include <winver.h>
#include <ntverp.h>

#define VER_FILEVERSION         VER_PRODUCTBUILD
#define VER_FILEVERSION_STR     VER_PRODUCTVERSION_STR

#define VER_PRODUCTNAME_STR      "Microsoft URL Moniker 1.0 for Windows NT(TM) Operating System\0"
#define VER_COMPANYNAME_STR      "Microsoft Corporation\0"
#define VER_LEGALTRADEMARKS_STR  "Microsoft\256 is a registered trademark of Microsoft Corporation. Windows NT(TM) is a trademark of Microsoft Corporation\0"
#define VER_LEGALCOPYRIGHT_STR   "Copyright \251 Microsoft Corp. 1995\0"
#define VER_COMMENT_STR          "Microsoft URL Moniker 1.0 for Windows NT(TM) Operating System\0"
#define VER_FILETYPE             VFT_DLL
#define VER_FILESUBTYPE          0
#define VER_FILEFLAGSMASK        VS_FFI_FILEFLAGSMASK
#define VER_FILEFLAGS            0L
#define VER_FILEOS               VOS_NT_WINDOWS32
#define VER_FILEDESCRIPTION_STR  "Microsoft URL Moniker 4.70 for Windows NT(TM) Operating System\0"

#endif /* RC_INVOKED */

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\inc\urlint.h ===
//+---------------------------------------------------------------------------
    //
    //  Microsoft Windows
    //  Copyright (C) Microsoft Corporation, 1992 - 1995.
    //
    //  File:       urlint.h
    //
    //  Contents:   internal include file for ulrmon project
    //
    //  Classes:
    //
    //  Functions:
    //
    //  History:    10-25-95   JohannP (Johann Posch)   Created
    //
    //----------------------------------------------------------------------------
    #ifndef _URLINT_H_
    #define _URLINT_H_
    #define _WITH_INTERNET_URL_ZONES_
    #ifdef ALPHA    // required for Wx86 support
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
    #endif
    #include <urlmki.h>
    #include <debug.h>
    #include <valid.h>
    #include <perftags.h>
    #include <crtsubst.h>
    #include <inetdbg.h> //for DEBUG_* macros/functions
        
    #ifndef ARRAYSIZE
    #define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
    #endif
    
    #if DBG==1
    #define XDBG(dbg,nondbg)    dbg
    #else
    #define XDBG(dbg,nondbg)    nondbg
    #endif
    
    #if DBG == 1
    //interface IDebugOut : public IUnknown
    #undef INTERFACE
    #define INTERFACE   IDebugOut
    DECLARE_INTERFACE_(IDebugOut,IUnknown)
    {
        // *** IUnknown methods ***
        STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
        STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
        STDMETHOD_(ULONG,Release) (THIS) PURE;
    
        // *** IDebugOut methods ***
        STDMETHOD_(void, SendEntry) (THIS_ DWORD ThreadId, DWORD dwFlags, LPCSTR pstr, DWORD dwReserved) PURE;
    };
    
    
    #undef INTERFACE
    #define INTERFACE   IDebugRegister
    DECLARE_INTERFACE_(IDebugRegister,IUnknown)
    {
        // *** IUnknown methods ***
        STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
        STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
        STDMETHOD_(ULONG,Release) (THIS) PURE;
    
        // *** IDebugRegister methods ***
        STDMETHOD(GetFacilities) (THIS_ LPCWSTR *ppwzNames, DWORD *pcNames, DWORD dwReserved) PURE;
        STDMETHOD(Register) (THIS_ LPCWSTR pwzName, IDebugOut *pDbgOut, DWORD dwFlags, DWORD dwReserved) PURE;
    };
    
    // each thread can have it's own IDebugOut interface
    EXTERN_C HRESULT RegisterDebugOut(LPCWSTR pwzName, DWORD dwOptions, IDebugOut *pDbgOut, DWORD dwReserved);
    void UrlSpySendEntry(IDebugOut *pDbgOut, LPSTR szOutBuffer, DWORD ThreadId = 0, DWORD dwFlags = 0, DWORD dwReserved = 0);
    void UrlSpyFn(int iOption, const char *pscFormat, ...);
    
    #define PerfDbgTag(tag, szOwner, szDescrip, iOption) int tag = iOption;
    #define     DbgTag(tag, szOwner, szDescrip, iOption) int tag = iOption;
    #define PerfDbgExtern(tag) extern int tag;
    #define     DbgExtern(tag) extern int tag;
    #define PerfDbgLog(tag,pv,f) PerfDbgLogFn(tag,pv,f)
    #define PerfDbgLog1(tag,pv,f,a1) PerfDbgLogFn(tag,pv,f,a1)
    #define PerfDbgLog2(tag,pv,f,a1,a2) PerfDbgLogFn(tag,pv,f,a1,a2)
    #define PerfDbgLog3(tag,pv,f,a1,a2,a3) PerfDbgLogFn(tag,pv,f,a1,a2,a3)
    #define PerfDbgLog4(tag,pv,f,a1,a2,a3,a4) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4)
    #define PerfDbgLog5(tag,pv,f,a1,a2,a3,a4,a5) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5)
    #define PerfDbgLog6(tag,pv,f,a1,a2,a3,a4,a5,a6) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6)
    #define PerfDbgLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7)
    #define PerfDbgLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8)
    #define PerfDbgLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9)
    #define PerfDbgLogN(x) PerfDbgLogFn x
    #define     DbgLog(tag,pv,f) PerfDbgLogFn(tag,pv,f)
    #define     DbgLog1(tag,pv,f,a1) PerfDbgLogFn(tag,pv,f,a1)
    #define     DbgLog2(tag,pv,f,a1,a2) PerfDbgLogFn(tag,pv,f,a1,a2)
    #define     DbgLog3(tag,pv,f,a1,a2,a3) PerfDbgLogFn(tag,pv,f,a1,a2,a3)
    #define     DbgLog4(tag,pv,f,a1,a2,a3,a4) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4)
    #define     DbgLog5(tag,pv,f,a1,a2,a3,a4,a5) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5)
    #define     DbgLog6(tag,pv,f,a1,a2,a3,a4,a5,a6) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6)
    #define     DbgLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7)
    #define     DbgLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8)
    #define     DbgLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) PerfDbgLogFn(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9)
    #define     DbgLogN(x) PerfDbgLogFn x
    void    PerfDbgLogFn(int tag, void * pvObj, const char * pchFmt, ...);
    
    #   define DEB_LEVEL_SHIFT      28
    #   define DEB_LEVEL_MASK       0x0FFFFFFF
    
        DECLARE_DEBUG(UrlMk)
    #   define UrlMkUrlSpy          UrlSpyFn
    #   define UrlMkDebugOut(x)     UrlMkUrlSpy x
    #   define UrlMkAssert(x)       Win4Assert(x)
    #   define UrlMkVerify(x)       UrlMkAssert(x)
    #   define DEB_URLMK_LEVEL      0x00000000
    #   define DEB_ASYNCAPIS        (DEB_USER1 | DEB_URLMK_LEVEL)
    #   define DEB_URLMON           (DEB_USER2 | DEB_URLMK_LEVEL)
    #   define DEB_ISTREAM          (DEB_USER3 | DEB_URLMK_LEVEL)
    #   define DEB_DLL              (DEB_USER4 | DEB_URLMK_LEVEL)
    #   define DEB_FORMAT           (DEB_USER5 | DEB_URLMK_LEVEL)
    #   define DEB_CODEDL           (DEB_USER6 | DEB_URLMK_LEVEL)
    
        DECLARE_DEBUG(Trans)
    #   define TransUrlSpy          UrlSpyFn
    #   define TransDebugOut(x)     TransUrlSpy x
    #   define TransAssert(x)       Win4Assert(x)
    #   define TransVerify(x)       TransAssert(x)
    #   define DEB_TRANS_LEVEL      0x10000000
    #   define DEB_BINDING          (DEB_USER1 | DEB_TRANS_LEVEL)
    #   define DEB_TRANS            (DEB_USER2 | DEB_TRANS_LEVEL)
    #   define DEB_TRANSPACKET      (DEB_USER3 | DEB_TRANS_LEVEL)
    #   define DEB_DATA             (DEB_USER4 | DEB_TRANS_LEVEL)
    #   define DEB_TRANSMGR         (DEB_USER5 | DEB_TRANS_LEVEL)
    #   define DEB_SESSION          (DEB_USER6 | DEB_TRANS_LEVEL)
    
        DECLARE_DEBUG(PProt)
    #   define PProtUrlSpy          UrlSpyFn
    #   define PProtDebugOut(x)     PProtUrlSpy x
    #   define PProtAssert(x)       Win4Assert(x)
    #   define PProtVerify(x)       PProtAssert(x)
    #   define DEB_PROT_LEVEL       0x20000000
    #   define DEB_PROT             (DEB_USER1 | DEB_PROT_LEVEL)
    #   define DEB_PROTHTTP         (DEB_USER2 | DEB_PROT_LEVEL)
    #   define DEB_PROTFTP          (DEB_USER3 | DEB_PROT_LEVEL)
    #   define DEB_PROTGOPHER       (DEB_USER4 | DEB_PROT_LEVEL)
    #   define DEB_PROTSIMP         (DEB_USER5 | DEB_PROT_LEVEL)
    
        DECLARE_DEBUG(Notf)
    #   define NotfUrlSpy          UrlSpyFn
    #   define NotfDebugOut(x)     NotfUrlSpy x
    #   define NotfAssert(x)       Win4Assert(x)
    #   define NotfVerify(x)       NotfAssert(x)
    #   define DEB_NOTF_LEVEL       0x30000000
    
    #   define DEB_NOTF_1             (DEB_USER1  | DEB_NOTF_LEVEL)
    #   define DEB_NOTF_2             (DEB_USER2  | DEB_NOTF_LEVEL)
    #   define DEB_NOTF_3             (DEB_USER3  | DEB_NOTF_LEVEL)
    #   define DEB_NOTF_4             (DEB_USER4  | DEB_NOTF_LEVEL)
    #   define DEB_NOTF_5             (DEB_USER5  | DEB_NOTF_LEVEL)
    #   define DEB_NOTF_6             (DEB_USER6  | DEB_NOTF_LEVEL)
    #   define DEB_NOTF_7             (DEB_USER7  | DEB_NOTF_LEVEL)
    #   define DEB_NOTF_8             (DEB_USER8  | DEB_NOTF_LEVEL)
    #   define DEB_NOTF_9             (DEB_USER9  | DEB_NOTF_LEVEL)
    #   define DEB_NOTF_10            (DEB_USER10 | DEB_NOTF_LEVEL)
    #   define DEB_NOTF_11            (DEB_USER11 | DEB_NOTF_LEVEL)
    #   define DEB_NOTF_12            (DEB_USER12 | DEB_NOTF_LEVEL)
    #   define DEB_NOTF_13            (DEB_USER13 | DEB_NOTF_LEVEL)
    #   define DEB_NOTF_14            (DEB_USER14 | DEB_NOTF_LEVEL)
    #   define DEB_NOTF_15            (DEB_USER15 | DEB_NOTF_LEVEL)
    
        DECLARE_DEBUG(EProt)
    #   define EProtUrlSpy          UrlSpyFn
    #   define EProtDebugOut(x)     EProtUrlSpy x
    #   define EProtAssert(x)       Win4Assert(x)
    #   define EProtVerify(x)       EProtAssert(x)
    #   define DEB_EPROT_LEVEL      0x40000000
    #   define DEB_PLUGPROT         (DEB_USER1  | DEB_EPROT_LEVEL)
    #   define DEB_BASE             (DEB_USER2  | DEB_EPROT_LEVEL)
    
        DECLARE_DEBUG(TNotf)
    #   define TNotfUrlSpy         UrlSpyFn
    #   define TNotfDebugOut(x)    TNotfUrlSpy x
    #   define TNotfAssert(x)      Win4Assert(x)
    #   define TNotfVerify(x)      TNotfAssert(x)
    #   define DEB_TNOTF_LEVEL     0x50000000
    
    #   define DEB_TNOTF_1            (DEB_USER1  | DEB_TNOTF_LEVEL)
    #   define DEB_TNOTF_2            (DEB_USER2  | DEB_TNOTF_LEVEL)
    #   define DEB_TNOTF_3            (DEB_USER3  | DEB_TNOTF_LEVEL)
    #   define DEB_TNOTF_4            (DEB_USER4  | DEB_TNOTF_LEVEL)
    #   define DEB_TNOTF_5            (DEB_USER5  | DEB_TNOTF_LEVEL)
    #   define DEB_TNOTF_6            (DEB_USER6  | DEB_TNOTF_LEVEL)
    #   define DEB_TNOTF_7            (DEB_USER7  | DEB_TNOTF_LEVEL)
    #   define DEB_TNOTF_8            (DEB_USER8  | DEB_TNOTF_LEVEL)
    #   define DEB_TNOTF_9            (DEB_USER9  | DEB_TNOTF_LEVEL)
    #   define DEB_TNOTF_10           (DEB_USER10 | DEB_TNOTF_LEVEL)
    #   define DEB_TNOTF_11           (DEB_USER11 | DEB_TNOTF_LEVEL)
    #   define DEB_TNOTF_12           (DEB_USER12 | DEB_TNOTF_LEVEL)
    #   define DEB_TNOTF_13           (DEB_USER13 | DEB_TNOTF_LEVEL)
    #   define DEB_TNOTF_14           (DEB_USER14 | DEB_TNOTF_LEVEL)
    #   define DEB_TNOTF_15           (DEB_USER15 | DEB_TNOTF_LEVEL)
    
    #   define PPKG_DUMP(ptr, params)       ptr->Dump params
    #   define PLIST_DUMP(ptr, params)      ptr->Dump params
    #   define LIST_DUMP(obj, params)       obj.Dump params
    #   define SPEW_TIME(params)            SpewTime params
    
    #else
    
    #define PerfDbgTag(tag, szOwner, szDescrip, iOption) PerfTag(tag, szOwner, szDescrip)
    #define     DbgTag(tag, szOwner, szDescrip, iOption)
    #define PerfDbgExtern(tag) PerfExtern(tag)
    #define     DbgExtern(tag)
    #define PerfDbgLog(tag,pv,f) PerfLog(tag,pv,f)
    #define PerfDbgLog1(tag,pv,f,a1) PerfLog1(tag,pv,f,a1)
    #define PerfDbgLog2(tag,pv,f,a1,a2) PerfLog2(tag,pv,f,a1,a2)
    #define PerfDbgLog3(tag,pv,f,a1,a2,a3) PerfLog3(tag,pv,f,a1,a2,a3)
    #define PerfDbgLog4(tag,pv,f,a1,a2,a3,a4) PerfLog4(tag,pv,f,a1,a2,a3,a4)
    #define PerfDbgLog5(tag,pv,f,a1,a2,a3,a4,a5) PerfLog5(tag,pv,f,a1,a2,a3,a4,a5)
    #define PerfDbgLog6(tag,pv,f,a1,a2,a3,a4,a5,a6) PerfLog6(tag,pv,f,a1,a2,a3,a4,a5,a6)
    #define PerfDbgLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7) PerfLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7)
    #define PerfDbgLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8) PerfLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8)
    #define PerfDbgLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9) PerfLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9)
    #define PerfDbgLogN(x) PerfLogFn x
    #define     DbgLog(tag,pv,f)
    #define     DbgLog1(tag,pv,f,a1)
    #define     DbgLog2(tag,pv,f,a1,a2)
    #define     DbgLog3(tag,pv,f,a1,a2,a3)
    #define     DbgLog4(tag,pv,f,a1,a2,a3,a4)
    #define     DbgLog5(tag,pv,f,a1,a2,a3,a4,a5)
    #define     DbgLog6(tag,pv,f,a1,a2,a3,a4,a5,a6)
    #define     DbgLog7(tag,pv,f,a1,a2,a3,a4,a5,a6,a7)
    #define     DbgLog8(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8)
    #define     DbgLog9(tag,pv,f,a1,a2,a3,a4,a5,a6,a7,a8,a9)
    #define     DbgLogN(x)
    
    #define PPKG_DUMP(ptr, params)
    #define PLIST_DUMP(ptr, params)
    #define LIST_DUMP(obj, params)
    #define SPEW_TIME(params)
    
    #if DBGASSERT == 1
    
    #   define UrlMkAssert(x)  (void) ((x) || (DebugBreak(),0))
    #   define TransAssert(x)  (void) ((x) || (DebugBreak(),0))
    #   define PProtAssert(x)  (void) ((x) || (DebugBreak(),0))
    #   define EProtAssert(x)  (void) ((x) || (DebugBreak(),0))
    #   define NotfAssert(x)   (void) ((x) || (DebugBreak(),0))
    
    #   define UrlMkDebugOut(x)
    #   define UrlMkVerify(x)         x
    
    #   define TransDebugOut(x)
    #   define TransVerify(x)         x
    
    #   define PProtDebugOut(x)
    #   define PProtVerify(x)         x
    
    #   define NotfDebugOut(x)
    #   define NotfVerify(x)          x
    
    #   define TNotfDebugOut(x)
    #   define TNotfVerify(x)         x
    
    #else
    
    #   define UrlMkDebugOut(x)
    #   define UrlMkAssert(x)
    #   define UrlMkVerify(x)         x
    
    #   define TransDebugOut(x)
    #   define TransAssert(x)
    #   define TransVerify(x)         x
    
    #   define PProtDebugOut(x)
    #   define PProtAssert(x)
    #   define PProtVerify(x)         x
    
    #   define NotfDebugOut(x)
    #   define NotfAssert(x)
    #   define NotfVerify(x)          x
    
    #   define TNotfDebugOut(x)
    #   define TNotfAssert(x)
    #   define TNotfVerify(x)         x
    
    #   define EProtDebugOut(x)
    #   define EProtAssert(x)
    #   define EProtVerify(x)         x
    
    #endif
    #endif
    
    HRESULT GetClassMime(LPSTR pszMime, CLSID *pclsid, BOOL fIgnoreMimeClsid=FALSE);
    STDAPI GetClassFileOrMime2(LPBC pBC, LPCWSTR pwzFilename, LPVOID pBuffer, DWORD cbSize,
        LPCWSTR pwzMimeIn, DWORD dwReserved, CLSID *pclsid, BOOL fIgnoreMimeClsid);
    HWND GetThreadNotificationWnd(BOOL fCreate = TRUE);
    
    // messages for URLMON's private window on client's thread
    #define WM_URLMON_BASE                  WM_USER+100
    #define WM_TRANS_FIRST                  WM_URLMON_BASE+1
    #define WM_TRANS_PACKET                 WM_URLMON_BASE+1
    #define WM_TRANS_NOPACKET               WM_URLMON_BASE+2
    #define WM_TRANS_OUTOFMEMORY            WM_URLMON_BASE+3
    #define WM_TRANS_INTERNAL               WM_URLMON_BASE+4
    #define WM_CODE_DOWNLOAD_SETUP          WM_URLMON_BASE+5
    #define WM_CODE_DOWNLOAD_TRUST_PIECE    WM_URMLON_BASE+6
    #define WM_CODE_DOWNLOAD_PROCESS_PIECE  WM_URLMON_BASE+7
    #define WM_CODE_DOWNLOAD_PROCESS_INF    WM_URLMON_BASE+8
    #define WM_THREADPACKET_POST            WM_URLMON_BASE+9
    #define WM_THREADPACKET_SEND            WM_URLMON_BASE+10
    #define WM_THREADPACKET_NOTIFY          WM_URLMON_BASE+11
    #define WM_THREADPACKET_INPUTSYNC       WM_URLMON_BASE+12
    #define WM_PROCESSPACKET_POST           WM_URLMON_BASE+13
    #define WM_PROCESSPACKET_SEND           WM_URLMON_BASE+14
    #define WM_PROCESSWAKEUP                WM_URLMON_BASE+15
    #define WM_THREADPACKET_PRIVATE3        WM_URLMON_BASE+16
    #define WM_SYNC_DEF_PROC_NOTIFICATIONS  WM_URLMON_BASE+17
    #define WM_TRANS_LAST                   WM_URLMON_BASE+17

    #define NOTF_SCHED_TIMER                0xABC123
    #define NOTF_DELAY_TIMER                0xDEF456
    
    #define IID_IAsyncURLMoniker    IID_IMoniker
    #define E_RETRY                 RPC_E_RETRY
    
    #ifdef UNUSED
    #undef VDATEPTROUT
    #undef VDATEPTRIN
    #undef VDATEIFACE
    #undef VDATEIID
    
    #define VDATEPTROUT(p, n)
    #define VDATEPTRIN(p, n)
    #define VDATETHIS(t)
    #define VDATEIFACE(x)
    #define VDATEIID(x)
    #endif //UNUSED
    
    #ifndef VDATETHIS
    #define VDATETHIS(t) VDATEIFACE(t)
    #endif
    
    // prototypes
    
    EXTERN_C const IID IID_IAsyncBindCtx;
    
    
    // Internal Helper API's
    void DllAddRef(void);
    void DllRelease(void);
    
    #undef  URLMONOFFSETOF
    #define URLMONOFFSETOF(t,f)   ((DWORD_PTR)(&((t*)0)->f))
   
    #define REG_BSCB_HOLDER          OLESTR("_BSCB_Holder_")
    #define REG_ENUMFORMATETC        OLESTR("_EnumFORMATETC_")
    #define REG_MEDIA_HOLDER         OLESTR("_Media_Holder_")
    #define SZ_TRANSACTIONDATA       OLESTR("_ITransData_Object_")
    #define SZ_TRANSACTION           OLESTR("_ITransaction_Object_")
    #define SZ_BINDING               OLESTR("CBinding Context")
    #define SZ_IUNKNOWN_PTR          OLESTR("IUnknown Pointer")
    
    #if DBG==1
    HRESULT DumpIID(REFIID riid);
    #else
    #define DumpIID(x)
    #endif
    
    // Needed for linking with static C runtime LIBCMT.LIB
    // Remove when linking to external C runtime DLL
    //#define strnicmp _strnicmp
    #define wcsnicmp _wcsnicmp
    //#define itoa _itoa
    //#define stricmp _stricmp        // URLBIND uses this one.
    #define wcsicmp _wcsicmp
    
    // old flags used inside urlmon
    typedef enum
    {
        BSCO_ONSTARTBINDING     = 0x00000001,
        BSCO_GETPRIORITY        = 0x00000002,
        BSCO_ONLOWRESOURCE      = 0x00000004,
        BSCO_ONPROGRESS         = 0x00000008,
        BSCO_ONSTOPBINDING      = 0x00000010,
        BSCO_GETBINDINFO        = 0x00000020,
        BSCO_ONDATAAVAILABLE    = 0x00000040,
        BSCO_ONOBJECTAVAILABLE  = 0x00000080,
        BSCO_ALLONIBSC          = 0x000000FF,
        BSCO_ALLONIBDGSITE      = 0x0000001F
    } BSCO_OPTION;
    
    // flags for the reserved parameter dwReserved of GetClassFileOrMime API
    typedef enum
    {
        GETCLASSFILEORMIME_IGNOREPLUGIN      = 0x00000001
    } GETCLASSFILEORMIME_FLAGS;
    
    #endif //_URLINT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\inc\wregint.h ===
#ifndef _REG_API_DEFINED_
#define _REG_API_DEFINED_

#ifdef unused
#define RegConnectRegistry  RegConnectRegistryW
#define RegConnectRegistry  RegConnectRegistryA
#define RegCreateKey  RegCreateKeyW
#define RegCreateKey  RegCreateKeyA
#define RegCreateKeyEx  RegCreateKeyExW
#define RegCreateKeyEx  RegCreateKeyExA
#define RegDeleteKey  RegDeleteKeyW
#define RegDeleteKey  RegDeleteKeyA
#define RegDeleteValue  RegDeleteValueW
#define RegDeleteValue  RegDeleteValueA
#define RegEnumKey  RegEnumKeyW
#define RegEnumKey  RegEnumKeyA
#define RegEnumKeyEx  RegEnumKeyExW
#define RegEnumKeyEx  RegEnumKeyExA
#define RegEnumValue  RegEnumValueW
#define RegEnumValue  RegEnumValueA
#define RegLoadKey  RegLoadKeyW
#define RegLoadKey  RegLoadKeyA
#define RegOpenKey  RegOpenKeyW
#define RegOpenKey  RegOpenKeyA
#define RegOpenKeyEx  RegOpenKeyExW
#define RegOpenKeyEx  RegOpenKeyExA
#define RegQueryInfoKey  RegQueryInfoKeyW
#define RegQueryInfoKey  RegQueryInfoKeyA
#define RegQueryValue  RegQueryValueW
#define RegQueryValue  RegQueryValueA
#define RegQueryMultipleValues  RegQueryMultipleValuesW
#define RegQueryMultipleValues  RegQueryMultipleValuesA
#define RegQueryValueEx  RegQueryValueExW
#define RegQueryValueEx  RegQueryValueExA
#define RegReplaceKey  RegReplaceKeyW
#define RegReplaceKey  RegReplaceKeyA
#define RegRestoreKey  RegRestoreKeyW
#define RegRestoreKey  RegRestoreKeyA
#define RegSaveKey  RegSaveKeyW
#define RegSaveKey  RegSaveKeyA
#define RegSetValue  RegSetValueW
#define RegSetValue  RegSetValueA
#define RegSetValueEx  RegSetValueExW
#define RegSetValueEx  RegSetValueExA
#define RegUnLoadKey  RegUnLoadKeyW
#define RegUnLoadKey  RegUnLoadKeyA
#define InitiateSystemShutdown  InitiateSystemShutdownW
#define InitiateSystemShutdown  InitiateSystemShutdownA
#define AbortSystemShutdown  AbortSystemShutdownW
#define AbortSystemShutdown  AbortSystemShutdownA


#undef RegConnectRegistry
#undef RegCreateKey
#undef RegCreateKeyEx
#undef RegDeleteKey
#undef RegDeleteValue
#undef RegEnumKey
#undef RegEnumKeyEx
#undef RegEnumValue
#undef RegLoadKey
#undef RegOpenKey
#undef RegOpenKeyEx
#undef RegQueryInfoKey
#undef RegQueryValue
#undef RegQueryMultipleValues
#undef RegQueryValueEx
#undef RegReplaceKey
#undef RegRestoreKey
#undef RegSaveKey
#undef RegSetValue
#undef RegSetValueEx
#undef RegUnLoadKey
#undef InitiateSystemShutdown
#undef AbortSystemShutdown

#endif //unused

#pragma warning(disable:4005)               // re-enable below


#include "..\utils\wreg.hxx"
extern CRegistryA *g_vpReg;


#define RegConnectRegistry            (g_vpReg)->ConnectRegistry
#define RegCloseKey                   (g_vpReg)->CloseKey
#define RegCreateKey                  (g_vpReg)->CreateKey
#define RegCreateKeyEx                (g_vpReg)->CreateKeyEx
#define RegDeleteKey                  (g_vpReg)->DeleteKey
#define RegDeleteValue                (g_vpReg)->DeleteValue
#define RegEnumKey                    (g_vpReg)->EnumKey
#define RegEnumKeyEx                  (g_vpReg)->EnumKeyEx
#define RegEnumValue                  (g_vpReg)->EnumValue
#define RegFlushKey                   (g_vpReg)->FlushKey
#define RegLoadKey                    (g_vpReg)->LoadKey
#define RegOpenKey                    (g_vpReg)->OpenKey
#define RegOpenKeyEx                  (g_vpReg)->OpenKeyEx
#define RegQueryInfoKey               (g_vpReg)->QueryInfoKey
#define RegQueryValue                 (g_vpReg)->QueryValue
#define RegQueryMultipleValues        (g_vpReg)->QueryMultipleValues
#define RegQueryValueEx               (g_vpReg)->QueryValueEx
#define RegReplaceKey                 (g_vpReg)->ReplaceKey
#define RegRestoreKey                 (g_vpReg)->RestoreKey
#define RegSaveKey                    (g_vpReg)->SaveKey
#define RegSetValue                   (g_vpReg)->SetValue
#define RegSetValueEx                 (g_vpReg)->SetValueEx
#define RegUnLoadKey                  (g_vpReg)->UnLoadKey

#pragma warning(default:4005)               // re-enable below

#endif //_REG_API_DEFINED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\inc\wcheckcb.h ===
#ifndef __CONTROL_REFRESH_CALLBACK__
#define __CONTROL_REFRESH_CALLBACK__

#include <webcheck.h>
#include <objidl.h>
#include <wininet.h>

#define CALLBACK_OBJ_CLSID "{5DFE9E81-46E4-11d0-94E8-00AA0059CE02}"
extern const CLSID CLSID_ControlRefreshCallback;


/******************************************************************************
   Class factory for callback object
******************************************************************************/
STDMETHODIMP CreateCallbackClassFactory(IClassFactory** ppCF);

class CCallbackObjFactory : public IClassFactory
{
public:

    // constructor
    CCallbackObjFactory();

    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID iid, void** ppvObject);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IClassFactory Methods
    STDMETHODIMP CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID* ppv);
    STDMETHODIMP LockServer(BOOL fLock);

private:

    // destructor
    ~CCallbackObjFactory();

    // data members
    UINT   m_cRef;         // object refcount
    UINT   m_cLocks;        // dll lock refcount
};


/******************************************************************************
   Callback object class
******************************************************************************/
class CControlRefreshCallback : public IPersistStream,
                                public IWebCheckAdviseSink
{

public:

    // constructor
    CControlRefreshCallback();

    // passing information to this callback object
    STDMETHODIMP SetInfo(REFCLSID rclsidControl, LPCWSTR lpwszURL);

    // IUnknown Methods
    STDMETHODIMP QueryInterface(REFIID iid, void** ppvObject);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IPersistStream Methods
    STDMETHODIMP GetClassID(CLSID* pClassID);
    STDMETHODIMP IsDirty(void);
    STDMETHODIMP Load(IStream* pStm);
    STDMETHODIMP Save(IStream* pStm, BOOL fClearDirty);
    STDMETHODIMP GetSizeMax(ULARGE_INTEGER* pcbSize);

    // IWebCheckAdviseSink Methods
    STDMETHODIMP UpdateBegin(long lCookie, SCODE scReason, BSTR lpURL);
    STDMETHODIMP UpdateEnd(long lCookie, SCODE scReason);
    STDMETHODIMP UpdateProgress(long lCookie, long lCurrent, long lMax);

protected:

    // Update flag in registry to indicate a new version of control
    // has arrived
//    HRESULT UpdateControlInCacheFlag(SCODE scReason) const;
    HRESULT DownloadControl() const;

protected:

    // destructor
    ~CControlRefreshCallback();

    // ref. count
    UINT m_cRef;

    // clsid of control this callback obj deals with
    CLSID m_clsidCtrl;

    // URL of control this callback obj deals with
    WCHAR m_wszURL[INTERNET_MAX_URL_LENGTH];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\inc\valid.h ===
#if DBG==1 && defined(WIN32) && !defined(_CHICAGO_)
#define VDATEHEAP() if( !HeapValidate(GetProcessHeap(),0,0)){ DebugBreak();}
#else
#define VDATEHEAP()
#endif  //  DBG==1 && defined(WIN32) && !defined(_CHICAGO_)

#define IsValidPtrIn(pv,cb)  ((pv == NULL) || !IsBadReadPtr ((pv),(cb)))
#define IsValidPtrOut(pv,cb) (!IsBadWritePtr((pv),(cb)))

STDAPI_(BOOL) IsValidInterface( void FAR* pv );


#if DBG==1
// for performance, do not do in retail builds
STDAPI_(BOOL) IsValidIid( REFIID riid );
#else
#define IsValidIid(x) (TRUE)
#endif

#ifdef _DEBUG

//** POINTER IN validation macros:
#define VDATEPTRIN( pv, TYPE ) \
        if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid in ptr", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTRIN( pv, TYPE, retval) \
        if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid in ptr", __FILE__, __LINE__), retval)
#define VOID_VDATEPTRIN( pv, TYPE ) \
        if (!IsValidPtrIn( (pv), sizeof(TYPE))) {\
    FnAssert(#pv,"Invalid in ptr", __FILE__, __LINE__); return; }

//** POINTER IN validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTRIN_LABEL(pv, TYPE, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = (FnAssert(#pv, "Invalid in ptr", __FILE__, __LINE__), ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATEPTRIN_LABEL(pv, TYPE, retval, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = (FnAssert(#pv, "Invalid in ptr", __FILE__, __LINE__), retval); \
         goto label; }
#define VOID_VDATEPTRIN_LABEL(pv, TYPE, label) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { FnAssert(#pv, "Invalid in ptr", __FILE__, __LINE__); goto label; }

//** POINTER OUT validation macros:
#define VDATEPTROUT( pv, TYPE ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid out ptr", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTROUT( pv, TYPE, retval ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid out ptr", __FILE__, __LINE__), retval)

//** POINTER OUT validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTROUT_LABEL( pv, TYPE, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = (FnAssert(#pv,"Invalid out ptr", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATEPTROUT_LABEL( pv, TYPE, retval, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = (FnAssert(#pv,"Invalid out ptr", __FILE__, __LINE__),retval); \
         goto label; }

//** INTERFACE validation macro:
#define GEN_VDATEIFACE( pv, retval ) \
        if (!IsValidInterface(pv)) \
    return (FnAssert(#pv,"Invalid interface", __FILE__, __LINE__), retval)
#define VDATEIFACE( pv ) \
        if (!IsValidInterface(pv)) \
    return (FnAssert(#pv,"Invalid interface", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG))
#define VOID_VDATEIFACE( pv ) \
        if (!IsValidInterface(pv)) {\
    FnAssert(#pv,"Invalid interface", __FILE__, __LINE__); return; }

//** INTERFACE validation macros for single entry/single exit functions
//** uses a goto instead of return
#define GEN_VDATEIFACE_LABEL( pv, retval, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = (FnAssert(#pv,"Invalid interface", __FILE__, __LINE__),retval); \
         goto label; }
#define VDATEIFACE_LABEL( pv, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = (FnAssert(#pv,"Invalid interface", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define VOID_VDATEIFACE_LABEL( pv, label ) \
        if (!IsValidInterface(pv)) {\
        FnAssert(#pv,"Invalid interface", __FILE__, __LINE__); goto label; }

//** INTERFACE ID validation macro:
// Only do this in debug build
#define VDATEIID( iid ) if (!IsValidIid( iid )) \
    return (FnAssert(#iid,"Invalid iid", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEIID( iid, retval ) if (!IsValidIid( iid )) {\
    FnAssert(#iid,"Invalid iid", __FILE__, __LINE__); return retval; }

//** INTERFACE ID validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEIID_LABEL( iid, label, retVar ) if (!IsValidIid( iid )) \
        {retVar = (FnAssert(#iid,"Invalid iid", __FILE__, __LINE__),ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATEIID_LABEL( iid, retval, label, retVar ) if (!IsValidIid( iid )) {\
        FnAssert(#iid,"Invalid iid", __FILE__, __LINE__); retVar = retval;  goto label; }
#else



//  --assertless macros for non-debug case
//** POINTER IN validation macros:
#define VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTRIN( pv, TYPE, retval ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (retval)
#define VOID_VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) {\
    return; }

//** POINTER IN validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTRIN_LABEL(pv, TYPE, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATEPTRIN_LABEL(pv, TYPE, retval, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = retval; \
         goto label; }
#define VOID_VDATEPTRIN_LABEL(pv, TYPE, label) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { goto label; }

//** POINTER OUT validation macros:
#define VDATEPTROUT( pv, TYPE ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))

#define GEN_VDATEPTROUT( pv, TYPE, retval ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (retval)

//** POINTER OUT validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTROUT_LABEL( pv, TYPE, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATEPTROUT_LABEL( pv, TYPE, retval, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = retval; \
         goto label; }

//** INTERFACE validation macro:
#define VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return (ResultFromScode(E_INVALIDARG))
#define VOID_VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return;
#define GEN_VDATEIFACE( pv, retval ) if (!IsValidInterface(pv)) \
    return (retval)

//** INTERFACE validation macros for single entry/single exit functions
//** uses a goto instead of return
#define GEN_VDATEIFACE_LABEL( pv, retval, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = retval; \
         goto label; }
#define VDATEIFACE_LABEL( pv, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define VOID_VDATEIFACE_LABEL( pv, label ) \
        if (!IsValidInterface(pv)) {\
         goto label; }

//** INTERFACE ID validation macro:
// do not do in retail build. This code USED to call a bogus version of
// IsValidIID that did no work. Now we are faster and no less stable than before.
#define VDATEIID( iid )             ((void)0)
#define GEN_VDATEIID( iid, retval ) ((void)0);

//** INTERFACE ID validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEIID_LABEL( iid, label, retVar ) if (!IsValidIid( iid )) \
        {retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATEIID_LABEL( iid, retval, label, retVar ) if (!IsValidIid( iid )) {\
        retVar = retval;  goto label; }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\mon\casyncmk.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       CAsyncMk.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-25-95   JohannP (Johann Posch)   Created
//
//  Note: this class servers as a base class for async moniker
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include "casyncmk.hxx"

//  The derived class must implement this method
inline HRESULT DerivedMustImplement( void )
{
    return E_NOTIMPL;
}

STDMETHODIMP CAsyncMoniker::QueryInterface
    (REFIID riid, LPVOID FAR* ppvObj)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "%p IN CAsyncMoniker::QueryInterface\n", this));

    HRESULT hresult = NOERROR;
    // Do not validate input as it has already been validated
    // by derived classes.

    if (   IsEqualIID(riid, IID_IMoniker)
        || IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IPersistStream)
        || IsEqualIID(riid, IID_IInternalMoniker)
        || IsEqualIID(riid, IID_IAsyncMoniker)
        || IsEqualIID(riid, IID_IAsyncURLMoniker)
       )
    {
        *ppvObj = this;
        InterlockedIncrement((long *)&m_refs);
    }
    else
    {
        *ppvObj = NULL;
        hresult = E_NOINTERFACE;
    }

    UrlMkDebugOut((DEB_ASYNCMONIKER, "%p OUT CAsyncMoniker::QueryInterface\n", this));
    return hresult;
}

STDMETHODIMP_(ULONG) CAsyncMoniker::AddRef ()
{
    ULONG crefs;
    UrlMkDebugOut((DEB_ASYNCMONIKER, "%p IN CAsyncMoniker::AddRef(%ld)\n", this, m_refs));

    crefs = InterlockedIncrement((long *)&m_refs);

    UrlMkDebugOut((DEB_ASYNCMONIKER, "%p OUT CAsyncMoniker::AddRef(%ld)\n", this, m_refs));
    return crefs;
}

STDMETHODIMP CAsyncMoniker::IsDirty (THIS)
{
    VDATETHIS(this);
    //  monikers are immutable so they are either always dirty or never dirty.
    HRESULT hresult = S_FALSE;
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN  CAsyncMoniker::(%p)\n", this));

    UrlMkDebugOut((DEB_ASYNCMONIKER, "OUT CAsyncMoniker::(%p) hr (%x)\n", this, hresult));
    return hresult;
}

STDMETHODIMP CAsyncMoniker::Load (THIS_ LPSTREAM pStm)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN/OUT CAsyncMoniker::(%p) hr=E_NOTIMPL\n", this));
    return DerivedMustImplement();
}

STDMETHODIMP CAsyncMoniker::Save (THIS_ LPSTREAM pStm,
            BOOL fClearDirty)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN/OUT CAsyncMoniker::(%p) hr=E_NOTIMPL\n", this));
    return DerivedMustImplement();
}

STDMETHODIMP CAsyncMoniker::GetSizeMax (THIS_ ULARGE_INTEGER FAR * pcbSize)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN/OUT CAsyncMoniker::(%p) hr=E_NOTIMPL\n", this));
    return DerivedMustImplement();
}

    // *** IMoniker methods ***
STDMETHODIMP CAsyncMoniker::BindToObject (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
    REFIID riidResult, LPVOID FAR* ppvResult)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN/OUT CAsyncMoniker::(%p) hr=E_NOTIMPL\n", this));
    return DerivedMustImplement();
}

STDMETHODIMP CAsyncMoniker::BindToStorage (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
    REFIID riid, LPVOID FAR* ppvObj)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN/OUT CAsyncMoniker::(%p) hr=E_NOTIMPL\n", this));
    return DerivedMustImplement();
}

STDMETHODIMP CAsyncMoniker::Reduce (THIS_ LPBC pbc, DWORD dwReduceHowFar, LPMONIKER FAR*
    ppmkToLeft, LPMONIKER FAR * ppmkReduced)
{
    VDATETHIS(this);
    *ppmkReduced = this;
    AddRef();
    return ResultFromScode(MK_S_REDUCED_TO_SELF);
}

STDMETHODIMP CAsyncMoniker::ComposeWith (THIS_ LPMONIKER pmkRight, BOOL fOnlyIfNotGeneric,
    LPMONIKER FAR* ppmkComposite)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN/OUT CAsyncMoniker::(%p) hr=E_NOTIMPL\n", this));
    return DerivedMustImplement();
}

STDMETHODIMP CAsyncMoniker::Enum (THIS_ BOOL fForward, LPENUMMONIKER FAR* ppenumMoniker)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN/OUT CAsyncMoniker::(%p) hr=E_NOTIMPL\n", this));
    return DerivedMustImplement();
}

STDMETHODIMP CAsyncMoniker::IsEqual (THIS_ LPMONIKER pmkOtherMoniker)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN/OUT CAsyncMoniker::(%p) hr=E_NOTIMPL\n", this));
    return DerivedMustImplement();
}

STDMETHODIMP CAsyncMoniker::Hash (THIS_ LPDWORD pdwHash)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN/OUT CAsyncMoniker::(%p) hr=E_NOTIMPL\n", this));
    return DerivedMustImplement();
}

STDMETHODIMP CAsyncMoniker::GetTimeOfLastChange (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
    FILETIME FAR* pfiletime)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN/OUT CAsyncMoniker::(%p) hr=E_NOTIMPL\n", this));
    return DerivedMustImplement();
}

STDMETHODIMP CAsyncMoniker::Inverse (THIS_ LPMONIKER FAR* ppmk)
{
    VDATETHIS(this);
    *ppmk = NULL;
    return ResultFromScode(MK_E_NOINVERSE);
}

STDMETHODIMP CAsyncMoniker::CommonPrefixWith (LPMONIKER pmkOther, LPMONIKER FAR*
    ppmkPrefix)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN/OUT CAsyncMoniker::(%p) hr=E_NOTIMPL\n", this));
    return DerivedMustImplement();
}

STDMETHODIMP CAsyncMoniker::RelativePathTo (THIS_ LPMONIKER pmkOther, LPMONIKER FAR*
    ppmkRelPath)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN/OUT CAsyncMoniker::(%p) hr=E_NOTIMPL\n", this));
    return DerivedMustImplement();
}

STDMETHODIMP CAsyncMoniker::GetDisplayName (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
    LPWSTR FAR* lplpszDisplayName)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN/OUT CAsyncMoniker::(%p) hr=E_NOTIMPL\n", this));
    return DerivedMustImplement();
}

STDMETHODIMP CAsyncMoniker::ParseDisplayName (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
    LPWSTR lpszDisplayName, ULONG FAR* pchEaten,
    LPMONIKER FAR* ppmkOut)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ASYNCMONIKER, "IN/OUT CAsyncMoniker::(%p) hr=E_NOTIMPL\n", this));
    return DerivedMustImplement();
}

STDMETHODIMP CAsyncMoniker::IsSystemMoniker (THIS_ LPDWORD pdwMksys)
{
    VDATEPTROUT (pdwMksys, DWORD);
    *pdwMksys = 0;

    return NOERROR;
}

STDMETHODIMP CAsyncMoniker::IsRunning (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
              LPMONIKER pmkNewlyRunning)
{
    VDATETHIS(this);
    VDATEIFACE (pbc);
    LPRUNNINGOBJECTTABLE pROT;
    HRESULT hresult = S_FALSE;

    return hresult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\mon\authent.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       AUTHENT.CXX
//
//  Contents:   Code to handle multiplexing multiple concurrent
//              IAuthenticate interfaces.
//
//  Classes:    CBasicAuthHolder
//
//  Functions:
//
//  History:    02-05-96    JoeS (Joe Souza)    Created
//
//----------------------------------------------------------------------------

#include <urlint.h>
#include <urlmon.hxx>
#include "authent.hxx"

CBasicAuthHolder::CBasicAuthHolder(void) : _CRefs()
{
    _pCBasicAuthNode = NULL;
    _cElements = 0;
}

STDMETHODIMP CBasicAuthHolder::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    UrlMkDebugOut((DEB_BINDING, "%p _IN CBasicAuthHolder::QueryInterface\n", this));

    *ppvObj = NULL;
    if (riid == IID_IAuthenticate)
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
        CBasicAuthNode  *pNode;

        pNode = _pCBasicAuthNode;

        while (pNode)
        {
            hr = pNode->GetBasicAuthentication()->QueryInterface(riid, ppvObj);

            if (hr == NOERROR)
            {
                pNode = NULL;
            }
            else
            {
                pNode = pNode->GetNextNode();
            }
        }
    }

    UrlMkDebugOut((DEB_BINDING, "%p OUT CBasicAuthHolder::QueryInterface (hr:%lx\n", this,hr));
    return hr;
}

STDMETHODIMP_(ULONG) CBasicAuthHolder::AddRef(void)
{
    UrlMkDebugOut((DEB_BINDING, "%p _IN CBasicAuthHolder::AddRef\n", this));

    LONG lRet = ++_CRefs;

    UrlMkDebugOut((DEB_BINDING, "%p OUT CBasicAuthHolder::AddRef (cRefs:%ld)\n", this,lRet));
    return lRet;
}

STDMETHODIMP_(ULONG) CBasicAuthHolder::Release(void)
{
    UrlMkDebugOut((DEB_BINDING, "%p _IN CBasicAuthHolder::Release\n", this));
    UrlMkAssert((_CRefs > 0));

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        RemoveAllNodes();
        delete this;
    }

    UrlMkDebugOut((DEB_BINDING, "%p OUT CBasicAuthHolder::Release (cRefs:%ld)\n",this,lRet));
    return lRet;
}

HRESULT CBasicAuthHolder::Authenticate(HWND* phwnd, LPWSTR *pszUsername,
            LPWSTR *pszPassword)
{
    UrlMkDebugOut((DEB_BINDING, "%p _IN CBasicAuthHolder::Authenticate\n", this));
    VDATETHIS(this);
    HRESULT         hr = NOERROR;
    CBasicAuthNode  *pNode;

    pNode = _pCBasicAuthNode;

    while (pNode)
    {
        hr = pNode->GetBasicAuthentication()->Authenticate(phwnd, pszUsername, pszPassword);
        if (hr == S_OK)
        {
            break;
        }

        pNode = pNode->GetNextNode();
    }

    UrlMkDebugOut((DEB_BINDING, "%p OUT CBasicAuthHolder::Authenticate\n", this));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBasicAuthHolder::AddNode
//
//  Synopsis:
//
//  Arguments:  [pIBasicAuth] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBasicAuthHolder::AddNode(IAuthenticate *pIBasicAuth)
{
    UrlMkDebugOut((DEB_BINDING, "%p _IN CBasicAuthHolder::AddNode \n", this));
    HRESULT hr = NOERROR;

    CBasicAuthNode *pFirstNode = _pCBasicAuthNode;
    CBasicAuthNode *pNode;

    // Allocate memory for new pNode member.

    pNode = new CBasicAuthNode(pIBasicAuth);

    if (!pNode)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        UrlMkDebugOut((DEB_BINDING, "%p IN  CBasicAuthHolder::AddNode (New Node:%p, IBasicAuth:%p) \n",
                                        this, pNode,pNode->GetBasicAuthentication() ));

        // if a node is already
        if (pFirstNode)
        {
            pNode->SetNextNode(pFirstNode);
        }

        // the new node is the first node
        _pCBasicAuthNode = pNode;
        _cElements++;
    }

    UrlMkDebugOut((DEB_BINDING, "%p OUT CBasicAuthHolder::AddNode (NewNode:%p, hr:%lx) \n", this, pNode, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBasicAuthHolder::RemoveAllNodes
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBasicAuthHolder::RemoveAllNodes(void)
{
    UrlMkDebugOut((DEB_BINDING, "%p _IN CBasicAuthHolder::RemoveAllNodes\n", this));
    HRESULT hr = S_OK;

    CBasicAuthNode *pNode = _pCBasicAuthNode;
    CBasicAuthNode *pNextNode = NULL;

    while (pNode)
    {
        pNextNode = pNode->GetNextNode();

        // release the object
        pNode->GetBasicAuthentication()->Release();
        UrlMkDebugOut((DEB_BINDING, "%p OUT CBasicAuthHolder::RemoveAllNodes (Delete Node:%p, IBasicAuth:%p) \n",
                        this, pNode, pNode->GetBasicAuthentication()));
        delete pNode;
        _cElements--;

        pNode = pNextNode;
    }

    _pCBasicAuthNode = NULL;
    UrlMkAssert((_cElements == 0));

    UrlMkDebugOut((DEB_BINDING, "%p OUT CBasicAuthHolder::RemoveAllNodes (hr:%lx) \n", this, hr));
    return hr;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\mon\enumfetc.cxx ===
//+---------------------------------------------------------------------------
//
//  Function:   CEnumFmtEtc
//
//  Synopsis:   Implements the IEnumFormatEtc.
//              Used by the urlmon by dataobject and CreateEnumFormatEtc
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
#include <mon.h>

PerfDbgTag(tagCEnumFmtEtc, "Urlmon", "Log CEnumFmtEtc", DEB_FORMAT);

//+---------------------------------------------------------------------------
//
//  Method:     CEnumFmtEtc::Create
//
//  Synopsis:
//
//  Arguments:  [cfmtetc] --
//              [rgfmtetc] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CEnumFmtEtc * CEnumFmtEtc::Create(UINT cfmtetc, FORMATETC* rgfmtetc)
{
    PerfDbgLog(tagCEnumFmtEtc, NULL, "+CEnumFmtEtc::Create");
    CEnumFmtEtc * pCEnumFEtc = NULL;

    if (cfmtetc >= 1)
    {
        // only create an enumerator if at least one element
        pCEnumFEtc = new CEnumFmtEtc();
        if (pCEnumFEtc)
        {
            if (pCEnumFEtc->Initialize(cfmtetc, rgfmtetc, 0) == FALSE)
            {
                delete pCEnumFEtc;
                pCEnumFEtc = NULL;
            }
        }
    }

    PerfDbgLog1(tagCEnumFmtEtc, NULL, "-CEnumFmtEtc::Create pEnum->(%lx)", pCEnumFEtc);
    return pCEnumFEtc;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEnumFmtEtc::Initialize
//
//  Synopsis:   set the size and position
//
//  Arguments:  [cfmtetc] -- number of elements
//              [iPos] --    position of enumerator
//
//  Returns:    true on success
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CEnumFmtEtc::Initialize(UINT cfmtetc, FORMATETC* rgfmtetc,  UINT iPos)
{
    LONG cbSize =  sizeof(FORMATETC) * cfmtetc;
    _iNext = iPos;
    _cElements = cfmtetc;

    _pFmtEtc = (FORMATETC *) new FORMATETC [cfmtetc];
    if (_pFmtEtc)
    {
        memcpy(_pFmtEtc, rgfmtetc, cbSize);
        _cElements = cfmtetc;
    }
    else
    {
        _cElements = 0;
    }

    return _cElements != 0;
}
//+---------------------------------------------------------------------------
//
//  Method:     CEnumFmtEtc::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CEnumFmtEtc::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    PerfDbgLog(tagCEnumFmtEtc, this, "+CEnumFmtEtc::QueryInterface");
    HRESULT hr = NOERROR;

    if (   (riid == IID_IUnknown)
        || (riid == IID_IEnumFORMATETC))
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }

    PerfDbgLog(tagCEnumFmtEtc, this, "-CEnumFmtEtc::QueryInterface");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CEnumFmtEtc::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumFmtEtc::AddRef(void)
{
    GEN_VDATEPTRIN(this,ULONG,0L);
    LONG lRet = ++_CRefs;
    PerfDbgLog1(tagCEnumFmtEtc, this, "CEnumFmtEtc::AddRef(%ld)", lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CEnumFmtEtc::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CEnumFmtEtc::Release(void)
{
    GEN_VDATEPTRIN(this,ULONG,0L);
    PerfDbgLog(tagCEnumFmtEtc, this, "+CEnumFmtEtc::Release");

    LONG lRet = --_CRefs;
    if (_CRefs == 0)
    {
        delete this;
    }

    PerfDbgLog1(tagCEnumFmtEtc, this, "-CEnumFmtEtc::Release(%ld)", lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEnumFmtEtc::Next
//
//  Synopsis:
//
//  Arguments:  [celt] --
//              [rgelt] --
//              [pceltFetched] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CEnumFmtEtc::Next(ULONG celt, FORMATETC * rgelt, ULONG * pceltFetched)
{
    PerfDbgLog(tagCEnumFmtEtc, this, "+CEnumFmtEtc::Next");
    HRESULT hr;

    if (!rgelt)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        for (ULONG i = 0; (i < celt) && (_iNext < _cElements); i++)
        {
            rgelt[i] = *(_pFmtEtc + _iNext++);
        }

        if (pceltFetched)
        {
            *pceltFetched = i;
        }

        hr = ((i == celt) ? NOERROR : S_FALSE);

    }

    PerfDbgLog1(tagCEnumFmtEtc, this, "-CEnumFmtEtc::Next (hr:%lx)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEnumFmtEtc::Skip
//
//  Synopsis:
//
//  Arguments:  [celt] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CEnumFmtEtc::Skip(ULONG celt)
{
    PerfDbgLog(tagCEnumFmtEtc, this, "+CEnumFmtEtc::Skip");
    HRESULT hr;

    _iNext += celt;

    if (_iNext <= _cElements)
    {
        hr = NOERROR;
    }
    else
    {
        _iNext = _cElements;
        hr = S_FALSE;
    }
    PerfDbgLog1(tagCEnumFmtEtc, this, "-CEnumFmtEtc::Skip (hr:%lx)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEnumFmtEtc::Reset
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CEnumFmtEtc::Reset(void)
{
    PerfDbgLog(tagCEnumFmtEtc, this, "+CEnumFmtEtc::Reset");
    _iNext = 0;
    PerfDbgLog1(tagCEnumFmtEtc, this, "-CEnumFmtEtc::Reset (hr:%lx)", S_OK);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CEnumFmtEtc::Clone
//
//  Synopsis:
//
//  Arguments:  [ppenum] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CEnumFmtEtc::Clone(IEnumFORMATETC ** ppenum)
{
    PerfDbgLog(tagCEnumFmtEtc, this, "+CEnumFmtEtc::Clone");
    HRESULT hr;
    if (ppenum)
    {
        CEnumFmtEtc * pCEnumFEtc;
        TransAssert((_cElements > 0));

        pCEnumFEtc = new CEnumFmtEtc();
        if (pCEnumFEtc)
        {
            if (pCEnumFEtc->Initialize(_cElements, _pFmtEtc, _iNext) == FALSE)
            {
                delete pCEnumFEtc;
                pCEnumFEtc = NULL;
            }
            else
            {
                *ppenum = pCEnumFEtc;
            }
        }
        hr = ((*ppenum != NULL) ? NOERROR : E_OUTOFMEMORY);

    }
    else
    {
        hr = E_INVALIDARG;
    }

    PerfDbgLog1(tagCEnumFmtEtc, this, "-CEnumFmtEtc::Clone (hr:%lx)", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\mon\media.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       media.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    1-20-96   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <mon.h>

PerfDbgTag(tagMedia,    "Urlmon", "Log Media methods", DEB_FORMAT);
PerfDbgTag(tagMediaApi, "Urlmon", "Log Media API",     DEB_ASYNCAPIS);

#if 1
CHAR vszTextPlain[] =                   "text/plain";
CHAR vszTextRichText[] =                "text/richtext";
CHAR vszImageXBitmap[] =                "image/x-xbitmap";
CHAR vszApplicationPostscript[] =       "application/postscript";
CHAR vszApplicationBase64[] =           "application/base64";
CHAR vszApplicationMacBinhex[] =        "application/macbinhex40";
CHAR vszApplicationPdf[] =              "application/pdf";
CHAR vszAudioAiff[] =                   "audio/x-aiff";
CHAR vszAudioBasic[] =                  "audio/basic";
CHAR vszAudioWav[] =                    "audio/wav";
CHAR vszImageGif[] =                    "image/gif";
CHAR vszImagePJpeg[] =                  "image/pjpeg";
CHAR vszImageJpeg[] =                   "image/jpeg";
CHAR vszImageTiff[] =                   "image/tiff";
CHAR vszImagePng[] =                    "image/x-png";
CHAR vszImagePng2[] =                   "image/png";
CHAR vszImageBmp[] =                    "image/bmp";
CHAR vszImageJG[] =                     "image/x-jg";
CHAR vszImageArt[] =                    "image/x-art";
CHAR vszImageEmf[] =                    "image/x-emf";
CHAR vszImageWmf[] =                    "image/x-wmf";
CHAR vszVideoAvi[] =                    "video/avi";
CHAR vszVideoMS[] =                     "video/x-msvideo";
CHAR vszVideoMpeg[] =                   "video/mpeg";
CHAR vszApplicationCompressed[] =       "application/x-compressed";
CHAR vszApplicationZipCompressed[] =    "application/x-zip-compressed";
CHAR vszApplicationGzipCompressed[] =   "application/x-gzip-compressed";
CHAR vszApplicationMSDownload[] =       "application/x-msdownload";
CHAR vszApplicationJava[] =             "application/java";
CHAR vszApplicationOctetStream[] =      "application/octet-stream";
CHAR vszTextHTML[] =                    "text/html";
CHAR vszApplicationCDF[] =              "application/x-cdf";
CHAR vszApplicationCommonDataFormat[] = "application/x-netcdf";
CHAR vszTextScriptlet[] =               "text/scriptlet";
#endif

const GUID IID_IMediaHolder =  {0x79eac9ce, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}};

#define XCLSID_MsHtml  {0x25336920, 0x03F9, 0x11cf, {0x8F, 0xD0, 0x00, 0xAA, 0x00, 0x68, 0x6F, 0x13}}
#define XCLSID_CDFVIEW {0xf39a0dc0, 0x9cc8, 0x11d0, {0xa5, 0x99, 0x0, 0xc0, 0x4f, 0xd6, 0x44, 0x33}}

BOOL g_fDefaultMediaRegistered = FALSE;
static MediaInfo rgMediaInfo[] =
{
       { vszTextHTML                    , 0, DATAFORMAT_TEXTORBINARY,   XCLSID_MsHtml, 0x00000070 ,0 ,CLSCTX_INPROC  }
      ,{ vszTextPlain                   , 0, DATAFORMAT_AMBIGUOUS,      {0} ,0 ,0 ,0  }
      ,{ vszTextRichText                , 0, DATAFORMAT_TEXT,           {0} ,0 ,0 ,0  }
      ,{ vszImageXBitmap                , 0, DATAFORMAT_TEXT,           {0} ,0 ,0 ,0  }
      ,{ vszApplicationPostscript       , 0, DATAFORMAT_TEXT,           {0} ,0 ,0 ,0  }
      ,{ vszApplicationBase64           , 0, DATAFORMAT_TEXT,           {0} ,0 ,0 ,0  }
      ,{ vszApplicationMacBinhex        , 0, DATAFORMAT_TEXT,           {0} ,0 ,0 ,0  }
      ,{ vszApplicationPdf              , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszAudioAiff                   , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszAudioBasic                  , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszAudioWav                    , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszImageGif                    , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszImagePJpeg                  , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszImageJpeg                   , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszImageTiff                   , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszImagePng                    , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszImagePng2                   , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszImageBmp                    , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszImageJG                     , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszImageArt                    , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszImageEmf                    , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszImageWmf                    , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszVideoAvi                    , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszVideoMS                     , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszVideoMpeg                   , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszApplicationCompressed       , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszApplicationZipCompressed    , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszApplicationGzipCompressed   , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszApplicationJava             , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszApplicationMSDownload       , 0, DATAFORMAT_BINARY,         {0} ,0 ,0 ,0  }
      ,{ vszApplicationOctetStream      , 0, DATAFORMAT_AMBIGUOUS,      {0} ,0 ,0 ,0  }
      ,{ vszApplicationCDF              , 0, DATAFORMAT_TEXT,           XCLSID_CDFVIEW ,(MI_GOTCLSID | MI_CLASSLOOKUP) ,0 ,CLSCTX_INPROC  }
      ,{ vszApplicationCommonDataFormat , 0, DATAFORMAT_AMBIGUOUS,      {0} ,0 ,0 ,0  }
      ,{ vszTextScriptlet               , 0, DATAFORMAT_TEXT,           {0} ,0 ,0 ,0  }
};

CMediaTypeHolder *g_pCMHolder = NULL;

//+---------------------------------------------------------------------------
//
//  Function:   GetMediaTypeHolder
//
//  Synopsis:   Retrieves the media type holder for this apartment
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-20-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CMediaTypeHolder *GetMediaTypeHolder()
{
    PerfDbgLog(tagMediaApi, NULL, "+GetMediaTypeHolder");
#ifdef PER_THREAD
    CUrlMkTls tls;

    CMediaTypeHolder *pCMHolder;

    if ((pCMHolder = tls->pCMediaHolder) == NULL)
    {
        tls->pCMediaHolder = pCMHolder = new CMediaTypeHolder();
    }
#else
    CLock lck(g_mxsMedia);

    if (g_pCMHolder == NULL)
    {
        g_pCMHolder = new CMediaTypeHolder();
    }

#endif //PER_THREAD

    PerfDbgLog1(tagMediaApi, NULL, "-GetMediaTypeHolder (pCMHolder:%lx)", g_pCMHolder);
    return g_pCMHolder;
}


void CMediaType::Initialize(LPSTR szType, CLIPFORMAT cfFormat)
{

    _pszType  = szType;
    _cfFormat = cfFormat;
}

void CMediaType::Initialize(CLIPFORMAT cfFormat, CLSID *pClsID)
{
    _pszType  = NULL;
    _cfFormat = cfFormat;
    _clsID = *pClsID;
    _dwInitFlags |= MI_GOTCLSID;
}


CMediaTypeHolder::CMediaTypeHolder() : _CRefs()
{
    _pCMTNode = NULL;
}

CMediaTypeHolder::~CMediaTypeHolder()
{
    CMediaTypeNode  *pCMTNode, *pNext;

    pCMTNode = _pCMTNode;

    // Delete everything that was allocated by Register.

    while (pCMTNode)
    {
        pNext = pCMTNode->GetNextNode();
        delete pCMTNode;
        pCMTNode = pNext;
    }

    _pCMTNode = NULL;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMediaTypeHolder::RegisterW
//
//  Synopsis:
//
//  Arguments:  [ctypes] --
//              [rgszTypes] --
//              [rgcfTypes] --
//
//  Returns:
//
//  History:    3-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CMediaTypeHolder::RegisterW(UINT ctypes, const LPCWSTR* rgszTypes, CLIPFORMAT* rgcfTypes)
{
    PerfDbgLog(tagMedia, this, "+CMediaTypeHolder::Register");
    HRESULT hr = NOERROR;

    UINT i;

    if (ctypes)
    {
        ULONG           ulSize;
        LPCWSTR         pwzStr;
        LPSTR           pszStr;
        LPSTR           pszHelp;

        LPSTR           pszTextBuffer;
        CMediaType      *pCMType;
        CMediaTypeNode  *pCMTNode;

        // Calculate size of single buffer needed to hold all strings.

        for (ulSize = i = 0; i < ctypes; i++)
        {
            pwzStr = *(rgszTypes + i);
            ulSize += wcslen(pwzStr) + 1;
            //PerfDbgLog2(tagMedia, this, "CMTHolder::Register(sz:%ws; len:%ld)", pszStr, ulSize));
        }

        pszTextBuffer = pszStr = new CHAR[ulSize];
        if (!pszTextBuffer)
        {
            hr = E_OUTOFMEMORY;
            goto RegisterExit;
        }

        pCMType = new CMediaType[ctypes];
        if (!pCMType)
        {
            delete pszTextBuffer;
            hr = E_OUTOFMEMORY;
            goto RegisterExit;
        }

        pCMTNode = new CMediaTypeNode(pCMType, pszTextBuffer, ctypes, _pCMTNode);
        if (!pCMTNode)
        {
            delete pCMType;
            delete pszTextBuffer;
            hr = E_OUTOFMEMORY;
            goto RegisterExit;
        }

        pszHelp = pszStr;

        for (i = 0; i < ctypes; i++)
        {
            pwzStr = *(rgszTypes + i);
            //wcscpy(pszHelp, pszStr);
            W2A(pwzStr, pszHelp, wcslen(pwzStr) + 1);
            (pCMType + i)->Initialize(pszHelp, *(rgcfTypes + i));
            pszHelp += strlen(pszHelp) + 1;
        }

        // New node is first on list.

        _pCMTNode = pCMTNode;
    }

RegisterExit:

    PerfDbgLog1(tagMedia, this, "-CMediaTypeHolder::Register (hr:%lx)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMediaTypeHolder::Register
//
//  Synopsis:
//
//  Arguments:  [ctypes] --
//              [rgszTypes] --
//              [rgcfTypes] --
//
//  Returns:
//
//  History:    3-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CMediaTypeHolder::Register(UINT ctypes, const LPCSTR* rgszTypes, CLIPFORMAT* rgcfTypes)
{
    PerfDbgLog(tagMedia, this, "+CMediaTypeHolder::Register");
    HRESULT hr = NOERROR;

    UINT i;

    if (ctypes)
    {
        ULONG           ulSize;
        LPCSTR          pszStr;
        LPSTR           pszNewStr;
        LPSTR           pszHelp;

        LPSTR           pszTextBuffer;
        CMediaType      *pCMType;
        CMediaTypeNode  *pCMTNode;

        // Calculate size of single buffer needed to hold all strings.

        for (ulSize = i = 0; i < ctypes; i++)
        {
            pszStr = *(rgszTypes + i);
            ulSize += strlen(pszStr) + 1;
            //PerfDbgLog2(tagMedia, this, "CMTHolder::Register(sz:%s; len:%ld)", pszStr, ulSize));
        }

        pszTextBuffer = pszNewStr = new CHAR[ulSize];
        if (!pszTextBuffer)
        {
            hr = E_OUTOFMEMORY;
            goto RegisterExit;
        }

        pCMType = new CMediaType[ctypes];
        if (!pCMType)
        {
            delete pszTextBuffer;
            hr = E_OUTOFMEMORY;
            goto RegisterExit;
        }

        pCMTNode = new CMediaTypeNode(pCMType, pszTextBuffer, ctypes, _pCMTNode);
        if (!pCMTNode)
        {
            delete pCMType;
            delete pszTextBuffer;
            hr = E_OUTOFMEMORY;
            goto RegisterExit;
        }

        pszHelp = pszNewStr;

        for (i = 0; i < ctypes; i++)
        {
            pszStr = *(rgszTypes + i);

            StrNCpy(pszHelp, pszStr, strlen(pszStr) + 1);
            *(rgcfTypes + i) = (CLIPFORMAT) RegisterClipboardFormat(pszStr);

            (pCMType + i)->Initialize(pszHelp, *(rgcfTypes + i));
            pszHelp += strlen(pszHelp) + 1;
        }

        // New node is first on list.

        if (!_pCMTNode)
        {
            _pCMTNode = pCMTNode;
        }
        else
        {
            CMediaTypeNode  *pCMTNext = _pCMTNode->GetNextNode();
            _pCMTNode->SetNextNode(pCMTNode);
            pCMTNode->SetNextNode(pCMTNext);
        }

    }

RegisterExit:

    PerfDbgLog1(tagMedia, this, "-CMediaTypeHolder::Register (hr:%lx)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMediaTypeHolder::Register
//
//  Synopsis:
//
//  Arguments:  [ctypes] --
//              [rgszTypes] --
//              [rgcfTypes] --
//
//  Returns:
//
//  History:    3-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CMediaTypeHolder::RegisterMediaInfo(UINT ctypes, MediaInfo *pMediaInfo, BOOL fFree)
{
    PerfDbgLog(tagMedia, this, "+CMediaTypeHolder::RegisterMediaInfo");
    HRESULT hr = NOERROR;

    UINT i;

    if (ctypes)
    {
        CMediaType      *pCMType;
        CMediaTypeNode  *pCMTNode;

        // Calculate size of single buffer needed to hold all strings.

        pCMType = (CMediaType *)pMediaInfo;
        if (!pCMType)
        {
            goto RegisterExit;
        }

        pCMTNode = new CMediaTypeNode(pCMType, NULL, ctypes, _pCMTNode, FALSE);
        if (!pCMTNode)
        {
            hr = E_OUTOFMEMORY;
            goto RegisterExit;
        }

        for (i = 0; i < ctypes; i++)
        {
            CMediaType *pCMT = (pCMType + i);
            CLIPFORMAT cf = (CLIPFORMAT) RegisterClipboardFormat(pCMT->GetTypeString());
            pCMT->SetClipFormat(cf);
        }

        // New node is first on list.
        _pCMTNode = pCMTNode;
    }

RegisterExit:

    PerfDbgLog1(tagMedia, this, "-CMediaTypeHolder::RegisterMediaInfo (hr:%lx)", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMediaTypeHolder::FindCMediaType
//
//  Synopsis:
//
//  Arguments:  [pszMimeStr] --
//              [ppCMType] --
//
//  Returns:
//
//  History:    3-26-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CMediaTypeHolder::FindCMediaType(CLIPFORMAT cfFormat, CMediaType **ppCMType)
{
    PerfDbgLog(tagMedia, this, "+CMediaTypeHolder::FindCMediaType");
    HRESULT         hr = E_INVALIDARG;
    CMediaTypeNode  *pCMTNode;
    CMediaType      *pCMType;
    UINT            i;

    UrlMkAssert((ppCMType));
    *ppCMType = NULL;

    pCMTNode = _pCMTNode;

    if (!pCMTNode)
    {
        hr = E_FAIL;
    }
    else while (pCMTNode)
    {
        pCMType = pCMTNode->GetMediaTypeArray();

        for (i = 0; i < pCMTNode->GetElementCount(); i++)
        {
            if (cfFormat == (pCMType + i)->GetClipFormat())
            {
                *ppCMType = pCMType + i;
                hr = NOERROR;
                break;
            }
        }

        if (*ppCMType)
        {
            break;
        }

        pCMTNode = pCMTNode->GetNextNode();
    }

    PerfDbgLog1(tagMedia, this, "-CMediaTypeHolder::FindCMediaType (hr:%lx)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMediaTypeHolder::FindCMediaType
//
//  Synopsis:
//
//  Arguments:  [pszMimeStr] --
//              [ppCMType] --
//
//  Returns:
//
//  History:    3-28-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CMediaTypeHolder::FindCMediaType(LPCSTR pszMimeStr, CMediaType **ppCMType)
{
    PerfDbgLog(tagMedia, this, "+CMediaTypeHolder::FindCMediaType");
    HRESULT         hr = E_INVALIDARG;
    CMediaTypeNode  *pCMTNode;
    CMediaType      *pCMType;
    UINT            i;

    *ppCMType = NULL;

    pCMTNode = _pCMTNode;

    if (!pCMTNode)
    {
        hr = E_FAIL;
    }
    else while (pCMTNode)
    {
        pCMType = pCMTNode->GetMediaTypeArray();

        for (i = 0; i < pCMTNode->GetElementCount(); i++)
        {
            if (!stricmp(pszMimeStr, (pCMType + i)->GetTypeString()))
            {
                *ppCMType = pCMType + i;
                hr = NOERROR;
                break;
            }
        }

        if (*ppCMType)
        {
            break;
        }

        pCMTNode = pCMTNode->GetNextNode();
    }

    PerfDbgLog1(tagMedia, this, "-CMediaTypeHolder::FindCMediaType (hr:%lx)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMediaTypeHolder::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppv] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMediaTypeHolder::QueryInterface( REFIID riid, void **ppv )
{
    HRESULT     hr = NOERROR;

    PerfDbgLog2(tagMedia, this, "+CMediaTypeHolder::QueryInterface (%lx, %lx)", riid, ppv);

    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IMediaHolder))
    {
        *ppv = (void FAR *)this;
        AddRef();
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    PerfDbgLog2(tagMedia, this, "-CMediaTypeHolder::QueryInterface (%lx)[%lx]", hr, *ppv);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMediaTypeHolder::AddRef
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMediaTypeHolder::AddRef( void )
{
    LONG lRet = _CRefs++;
    PerfDbgLog1(tagMedia, this, "CMediaTypeHolder::AddRef (%ld)", lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMediaTypeHolder::Release
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CMediaTypeHolder::Release( void )
{
    PerfDbgLog(tagMedia, this, "+CMediaTypeHolder::Release");

    LONG lRet = --_CRefs;
    if (_CRefs == 0)
    {
        delete this;
    }
    PerfDbgLog1(tagMedia, this, "-CMediaTypeHolder::Release (%ld)", lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMediaTypeHolder::RegisterClassMapping
//
//  Synopsis:   registers a class mapping for given mimes strings
//
//  Arguments:  [ctypes] --
//              [rgszNames] --
//              [rgClsIDs] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    8-20-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMediaTypeHolder::RegisterClassMapping (DWORD ctypes, LPCSTR rgszNames[], CLSID rgClsIDs[], DWORD dwReserved)
{
    PerfDbgLog(tagMedia, this, "+CMediaTypeHolder::RegisterClassMapping");

    HRESULT hr = RegisterClass(ctypes, rgszNames, rgClsIDs );

    PerfDbgLog1(tagMedia, this, "-CMediaTypeHolder::RegisterClassMapping (hr:%lX)", hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CMediaTypeHolder::FindClassMapping
//
//  Synopsis:   returns the class for a given mime if registered
//
//  Arguments:  [szMime] --
//              [pClassID] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    8-20-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CMediaTypeHolder::FindClassMapping(LPCSTR szMime, CLSID *pClassID, DWORD dwReserved)
{
    PerfDbgLog(tagMedia, this, "+CMediaTypeHolder::FindClassMapping");
    HRESULT hr = NOERROR;
    CLIPFORMAT cfTypes = CF_NULL;

    TransAssert((pClassID));
    *pClassID = CLSID_NULL;

    cfTypes = (CLIPFORMAT) RegisterClipboardFormat(szMime);
    if (cfTypes != CF_NULL)
    {
        CMediaType  *pCMType = NULL;
        hr = FindCMediaType(cfTypes, &pCMType);
        if (hr == NOERROR)
        {
            TransAssert((pCMType));
            hr = pCMType->GetClsID(pClassID);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    PerfDbgLog1(tagMedia, this, "-CMediaTypeHolder::FindClassMapping (hr:%lx)", hr);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Method:     CMediaTypeHolder::RegisterClass
//
//  Synopsis:
//
//  Arguments:  [ctypes] --
//              [rgszTypes] --
//              [rgcfTypes] --
//
//  Returns:
//
//  History:    3-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CMediaTypeHolder::RegisterClass(UINT ctypes, const LPCSTR* rgszTypes, CLSID *rgclsID)
{
    PerfDbgLog(tagMedia, this, "+CMediaTypeHolder::RegisterClass");
    HRESULT hr = NOERROR;

    UINT i;

    if (ctypes)
    {
        ULONG           ulSize;
        CMediaType      *pCMType;
        CMediaTypeNode  *pCMTNode;

        // Calculate size of single buffer needed to hold all strings.

        pCMType = new CMediaType[ctypes];
        if (!pCMType)
        {
            hr = E_OUTOFMEMORY;
            goto RegisterExit;
        }

        pCMTNode = new CMediaTypeNode(pCMType, NULL, ctypes, _pCMTNode);
        if (!pCMTNode)
        {
            delete pCMType;
            hr = E_OUTOFMEMORY;
            goto RegisterExit;
        }
        for (i = 0; i < ctypes; i++)
        {
            CLIPFORMAT cfTypes;
            LPCSTR pszStr = *(rgszTypes + i);

            cfTypes = (CLIPFORMAT) RegisterClipboardFormat(pszStr);
            pCMType[i].Initialize(cfTypes,(rgclsID + i));
        }

        // New node is first on list.
        _pCMTNode = pCMTNode;
    }

RegisterExit:

    PerfDbgLog1(tagMedia, this, "-CMediaTypeHolder::RegisterClass (hr:%lx)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterDefaultMediaType
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    3-28-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT RegisterDefaultMediaType()
{
    PerfDbgLog(tagMediaApi, NULL, "+RegisterDefaultMediaType");

    HRESULT hr = InternalRegisterDefaultMediaType();

    PerfDbgLog(tagMediaApi, NULL, "-RegisterDefaultMediaType");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   InternalRegisterDefaultMediaType
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    7-24-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT InternalRegisterDefaultMediaType()
{
    HRESULT hr = NOERROR;
    PerfDbgLog(tagMediaApi, NULL, "+InternalRegisterDefaultMediaType");
    static DWORD s_dwfHonorTextPlain = 42;
    CLock lck(g_mxsMedia);

    // Provide a registry hook for enabling urlmon to honor
    // text/plain, rather than defer to the extension.
    // Previously, this was considered ambiguous due to compat
    // reasons with older servers sending this for unknown content types.
    //
    // TODO:  Consider making this the default behavior because
    //        other browsers (e.g. Nav 4.61) are moving in this
    //        direction.
    if (s_dwfHonorTextPlain == 42)
    {
        HKEY hKey;
        DWORD dwType;
        DWORD dwSize = sizeof(s_dwfHonorTextPlain);
        s_dwfHonorTextPlain = 0;

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings", 0, KEY_QUERY_VALUE, &hKey))
        {
            if (ERROR_SUCCESS != RegQueryValueEx(hKey, TEXT("IsTextPlainHonored"), NULL, &dwType, (LPBYTE)&s_dwfHonorTextPlain, &dwSize))
                s_dwfHonorTextPlain = 0;

            RegCloseKey(hKey);
        }
        // rgMediaInfo is a static global, so we only need to do this once.
        if (s_dwfHonorTextPlain)
        {
            DWORD d = 0;
            dwSize = sizeof(rgMediaInfo)/sizeof(MediaInfo);
            for (d = 0; d < dwSize; d++)
            {
                if (!lstrcmp(vszTextPlain, rgMediaInfo[d]._pszType))
                {
                    rgMediaInfo[d]._dwDataFormat = DATAFORMAT_TEXTORBINARY;  // remove the ambiguity
                    break;
                }
            }
        }
    }

    if (g_fDefaultMediaRegistered == FALSE)
    {
        CMediaTypeHolder *pCMHolder;
        g_fDefaultMediaRegistered = TRUE;

        pCMHolder = GetMediaTypeHolder();

        if (pCMHolder)
        {
            DWORD dwSize =sizeof(rgMediaInfo)/sizeof(MediaInfo);
            hr = pCMHolder->RegisterMediaInfo(dwSize,rgMediaInfo,FALSE);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    PerfDbgLog(tagMediaApi, NULL, "-InternalRegisterDefaultMediaType");
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   FindMediaType
//
//  Synopsis:
//
//  Arguments:  [pwzType] --
//              [cfType] --
//
//  Returns:
//
//  History:    3-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT FindMediaType(LPCSTR pszType, CLIPFORMAT *cfType)
{
    HRESULT hr = E_OUTOFMEMORY;
    PerfDbgLog(tagMediaApi, NULL, "+FindMediaType");
    CMediaTypeHolder *pCMHolder;
    CLock lck(g_mxsMedia);

    UrlMkAssert((cfType));

    InternalRegisterDefaultMediaType();

    if ((pszType == NULL) || (cfType == CF_NULL))
    {
        hr = E_INVALIDARG;
    }
    else if ((pCMHolder = GetMediaTypeHolder()) != NULL)
    {

        CMediaType  *pCMType;
        *cfType = CF_NULL;

        hr = pCMHolder->FindCMediaType(pszType, &pCMType);
        if (hr == NOERROR)
        {
            *cfType = pCMType->GetClipFormat();
        }
    }
    else
    {
        hr = E_FAIL;
    }

    PerfDbgLog(tagMediaApi, NULL, "-FindMediaType");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindMediaTypeW
//
//  Synopsis:
//
//  Arguments:  [pwzType] --
//              [cfType] --
//
//  Returns:
//
//  History:    3-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT FindMediaTypeW(LPCWSTR pwzType, CLIPFORMAT *pcfType)
{
    HRESULT hr = E_NOTIMPL;
    PerfDbgLog(tagMediaApi, NULL, "+FindMediaTypeW");
    CMediaTypeHolder *pCMHolder;
    CLock lck(g_mxsMedia);

    char szMime[SZMIMESIZE_MAX];
    W2A(pwzType, szMime, SZMIMESIZE_MAX);

    if (FindMediaType((LPCSTR)szMime,pcfType) != NOERROR)
    {
        *pcfType = (CLIPFORMAT) RegisterClipboardFormat(szMime);
        hr = NOERROR;
    }

    PerfDbgLog(tagMediaApi, NULL, "-FindMediaTypeW");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindMediaString
//
//  Synopsis:
//
//  Arguments:  [cfFormat] --
//              [ppStr] --
//
//  Returns:
//
//  History:    3-29-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT FindMediaString(CLIPFORMAT cfFormat, LPSTR *ppStr)
{
    HRESULT hr = E_OUTOFMEMORY;
    PerfDbgLog1(tagMediaApi, NULL, "+FindMediaString (cfFormat:%d)", cfFormat);
    CMediaTypeHolder *pCMHolder;
    CLock lck(g_mxsMedia);

    UrlMkAssert((cfFormat));

    InternalRegisterDefaultMediaType();

    if ((pCMHolder = GetMediaTypeHolder()) != NULL)
    {
        CMediaType  *pCMType = NULL;
        hr = pCMHolder->FindCMediaType(cfFormat, &pCMType);
        if ((hr == NOERROR) && pCMType)
        {
            *ppStr = pCMType->GetTypeString();
            UrlMkAssert((*ppStr));
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    PerfDbgLog2(tagMediaApi, NULL, "-FindMediaString (clFormat:%d -> szMime:%s)",cfFormat,hr?"":*ppStr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindMediaTypeFormat
//
//  Synopsis:
//
//  Arguments:  [pszType] --
//              [cfType] --
//              [pdwFormat] --
//
//  Returns:
//
//  History:    7-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT FindMediaTypeFormat(LPCWSTR pwzType, CLIPFORMAT *cfType, DWORD *pdwFormat)
{
    HRESULT hr = E_OUTOFMEMORY;
    PerfDbgLog(tagMediaApi, NULL, "+FindMediaTypeFormat");
    CMediaTypeHolder *pCMHolder;
    CLock lck(g_mxsMedia);

    UrlMkAssert((cfType));

    LPSTR pszType = DupW2A(pwzType);

    InternalRegisterDefaultMediaType();

    if ((pszType == NULL) || (cfType == CF_NULL) || (!pdwFormat))
    {
        hr = E_INVALIDARG;
    }
    else if ((pCMHolder = GetMediaTypeHolder()) != NULL)
    {

        CMediaType  *pCMType;
        *cfType = CF_NULL;

        hr = pCMHolder->FindCMediaType(pszType, &pCMType);
        if (hr == NOERROR)
        {
            *cfType = pCMType->GetClipFormat();
            *pdwFormat = pCMType->GetDataFormat();
        }
    }
    else
    {
        hr = E_FAIL;
    }

    if (pszType)
    {
        delete pszType;
    }

    PerfDbgLog4(tagMediaApi, NULL, "-FindMediaTypeFormat (hr:%lx Mime:%ws, cf:%ld, DataFormat:%ld)",
        hr, pwzType, cfType, *pdwFormat);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindMediaTypeClassInfo
//
//  Synopsis:
//
//  Arguments:  [pszType] --
//              [pclsid] --
//              [pdwClsCtx] --
//
//  Returns:
//
//  History:    7-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT FindMediaTypeClassInfo(LPCSTR pszType, LPCSTR pszFileName, LPCLSID pclsid, DWORD *pdwClsCtx, DWORD dwFlags)
{
    HRESULT hr = E_OUTOFMEMORY;
    PerfDbgLog(tagMediaApi, NULL,"+FindMediaTypeClassInfo\n");
    CMediaTypeHolder *pCMHolder;
    BOOL fChecked = FALSE;
    CLock lck(g_mxsMedia);

    UrlMkAssert((pclsid));

    InternalRegisterDefaultMediaType();

    if ((pszType == NULL) || (!pclsid))
    {
        hr = E_INVALIDARG;
    }
    else if ((pCMHolder = GetMediaTypeHolder()) != NULL)
    {

        CMediaType  *pCMType;
        *pclsid = CLSID_NULL;

        hr = pCMHolder->FindCMediaType(pszType, &pCMType);
        if ( hr == NOERROR && !(dwFlags & MIMEFLAGS_IGNOREMIME_CLASSID) ) 
        {
            fChecked = TRUE;

            hr = pCMType->GetClsID(pclsid);

            if (hr == NOERROR)
            {
                hr = pCMType->GetClsCtx(pdwClsCtx);
                if (hr != NOERROR)
                {
                    hr = GetClsIDInfo(pclsid, 0, pdwClsCtx);
                    if (hr == NOERROR)
                    {
                        pCMType->SetClsCtx(*pdwClsCtx);
                    }
                }
            }
            else if (!pCMType->IsLookupDone())
            {
                pCMType->SetLookupDone();
                
                //
                // find the clsid and clsctx
                DWORD dwMimeFlags = 0;
                hr = GetMimeInfo((LPSTR)pszType, pclsid, FALSE, &dwMimeFlags);
                
                if (hr == NOERROR)
                {
                    pCMType->SetMimeInfo(*pclsid, dwMimeFlags);
                    hr = GetClsIDInfo(pclsid, 0, pdwClsCtx);
                    if (hr == NOERROR)
                    {
                        pCMType->SetClsCtx(*pdwClsCtx);
                    }
                } 
            
                // no class found yet - try the filename
                
                if (hr != NOERROR && pszFileName)
                {
                    WCHAR wzFileName[MAX_PATH];
                    
                    A2W((LPSTR)pszFileName,wzFileName, MAX_PATH);
                    
                    hr = GetClassFile(wzFileName, pclsid);

                    if (hr == NOERROR)
                    {
                        // do not trust filename-app/oc combination
                        // example: a.doc and a.xls are both marked as app/oc
                        if( strcmp(pszType, "application/octet-stream"))
                        {
                            
                            // found a class for this mime
                            pCMType->SetMimeInfo(*pclsid, dwMimeFlags);
                            hr = GetClsIDInfo(pclsid, 0, pdwClsCtx);
                            if (hr == NOERROR)
                            {
                                pCMType->SetClsCtx(*pdwClsCtx);
                            }
                        }
                        else
                        {
                            pCMType->SetLookupDone(FALSE);
                        }
    
                    }
                }
            }
        }
        
        if (   (hr != NOERROR || (dwFlags & MIMEFLAGS_IGNOREMIME_CLASSID) ) 
            && !fChecked )
        {
            hr = GetClassMime((LPSTR)pszType, pclsid, (dwFlags & MIMEFLAGS_IGNOREMIME_CLASSID));
        }
        
    }
    else
    {
        hr = E_FAIL;
    }

    PerfDbgLog1(tagMediaApi, NULL, "-FindMediaTypeClassInfo (hr:%lx)\n",hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\mon\guids.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       GUIDS.C
//
//  Contents:   Defines GUIDS used in this DLL.
//
//  Classes:
//
//  Functions:
//
//  History:    11-02-95   JoeS (Joe Souza)     Created
//
//----------------------------------------------------------------------------
#include <urlint.h>


#ifdef __cplusplus
extern "C" {
#endif

// CLSIDs of the classes implemented in this dll
//DEFINE_GUID(CLSID_URLMoniker, 0x79eac9e0, 0xbaf9, 0x11ce, 0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b);


#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} GUID;
#endif // GUID_DEFINED

const GUID CLSID_StdURLMoniker =
{
    0x79eac9d0, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b }
};
const GUID CLSID_StdURLProtocol =
{
    0x79eac9e1, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}
};

const GUID CLSID_PSUrlMonProxy =
{
    0x79eac9f1, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}
};



#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\mon\precomp1.inc ===
#//+---------------------------------------------------------------
#//
#//  File:      precomp1.inc
#//
#//  Contents:  directives for global precompiled include file when the
#//             sources file is two directories below com (or wherever
#//             this file is located).  We could easily have precomp3 and
#//             precomp4 for other areas.The urlint.* files should not
#//             otherwise be mentioned in the sources files.
#//
#//
#//----------------------------------------------------------------

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\..\inc\mon.h
PRECOMPILED_TARGET=$(GPCH_BUILD)\$(_OBJ_DIR)\*\mon.pch
PRECOMPILED_OPTION=/Yumon.h /Fp$(GPCH_BUILD)\$(_OBJ_DIR)\*\mon.pch
PRECOMPILED_OBJ=$(GPCH_BUILD)\$(_OBJ_DIR)\*\mon.obj


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\mon\httpneg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       HTTPNEG.CXX
//
//  Contents:   Code to handle multiplexing multiple concurrent
//              IHttpNegotiate interfaces.
//
//  Classes:    CHttpNegHolder
//
//  Functions:
//
//  History:    01-30-96    JoeS (Joe Souza)    Created
//
//----------------------------------------------------------------------------

#include <urlint.h>
#include <urlmon.hxx>
#include "httpneg.hxx"

CHttpNegHolder::CHttpNegHolder(void) : _CRefs()
{
    _pCHttpNegNode = NULL;
    _cElements = 0;
}

STDMETHODIMP CHttpNegHolder::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    UrlMkDebugOut((DEB_BINDING, "%p _IN CHttpNegHolder::QueryInterface\n", this));

    *ppvObj = NULL;
    if (riid == IID_IHttpNegotiate)
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
        CHttpNegNode   *pNode;

        pNode = _pCHttpNegNode;

        while (pNode)
        {
            hr = pNode->GetHttpNegotiate()->QueryInterface(riid, ppvObj);

            if (hr == NOERROR)
            {
                pNode = NULL;
            }
            else
            {
                pNode = pNode->GetNextNode();
            }
        }
    }

    UrlMkDebugOut((DEB_BINDING, "%p OUT CHttpNegHolder::QueryInterface (hr:%lx\n", this,hr));
    return hr;
}

STDMETHODIMP_(ULONG) CHttpNegHolder::AddRef(void)
{
    UrlMkDebugOut((DEB_BINDING, "%p _IN CHttpNegHolder::AddRef\n", this));

    LONG lRet = ++_CRefs;

    UrlMkDebugOut((DEB_BINDING, "%p OUT CHttpNegHolder::AddRef (cRefs:%ld)\n", this,lRet));
    return lRet;
}

STDMETHODIMP_(ULONG) CHttpNegHolder::Release(void)
{
    UrlMkDebugOut((DEB_BINDING, "%p _IN CHttpNegHolder::Release\n", this));
    UrlMkAssert((_CRefs > 0));

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        RemoveAllNodes();
        delete this;
    }

    UrlMkDebugOut((DEB_BINDING, "%p OUT CHttpNegHolder::Release (cRefs:%ld)\n",this,lRet));
    return lRet;
}

HRESULT CHttpNegHolder::BeginningTransaction(LPCWSTR szURL, LPCWSTR szHeaders,
            DWORD dwReserved, LPWSTR *pszAdditionalHeaders)
{
    UrlMkDebugOut((DEB_BINDING, "%p _IN CHttpNegHolder::BeginningTransaction (szURL:%ws, szHeaders:%ws)\n", this, szURL, szHeaders));
    VDATETHIS(this);
    HRESULT         hr = NOERROR;
    CHttpNegNode    *pNode;
    LPWSTR          szTmp = NULL, szNew = NULL, szRunning = NULL;

    pNode = _pCHttpNegNode;

    while (pNode)
    {
        hr = pNode->GetHttpNegotiate()->BeginningTransaction(szURL, szHeaders, dwReserved, &szNew);
        UrlMkDebugOut((DEB_BINDING, "%p === CHttpNegHolder::BeginningTransaction (szNew:%ws )\n", this, szNew));

        if (hr == NOERROR && szNew != NULL && szRunning != NULL)
        {
            szTmp = szRunning;
            szRunning = new WCHAR [wcslen(szTmp) + 1 + wcslen(szNew) + 1];
            if (szRunning)
            {
                if (szTmp)
                {
                    wcscpy(szRunning, szTmp);
                    wcscat(szRunning, szNew);
                }
                else
                {
                    wcscpy(szRunning, szNew);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            delete szTmp;
            delete szNew;

            if (hr != NOERROR)
            {
                goto BegTransExit;
            }
        }
        else
        {
            szRunning = szNew;
        }

        pNode = pNode->GetNextNode();
    }

    *pszAdditionalHeaders = szRunning;

BegTransExit:

    UrlMkDebugOut((DEB_BINDING, "%p OUT CHttpNegHolder::BeginningTransaction (pszAdditionalHeaders:%ws )\n", this, *pszAdditionalHeaders));
    return hr;
}

HRESULT CHttpNegHolder::OnResponse(DWORD dwResponseCode,LPCWSTR szResponseHeaders,
                        LPCWSTR szRequestHeaders,LPWSTR *pszAdditionalRequestHeaders)
{
    UrlMkDebugOut((DEB_BINDING, "%p _IN CHttpNegHolder::OnError\n", this));
    VDATETHIS(this);
    HRESULT         hr = NOERROR;
    CHttpNegNode    *pNode;
    LPWSTR          szTmp = NULL, szNew = NULL, szRunning = NULL;

    pNode = _pCHttpNegNode;

    while (pNode)
    {
        hr = pNode->GetHttpNegotiate()->OnResponse(dwResponseCode, szResponseHeaders, szRequestHeaders, &szNew);
        if (hr == NOERROR && szNew != NULL && szRunning != NULL)
        {
            szTmp = szRunning;
            szRunning = new WCHAR [wcslen(szTmp) + 1 + wcslen(szNew) + 1];
            if (szRunning)
            {
                if (szTmp)
                {
                    wcscpy(szRunning, szTmp);
                    wcscat(szRunning, szNew);
                }
                else
                {
                    wcscpy(szRunning, szNew);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            delete szTmp;
            delete szNew;

            if (hr != NOERROR)
            {
                goto OnErrorExit;
            }
        }
        else
        {
            szRunning = szNew;
        }

        pNode = pNode->GetNextNode();
    }

    *pszAdditionalRequestHeaders = szRunning;

    if (hr == E_NOTIMPL)
    {
        hr = NOERROR;
    }

OnErrorExit:

    UrlMkDebugOut((DEB_BINDING, "%p OUT CHttpNegHolder::OnError\n", this));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CHttpNegHolder::AddNode
//
//  Synopsis:
//
//  Arguments:  [pIHttpNeg] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CHttpNegHolder::AddNode(IHttpNegotiate *pIHttpNeg)
{
    UrlMkDebugOut((DEB_BINDING, "%p _IN CHttpNegHolder::AddNode \n", this));
    HRESULT hr = NOERROR;

    CHttpNegNode *pFirstNode = _pCHttpNegNode;
    CHttpNegNode *pNode;

    // Allocate memory for new pNode member.

    pNode = new CHttpNegNode(pIHttpNeg);

    if (!pNode)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        UrlMkDebugOut((DEB_BINDING, "%p IN  CHttpNegHolder::AddNode (New Node:%p, IHttpNeg:%p) \n",
                                        this, pNode,pNode->GetHttpNegotiate() ));

        // if a node is already
        if (pFirstNode)
        {
            pNode->SetNextNode(pFirstNode);
        }

        // the new node is the first node
        _pCHttpNegNode = pNode;
        _cElements++;
    }

    UrlMkDebugOut((DEB_BINDING, "%p OUT CHttpNegHolder::AddNode (NewNode:%p, hr:%lx) \n", this, pNode, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CHttpNegHolder::RemoveAllNodes
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CHttpNegHolder::RemoveAllNodes(void)
{
    UrlMkDebugOut((DEB_BINDING, "%p _IN CHttpNegHolder::RemoveAllNodes\n", this));
    HRESULT hr = S_OK;

    CHttpNegNode *pNode = _pCHttpNegNode;
    CHttpNegNode *pNextNode = NULL;

    while (pNode)
    {
        pNextNode = pNode->GetNextNode();

        // release the object
        pNode->GetHttpNegotiate()->Release();
        UrlMkDebugOut((DEB_BINDING, "%p OUT CHttpNegHolder::RemoveAllNodes (Delete Node:%p, IHttpNeg:%p) \n",
                        this, pNode, pNode->GetHttpNegotiate()));
        delete pNode;
        _cElements--;

        pNode = pNextNode;
    }

    _pCHttpNegNode = NULL;
    UrlMkAssert((_cElements == 0));

    UrlMkDebugOut((DEB_BINDING, "%p OUT CHttpNegHolder::RemoveAllNodes (hr:%lx) \n", this, hr));
    return hr;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\mon\httpcls.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       HTTPCLS.CXX
//
//  Contents:   Implements the HTTPMoniker class, which is derived from
//              the CAsyncMoniker class.
//
//  Classes:    HTTPMoniker
//
//  Functions:
//
//  History:    11-02-95   JoeS (Joe Souza)     Created
//
//----------------------------------------------------------------------------

#include <urlint.h>
#include "urlapi.hxx"
#include "casyncmk.hxx"
#include "httpcls.hxx"

STDMETHODIMP_(ULONG) HTTPMoniker::Release(void)
{
    // Decrement refcount, destroy object if refcount goes to zero.
    // Return the new refcount.

    if (!(--m_refs))
    {
        delete this;
        return(0);
    }

    return(m_refs);
}

STDMETHODIMP HTTPMoniker::GetClassID(CLSID *pClassID)
{
    VDATEPTRIN(pClassID, CLSID);

    *pClassID = CLSID_StdURLMoniker;
    return(NOERROR);
}

STDMETHODIMP HTTPMoniker::BindToStorage (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
    REFIID riid, LPVOID FAR* ppvObj)
{
    VDATEPTROUT(ppvObj, LPVOID);
    *ppvObj = NULL;
    VDATEIFACE(pbc);
    if (pmkToLeft)
        VDATEIFACE(pmkToLeft);

    HRESULT hresult = NOERROR;

    //if (!::CreateURLBinding(pbc, this, m_pwzURL))
    //if (!CreateURLBinding(pbc, this, m_pwzURL))
    //    hresult = E_OUTOFMEMORY;    // BUGBUG: Should we use a better error code?

    // BUGBUG: Must attach riid interface to new storage, and return storage
    // object in ppvObj.  (I.e. get temp file name and call StgOpenStorage, etc.

    return(hresult);
}

STDMETHODIMP HTTPMoniker::ParseDisplayName (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
    LPWSTR lpszDisplayName, ULONG FAR* pchEaten,
    LPMONIKER FAR* ppmkOut)
{
    VDATEPTROUT(ppmkOut, LPMONIKER);
    *ppmkOut = NULL;
    VDATEIFACE(pbc);
    if (pmkToLeft)
        VDATEIFACE(pmkToLeft);
    VDATEPTRIN(lpszDisplayName, char);
    VDATEPTROUT(pchEaten, ULONG);

    HRESULT hresult = NOERROR;
    int     len;

    if (m_pwzURL)
        delete [] m_pwzURL;

    len = wcslen(lpszDisplayName);

    m_pwzURL = new WCHAR [len + 1];
    if (!m_pwzURL)
        return(E_OUTOFMEMORY);
    wcscpy(m_pwzURL, lpszDisplayName);

    *pchEaten = len;
    *ppmkOut = this;
    AddRef();
    return(hresult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\mon\selfreg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       selfreg.cxx
//
//  Contents:   Taken from Office96
//              Source file for the common self registration code used by all the
//              sub projects of Sweeper project. They are
//              UrlMon
//              UrlMnPrx
//
//  Exports:    HrDllRegisterServer()
//              HrDllUnregisterServer()
//
//  Classes:
//
//  Functions:
//
//  History:    5-03-96   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <mon.h>
#include "selfreg.hxx"

HINSTANCE g_hinstDll = NULL;
PFNLOADSTRING g_pfnLoadString = NULL;

//+---------------------------------------------------------------------------
//
//  Function:   GetDllFullPath
//
//  Synopsis:
//
//  Arguments:  [lpszExeName] --
//              [cch] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL GetDllFullPath( LPSTR lpszExeName, DWORD cch )
{
    if ( NULL == g_hinstDll )
    {
        UrlMkAssert(( FALSE && "NULL hInst"));
        return FALSE;
    }

    *lpszExeName = NULL;

    if ( GetModuleFileName( g_hinstDll, lpszExeName, cch ) == 0)
    {
        UrlMkAssert(( FALSE && "GetModuleFileName Failed"));
        return FALSE;
    }

    return TRUE;
}


inline BOOL IsASeparator( char ch )
{
    return (ch == '\\' || ch == '/' || ch == ':');
}

//+---------------------------------------------------------------------------
//
//  Function:   ParseAFileName
//
//  Synopsis:
//
//  Arguments:  [szFileName] --
//              [piRetLen] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
LPSTR ParseAFileName( LPSTR szFileName, int *piRetLen)
{
    LPSTR pszFile;

    // Start at the end of the filename.
    pszFile = szFileName + ( lstrlen(szFileName) - 1 );

    // Back up to a '\\' or beginning or something!! We just want a file
    // name!. Whatever comes first.
    while ( pszFile > szFileName && !IsASeparator(*pszFile ) )
        pszFile = CharPrev(szFileName, pszFile);

    if ( pszFile != szFileName )
        pszFile = CharNext(pszFile);

    if ( piRetLen )
        *piRetLen = lstrlen(pszFile);

    return pszFile;
}


//+---------------------------------------------------------------------------
//
//  Function:   FRegisterEntries
//
//  Synopsis:   FRegisterEntries: Register a group of reg entries off a base key.
//
//  Arguments:  [hkRoot] --
//              [rgEntries] --
//              [dwEntries] --
//              [pszPath] --
//              [pszBinderName] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL FRegisterEntries(HKEY hkRoot, const REGENTRY rgEntries[],
                    DWORD dwEntries, char *pszPath, char *pszBinderName)
{
    HKEY    hkey = NULL;
    LONG    lRet;
    char    szValue[1024];
    char    szResString[1024];
    char    szKeyName[1024];
    BOOL    fRet = FALSE;
    int         i;

    for (i = 0; i < (int)dwEntries; i++)
    {
        // We work with a copy of the entry, since we might modify it
        REGENTRY reCurrentEntry = rgEntries[i];

        if (reCurrentEntry.iKeyType ==  KEYTYPE_RESID)
        {
            int cch;
            if (g_pfnLoadString == NULL)
                return FALSE;
            cch = g_pfnLoadString(g_hinstDll, (UINT) PtrToUlong(reCurrentEntry.pszKey), szKeyName,
                    sizeof(szKeyName));
            if (cch > 0 && cch <= 1024)
            {
                reCurrentEntry.pszKey = szKeyName;
            }
            else
            {
                UrlMkAssert(( FALSE && "LoadString Failed ( 1)"));
                continue;
            }
        }

        lRet = RegCreateKey(hkRoot, reCurrentEntry.pszKey, &hkey);

        if (lRet != ERROR_SUCCESS)
        {
            UrlMkAssert(( FALSE && "RegCreateKey Failed ( 1)"));
            continue;
        }

         // If the type is REG_RESID, then pbData holds the resource ID.  We
         // load the resource string, then modify our reCurrentEntry to point
         // to it.

        if (reCurrentEntry.dwType == REG_RESID)
        {
            int cch;
            if (g_pfnLoadString == NULL)
                return FALSE;

            cch = g_pfnLoadString(g_hinstDll, (UINT) PtrToUlong(reCurrentEntry.pbData), szResString,
                    sizeof(szResString));
            if (cch > 0 && cch <= 1024)
            {
                reCurrentEntry.dwType = REG_SZ;
                reCurrentEntry.pbData = (BYTE*) szResString;
            }
            else
            {
                UrlMkAssert(( FALSE && "LoadString Failed (2)"));
                reCurrentEntry.pbData = NULL;
            }
        }


        // Set the value if there is one
        if (reCurrentEntry.pbData != NULL || reCurrentEntry.dwType != REG_SZ)
        {
            switch (reCurrentEntry.dwType)
            {
                case REG_SZ:
                    // Replace the first %s with the path, and the second
                    // %s with the name of the binder app (may not do anything).
                    if (pszPath != NULL && pszBinderName != NULL)
                    {
                        wsprintf(szValue, (char*)reCurrentEntry.pbData, pszPath,
                            pszBinderName);

                        lRet = RegSetValueEx(hkey, reCurrentEntry.pszValueName, 0,
                            REG_SZ, (BYTE*)szValue, lstrlen(szValue)+1);
#if DBG == 1
                        if ( ERROR_SUCCESS != lRet )
                            UrlMkAssert(( FALSE && "RegSetValueEx Failed ( 1)"));
#endif
                    }
                    break;

                case REG_DWORD:
                    lRet = RegSetValueEx(hkey, reCurrentEntry.pszValueName, 0,
                        REG_DWORD,  (BYTE*)&reCurrentEntry.pbData, sizeof(DWORD));

#if DBG == 1
                    if ( ERROR_SUCCESS != lRet )
                        UrlMkAssert(( FALSE && "RegSetValueEx Failed (2)"));
#endif
                    break;

                default:
                    UrlMkAssert(( FALSE && "Unexpected reg entry type"));
                    // Unexpected type: ignore
                    break;
            }
        }

        // Close the subkey
        RegCloseKey(hkey);
        hkey = NULL;
    }

    fRet = TRUE;

    // Close the base key if it was open
    if (hkey)
        RegCloseKey(hkey);

    return fRet;
}


/*
 * FRegisterEntryGroups: Register several groups of reg entries.
 */
BOOL FRegisterEntryGroups(const REGENTRYGROUP *rgRegEntryGroups,
    char *pszPath, char *pszBinderName)
{
    BOOL fError = FALSE;
    int i;

    // Keep going even if we get some errors
    for (i=0; rgRegEntryGroups[i].hkRoot != NULL; i++)
    {
        if (!FRegisterEntries(rgRegEntryGroups[i].hkRoot, rgRegEntryGroups[i].rgEntries,
            rgRegEntryGroups[i].dwEntries,pszPath, pszBinderName))
        {
            fError = TRUE;
        }
    }

    return !fError;
}

//+---------------------------------------------------------------------------
//
//  Function:   FDeleteEntries
//
//  Synopsis:   Delete a group of reg entries off a base key.
//
//  Arguments:  [hkRoot] --
//              [rgEntries] --
//              [dwEntries] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL FDeleteEntries(HKEY hkRoot, const REGENTRY rgEntries[], DWORD dwEntries)
{
    LONG    lRet;
    int         i;
    char    szKeyName[1024];
    PSTR    pKey;

    // Delete in reverse order, to kill children before parent
    for (i = (int)dwEntries - 1; i >= 0; i--)
    {
        pKey = NULL;

        if (rgEntries[i].iKeyType ==  KEYTYPE_RESID)
        {
            int cch;
            cch = g_pfnLoadString(g_hinstDll, (UINT) PtrToUlong(rgEntries[i].pszKey), szKeyName,
                    sizeof(szKeyName));
            if (cch > 0 && cch <= 1024)
            {
                pKey = szKeyName;
            }
        else
            {
                UrlMkAssert(( FALSE && "LoadString Failed (FDeleteEntries)"));
                continue;
            }
        }
        else
        {
            if ( KEYTYPE_STRING != rgEntries[i].iKeyType )
            {
                UrlMkAssert(( FALSE && "Unknown Key Type"));
                continue;
            }
            pKey = rgEntries[i].pszKey;
        }

        if (pKey != NULL)
        {
            // Delete the current key if it has no subkeys.
            // Ignore the return value.
            lRet = RegDeleteKey(hkRoot, pKey);
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   FDeleteEntryGroups
//
//  Synopsis:   Delete the base keys of all the given groups.

//
//  Arguments:  [rgRegEntryGroups] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL FDeleteEntryGroups(const REGENTRYGROUP *rgRegEntryGroups)
{
    BOOL fError = FALSE;

    // Keep going even if we get some errors
    for (int i=0; rgRegEntryGroups[i].hkRoot != NULL; i++)
    {
        if (!FDeleteEntries(rgRegEntryGroups[i].hkRoot,
            rgRegEntryGroups[i].rgEntries,
            rgRegEntryGroups[i].dwEntries))
        {
            fError = TRUE;
        }
    }

    return !fError;
}


#ifdef NOT_USED
/*
 * FDeleteSubtree - Delete given key and all subkeys
 */
BOOL FDeleteSubtree(HKEY hkRoot, char *pszKey)
{
    HKEY        hkey = NULL;
    LONG        lRet;
    char        szSubKey[MAX_PATH];

    lRet = RegOpenKey(hkRoot, pszKey, &hkey);
    if (lRet != ERROR_SUCCESS)
        goto End;

    // remove all subkeys
    for (;;)
{
        lRet = RegEnumKey(hkey, 0, szSubKey, sizeof szSubKey);

        if (lRet == ERROR_NO_MORE_ITEMS)
            break;

        if (lRet != ERROR_SUCCESS)
            goto End;

        if (!FDeleteSubtree(hkey, szSubKey))
            goto End;
}

End:
    if (hkey != NULL)
        RegCloseKey (hkey);

    lRet = RegDeleteKey(hkRoot, pszKey);

    return (lRet == ERROR_SUCCESS);
}
#endif // NOT_USED



//+---------------------------------------------------------------------------
//
//  Function:   HrDllRegisterServer
//
//  Synopsis:   registers an entrygroup
//
//  Arguments:  [HINSTANCE] --
//              [hinstDll] --
//              [pfnLoadString] --
//              [pszAppName] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT HrDllRegisterServer(const REGENTRYGROUP *rgRegEntryGroups,HINSTANCE hinstDll,
                            PFNLOADSTRING pfnLoadString, char *pszAppName)
{
    // REVIEW: for Windows dll, do we want to register full path?
    BOOL    fRet = TRUE;
    char    szFullPath[MAX_PATH];
    char    szFileName[MAX_PATH];
    char    *pszFileName;

    g_hinstDll = hinstDll;
    if ((g_pfnLoadString = pfnLoadString) == NULL)
        // set the pointer to windows LoadString() api
        g_pfnLoadString = (PFNLOADSTRING) LoadString;

    if (!GetDllFullPath(szFullPath, MAX_PATH))
        return E_FAIL;

    pszFileName = ParseAFileName(szFullPath, NULL);

    if (pszAppName != NULL)
        lstrcpy(szFileName, pszAppName);
    else
        lstrcpy(szFileName, pszFileName);

    // Terminate the path at the file name
    *pszFileName = '\0';
#ifdef UNIX
    /* On Unix, we find the location of the dll using LD_LIBRARY_PATH
     * which is included in the wrapper script
     * So, we do not want to specify the whole path for the dll in the
     * registry.
     */
    *szFullPath = '\0';
#endif /* UNIX */
    fRet = FRegisterEntryGroups(rgRegEntryGroups, szFullPath, szFileName);

    g_hinstDll = NULL;
    g_pfnLoadString = NULL;
    return fRet ? NOERROR : E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrDllUnregisterServer
//
//  Synopsis:   unregisters an entrygroup
//
//  Arguments:  [HINSTANCE] --
//              [hinstDll] --
//              [pfnLoadString] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT HrDllUnregisterServer(const REGENTRYGROUP *rgRegEntryGroups,HINSTANCE hinstDll, PFNLOADSTRING pfnLoadString)
{
    g_hinstDll = hinstDll;
    if ((g_pfnLoadString = pfnLoadString) == NULL)
        // set the pointer to windows LoadString() api
        g_pfnLoadString = (PFNLOADSTRING) LoadString;

    FDeleteEntryGroups(rgRegEntryGroups);

    g_hinstDll = NULL;
    g_pfnLoadString = NULL;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\mon\tls.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       tls.cxx
//
//  Contents:   Thread Local Storage initialization and cleanup.
//
//  Classes:
//
//  Functions:
//
//  History:    12-02-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <mon.h>
#ifndef unix
#include "..\trans\transact.hxx"
#include "..\download\cdl.h"
#else
#include "../trans/transact.hxx"
#include "../download/cdl.h"
#endif /* unix */
#include <tls.h>

PerfDbgExtern(tagUrlDll)
DbgTag(tagUrlDllErr,  "Urlmon", "Log CBinding Errors", DEB_BINDING|DEB_ERROR);

// Thread Local Storage index.
DWORD gTlsIndex;
HINSTANCE g_hInst = 0;
HANDLE g_hHeap = 0;     // used for tls data

// Heap Handle
extern  HANDLE    g_hHeap;
#define HEAP_SERIALIZE 0
BOOL UnregisterUrlMkWndClass();
HRESULT DeleteOInetSession(DWORD dwReserved);

extern  URLMON_TS*  g_pHeadURLMONTSList;


HRESULT AddTSToList(URLMON_TS* pts)
{
    CLock lck(g_mxsMedia);
    pts->_pNext = g_pHeadURLMONTSList;
    g_pHeadURLMONTSList = pts;

    return NOERROR;
}

HRESULT RemoveTSFromList(DWORD tid)
{
    // this can only be called from ThreadDetach time
    CLock lck(g_mxsMedia);
    URLMON_TS*  pts = NULL;
    URLMON_TS*  ptsPrev = NULL;
    pts = g_pHeadURLMONTSList;

    while( pts )
    {
        if( pts->_dwTID == tid )
        {
            if( ptsPrev == NULL )
            {
                // this is the head of the list
                g_pHeadURLMONTSList = pts->_pNext;
            }
            else
            {
                ptsPrev->_pNext = pts->_pNext;
            }

            // destroy the window
            // can only be called from current thread

            DestroyWindow(pts->_hwndNotify);

            // delete pts
            delete pts;

            break;
        }

        // advance
        ptsPrev = pts;
        pts = pts->_pNext;
    }

    return NOERROR;
}

URLMON_TS* GetTS(DWORD tid)
{
    CLock lck(g_mxsMedia);
    URLMON_TS*  pts = NULL;
    pts = g_pHeadURLMONTSList;

    while( pts )
    {
        if( pts->_dwTID == tid )
        {
            break;
        }

        // advance
        pts = pts->_pNext;
    }

    return pts;
}

HRESULT CleanupTSOnProcessDetach()
{
    CLock lck(g_mxsMedia);

    URLMON_TS*  pts = NULL;
    URLMON_TS*  ptsToFree = NULL;
    pts = g_pHeadURLMONTSList;

    while( pts )
    {
        if( pts->_dwTID == GetCurrentThreadId() )
        {
            // destroy the window (the owner thread can do so)
            DestroyWindow(pts->_hwndNotify);
            DbgLog2(
                tagUrlDllErr,
                NULL,
                ">>> tid: %lx -> DestroyWindow :%p",
                pts->_dwTID,
                pts->_hwndNotify
            );
        }
        else
        {
            // we are on a thread different from the window owner
            // so we can only Post message

            // set wndproc to user32's
            SetWindowLongPtr(
                pts->_hwndNotify,
                GWLP_WNDPROC,
                (LONG_PTR)DefWindowProc);

            // post message
            PostMessage(pts->_hwndNotify, WM_CLOSE, 0, 0);
            DbgLog2(
                tagUrlDllErr,
                NULL,
                ">>> tid: %lx -> PostMessage WM_CLOSE :%p",
                pts->_dwTID,
                pts->_hwndNotify
            );
        }

        // save this pts since we are to free it
        ptsToFree = pts;

        // walk down the list
        pts = pts->_pNext;

        // free the pts
        if( ptsToFree )
        {
            delete ptsToFree;
            ptsToFree = NULL;
        }
    }

    // mark list empty
    g_pHeadURLMONTSList = NULL;

    return NOERROR;
}


//+-------------------------------------------------------------------------
//
//  Function:   TLSAllocData
//
//  Synopsis:   Allocates the thread local storage block
//
//  Returns:    S_OK - allocated the data
//              E_OUTOFMEMORY - could not allocate the data
//
//--------------------------------------------------------------------------
HRESULT CUrlMkTls::TLSAllocData(void)
{
    Win4Assert(TlsGetValue(gTlsIndex) == 0);
    Win4Assert(g_hHeap != NULL);

    _pData = (SUrlMkTlsData *) HeapAlloc(g_hHeap, HEAP_SERIALIZE,
                                       sizeof(SUrlMkTlsData));

    if (_pData)
    {
        // This avoids having to set most fields to NULL, 0, etc and
        // is needed cause on debug builds memory is not guaranteed to
        // be zeroed.

        memset(_pData, 0, sizeof(SUrlMkTlsData));

        // fill in the non-zero values

        _pData->dwFlags = URLMKTLS_LOCALTID;

#ifdef ENABLE_DEBUG
        _pData->ThreadId = GetCurrentThreadId();
#endif // ENABLE_DEBUG

        // store the data ptr in TLS
        if (TlsSetValue(gTlsIndex, _pData))
        {
            return S_OK;
        }

        // error, cleanup and fallthru to error exit
        HeapFree(g_hHeap, HEAP_SERIALIZE, _pData);
        _pData = NULL;
    }

    UrlMkDebugOut((DEB_TRACE, "TLSAllocData failed.\n"));
    return E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
//  Function:   DoThreadCleanup
//
//  Synopsis:   Called to perform cleanup on all this threads data
//              structures, and to call CoUninitialize() if needed.
//
//              Could be called by DLL_THREAD_DETACH or DLL_PROCESS_DETACH
//
//
//----------------------------------------------------------------------------
extern CMutexSem g_mxsTransMgr;
void DoThreadCleanup(BOOL bInThreadDetach)
{
    SUrlMkTlsData *pTls = (SUrlMkTlsData *) TlsGetValue(gTlsIndex);

    if (pTls != NULL)
    {

        // Because of the DLL unload rules in NT we need to be careful
        // what we do in clean up. We notify the routines with special
        // behavior here.

        pTls->dwFlags |= URLMKTLS_INTHREADDETACH;

        if (pTls->pCTransMgr != NULL)
        {
            // If the Release() returns non-zero, 
            // AND we're not really in ThreadDetach, then we have other references on 
            // the Transaction Manager.  Put back our reference and leave.
            //
            if (bInThreadDetach == FALSE)
            {
                CLock lck(g_mxsTransMgr);
                
                if (pTls->pCTransMgr->Release())
                {
                    pTls->pCTransMgr->AddRef();
                    pTls->dwFlags &= ~URLMKTLS_INTHREADDETACH;
                    goto Exit;
                }
            }
            else
            {
               pTls->pCTransMgr->Release();
            }
        }

        if (pTls->pCodeDownloadList != NULL)
        {
            delete pTls->pCodeDownloadList;
        }

        if (pTls->pRejectedFeaturesList != NULL)
        {
            LISTPOSITION curpos;
            LPCWSTR pwszRejectedFeature = NULL;
            int iNumRejected;
            int i;

            iNumRejected = pTls->pRejectedFeaturesList->GetCount();
            curpos = pTls->pRejectedFeaturesList->GetHeadPosition();

            // walk thru all the rejected features in the thread and delete
            for (i=0; i < iNumRejected; i++) {

                pwszRejectedFeature = pTls->pRejectedFeaturesList->GetNext(curpos);
                delete (LPWSTR)pwszRejectedFeature;

            }


            delete pTls->pRejectedFeaturesList;

        }

        if (pTls->pSetupCookie != NULL)
        {
            delete pTls->pSetupCookie;
        }

        if (pTls->pTrustCookie != NULL)
        {
            delete pTls->pTrustCookie;
        }

        if (pTls->pCDLPacketMgr != NULL)
        {
            delete pTls->pCDLPacketMgr;
        }

#ifdef PER_THREAD
        if (pTls->pCMediaHolder != NULL)
        {
            delete pTls->pCMediaHolder;
        }
#endif //PER_THREAD

        // reset the index so we dont find this data again.
        TlsSetValue(gTlsIndex, NULL);

        // cleanup hwnd (not on TLS, but on urlmon's global table)
        DWORD tid = GetCurrentThreadId();
        if( GetTS(tid))
        {
            RemoveTSFromList(tid);
        }

        if (pTls->hwndUrlMkNotify != NULL)
        {
            DbgLog1(tagUrlDllErr, NULL, "ASSERT!!! tld: %lx ->hwnd !NULL", tid);

        }

        /*******************************************************************
        if (pTls->hwndUrlMkNotify != NULL)
        {
            HWND h = pTls->hwndUrlMkNotify;
            DestroyWindow(pTls->hwndUrlMkNotify);
        }
        ********************************************************************/

        HeapFree(g_hHeap, HEAP_SERIALIZE, pTls);
    }
    // else
    // there is no TLS for this thread, so there can't be anything
    // to cleanup.

Exit:;
}

//+-------------------------------------------------------------------------
//
//  Function:   TlsDllMain
//
//  Synopsis:   Dll entry point
//
//  Arguments:  [hIntance]      -- a handle to the dll instance
//              [dwReason]      -- the reason LibMain was called
//              [lpvReserved]   - NULL - called due to FreeLibrary
//                              - non-NULL - called due to process exit
//
//  Returns:    TRUE on success, FALSE otherwise
//
//  Notes:      other one time initialization occurs in ctors for
//              global objects
//
//  WARNING:    if we are called because of FreeLibrary, then we should do as
//              much cleanup as we can. If we are called because of process
//              termination, we should not do any cleanup, as other threads in
//              this process will have already been killed, potentially while
//              holding locks around resources.
//
//
//--------------------------------------------------------------------------
STDAPI_(BOOL) TlsDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpvReserved )
{
    BOOL fResult = FALSE;

    #if DBG==1 || defined(PERFTAGS)
    if (dwReason == DLL_THREAD_ATTACH || dwReason == DLL_THREAD_DETACH)
        PerfDbgLog1(tagUrlDll, NULL, "+TlsDllMain %s", dwReason == DLL_THREAD_ATTACH ?
            "DLL_THREAD_ATTACH" : "DLL_THREAD_DETACH");
    #endif

    switch (dwReason)
    {
    case DLL_THREAD_ATTACH:

        // new thread is starting
        {
            HRESULT hr;
            CUrlMkTls tls(hr);
            if (FAILED(hr))
            {
                goto ret;
            }
        }
        break;

    case DLL_THREAD_DETACH:
        // Thread is exiting, clean up resources associated with threads.
        DoThreadCleanup(TRUE);
        break;

    case DLL_PROCESS_ATTACH:

        // Initial setup. Get a thread local storage index for use by OLE
        g_hInst = hInstance;
        if ((g_hHeap = GetProcessHeap()) == 0)
        {
            // can continue E_OUTOFMEMORY;
            UrlMkAssert("Call GetProcessHeap failed.");
            goto ret;
        }
        gTlsIndex = TlsAlloc();
        if (gTlsIndex == 0xffffffff)
        {
            UrlMkAssert("Could not get TLS Index.");
            goto ret;
        }
        {
            HRESULT hr;
            CUrlMkTls tls(hr);
            if (FAILED(hr))
            {
                goto ret;
            }
        }
        break;

    case DLL_PROCESS_DETACH:

        UrlMkDebugOut((DEB_DLL,"DLL_PROCESS_DETACH:\n"));
        //if (NULL == lpvReserved)
        {
            // exiting because of FreeLibrary, so try to cleanup

            // DLL_PROCESS_DETACH is called when we unload. The thread that is
            // currently calling has not done thread specific cleanup yet.
            //

            DoThreadCleanup(TRUE);

            UnregisterUrlMkWndClass();

            if (g_pCMHolder != NULL)
            {
                UrlMkDebugOut((DEB_DLL | DEB_ITRACE,">>> DoThreadCleanup delete process pCMediaHolder:%p \n", g_pCMHolder));
                delete g_pCMHolder;
                g_pCMHolder = 0;
            }
            DeleteOInetSession(0);

            if (g_hSession)
            {
                // BUGBUG: do not close the session handle - check with RFirth
                InternetCloseHandle(g_hSession);
                g_hSession = NULL;
            }

            TlsFree(gTlsIndex);

        }
        UrlMkDebugOut((DEB_DLL,"DLL_PROCESS_DETACH: done\n"));

        break;
    }

    fResult = TRUE;

ret:
    #if DBG==1 || defined(PERFTAGS)
    if (dwReason == DLL_THREAD_ATTACH || dwReason == DLL_THREAD_DETACH)
        PerfDbgLog(tagUrlDll, NULL, "-TlsDllMain");
    #endif

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\mon\mpxbsc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       MPXBSC.CXX
//
//  Contents:   Code to handle multiplexing multiple concurrent
//              IBindStatusCallback interfaces.
//
//  Classes:    CBSCHolder
//
//  Functions:
//
//  History:    01-04-96    JoeS (Joe Souza)    Created
//              01-15-96    JohannP (Johann Posch)  Modified to new IBSC
//
//----------------------------------------------------------------------------
#include <mon.h>
#include "mpxbsc.hxx"

PerfDbgTag(tagCBSCHolder, "Urlmon", "Log CBSCHolder", DEB_BINDING);

HRESULT GetObjectParam(IBindCtx *pbc, LPOLESTR pszKey, REFIID riid, IUnknown **ppUnk);

//+---------------------------------------------------------------------------
//
//  Function:   UrlMonInvokeExceptionFilterMSN
//
//  Synopsis:
//
//  Arguments:  [lCode] --
//              [lpep] --
//
//  Returns:
//
//  History:    8-25-97   DanpoZ(Danpo Zhang)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LONG UrlMonInvokeExceptionFilterMSN( DWORD lCode, LPEXCEPTION_POINTERS lpep )
{
    DEBUG_ENTER((DBG_CALLBACK,
                Int,
                "UrlMonInvokeExceptionFilterMSN",
                "%#x, %#x",
                lCode, lpep
                ));
                
#if DBG == 1
    DbgLog2(tagCBSCHolder, NULL, "Exception 0x%#x at address 0x%#x",
               lCode, lpep->ExceptionRecord->ExceptionAddress);
    DebugBreak();
#endif
    LONG exr = EXCEPTION_CONTINUE_EXECUTION;

    if( lCode == STATUS_ACCESS_VIOLATION )
    {
        char achProgname[256];
        achProgname[0] = 0;
        GetModuleFileNameA(NULL,achProgname,sizeof(achProgname));

        if( StrStrI(achProgname, "msnviewr.exe") )
        {
            exr = EXCEPTION_EXECUTE_HANDLER;
        }
    }

    DEBUG_LEAVE(exr);
    return exr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetBSCHolder
//
//  Synopsis:   Returns a holder for IBindStatusCallback
//
//  Arguments:  [pBC] --
//              [ppCBSHolder] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetBSCHolder(LPBC pBC, CBSCHolder **ppCBSHolder)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "GetBSCHolder",
                "%#x, %#x",
                pBC, ppCBSHolder
                ));
                
    PerfDbgLog(tagCBSCHolder, NULL, "+GetBSCHolder");
    UrlMkAssert((ppCBSHolder != NULL));

    HRESULT hr;
    CBSCHolder *pCBSCBHolder = NULL;

    hr = GetObjectParam(pBC, REG_BSCB_HOLDER, IID_IBindStatusCallbackHolder, (IUnknown **)&pCBSCBHolder);
    if (pCBSCBHolder == NULL)
    {
        pCBSCBHolder = new CBSCHolder;
        if (!pCBSCBHolder)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = pBC->RegisterObjectParam(REG_BSCB_HOLDER, (IBindStatusCallback *) pCBSCBHolder);
            *ppCBSHolder = pCBSCBHolder;
        }
    }
    else
    {
        *ppCBSHolder = pCBSCBHolder;
    }

    PerfDbgLog1(tagCBSCHolder, NULL, "-GetBSCHolder (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

CBSCHolder::CBSCHolder(void) : _CRefs(), _cElements(0)
{
    DEBUG_ENTER((DBG_CALLBACK,
                None,
                "CBSCHolder::CBSCHolder",
                "this=%#x",
                this
                ));
                
    _pCBSCNode = NULL;
    _fBindStarted = FALSE;
    _fBindStopped = FALSE;
    _fHttpNegotiate = FALSE;
    _fAuthenticate  = FALSE;

    _fHttpNegotiate2 = FALSE;

    DEBUG_LEAVE(0);
}

CBSCHolder::~CBSCHolder(void)
{
    DEBUG_ENTER((DBG_CALLBACK,
                None,
                "CBSCHolder::~CBSCHolder",
                "this=%#x",
                this
                ));
                
    CBSCNode *pNode, *pNextNode;

    pNode = _pCBSCNode;

    while (pNode)
    {
        pNextNode = pNode->GetNextNode();
        delete pNode;
        pNode = pNextNode;
    }

    DEBUG_LEAVE(0);
}

STDMETHODIMP CBSCHolder::QueryInterface(REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppvObj
                ));
                
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::QueryInterface");

    if (   (riid == IID_IUnknown)
        || (riid == IID_IBindStatusCallback)
        || (riid == IID_IBindStatusCallbackHolder) )
    {
        // the holder is not marshalled!!
        *ppvObj = (void*)(IBindStatusCallback *) this;
    }
    else if (riid == IID_IServiceProvider)
    {
        *ppvObj = (void*)(IServiceProvider *) this;
    }
    else if (riid == IID_IHttpNegotiate)
    {
        *ppvObj = (void*)(IHttpNegotiate *) this;
    }
    else if (riid == IID_IHttpNegotiate2)
    {
        *ppvObj = (void*)(IHttpNegotiate2 *) this;
    }
    else if (riid == IID_IAuthenticate)
    {
        *ppvObj = (void*)(IAuthenticate *) this;
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }

    if (hr == NOERROR)
    {
        AddRef();
    }

    PerfDbgLog1(tagCBSCHolder, this, "-CBSCHolder::QueryInterface (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP_(ULONG) CBSCHolder::AddRef(void)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Dword,
                "CBSCHolder::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    LONG lRet = ++_CRefs;
    PerfDbgLog1(tagCBSCHolder, this, "CBSCHolder::AddRef (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

STDMETHODIMP_(ULONG) CBSCHolder::Release(void)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Dword,
                "CBSCHolder::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::Release");
    UrlMkAssert((_CRefs > 0));

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        delete this;
    }

    PerfDbgLog1(tagCBSCHolder, this, "-CBSCHolder::Release (cRefs:%ld)",lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::GetBindInfo
//
//  Synopsis:
//
//  Arguments:  [grfBINDINFOF] --
//              [pbindinfo] --
//
//  Returns:
//
//  History:
//
//  Notes:      Only the first BSC which also receives data gets called
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::GetBindInfo(DWORD *grfBINDINFOF,BINDINFO * pbindinfo)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::IBindStatusCallback::GetBindInfo",
                "this=%#x, %#x, %#x",
                this, grfBINDINFOF, pbindinfo
                ));
                
    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::GetBindInfo");
    HRESULT     hr = E_FAIL;
    CBSCNode   *pNode;

    pNode = _pCBSCNode;

    if (pNode && (pNode->GetFlags() & BSCO_GETBINDINFO))
    {
        UrlMkAssert(( pbindinfo && (pbindinfo->cbSize == sizeof(BINDINFO)) ));

        DEBUG_ENTER((DBG_CALLBACK,
                    Hresult,
                    "EXTERNAL_CLIENT::IBindStatusCallback::GetBindInfo",
                    "this=%#x, %#x, %#x",
                    pNode->GetBSCB(), grfBINDINFOF, pbindinfo
                    ));
                    
        // We only call the first link for GetBindInfo.
        hr = pNode->GetBSCB()->GetBindInfo(grfBINDINFOF, pbindinfo);
        
        DEBUG_LEAVE(hr);
    }
    else
    {
        UrlMkAssert((FALSE && "Not IBSC node called on GetBindInfo"));
    }

    PerfDbgLog2(tagCBSCHolder, this, "-CBSCHolder::CallGetBindInfo (grfBINDINFOF:%lx, hr:%lx)", grfBINDINFOF,  hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::OnStartBinding
//
//  Synopsis:
//
//  Arguments:  [grfBINDINFOF] --
//              [pib] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::OnStartBinding(DWORD grfBINDINFOF, IBinding * pib)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::IBindStatusCallback::OnStartBinding",
                "this=%#x, %#x, %#x",
                this, grfBINDINFOF, pib
                ));
                
    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::OnStartBinding");
    VDATETHIS(this);

    HRESULT     hr = E_FAIL;
    CBSCNode   *pNode;
    BOOL        fFirstNode = TRUE;

    _fBindStarted = TRUE;

    pNode = _pCBSCNode;

    while (pNode)
    {
        grfBINDINFOF = pNode->GetFlags();

        if (fFirstNode)
        {
            grfBINDINFOF |= (BSCO_ONDATAAVAILABLE | BSCO_ONOBJECTAVAILABLE);
        }
        else
        {
            grfBINDINFOF &= ~(BSCO_ONDATAAVAILABLE | BSCO_ONOBJECTAVAILABLE);
        }

        DbgLog1(tagCBSCHolder, this, "CBSCHolder::OnStartBinding on (IBSC:%lx)", pNode->GetBSCB());

        DEBUG_ENTER((DBG_CALLBACK,
                    Hresult,
                    "EXTERNAL_CLIENT::IBindStatusCallback::OnStartBinding",
                    "this=%#x, %#x, %#x",
                    pNode->GetBSCB(), grfBINDINFOF, pib
                    ));
                    
        hr = pNode->GetBSCB()->OnStartBinding(grfBINDINFOF, pib);

        DEBUG_LEAVE(hr);
        
        pNode = pNode->GetNextNode();
        fFirstNode = FALSE;
    }

    // BUGBUG: hr is set to return code only from last node we called.
    // Is this what we want?
    // What if one of the earlier nodes failed?

    PerfDbgLog1(tagCBSCHolder, this, "-CBSCHolder::OnStartBinding (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::OnProgress
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//              [ulProgressMax] --
//              [ulStatusCode] --
//              [szStatusText] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::OnProgress(ULONG ulProgress,ULONG ulProgressMax,
                               ULONG ulStatusCode, LPCWSTR szStatusText)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::IBindStatusCallback::OnProgress",
                "this=%#x, %#x, %#x, %#x, %.80wq",
                this, ulProgress, ulProgressMax, ulStatusCode, szStatusText
                ));
                
    PerfDbgLog4(tagCBSCHolder, this, "+CBSCHolder::OnProgress (StatusCode:%ld, StatusText:%ws, Progress:%ld, ProgressMax:%ld)",
        ulStatusCode, szStatusText?szStatusText:L"", ulProgress, ulProgressMax);
    VDATETHIS(this);
    HRESULT     hr = NOERROR;
    CBSCNode   *pNode;

    pNode = _pCBSCNode;

    while (pNode)
    {
        if (pNode->GetFlags() & BSCO_ONPROGRESS)
        {
            DEBUG_ENTER((DBG_CALLBACK,
                        Hresult,
                        "EXTERNAL_CLIENT::IBindStatusCallback::OnProgress",
                        "this=%#x, %#x, %#x, %#x, %.80wq",
                        pNode->GetBSCB(), ulProgress, ulProgressMax, ulStatusCode, szStatusText
                        ));
                        
            hr = pNode->GetBSCB()->OnProgress(ulProgress, ulProgressMax, ulStatusCode,szStatusText);

            DEBUG_LEAVE(hr);
        }

        pNode = pNode->GetNextNode();
    }

    // BUGBUG: hr is set to return code only from last node we called.
    // Is this what we want?
    // What if one of the earlier nodes failed?

    PerfDbgLog1(tagCBSCHolder, this, "-CBSCHolder::OnProgress (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::OnDataAvailable
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [FORMATETC] --
//              [pformatetc] --
//              [pstgmed] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::OnDataAvailable(DWORD grfBSC,DWORD dwSize,FORMATETC *pformatetc, STGMEDIUM *pstgmed)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::IBindStatusCallback::OnDataAvailable",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, grfBSC, dwSize, pformatetc, pstgmed
                ));

    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::OnDataAvailable");
    VDATETHIS(this);
    HRESULT     hr = E_FAIL;
    CBSCNode   *pNode;

    pNode = _pCBSCNode;

    if (pNode && (pNode->GetFlags() & BSCO_ONDATAAVAILABLE))
    {
        DEBUG_ENTER((DBG_CALLBACK,
                    Hresult,
                    "EXTERNAL_CLIENT::IBindStatusCallback::OnDataAvailable",
                    "this=%#x, %#x, %#x, %#x, %#x",
                    pNode->GetBSCB(), grfBSC, dwSize, pformatetc, pstgmed
                    ));
                    
        hr = pNode->GetBSCB()->OnDataAvailable(grfBSC, dwSize, pformatetc, pstgmed);

        DEBUG_LEAVE(hr);
        
        //hr = NOERROR; //Trident BTS->BTO
    }

    PerfDbgLog1(tagCBSCHolder, this, "-CBSCHolder::OnDataAvailable (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::OnObjectAvailable
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [punk] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::IBindStatusCallback::OnObjectAvailable",
                "this=%#x, %#x, %#x",
                this, &riid, punk
                ));

    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::OnObjectAvailable");
    VDATETHIS(this);
    CBSCNode   *pNode;

    pNode = _pCBSCNode;

    if (pNode && (pNode->GetFlags() & BSCO_ONOBJECTAVAILABLE))
    {
        DEBUG_ENTER((DBG_CALLBACK,
                    Hresult,
                    "EXTERNAL_CLIENT::IBindStatusCallback::OnObjectAvailable",
                    "this=%#x, %#x, %#x",
                    pNode->GetBSCB(), &riid, punk
                    ));
                
        HRESULT hr = pNode->GetBSCB()->OnObjectAvailable(riid, punk);

        DEBUG_LEAVE(hr);
    }

    PerfDbgLog(tagCBSCHolder, this, "-CBSCHolder::OnObjectAvailable (hr:0)");

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::OnLowResource
//
//  Synopsis:
//
//  Arguments:  [reserved] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::OnLowResource(DWORD reserved)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::IBindStatusCallback::OnLowResource",
                "this=%#x, %#x",
                this, reserved
                ));
                
    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::OnLowResource");
    VDATETHIS(this);
    HRESULT     hr = E_FAIL;
    CBSCNode   *pNode;

    pNode = _pCBSCNode;

    while (pNode)
    {
        if (pNode->GetFlags() & BSCO_ONLOWRESOURCE)
        {
            DEBUG_ENTER((DBG_CALLBACK,
                        Hresult,
                        "EXTERNAL_CLIENT::IBindStatusCallback::OnLowResource",
                        "this=%#x, %#x",
                        pNode->GetBSCB(), reserved
                        ));
                
            hr = pNode->GetBSCB()->OnLowResource(reserved);

            DEBUG_LEAVE(hr);
        }

        pNode = pNode->GetNextNode();
    }

    // BUGBUG: hr is set to return code only from last node we called.
    // Is this what we want?
    // What if one of the earlier nodes failed?

    PerfDbgLog1(tagCBSCHolder, this, "-CBSCHolder::OnLowResource (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::OnStopBinding
//
//  Synopsis:
//
//  Arguments:  [LPCWSTR] --
//              [szError] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::OnStopBinding(HRESULT hrRes,LPCWSTR szError)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::IBindStatusCallback::OnStopBinding",
                "this=%#x, %#x, %.80wq",
                this, hrRes, szError
                ));
                
    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::OnStopBinding");
    HRESULT     hr = E_FAIL;
    CBSCNode   *pNode;
    CBSCNode   *pNodeNext;
    DWORD      dwFault;

    VDATETHIS(this);

    _fBindStopped = TRUE;   // Allow consumer to remove node on OnStopBinding.

    pNode = _pCBSCNode;

        while (pNode)
        {
            // save the next node since this node
            // we using now might get deleted
            // by RevokeBindStatusCallback
            pNodeNext = pNode->GetNextNode();

            pNode->SetLocalFlags(NODE_FLAG_REMOVEOK);

            PerfDbgLog2(tagCBSCHolder, this, "+CBSCHolder::OnStopBinding calling (Node:%lx, IBSC:%lx)",
            pNode,pNode->GetBSCB());

            // IE4 bug #32739, the CBSC might no longer be there (MSN) 
            _try
            {
                DEBUG_ENTER((DBG_CALLBACK,
                            Hresult,
                            "EXTERNAL_CLIENT::IBindStatusCallback::OnStopBinding",
                            "this=%#x, %#x, %.80wq",
                            pNode->GetBSCB(), hrRes, szError
                            ));
                            
                hr = pNode->GetBSCB()->OnStopBinding(hrRes, szError);

                DEBUG_LEAVE(hr);
            }
            //_except(UrlMonInvokeExceptionFilterMSN(GetExceptionCode(), GetExceptionInformation()))
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                DEBUG_LEAVE(hr);
                
                #if DBG == 1
                {
                    dwFault = GetExceptionCode();
                    DbgLog1(tagCBSCHolder, this, "fault 0x%08x at OnStopBinding", dwFault);
                }
                #endif
            }
#ifdef unix
            __endexcept
#endif /* unix */
            PerfDbgLog1(tagCBSCHolder, this, "-CBSCHolder::OnStopBinding done (Node:%lx)", pNode);

            pNode = pNodeNext;
        }

    // Reset bind active flags.

    _fBindStarted = FALSE;
    _fBindStopped = FALSE;

    // BUGBUG: hr is set to return code only from last node we called.
    // Is this what we want?
    // What if one of the earlier nodes failed?

    PerfDbgLog1(tagCBSCHolder, this, "-CBSCHolder::OnStopBinding (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::GetPriority
//
//  Synopsis:
//
//  Arguments:  [pnPriority] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::GetPriority(LONG * pnPriority)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::IBindStatusCallback::GetPriority",
                "this=%#x, %#x",
                this, pnPriority
                ));

    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::GetPriority");
    HRESULT     hr = E_FAIL;
    CBSCNode   *pNode;

    pNode = _pCBSCNode;

    if (pNode && (pNode->GetFlags() & BSCO_GETPRIORITY))
    {
        DEBUG_ENTER((DBG_CALLBACK,
                    Hresult,
                    "EXTERNAL_CLIENT::IBindStatusCallback::GetPriority",
                    "this=%#x, %#x",
                    pNode->GetBSCB(), pnPriority
                    ));
                    
        hr = pNode->GetBSCB()->GetPriority(pnPriority);

        DEBUG_LEAVE(hr);
    }

    PerfDbgLog1(tagCBSCHolder, this, "-CBSCHolder::GetPriority (hr:%lx)", hr);

    DEBUG_LEAVE(S_FALSE);
    return S_FALSE;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::QueryService
//
//  Synopsis:
//
//  Arguments:  [rsid] --
//              [iid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    4-05-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::QueryService(REFGUID rsid, REFIID riid, void ** ppvObj)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::IServiceProvider::QueryService",
                "this=%#x, %#x, %#x, %#x",
                this, &rsid, &riid, ppvObj
                ));
                
    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::QueryService");
    HRESULT     hr = NOERROR;
    VDATETHIS(this);
    UrlMkAssert((ppvObj));

    *ppvObj = 0;

    hr = ObtainService(rsid, riid, ppvObj);
    UrlMkAssert(( (hr == E_NOINTERFACE) || ((hr == NOERROR) && *ppvObj) ));

    PerfDbgLog1(tagCBSCHolder, this, "-CBSCHolder::QueryService (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::BeginningTransaction
//
//  Synopsis:
//
//  Arguments:  [szURL] --
//              [szHeaders] --
//              [dwReserved] --
//              [pszAdditionalHeaders] --
//
//  Returns:
//
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::BeginningTransaction(LPCWSTR szURL, LPCWSTR szHeaders,
            DWORD dwReserved, LPWSTR *pszAdditionalHeaders)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::IHttpNegotiate::BeginningTransaction",
                "this=%#x, %.80wq, %.80wq, %#x, %#x",
                this, szURL, szHeaders, dwReserved, pszAdditionalHeaders
                ));
                
    PerfDbgLog2(tagCBSCHolder, this, "+CBSCHolder::BeginningTransaction (szURL:%ws, szHeaders:%ws)", szURL, XDBG(szHeaders,""));
    VDATETHIS(this);
    HRESULT    hr = NOERROR;
    CBSCNode   *pNode;
    LPWSTR     szTmp = NULL, szNew = NULL, szRunning = NULL;

    pNode = _pCBSCNode;
    UrlMkAssert((szURL));

    while (pNode)
    {
        if (pNode->GetHttpNegotiate())
        {
            DEBUG_ENTER((DBG_CALLBACK,
                        Hresult,
                        "EXTERNAL_CLIENT::IHttpNegotiate::BeginningTransaction",
                        "this=%#x, %.80wq, %.80wq, %#x, %#x",
                        pNode->GetHttpNegotiate(), szURL, szHeaders, dwReserved, pszAdditionalHeaders
                        ));
                
            hr = pNode->GetHttpNegotiate()->BeginningTransaction(szURL, szHeaders, dwReserved, &szNew);

            DEBUG_LEAVE(hr);
            
            PerfDbgLog2(tagCBSCHolder, this, "CBSCHolder::BeginningTransaction (IHttpNegotiate:%lx, szNew:%ws)",
                pNode->GetHttpNegotiate(), XDBG(szNew,L""));

            // shdocvw might return uninitialized hr, so we
            // should just check for szNew not NULL and reset hr
            if( hr != NOERROR && szNew != NULL )
            {
                hr = NOERROR;
            }

            if (hr == NOERROR && szNew != NULL && szRunning != NULL)
            {
                szTmp = szRunning;
                szRunning = new WCHAR [wcslen(szTmp) + 1 + wcslen(szNew) + 1];
                if (szRunning)
                {
                    if (szTmp)
                    {
                        wcscpy(szRunning, szTmp);
                        wcscat(szRunning, szNew);
                    }
                    else
                    {
                        wcscpy(szRunning, szNew);
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                delete szTmp;
                delete szNew;

                if (hr != NOERROR)
                {
                    goto BegTransExit;
                }
            }
            else
            {
                szRunning = szNew;
            }
        }

        pNode = pNode->GetNextNode();
    }

    *pszAdditionalHeaders = szRunning;

BegTransExit:
    PerfDbgLog1(tagCBSCHolder, this, "-CBSCHolder::BeginningTransaction (pszAdditionalHeaders:%ws)", (hr || !*pszAdditionalHeaders) ? L"":*pszAdditionalHeaders);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::OnResponse
//
//  Synopsis:
//
//  Arguments:  [LPCWSTR] --
//              [szResponseHeaders] --
//              [LPWSTR] --
//              [pszAdditionalRequestHeaders] --
//
//  Returns:
//
//  History:    4-05-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::OnResponse(DWORD dwResponseCode,LPCWSTR wzResponseHeaders,
                        LPCWSTR wzRequestHeaders,LPWSTR *pszAdditionalRequestHeaders)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::IHttpNegotiate::OnResponse",
                "this=%#x, %#x, %.80wq, %.80wq, %#x",
                this, dwResponseCode, wzResponseHeaders, wzRequestHeaders, pszAdditionalRequestHeaders
                ));
                
    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::OnResponse");
    VDATETHIS(this);
    HRESULT    hr;
    CBSCNode   *pNode;
    LPWSTR     szTmp = NULL, szNew = NULL, szRunning = NULL;

    pNode = _pCBSCNode;

    hr = (IsStatusOk(dwResponseCode)) ? S_OK : S_FALSE;

    while (pNode)
    {
        if (pNode->GetHttpNegotiate())
        {
            PerfDbgLog1(tagCBSCHolder, this, "+CBSCHolder::OnResponse on Node: %lx", pNode);
            
            DEBUG_ENTER((DBG_CALLBACK,
                        Hresult,
                        "EXTERNAL_CLIENT::IHttpNegotiate::OnResponse",
                        "this=%#x, %#x, %.80wq, %.80wq, %#x",
                        pNode->GetHttpNegotiate(), dwResponseCode, wzResponseHeaders, wzRequestHeaders, pszAdditionalRequestHeaders
                        ));
                        
            hr = pNode->GetHttpNegotiate()->OnResponse(dwResponseCode, wzResponseHeaders, wzRequestHeaders, &szNew);
    
            DEBUG_LEAVE(hr);
            
            PerfDbgLog2(tagCBSCHolder, this, "-CBSCHolder::OnResponse on Node: %lx, hr:%lx", pNode, hr);
            if (hr == NOERROR && szNew != NULL && szRunning != NULL)
            {
                szTmp = szRunning;
                szRunning = new WCHAR [wcslen(szTmp) + 1 + wcslen(szNew) + 1];
                if (szRunning)
                {
                    if (szTmp)
                    {
                        wcscpy(szRunning, szTmp);
                        wcscat(szRunning, szNew);
                    }
                    else
                    {
                        wcscpy(szRunning, szNew);
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                delete szTmp;
                delete szNew;

                if (hr != NOERROR)
                {
                    goto OnErrorExit;
                }
            }
            else
            {
                szRunning = szNew;
            }
        }
        pNode = pNode->GetNextNode();
    }

    if (pszAdditionalRequestHeaders)
    {
        *pszAdditionalRequestHeaders = szRunning;
    }

    if (hr == E_NOTIMPL)
    {
        hr = NOERROR;
    }

OnErrorExit:

    PerfDbgLog(tagCBSCHolder, this, "-CBSCHolder::OnResponse");

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT CBSCHolder::GetRootSecurityId(BYTE* pbSecurityId, DWORD* cbSecurityId, 
            DWORD_PTR dwReserved)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::IHttpNegotiate2::GetRootSecurityId",
                "this=%#x, %#x, %#x, %#x",
                this, pbSecurityId, cbSecurityId, dwReserved
                ));
                
    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::GetRootSecurityId");
    VDATETHIS(this);
    HRESULT hr = E_FAIL;
    CBSCNode *pNode;
    pNode = _pCBSCNode;

    while (pNode)
    {
        if (pNode->GetHttpNegotiate2())
        {
            DEBUG_ENTER((DBG_CALLBACK,
                        Hresult,
                        "EXTERNAL_CLIENT::IHttpNegotiate2::GetRootSecurityId",
                        "this=%#x, %#x, %#x, %#x",
                        pNode->GetHttpNegotiate2(), pbSecurityId, cbSecurityId, dwReserved
                        ));
                        
            hr = pNode->GetHttpNegotiate2()->GetRootSecurityId( pbSecurityId, cbSecurityId, dwReserved );

            DEBUG_LEAVE(hr);
            
            if (SUCCEEDED(hr))
            {
                break;
            }
        }

        pNode = pNode->GetNextNode();
    }

    PerfDbgLog(tagCBSCHolder, this, "-CBSCHolder::Authenticate");

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::Authenticate
//
//  Synopsis:
//
//  Arguments:  [phwnd] --
//              [pszUsername] --
//              [pszPassword] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::Authenticate(HWND* phwnd, LPWSTR *pszUsername,
            LPWSTR *pszPassword)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::IAuthenticate::Authenticate",
                "this=%#x, %#x, %#x, %#x",
                this, phwnd, pszUsername, pszPassword
                ));
                
    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::Authenticate");
    VDATETHIS(this);
    HRESULT hr = NOERROR;
    CBSCNode *pNode;
    pNode = _pCBSCNode;

    while (pNode)
    {
        if (pNode->GetAuthenticate())
        {
            DEBUG_ENTER((DBG_CALLBACK,
                        Hresult,
                        "EXTERNAL_CLIENT::IAuthenticate::Authenticate",
                        "this=%#x, %#x, %#x, %#x",
                        pNode->GetAuthenticate(), phwnd, pszUsername, pszPassword
                        ));
                        
            hr = pNode->GetAuthenticate()->Authenticate(phwnd, pszUsername, pszPassword);

            DEBUG_LEAVE(hr);
            
            if (hr == S_OK)
            {
                break;
            }
        }

        pNode = pNode->GetNextNode();
    }

    PerfDbgLog(tagCBSCHolder, this, "-CBSCHolder::Authenticate");

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::AddNode
//
//  Synopsis:
//
//  Arguments:  [pIBSC] --
//              [grfFlags] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::AddNode(IBindStatusCallback *pIBSC, DWORD grfFlags)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::AddNode",
                "this=%#x, %#x, %#x",
                this, pIBSC, grfFlags
                ));
                
    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::AddNode");
    HRESULT hr = NOERROR;
    CLock lck(_mxs);

    CBSCNode *pFirstNode = _pCBSCNode;
    CBSCNode *pNode;
    CBSCNode *pNodeTmp;
    LPVOID pvLocal = NULL;

    // No new nodes allowed after binding has started.
    if (_fBindStarted)
    {
        hr = E_FAIL;
        goto AddNodeExit;
    }

    // Allocate memory for new pNode member.
    pNode = new CBSCNode(pIBSC, grfFlags);

    if (!pNode)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        // addref the IBSC pointer
        pIBSC->AddRef();

        // QI for IServiceProvider - QI addref IBSC
        if (pIBSC->QueryInterface(IID_IServiceProvider, &pvLocal) == NOERROR)
        {
            pNode->SetServiceProvider((IServiceProvider *)pvLocal);
        }

        PerfDbgLog3(tagCBSCHolder, this, "CBSCHolder::AddNode (New Node:%lx, IBSC:%lx, IServiceProvider:%lx)",
            pNode, pNode->GetBSCB(), pvLocal);

        // If we have a node already
        if (pFirstNode)
        {
            if (pNode->GetFlags() & BSCO_ONDATAAVAILABLE)
            {
                // If the new node gets the data, link it first.

                pNode->SetNextNode(pFirstNode);
                _pCBSCNode = pNode;
            }
            else
            {
                // The new node does not get data, link it second in list.

                pNodeTmp = pFirstNode->GetNextNode();

                pFirstNode->SetNextNode(pNode);
                pNode->SetNextNode(pNodeTmp);
            }
        }
        else
        {
            _pCBSCNode = pNode;
        }

        _cElements++;
    }

AddNodeExit:

    PerfDbgLog2(tagCBSCHolder, this, "-CBSCHolder::AddNode (NewNode:%lx, hr:%lx)", pNode, hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::RemoveNode
//
//  Synopsis:
//
//  Arguments:  [pIBSC] --
//
//  Returns:
//
//  History:
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::RemoveNode(IBindStatusCallback *pIBSC)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::RemoveNode",
                "this=%#x, %#x",
                this, pIBSC
                ));
                
    PerfDbgLog1(tagCBSCHolder, this, "+CBSCHolder::RemoveNode (IBSC:%lx)", pIBSC);
    HRESULT hr = E_FAIL;
    CLock lck(_mxs);

    CBSCNode *pNextNode = NULL;
    CBSCNode *pPrevNode = _pCBSCNode;

    // If binding has started, removal of nodes not allowed until binding stops.

    if (_fBindStarted && !_fBindStopped)
    {
        UrlMkAssert((FALSE && "IBSC in use - can not be revoked"));

        goto RemoveNodeExit;
    }

    if (pPrevNode)
    {
        pNextNode = pPrevNode->GetNextNode();
    }
    else
    {
        TransAssert((_cElements == 0));
        hr = S_FALSE;
        goto RemoveNodeExit;
    }

    if (_pCBSCNode->GetBSCB() == pIBSC)
    {
        UrlMkAssert((_pCBSCNode->GetBSCB() == pIBSC));
        if (!_fBindStarted || _pCBSCNode->CheckLocalFlags(NODE_FLAG_REMOVEOK))
        {
            PerfDbgLog2(tagCBSCHolder, this, "CBSCHolder::RemoveNode (Delete Node:%lx, IBSC:%lx)",
                _pCBSCNode, _pCBSCNode->GetBSCB());

            // release all obtained objects in the disdructor
            delete _pCBSCNode;

            _pCBSCNode = pNextNode;
            _cElements--;

            if (_cElements == 0)
            {
                hr = S_FALSE;
            }
            else
            {
                hr = S_OK;
            }
        }
    }
    else while (pNextNode)
    {
        PerfDbgLog2(tagCBSCHolder, this, "CBSCHolder::RemoveNode (pNextNode:%lx, pNextNode->pIBSC:%lx)",pNextNode,pNextNode->GetBSCB());

        if (pNextNode->GetBSCB() == pIBSC && (!_fBindStarted || pNextNode->CheckLocalFlags(NODE_FLAG_REMOVEOK)))
        {
            //we found the Node
            if (pPrevNode)
            {
                pPrevNode->SetNextNode(pNextNode->GetNextNode());
            }

            PerfDbgLog2(tagCBSCHolder, this, "CBSCHolder::RemoveNode (Delete Node:%lx, IBSC:%lx)",
                pNextNode,pNextNode->GetBSCB());

            // release all obtained objects in the disdructor
            delete pNextNode;

            hr = S_OK;
            _cElements--;

            UrlMkAssert((_cElements > 0));

            break;
        }
        else
        {
            pPrevNode = pNextNode;
            pNextNode = pNextNode->GetNextNode();
        }
        UrlMkAssert((hr == S_OK && "Node not found"));
    }

RemoveNodeExit:

    PerfDbgLog1(tagCBSCHolder, this, "-CBSCHolder::RemoveNode (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::SetMainNode
//
//  Synopsis:
//
//  Arguments:  [pIBSC] --
//              [ppIBSCPrev] --
//
//  Returns:
//
//  History:    5-08-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::SetMainNode(IBindStatusCallback *pIBSC, IBindStatusCallback **ppIBSCPrev)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::SetMainNode",
                "this=%#x, %#x, #x",
                this, pIBSC, ppIBSCPrev
                ));
                
    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::SetMainNode");
    HRESULT hr = NOERROR;
    CLock lck(_mxs);

    CBSCNode *pFirstNode = _pCBSCNode;
    CBSCNode *pNode;
    CBSCNode *pNodeTmp;
    LPVOID pvLocal = NULL;

    // No new nodes allowed after binding has started.
    if (_fBindStarted)
    {
        hr = E_FAIL;
        goto GetFirsNodeExit;
    }
    if (pFirstNode)
    {
        IBindStatusCallback *pBSC = pFirstNode->GetBSCB();

        // addref the node here and return it
        if (ppIBSCPrev)
        {
            pBSC->AddRef();
            *ppIBSCPrev = pBSC;
        }

        hr = RemoveNode(pBSC);
    }

    pFirstNode = _pCBSCNode;

    // Allocate memory for new pNode member.
    pNode = new CBSCNode(pIBSC, BSCO_ALLONIBSC);

    if (!pNode)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        // addref the IBSC pointer
        pIBSC->AddRef();
        hr = NOERROR;

        // QI for IServiceProvider - QI addref IBSC
        if (pIBSC->QueryInterface(IID_IServiceProvider, &pvLocal) == NOERROR)
        {
            pNode->SetServiceProvider((IServiceProvider *)pvLocal);
        }

        PerfDbgLog3(tagCBSCHolder, this, "CBSCHolder::SetMainNode (New Node:%lx, IBSC:%lx, IServiceProvider:%lx)",
            pNode, pNode->GetBSCB(), pvLocal);

        // If we have a node already
        if (pFirstNode)
        {
            if (pNode->GetFlags() & BSCO_ONDATAAVAILABLE)
            {
                // If the new node gets the data, link it first.

                pNode->SetNextNode(pFirstNode);
                _pCBSCNode = pNode;
            }
            else
            {
                // The new node does not get data, link it second in list.

                pNodeTmp = pFirstNode->GetNextNode();

                pFirstNode->SetNextNode(pNode);
                pNode->SetNextNode(pNodeTmp);
            }
        }
        else
        {
            _pCBSCNode = pNode;
        }

        _cElements++;
    }
GetFirsNodeExit:

    PerfDbgLog2(tagCBSCHolder, this, "-CBSCHolder::SetMainNode (NewNode:%lx, hr:%lx)", pNode, hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBSCHolder::ObtainService
//
//  Synopsis:   Retrieves the requested service with QI and QueryService
//              for all nodes. The interfaces is addref'd and kept in the node.
//
//  Arguments:  [rsid] --
//              [riid] --
//
//  Returns:
//
//  History:    4-09-96   JohannP (Johann Posch)   Created
//
//  Notes:      The obtained interfaces are released in the disdructor of the
//              CNode.
//
//----------------------------------------------------------------------------
HRESULT CBSCHolder::ObtainService(REFGUID rsid, REFIID riid, void ** ppvObj)
{
    DEBUG_ENTER((DBG_CALLBACK,
                Hresult,
                "CBSCHolder::ObtainService",
                "this=%#x, %#x, #x, %#x",
                this, &rsid, &riid, ppvObj
                ));
                
    PerfDbgLog(tagCBSCHolder, this, "+CBSCHolder::ObtainService");
    HRESULT     hr = NOERROR;
    CBSCNode   *pNode;
    VDATETHIS(this);
    LPVOID pvLocal = NULL;

    pNode = _pCBSCNode;

    // the old code was under the assumption that rsid was always the same
    // as riid. it checked riid when it should have been checking rsid, and it
    // always passed riid on in the place of rsid! All callers that I've
    // seen that use IID_IHttpNegotiate and IID_IAuthenticate pass the
    // same iid in both rsid and riid, so fixing this should be safe.
    if (rsid == IID_IHttpNegotiate)
    {
        *ppvObj = (void*)(IHttpNegotiate *) this;
        AddRef();

        // loop once to get all interfaces
        if (!_fHttpNegotiate)
        {
            while (pNode)
            {
                if (   (pNode->GetBSCB()->QueryInterface(riid, &pvLocal) == NOERROR)
                    || (   pNode->GetServiceProvider()
                        && (pNode->GetHttpNegotiate() == NULL)
                        && (pNode->GetServiceProvider()->QueryService(rsid, riid, &pvLocal)) == NOERROR)
                    )
                {
                    // Note: the interface is addref'd by QI or QS
                    pNode->SetHttpNegotiate((IHttpNegotiate *)pvLocal);
                }

                pNode = pNode->GetNextNode();
            }

            _fHttpNegotiate = TRUE;
        }
    }
    else if (rsid == IID_IAuthenticate)
    {
        *ppvObj = (void*)(IAuthenticate *) this;
        AddRef();

        if (!_fAuthenticate)
        {
            while (pNode)
            {
                if (   (pNode->GetBSCB()->QueryInterface(riid, &pvLocal) == NOERROR)
                    || (   pNode->GetServiceProvider()
                        && (pNode->GetAuthenticate() == NULL)
                        && (pNode->GetServiceProvider()->QueryService(rsid, riid, &pvLocal)) == NOERROR)
                    )
                {
                    // Note: the interface is addref'd by QI or QS
                    pNode->SetAuthenticate((IAuthenticate *)pvLocal);
                }

                pNode = pNode->GetNextNode();
            }

            _fAuthenticate = TRUE;
        }

    }
    else if (rsid == IID_IHttpNegotiate2)
    {
        *ppvObj = (void*)(IHttpNegotiate2 *) this;
        AddRef();

        // loop once to get all interfaces
        if (!_fHttpNegotiate2)
        {
            while (pNode)
            {
                if (   (pNode->GetBSCB()->QueryInterface(riid, &pvLocal) == NOERROR)
                    || (   pNode->GetServiceProvider()
                        && (pNode->GetHttpNegotiate2() == NULL)
                        && (pNode->GetServiceProvider()->QueryService(rsid, riid, &pvLocal)) == NOERROR)
                    )
                {
                    // Note: the interface is addref'd by QI or QS
                    pNode->SetHttpNegotiate2((IHttpNegotiate2 *)pvLocal);
                }

                pNode = pNode->GetNextNode();
            }

            _fHttpNegotiate2 = TRUE;
        }
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;

        while (pNode)
        {
            // old urlmon code did a QueryInterface on this object (CBSCHolder)
            // without regard to rsid. That's QueryService badness, but CINet
            // (and several other places) call QueryService using the same rsid/riid
            // (in this case IID_IHttpSecurity) and *expect* the below QI to pick
            // the interface off the BSCB. We should create an URLMON service id
            // that means "ask the BSCB for this interface" and use that...
            if (    (pNode->GetBSCB()->QueryInterface(riid, &pvLocal) == NOERROR)
                 || (pNode->GetServiceProvider()
                 && (pNode->GetServiceProvider()->QueryService(rsid, riid, &pvLocal)) == NOERROR)
                )
            {
                *ppvObj = pvLocal;
                hr = NOERROR;
                // Note: the interface is addref'd by QI or QS
                // stop looking at other nodes for this service
                pNode = NULL;
            }

            if (pNode)
            {
                pNode = pNode->GetNextNode();
            }
        }
    }

    PerfDbgLog1(tagCBSCHolder, this, "-CBSCHolder::ObtainService (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\mon\urlcf.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       urlcf.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <mon.h>
#include <eapp.h>
#include "urlcf.hxx"
#ifndef unix
#include "..\eapp\protbase.hxx"
#include "..\trans\urlmk.hxx"
#include "..\trans\bindctx.hxx"
#include "..\trans\oinet.hxx"
#include "..\download\cdl.h"
#else
#include "../eapp/protbase.hxx"
#include "../trans/urlmk.hxx"
#include "../trans/bindctx.hxx"
#include "../trans/oinet.hxx"
#include "../download/cdl.h"
#endif /* unix */

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::Create
//
//  Synopsis:
//
//  Arguments:  [clsid] --
//              [ppCF] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CUrlClsFact::Create(REFCLSID clsid, CUrlClsFact **ppCF)
{
    UrlMkDebugOut((DEB_URLMON, "NULL _IN CUrlClsFact::Create\n"));
    HRESULT hr = NOERROR;
    CUrlClsFact * pCF =  NULL;

    DWORD dwId = IsKnownOInetProtocolClass( (CLSID*)&clsid );

    if (   (dwId != DLD_PROTOCOL_NONE)
        || (clsid == CLSID_StdURLMoniker)
        || (clsid == CLSID_UrlMkBindCtx)
        || (clsid == CLSID_StdURLProtocol)
        || (clsid == CLSID_SoftDistExt)
        || (clsid == CLSID_DeCompMimeFilter)
        || (clsid == CLSID_StdEncodingFilterFac)
        || (clsid == CLSID_ClassInstallFilter)
        || (clsid == CLSID_CdlProtocol)
        || (clsid == CLSID_InternetSecurityManager)
        || (clsid == CLSID_InternetZoneManager)
       )
    {
        pCF = (CUrlClsFact *) new CUrlClsFact(clsid, dwId);
    }

    if (pCF == NULL)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        *ppCF = pCF;
    }

    UrlMkDebugOut((DEB_URLMON, "%p OUT CUrlClsFact::Create (hr:%lx\n", pCF,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::CUrlClsFact
//
//  Synopsis:   constructor
//
//  Arguments:  [clsid] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:      we need to keep a refcount on the dll if for each object given to
//              outside, including ClassFactories.
//              The corresponding DllRelease is in the destructor
//
//----------------------------------------------------------------------------
CUrlClsFact::CUrlClsFact(REFCLSID clsid, DWORD dwId) : _CRefs(), _CLocks(0)
{
    _ClsID =  clsid;
    _dwId = dwId;

    DllAddRef();
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::~CUrlClsFact
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CUrlClsFact::~CUrlClsFact()
{
    DllRelease();
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::CreateInstance
//
//  Synopsis:   creates an instance of an Explode Object
//
//  Arguments:  [pUnkOuter] -- controlling unknown (must be NULL)
//              [riid] --      id of desired interface
//              [ppv] --       pointer to receive the interface
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:      S_OK - success
//              CLASS_E_NOAGGREATION - the caller tried to aggregate
//              CLASS_E_CLASSNOTAVAILABLE - couldn't initialize the class
//              E_OUTOFMEMORY - not enough memory to instantiate class
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlClsFact::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppv)
{
    //UrlMkDebugOut((DEB_URLMON, "%p _IN CUrlClsFact::CreateInstance\n", this));
    HRESULT hr = NOERROR;
    // Class factory init time, the pointer to the creation function of
    // the object is given.  Use that to create the object

    //DumpIID(riid);
    //DumpIID(_rClsID);

    if (riid == IID_IClassFactory)
    {
        *ppv = (IClassFactory *)this;
        AddRef();
    }
    else if (_dwId != DLD_PROTOCOL_NONE)
    {
        hr = CreateKnownProtocolInstance(_dwId, _ClsID, pUnkOuter, riid, (IUnknown **)ppv);
    }
    else if (_ClsID == CLSID_StdURLMoniker)
    {
        CUrlMon * pMnk = NULL;
        LPWSTR szUrl = NULL;

        if ((pMnk = new CUrlMon(szUrl)) != NULL)
        {
            hr = pMnk->QueryInterface(riid, ppv);
            pMnk->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

    }
    else if (_ClsID == CLSID_UrlMkBindCtx)
    {
        CBindCtx *pCBCtx = NULL;

        hr = CBindCtx::Create(&pCBCtx);

        if (hr == NOERROR)
        {
            TransAssert((pCBCtx));
            hr = pCBCtx->QueryInterface(riid, ppv);
            pCBCtx->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

    }
    else if (_ClsID == CLSID_StdURLProtocol)
    {
        // BUGBUG: add protocol here

    }
    else if (_ClsID == CLSID_InternetSecurityManager)
    {
        hr = InternetCreateSecurityManager(pUnkOuter, riid, ppv, 0);
    }
    else if (_ClsID == CLSID_InternetZoneManager)
    {
        hr = InternetCreateZoneManager(pUnkOuter, riid, ppv, 0);
    }
    else if (_ClsID == CLSID_SoftDistExt)
    {
        CSoftDist * pSoftDist = NULL;

        if ((pSoftDist = new CSoftDist()) != NULL)
        {
            hr = pSoftDist->QueryInterface(riid, ppv);
            pSoftDist->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

    }
    else if( _ClsID == CLSID_DeCompMimeFilter)
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
        if( pUnkOuter)
            hr = CLASS_E_NOAGGREGATION;
        else
        {
            CMimeFt*    pMft = NULL;
            hr = CMimeFt::Create(&pMft);
            if( (hr == NOERROR) && pMft )
            {
                hr = pMft->QueryInterface(riid, ppv);
                pMft->Release();
            }
        }
    }
    else if( _ClsID == CLSID_StdEncodingFilterFac)
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
        if( pUnkOuter)
            hr = CLASS_E_NOAGGREGATION;
        else
        {
            *ppv = NULL;
            *ppv = new CEncodingFilterFactory;
            if( *ppv == NULL )
                hr = E_OUTOFMEMORY;
            else
                hr = ((IEncodingFilterFactory*)(*ppv))->AddRef();                
        }
    
    }
    else if( _ClsID == CLSID_ClassInstallFilter)
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
        if (pUnkOuter)
            hr = CLASS_E_NOAGGREGATION;
        else
        {
            CClassInstallFilter *pCIF = NULL;
            pCIF = new CClassInstallFilter();
            *ppv = (LPVOID)(IOInetProtocol *)pCIF;
            if (!*ppv)
                hr = E_OUTOFMEMORY;
            else
                hr = S_OK;
        }
    }
    else if (_ClsID == CLSID_CdlProtocol)
    {
        hr = CreateAPP(_ClsID, pUnkOuter, riid, (IUnknown **)ppv);
    }

    UrlMkDebugOut((DEB_URLMON, "%p OUT CUrlClsFact::CreateInstance (hr:%lx)\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::LockServer
//
//  Synopsis:   locks the server, preventing it from being unloaded
//
//  Arguments:  [fLock] -- TRUE to lock, FALSE to unlock
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlClsFact::LockServer(BOOL fLock)
{
    UrlMkDebugOut((DEB_URLMON, "%p _IN CUrlClsFact::LockServer\n", this));
    HRESULT hr = NOERROR;
    if (fLock)
    {
        if (++_CLocks == 1)
        {
            DllAddRef();
        }
    }
    else
    {
        UrlMkAssert((_CLocks > 0));
        if (_CLocks > 0)
        {
            if (--_CLocks == 0)
            {
                DllRelease();
            }
        }
    }

    UrlMkDebugOut((DEB_URLMON, "%p OUT CUrlClsFact::LockServer (hr:%lx)\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlClsFact::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    HRESULT hr = NOERROR;
    UrlMkDebugOut((DEB_URLMON, "%p _IN CUrlClsFact::QueryInterface\n", this));

    if (   riid == IID_IUnknown
        || riid == IID_IClassFactory)
    {
        *ppvObj = this;
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }
    if (hr == NOERROR)
    {
        AddRef();
    }

    UrlMkDebugOut((DEB_URLMON, "%p OUT CUrlClsFact::QueryInterface (hr:%lx\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CUrlClsFact::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CUrlClsFact::AddRef(void)
{
    UrlMkDebugOut((DEB_URLMON, "%p _IN CUrlClsFact::AddRef\n", this));

    LONG lRet = ++_CRefs;

    UrlMkDebugOut((DEB_URLMON, "%p OUT CUrlClsFact::AddRef (cRefs:%ld)\n", this,lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CUrlClsFact::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CUrlClsFact::Release(void)
{
    UrlMkDebugOut((DEB_URLMON, "%p _IN CUrlClsFact::Release\n", this));

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        delete this;
    }

    UrlMkDebugOut((DEB_URLMON, "%p OUT CUrlClsFact::Release (cRefs:%ld)\n", this,lRet));
    return lRet;
}

#if DBG==1
HRESULT DumpIID(REFIID riid)
{

    HRESULT hr;
    LPOLESTR pszStr = NULL;
    hr = StringFromCLSID(riid, &pszStr);
    UrlMkDebugOut((DEB_BINDING, "API >>> DumpIID (riid:%ws) \n", pszStr));

    if (pszStr)
    {
        delete pszStr;
    }
    return hr;
}
#endif


#ifdef FOR_SHDOCVW
//+---------------------------------------------------------------------------
//
//  Function:   GetObjectOffFileMoniker
//
//  Synopsis:   tries to create on object using a file moniker
//              this is a work around for OLE
//
//  Arguments:  [pMnk] --
//              [REFIID] --
//              [riid] --
//              [ppv] --
//
//  Returns:
//
//  History:    3-10-96   JohannP (Johann Posch)   Created
//
//  Notes:      See comments inside function
//
//----------------------------------------------------------------------------
HRESULT GetObjectOffFileMoniker(IMoniker *pMnk, IBindCtx *pbc,REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    DWORD dwMnk;
    LPWSTR      wzFilename = NULL;
    CLSID       * pClsID = NULL;
    IUnknown    * pUnk = NULL;
    IPersistFile *pPersistFile = NULL;
    BIND_OPTS     bindopts;

    bindopts.cbStruct = sizeof(BIND_OPTS);
    hr = pbc->GetBindOptions(&bindopts);


    pMnk->IsSystemMoniker(&dwMnk);

    if (dwMnk != MKSYS_FILEMONIKER)
    {
        goto Done;
    }

    //get path and filename
    hr = pMnk->GetDisplayName(NULL, NULL, &wzFilename);
    if (wzFilename == NULL)
    {
        goto Done;
    }

    // try to find class
    hr = GetClassFile(wzFilename, pClsID);
    if (hr != NOERROR)
    {
        goto Done;
    }

    // create object
    hr = CoCreateInstance(*pClsID, NULL, CLSCTX_INPROC_SERVER |CLSCTX_LOCAL_SERVER,
                            riid, (void**)&pUnk);

    if (hr != NOERROR)
    {
        goto Done;
    }

    // ask for the IPersistFile interface
    hr = pUnk->QueryInterface(IID_IPersistFile, (void**)&pPersistFile);
    if (hr != NOERROR)
    {
        goto Done;
    }
    // load the object
    hr = pPersistFile->Load(wzFilename, bindopts.grfMode);

Done:
    if (hr != NOERROR)
    {
        if (pUnk)
        {
            pUnk->Release();
        }
    }
    else
    {
        *ppv = (void *)pUnk;
    }

    if (pPersistFile)
    {
        pPersistFile->Release();
    }
    if (pClsID)
    {
        delete pClsID;
    }
    if (wzFilename)
    {
        delete wzFilename;
    }

    return hr;
}
#endif //FOR_SHDOCVW
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\mon\urldll.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       urldll.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-25-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <mon.h>
#include "urlcf.hxx"
#include "selfreg.hxx"
#include <delaydll.h>
#include <tls.h>
#include <commctrl.h>
#include <shfusion.h>

#define MLUI_INIT
#include "mluisupp.h"

#ifdef _SBS_
#include "sbsclsid.hxx"
#else
#include "clsid.hxx"
#endif //_SBS_

//
// Downlevel delay load support (we forward to shlwapi)
//
#include <delayimp.h>

PfnDliHook __pfnDliFailureHook;

#ifdef unix
#define DllMain DllMainInternal
#endif /* unix */

COleAutDll  g_OleAutDll;

PerfDbgTag(tagUrlDll, "Urlmon", "Log DllMain", DEB_URLMON);

DECLARE_INFOLEVEL(UrlMk)
DECLARE_INFOLEVEL(Trans)
DECLARE_INFOLEVEL(PProt)
DECLARE_INFOLEVEL(Notf)
DECLARE_INFOLEVEL(EProt)
DECLARE_INFOLEVEL(TNotf)

extern HINSTANCE g_hInst;
extern HMODULE   g_hLibPluginOcx;
extern HMODULE   g_hLibMlang;
extern ULONG     Win4AssertLevel;
extern IEnumFORMATETC *g_pEFmtETC;

DWORD g_dwSettings = 0;
BOOL  g_bCanUseSimpleBinding = TRUE;
BOOL  CanUseSimpleBinding();
BOOL  g_bHasMimeHandlerForTextHtml = TRUE;
LONG  g_cTransLevelHandler = 0;
BOOL  g_bGlobalUTF8Enabled = FALSE;
BOOL  g_bGlobalUTF8hackEnabled = TRUE;
BOOL  GlobalUTF8Enabled();
BOOL  GlobalUTF8hackEnabled();
BOOL  g_bNT5OrGreater = FALSE;

URLMON_TS* g_pHeadURLMONTSList; 
HRESULT    CleanupTSOnProcessDetach();
BOOL  g_bUseImprovedZoneCheck;
BOOL  CanUseImprovedZoneCheck();


// defined in calldatax.c
EXTERN_C HRESULT PrxDllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv);
EXTERN_C HRESULT PrxDllRegisterServer();
EXTERN_C HRESULT PrxDllUnregisterServer();
EXTERN_C HRESULT PrxDllMain(HINSTANCE hInstance,DWORD dwReason,LPVOID lpvReserved);

// defined in zoneutil.c
EXTERN_C HRESULT ZonesDllInstall(BOOL bInstall, LPCWSTR pwStr);

// global variables
CRefCount g_cRef(0);        // global dll refcount
CMutexSem g_mxsMedia;       // single access to media holder

LPSTR g_pszUserAgentString = NULL;  // Per-process configurable User Agent string
IInternetSecurityManager *g_pSecurityManager = NULL; 
LPSTR g_pszUAInfoString = NULL;
LPSTR GetUAInfoString(void);


STDAPI_(BOOL) TlsDllMain(HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved);


#define STDCOURIER_CLSID                        "{c733e4af-576e-11d0-b28c-00c04fd7cd22}"
#define STDCOURIER_CLSID_REGKEY                 "CLSID\\"STDCOURIER_CLSID
#define STDCOURIER_CLSID_REGKEY                 "CLSID\\"STDCOURIER_CLSID
#define STDCOURIER_DESCRIP                      "Thread NotificationMgr"

const REGENTRY rgStdNotificationMgr[] =
{
    //***** STDCOURIER ENTRIES *****
    STD_ENTRY(STDCOURIER_CLSID_REGKEY, STDCOURIER_DESCRIP),
    STD_ENTRY(STDCOURIER_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, STDCOURIER_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};


///* Registration of urlmon class
// HKEY_CLASSES_ROOT
const REGENTRY rgClassesRoot[] =
{
    //***** URLMONIKER ENTRIES *****
    STD_ENTRY(URLMONIKER_CLSID_REGKEY, URLMONIKER_DESCRIP),
    STD_ENTRY(URLMONIKER_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, URLMONIKER_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

const REGENTRY rgClassesSoftDist[] =
{
    //***** SOFTDIST ENTRIES *****
    STD_ENTRY(SOFTDIST_CLSID_REGKEY, SOFTDIST_DESCRIP),
    STD_ENTRY(SOFTDIST_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, SOFTDIST_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

const REGENTRY rgClassesSecMgr[] =
{
    //***** SECMGR ENTRIES *****
    STD_ENTRY(SECMGR_CLSID_REGKEY, SECMGR_DESCRIP),
    STD_ENTRY(SECMGR_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, SECMGR_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Both" },
};

const REGENTRY rgClassesZoneMgr[] =
{
    //***** ZONEMGR ENTRIES *****
    STD_ENTRY(ZONEMGR_CLSID_REGKEY, ZONEMGR_DESCRIP),
    STD_ENTRY(ZONEMGR_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, ZONEMGR_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Both" },
};

const REGENTRY rgClassesBindCtx[] =
{
    //***** URLBINDCTX ENTRIES *****
    STD_ENTRY(URLBINDCTX_CLSID_REGKEY, URLBINDCTX_DESCRIP),
    STD_ENTRY(URLBINDCTX_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, URLBINDCTX_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

// Registration of proxy/stub class id
const REGENTRY rgPSFactory[] =
{
    //***** URLMONIKER PS ENTRIES *****
    STD_ENTRY(URLMONIKER_PS_CLSID_REGKEY, URLMONIKER_PS_DESCRIP),
    STD_ENTRY(URLMONIKER_PS_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, URLMONIKER_PS_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

// protocols
const REGENTRY rgClassesHttp[] =
{
    //***** PROTOCOL_HTTP ENTRIES *****
    STD_ENTRY(PROTOCOL_HTTP_CLSID_REGKEY, PROTOCOL_HTTP_DESCRIP),
    STD_ENTRY(PROTOCOL_HTTP_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, PROTOCOL_HTTP_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};
const REGENTRY rgClassesFtp[] =
{
    //***** PROTOCOL_FTP ENTRIES *****
    STD_ENTRY(PROTOCOL_FTP_CLSID_REGKEY, PROTOCOL_FTP_DESCRIP),
    STD_ENTRY(PROTOCOL_FTP_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, PROTOCOL_FTP_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

const REGENTRY rgClassesGopher[] =
{
    //***** PROTOCOL_GOPHER ENTRIES *****
    STD_ENTRY(PROTOCOL_GOPHER_CLSID_REGKEY, PROTOCOL_GOPHER_DESCRIP),
    STD_ENTRY(PROTOCOL_GOPHER_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, PROTOCOL_GOPHER_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

const REGENTRY rgClassesHttpS[] =
{
    //***** PROTOCOL_HTTPS ENTRIES *****
    STD_ENTRY(PROTOCOL_HTTPS_CLSID_REGKEY, PROTOCOL_HTTPS_DESCRIP),
    STD_ENTRY(PROTOCOL_HTTPS_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, PROTOCOL_HTTPS_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

const REGENTRY rgClassesMk[] =
{
    //***** PROTOCOL_MK ENTRIES *****
    STD_ENTRY(PROTOCOL_MK_CLSID_REGKEY, PROTOCOL_MK_DESCRIP),
    STD_ENTRY(PROTOCOL_MK_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, PROTOCOL_MK_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

const REGENTRY rgClassesFile[] =
{
    //***** PROTOCOL_FILE ENTRIES *****
    STD_ENTRY(PROTOCOL_FILE_CLSID_REGKEY, PROTOCOL_FILE_DESCRIP),
    STD_ENTRY(PROTOCOL_FILE_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, PROTOCOL_FILE_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};



#define HANDLER_HTTP        SZPROTOCOLROOT"http"
#define HANDLER_FTP         SZPROTOCOLROOT"ftp"
#define HANDLER_GOPHER      SZPROTOCOLROOT"gopher"
#define HANDLER_HTTPS       SZPROTOCOLROOT"https"
#define HANDLER_MK          SZPROTOCOLROOT"mk"
#define HANDLER_FILE        SZPROTOCOLROOT"file"
#define HANDLER_LOCAL       SZPROTOCOLROOT"local"


//const REGENTRY rgHandler[] = { STD_ENTRY(HANDLER_HTTP, PROTOCOL_HTTP_DESCRIP), { KEYTYPE_STRING, HANDLER_HTTP, "CLSID", REG_SZ, (BYTE*)PROTOCOL_HTTP_CLSID } };
const REGENTRY rgHandlerHttp   [] = { STD_ENTRY(HANDLER_HTTP  , PROTOCOL_HTTP_DESCRIP  ), { KEYTYPE_STRING, HANDLER_HTTP  , "CLSID", REG_SZ, (BYTE*)PROTOCOL_HTTP_CLSID   } };
const REGENTRY rgHandlerFtp    [] = { STD_ENTRY(HANDLER_FTP   , PROTOCOL_FTP_DESCRIP   ), { KEYTYPE_STRING, HANDLER_FTP   , "CLSID", REG_SZ, (BYTE*)PROTOCOL_FTP_CLSID    } };
const REGENTRY rgHandlerGopher [] = { STD_ENTRY(HANDLER_GOPHER, PROTOCOL_GOPHER_DESCRIP), { KEYTYPE_STRING, HANDLER_GOPHER, "CLSID", REG_SZ, (BYTE*)PROTOCOL_GOPHER_CLSID } };
const REGENTRY rgHandlerHttpS  [] = { STD_ENTRY(HANDLER_HTTPS , PROTOCOL_HTTPS_DESCRIP ), { KEYTYPE_STRING, HANDLER_HTTPS , "CLSID", REG_SZ, (BYTE*)PROTOCOL_HTTPS_CLSID  } };
const REGENTRY rgHandlerMk     [] = { STD_ENTRY(HANDLER_MK    , PROTOCOL_MK_DESCRIP    ), { KEYTYPE_STRING, HANDLER_MK    , "CLSID", REG_SZ, (BYTE*)PROTOCOL_MK_CLSID     } };
const REGENTRY rgHandlerFile   [] = { STD_ENTRY(HANDLER_FILE  , PROTOCOL_FILE_DESCRIP  ), { KEYTYPE_STRING, HANDLER_FILE  , "CLSID", REG_SZ, (BYTE*)PROTOCOL_FILE_CLSID   } };
const REGENTRY rgHandlerLocal  [] = { STD_ENTRY(HANDLER_LOCAL , PROTOCOL_FILE_DESCRIP  ), { KEYTYPE_STRING, HANDLER_LOCAL , "CLSID", REG_SZ, (BYTE*)PROTOCOL_FILE_CLSID   } };


// From PlugProt.dll (merge)
#define SZFILTERROOT        "PROTOCOLS\\Filter\\"
#define SZPROTOCOLROOT      "PROTOCOLS\\Handler\\"
#define SZCLASS             "CLSID"
#define SZHANDLER           "HANDLER"

EXTERN_C const GUID CLSID_StdEncodingFilterFac;  
EXTERN_C const GUID CLSID_DeCompMimeFilter;    
EXTERN_C const GUID CLSID_CdlProtocol;   
EXTERN_C const GUID CLSID_ClassInstallFilter; 

//*************************** Registry keys for CDL protocol handler


const REGENTRY rgHandlerCdl[] = 
{ 
    STD_ENTRY(HANDLER_CDL  , PROTOCOL_CDL_DESCRIP  ), 
        { KEYTYPE_STRING, HANDLER_CDL  , "CLSID", REG_SZ, (BYTE*)PROTOCOL_CDL_CLSID   } 
};

const REGENTRY rgClassesCdl[] =
{
    STD_ENTRY(PROTOCOL_CDL_CLSID_REGKEY, PROTOCOL_CDL_DESCRIP),
    STD_ENTRY(PROTOCOL_CDL_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, PROTOCOL_CDL_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

//*************************** Registry keys for Class Install Handler protocol filter


const REGENTRY rgClassesMimeInstallHandler[] =
{
    STD_ENTRY(PROT_FILTER_CLASS_CLSID_REGKEY, PROT_FILTER_CLASS_DESCRIP),
    STD_ENTRY(PROT_FILTER_CLASS_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, PROT_FILTER_CLASS_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

const REGENTRY rgMimeInstallHandler[] = 
{ 
    STD_ENTRY(PROT_FILTER_CLASS , PROT_FILTER_CLASS_DESCRIP  ), 
        { KEYTYPE_STRING, PROT_FILTER_CLASS, "CLSID", REG_SZ, (BYTE*)PROT_FILTER_CLASS_CLSID   } 
};

//*************************** Registry keys for ENC & Deflate protocol filters


const REGENTRY rgClassesMimeHandlerEnc[] =
{
    STD_ENTRY(PROT_FILTER_ENC_CLSID_REGKEY, PROT_FILTER_ENC_DESCRIP),
    STD_ENTRY(PROT_FILTER_ENC_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, PROT_FILTER_ENC_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};

const REGENTRY rgMimeHandlerEnc  [] = 
{ 
    STD_ENTRY(PROT_FILTER_ENC , PROT_FILTER_ENC_DESCRIP  ), 
    { KEYTYPE_STRING, PROT_FILTER_ENC , "CLSID", REG_SZ, (BYTE*)PROT_FILTER_ENC_CLSID   } 
};


const REGENTRY rgDeflateEnc  [] = 
{ 
    STD_ENTRY(PROT_FILTER_DEFLATE , PROT_FILTER_DEFLATE_DESCRIP  ), 
    { KEYTYPE_STRING, PROT_FILTER_DEFLATE , "CLSID", REG_SZ, (BYTE*)PROT_FILTER_DEFLATE_CLSID   } 
};


const REGENTRY rgGZIPEnc  [] = 
{ 
    STD_ENTRY(PROT_FILTER_GZIP , PROT_FILTER_GZIP_DESCRIP  ), 
    { KEYTYPE_STRING, PROT_FILTER_GZIP , "CLSID", REG_SZ, (BYTE*)PROT_FILTER_GZIP_CLSID   } 
};

const REGENTRY rgClassesStdEncFac[] =
{
    STD_ENTRY(STD_ENC_FAC_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, STD_ENC_FAC_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};


const REGENTRYGROUP rgRegEntryGroups[] = {
    { HKEY_CLASSES_ROOT, rgStdNotificationMgr,      ARRAYSIZE(rgStdNotificationMgr) },
    { HKEY_CLASSES_ROOT, rgClassesRoot,     ARRAYSIZE(rgClassesRoot) },
    { HKEY_CLASSES_ROOT, rgClassesSoftDist,  ARRAYSIZE(rgClassesSoftDist) },
    { HKEY_CLASSES_ROOT, rgClassesSecMgr,   ARRAYSIZE(rgClassesSecMgr) },
    { HKEY_CLASSES_ROOT, rgClassesZoneMgr,   ARRAYSIZE(rgClassesZoneMgr) },
    { HKEY_CLASSES_ROOT, rgClassesBindCtx,  ARRAYSIZE(rgClassesBindCtx) },
    { HKEY_CLASSES_ROOT, rgPSFactory,       ARRAYSIZE(rgPSFactory) },
    { HKEY_CLASSES_ROOT, rgClassesHttp,     ARRAYSIZE(rgClassesHttp) },
    { HKEY_CLASSES_ROOT, rgClassesFtp,      ARRAYSIZE(rgClassesFtp) },
    { HKEY_CLASSES_ROOT, rgClassesGopher,   ARRAYSIZE(rgClassesGopher) },
    { HKEY_CLASSES_ROOT, rgClassesHttpS,    ARRAYSIZE(rgClassesHttpS) },
    { HKEY_CLASSES_ROOT, rgClassesMk,       ARRAYSIZE(rgClassesMk) },
    { HKEY_CLASSES_ROOT, rgClassesFile,     ARRAYSIZE(rgClassesFile) },

    { HKEY_CLASSES_ROOT, rgHandlerHttp  ,   ARRAYSIZE(rgHandlerHttp  ) },
    { HKEY_CLASSES_ROOT, rgHandlerFtp   ,   ARRAYSIZE(rgHandlerFtp   ) },
    { HKEY_CLASSES_ROOT, rgHandlerGopher,   ARRAYSIZE(rgHandlerGopher) },
    { HKEY_CLASSES_ROOT, rgHandlerHttpS ,   ARRAYSIZE(rgHandlerHttpS ) },
    { HKEY_CLASSES_ROOT, rgHandlerMk    ,   ARRAYSIZE(rgHandlerMk    ) },
    { HKEY_CLASSES_ROOT, rgHandlerFile  ,   ARRAYSIZE(rgHandlerFile  ) },
    { HKEY_CLASSES_ROOT, rgHandlerLocal ,   ARRAYSIZE(rgHandlerLocal ) },
    { HKEY_CLASSES_ROOT, rgMimeHandlerEnc,        ARRAYSIZE(rgMimeHandlerEnc) },
    { HKEY_CLASSES_ROOT, rgClassesMimeHandlerEnc, ARRAYSIZE(rgClassesMimeHandlerEnc) },

    { HKEY_CLASSES_ROOT, rgDeflateEnc,        ARRAYSIZE(rgDeflateEnc) },
    { HKEY_CLASSES_ROOT, rgGZIPEnc,  ARRAYSIZE(rgGZIPEnc) },
    { HKEY_CLASSES_ROOT, rgClassesStdEncFac,  ARRAYSIZE(rgClassesStdEncFac) },
    
    { HKEY_CLASSES_ROOT, rgClassesMimeInstallHandler,      ARRAYSIZE(rgClassesMimeInstallHandler) },
    { HKEY_CLASSES_ROOT, rgMimeInstallHandler,             ARRAYSIZE(rgMimeInstallHandler) },

    { HKEY_CLASSES_ROOT, rgClassesCdl,      ARRAYSIZE(rgClassesCdl) },
    { HKEY_CLASSES_ROOT, rgHandlerCdl  ,    ARRAYSIZE(rgHandlerCdl) },
#ifdef TEST_JOHANNP
#if DBG==1
    { HKEY_CLASSES_ROOT, rgNameSpaceTest1 ,   ARRAYSIZE(rgNameSpaceTest1 ) },
    { HKEY_CLASSES_ROOT, rgNameSpaceTest2 ,   ARRAYSIZE(rgNameSpaceTest2 ) },
#endif // DBG
#endif //TEST_JOHANNP
    { NULL, NULL, 0 }       // terminator
};


const REGENTRYGROUP rgRegEntryGroupsDel[] = {
    { HKEY_CLASSES_ROOT, rgStdNotificationMgr,      ARRAYSIZE(rgStdNotificationMgr) },
    { HKEY_CLASSES_ROOT, rgClassesRoot,     ARRAYSIZE(rgClassesRoot) },
    { HKEY_CLASSES_ROOT, rgClassesSoftDist,  ARRAYSIZE(rgClassesSoftDist) },
    { HKEY_CLASSES_ROOT, rgClassesSecMgr,   ARRAYSIZE(rgClassesSecMgr) },
    { HKEY_CLASSES_ROOT, rgClassesZoneMgr,   ARRAYSIZE(rgClassesZoneMgr) },
    { HKEY_CLASSES_ROOT, rgClassesBindCtx,  ARRAYSIZE(rgClassesBindCtx) },
    { HKEY_CLASSES_ROOT, rgPSFactory,       ARRAYSIZE(rgPSFactory) },
    { HKEY_CLASSES_ROOT, rgClassesHttp,     ARRAYSIZE(rgClassesHttp) },
    { HKEY_CLASSES_ROOT, rgClassesFtp,      ARRAYSIZE(rgClassesFtp) },
    { HKEY_CLASSES_ROOT, rgClassesGopher,   ARRAYSIZE(rgClassesGopher) },
    { HKEY_CLASSES_ROOT, rgClassesHttpS,    ARRAYSIZE(rgClassesHttpS) },
    { HKEY_CLASSES_ROOT, rgClassesMk,       ARRAYSIZE(rgClassesMk) },
    { HKEY_CLASSES_ROOT, rgClassesFile,     ARRAYSIZE(rgClassesFile) },

    { HKEY_CLASSES_ROOT, rgHandlerFtp   ,   ARRAYSIZE(rgHandlerFtp   ) },
    { HKEY_CLASSES_ROOT, rgHandlerGopher,   ARRAYSIZE(rgHandlerGopher) },
    { HKEY_CLASSES_ROOT, rgHandlerMk    ,   ARRAYSIZE(rgHandlerMk    ) },
    { HKEY_CLASSES_ROOT, rgHandlerFile  ,   ARRAYSIZE(rgHandlerFile  ) },
    { HKEY_CLASSES_ROOT, rgHandlerLocal ,   ARRAYSIZE(rgHandlerLocal ) },
    { HKEY_CLASSES_ROOT, rgMimeHandlerEnc,        ARRAYSIZE(rgMimeHandlerEnc) },
    { HKEY_CLASSES_ROOT, rgClassesMimeHandlerEnc, ARRAYSIZE(rgClassesMimeHandlerEnc) },

    { HKEY_CLASSES_ROOT, rgDeflateEnc,        ARRAYSIZE(rgDeflateEnc) },
    { HKEY_CLASSES_ROOT, rgGZIPEnc,  ARRAYSIZE(rgGZIPEnc) },
    { HKEY_CLASSES_ROOT, rgClassesStdEncFac,  ARRAYSIZE(rgClassesStdEncFac) },
    
    { HKEY_CLASSES_ROOT, rgClassesMimeInstallHandler,      ARRAYSIZE(rgClassesMimeInstallHandler) },
    { HKEY_CLASSES_ROOT, rgMimeInstallHandler,             ARRAYSIZE(rgMimeInstallHandler) },

    { HKEY_CLASSES_ROOT, rgClassesCdl,      ARRAYSIZE(rgClassesCdl) },
    { HKEY_CLASSES_ROOT, rgHandlerCdl  ,    ARRAYSIZE(rgHandlerCdl) },
#ifdef TEST_JOHANNP
#if DBG==1
    { HKEY_CLASSES_ROOT, rgNameSpaceTest1 ,   ARRAYSIZE(rgNameSpaceTest1 ) },
    { HKEY_CLASSES_ROOT, rgNameSpaceTest2 ,   ARRAYSIZE(rgNameSpaceTest2 ) },
#endif // DBG
#endif //TEST_JOHANNP
    { NULL, NULL, 0 }       // terminator
};


//+---------------------------------------------------------------------------
//
//  Function:   DllAddRef
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    12-10-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void DllAddRef(void)
{
    g_cRef++;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllRelease
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    12-10-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void DllRelease(void)
{
    UrlMkAssert((g_cRef > 0));
    if (g_cRef > 0)
    {
        g_cRef--;
    }
}

//+---------------------------------------------------------------------------
//
//  Operator:   new
//
//  Synopsis:
//
//  Arguments:  [size] --
//
//  Returns:
//
//  History:    12-10-95   JohannP (Johann Posch)   Created
//
//  Notes:      BUBUG: get and use IMalloc
//
//----------------------------------------------------------------------------
void * _cdecl operator new(size_t size)
{
    void * pBuffer;
    pBuffer = CoTaskMemAlloc(size);
    if (pBuffer)
    {
        memset(pBuffer,0, size);
    }
    return pBuffer;
}

void * _cdecl operator new(size_t sizeEl, ULONG cEl)
{
    void * pBuffer;
    size_t size = sizeEl * cEl;
    pBuffer = CoTaskMemAlloc(size);
    if (pBuffer)
    {
        memset(pBuffer,0, size);
    }
    return pBuffer;
}


//+---------------------------------------------------------------------------
//
//  Operator:   delete
//
//  Synopsis:
//
//  Arguments:  [lpv] --
//
//  Returns:
//
//  History:    2-14-96   JohannP (Johann Posch)   Created
//
//  Notes:      BUBUG: get and use IMalloc
//
//----------------------------------------------------------------------------
void _cdecl operator delete(void *lpv)
{
    //UrlMkAssert((lpv != NULL));
    if (lpv == NULL)
    {
        return;
    }

    CoTaskMemFree(lpv);
}

#ifdef UNUSED
//
int _cdecl _purecall( void )
{
    UrlMkAssert(FALSE);
    return 0;
}

#endif //UNUSED

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Dll entry point
//
//  Arguments:  [clsid] - class id for new class
//              [iid] - interface required of class
//              [ppv] - where to put new interface
//
//  Returns:    S_OK - class object created successfully created.
//
//
//--------------------------------------------------------------------------
STDAPI DllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv)
{
    UrlMkDebugOut((DEB_URLMON, "API _IN DllGetClassObject\n"));

    HRESULT hr = E_NOTIMPL;

    if (   (clsid == CLSID_StdURLMoniker)
        || (clsid == CLSID_UrlMkBindCtx)
        || (clsid == CLSID_HttpSProtocol )
        || (clsid == CLSID_HttpProtocol  )
        || (clsid == CLSID_FtpProtocol   )
        || (clsid == CLSID_GopherProtocol)
        || (clsid == CLSID_FileProtocol  )
        || (clsid == CLSID_MkProtocol    )
        || (clsid == CLSID_SoftDistExt    )
        || (clsid == CLSID_InternetSecurityManager     )
        || (clsid == CLSID_InternetZoneManager    )
        || (clsid == CLSID_DeCompMimeFilter)
        || (clsid == CLSID_StdEncodingFilterFac)
        || (clsid == CLSID_CdlProtocol)
        || (clsid == CLSID_ClassInstallFilter) 
       )
    {
        CUrlClsFact *pCF = NULL;
        hr = CUrlClsFact::Create(clsid, &pCF);
        if (hr == NOERROR)
        {
            UrlMkAssert((pCF != NULL));
            hr = pCF->QueryInterface(iid, ppv);
            pCF->Release();
        }
    }
    else
    {
        hr = PrxDllGetClassObject(clsid, iid, ppv);
    }

    DumpIID(clsid);

    UrlMkDebugOut((DEB_URLMON, "API OUT DllGetClassObject (hr:%lx, ppv:%p)\n",hr,*ppv));
    return hr;
}

void SetupDelayloadErrorHandler()
{
    __pfnDliFailureHook = (PfnDliHook)GetProcAddress(GetModuleHandleA("shlwapi.dll"), "DelayLoadFailureHook");
}

//+-------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:
//
//  Arguments:  [hDll]          - a handle to the dll instance
//              [dwReason]      - the reason LibMain was called
//              [lpvReserved]   - NULL - called due to FreeLibrary
//                              - non-NULL - called due to process exit
//
//  Returns:    TRUE on success, FALSE otherwise
//
//  Notes:
//
//              The officially approved DLL entrypoint name is DllMain. This
//              entry point will be called by the CRT Init function.
//
//
//--------------------------------------------------------------------------
BOOL WINAPI DllMain(HINSTANCE hInstance,DWORD dwReason,LPVOID lpvReserved)
{
    BOOL fResult = TRUE;
    UrlMkDebugOut((DEB_DLL,"DllMain:%lx\n", dwReason));

    PrxDllMain(hInstance, dwReason, lpvReserved);

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
#if DBG==1
        {
            UrlMkInfoLevel = (DWORD) GetProfileIntA("UrlMon","UrlMk", (DEB_ERROR | DEB_WARN)) & DEB_LEVEL_MASK;
            TransInfoLevel = (DWORD) GetProfileIntA("UrlMon","Trans", (DEB_ERROR | DEB_WARN)) & DEB_LEVEL_MASK;
            PProtInfoLevel = (DWORD) GetProfileIntA("UrlMon","PProt", (DEB_ERROR | DEB_WARN)) & DEB_LEVEL_MASK;
            NotfInfoLevel  = (DWORD) GetProfileIntA("UrlMon","Notf",  (DEB_ERROR | DEB_WARN)) & DEB_LEVEL_MASK;
            EProtInfoLevel = (DWORD) GetProfileIntA("UrlMon","EProt", (DEB_ERROR | DEB_WARN)) & DEB_LEVEL_MASK;
            TNotfInfoLevel = (DWORD) GetProfileIntA("UrlMon","TNotf",  (DEB_ERROR | DEB_WARN)) & DEB_LEVEL_MASK;
            g_dwSettings   = (DWORD) GetProfileIntA("UrlMon","Global", (DEB_ERROR | DEB_WARN));
            Win4AssertLevel= (ULONG) GetProfileIntA("UrlMon","AssertLevel", 0);

        // enable encoding handler
        // g_dwSettings |= 0x00100000;
        }
#endif //DBG==1
        SHFusionInitializeFromModule((HMODULE)hInstance);
        SetupDelayloadErrorHandler();

        PerfDbgLog(tagUrlDll, NULL, "+URLMON DLL_PROCESS_ATTACH");
        g_pszUserAgentString = NULL;
        g_pszUAInfoString = GetUAInfoString();
        // We ignore the return code of ZonesInit because other parts of urlmon
        // could still function fine if we can't init zones. 
        ZonesInit( );

        g_bCanUseSimpleBinding = CanUseSimpleBinding();
        g_bGlobalUTF8Enabled = GlobalUTF8Enabled();
        g_bGlobalUTF8hackEnabled = GlobalUTF8hackEnabled();
        g_bUseImprovedZoneCheck = CanUseImprovedZoneCheck();
        g_pHeadURLMONTSList = NULL; 

        OSVERSIONINFO osvi;

        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    
        if (GetVersionEx(&osvi))
        {
            g_bNT5OrGreater = (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) && (osvi.dwMajorVersion >= 5);
        }

        fResult = TlsDllMain(hInstance, dwReason, lpvReserved);

        MLLoadResources(hInstance, TEXT("inetcplc.dll"));
        
        //debug log related stuff
        INET_DEBUG_START();
        
        PerfDbgLog(tagUrlDll, NULL, "-URLMON DLL_PROCESS_ATTACH");
        break;

    case DLL_PROCESS_DETACH:
        if (g_pszUserAgentString != NULL)
        {
            delete g_pszUserAgentString;
            g_pszUserAgentString = NULL;
        }
        if (g_pSecurityManager)
        {
            g_pSecurityManager->Release();
            g_pSecurityManager = NULL;
        }
        if (g_pszUAInfoString != NULL)
        {
            delete g_pszUAInfoString;
            g_pszUAInfoString = NULL;
        }

        if (g_hLibPluginOcx)
        {
            FreeLibrary(g_hLibPluginOcx);
        }

        if (g_hLibMlang)
        {
            FreeLibrary(g_hLibMlang);
        }

        ZonesUnInit( );

        g_bCanUseSimpleBinding = TRUE;

        if (g_pEFmtETC)
        {
            g_pEFmtETC->Release();
        }

        if(g_pHeadURLMONTSList) 
        {
            //
            // if    lpvReserved == NULL   - called due to FreeLibrary
            // else                        - called due to process Terminate
            //
            // Since we are using SendMessage to kill the thread notification 
            // window, we should only do that when FreeLibraray() happens
            //
            if( !lpvReserved )
            {
                CleanupTSOnProcessDetach();   
            }
        }
        
        MLFreeResources(hInstance);

        //debug log related stuff
        INET_DEBUG_FINISH();

        // Fall through

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        fResult = TlsDllMain(hInstance, dwReason, lpvReserved);

        if (dwReason==DLL_PROCESS_DETACH)
        {
            SHFusionUninitialize();
        }
    }
    UrlMkDebugOut((DEB_DLL,"DllMain: done\n"));

    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
    return (g_cRef ? S_FALSE : S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    5-03-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI DllRegisterServer()
{
    UrlMkDebugOut((DEB_URLMON, "API _IN DllRegisterServer\n"));
    HRESULT hr;

    // don't register the proxies now
    // PrxDllRegisterServer();
    PrxDllRegisterServer();

    hr = HrDllRegisterServer(rgRegEntryGroups, g_hInst, NULL /*pfnLoadString*/);


    UrlMkDebugOut((DEB_URLMON, "API OUT DllRegisterServer (hr:%lx)\n",hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllUnregisterServer
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    5-03-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI DllUnregisterServer()
{
    UrlMkDebugOut((DEB_URLMON, "API _IN DllUnregisterServer\n"));
    HRESULT hr;

    // don't register the proxies now
    //PrxDllUnregisterServer();
    hr = HrDllUnregisterServer(rgRegEntryGroupsDel, g_hInst, NULL /*pfnLoadString*/);

    UrlMkDebugOut((DEB_URLMON, "API OUT DllUnregisterServer (hr:%lx)\n",hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllRegisterServerEx
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    5-03-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI DllRegisterServerEx()
{
    UrlMkDebugOut((DEB_URLMON, "API _IN DllRegisterServerEx\n"));

    HRESULT hr = E_NOTIMPL;

    UrlMkDebugOut((DEB_URLMON, "API OUT DllRegisterServerEx (hr:%lx)\n",hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllInstall
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    6-17-97   SanjayS (Sanjay Shenoy)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI DllInstall(BOOL bInstall, LPCWSTR pwStr)
{
    UrlMkDebugOut((DEB_URLMON, "API _IN DllInstall\n"));

#ifdef UNIX
    /*
     * On Unix, regsetup always passes in L"" for pwStr.
     */
    HRESULT hr;

    if (pwStr && !wcscmp(pwStr, L""))
       hr = ZonesDllInstall(bInstall, L"HKCU");
    else
       hr = ZonesDllInstall(bInstall, pwStr);
#else
    HRESULT hr = ZonesDllInstall(bInstall, pwStr);
#endif /* UNIX */

    UrlMkDebugOut((DEB_URLMON, "API OUT DllInstall (hr:%lx)\n", hr));
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   CoBuildVersion
//
//  Synopsis:   Return build version DWORD
//
//  Returns:    DWORD hiword = 23
//              DWORD loword = build number
//
//  Notes:      The high word must always be constant for a given platform.
//              For Win16 it must be exactly 23 (because that's what 16-bit
//              OLE 2.01 shipped with).  We can choose a different high word
//              for other platforms.  The low word must be greater than 639
//              (also because that's what 16-bit OLE 2.01 shipped with).
//
//--------------------------------------------------------------------------

STDAPI_(DWORD)  UrlMkBuildVersion( VOID )
{
    WORD wLowWord;
    WORD wHighWord;


    wHighWord = 23;
    //wLowWord  = rmm;    //  from ih\verole.h
    wLowWord  = 1;    //  from ih\verole.h

    //Win4Assert(wHighWord == 23 && "CoBuildVersion high word magic number");
    //Win4Assert(wLowWord > 639 && "CoBuildVersion low word not large enough");

    DWORD dwVersion;

    dwVersion = MAKELONG(wLowWord, wHighWord);

    return dwVersion;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetUAInfoString
//
//  Synopsis:   Creates the extra UA header string
//
//  Arguments:
//
//  Returns:    pointer to newly allocated string
//
//  History:    5-27-96   JoeS (Joe Souza)  Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPSTR GetUAInfoString(void)
{
    BOOL    bRet;

    CHAR    szINTEL[] = "x86";
    CHAR    szMIPS[] = "MIPS";
    CHAR    szALPHA[] = "Alpha";
    CHAR    szPPC[] = "PPC";
    CHAR    *pszProcessorString = szINTEL;

    CHAR    szExtraUAInfo[] = "UA-CPU: %s\r\n";
    #define SZUSERAGENTMAX 256
    static char vszBuffer[SZUSERAGENTMAX] = "";

    LPSTR   pszTmp;
    BOOL    fIsNT = FALSE;

    // Get all needed info.
    OSVERSIONINFO   osvi;
    SYSTEM_INFO si;

    {
        memset(&osvi, 0, sizeof(osvi));

        osvi.dwOSVersionInfoSize = sizeof(osvi);
        GetVersionEx(&osvi);
        if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            // We are running on NT
            fIsNT = TRUE;
            memset(&si, 0, sizeof(si));

            GetSystemInfo(&si);

            switch (si.wProcessorArchitecture)
            {
            case PROCESSOR_ARCHITECTURE_MIPS:
                pszProcessorString = szMIPS;
                break;

            case PROCESSOR_ARCHITECTURE_ALPHA:
                pszProcessorString = szALPHA;
                break;

            case PROCESSOR_ARCHITECTURE_PPC:
                pszProcessorString = szPPC;
                break;
            }
        }
    }

    // Build header string.
    wsprintf(vszBuffer, szExtraUAInfo, pszProcessorString);

    pszTmp = new CHAR [strlen(vszBuffer) + 1];

    if (pszTmp )
    { 
        if(fIsNT && si.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL )
            strcpy(pszTmp, vszBuffer);
        else 
            pszTmp[0] = '\0';
    }

    return pszTmp;
}

#if DBG==1

#include <sem.hxx>
CMutexSem   mxs;

IDebugOut *v_pPProtDbgOut = NULL;
IDebugOut *v_pTransDbgOut = NULL;
IDebugOut *v_pUrlMkDbgOut = NULL;
IDebugOut *v_pNotfDbgOut = NULL;
IDebugOut *v_pEProtDbgOut = NULL;
IDebugOut *v_pTNotfDbgOut = NULL;

void UrlSpyFn(int iOption, const char *pscFormat, ...)
{
    CLock lck(mxs);
    
    static char szOutBuffer[2048];
    static DWORD * apiLevel[] = { &UrlMkInfoLevel, &TransInfoLevel, &PProtInfoLevel, &NotfInfoLevel, &EProtInfoLevel, &TNotfInfoLevel };
    static IDebugOut ** apDbgOut[] = { &v_pUrlMkDbgOut, &v_pTransDbgOut, &v_pPProtDbgOut,&v_pNotfDbgOut, &v_pEProtDbgOut, &v_pTNotfDbgOut };
    int iIndex = iOption >> DEB_LEVEL_SHIFT;
    int iLevel = *apiLevel[iIndex];

    if ((iOption & iLevel) == 0)
        return;

    DWORD tid = GetCurrentThreadId();
    DWORD cbBufLen;
    IDebugOut * pDbgOut = *apDbgOut[iIndex];

    wsprintf(szOutBuffer, "%08x> ", tid);
    cbBufLen = strlen(szOutBuffer);

    va_list args;
    va_start(args, pscFormat);
    vsprintf(szOutBuffer + cbBufLen, pscFormat, args);
    va_end(args);
    UrlSpySendEntry(pDbgOut, szOutBuffer, tid, iOption & DEB_LEVEL_MASK, 0);
}

void PerfDbgLogFn(int tag, void * pvObj, const char * pchFmt, ...)
{
    CLock lck(mxs);
    
    static char szOutBuffer[2048];
    static DWORD * apiLevel[] = { &UrlMkInfoLevel, &TransInfoLevel, &PProtInfoLevel, &NotfInfoLevel, &EProtInfoLevel, &TNotfInfoLevel };
    static IDebugOut ** apDbgOut[] = { &v_pUrlMkDbgOut, &v_pTransDbgOut, &v_pPProtDbgOut, &v_pEProtDbgOut };
    int iIndex = min(tag >> DEB_LEVEL_SHIFT, 2);
    int iLevel = *apiLevel[iIndex];

    if ((tag & iLevel) == 0)
        return;

    DWORD tid = GetCurrentThreadId();
    DWORD cbBufLen;
    IDebugOut * pDbgOut = *apDbgOut[iIndex];

    sprintf(szOutBuffer, "%08x> %p %s", tid, pvObj,
        *pchFmt == '+' ? "_IN " : (*pchFmt == '-' ? "OUT " : ""));
    cbBufLen = strlen(szOutBuffer);

    if (*pchFmt == '+' || *pchFmt == '-')
        pchFmt += 1;

    va_list args;
    va_start(args, pchFmt);
    vsprintf(szOutBuffer + cbBufLen, pchFmt, args);
    lstrcat(szOutBuffer, "\n");
    va_end(args);
    UrlSpySendEntry(pDbgOut, szOutBuffer, tid, tag & DEB_LEVEL_MASK, 0);
}

void UrlSpySendEntry(IDebugOut *pDbgOut, LPSTR szOutBuffer, DWORD ThreadId, DWORD dwFlags, DWORD dwReserved)
{
    if (pDbgOut)
    {
        pDbgOut->SendEntry(ThreadId, dwFlags, szOutBuffer, dwReserved);
    }
    else
    {
        OutputDebugString(szOutBuffer);
    }
}

HRESULT RegisterDebugOut(LPCWSTR pwzName, DWORD dwOptions, IDebugOut *pDbgOut, DWORD dwReserved)
{
    if (pwzName)
    {

        if (!wcsicmp(pwzName, L"UrlMk"))
        {
            UrlMkInfoLevel = dwOptions;
            if (v_pUrlMkDbgOut)
            {
                v_pUrlMkDbgOut->Release();
                v_pUrlMkDbgOut = NULL;
            }
            if (pDbgOut)
            {

                v_pUrlMkDbgOut = pDbgOut;
                pDbgOut->AddRef();
            }

        }
        if (!wcsicmp(pwzName, L"Trans"))
        {
            TransInfoLevel = dwOptions;
            if (v_pTransDbgOut)
            {
                v_pTransDbgOut->Release();
                v_pTransDbgOut = NULL;
            }
            if (pDbgOut)
            {

                v_pTransDbgOut = pDbgOut;
                pDbgOut->AddRef();
            }

        }
        if (!wcsicmp(pwzName, L"PProt"))
        {
            PProtInfoLevel = dwOptions;
            if (v_pPProtDbgOut)
            {
                v_pPProtDbgOut->Release();
                v_pPProtDbgOut = NULL;
            }
            if (pDbgOut)
            {

                v_pPProtDbgOut = pDbgOut;
                pDbgOut->AddRef();
            }

        }
        if (!wcsicmp(pwzName, L"Notf"))
        {
            NotfInfoLevel = dwOptions;
            if (v_pNotfDbgOut)
            {
                v_pNotfDbgOut->Release();
                v_pNotfDbgOut = NULL;
            }
            if (pDbgOut)
            {

                v_pNotfDbgOut = pDbgOut;
                pDbgOut->AddRef();
            }

        }
        if (!wcsicmp(pwzName, L"EProt"))
        {
            EProtInfoLevel = dwOptions;
            if (v_pEProtDbgOut)
            {
                v_pEProtDbgOut->Release();
                v_pEProtDbgOut = NULL;
            }
            if (pDbgOut)
            {

                v_pEProtDbgOut = pDbgOut;
                pDbgOut->AddRef();
            }

        }
        if (!wcsicmp(pwzName, L"TNotf"))
        {
            TNotfInfoLevel = dwOptions;
            if (v_pTNotfDbgOut)
            {
                v_pTNotfDbgOut->Release();
                v_pTNotfDbgOut = NULL;
            }
            if (pDbgOut)
            {

                v_pTNotfDbgOut = pDbgOut;
                pDbgOut->AddRef();
            }

        }


    }

    return NOERROR;
}


#endif //DBG==1

/*
const REGENTRY rgClassesRes[] =
{
    //***** PROTOCOL_RES ENTRIES *****
    STD_ENTRY(PROTOCOL_RES_CLSID_REGKEY, PROTOCOL_RES_DESCRIP),
    STD_ENTRY(PROTOCOL_RES_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
        { KEYTYPE_STRING, PROTOCOL_RES_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};
*/

/*
const REGENTRY rgClasses[] =
{
    //***** URLMONIKER ENTRIES *****
        STD_ENTRY(URLMONIKER_CLSID_REGKEY, URLMONIKER_DESCRIP),
        STD_ENTRY(URLMONIKER_CLSID_REGKEY"\\InprocServer32", "%s"URLMON_NAME),
{ KEYTYPE_STRING, URLMONIKER_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\mon\urlguids.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       urlguids.cxx
//
//  Contents:   Defines GUIDS used in this DLL.
//
//
//  History:    10-02-1996   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
//#include <urlint.h>


#ifdef __cplusplus
extern "C" {
#endif


#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} GUID;
#endif // GUID_DEFINED


const GUID CLSID_MsHtml           = { 0x25336920, 0x03F9, 0x11cf, {0x8F, 0xD0, 0x00, 0xAA, 0x00, 0x68, 0x6F, 0x13} };
const GUID IID_ITransactionData   = { 0x79eac9cf, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b} };
const GUID IID_ITransProtocolSink = { 0x7291765a, 0xa83f, 0x401d, {0x81, 0xa6, 0x11, 0x2c, 0x3a, 0x46, 0x8a, 0x7b} };

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\perf\condown\condown.cpp ===
#undef UNICODE
#include "urlmon.h"
#include "wininet.h"
#include "commctrl.h"
#include "windows.h"
#include <stdio.h>
#include "initguid.h"
#include "hlink.h"
///#include "hlguids.h"

#ifdef PRODUCT_PROF
extern "C" void _stdcall StartCAP(void);
extern "C" void _stdcall StopCAP(void);
extern "C" void _stdcall SuspendCAP(void);
extern "C" void _stdcall ResumeCAP(void);
extern "C" void _stdcall StartCAPAll(void);
extern "C" void _stdcall StopCAPAll(void);
#else
#define StartCAP()
#define StopCAP()
#define SuspendCAP()
#define ResumeCAP()
#define StartCAPAll()
#define StopCAPAll()
#endif

typedef BOOL (WINAPI *PFNSPA)(HANDLE, DWORD);
typedef HRESULT (WINAPI * pfnCreateURLMoniker)(IMoniker *, LPCWSTR, IMoniker **);
typedef HRESULT (WINAPI * pfnRegisterBindStatusCallback)(LPBC, IBindStatusCallback *, IBindStatusCallback **, DWORD);

typedef struct
{
    TCHAR*   pBuf;      //Actual buffer to hold data
    DWORD    lNumRead;  //number of bytes read in buffer
    void*    pNext;     //Pointer to next buffer
} buffer;


HINSTANCE g_hUrlMon = NULL;
pfnCreateURLMoniker g_pfnCreateURLMoniker = NULL;
pfnRegisterBindStatusCallback g_pfnRegisterBindStatusCallback = NULL;

#define _HRESULT_TYPEDEF_(_sc) ((HRESULT)_sc)

#define DO_DOWNLOAD   WM_USER + 10
#define DOWNLOAD_DONE WM_USER + 11

#pragma warning(disable:4100)

// ---------------------------------------------------------------------------
#define DBG_ERROR            0x80000000

// verbose flags
#define DBG_RESULTS          0x01
#define DBG_DEBUG            0x02
#define DBG_INFO             0x04
#define DBG_STARTBINDING     0x08
#define DBG_STOPBINDING      0x10
#define DBG_ONPROGRESS       0x20
#define DBG_ONAVAIL          0x40
#define DBG_BREAKONERROR     0x80

#define DBG_ALLVALID         DBG_RESULTS | DBG_DEBUG | DBG_STARTBINDING | DBG_STOPBINDING | DBG_ONPROGRESS | DBG_ONAVAIL

DWORD g_dwDbgFlags = DBG_RESULTS;
// ---------------------------------------------------------------------------

const INT MAX_BUF_SIZE = 1024 * 16;
const INT BUF_SIZE = 2 * 1024;
const INT URL_MAX = 4;
const INT BUF_NUM = 16*4;
const DWORD TIMEOUT = 10000000;
const INT LDG_DONE = 1;
const INT LDG_STARTED = 0;
const INT PRI_LOW = 1;
const INT PRI_MED = 2;
const INT PRI_HI  = 3;

DWORD dwBegin_Time = 0;
DWORD dwEnd_Time;
DWORD dwTot_Time;
BOOL bDelim = FALSE;
DWORD dwNum_Opens = 1;
DWORD dwBuf_Size = BUF_SIZE;
DWORD dwBytes_Read = 0;
DWORD dwMax_Simul_Downloads = URL_MAX;
DWORD g_dwCacheFlag = BINDF_NOWRITECACHE | BINDF_GETNEWESTVERSION;
char *pFilename = NULL;
char *pInFile = NULL;
char *g_pRunStr = NULL;
char *g_pTestName = NULL;
char g_CmdLine[1024];
TCHAR sUrl[(INTERNET_MAX_URL_LENGTH+1)];
TCHAR* g_pBuf = NULL;

// %%Classes: ----------------------------------------------------------------

class CInfo 
{
public:
    CInfo();
    ~CInfo();
    INT      incDownloads(void) { return m_iDownloads++; }
    INT      decDownloads(void) { return m_iDownloads--; }
    INT      getDownloads(void) { return m_iDownloads; }

    HANDLE           m_hCompleteEvent;
    CRITICAL_SECTION m_csInfo;        //for critical section
    HANDLE           m_hMaxDownloadSem;
    buffer*          m_pPool;         //Pointer to current available buffer in pool
    void*            m_pdFirst;       //pointer to the first element
private:
    INT              m_iDownloads;    //number of current downloads
};

class CDownload 
{
  public:
    CDownload(LPSTR sName, CInfo* pcInfo);
    ~CDownload();
    HRESULT      doDownload(void);
    INT          getStatus(void) { return m_iStatus; }
    INT          getPriority(void) { return m_iPriority; }
#ifdef USE_POOL
    INT          releasePool(void);
#endif

    WCHAR                m_pUrl[(INTERNET_MAX_URL_LENGTH+1)];
#ifdef USE_POOL    
    buffer*              m_pbStartBuffer; //first buffer to hold data
    buffer*              m_pbCurBuffer;   //Current Buffer
#endif    
    CInfo*               m_pcInfo;  
    void*                m_pdNext;        //pointer to next element
    INT                  m_iStatus;       //the url's status
    INT                  m_iPriority;     //the url's priority
    DWORD                lNumRead;  //number of bytes read in buffer for this download
    
  private:
    IMoniker*            m_pMoniker;
    IBindCtx*            m_pBindCtx;
    IBindStatusCallback* m_pBindCallback;
};


class CBindStatusCallback : public IBindStatusCallback 
{
  public:
    // IUnknown methods
    STDMETHODIMP    QueryInterface(REFIID riid,void ** ppv);
    STDMETHODIMP_(ULONG)    AddRef()    { return m_cRef++; }
    STDMETHODIMP_(ULONG)    Release()   { if (--m_cRef == 0) { delete this; return 0; } return m_cRef; }

    // IBindStatusCallback methods
    STDMETHODIMP    OnStartBinding(DWORD dwReserved, IBinding* pbinding);
    STDMETHODIMP    GetPriority(LONG* pnPriority);
    STDMETHODIMP    OnLowResource(DWORD dwReserved);
    STDMETHODIMP    OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode,
                        LPCWSTR pwzStatusText);
    STDMETHODIMP    OnStopBinding(HRESULT hrResult, LPCWSTR szError);
    STDMETHODIMP    GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pbindinfo);
    STDMETHODIMP    OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC *pfmtetc,
                        STGMEDIUM* pstgmed);
    STDMETHODIMP    OnObjectAvailable(REFIID riid, IUnknown* punk);

    // constructors/destructors
    CBindStatusCallback(CDownload* pcDownload);
    ~CBindStatusCallback();

    
    // data members
    DWORD           m_cRef;
    IBinding*       m_pBinding;
    IStream*        m_pStream;
    DWORD           m_cbOld;
    CDownload*      m_pcDownload;
};


// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
INT dprintf(DWORD dwFlags, TCHAR *fmt, ... ) 
{
    INT      ret = 0;
    va_list  marker;
    TCHAR     szBuffer[256];

    if(dwFlags & (g_dwDbgFlags | DBG_ERROR))
    {
        va_start( marker, fmt );
        ret = vsprintf( szBuffer, fmt, marker );
        OutputDebugString( szBuffer );
        printf(szBuffer);

        if(g_dwDbgFlags & DBG_BREAKONERROR)
            DebugBreak();
    }
    return ret; 
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
void SetSingleProcessorAffinity()
{
    PFNSPA pfn;

    pfn = (PFNSPA)GetProcAddress(GetModuleHandleA("KERNEL32.DLL"),
            "SetProcessAffinityMask");

    if (pfn)
    {
        pfn(GetCurrentProcess(), 1);
    }
}


// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
HRESULT LoadUrlMon()
{
    g_hUrlMon = (HINSTANCE)LoadLibraryA("URLMON.DLL");

    if (g_hUrlMon == NULL)
    {
        dprintf(DBG_ERROR, "LoadLibraryA of URLMON.DLL failed\n");
        return(E_FAIL);
    }

    g_pfnCreateURLMoniker = (pfnCreateURLMoniker)GetProcAddress(g_hUrlMon, "CreateURLMoniker");
    
    if (g_pfnCreateURLMoniker == NULL)
    {
        dprintf(DBG_ERROR, "GetProcAddress CreateURLMoniker failed\n");
        return(E_FAIL);
    }

    g_pfnRegisterBindStatusCallback = (pfnRegisterBindStatusCallback)GetProcAddress(g_hUrlMon, "RegisterBindStatusCallback");

    if (g_pfnRegisterBindStatusCallback == NULL)
    {
        dprintf(DBG_ERROR, "GetProcAddress RegisterBindStatusCallback failed\n");
        return(E_FAIL);
    }

    return(S_OK);
}

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
void UnloadUrlMon()
{
    if (g_hUrlMon)
    {
        FreeLibrary(g_hUrlMon);
    }
}

// ===========================================================================
//                     CBindStatusCallback Implementation
// ===========================================================================

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::CBindStatusCallback
// ---------------------------------------------------------------------------
CBindStatusCallback::CBindStatusCallback(CDownload* pcDownload)
{
    m_pBinding = NULL;
    m_pStream = NULL;
    m_cRef = 1;
    m_cbOld = 0;
    m_pcDownload = pcDownload;
}  // CBindStatusCallback

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::~CBindStatusCallback
// ---------------------------------------------------------------------------
CBindStatusCallback::~CBindStatusCallback()
{
}  // ~CBindStatusCallback

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::QueryInterface
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;

    if (riid==IID_IUnknown || riid==IID_IBindStatusCallback) 
    {
        *ppv = this;
        AddRef();
        return S_OK;    
    }
    return E_NOINTERFACE;
 }  // CBindStatusCallback::QueryInterface

 // ---------------------------------------------------------------------------
 // %%Function: CBindStatusCallback::OnStartBinding
 // ---------------------------------------------------------------------------
 STDMETHODIMP CBindStatusCallback::OnStartBinding(DWORD dwReserved, IBinding* pBinding)
 {
    if (m_pBinding != NULL)
        m_pBinding->Release();

    m_pBinding = pBinding;

    if (m_pBinding != NULL) 
        m_pBinding->AddRef();

    m_pcDownload->m_pcInfo->incDownloads();

    if(g_dwDbgFlags)    
        dprintf(DBG_STOPBINDING, "OnStartBinding getDownloads()=%d\n", m_pcDownload->m_pcInfo->getDownloads());
    return S_OK;

 }  // CBindStatusCallback::OnStartBinding

 // ---------------------------------------------------------------------------
 // %%Function: CBindStatusCallback::GetPriority
 // ---------------------------------------------------------------------------
 STDMETHODIMP CBindStatusCallback::GetPriority(LONG* pnPriority)
 {
     return E_NOTIMPL;
 }  // CBindStatusCallback::GetPriority

 // ---------------------------------------------------------------------------
 // %%Function: CBindStatusCallback::OnLowResource
 // ---------------------------------------------------------------------------
 STDMETHODIMP CBindStatusCallback::OnLowResource(DWORD dwReserved)
 {
     return E_NOTIMPL;
 }  // CBindStatusCallback::OnLowResource

 // ---------------------------------------------------------------------------
 // %%Function: CBindStatusCallback::OnProgress
 // ---------------------------------------------------------------------------
 
STDMETHODIMP CBindStatusCallback::OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText)
{
    TCHAR sz[255];
    if(szStatusText != NULL) {
         WideCharToMultiByte(CP_ACP, 0, szStatusText, -1, sz, 255,0,0);
    }
    if(g_dwDbgFlags)    
        dprintf(DBG_ONPROGRESS, "OnProgress: %d(%s) %d of %d\n", ulStatusCode, sz, ulProgress, (ulProgress>ulProgressMax)?ulProgress:ulProgressMax);
    return(NOERROR);
}  // CBindStatusCallback::OnProgress

 // ---------------------------------------------------------------------------
 // %%Function: CBindStatusCallback::OnStopBinding
 // ---------------------------------------------------------------------------
 STDMETHODIMP CBindStatusCallback::OnStopBinding(HRESULT hrStatus, LPCWSTR pszError)
 {
     if (hrStatus != S_OK) 
     {
        if(g_dwDbgFlags & DBG_DEBUG)
        {
             TCHAR sUrl[(INTERNET_MAX_URL_LENGTH+1)];
             TCHAR sErr[1024];
             WideCharToMultiByte(CP_ACP, 0, m_pcDownload->m_pUrl, -1, 
                 sUrl, INTERNET_MAX_URL_LENGTH, 0, 0);
             WideCharToMultiByte(CP_ACP, 0, pszError, -1, 
                sErr, 1024, 0, 0);
             dprintf(DBG_ERROR, "*** ERROR *** %s OnStopBinding download failed. Status=%x Err=%s\n", sUrl, hrStatus, sErr);
         }
     }
     if (m_pBinding)	
     {
         m_pBinding->Release();
         m_pBinding = NULL;
     }
     
     m_pcDownload->m_pcInfo->decDownloads();
     if(g_dwDbgFlags)    
        dprintf(DBG_STOPBINDING, "OnStopBinding hrStatus=%d getDownloads()=%d\n", hrStatus, m_pcDownload->m_pcInfo->getDownloads());

     if(m_pcDownload->m_pcInfo->getDownloads() == 0) 
     {
         SetEvent(m_pcDownload->m_pcInfo->m_hCompleteEvent);
     }         

     return S_OK;
 }  // CBindStatusCallback::OnStopBinding


 // ---------------------------------------------------------------------------
 // %%Function: CBindStatusCallback::GetBindInfo
 // ---------------------------------------------------------------------------
 STDMETHODIMP CBindStatusCallback::GetBindInfo(DWORD* pgrfBINDF, BINDINFO* pBindInfo)
 {
     *pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA;
     *pgrfBINDF |= g_dwCacheFlag;
     pBindInfo->cbSize = sizeof(BINDINFO);
     pBindInfo->szExtraInfo = NULL;
     memset(&pBindInfo->stgmedData, 0, sizeof(STGMEDIUM));
     pBindInfo->grfBindInfoF = 0;
     pBindInfo->dwBindVerb = BINDVERB_GET;
     pBindInfo->szCustomVerb = NULL;
     return S_OK;
 }  // CBindStatusCallback::GetBindInfo

 // ---------------------------------------------------------------------------
 // %%Function: CBindStatusCallback::OnDataAvailable
 // ---------------------------------------------------------------------------
 
 
STDMETHODIMP CBindStatusCallback::OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC* pfmtetc, STGMEDIUM* pstgmed)
{
    DWORD dwRead = dwSize - m_cbOld; // Amount to be read
    HRESULT hr = S_OK;

     // Get the Stream passed

     if(g_dwDbgFlags)
        dprintf(DBG_ONAVAIL, "OnDataAvailable(grfBSCF=%d pStream=0x%x dwRead=%d dwSize=%d pfmtetc=0x%x, pstgmed=0x%x\n",
            grfBSCF, m_pStream, dwRead, dwSize, pfmtetc, pstgmed);
    
     if (!m_pStream && pstgmed->tymed == TYMED_ISTREAM)
     {
         m_pStream = pstgmed->pstm;
     }

     // If there is some data to be read then go ahead and read
     if (m_pStream && dwRead) 
     {
         while(hr!=E_PENDING) 
         {
#ifdef USE_POOL    
             if(m_pcDownload->m_pcInfo->m_pPool) 
             {
                 //if pool ready
                 EnterCriticalSection(&(m_pcDownload->m_pcInfo->m_csInfo));    
                 if(!m_pcDownload->m_pbStartBuffer) 
                 {    
                     // if the first time
                     m_pcDownload->m_pbStartBuffer = 
                         m_pcDownload->m_pbCurBuffer = 
                         m_pcDownload->m_pcInfo->m_pPool;
                     m_pcDownload->m_pcInfo->m_pPool = 
                         (buffer *)m_pcDownload->m_pcInfo->m_pPool->pNext;
                     m_pcDownload->m_pbStartBuffer->pNext = NULL;    
                 }
                 else 
                 {
                     m_pcDownload->m_pbCurBuffer->pNext = 
                         m_pcDownload->m_pcInfo->m_pPool;
                     m_pcDownload->m_pcInfo->m_pPool =
                     (buffer *)m_pcDownload->m_pcInfo->m_pPool->pNext;
                     m_pcDownload->m_pbCurBuffer = (buffer *) m_pcDownload->m_pbCurBuffer->pNext;
                     m_pcDownload->m_pbCurBuffer->pNext = NULL;
                 }   
                 LeaveCriticalSection(&(m_pcDownload->m_pcInfo->m_csInfo));   
             }    
             else 
             {
                 //allocate buffers on the fly
                 if(!m_pcDownload->m_pbStartBuffer) 
                 {    
                     // if the first time
                     m_pcDownload->m_pbStartBuffer = m_pcDownload->m_pbCurBuffer =  new buffer;
                     if(!m_pcDownload->m_pbCurBuffer)
                     {
                         dprintf(DBG_ERROR, "*** ERROR *** on buff alloc\n");
                         return S_FALSE;
                     }
                     m_pcDownload->m_pbCurBuffer->pBuf = new TCHAR[dwBuf_Size];

                     if(!m_pcDownload->m_pbCurBuffer->pBuf)
                     {
                         dprintf(DBG_ERROR, "*** ERROR *** on buf alloc\n");
                         return S_FALSE;
                     }
                 
                     m_pcDownload->m_pbStartBuffer->pNext = NULL;        
                 }
             
                 else 
                 {    
                     m_pcDownload->m_pbCurBuffer->pNext = new buffer;
                     if(!m_pcDownload->m_pbCurBuffer->pNext)
                     {
                         dprintf(DBG_ERROR, "*** ERROR *** on buff alloc\n");
                         return S_FALSE;
                     }
                     m_pcDownload->m_pbCurBuffer = (buffer *) m_pcDownload->m_pbCurBuffer->pNext;
                     m_pcDownload->m_pbCurBuffer->pBuf = new TCHAR[dwBuf_Size];
                     if(!m_pcDownload->m_pbCurBuffer->pBuf)
                     {
                         dprintf(DBG_ERROR, "*** ERROR *** on buf alloc\n");
                         return S_FALSE;
                     }
                 
                     m_pcDownload->m_pbCurBuffer->pNext = NULL;
                 }
             }
#endif
             if(dwBegin_Time == 0)
                 dwBegin_Time = GetTickCount();

#ifdef USE_POOL    
             hr = m_pStream->Read(m_pcDownload->m_pbCurBuffer->pBuf,             
                 dwBuf_Size, &(m_pcDownload->m_pbCurBuffer->lNumRead));
             if(g_dwDbgFlags)
             {
                  dprintf(DBG_INFO & DBG_DEBUG, "Stream->Read Size=%d Read=%d hr=0x%x\n", dwBuf_Size, m_pcDownload->m_pbCurBuffer->lNumRead, hr);
                  if(hr != S_OK && hr != E_PENDING && hr != S_FALSE)
                    dprintf(DBG_ERROR, "************ Stream->Read hr=0x%x\n", hr);
             }
#else                 
             hr = m_pStream->Read(g_pBuf, dwBuf_Size, &(m_pcDownload->lNumRead));
             if(g_dwDbgFlags)
             {
                  dprintf(DBG_INFO & DBG_DEBUG, "Stream->Read Size=%d Read=%d hr=0x%x\n", dwBuf_Size, m_pcDownload->lNumRead, hr);
                  if(hr != S_OK && hr != E_PENDING && hr != S_FALSE)
                    dprintf(DBG_ERROR, "************ Stream->Read hr=0x%x\n", hr);
             }
#endif                 
             
             //need to check for error if read reaches end of stream
             if(hr == S_FALSE) 
             {
                 break;            
             }
#ifdef USE_POOL    
             if (m_pcDownload->m_pbCurBuffer->lNumRead > 0) 
             {
                 m_cbOld += m_pcDownload->m_pbCurBuffer->lNumRead;
             }
#else
             if (m_pcDownload->lNumRead > 0) 
             {
                 m_cbOld += m_pcDownload->lNumRead;
             }
#endif
         }
     }//     if(m_pstm && dwRead)

     if (BSCF_LASTDATANOTIFICATION & grfBSCF) 
     {
         WideCharToMultiByte(CP_ACP, 0, m_pcDownload->m_pUrl, -1, 
             sUrl, INTERNET_MAX_URL_LENGTH, 0, 0);
         if(g_dwDbgFlags && !bDelim)
            dprintf(DBG_INFO, "Status: %s downloaded.\n", sUrl);
//         m_pcDownload->m_pcInfo->decDownloads();
    
         m_pcDownload->m_iStatus = LDG_DONE;

         if(!ReleaseSemaphore(m_pcDownload->m_pcInfo->m_hMaxDownloadSem,1,NULL)) 
         {
             dprintf(DBG_ERROR, "*** ERROR *** ReleaseSemaphore failed!\n");
             return S_FALSE; 
         }

         dwBytes_Read += m_cbOld;  // accum buf size that was downloaded
     }
     return S_OK;
}  // CBindStatusCallback::OnDataAvailable

// ---------------------------------------------------------------------------
// %%Function: CBindStatusCallback::OnObjectAvailable
// ---------------------------------------------------------------------------
 STDMETHODIMP
CBindStatusCallback::OnObjectAvailable(REFIID riid, IUnknown* punk)
{
    return E_NOTIMPL;
}  // CBindStatusCallback::OnObjectAvailable

// ===========================================================================
//                           CDownload Implementation
// ===========================================================================

// ---------------------------------------------------------------------------
// %%Function: CDownload::CDownload
// ---------------------------------------------------------------------------
CDownload::CDownload(LPSTR sName, CInfo* pcInfo)
{
    MultiByteToWideChar(CP_ACP, 0, sName, -1, m_pUrl, INTERNET_MAX_URL_LENGTH);  
    m_pMoniker = 0;
    m_pBindCtx = 0;
    m_pBindCallback = 0;
    m_pdNext = NULL;

    m_iStatus = LDG_STARTED;
    m_iPriority = PRI_MED;
    m_pcInfo = pcInfo;
#ifdef USE_POOL    
    m_pbStartBuffer = m_pbCurBuffer = NULL;
#endif    

}  // CDownload

// ---------------------------------------------------------------------------
// %%Function: CDownload::~CDownload
// ---------------------------------------------------------------------------
CDownload::~CDownload()
{
    buffer* pbLastBuf = NULL;

    if (m_pMoniker)
        m_pMoniker->Release();
    if (m_pBindCtx)
        m_pBindCtx->Release();
    if (m_pBindCallback)
        m_pBindCallback->Release();
    delete m_pcInfo;

#ifdef USE_POOL    
    if(m_pbStartBuffer)
    {
        while(m_pbStartBuffer->lNumRead != 0 && 
            m_pbStartBuffer->lNumRead <= dwBuf_Size) 
        {
            delete m_pbStartBuffer->pBuf;
            pbLastBuf = m_pbStartBuffer;
            m_pbStartBuffer = (buffer *)m_pbStartBuffer->pNext;   
            delete pbLastBuf;   
        }   
    }
#endif
    GlobalFree(m_pUrl);
}  // ~CDownload

// ---------------------------------------------------------------------------
// %%Function: CDownload::DoDownload
// ---------------------------------------------------------------------------
 

HRESULT CDownload::doDownload(void) 
{
    IStream*        pstm;
    HRESULT         hr;

    hr = g_pfnCreateURLMoniker(NULL, m_pUrl, &m_pMoniker);
    if (FAILED(hr)) 
    {
        dprintf(DBG_ERROR, "*** ERROR *** doDownload CreateURLMoniker failed hr=0x%x\n", hr);
        goto LErrExit;    
    }
            
    m_pBindCallback = new CBindStatusCallback(this);

    if (m_pBindCallback == NULL) 
    {
        dprintf(DBG_ERROR, "*** ERROR *** doDownload CBindStatusCallback failed hr=0x%x\n", hr);
        hr = E_OUTOFMEMORY;
        goto LErrExit;        
    }

    hr = CreateBindCtx(0, &m_pBindCtx);
    if (FAILED(hr)) 
    {
        dprintf(DBG_ERROR, "*** ERROR *** doDownload CreateBindCtx failed hr=0x%x\n", hr);
        goto LErrExit;      
    }

    hr = g_pfnRegisterBindStatusCallback(
        m_pBindCtx, 
        m_pBindCallback, 
        0, 0L);
        
    if (FAILED(hr)) 
    {
        dprintf(DBG_ERROR, "*** ERROR *** doDownload RegisterBindStatusCallback failed hr=0x%x\n", hr);
        goto LErrExit;    
    }
    
    hr = m_pMoniker->BindToStorage(
        m_pBindCtx, 
        0, 
        IID_IStream, 
        (void**)&pstm);
    if (FAILED(hr)) 
    {
        dprintf(DBG_ERROR, "*** ERROR *** doDownload BindToStorage failed hr=0x%x\n", hr);
        goto LErrExit;    
    }
    
    return(hr);

LErrExit:
    if (m_pBindCtx != NULL) 
    {
        m_pBindCtx->Release();
        m_pBindCtx = NULL;
        }
    if (m_pBindCallback != NULL) 
    {
        m_pBindCallback->Release();
        m_pBindCallback = NULL;
        }
    if (m_pMoniker != NULL) 
    {
        m_pMoniker->Release();
        m_pMoniker = NULL;
        }
    return hr;
}

// ---------------------------------------------------------------------------
// %%Function: CDownload::releasePool
// ---------------------------------------------------------------------------
#ifdef USE_POOL
INT CDownload::releasePool()
{
    buffer *pbStart;

    EnterCriticalSection(&(m_pcInfo->m_csInfo));

    while(m_pbStartBuffer) 
    {
        // remember the start buf
        pbStart = (buffer *) m_pbStartBuffer->pNext;
        // adjust the start
        m_pbStartBuffer = (buffer *) m_pbStartBuffer->pNext;

        //insert the buffer at the beginning of the pool
        pbStart->pNext = m_pcInfo->m_pPool;

        // update the pool
        m_pcInfo->m_pPool = pbStart;
    }

    LeaveCriticalSection(&(m_pcInfo->m_csInfo));
    return TRUE;
}
#endif

// ===========================================================================
//                           CInfo Implementation
// ===========================================================================

// ---------------------------------------------------------------------------
// %%Function: CInfo::CInfo
// ---------------------------------------------------------------------------
CInfo::CInfo()
{
#ifdef USE_POOL    
    INT i;

    buffer* pStartBuffer = NULL;
#endif

    m_hCompleteEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!m_hCompleteEvent) 
    {
        dprintf(DBG_ERROR, "*** ERROR *** on create Event!\n");
    }

    InitializeCriticalSection(&(m_csInfo));

    m_hMaxDownloadSem = CreateSemaphore(NULL,dwMax_Simul_Downloads,dwMax_Simul_Downloads, NULL);
    if(!m_hMaxDownloadSem) 
    {
        dprintf(DBG_ERROR, "*** ERROR *** CreateSem failed!\n");
    }

#ifdef USE_POOL    
    pStartBuffer = m_pPool = new buffer; 
    if(!m_pPool)
        return;

    m_pPool->pBuf = new TCHAR[dwBuf_Size]; 
    if (!m_pPool->pBuf)
        return;

    m_pPool->lNumRead = 0;
#endif    

    m_iDownloads = 0;

#ifdef USE_POOL    
    m_pPool->pNext = NULL;
    for(i=1; i<BUF_NUM; i++) 
    {
        m_pPool->pNext = new buffer;
        if (!m_pPool->pNext)
            return;

        m_pPool = (buffer *)m_pPool->pNext;
        m_pPool->pBuf = new TCHAR[dwBuf_Size];
        
        if (!m_pPool->pBuf)
            return;

        m_pPool->lNumRead = 0;
        m_pPool->pNext = NULL;
    }

    m_pPool = pStartBuffer;
#endif    
    return;
}  // CInfo

// ---------------------------------------------------------------------------
// %%Function: CInfo::~CInfo
// ---------------------------------------------------------------------------
CInfo::~CInfo()
{
    buffer *pLastBuf;

    while(m_pPool) 
    {
        delete m_pPool->pBuf;
        pLastBuf = m_pPool;
        m_pPool = (buffer *)m_pPool->pNext;   
        delete pLastBuf;
    }
    delete this;
}  // ~CInfo



// ===========================================================================
//                  User Interface and Initialization Routines
// ===========================================================================

//----------------------------------------------------------------------------
//  Procedure:   DownloadThread
//  Purpose:     Opens internet connection and downloads URL.  Saves
//               URL to pOutQ (one chunk per buffer).
//  Arguments:   outQ
//  Return Val:  TRUE or FALSE based on error
//----------------------------------------------------------------------------

DWORD DownloadThread(LPDWORD lpdwParam) 
{

    INT retVal;
    MSG msg;
    CDownload *pcDownload = (CDownload *) lpdwParam;

    SetEvent(pcDownload->m_pcInfo->m_hCompleteEvent);
    if(g_dwDbgFlags)    
        dprintf(DBG_INFO, "DownloadThread: m_hCompleteEvent set.\n");

    StartCAP();

    for (;;)
    {
        SuspendCAP();

        retVal = GetMessage(&msg, NULL, 0, 0);

        ResumeCAP();

        if(retVal == -1) 
        {
            dprintf(DBG_ERROR, "*** ERROR *** on GetMessage\n");
            break;
        }
        if(retVal == FALSE) 
        {
            msg.message = DOWNLOAD_DONE;
        }
        pcDownload = (CDownload *) msg.wParam;
        switch(msg.message) 
        {
        case DOWNLOAD_DONE:
            delete pcDownload;
            if(g_dwDbgFlags)    
                dprintf(DBG_INFO, "DownloadThread: exit\n");
            return TRUE;
            break;
        
        case DO_DOWNLOAD:
            if(FAILED(pcDownload->doDownload()))
            {
                return FALSE;
            }
            break;
        default:
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }    
    return TRUE;
}

//==================================================================
void Display_Usage(char **argv)
{
    printf("\nUsage: %s -fURLname [options]\n", argv[0]);
    printf("\n          -iInputFileName [options]\n");
    printf("\n\t options:\n");
    printf("\t\t -l   - read buffer length\n");
    printf("\t\t -m   - maximum number of simultaneous downloads\n");
    printf("\t\t -n## - number of times to download\n");
    printf("\t\t -z   - comma delimited format\n");
    printf("\t\t -c   - write to cache (default is NOWRITECACHE)\n");
    printf("\t\t -g   - read from cache (default is GETNEWESTVERSION)\n");
    printf("\t\t -d   - direct read (default uses QueryDataAvailable)\n");
    printf("\t\t -1   - single processor affinity (default multiprocessor)\n");
    printf("\t\t -x#  - verbose flags (default=0x%x)\n", g_dwDbgFlags);
    printf("\t\t\t Results          0x%02x\n",DBG_RESULTS);
    printf("\t\t\t Debug            0x%02x\n",DBG_DEBUG);
    printf("\t\t\t Info             0x%02x\n",DBG_INFO);
    printf("\t\t\t StartBinding     0x%02x\n",DBG_STARTBINDING);
    printf("\t\t\t StopBinding      0x%02x\n",DBG_STOPBINDING);
    printf("\t\t\t OnProgress       0x%02x\n",DBG_ONPROGRESS);
    printf("\t\t\t OnDataAvailable  0x%02x\n",DBG_ONAVAIL);
    printf("\t\t\t Break on Errors  0x%02x\n",DBG_BREAKONERROR);
}

//==================================================================
BOOL Process_Command_Line(int argcIn, char **argvIn)
{
    BOOL bRC = TRUE;
    int argc = argcIn;
    char **argv = argvIn;
    DWORD dwLen = 0;

    *g_CmdLine = '\0';
    
    argv++; argc--;
    while( argc > 0 && argv[0][0] == '-' )  
    {
        switch (argv[0][1]) 
        {
            case 'c':
                g_dwCacheFlag &= ~BINDF_NOWRITECACHE;
                break;
            case 'g':
                g_dwCacheFlag &= ~BINDF_GETNEWESTVERSION;
                break;
            case 'd':
                g_dwCacheFlag |= BINDF_DIRECT_READ;
                break;
            case 'f':
                pFilename = &argv[0][2];
                break;
            case 'i':
                pInFile = &argv[0][2];
                break;
            case 'n':
                dwNum_Opens = atoi(&argv[0][2]);
                break;
            case 'l':
                dwBuf_Size =  atoi(&argv[0][2]);
                if(dwBuf_Size > MAX_BUF_SIZE)
                    dwBuf_Size = MAX_BUF_SIZE;
                break;
            case 'm':
                dwMax_Simul_Downloads = atoi(&argv[0][2]);
                break;
            case 'r':
                g_pRunStr = &argv[0][2];
                break;
            case 't':
                g_pTestName = &argv[0][2];
                break;
            case 'z':
                bDelim = TRUE;
                break;
            case '1':
                SetSingleProcessorAffinity();
                break;
            case 'x':
                sscanf(&argv[0][2], "%x", &g_dwDbgFlags);
                if(!(g_dwDbgFlags & (DBG_ALLVALID)))
                {
                    printf("Invalid verbose flags %x\n", g_dwDbgFlags);
                    Display_Usage(argvIn);
                    bRC = FALSE;
                }
                break;
            default:
                Display_Usage(argvIn);
                bRC = FALSE;
        }
        if(bRC)
        {
            dwLen += lstrlen(argv[0]) + 1;   // length of arg and space
            if(dwLen < ((sizeof(g_CmdLine)/sizeof(g_CmdLine[0]))-1))
            {
                lstrcat(g_CmdLine, ",");
                lstrcat(g_CmdLine, argv[0]);
            }
        }
        
        argv++; argc--;
    }

    if(!pFilename && !pInFile)
    {
        Display_Usage(argvIn);
        bRC = FALSE;
    }

    return(bRC);
}

//----------------------------------------------------------------------------
// Function:  WinMain
// Purpose:   main entry procedure
// Args:      none
// RetVal:    TRUE or FALSE based on error
//----------------------------------------------------------------------------
//int WINAPI WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR szCmdLine, int nCmdShow)
int __cdecl main(INT argc, TCHAR *argv[]) //for console
{
    CDownload*      pcDownload = NULL;
    CDownload*      pcdFirst = NULL;
    CInfo*          pcInfo = NULL;
    DWORD           dwThreadID;
    DWORD           dwCnt;
    HANDLE          hDownloadThread;
    INT             iError;
    char            szName[MAX_PATH];
    __int64         ibeg, iend, ifrq;
    float fKB;
    float fSec;
    float fKBSec;

    if(!Process_Command_Line(argc, argv))
        exit(0);

    pcInfo = new CInfo();
    g_pBuf = new TCHAR[dwBuf_Size];

    if(!pcInfo) 
    {
        dprintf(DBG_ERROR, "*** ERROR *** generating pool!\n");
        return(0);
    }

    dwCnt = 0;
    if(pFilename)
    {
        while(dwCnt++ < dwNum_Opens)
        {    

            if(g_dwCacheFlag & BINDF_NOWRITECACHE)
                lstrcpy(szName, pFilename);
            else
                wsprintf(szName, "%s.%d", pFilename, dwCnt);

            if(!pcDownload) 
            {
                pcdFirst = pcDownload = new CDownload(szName, pcInfo);
                pcDownload->m_pcInfo->m_pdFirst = pcDownload;
            }
            else 
            {
                pcDownload->m_pdNext = new CDownload(szName, pcInfo);
                pcDownload = (CDownload *) pcDownload->m_pdNext;
            }

            if(!pcDownload)
            {
                dprintf(DBG_ERROR, "*** ERROR *** initializing pcDownload!\n");
                return(0);
            }
        }
    }
    else if(pInFile)    // Process input file
    {
        FILE *fp;

        while(dwCnt++ < dwNum_Opens) 
        {
            if((fp = fopen(pInFile, "r")) == NULL) 
            {
                dprintf(DBG_ERROR, "*** ERROR *** opening file\n");
                return(0);
            }

            while(fgets(szName, INTERNET_MAX_URL_LENGTH, fp) != NULL) 
            {
                if(szName[0] != '#') 
                {
                    szName[strlen(szName) - sizeof(char)] = '\0';

                    if(!pcDownload) 
                    {
                        pcdFirst = pcDownload = new CDownload(szName, pcInfo);
                        pcDownload->m_pcInfo->m_pdFirst = pcDownload;
                    }
                    else 
                    {
                        pcDownload->m_pdNext = new CDownload(szName, pcInfo);
                        pcDownload = (CDownload *) pcDownload->m_pdNext;
                    }

                    if(!pcDownload)
                    {
                        dprintf(DBG_ERROR, "*** ERROR *** initializing pcDownload!\n");
                        return(0);
                    }
                }
            }

            fclose(fp);
        }
    }

    pcDownload = (CDownload *) pcDownload->m_pcInfo->m_pdFirst;

    if (LoadUrlMon() != S_OK)
    {
        dprintf(DBG_ERROR, "*** ERROR *** LoadUrlMon() failed\n");
        return(0);
    }

    if (CoInitialize(NULL) != S_OK) 
    {
        dprintf(DBG_ERROR, "*** ERROR *** CoInitialize() failed\n");
        return(0);
    }

    pcDownload->m_pcInfo->m_hCompleteEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (!pcDownload->m_pcInfo->m_hCompleteEvent) 
    {
        dprintf(DBG_ERROR, "*** ERROR *** on create Event!\n");
    }

    hDownloadThread = CreateThread(NULL,
        0,
        (LPTHREAD_START_ROUTINE)DownloadThread,
        (LPVOID)pcDownload,
        0,
        &dwThreadID );

    if (!hDownloadThread) 
    {
        dprintf(DBG_ERROR, "*** ERROR *** Could not create Thread\n");
        return(0);
    }

    if(WaitForSingleObject(pcDownload->m_pcInfo->m_hCompleteEvent, TIMEOUT)
        == WAIT_TIMEOUT) 
    {
        dprintf(DBG_ERROR, "*** ERROR *** timeout on init\n");
    }
    Sleep(100);

    QueryPerformanceCounter((LARGE_INTEGER *)&ibeg);

    while(pcDownload) 
    {
        if(WaitForSingleObject(pcDownload->m_pcInfo->m_hMaxDownloadSem, TIMEOUT) 
            == WAIT_TIMEOUT) 
        {
            dprintf(DBG_ERROR, "*** ERROR *** timeout on Sem\n");
        }

        if(g_dwDbgFlags)
        {
            TCHAR sz[255];
            WideCharToMultiByte(CP_ACP, 0, pcDownload->m_pUrl, -1, sz, 255,0,0);
            dprintf(DBG_INFO, "main: PostThreadMessage DO_DOWNLOAD %s\n", sz);
        }
        if(!PostThreadMessage(dwThreadID, DO_DOWNLOAD, (WPARAM) pcDownload, 0))
        {
            iError = GetLastError();
            dprintf(DBG_ERROR, "*** Error *** on PostThreadMessage(0x%X, %ld, 0x%lX, 0) [GLE=%d]\n", 
                dwThreadID, DO_DOWNLOAD, pcDownload, iError);
            return(0);
        }
        pcDownload = (CDownload *) pcDownload->m_pdNext;    
    }  
    //wait for completion downloads at one time
    if(WaitForSingleObject(pcdFirst->m_pcInfo->m_hCompleteEvent, TIMEOUT) == WAIT_TIMEOUT) 
    {
        dprintf(DBG_ERROR, "*** ERROR *** timeout on Sem\n");
    }

    QueryPerformanceCounter((LARGE_INTEGER *) &iend);
    QueryPerformanceFrequency((LARGE_INTEGER *) &ifrq);

    dwTot_Time = (DWORD)((iend - ibeg) * 1000 / ifrq);
    if(dwTot_Time == 0)
     dwTot_Time = 1;
    fKB = ((float)dwBytes_Read)/1024;
    fSec = ((float)dwTot_Time)/1000;
    fKBSec = fKB / fSec;
    if(!bDelim)
    {
        dprintf(DBG_RESULTS, "Downloaded: %s\r\n", sUrl);
        dprintf(DBG_RESULTS, "%ld Bytes in %ld Milliseconds = %2.0f KB/Sec\r\n", dwBytes_Read, dwTot_Time, fKBSec );
        dprintf(DBG_RESULTS, "%ld Reads, %ld Downloads, %ld Byte Read Buffer\r\n",
            dwNum_Opens, dwMax_Simul_Downloads, dwBuf_Size);
    }
    else
        dprintf(DBG_RESULTS, "%s, %s, %ld, %ld, %2.0f %s\n", 
            g_pTestName ?g_pTestName :"urlmon",
            g_pRunStr ?g_pRunStr :"1",
            dwTot_Time, dwBytes_Read, fKBSec, g_CmdLine );

    if(g_dwDbgFlags)    
        dprintf(DBG_INFO, "realized finished on data ready\n");

    if(!PostThreadMessage(dwThreadID, DOWNLOAD_DONE, (WPARAM) pcDownload, 0))
    {
        iError = GetLastError();
        dprintf(DBG_ERROR, "*** Error *** on PostThreadMessage(0x%X, %ld, 0x%lX, 0) [GLE=%d]\n", 
            dwThreadID, DOWNLOAD_DONE, pcDownload, iError);
        return(0);
    }
    if(WaitForSingleObject(hDownloadThread, TIMEOUT) == WAIT_TIMEOUT) 
    {
        dprintf(DBG_ERROR, "*** ERROR *** timeout on DownloadThread exit\n");
    }
   
    CloseHandle(hDownloadThread);
    CoUninitialize();
    UnloadUrlMon();

    if(g_dwDbgFlags)    
        dprintf(DBG_INFO, "main: exit\n");

    return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\mon\urlapi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       UrlApi.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-25-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <mon.h>
#include <shlwapip.h>
#include "urlapi.hxx"
#include "httpneg.hxx"
#include "mpxbsc.hxx"
#ifndef unix
#include "..\trans\transact.hxx"
#include "..\trans\bindctx.hxx"
#include "..\trans\urlmk.hxx"
#else
#include "../trans/transact.hxx"
#include "../trans/bindctx.hxx"
#include "../trans/urlmk.hxx"
#endif /* unix */

PerfDbgTag(tagUrlApi, "Urlmon", "Log UrlMon API", DEB_ASYNCAPIS);

// API defined in trans\oinet.cxx
BOOL IsOInetProtocol(IBindCtx*, LPCWSTR);

//+---------------------------------------------------------------------------
//
//  Function:   CreateURLMoniker
//
//  Synopsis:   Create a new empty URL Moniker object
//
//  Arguments:  [pMkCtx] -- the context moniker
//              [szUrl] --  url string
//              [ppmk] --   new moniker
//
//  Returns:
//
//  History:    12-13-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CreateURLMoniker(LPMONIKER pMkCtx, LPCWSTR szUrl, LPMONIKER FAR * ppMk)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "CreateURLMoniker",
                    "%#x, %.80wq, %#x",
                    pMkCtx, szUrl, ppMk
                    ));

    HRESULT hr = CreateURLMonikerEx(pMkCtx, szUrl, ppMk, URL_MK_LEGACY);

    DEBUG_LEAVE_API(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateURLMonikerEx
//
//  Synopsis:   Create a new empty URL Moniker object
//
//  Arguments:  [pMkCtx] -- the context moniker
//              [szUrl] --  url string
//              [ppmk] --   new moniker
//              [dwflags] -- controlling flags
//
//  Returns:
//
//  History:    12-13-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CreateURLMonikerEx(LPMONIKER pMkCtx, LPCWSTR szUrl, LPMONIKER FAR * ppMk, DWORD dwFlags)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "CreateURLMonikerEx",
                    "%#x, %.200wq, %#x, %08x",
                    pMkCtx, szUrl, ppMk, dwFlags
                    ));

    VDATEPTROUT(ppMk,LPMONIKER);
    VDATEPTRIN(szUrl,WCHAR);
    PerfDbgLog2(tagUrlApi, NULL, "+CreateURLMoniker (szUrl%ws, pMkCtx:%lx)",szUrl?szUrl:L"<NULL PATH>", pMkCtx);
    HRESULT hr = NOERROR;
    LPWSTR  szUrlLocal = NULL;
    WCHAR   wzUrlStr[MAX_URL_SIZE + 1];
    CUrlMon * pUMk = NULL;
    DWORD   dwCUFlags = (dwFlags & URL_MK_UNIFORM) ? CU_STANDARD_FORM : 0;

    if (dwFlags & URL_MK_NO_CANONICALIZE)
        dwCUFlags |= CU_NO_CANONICALIZE;
    else
        dwCUFlags |= CU_CANONICALIZE;
        
    hr = ConstructURL(NULL, pMkCtx, NULL, (LPWSTR)szUrl, wzUrlStr,
            sizeof(wzUrlStr), dwCUFlags);

    if (hr != NOERROR)
    {
        goto CreateExit;
    }

    szUrlLocal = new WCHAR [wcslen(wzUrlStr) + 1];
    if (szUrlLocal)
    {
        wcscpy(szUrlLocal, wzUrlStr);

        if ((pUMk = new CUrlMon(szUrlLocal)) == NULL)
        {
            hr = E_OUTOFMEMORY;
        }

        // CUrlmon has refcount of 1 now
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

CreateExit:

    *ppMk = pUMk;

    PerfDbgLog2(tagUrlApi, NULL, "-CreateURLMoniker(%ws, Mnk:%lx)",wzUrlStr?wzUrlStr:L"<NULL PATH>",pUMk);

    DEBUG_LEAVE_API(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   MkParseDisplayNameEx
//
//  Synopsis:
//
//  Arguments:  [pbc] --
//              [pszName] --
//              [pchEaten] --
//              [ppmk] --
//
//  Returns:
//
//  History:    12-13-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI MkParseDisplayNameEx(LPBC pbc, LPCWSTR szDispName, ULONG *pchEaten, LPMONIKER *ppmk)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "MkParseDisplayNameEx",
                    "%#x, %.80wq, %#x, %#x",
                    pbc, szDispName, pchEaten, ppmk
                    ));

    VDATEPTROUT(ppmk, LPMONIKER);
    VDATEPTROUT(pchEaten, ULONG);
    VDATEIFACE(pbc);
    VDATEPTRIN(szDispName, WCHAR);
    HRESULT hr = NOERROR;
    WCHAR   wzUrlStr[MAX_URL_SIZE + 1];
    PerfDbgLog1(tagUrlApi, NULL, "+MkParseDisplayNameEx(%ws)",szDispName);


    // No need to canonicalize the URL here.  It will be done later by
    // CreateURLMoniker call below.

    hr = ConstructURL(pbc, NULL, NULL, (LPWSTR)szDispName, wzUrlStr,
            sizeof(wzUrlStr), CU_NO_CANONICALIZE);

    // for unknown protocol (not registered)
    // instead of returning a Moniker which will fail on the Bind
    // we should call the system's MkParseDisplayName()
    if( hr == NOERROR )
    {
        // this is an internal API defined at trans\oinet.cxx
        if(!IsOInetProtocol(pbc, wzUrlStr))
        {
            // for Office backward compatibility...
            if( !StrCmpNIW(wzUrlStr, L"telnet", (sizeof("telnet") - 1) ) )
            {
                hr = NOERROR;
            }
            else
            {
                hr = INET_E_UNKNOWN_PROTOCOL;
            }
        }
    }

    if (hr == NOERROR)
    {
        IMoniker *pmk = NULL;
        // create a URL Moniker and call ParseDisplayName
        hr = CreateURLMoniker(NULL, wzUrlStr, &pmk);
        if (hr == NOERROR)
        {
            *pchEaten = wcslen(szDispName);
            *ppmk = pmk;
        }
        else
        {
            *pchEaten = 0;
            *ppmk = NULL;
        }
    }
    else
    {
        // call the standard OLE parser
        hr = MkParseDisplayName(pbc, szDispName, pchEaten, ppmk);
    }

    PerfDbgLog1(tagUrlApi, NULL, "-MkParseDisplayNameEx(%ws)",szDispName);
    
    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateAsyncBindCtx
//
//  Synopsis:
//
//  Arguments:  [reserved] --
//              [pBSCb] --
//              [ppBC] --
//
//  Returns:
//
//  History:    10-25-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CreateAsyncBindCtx(DWORD reserved, IBindStatusCallback *pBSCb, IEnumFORMATETC *pEnum, IBindCtx **ppBC)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "CreateAsyncBindCtx",
                    "%#x, %#x, %#x, %#x",
                    reserved, pBSCb, pEnum, ppBC
                    ));

    PerfDbgLog1(tagUrlApi, NULL, "+CreateAsyncBindCtx(%lx)",pBSCb);
    HRESULT hr = NOERROR;
    IUnknown *pUnk;


    if (pBSCb == NULL || ppBC == NULL)
    {
        hr = E_INVALIDARG;
        goto End;
    }

    hr = CreateBindCtx(reserved, ppBC);
    if (hr == NOERROR)
    {
        BIND_OPTS BindOpts;
        BindOpts.cbStruct = sizeof(BIND_OPTS);
        BindOpts.grfFlags = BIND_MAYBOTHERUSER;
        BindOpts.grfMode = STGM_READWRITE | STGM_SHARE_EXCLUSIVE;
        BindOpts.dwTickCountDeadline = 0L;

        ((IBindCtx *)*ppBC)->SetBindOptions(&BindOpts);

        // Register the IBindStatusCallback in the bind context.
        if (pBSCb != NULL)
        {
            CBSCHolder *pCBSCHolder;

            hr = GetBSCHolder(*ppBC, &pCBSCHolder);

            if (hr == NOERROR)
            {
                //hr = pCBSCHolder->AddNode(pBSCb, BSCO_ALLONIBSC);
                hr = pCBSCHolder->SetMainNode(pBSCb, 0);
                pCBSCHolder->Release();
            }
        }
        if ((hr == NOERROR) && (pEnum != NULL))
        {
            hr = RegisterFormatEnumerator(*ppBC, pEnum, 0);
        }
    }

End:

    PerfDbgLog1(tagUrlApi, NULL, "-CreateAsyncBindCtx(%lx)",pBSCb);

    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateAsyncBindCtxEx
//
//  Synopsis:
//
//  Arguments:  [pbc] --
//              [dwOptions] --
//              [pBSCb] --
//              [pEnum] --
//              [ppBC] --
//              [reserved] --
//
//  Returns:
//
//  History:    10-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CreateAsyncBindCtxEx(IBindCtx *pbc, DWORD dwOptions, IBindStatusCallback *pBSCb, IEnumFORMATETC *pEnum, IBindCtx **ppBC, DWORD reserved)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "CreateAsyncBindCtxEx",
                    "%#x, %#x, %#x, %#x, %#x, %#x",
                    pbc, dwOptions, pBSCb, pEnum, ppBC, reserved
                    ));

    PerfDbgLog1(tagUrlApi, NULL, "+CreateAsyncBindCtxEx(%lx)",pBSCb);
    HRESULT hr = NOERROR;
    IUnknown *pUnk;
    CBindCtx *pCBCtx = NULL;


    if (ppBC == NULL)
    {
        hr = E_INVALIDARG;
    }
    else 
    {
        hr = CBindCtx::Create(&pCBCtx, pbc);
        if (hr == NOERROR)
        {

            *ppBC = pCBCtx;
            BIND_OPTS BindOpts;
            BindOpts.cbStruct = sizeof(BIND_OPTS);
            BindOpts.grfFlags = BIND_MAYBOTHERUSER;
            BindOpts.grfMode = STGM_READWRITE | STGM_SHARE_EXCLUSIVE;
            BindOpts.dwTickCountDeadline = 0L;

            ((IBindCtx *)*ppBC)->SetBindOptions(&BindOpts);

            // Register the IBindStatusCallback in the bind context.
            if (pBSCb != NULL)
            {
                CBSCHolder *pCBSCHolder;

                hr = GetBSCHolder(*ppBC, &pCBSCHolder);

                if (hr == NOERROR)
                {
                    //hr = pCBSCHolder->AddNode(pBSCb, BSCO_ALLONIBSC);
                    hr = pCBSCHolder->SetMainNode(pBSCb, 0);
                    pCBSCHolder->Release();
                }
            }
            if ((hr == NOERROR) && (pEnum != NULL))
            {
                hr = RegisterFormatEnumerator(*ppBC, pEnum, 0);
            }
        }
    }

    PerfDbgLog1(tagUrlApi, NULL, "-CreateAsyncBindCtxEx(%lx)",pBSCb);

    DEBUG_LEAVE_API(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsAsyncMoniker
//
//  Synopsis:
//
//  Arguments:  [pmk] --
//
//  Returns:
//
//  History:    2-13-96   JohannP (Johann Posch)   Created
//              3-05-96   JoePe - Changed to use QI for IID_IAsyncMoniker
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI IsAsyncMoniker(IMoniker* pmk)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "IsAsyncMoniker",
                    "%#x",
                    pmk
                    ));

    PerfDbgLog1(tagUrlApi, NULL, "+IsAsyncMoniker(%lx)", pmk);
    HRESULT hr = NOERROR;

    if (pmk)
    {
        IUnknown *punk;
        hr = pmk->QueryInterface(IID_IAsyncMoniker, (void**)&punk);
        if (hr == S_OK)
        {
            punk->Release();
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    PerfDbgLog2(tagUrlApi, NULL, "-IsAsyncMoniker(%lx, hr:%lx)",pmk, hr);
    
    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterBindStatusCallback
//
//  Synopsis:
//
//  Arguments:  [pBC] --
//              [pBSCb] --
//              [reserved] --
//
//  Returns:
//
//  History:    12-13-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI RegisterBindStatusCallback(LPBC pBC, IBindStatusCallback *pBSCb,IBindStatusCallback **ppBSCBPrev, DWORD reserved)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "RegisterBindStatusCallback",
                    "%#x, %#x, %#x, %#x",
                    pBC, pBSCb, ppBSCBPrev, reserved
                    ));

    HRESULT hr;
    PerfDbgLog2(tagUrlApi, NULL, "+RegisterBindStatusCallback(pBC:%lx, pBSCb:%lx)",pBC,pBSCb);

    if (ppBSCBPrev)
    {
        *ppBSCBPrev = NULL;
    }

    // Register the IBindStatusCallback in the bind context.
    if (pBSCb != NULL && pBC != NULL)
    {
        CBSCHolder *pCBSCHolder;
        IBindStatusCallback *pBSCBUnused = NULL;

        // Note: get the previous register IBSC - this
        //       might be actual a marshaled object
        //
        if (ppBSCBPrev)
        {
            // ask for the IBSC and NOT the holder since the holder does NOT get marshaled
            hr = GetObjectParam(pBC, REG_BSCB_HOLDER, IID_IBindStatusCallback, (IUnknown **)ppBSCBPrev);
            PerfDbgLog1(tagUrlApi, NULL, "=== RegisterBindStatusCallback (pBSCBPrev:%lx)",*ppBSCBPrev);
        }

        hr = GetBSCHolder(pBC, &pCBSCHolder);
        if (hr == NOERROR)
        {
            hr = pCBSCHolder->SetMainNode(pBSCb, &pBSCBUnused);
            pCBSCHolder->Release();
        }

        if (pBSCBUnused)
        {
            if (ppBSCBPrev && *ppBSCBPrev)
            {
                (*ppBSCBPrev)->Release();
            }

            if (ppBSCBPrev)
            {
                *ppBSCBPrev = pBSCBUnused;
            }
            else
            {
                pBSCBUnused->Release();
            }
        }
    }
    else
    {
        UrlMkAssert((pBSCb != NULL && pBC != NULL && "Invalid argument passed in RegisterBindStatusCallback"));
        hr = E_INVALIDARG;
    }

    PerfDbgLog1(tagUrlApi, NULL, "-RegisterBindStatusCallback(hr:%lx)",hr);
    
    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RevokeBindStatusCallback
//
//  Synopsis:
//
//  Arguments:  [pBC] --
//              [pBSCb] --
//              [reserved] --
//
//  Returns:
//
//  History:    12-13-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI RevokeBindStatusCallback(LPBC pBC, IBindStatusCallback *pBSCb)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "RevokeBindStatusCallback",
                    "%#x, %#x",
                    pBC, pBSCb
                    ));
                    
    HRESULT hr;
    PerfDbgLog2(tagUrlApi, NULL, "+RevokeBindStatusCallback(pBC:%lx, pBSCb:%lx)",pBC,pBSCb);
    CBSCHolder *pCBSCHolder;

    if (pBSCb != NULL && pBC != NULL)
    {
        hr = GetBSCHolder(pBC, &pCBSCHolder);
        if (hr == NOERROR)
        {
            hr = pCBSCHolder->RemoveNode(pBSCb);
            if (hr == S_FALSE)
            {
                // remove the holder from this bind context
                // the holder will be deleted since by the
                // last release
                PerfDbgLog2(tagUrlApi, NULL, "===  RevokeBindStatusCallback Revoke Holder Start (pBndCtx:%lx, -> %lx)",pBC, pBSCb);
                hr = pBC->RevokeObjectParam(REG_BSCB_HOLDER);
                PerfDbgLog2(tagUrlApi, NULL, "===  RevokeBindStatusCallback Revoke Holder Done (pBndCtx:%lx, -> %lx)",pBC, pBSCb);
            }
            else
            {
                hr = NOERROR;
            }
            pCBSCHolder->Release();
        }
    }
    else
    {
        UrlMkAssert((pBSCb != NULL && pBC != NULL && "Invalid argument passed in RevokeBindStatusCallback"));
        hr = E_INVALIDARG;
    }

    PerfDbgLog2(tagUrlApi, NULL, "-RevokeBindStatusCallback(%lx, hr:%lx)",pBSCb, hr);
    
    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetClassURL
//
//  Synopsis:
//
//  Arguments:  [szURL] --
//              [pClsID] --
//
//  Returns:
//
//
//  Notes:      BUGBUG: do we have to implement this api? Is it really needed?
//
//----------------------------------------------------------------------------
STDAPI GetClassURL(LPCWSTR szURL, CLSID *pClsID)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "GetClassURL",
                    "%.80wq, %#x",
                    szURL, pClsID
                    ));
 
    HRESULT hr = E_NOTIMPL;
    PerfDbgLog(tagUrlApi, NULL, "+GetClassURL");

    PerfDbgLog(tagUrlApi, NULL, "-GetClassURL");
    
    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterMediaTypesW
//
//  Synopsis:   registers a media types for the current apartment
//
//  Arguments:  [ctypes] --
//              [rgszTypes] --
//              [rgcfTypes] --
//
//  Returns:
//
//  History:    1-20-96   JohannP (Johann Posch)   Created
//
//  Notes:      Media types are registered on apartment level
//
//----------------------------------------------------------------------------
HRESULT RegisterMediaTypesW(UINT ctypes, const LPCWSTR* rgszTypes, CLIPFORMAT* rgcfTypes)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "RegisterMediaTypesW",
                    "%u, %#x, %#x",
                    ctypes, rgszTypes, rgcfTypes
                    ));
 
    HRESULT hr = E_NOTIMPL;
    PerfDbgLog(tagUrlApi, NULL, "+RegisterMediaTypesW");
    CMediaTypeHolder *pCMHolder;
    CLock lck(g_mxsMedia);

#ifdef UNUSED
    pCMHolder = GetMediaTypeHolder();

    if (pCMHolder)
    {
        hr = pCMHolder->Register(ctypes, rgszTypes, rgcfTypes);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
#endif //UNUSED

    PerfDbgLog(tagUrlApi, NULL, "-RegisterMediaTypesW");
    
    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterMediaTypes
//
//  Synopsis:   registers a media types for the current apartment
//
//  Arguments:  [ctypes] --
//              [rgszTypes] --
//              [rgcfTypes] --
//
//  Returns:
//
//  History:    1-20-96   JohannP (Johann Posch)   Created
//
//  Notes:      Media types are registered on apartment level
//
//----------------------------------------------------------------------------
HRESULT RegisterMediaTypes(UINT ctypes, const LPCSTR* rgszTypes, CLIPFORMAT* rgcfTypes)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "RegisterMediaTypes",
                    "%u, %#x, %#x",
                    ctypes, rgszTypes, rgcfTypes
                    ));
 
    HRESULT hr;
    PerfDbgLog(tagUrlApi, NULL, "+RegisterMediaTypes");
    CMediaTypeHolder *pCMHolder;
    CLock lck(g_mxsMedia);

    if (ctypes > 0)
    {
        pCMHolder = GetMediaTypeHolder();

        if (pCMHolder)
        {
            hr = pCMHolder->Register(ctypes, rgszTypes, rgcfTypes);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }


    PerfDbgLog(tagUrlApi, NULL, "-RegisterMediaTypes");
    
    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterMediaTypeClass
//
//  Synopsis:
//
//  Arguments:  [UINT] --
//              [ctypes] --
//              [rgszTypes] --
//              [rgclsID] --
//              [reserved] --
//
//  Returns:
//
//  History:    3-26-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI RegisterMediaTypeClass(LPBC pBC,UINT ctypes,  const LPCSTR* rgszTypes, CLSID *rgclsID, DWORD reserved)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "RegisterMediaTypeClass",
                    "%#x, %u, %#x, %#x, %#x",
                    pBC, ctypes, rgszTypes, rgclsID, reserved
                    ));
 
    HRESULT hr = E_FAIL;
    PerfDbgLog(tagUrlApi, NULL, "+RegisterMediaTypeClass");
    IMediaHolder *pIMHolder = NULL;

    if (ctypes > 0)
    {
        hr = GetObjectParam(pBC, REG_MEDIA_HOLDER, IID_IMediaHolder, (IUnknown**)&pIMHolder);

        if (pIMHolder == NULL)
        {
            pIMHolder = new CMediaTypeHolder();
            if (pIMHolder)
            {
                hr = pBC->RegisterObjectParam(REG_MEDIA_HOLDER, pIMHolder);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    if (hr == NOERROR)
    {
        UrlMkAssert((pIMHolder));
        hr = pIMHolder->RegisterClassMapping(ctypes,(const char **) rgszTypes, rgclsID, 0);
    }

    if (pIMHolder)
    {
        pIMHolder->Release();
    }

    PerfDbgLog(tagUrlApi, NULL, "-RegisterMediaTypeClass");
    
    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   FindMediaTypeClass
//
//  Synopsis:
//
//  Arguments:  [pBC] --
//              [pszType] --
//              [pclsID] --
//              [reserved] --
//
//  Returns:
//
//  History:    3-26-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI FindMediaTypeClass(LPBC pBC, LPCSTR pszType, CLSID *pclsID, DWORD reserved)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "FindMediaTypeClass",
                    "%#x, %.80q, %#x, %#x",
                    pBC, pszType, pclsID, reserved
                    ));
 
    HRESULT hr = NOERROR;
    PerfDbgLog(tagUrlApi, NULL, "+FindMediaTypeClass");
    IMediaHolder *pIMHolder;
    CLIPFORMAT cfTypes = CF_NULL;

    TransAssert((pclsID));
    *pclsID = CLSID_NULL;

    cfTypes = (CLIPFORMAT) RegisterClipboardFormat(pszType);
    if (cfTypes != CF_NULL)
    {
        hr = GetObjectParam(pBC, REG_MEDIA_HOLDER, IID_IMediaHolder, (IUnknown**)&pIMHolder);

        if (pIMHolder)
        {
            hr = pIMHolder->FindClassMapping(pszType, pclsID, 0);
            pIMHolder->Release();
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    PerfDbgLog1(tagUrlApi, NULL, "-FindMediaTypeClass (hr:%lx)", hr);
    
    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateFormatEnumerator
//
//  Synopsis:
//
//  Arguments:  [cfmtetc] --
//              [rgfmtetc] --
//              [ppenumfmtetc] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CreateFormatEnumerator( UINT cfmtetc, FORMATETC* rgfmtetc, IEnumFORMATETC** ppenumfmtetc)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "CreateFormatEnumerator",
                    "%u, %#x, %#x",
                    cfmtetc, rgfmtetc, ppenumfmtetc
                    ));
 
    HRESULT hr = NOERROR;
    PerfDbgLog(tagUrlApi, NULL, "+CreateFormatEnumerator");

    if (ppenumfmtetc != NULL)
    {
        CEnumFmtEtc *pCEnum;
        pCEnum = CEnumFmtEtc::Create(cfmtetc, rgfmtetc);
        if (pCEnum)
        {
            *ppenumfmtetc = (IEnumFORMATETC *)pCEnum;
        }
        else
        {
            *ppenumfmtetc = NULL;
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    PerfDbgLog(tagUrlApi, NULL, "-CreateFormatEnumerator");
    
    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   BindAsyncMoniker
//
//  Synopsis:
//
//  Arguments:  [pmk] --
//              [grfOpt] --
//              [iidResult] --
//              [ppvResult] --
//
//  Returns:
//
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI BindAsyncMoniker (LPMONIKER pmk, DWORD grfOpt, IBindStatusCallback *pIBSCb, REFIID iidResult, LPVOID FAR* ppvResult)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "BindAsyncMoniker",
                    "%#x, %#x, %#x, %#x, %#x",
                    pmk, grfOpt, pIBSCb, iidResult, ppvResult
                    ));
 
    VDATEPTROUT(ppvResult,LPVOID);
    *ppvResult = NULL;
    VDATEIFACE(pmk);
    VDATEIID(iidResult);

    LPBC pbc = NULL;
    HRESULT hr = E_INVALIDARG;
    PerfDbgLog1(tagUrlApi, NULL, "+BindAsyncMoniker(%lx)",pmk);

    if (pmk)
    {
        hr = CreateAsyncBindCtx(0, pIBSCb, NULL, &pbc);
        if (hr == NOERROR)
        {
            hr = pmk->BindToObject(pbc, NULL, iidResult, ppvResult);
            pbc->Release();

        }
    }

    PerfDbgLog1(tagUrlApi, NULL, "-BindAsyncMoniker(%lx)",pmk);
    
    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterFormatEnumerator
//
//  Synopsis:
//
//  Arguments:  [pBC] --
//              [pEFetc] --
//              [reserved] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI RegisterFormatEnumerator(LPBC pBC, IEnumFORMATETC *pEFetc, DWORD reserved)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "RegisterFormatEnumerator",
                    "%#x, %#x, %#x",
                    pBC, pEFetc, reserved
                    ));
 
    HRESULT hr = E_INVALIDARG;
    PerfDbgLog1(tagUrlApi, NULL, "+RegisterFormatEnumerator(%lx)",pBC);

    if (pBC)
    {
        hr = pBC->RegisterObjectParam(REG_ENUMFORMATETC, pEFetc);
    }

    PerfDbgLog1(tagUrlApi, NULL, "-RegisterFormatEnumerator(%lx)",pBC);
    
    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   RevokeFormatEnumerator
//
//  Synopsis:
//
//  Arguments:  [pBC] --
//              [pEFetc] --
//
//  Returns:
//
//  History:    1-19-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI RevokeFormatEnumerator(LPBC pBC, IEnumFORMATETC *pEFetc)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "RevokeFormatEnumerator",
                    "%#x, %#x",
                    pBC, pEFetc
                    ));
 
    HRESULT hr = E_INVALIDARG;
    PerfDbgLog1(tagUrlApi, NULL, "+RevokeFormatEnumerator(%lx)",pBC);

    if (pBC)
    {
        hr = pBC->RevokeObjectParam(REG_ENUMFORMATETC);
    }

    PerfDbgLog1(tagUrlApi, NULL, "-RevokeFormatEnumerator(%lx)",pBC);
    
    DEBUG_LEAVE_API(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\proxy\dlldatax.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       dlldatax.c
//
//  Contents:   wrapper for dlldata.c
//
//  Classes:
//
//  Functions:
//
//  History:    1-08-96   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

#define PROXY_CLSID CLSID_PSUrlMonProxy

#define DllMain             PrxDllMain
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow
#define DllRegisterServer   PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer

#include "dlldata.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\perf\oinetperf\precomp1.inc ===
#//+---------------------------------------------------------------
#//
#//  File:      precomp1.inc
#//
#//  Contents:  directives for global precompiled include file when the
#//             sources file is two directories below com (or wherever
#//             this file is located).  We could easily have precomp3 and
#//             precomp4 for other areas.The urlint.* files should not
#//             otherwise be mentioned in the sources files.
#//
#//
#//----------------------------------------------------------------

PRECOMPILED_CXX=1
#PRECOMPILED_INCLUDE=..\..\inc\urlb.h
#PRECOMPILED_TARGET=$(GPCH_BUILD)\$(_OBJ_DIR)\*\urlb.pch
#PRECOMPILED_OPTION=/Yuurlb.h /Fp$(GPCH_BUILD)\$(_OBJ_DIR)\*\urlb.pch
#PRECOMPILED_OBJ=$(GPCH_BUILD)\$(_OBJ_DIR)\*\urlb.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\perf\oinetperf\oinet.cxx ===
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <urlmon.h>
#include <string.h>
#include <malloc.h>
#include <urlmon.hxx>

#define IE5

#ifdef PRODUCT_PROF
extern "C" void _stdcall StartCAP(void);
extern "C" void _stdcall StopCAP(void);
extern "C" void _stdcall SuspendCAP(void);
extern "C" void _stdcall ResumeCAP(void);
extern "C" void _stdcall StartCAPAll(void);
extern "C" void _stdcall StopCAPAll(void);
#else
#define StartCAP()
#define StopCAP()
#define SuspendCAP()
#define ResumeCAP()
#define StartCAPAll()
#define StopCAPAll()
#endif

#define FLAG_TRACE    1
#define FLAG_DUMPDATA 2
#define MAX_DOWNLOADS 2000
#define MAX_URL INTERNET_MAX_URL_LENGTH
const INT BUF_SIZE = 2 * 1024;
const INT MAX_BUF_SIZE = 1024 * 16;

BOOL g_dwVerbose = 0;
DWORD g_dwNumDownloads = 1;
DWORD g_dwDownloads = 1;
DWORD g_dwTotalBytes = 0;
DWORD g_dwCacheFlag = BINDF_NOWRITECACHE | BINDF_GETNEWESTVERSION;
DWORD dwBuf_Size = BUF_SIZE;
LPWSTR g_pwzUrl = NULL;
LPCSTR g_pInfile = NULL;
LPCSTR g_pTitle = NULL;
LPCSTR g_pRun = NULL;
LPCSTR g_pModule = NULL;
HANDLE g_hCompleted;

__int64 g_ibeg = 0, g_iend, g_ifreq;

//------------------------------------------------------------------------
//      Class:      COInetProtocolHook
//
//      Purpose:    Sample Implementation of ProtocolSink and BindInfo
//                  interface for simplified urlmon async download 
//
//      Interfaces: 
//          [Needed For All]
//                  IOInetProtocolSink
//                      - provide sink for pluggable prot's callback  
//                  IOInetBindInfo    
//                      - provide the bind options
//
//          [Needed For Http] 
//                  IServiceProvider
//                      - used to query http specific services
//                        e.g. HttpNegotiate, Authentication, UIWindow
//                  IHttpNegotiate    
//                      - http negotiation service, it has two methods, 
//                        one is the http pluggable protocol asks the 
//                        client for additional headers, the other is
//                        callback for returned http server status
//                        e.g 200, 401, etc. 
//                                                
//
//      Author:     DanpoZ (Danpo Zhang)
//
//      History:    11-20-97    Created
//                  05-19-98    Modified to act as performance test
//
//      NOTE:       IOInetXXXX == IInternetXXXX
//                  on the SDK, you will see IInternetXXXX, these are same
//                  interfaces
//
//------------------------------------------------------------------------
class COInetProtocolHook :  public IOInetProtocolSink, 
                            public IOInetBindInfo,
                            public IHttpNegotiate,
                            public IServiceProvider
{
public:
    COInetProtocolHook(HANDLE g_hCompleted, IOInetProtocol* pProt);

    virtual ~COInetProtocolHook();

    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID iid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IOInetProtocolSink methods
    STDMETHODIMP Switch( PROTOCOLDATA *pStateInfo);
    STDMETHODIMP ReportProgress( ULONG ulStatusCode, LPCWSTR szStatusText);
    STDMETHODIMP ReportData( 
        DWORD grfBSCF, 
        ULONG ulProgress, 
        ULONG ulProgressMax
    );
    STDMETHODIMP ReportResult(
        HRESULT hrResult,
        DWORD   dwError,
        LPCWSTR wzResult
    );

    //IOInetBindInfo methods
    STDMETHODIMP GetBindInfo(
        DWORD *grfBINDF,
        BINDINFO * pbindinfo
    );
    STDMETHODIMP GetBindString(
        ULONG ulStringType,
        LPOLESTR *ppwzStr,
        ULONG cEl,
        ULONG *pcElFetched
    );

    //IService Provider methods
    STDMETHODIMP QueryService(
        REFGUID guidService,
        REFIID  riid,
        void    **ppvObj 
    );

    //IHttpNegotiate methods
    STDMETHODIMP BeginningTransaction(
        LPCWSTR szURL,
        LPCWSTR szHeaders,
        DWORD   dwReserved,
        LPWSTR  *pszAdditionalHeaders
    );

    STDMETHODIMP OnResponse(
        DWORD    dwResponseCode,
        LPCWSTR  szResponseHeaders,
        LPCWSTR  szRequestHeaders,
        LPWSTR   *pszAdditionalHeaders
    );
private:
    IOInetProtocol* _pProt; 
    HANDLE          _hCompleted;
    CRefCount       _CRefs;          
};


typedef struct tagInfo
{
    WCHAR wzUrl[INTERNET_MAX_URL_LENGTH];
    IOInetProtocol* pProt;
    COInetProtocolHook* pHook;
    IOInetProtocolSink* pSink;
    IOInetBindInfo*     pBindInfo;
} INFO, *PINFO;

typedef BOOL (WINAPI *PFNSPA)(HANDLE, DWORD);

INFO Info[MAX_DOWNLOADS];

//------------------------------------------------------------------------
//------------------------------------------------------------------------

void MylstrcpyW(WCHAR *pwd, WCHAR *pws)
{
    while (*pws)
    {
        *pwd++ = *pws++;
    }
    *pwd = 0;
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
WCHAR *MyDupA2W(LPSTR pa)
{
    int i;
    WCHAR *pw, *pwd;

    i = lstrlen(pa);
    pw = (WCHAR *)CoTaskMemAlloc((i+1) * sizeof(WCHAR));
    pwd = pw;
    while (*pa)
    {
        *pwd++ = (WCHAR)*pa++;
    }
    *pwd++ = 0;

    return pw;
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
void SetSingleProcessorAffinity()
{
    PFNSPA pfn;

    pfn = (PFNSPA)GetProcAddress(GetModuleHandleA("KERNEL32.DLL"),
            "SetProcessAffinityMask");

    if (pfn)
    {
        pfn(GetCurrentProcess(), 1);
    }
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
VOID DisplayUsage(char **argv)
{
    printf("Usage: %s /u:url [/n:# /t:Title /r:RunStr /v:#]\n", argv[0]);
    printf("       %s /i:infile [/t:Title /r:RunStr /v:#]\n", argv[0]);
    printf("   /c   - write to cache (default is NOWRITECACHE)\n");
    printf("   /g   - read from cache (default is GETNEWESTVERSION)\n");
    printf("   /d   - direct read (default uses QueryDataAvailable)\n");
    printf("   /l:# - read buffer length\n");
    printf("   /m:module - pre load module\n");
    printf("   /n:# - download # times.\n");
    printf("   /1   - single processor affinity (default multiprocessor)\n");
    printf("   /v:# - verbose level 1=trace 2=dump data\n");
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
BOOL ProcessCommandLine(int argcIn, char **argvIn)
{
    BOOL bRC = FALSE;
    int argc = argcIn;
    char **argv = argvIn;

    argv++; argc--;
    if(argc == 0)
    {
        DisplayUsage(argvIn);
        return(FALSE);
    }
    
    while( argc > 0 && argv[0][0] == '/' )  
    {
        switch (argv[0][1]) 
        {
            case 'c':
            case 'C':
                g_dwCacheFlag &= ~BINDF_NOWRITECACHE;
                break;
            case 'g':
            case 'G':
                g_dwCacheFlag &= ~BINDF_GETNEWESTVERSION;
                break;
            case 'd':
            case 'D':
                g_dwCacheFlag |= BINDF_DIRECT_READ;
                break;
            case 'i':
            case 'I':
                g_pInfile = &argv[0][3];
                bRC = TRUE;
                break;
            case 'l':
            case 'L':
                dwBuf_Size =  atoi(&argv[0][3]);
                if(dwBuf_Size > MAX_BUF_SIZE)
                    dwBuf_Size = MAX_BUF_SIZE;
                break;
            case 'm':
            case 'M':
                g_pModule = &argv[0][3];
                break;
            case 'n':
            case 'N':
                g_dwNumDownloads = (DWORD)atoi(&argv[0][3]);
				g_dwNumDownloads = max(1, g_dwNumDownloads);
				g_dwNumDownloads = min(MAX_DOWNLOADS, g_dwNumDownloads);
                break;
            case 'r':
            case 'R':
                g_pRun = &argv[0][3];
                break;
            case 't':
            case 'T':
                g_pTitle = &argv[0][3];
                break;
            case 'u':
            case 'U':
                g_pwzUrl = MyDupA2W(&argv[0][3]);
                bRC = TRUE;
                break;
            case 'v':
            case 'V':
                g_dwVerbose = (DWORD)atoi(&argv[0][3]);
                break;
            case '1':
                SetSingleProcessorAffinity();
                break;
            case '?':
            default:
                DisplayUsage(argvIn);
                bRC = FALSE;
        }
        argv++; argc--;
    }

    return(bRC);
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
BOOL BuildInfoList(PINFO pInfo, DWORD dwNumDownloads)
{
    DWORD i = 0;
    
    if(g_pInfile != NULL)
    {
        TCHAR szName[INTERNET_MAX_URL_LENGTH+1];
        FILE *fp;

        if((fp = fopen(g_pInfile, "r")) == NULL)
        {
            printf("error opening file:%s GLE=%d\n", g_pInfile, GetLastError());
            return NULL;
        }

        while(fgets(szName, INTERNET_MAX_URL_LENGTH, fp) != NULL)
        {
            if(szName[0] != '#')
            {
                szName[strlen(szName) - sizeof(char)] = '\0';

                int rc;
                rc = MultiByteToWideChar(CP_ACP, 0, szName, -1, (pInfo+i)->wzUrl, INTERNET_MAX_URL_LENGTH);
                if (!rc)
                {
                    (pInfo+i)->wzUrl[INTERNET_MAX_URL_LENGTH-1] = 0;
                    wprintf(L"BuildInfoList:string too long; truncated to %s\n", (pInfo+i)->wzUrl);
                }
                i++;
            }
        }
        
        g_dwNumDownloads = i;
        fclose(fp);
    }
    else
    {
        for(i =0; i < dwNumDownloads; i++)
        {
            MylstrcpyW((pInfo+i)->wzUrl, g_pwzUrl);
        }
    }

    g_dwDownloads = g_dwNumDownloads;

    return(TRUE);
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
HRESULT StartDownloads(IOInetSession* pSession, PINFO pInfo, DWORD dwNumDownloads)
{
    HRESULT hr = NOERROR;
    
    for(DWORD i =0; i < dwNumDownloads; i++)
    {
        // Create a pluggable protocol
            hr = pSession->CreateBinding(
                NULL,           // [in ] BindCtx, always NULL 
                (pInfo+i)->wzUrl,         // [in ] url 
                NULL,           // [in ] IUnknown for Aggregration
                NULL,           // [out] IUNknown for Aggregration
                &(pInfo+i)->pProt,         // [out] return pProt pointer 
                0               // [in ] bind option, pass 0
            );
            if(g_dwVerbose & FLAG_TRACE)
                printf("MAIN:    Session->CreateBinding: %lx\n", hr);

        // Create a protocolHook (sink) and Start the async operation
        if( hr == NOERROR )
        {
            (pInfo+i)->pHook = new COInetProtocolHook(g_hCompleted, (pInfo+i)->pProt);
            (pInfo+i)->pSink = NULL;
            (pInfo+i)->pBindInfo = NULL;
            
            if( (pInfo+i)->pHook )
            {
                hr = (pInfo+i)->pHook->QueryInterface(IID_IOInetProtocolSink, (void**)&(pInfo+i)->pSink);
                hr = (pInfo+i)->pHook->QueryInterface(IID_IOInetBindInfo, (void**)&(pInfo+i)->pBindInfo);
            }

            if( (pInfo+i)->pProt && (pInfo+i)->pSink && (pInfo+i)->pBindInfo )
            {
                hr = (pInfo+i)->pProt->Start(
                    (pInfo+i)->wzUrl,                        
                    (pInfo+i)->pSink,    
                    (pInfo+i)->pBindInfo,
                    PI_FORCE_ASYNC, 
                    0 
                );
                if(g_dwVerbose & FLAG_TRACE)
                    printf("MAIN:    pProtocol->Start: %lx\n", hr);
            }
        }
    }

    return(hr);
}

//------------------------------------------------------------------------
//------------------------------------------------------------------------
VOID CleanInfoList(PINFO pInfo, DWORD dwNumDownloads)
{
    for(DWORD i = 0; i < dwNumDownloads; i++)
    {
        if((pInfo+i)->pProt)
            (pInfo+i)->pProt->Terminate(0);
        
        if( (pInfo+i)->pSink )
        {
            (pInfo+i)->pSink->Release();
        }
        if( (pInfo+i)->pBindInfo )
        {
            (pInfo+i)->pBindInfo->Release();
        }
        if( (pInfo+i)->pHook )
        {
            (pInfo+i)->pHook->Release();
        }
        
        // release COM objects
        if( (pInfo+i)->pProt )
        {
            //
            // BUG (POSSIBLE RESOURCE LEAK) 
            // If the pProt is IE's http/gopher/ftp implementation, 
            // calling pProt->Release() now might cause resource leak
            // since pProt (although finished the download), might
            // be still waiting wininet to call back about the 
            // confirmation of the handle closing.
            // The correct time to release pProt is to wait after 
            // pProtSink get destroyed.  
            //
            (pInfo+i)->pProt->Release();
        }
    }
}

//------------------------------------------------------------------------
//
//      Purpose:    create a session object
//                  Get a pluggable procotol from the session
//                  Start the pluggable protocol async download 
//
//      Author:     DanpoZ (Danpo Zhang)
//
//      History:    11-20-97    Created
//
//------------------------------------------------------------------------
int _cdecl main(int argc, char** argv) 
{
    IOInetSession* pSession = NULL;
    IOInetProtocol* pProt = NULL;
    HRESULT hr = NOERROR;
    DWORD dwLoadTime;
    HMODULE hMod = NULL;
    
    if(!ProcessCommandLine(argc, argv))
        return 0;
        
    // Init COM
    CoInitialize(NULL); 

	if(g_pModule != NULL)
	{
		hMod = LoadLibrary(g_pModule);
	}
	
    g_hCompleted = CreateEvent(NULL, FALSE, FALSE, NULL);
    
    // Get a Session
    hr = CoInternetGetSession(0, &pSession, 0);    
    if(g_dwVerbose & FLAG_TRACE)
        printf("MAIN:    Created Session: %lx\n", hr);

    if( hr == NOERROR )
    {
        if(!BuildInfoList(&Info[0], g_dwNumDownloads))
            return(2);

        hr = StartDownloads(pSession, &Info[0], g_dwNumDownloads);
    
        if( hr == NOERROR )
        {
            // wait until the async download finishes
            WaitForSingleObject(g_hCompleted, INFINITE);
        }

        StopCAP();
		QueryPerformanceCounter((LARGE_INTEGER *)&g_iend);
        QueryPerformanceFrequency((LARGE_INTEGER *)&g_ifreq);

        dwLoadTime = (LONG)(((g_iend - g_ibeg) * 1000) / g_ifreq);
        float fKB;
        float fSec;
        float fKBSec;

        if(dwLoadTime == 0)
            dwLoadTime = 1;
        fKB = ((float)g_dwTotalBytes)/1024;
        fSec = ((float)dwLoadTime)/1000;
        fKBSec = fKB / fSec;        
        printf("%s,%s,%d,%d,%2.0f\n", 
            g_pTitle ?g_pTitle :"Oinetperf",
            g_pRun ?g_pRun :"1",
            dwLoadTime, g_dwTotalBytes, fKBSec);

        CleanInfoList(&Info[0], g_dwNumDownloads);
    
    }


    if( pSession )
    {
        pSession->Release();
    }
    
    CoTaskMemFree(g_pwzUrl);

	if((g_pModule != NULL) && (hMod != NULL))
	{
		FreeLibrary(hMod);
	}

    // kill COM 
    CoUninitialize();

    return(0); 
}


COInetProtocolHook::COInetProtocolHook
(
    HANDLE g_hCompleted, 
    IOInetProtocol* pProt
)
{
    _hCompleted = g_hCompleted;
    _pProt = pProt;
}

COInetProtocolHook::~COInetProtocolHook() 
{
    CloseHandle(_hCompleted);
}

HRESULT
COInetProtocolHook::QueryInterface(REFIID iid, void **ppvObj)
{
    HRESULT hr = NOERROR;
    *ppvObj = NULL;

    if( iid == IID_IUnknown  || iid == IID_IOInetProtocolSink )
    {
        *ppvObj = static_cast<IOInetProtocolSink*>(this);
    } 
    else
    if( iid == IID_IOInetBindInfo )
    {
        *ppvObj = static_cast<IOInetBindInfo*>(this);
    }
    else
    if( iid == IID_IServiceProvider)
    {
        *ppvObj = static_cast<IServiceProvider*>(this);
    }
    else
    if( iid == IID_IHttpNegotiate )
    {
        *ppvObj = static_cast<IHttpNegotiate*>(this);
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    if( *ppvObj )
    {
        AddRef();
    }

    return hr;
}    

ULONG    
COInetProtocolHook::AddRef(void)
{
    LONG lRet = ++_CRefs;
    return lRet;
}

ULONG
COInetProtocolHook::Release(void)
{
    LONG lRet = --_CRefs;

    if (lRet == 0)
    {
        delete this;
    }

    return lRet;
}

HRESULT
COInetProtocolHook::Switch( PROTOCOLDATA *pStateInfo)
{
    printf("Are you crazy? I don't know how to do Thread switching!!!\n"); 
    return E_NOTIMPL;
}

HRESULT
COInetProtocolHook::ReportProgress( ULONG ulStatusCode, LPCWSTR szStatusText)
{
    switch( ulStatusCode )
    {
        case BINDSTATUS_FINDINGRESOURCE:
            if(g_dwVerbose & FLAG_TRACE)
                wprintf(
                    L"CALLBACK(ReportProgress): Resolving name %s\n", szStatusText );  
            break;

        case BINDSTATUS_CONNECTING:
        if(g_dwVerbose & FLAG_TRACE)
                wprintf(L"CALLBACK(ReportProgress): Connecting to %s\n", szStatusText );
            break;

        case BINDSTATUS_SENDINGREQUEST:
            if(g_dwVerbose & FLAG_TRACE)
                wprintf(L"CALLBACK(ReportProgress): Sending request\n");
            break;

        case BINDSTATUS_CACHEFILENAMEAVAILABLE:
            if(g_dwVerbose & FLAG_TRACE)
                wprintf(L"CALLBACK(ReportProgress): cache filename available\n");
            break;

        case BINDSTATUS_MIMETYPEAVAILABLE:
            if(g_dwVerbose & FLAG_TRACE)
                wprintf(L"CALLBACK(ReportProgress): mimetype available = %s\n", szStatusText);
            break;

        case BINDSTATUS_REDIRECTING:
            if(g_dwVerbose & FLAG_TRACE)
                 wprintf(L"CALLBACK(ReportProgress): Redirecting to %s\n", szStatusText);
            break;

        default:
            if(g_dwVerbose & FLAG_TRACE)
                 wprintf(L"CALLBACK(ReportProgress): others...\n");
            break;
    }
    return NOERROR;
}

HRESULT 
COInetProtocolHook::ReportData( 
    DWORD grfBSCF, 
    ULONG ulProgress, 
    ULONG ulProgressMax
)
{
    if(g_dwVerbose & FLAG_TRACE)
        printf("CALLBACK(ReportData) %d, %d, %d \n", grfBSCF, ulProgress, ulProgressMax);

    // Pull data via pProt->Read(), here are the possible returned 
    // HRESULT values and how we should act upon: 
    // 
    // if E_PENDING is returned:  
    //    client already get all the data in buffer, there is nothing
    //    can be done here, client should walk away and wait for the  
    //    next chuck of data, which will be notified via ReportData()
    //    callback.
    // 
    // if S_FALSE is returned:
    //    this is EOF, everything is done, however, client must wait
    //    for ReportResult() callback to indicate that the pluggable 
    //    protocol is ready to shutdown.
    // 
    // if S_OK is returned:
    //    keep on reading, until you hit E_PENDING/S_FALSE/ERROR, the deal 
    //    is that the client is supposed to pull ALL the available
    //    data in the buffer
    // 
    // if none of the above is returning:
    //    Error occured, client should decide how to handle it, most
    //    commonly, client will call pProt->Abort() to abort the download
 
    char *pBuf = (char *)_alloca(dwBuf_Size);
    HRESULT hr = NOERROR;
    ULONG cbRead;

    while( hr == S_OK )       
    {
        cbRead = 0;

		if (g_ibeg == 0)
		{
			QueryPerformanceCounter((LARGE_INTEGER *)&g_ibeg);
			StartCAP();
		}


        // pull data

        if(g_dwVerbose & FLAG_TRACE)
        {
            printf("MAIN:    pProtocol->Read attempting %d bytes\n", dwBuf_Size);
        }

        hr = _pProt->Read((void*)pBuf, dwBuf_Size, &cbRead);
        if( (hr == S_OK || hr == E_PENDING || hr == S_FALSE) && cbRead )
        {
            if( g_dwVerbose & FLAG_DUMPDATA )
            {
                for( ULONG i = 0; i < cbRead; i++)
                {
                    printf("%c", pBuf[i]);    
                }    
            }

            if(g_dwVerbose & FLAG_TRACE)
            {
                printf("MAIN:    pProtocol->Read %d bytes\n", cbRead);
            }
            g_dwTotalBytes += cbRead;
        }
    }

    if( hr == S_FALSE )
    {
        if(g_dwVerbose & FLAG_TRACE)
            printf("MAIN:    pProtocol->Read returned EOF \n");
    }
    else 
    if( hr != E_PENDING )
    {
        if(g_dwVerbose & FLAG_TRACE)
        {
            printf("MAIN:    pProtocol->Read returned Error %1x \n, hr");
            printf("MAIN:    pProtocol->Abort called \n", hr);
        }
        _pProt->Abort(hr, 0);
    }

    return NOERROR;
}

HRESULT
COInetProtocolHook::ReportResult(
    HRESULT hrResult,
    DWORD   dwError,
    LPCWSTR wzResult
)
{
    // This is the last call back from the pluggable protocol, 
    // this call is equivlant to the IBindStatusCallBack::OnStopBinding()
    // it basically tells you that the pluggable protocol is ready
    // to shutdown

    if(g_dwVerbose & FLAG_TRACE)
        printf("CALLBACK(ReportResult): Download completed with status %1x\n", hrResult);

    // set event to the main thread
    if(InterlockedDecrement((LONG*)&g_dwDownloads ) == 0)
        SetEvent(g_hCompleted);
            
    return NOERROR;
}

HRESULT
COInetProtocolHook::GetBindInfo(
    DWORD *grfBINDF,
    BINDINFO * pbindinfo
)
{
    HRESULT hr = NOERROR;
    
//    *grfBINDF = BINDF_DIRECT_READ | BINDF_ASYNCHRONOUS | BINDF_PULLDATA;
//    *grfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA;
    *grfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA | BINDF_IGNORESECURITYPROBLEM;
    *grfBINDF |= g_dwCacheFlag;

    // for HTTP GET,  VERB is the only field we interested
    // for HTTP POST, BINDINFO will point to Storage structure which 
    //                contains data
    BINDINFO bInfo;
    ZeroMemory(&bInfo, sizeof(BINDINFO));

    // all we need is size and verb field
    bInfo.cbSize = sizeof(BINDINFO);
    bInfo.dwBindVerb = BINDVERB_GET;

    // src -> dest 
    hr = CopyBindInfo(&bInfo, pbindinfo ); 

    return hr;
}


static LPSTR g_szAcceptStrAll = "*/*";
HRESULT
COInetProtocolHook::GetBindString(
    ULONG ulStringType,
    LPOLESTR *ppwzStr,
    ULONG cEl,
    ULONG *pcElFetched
)
{

    HRESULT hr = INET_E_USE_DEFAULT_SETTING;

    switch (ulStringType)
    {
    case BINDSTRING_HEADERS     :
    case BINDSTRING_EXTRA_URL   :
    case BINDSTRING_LANGUAGE    :
    case BINDSTRING_USERNAME    :
    case BINDSTRING_PASSWORD    :
    case BINDSTRING_ACCEPT_ENCODINGS:
    case BINDSTRING_URL:
    case BINDSTRING_USER_AGENT  :
    case BINDSTRING_POST_COOKIE :
    case BINDSTRING_POST_DATA_MIME:
        break;

    case BINDSTRING_ACCEPT_MIMES:
        // IE4's http pluggable protocol implementation does not 
        // honer INET_E_USE_DEFAULT_SETTING returned by this function 
        // starting from IE5, client can just return the USE_DEFAULT 
        
// use for ie5 so we don't need a seperate bin for ie4  // #ifndef IE5
        // this will be freed by the caller
        *(ppwzStr + 0) = MyDupA2W(g_szAcceptStrAll);
        *(ppwzStr + 1) = NULL;
        *pcElFetched = 1;
        
        hr = NOERROR;
//#endif

        break;

    default:
        break; 
    }

    return hr;
}


HRESULT
COInetProtocolHook::QueryService(
    REFGUID guidService,
    REFIID  riid,
    void    **ppvObj 
)
{
    HRESULT hr = E_NOINTERFACE;
    *ppvObj = NULL;
    if( guidService == IID_IHttpNegotiate )
    {
        *ppvObj = static_cast<IHttpNegotiate*>(this);
    }
   
    if( *ppvObj )
    {
        AddRef();
        hr = NOERROR;
    } 
    
    
    return hr;
}


HRESULT
COInetProtocolHook::BeginningTransaction(
    LPCWSTR szURL,
    LPCWSTR szHeaders,
    DWORD   dwReserved,
    LPWSTR  *pszAdditionalHeaders
)
{
    if(g_dwVerbose & FLAG_TRACE)
        printf("HTTPNEGOTIATE: Additional Headers? - No \n"); 
    *pszAdditionalHeaders = NULL;
    return NOERROR;
}

HRESULT
COInetProtocolHook::OnResponse(
    DWORD    dwResponseCode,
    LPCWSTR  szResponseHeaders,
    LPCWSTR  szRequestHeaders,
    LPWSTR   *pszAdditionalHeaders
)
{
    if(g_dwVerbose & FLAG_TRACE)
        printf("HTTPNEGOTIATE: Http server response code %d\n", dwResponseCode);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\proxy\daytona\makefile.inc ===
$(O)\urlmki_p.c : ..\..\idl\$(O)\urlmki_p.c
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\proxy\call_as.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       call_as.c wrapper functions for urlmon
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    1-08-96   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include "transmit.h"

//+---------------------------------------------------------------------------
//
//  Function:   IBindHost_MonikerBindToStorage_Proxy
//
//  Synopsis:
//
//  Arguments:  [This] --
//              [pMk] --
//              [pBC] --
//              [pBSC] --
//              [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    7-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToStorage_Proxy(
    IBindHost __RPC_FAR * This,
    /* [in] */ IMoniker __RPC_FAR *pMk,
    /* [in] */ IBindCtx __RPC_FAR *pBC,
    /* [in] */ IBindStatusCallback __RPC_FAR *pBSC,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj)
{
    HRESULT hr;
    TransDebugOut((DEB_DATA,"%p _IN IBindHost_MonikerBindToStorage_Proxy\n",This));
    *ppvObj = 0;

    hr = IBindHost_RemoteMonikerBindToStorage_Proxy(This, pMk, pBC, pBSC, riid, (IUnknown **)ppvObj);

    TransDebugOut((DEB_DATA,"%p OUT IBindHost_MonikerBindToStorage_Proxy (hr:%lx)\n",This, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IBindHost_MonikerBindToStorage_Stub
//
//  Synopsis:
//
//  Arguments:  [This] --
//              [pMk] --
//              [pBC] --
//              [pBSC] --
//              [riid] --
//              [ppUnk] --
//
//  Returns:
//
//  History:    7-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToStorage_Stub(
    IBindHost __RPC_FAR * This,
    /* [unique][in] */ IMoniker __RPC_FAR *pMk,
    /* [unique][in] */ IBindCtx __RPC_FAR *pBC,
    /* [unique][in] */ IBindStatusCallback __RPC_FAR *pBSC,
    /* [in] */         REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk)
{
    HRESULT hr;
    TransDebugOut((DEB_DATA,"%p _IN IBindHost_MonikerBindToStorage_Stub\n",This));

    hr = This->MonikerBindToStorage(pMk, pBC, pBSC, riid, (void **)ppUnk);

    if (FAILED(hr))
    {
        TransAssert((*ppUnk == 0));
        *ppUnk = 0;
    }

    TransDebugOut((DEB_DATA,"%p OUT IBindHost_MonikerBindToStorage_Stub (hr:%lx)\n",This, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IBindHost_MonikerBindToObject_Proxy
//
//  Synopsis:
//
//  Arguments:  [This] --
//              [pMk] --
//              [pBC] --
//              [pBSC] --
//              [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    7-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToObject_Proxy(
    IBindHost __RPC_FAR * This,
    /* [in] */ IMoniker __RPC_FAR *pMk,
    /* [in] */ IBindCtx __RPC_FAR *pBC,
    /* [in] */ IBindStatusCallback __RPC_FAR *pBSC,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObj)
{
    HRESULT hr;
    TransDebugOut((DEB_DATA,"%p _IN IBindHost_MonikerBindToObject_Proxy\n",This));

    *ppvObj = 0;
    hr = IBindHost_RemoteMonikerBindToObject_Proxy(This, pMk, pBC, pBSC, riid, (IUnknown **)ppvObj);

    TransDebugOut((DEB_DATA,"%p OUT IBindHost_MonikerBindToObject_Proxy (hr:%lx)\n",This, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IBindHost_MonikerBindToObject_Stub
//
//  Synopsis:
//
//  Arguments:  [This] --
//              [pMk] --
//              [pBC] --
//              [pBSC] --
//              [riid] --
//              [ppUnk] --
//
//  Returns:
//
//  History:    7-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IBindHost_MonikerBindToObject_Stub(
    IBindHost __RPC_FAR * This,
    /* [unique][in] */ IMoniker __RPC_FAR *pMk,
    /* [unique][in] */ IBindCtx __RPC_FAR *pBC,
    /* [unique][in] */ IBindStatusCallback __RPC_FAR *pBSC,
    /* [in] */          REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppUnk)
{
    HRESULT hr;
    TransDebugOut((DEB_DATA,"%p _IN IBindHost_MonikerBindToObject_Stub\n",This));

    hr = This->MonikerBindToObject(pMk, pBC, pBSC, riid, (void **)ppUnk);

    if (FAILED(hr))
    {
        TransAssert((*ppUnk == 0));
        *ppUnk = 0;
    }

    TransDebugOut((DEB_DATA,"%p OUT IBindHost_MonikerBindToObject_Stub (hr:%lx)\n",This, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IBindStatusCallback_GetBindInfo_Proxy
//
//  Synopsis:
//
//  Arguments:  [This] --
//              [grfBINDF] --
//              [pbindinfo] --
//
//  Returns:
//
//  History:    7-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IBindStatusCallback_GetBindInfo_Proxy(
    IBindStatusCallback __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *grfBINDF,
    /* [unique][out][in] */ BINDINFO __RPC_FAR *pbindinfo)
{
    TransDebugOut((DEB_DATA,"%p _IN IBindStatusCallback_GetBindInfo_Proxy\n",This));
    HRESULT hr;
    RemSTGMEDIUM RemoteMedium;
    RemSTGMEDIUM *pRemoteMedium = &RemoteMedium;
    RemBINDINFO RemoteBindInfo;
    RemBINDINFO *pRemoteBindInfo = &RemoteBindInfo;

    hr = NOERROR;
    memset(&RemoteBindInfo, 0, sizeof(RemoteBindInfo));

    __try
    {

        RemoteBindInfo.cbSize        = pbindinfo->cbSize      ;
        RemoteBindInfo.szExtraInfo   = pbindinfo->szExtraInfo ;
        RemoteBindInfo.grfBindInfoF  = pbindinfo->grfBindInfoF;
        RemoteBindInfo.dwBindVerb    = pbindinfo->dwBindVerb  ;
        RemoteBindInfo.szCustomVerb  = pbindinfo->szCustomVerb;
        RemoteBindInfo.cbstgmedData  = pbindinfo->cbstgmedData;
        RemoteBindInfo.iid  = IID_NULL;
        STGMEDIUM_to_xmit(&(pbindinfo->stgmedData), (RemSTGMEDIUM **) &pRemoteMedium);

        hr = IBindStatusCallback_RemoteGetBindInfo_Proxy(This, grfBINDF, pRemoteBindInfo,pRemoteMedium);

        if (hr == NOERROR)
        {
            pbindinfo->szExtraInfo =   pRemoteBindInfo->szExtraInfo   ;
            pbindinfo->grfBindInfoF=   pRemoteBindInfo->grfBindInfoF  ;
            pbindinfo->dwBindVerb  =   pRemoteBindInfo->dwBindVerb    ;
            pbindinfo->szCustomVerb=   pRemoteBindInfo->szCustomVerb  ;
            pbindinfo->cbstgmedData=   pRemoteBindInfo->cbstgmedData  ;

            if ( pbindinfo->cbSize > URLMONOFFSETOF(BINDINFO, dwReserved) )
            {
                pbindinfo->pUnk =  0;
                pbindinfo->dwReserved =   pRemoteBindInfo->dwReserved;
                pbindinfo->dwOptions =    pRemoteBindInfo->dwOptions ;
                pbindinfo->dwOptionsFlags = pRemoteBindInfo->dwOptionsFlags;
                pbindinfo->dwCodePage = pRemoteBindInfo->dwCodePage;
                pbindinfo->iid = IID_NULL;
            }           
            STGMEDIUM_from_xmit( (RemSTGMEDIUM *) pRemoteMedium, &(pbindinfo->stgmedData));
        }
        else
        {

        }

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //Just ignore the exception.
    }
#ifdef unix
    __endexcept
#endif /* unix */
    TransDebugOut((DEB_DATA,"%p OUT IBindStatusCallback_GetBindInfo_Proxy (hr:%lx)\n",This, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IBindStatusCallback_GetBindInfo_Stub
//
//  Synopsis:
//
//  Arguments:  [This] --
//              [grfBINDF] --
//              [pbindinfo] --
//              [pRemstgmed] --
//
//  Returns:
//
//  History:    7-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IBindStatusCallback_GetBindInfo_Stub(
    IBindStatusCallback __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *grfBINDF,
    /* [unique][out][in] */ RemBINDINFO __RPC_FAR *prembindinfo,
    /* [unique][out][in] */ RemSTGMEDIUM __RPC_FAR *pRemstgmed
    )
{
    TransDebugOut((DEB_DATA,"%p _IN IBindStatusCallback_GetBindInfo_Stub\n",This));
    HRESULT hr;
    BINDINFO BindInfo;
    STGMEDIUM *pstgmed = NULL;

    hr = NOERROR;
    memset(&BindInfo, 0, sizeof(BindInfo));

    __try
    {
        BindInfo.cbSize        = prembindinfo->cbSize      ;
        BindInfo.szExtraInfo   = prembindinfo->szExtraInfo ;
        BindInfo.grfBindInfoF  = prembindinfo->grfBindInfoF;
        BindInfo.dwBindVerb    = prembindinfo->dwBindVerb  ;
        BindInfo.szCustomVerb  = prembindinfo->szCustomVerb;
        BindInfo.cbstgmedData  = prembindinfo->cbstgmedData;
        BindInfo.iid           = IID_NULL;
        
        if ( prembindinfo->cbSize >= URLMONOFFSETOF(BINDINFO, dwReserved) )
        {
            BindInfo.dwOptions      = prembindinfo->dwOptions;
            BindInfo.dwOptionsFlags = prembindinfo->dwOptionsFlags;
        }

        memset(&(BindInfo.stgmedData), 0 , sizeof(BindInfo.stgmedData));
        BindInfo.stgmedData.tymed  = TYMED_NULL;

        hr = This->GetBindInfo(grfBINDF, &BindInfo);

        if (hr == NOERROR)
        {
            pstgmed = &BindInfo.stgmedData;
            TransAssert((   (pstgmed->tymed == TYMED_NULL &&  pstgmed->pUnkForRelease == NULL)
                         || (pstgmed->tymed != TYMED_NULL) ));

            if (pstgmed->tymed != TYMED_NULL)
            {
                //Convert an STGMEDIUM to a RemSTGMEDIUM
                // structure so it can be sent
                STGMEDIUM_to_xmit(pstgmed,&pRemstgmed);
            }

            prembindinfo->szExtraInfo  = BindInfo.szExtraInfo   ;
            prembindinfo->grfBindInfoF = BindInfo.grfBindInfoF  ;
            prembindinfo->dwBindVerb   = BindInfo.dwBindVerb    ;
            prembindinfo->szCustomVerb = BindInfo.szCustomVerb  ;
            prembindinfo->cbstgmedData = BindInfo.cbstgmedData  ;

            if ( prembindinfo->cbSize > URLMONOFFSETOF(BINDINFO, dwReserved) )
            {
                prembindinfo->dwReserved     = BindInfo.dwReserved;
                prembindinfo->dwOptions      = BindInfo.dwOptions;
                prembindinfo->dwOptionsFlags = BindInfo.dwOptionsFlags;
                prembindinfo->iid  = IID_NULL;
                prembindinfo->pUnk = 0;
                prembindinfo->dwCodePage     = BindInfo.dwCodePage;
            }
            
        }
    }
    __finally
    {
    }
#ifdef unix
    __endfinally
#endif /* unix */
    TransDebugOut((DEB_DATA,"%p OUT IBindStatusCallback_GetBindInfo_Stub (hr:%lx)\n",This, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IBindStatusCallback_OnDataAvailable_Proxy
//
//  Synopsis:
//
//  Arguments:  [This] --
//              [grfBSCF] --
//              [dwSize] --
//              [pformatetc] --
//              [pstgmed] --
//
//  Returns:
//
//  History:    7-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IBindStatusCallback_OnDataAvailable_Proxy(
    IBindStatusCallback __RPC_FAR * This,
    /* [in] */ DWORD grfBSCF,
    /* [in] */ DWORD dwSize,
    /* [in] */ FORMATETC __RPC_FAR *pformatetc,
    /* [in] */ STGMEDIUM __RPC_FAR *pstgmed)
{
    TransDebugOut((DEB_DATA,"%p _IN IBindStatusCallback_OnDataAvailable_Proxy\n",This));
    HRESULT hr;
    RemSTGMEDIUM *pRemoteMedium = 0;
    RemFORMATETC *pRemoteformatetc = 0;
    RemFORMATETC Remoteformatetc;

    hr = NOERROR;

    __try
    {

        Remoteformatetc.cfFormat = (DWORD)pformatetc->cfFormat;
        Remoteformatetc.ptd      = 0;
        Remoteformatetc.dwAspect = pformatetc->dwAspect;
        Remoteformatetc.lindex   = pformatetc->lindex;
        Remoteformatetc.tymed    = pformatetc->tymed;
        pRemoteformatetc = &Remoteformatetc;

        STGMEDIUM_to_xmit(pstgmed, (RemSTGMEDIUM **) &pRemoteMedium);
        hr = IBindStatusCallback_RemoteOnDataAvailable_Proxy(This, grfBSCF, dwSize,
                                    pRemoteformatetc, pRemoteMedium);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //Just ignore the exception.
    }
#ifdef unix
    __endexcept
#endif /* unix */
    if(pRemoteMedium != 0)
    {
        CoTaskMemFree(pRemoteMedium);
        pRemoteMedium = 0;
    }

    TransDebugOut((DEB_DATA,"%p OUT IBindStatusCallback_OnDataAvailable_Proxy (hr:%lx)\n",This, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IBindStatusCallback_OnDataAvailable_Stub
//
//  Synopsis:
//
//  Arguments:  [This] --
//              [grfBSCF] --
//              [dwSize] --
//              [pformatetc] --
//              [pstgmed] --
//
//  Returns:
//
//  History:    7-23-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IBindStatusCallback_OnDataAvailable_Stub(
    IBindStatusCallback __RPC_FAR * This,
    /* [in] */ DWORD grfBSCF,
    /* [in] */ DWORD dwSize,
    /* [in] */ RemFORMATETC *pformatetc,
    /* [in] */ RemSTGMEDIUM __RPC_FAR *pstgmed)
{
    TransDebugOut((DEB_DATA,"%p _IN IBindStatusCallback_OnDataAvailable_Stub\n",This));
    HRESULT hr;
    STGMEDIUM medium;
    FORMATETC formatetc;

    hr = NOERROR;

    __try
    {
        formatetc.cfFormat = (CLIPFORMAT) pformatetc->cfFormat;
        formatetc.ptd      = NULL;
        formatetc.dwAspect = pformatetc->dwAspect;
        formatetc.lindex   = pformatetc->lindex  ;
        formatetc.tymed    = pformatetc->tymed   ;

        memset(&medium, 0, sizeof(medium));
        STGMEDIUM_from_xmit (pstgmed, &medium);
        This->OnDataAvailable(grfBSCF,  dwSize, &formatetc, &medium);
    }
    __finally
    {
        STGMEDIUM_free_inst(&medium);
    }
#ifdef unix
    __endfinally
#endif /* unix */
    TransDebugOut((DEB_DATA,"%p OUT IBindStatusCallback_OnDataAvailable_Stub (hr:%lx)\n",This, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IBinding_GetBindResult_Proxy
//
//  Synopsis:
//
//  Arguments:  [This] --
//              [pclsidProtocol] --
//              [pdwResult] --
//              [pszResult] --
//              [pdwReserved] --
//
//  Returns:
//
//  History:    7-25-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IBinding_GetBindResult_Proxy(
    IBinding __RPC_FAR * This,
    /* [out] */ CLSID __RPC_FAR *pclsidProtocol,
    /* [out] */ DWORD __RPC_FAR *pdwResult,
    /* [out] */ LPOLESTR __RPC_FAR *pszResult,
    /* [out][in] */ DWORD __RPC_FAR *pdwReserved)
{
    TransDebugOut((DEB_DATA,"%p _IN IBindStatusCallbackMsg_GetBindResult_Proxy\n",This));
    HRESULT hr;

    __try
    {
        hr = IBinding_RemoteGetBindResult_Proxy(
                        This,
                        pclsidProtocol,
                        pdwResult,
                        pszResult,
                        NULL);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //Just ignore the exception.
    }
#ifdef unix
    __endexcept
#endif /* unix */

    TransDebugOut((DEB_DATA,"%p OUT IBindStatusCallbackMsg_GetBindResult_Proxy (hr:%lx)\n",This, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   IBinding_GetBindResult_Stub
//
//  Synopsis:
//
//  Arguments:  [This] --
//              [pclsidProtocol] --
//              [pdwResult] --
//              [pszResult] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    7-25-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IBinding_GetBindResult_Stub(
    IBinding __RPC_FAR * This,
    /* [out] */ CLSID __RPC_FAR *pclsidProtocol,
    /* [out] */ DWORD __RPC_FAR *pdwResult,
    /* [out] */ LPOLESTR __RPC_FAR *pszResult,
    /* [in] */ DWORD dwReserved)
{
    TransDebugOut((DEB_DATA,"%p _IN IBindStatusCallbackMsg_RemoteGetBindResult_Stub\n",This));
    HRESULT hr;
    hr = NOERROR;
    MSG msg;

    __try
    {
        This->GetBindResult(
            pclsidProtocol,
            pdwResult,
            pszResult,
            NULL);
    }
    __finally
    {
    }
#ifdef unix
    __endfinally
#endif /* unix */
    TransDebugOut((DEB_DATA,"%p OUT IBindStatusCallbackMsg_RemoteGetBindResult_Stub (hr:%lx)\n",This, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IWinInetHttpInfo_QueryInfo_Proxy
//
//  Synopsis:
//
//  Arguments:  [This] --
//              [dwOption] --
//              [pBuffer] --
//              [pcbBuf] --
//              [pdwFlags] --
//              [pdwReserved] --
//
//  Returns:
//
//  History:    9-20-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IWinInetHttpInfo_QueryInfo_Proxy(
    IWinInetHttpInfo __RPC_FAR * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out] */ LPVOID pBuffer,
    /* [out][in] */ DWORD __RPC_FAR *pcbBuf,
    /* [out][in] */ DWORD __RPC_FAR *pdwFlags,
    /* [out][in] */ DWORD __RPC_FAR *pdwReserved)
{
    TransDebugOut((DEB_DATA,"%p _IN IWinInetHttpInfo_QueryInfo_Proxy\n",This));
    HRESULT hr;

    if (!pcbBuf || (!pBuffer &&  *pcbBuf != 0))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        DWORD dwBuffer = 0;
        DWORD dwFlags = 0;
        DWORD dwReserved = 0;

        if (pdwFlags == NULL)
        {
            pdwFlags = &dwFlags;
        }

        if (pdwReserved == NULL)
        {
            pdwReserved = &dwReserved;
        }

        if (pBuffer == NULL)
        {
            pBuffer = &dwBuffer;
        }

        hr = IWinInetHttpInfo_RemoteQueryInfo_Proxy(This, dwOption, (BYTE*)pBuffer,
                                                    pcbBuf,pdwFlags,pdwReserved);
    }

    TransDebugOut((DEB_DATA,"%p OUT IWinInetHttpInfo_QueryInfo_Proxy (hr:%lx)\n",This, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IWinInetHttpInfo_QueryInfo_Stub
//
//  Synopsis:
//
//  Arguments:  [This] --
//              [dwOption] --
//              [pBuffer] --
//              [pcbBuf] --
//              [pdwFlags] --
//              [pdwReserved] --
//
//  Returns:
//
//  History:    9-20-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IWinInetHttpInfo_QueryInfo_Stub(
    IWinInetHttpInfo __RPC_FAR * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out] */ BYTE __RPC_FAR *pBuffer,
    /* [out][in] */ DWORD __RPC_FAR *pcbBuf,
    /* [out][in] */ DWORD __RPC_FAR *pdwFlags,
    /* [out][in] */ DWORD __RPC_FAR *pdwReserved)
{
    TransDebugOut((DEB_DATA,"%p _IN IWinInetHttpInfo_QueryInfo_Stub\n",This));
    HRESULT hr;

    hr = This->QueryInfo(dwOption, pBuffer, pcbBuf, pdwFlags, pdwReserved);

    TransDebugOut((DEB_DATA,"%p OUT IWinInetHttpInfo_QueryInfo_Stub (hr:%lx)\n",This, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IWinInetInfo_QueryOption_Proxy
//
//  Synopsis:
//
//  Arguments:  [This] --
//              [dwOption] --
//              [pBuffer] --
//              [pcbBuf] --
//
//  Returns:
//
//  History:    9-20-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IWinInetInfo_QueryOption_Proxy(
    IWinInetInfo __RPC_FAR * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out] */ LPVOID pBuffer,
    /* [out][in] */ DWORD *pcbBuf)
{
    TransDebugOut((DEB_DATA,"%p _IN IWinInetInfo_QueryOption_Proxy\n",This));
    HRESULT hr;

    if (!pcbBuf || (!pBuffer &&  *pcbBuf != 0))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        DWORD dwBuffer = 0;

        if (pBuffer == NULL)
        {
            pBuffer = &dwBuffer;
        }

        hr = IWinInetInfo_RemoteQueryOption_Proxy(This,dwOption, (BYTE*)pBuffer,pcbBuf);
    }

    TransDebugOut((DEB_DATA,"%p OUT IWinInetInfo_QueryOption_Proxy (hr:%lx)\n",This, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   IWinInetInfo_QueryOption_Stub
//
//  Synopsis:
//
//  Arguments:  [This] --
//              [dwOption] --
//              [pBuffer] --
//              [pcbBuf] --
//
//  Returns:
//
//  History:    9-20-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE IWinInetInfo_QueryOption_Stub(
    IWinInetInfo __RPC_FAR * This,
    /* [in] */ DWORD dwOption,
    /* [size_is][out] */ BYTE __RPC_FAR *pBuffer,
    /* [out][in] */ DWORD __RPC_FAR *pcbBuf)
{
    TransDebugOut((DEB_DATA,"%p _IN IWinInetInfo_QueryOption_Stub\n",This));
    HRESULT hr;

    hr = This->QueryOption(dwOption,pBuffer,pcbBuf);

    TransDebugOut((DEB_DATA,"%p OUT IWinInetInfo_QueryOption_Stub (hr:%lx)\n",This, hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\search\b4hook.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       resprot.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include <stdio.h>
#include <sem.hxx>
#include <wininet.h>
#include "urlcf.hxx"
#include "protbase.hxx"
#include "b4hook.hxx"
#include <tchar.h>

#define MAX_ID 10000


HRESULT LookupProtocolClsIDFromReg(LPCTSTR pszUrl, CLSID *pclsid);

#define SZPROTOCOLROOT  "PROTOCOLS\\Handler\\"
#define SZCLASS         "CLSID"

#define SZMYPROTOCOL    "search"



//+---------------------------------------------------------------------------
//
//  Method:     CB4Hook::Start
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pTrans] --
//              [pOIBindInfo] --
//              [grfSTI] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CB4Hook::Start(LPCWSTR pwzUrl, IOInetProtocolSink *pTrans, IOInetBindInfo *pOIBindInfo,
                          DWORD grfSTI, DWORD dwReserved)
{
    TransDebugOut((DEB_PROT, "%p _IN CB4Hook::Start\n", this));
    HRESULT hr = NOERROR;
    CLSID clsid;

    TransAssert((!_pProtSink && pOIBindInfo && pTrans));
    TransAssert((_pszUrl == NULL));

    // have to start the base class to get the bindinfo and the full URL.

    hr = CBaseProtocol::Start(pwzUrl,pTrans, pOIBindInfo, grfSTI, dwReserved);

    if (hr == NOERROR)
    {
        // first, check if this is hookable URL.
        // return E_USEDEFAULTPROTOCAL if not.

        if ((hr = Bind()) == NOERROR)
        {
            // We need to use the new (cooked) URL if Bind() succeeded.

            if ((hr = LookupProtocolClsIDFromReg(_szNewUrl, &clsid)) == NOERROR)
            {
                IClassFactory *pCF = 0;
                hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER,IID_IClassFactory, (void**)&pCF);
                if (hr == NOERROR)
                {
                    // Perf: 
                    // we might want to move Create/Release of the HTTP protocl handler out of
                    // Start/Terminate to Create/Release.
    
                    hr = pCF->CreateInstance(NULL, IID_IOInetProtocol, (void **)&_pProt);
                    if (hr == NOERROR)
                    {
                        // ???
                        // We also may need to implement our own IOInetBindInfo so that we
                        // can give it the new (cooked) BindInfo.

                        // We need to pass down the new (cooked) URL if Bind() succeeded.

                        LPWSTR pwzNewUrl = DupA2W(_szNewUrl);
            
                        if (pwzNewUrl)
                        {
                            hr = _pProt->Start(pwzNewUrl, pTrans, pOIBindInfo, grfSTI, dwReserved);

                            delete pwzNewUrl;
                        }
                    }
    
                    pCF->Release();
                }
    
            }
        }
    }

    TransDebugOut((DEB_PROT, "%p OUT CB4Hook::Start (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CB4Hook::Continue
//
//  Synopsis:
//
//  Arguments:  [pStateInfoIn] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CB4Hook::Continue(PROTOCOLDATA *pStateInfoIn)
{
    TransDebugOut((DEB_PROT, "%p _IN CB4Hook::Continue\n", this));
    HRESULT hr = E_FAIL;

    if (_pProt)
        hr = _pProt->Continue(pStateInfoIn);

    TransDebugOut((DEB_PROT, "%p OUT CB4Hook::Continue (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CB4Hook::Read
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//              [ULONG] --
//              [pcbRead] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CB4Hook::Read(void *pv,ULONG cb,ULONG *pcbRead)
{
    TransDebugOut((DEB_PROT, "%p _IN CB4Hook::Read (cb:%ld)\n", this,cb));
    HRESULT hr = NOERROR;

    if (_pProt)
        hr = _pProt->Read(pv, cb, pcbRead);

    TransDebugOut((DEB_PROT, "%p OUT CB4Hook::Read (pcbRead:%ld, hr:%lx)\n",this,*pcbRead, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CB4Hook::Seek
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [ULARGE_INTEGER] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:      WORK: not done
//
//----------------------------------------------------------------------------
STDMETHODIMP CB4Hook::Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    TransDebugOut((DEB_PROT, "%p _IN CB4Hook::Seek\n", this));
    HRESULT hr = NOERROR;

    if (_pProt)
        hr = _pProt->Seek(dlibMove, dwOrigin, plibNewPosition);

    TransDebugOut((DEB_PROT, "%p OUT CB4Hook::Seek (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CB4Hook::CB4Hook
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CB4Hook::CB4Hook(REFCLSID rclsid, IUnknown *pUnkOuter, IUnknown **ppUnkInner) : CBaseProtocol(rclsid, pUnkOuter, ppUnkInner)
{
    TransDebugOut((DEB_PROT, "%p _IN/OUT CB4Hook::CB4Hook \n", this));
}

//+---------------------------------------------------------------------------
//
//  Method:     CB4Hook::~CB4Hook
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CB4Hook::~CB4Hook()
{
    TransDebugOut((DEB_PROT, "%p _IN/OUT CB4Hook::~CB4Hook \n", this));
}


// SUPER HACK FUNCTION because InternetCrackUrl is not very good.
// THIS FUNCTION DOES NOT CHECK THE INPUT BUFFER SIZE.
// AND CALLER MUST PROVIDE lpszUrlPath buffer for us to parse.

BOOL
MyCrackUrl(
    LPCSTR lpszUrl,
    DWORD dwUrlLength,
    DWORD dwFlags,
    LPURL_COMPONENTSA lpUC
)
{
    LPSTR pszBuf = lpUC->lpszUrlPath;
    DWORD dwSize = lpUC->dwUrlPathLength;
    BOOL ret = FALSE;

    if (pszBuf)
    {
        if (InternetCanonicalizeUrl(lpszUrl, pszBuf, &dwSize, ICU_DECODE | ICU_NO_ENCODE))
        {
            // find protocol

            LPSTR pTmp = StrChr(pszBuf, ':');

            if (pTmp)
            {
                *pTmp = '\0';

                if (lpUC->lpszScheme)
                {
                    lstrcpy(lpUC->lpszScheme, pszBuf);
                    lpUC->dwSchemeLength = pTmp - pszBuf;
                }

                pszBuf = ++pTmp;

                // skip '/'s

                while (*pszBuf && (*pszBuf == '/')) 
                    pszBuf++;

                // find host name

                pTmp = StrChr(pszBuf, '/');

                if (lpUC->lpszHostName)
                {
                    if (pTmp)
                        lpUC->dwHostNameLength = pTmp - pszBuf;
                    else
                        lpUC->dwHostNameLength = lstrlen(pszBuf);
    
                    // + 1 for the NULL terminator
    
                    lstrcpyn(lpUC->lpszHostName, pszBuf, lpUC->dwHostNameLength + 1);
                }

                // if a '/' was found, the rest is URL path

                if (pTmp)
                    lpUC->dwUrlPathLength = lstrlen(pTmp);
                else
                    lpUC->dwUrlPathLength = 0;

                lpUC->lpszUrlPath = pTmp;

                ret = TRUE;
            }
        }
    }

    return ret;
}


//+---------------------------------------------------------------------------
//
//  Method:     CB4Hook::Bind
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CB4Hook::Bind()
{
    TransDebugOut((DEB_PROT, "%p _IN CB4Hook::Bind (szUrl >%s< )\n", this, _pszUrl));

    HRESULT hr = INET_E_USE_DEFAULT_PROTOCOLHANDLER;
    URL_COMPONENTS uc;
    TCHAR szScheme[INTERNET_MAX_SCHEME_LENGTH];
    TCHAR szHost[INTERNET_MAX_HOST_NAME_LENGTH];
    TCHAR szURL[MAX_URL_SIZE];
    DWORD dwNeeded;
    LPSTR lpSearchName;
    LPSTR lpNewName = NULL;

    ZeroMemory(&uc, sizeof(uc));
    uc.dwStructSize = sizeof(uc);
    uc.lpszScheme = szScheme;
    uc.dwSchemeLength = ARRAYSIZE(szScheme);
    uc.lpszHostName = szHost;
    uc.dwHostNameLength = ARRAYSIZE(szHost);
    uc.lpszUrlPath = szURL;
    uc.dwUrlPathLength = ARRAYSIZE(szURL);

    // uc.dwExtraInfoLength ???

    // BUGBUG ???
    // InternetCrackUrl doesn't work with "search:\\..."

    if (MyCrackUrl(_pszUrl, 0, ICU_DECODE, &uc))
    {
        // TODO:
        // process the URL string

        if (!lstrcmpi(szScheme, SZMYPROTOCOL))
        {
            // if this is our "search:" protocol

            // BUGBUG
            // we need to look up the registry for the default protocol to use.

            uc.lpszScheme = NULL;
            uc.nScheme = INTERNET_SCHEME_HTTP;
            uc.nPort = INTERNET_DEFAULT_HTTP_PORT;

            if (uc.dwHostNameLength)
            {
                lpSearchName = uc.lpszHostName;
                uc.dwHostNameLength = 0;

                // ???
                // should we clear the UrlPath and ExtraInfo
            }
            else if (uc.dwUrlPathLength)
            {
                lpSearchName = uc.lpszUrlPath;
                uc.lpszUrlPath = NULL;
            }
            else
                lpSearchName = NULL;

            if (lpSearchName)
            {
                // apply the search.
                // ==========================================================
                if (!lstrcmpi(lpSearchName, "united airline"))
                    lpNewName = "www.ual.com";
                else if (!lstrcmpi(lpSearchName, "foo bar"))
                    lpNewName = "msw";
                // ==========================================================

                if (lpNewName)
                {
                    // this is a searchable string

                    uc.lpszHostName = lpNewName;
    
                    dwNeeded = ARRAYSIZE(_szNewUrl);
        
                    if (InternetCreateUrl(&uc, 0, _szNewUrl, &dwNeeded))
                        hr = NOERROR;
                }
            }
        }
        else if (uc.nScheme == INTERNET_SCHEME_HTTP)
        {
            lpSearchName = uc.lpszHostName;

            // apply search
            // ==========================================================
            if (!lstrcmpi(lpSearchName, "united airline"))
                lpNewName = "www.ual.com";
            else if (!lstrcmpi(lpSearchName, "foo bar"))
                lpNewName = "msw";
            // ==========================================================

            if (lpNewName)
            {
                // if search succeeded
                uc.lpszHostName = lpNewName;
                uc.dwHostNameLength = 0;
    
                dwNeeded = ARRAYSIZE(_szNewUrl);
    
                if (InternetCreateUrl(&uc, 0, _szNewUrl, &dwNeeded))
                    hr = NOERROR;
            }
        }
    }
    else
    {
        DebugBreak();

        DWORD dwError = GetLastError();
    }

    // if (hr == MK_E_SYNTAX)
    if (hr == INET_E_USE_DEFAULT_PROTOCOLHANDLER)
    {
        _pProtSink->ReportResult(hr, 0, 0);
    }

    TransDebugOut((DEB_PROT, "%p OUT CB4Hook::Bind (hr:%lx)\n", this,hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   LookupProtocolClsIDFromReg
//
//  Synopsis:   finds a protocol handler class for a given URL
//
//  Arguments:  [pwzUrl] --
//              [pclsid] --
//
//  Returns:
//
//  History:    11-01-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT LookupProtocolClsIDFromReg(LPCTSTR pszUrl, CLSID *pclsid)
{
    TransDebugOut((DEB_PROT, "API _IN LookupProtocolClsIDFromReg (szUrl >%s< )\n", pszUrl));
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;
    DWORD dwType;
    TCHAR pszProt[MAX_URL_SIZE + 1];

    TransAssert((pszUrl && pclsid));

    if (pszUrl)
    {
        char szDelimiter = ':';

        lstrcpy(pszProt, pszUrl);

        LPSTR pszDel = StrChr(pszProt, szDelimiter);

        if (pszDel)
        {
            *pszDel = '\0';

            // fail if the protocol is "search" so we don't get call recursively.
            if (lstrcmpi(pszProt, SZMYPROTOCOL))
            {
                HKEY hProtocolKey = NULL;
                DWORD dwLen = 256;
                char szProtocolKey[256];

                lstrcpy(szProtocolKey, SZPROTOCOLROOT);
                lstrcat(szProtocolKey, pszProt);
    
                if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szProtocolKey, 0, KEY_QUERY_VALUE, &hProtocolKey) == ERROR_SUCCESS)
                {
                    if (RegQueryValueEx(hProtocolKey, SZCLASS, NULL, &dwType, (LPBYTE)szProtocolKey, &dwLen) == ERROR_SUCCESS)
                    {
                        LPWSTR pwzClsId = DupA2W(szProtocolKey);
    
                        if (pwzClsId)
                        {
                            hr = CLSIDFromString(pwzClsId, pclsid);
                            TransDebugOut((DEB_PROT, "API FOUND LookupProtocolClsIDFromReg(hr:%lx, ClsId:%ws)\n", hr,pwzClsId));
                            delete pwzClsId;
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
    
                    RegCloseKey(hProtocolKey);
                }
            }
        }
        else
        {
            // look up the registry
            hr = MK_E_SYNTAX;
        }
    }

    TransDebugOut((DEB_PROT, "API OUT LookupProtocolClsIDFromReg(hr:%lx)\n", hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\proxy\transmit.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994.
//
//  File:       transmit.h
//
//  Contents:   Function prototypes for STGMEDIUM marshalling.
//
//  Functions:  STGMEDIUM_to_xmit
//              STGMEDIUM_from_xmit
//              STGMEDIUM_free_inst
//
//  History:    May-10-94   ShannonC    Created
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_API STGMEDIUM_to_xmit (STGMEDIUM *pinst, RemSTGMEDIUM **ppxmit);
EXTERN_C void __RPC_API STGMEDIUM_from_xmit (RemSTGMEDIUM __RPC_FAR *pxmit, STGMEDIUM __RPC_FAR *pinst);
EXTERN_C void __RPC_API STGMEDIUM_free_inst(STGMEDIUM *pinst);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\proxy\transmit.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       transmit.cxx
//
//  Contents:   Transmit_as routines for oleprx32.dll.
//
//  Functions:  operator new
//              operator delete
//              EXCEPINFO_to_xmit
//              EXCEPINFO_from_xmit
//              EXCEPINFO_free_inst
//              EXCEPINFO_free_xmit
//              HGLOBAL_to_xmit
//              HGLOBAL_from_xmit
//              HGLOBAL_free_inst
//              HGLOBAL_free_xmit
//              HMETAFILEPICT_to_xmit
//              HMETAFILEPICT_from_xmit
//              HMETAFILEPICT_free_inst
//              HMETAFILEPICT_free_xmit
//              HENHMETAFILE_to_xmit
//              HENHMETAFILE_from_xmit
//              HENHMETAFILE_free_inst
//              HENHMETAFILE_free_xmit
//              HBITMAP_to_xmit
//              HBITMAP_from_xmit
//              HBITMAP_free_inst
//              HBITMAP_free_xmit
//              HBRUSH_to_xmit
//              HBRUSH_from_xmit
//              HBRUSH_free_inst
//              HBRUSH_free_xmit
//              STGMEDIUM_to_xmit
//              STGMEDIUM_from_xmit
//              STGMEDIUM_free_inst
//              STGMEDIUM_free_xmit
//              HACCEL_to_xmit
//              HACCEL_from_xmit
//              HACCEL_free_inst
//              HACCEL_free_xmit
//              UINT_to_xmit
//              UINT_from_xmit
//              UINT_free_inst
//              UINT_free_xmit
//              WPARAM_to_xmit
//              WPARAM_from_xmit
//              WPARAM_free_inst
//              WPARAM_free_xmit
//
//  History:    24-Aug-93   ShannonC    Created
//              24-Nov-93   ShannonC    Added HGLOBAL
//              14-May-94   DavePl      Added HENHMETAFILE
//              18-May-94   ShannonC    Added HACCEL, UINT, WPARAM
//              19-May-94   DavePl      Added HENHMETAFILE to STGMEDIUM code
//              25-May-96   JohannP     Moved to urlmon; minor modifications
//
//--------------------------------------------------------------------------
#include "stdrpc.hxx"
#pragma hdrstop

#include "objbase.h"
#include "transmit.h"
#include "crtsubst.h"

#ifndef _CHICAGO_
    HBRUSH     OleGdiConvertBrush(HBRUSH hbrush);
    HBRUSH     OleGdiCreateLocalBrush(HBRUSH hbrushRemote);
#endif  // _CHICAGO_


void __RPC_USER HENHMETAFILE_to_xmit (HENHMETAFILE __RPC_FAR *pHEnhMetafile,
    RemHENHMETAFILE __RPC_FAR * __RPC_FAR *ppxmit);
void __RPC_USER HENHMETAFILE_from_xmit( RemHENHMETAFILE __RPC_FAR *pxmit,
    HENHMETAFILE __RPC_FAR *pHEnhMetafile );
void __RPC_USER HENHMETAFILE_free_xmit( RemHENHMETAFILE __RPC_FAR *pxmit);
void __RPC_USER HPALETTE_to_xmit (HPALETTE __RPC_FAR *pHPALETTE,
    RemHPALETTE __RPC_FAR * __RPC_FAR *ppxmit);
void __RPC_USER HPALETTE_from_xmit( RemHPALETTE __RPC_FAR *pxmit,
    HPALETTE __RPC_FAR *pHPALETTE );
void __RPC_USER HPALETTE_free_xmit( RemHPALETTE __RPC_FAR *pxmit);
void __RPC_USER HPALETTE_free_inst( HPALETTE __RPC_FAR *pHPALETTE);




WINOLEAPI_(void) ReleaseStgMedium(LPSTGMEDIUM pStgMed);

// BUGBUG: setting NTDEBUG=retail does not build this retail, so i cant
//     use DBG to conditionally generate this code, hence i must
//     disable it for now.
//
// #if DBG==1
// #define Assert(a) ((a) ? NOERROR : FnAssert(#a, NULL, __FILE__, __LINE__))
// #else
#define Assert(a) ((void)0)
// #endif

#pragma code_seg(".orpc")

// we dont need these when we are in with ole32.dll
#if 0
//+-------------------------------------------------------------------------
//
//  Function:  operator new
7//
//  Synopsis:  Override operator new so we don't need C runtime library.
//
//--------------------------------------------------------------------------
void *
_CRTAPI1
operator new (size_t size)
{
    return CoTaskMemAlloc(size);
}


//+-------------------------------------------------------------------------
//
//  Function:  operator delete
//
//  Synopsis:  Override operator delete so we don't need C runtime library.
//
//--------------------------------------------------------------------------
void
_CRTAPI1
operator delete (void * pObj)
{
    CoTaskMemFree(pObj);
}
#endif

//+-------------------------------------------------------------------------
//
//  class:  CPunkForRelease
//
//  purpose:    special IUnknown for remoted STGMEDIUMs
//
//  history:    02-Mar-94   Rickhi      Created
//
//  notes:  This class is used to do the cleanup correctly when certain
//      types of storages are passed between processes or machines
//      in Nt.
//
//      GLOBAL, GDI, and BITMAP handles cannot be passed between
//      processes, so we actually copy the whole data and create a
//      new handle in the receiving process. However, STGMEDIUMs have
//      this weird behaviour where if PunkForRelease is non-NULL then
//      the sender is responsible for cleanup, not the receiver. Since
//      we create a new handle in the receiver, we would leak handles
//      if we didnt do some special processing.  So, we do the
//      following...
//
//          During STGMEDIUM_from_xmit, if there is a pUnkForRelease
//          replace it with a CPunkForRelease.  When Release is called
//          on the CPunkForRelease, do the necessary cleanup work,
//          then call the real PunkForRelease.
//
//+-------------------------------------------------------------------------

class   CPunkForRelease : public IUnknown
{
public:
    CPunkForRelease(STGMEDIUM *pStgMed);

    //  IUnknown Methods
    STDMETHOD(QueryInterface)(REFIID riid, void **ppunk);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

private:
    ~CPunkForRelease(void);

    ULONG       _cRefs;                 //  reference count
    STGMEDIUM   _stgmed;                //  storage medium
    IUnknown  * _pUnkForRelease;        //  real pUnkForRelease
};


inline CPunkForRelease::CPunkForRelease(STGMEDIUM *pStgMed) :
    _cRefs(1),
    _stgmed(*pStgMed)
{
    //  NOTE: we assume the caller has verified pStgMed is not NULL,
    //  and the pUnkForRelease is non-null, otherwise there is no
    //  point in constructing this object.  The tymed must also be
    //  one of the special ones.

    Assert(pStgMed);
    Assert(pStgMed->tymed == TYMED_HGLOBAL ||
       pStgMed->tymed == TYMED_GDI  ||
       pStgMed->tymed == TYMED_MFPICT  ||
       pStgMed->tymed == TYMED_ENHMF);

    _pUnkForRelease = pStgMed->pUnkForRelease;
}


inline CPunkForRelease::~CPunkForRelease()
{
    //  since we really have our own copies of these handles, just
    //  pretend like the callee is responsible for the release, and
    //  recurse into ReleaseStgMedium to do the cleanup.

    _stgmed.pUnkForRelease = NULL;
    ReleaseStgMedium(&_stgmed);

    //  release the callers punk
    _pUnkForRelease->Release();
}

STDMETHODIMP_(ULONG) CPunkForRelease::AddRef(void)
{
    InterlockedIncrement((LONG *)&_cRefs);
    return _cRefs;
}

STDMETHODIMP_(ULONG) CPunkForRelease::Release(void)
{
    if (InterlockedDecrement((LONG *)&_cRefs) == 0)
    {
    delete this;
    return 0;
    }
    else
    return _cRefs;
}

STDMETHODIMP CPunkForRelease::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
    *ppv = (void *)(IUnknown *) this;
    AddRef();
    return S_OK;
    }
    else
    {
    *ppv = NULL;
    return E_NOINTERFACE;
    }
}



#ifdef UNUSED
//+-------------------------------------------------------------------------
//
//  Function:   EXCEPINFO_to_xmit
//
//  Synopsis:   Convert an EXCEPINFO to a RemEXCEPINFO structure so it can be sent
//                              over the network.
//
//--------------------------------------------------------------------------
void __RPC_USER EXCEPINFO_to_xmit (EXCEPINFO *pinst, RemEXCEPINFO **ppxmit)
{
    unsigned int cSource = 0;
    unsigned int cDescription = 0;
    unsigned int cHelpFile = 0;
    unsigned int *pCount;
    wchar_t *pTemp;

    if(pinst->pfnDeferredFillIn)
    {
    //Fill in the EXCEPINFO structure.
    (pinst->pfnDeferredFillIn) (pinst);
    }

    //Calculate the total size of the strings.
    if(pinst->bstrSource)
    {
    pCount = (unsigned int *) pinst->bstrSource;
    pCount--;
    cSource = *pCount;
    }

    if(pinst->bstrDescription)
    {
    pCount = (unsigned int *) pinst->bstrDescription;
    pCount--;
    cDescription = *pCount;
    }

    if(pinst->bstrHelpFile)
    {
    pCount = (unsigned int *) pinst->bstrHelpFile;
    pCount--;
    cHelpFile = *pCount;
    }

    *ppxmit = (RemEXCEPINFO *) NdrOleAllocate(sizeof(RemEXCEPINFO) +
                          ((cSource + cDescription + cHelpFile) * sizeof(wchar_t)));
    (*ppxmit)->wCode = pinst->wCode;
    (*ppxmit)->wReserved = pinst->wReserved;
    (*ppxmit)->dwHelpContext = pinst->dwHelpContext;
    (*ppxmit)->scode = pinst->scode;
    (*ppxmit)->cSource = cSource;
    (*ppxmit)->cDescription = cDescription;
    (*ppxmit)->cHelpFile = cHelpFile;

    pTemp = (*ppxmit)->strings;
    if(pinst->bstrSource)
    {
    memcpy(pTemp, pinst->bstrSource, (*ppxmit)->cSource * sizeof(wchar_t));
    pTemp += cSource;
    }

    if(pinst->bstrDescription)
    {
    memcpy(pTemp, pinst->bstrDescription, (*ppxmit)->cDescription * sizeof(wchar_t));
    pTemp += cDescription;
    }

    if(pinst->bstrHelpFile)
    {
    memcpy(pTemp, pinst->bstrHelpFile, (*ppxmit)->cHelpFile * sizeof(wchar_t));
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   EXCEPINFO_from_xmit
//
//  Synopsis:   Convert a RemEXCEPINFO structure to an EXCEPINFO.
//
//--------------------------------------------------------------------------
void __RPC_USER EXCEPINFO_from_xmit (RemEXCEPINFO *pxmit, EXCEPINFO *pinst)
{
    wchar_t *pTemp;
    unsigned int *pCount;

    pinst->wCode = pxmit->wCode;
    pinst->wReserved = pxmit->wReserved;
    pinst->bstrSource = 0;
    pinst->bstrDescription = 0;
    pinst->bstrHelpFile = 0;
    pinst->dwHelpContext = pxmit->dwHelpContext;
    pinst->pvReserved = 0;
    pinst->pfnDeferredFillIn = 0;
    pinst->scode = pxmit->scode;

    //unmarshal BSTRs
    pTemp = pxmit->strings;

    if(pxmit->cSource)
    {
    pCount = (unsigned int *) NdrOleAllocate(sizeof(int) + pxmit->cSource * sizeof(wchar_t) + sizeof(wchar_t));

    //set the BSTR count.
    *pCount = pxmit->cSource;
    pCount++;
    pinst->bstrSource = (BSTR) pCount;

    //copy the BSTR characters
    memcpy(pinst->bstrSource, pTemp, pxmit->cSource * sizeof(wchar_t));

    //zero-terminate the BSTR.
    pinst->bstrSource[pxmit->cSource] = 0;

    //advance the data pointer.
    pTemp += pxmit->cSource;
    }

    if(pxmit->cDescription)
    {
    pCount = (unsigned int *) NdrOleAllocate(sizeof(int) + pxmit->cDescription * sizeof(wchar_t) + sizeof(wchar_t));

    //set the character count.
    *pCount = pxmit->cDescription;
    pCount++;
    pinst->bstrDescription = (BSTR) pCount;

    //copy the characters
    memcpy(pinst->bstrDescription, pTemp, pxmit->cDescription *sizeof(wchar_t));

    //zero-terminate the BSTR.
    pinst->bstrDescription[pxmit->cDescription] = 0;

    //advance the data pointer.
    pTemp += pxmit->cDescription;
    }

    if(pxmit->cHelpFile)
    {
    pCount = (unsigned int *) NdrOleAllocate(sizeof(int) + pxmit->cHelpFile * sizeof(wchar_t) + sizeof(wchar_t));

    //set the BSTR count.
    *pCount = pxmit->cHelpFile;
    pCount++;
    pinst->bstrHelpFile = (BSTR) pCount;

    //copy the BSTR characters
    memcpy(pinst->bstrHelpFile, pTemp, pxmit->cHelpFile * sizeof(wchar_t));

    //zero-terminate the BSTR.
    pinst->bstrHelpFile[pxmit->cHelpFile] = 0;

    //advance the data pointer.
    pTemp += pxmit->cHelpFile;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   EXCEPINFO_free_inst
//
//  Synopsis:   Free the contents of an EXCEPINFO structure.
//
//--------------------------------------------------------------------------
void __RPC_USER EXCEPINFO_free_inst (EXCEPINFO *pinst)
{
    unsigned int *pInt;

    if(pinst)
    {
    if(pinst->bstrSource)
    {
        pInt = (unsigned int *) pinst->bstrSource;
        pInt--;
        NdrOleFree(pInt);
    }

    if(pinst->bstrDescription)
    {
        pInt = (unsigned int *) pinst->bstrDescription;
        pInt--;
        NdrOleFree(pInt);
    }

    if(pinst->bstrHelpFile)
    {
        pInt = (unsigned int *) pinst->bstrHelpFile;
        pInt--;
        NdrOleFree(pInt);
    }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   EXCEPINFO_free_xmit
//
//  Synopsis:   Free a RemEXCEPINFO previously obtained via EXCEPINFO_to_xmit.
//
//--------------------------------------------------------------------------
void __RPC_USER EXCEPINFO_free_xmit (RemEXCEPINFO *pxmit)
{
    if(pxmit)
    {
    NdrOleFree(pxmit);
    }
}

#endif //UNUSED
//+-------------------------------------------------------------------------
//
//  Function:   HGLOBAL_to_xmit
//
//  Synopsis:   Convert an HGLOBAL to a RemHGLOBAL structure so it can be sent
//              over the network.
//
//  Derivation: We get the size of the global memory block,
//              allocate a RemHGLOBAL structure, then copy the contents
//              of the global memory block into the RemHGLOBAL structure.
//
//--------------------------------------------------------------------------

void __RPC_USER HGLOBAL_to_xmit (HGLOBAL *pinst, RemHGLOBAL **ppxmit)
{
    HGLOBAL hGlobal = *pinst;

    //calculate size - we give a null hGlobal a size of zero
    DWORD cbData = (DWORD) ((hGlobal)?GlobalSize(hGlobal):0);

    //allocate memory
    *ppxmit = (RemHGLOBAL *) NdrOleAllocate(sizeof(RemHGLOBAL) + cbData);

    // save size of variable length data
    (*ppxmit)->cbData = cbData;

    if (hGlobal != NULL)
    {
    // There is an hglobal to transmit
    (*ppxmit)->fNullHGlobal = FALSE;

    // Remember that an HGLOBAL can be alloc'd to zero size. So we
    // check whether there is anything to copy.
    if (cbData != 0)
    {
        // Copy the data
        void *pData = GlobalLock(hGlobal);
        memcpy((*ppxmit)->data, pData, cbData);
        GlobalUnlock(hGlobal);
    }
    }
    else
    {
    (*ppxmit)->fNullHGlobal = TRUE;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   HGLOBAL_from_xmit
//
//  Synopsis:   Convert a RemHGLOBAL structure to an HGLOBAL.
//
//  Derivation: We get the data size, allocate a global memory block,
//                              then copy the data from the RemHGLOBAL structure to
//                              the global memory block.
//
//--------------------------------------------------------------------------
void __RPC_USER HGLOBAL_from_xmit (RemHGLOBAL __RPC_FAR *pxmit, HGLOBAL __RPC_FAR *pinst)
{
    // Default to NULL hglobal
    HGLOBAL hGlobal = NULL;
    void *pData;

    //allocate memory
    if (!pxmit->fNullHGlobal)
    {
    hGlobal = GlobalAlloc(GMEM_MOVEABLE, pxmit->cbData);

    if(hGlobal)
    {
        //copy the data
        pData = GlobalLock(hGlobal);
        if(pData)
        {
        memcpy(pData, pxmit->data, pxmit->cbData);
        GlobalUnlock(hGlobal);
        }
    }
    else
    {
        RpcRaiseException(E_OUTOFMEMORY);
    }
    }

    *pinst = hGlobal;
}

//+-------------------------------------------------------------------------
//
//  Function:   HGLOBAL_free_inst
//
//  Synopsis:   Free an HGLOBAL.
//
//--------------------------------------------------------------------------
void __RPC_USER HGLOBAL_free_inst(HGLOBAL *pinst)
{
    if(pinst)
    {
    if(*pinst)
    {
        GlobalFree(*pinst);
    }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   HGLOBAL_free_xmit
//
//  Synopsis:   Free a RemHGLOBAL previously obtained via HGLOBAL_to_xmit.
//
//--------------------------------------------------------------------------
void __RPC_USER HGLOBAL_free_xmit(RemHGLOBAL *pxmit)
{
    if(pxmit != 0)
        NdrOleFree(pxmit);
}


//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_to_xmit
//
//  Synopsis:   Converts a metafilepict handle into a global handle
//              that can be remoted
//
//  Arguments:  [pHMetafilePict]-- pointer to the original metafile handle
//              [ppxmit]        -- set to point to the transmitted value
//
//  Returns:    void
//
//  Algorithm:  calls a private gdi api to convert the handle
//
//  History:    16-Nov-93 alexgo    created
//              07-Jan-94 rickhi    copy the metafile
//
//  Notes:
//
//--------------------------------------------------------------------------

void __RPC_USER HMETAFILEPICT_to_xmit (HMETAFILEPICT __RPC_FAR *pHMetafilePict,
    RemHMETAFILEPICT __RPC_FAR * __RPC_FAR *ppxmit)
{
#ifdef NEW_GDI_MARSHALLING
    //  CODEWORK: we can use this in the Daytona and Local Cairo case,
    //            but not in Chicago or remote Cairo

    //calculate size
    DWORD cbData = sizeof(long);

    //allocate memory
    *ppxmit = (RemHMETAFILEPICT *) NdrOleAllocate(sizeof(RemHMETAFILEPICT) + cbData);

    if (*ppxmit)
    {
    //copy data
    (*ppxmit)->cbData = cbData;
    // BUGBUG: enable this code!
    //long lData = (long)OleGdiConvertMetaFilePict(*(HANDLE *)pHMetafilePict);

    memcpy((*ppxmit)->data, &lData, cbData);
    }
    else
    {
    RpcRaiseException(E_OUTOFMEMORY);
    }

#else

    //  lock the data
    METAFILEPICT *pmfp = (METAFILEPICT *)GlobalLock(*(HANDLE *)pHMetafilePict);

    if (pmfp)
    {
    // calculate the size needed to hold the windows metafile
    DWORD cbData = GetMetaFileBitsEx(pmfp->hMF, 0, NULL);

    // allocate memory
    *ppxmit = (RemHMETAFILEPICT *) NdrOleAllocate(sizeof(RemHMETAFILEPICT) + cbData);

    // copy data
    (*ppxmit)->cbData = cbData;
    (*ppxmit)->mm     = pmfp->mm;
    (*ppxmit)->xExt   = pmfp->xExt;
    (*ppxmit)->yExt   = pmfp->yExt;

    GetMetaFileBitsEx(pmfp->hMF, cbData, &((*ppxmit)->data[0]));

    GlobalUnlock(*(HANDLE *)pHMetafilePict);
    }
    else
    {
    RpcRaiseException(E_OUTOFMEMORY);
    }

#endif
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_from_xmit
//
//  Synopsis:   Converts a global metafilepict handle into a metafile
//              handle that a process can use
//
//  Arguments:  [pxmit]         -- the transmitted global handle
//              [pHMetafilePict]-- where to put the local metafilepict handle
//
//  Returns:    void
//
//  Algorithm:  calls a private gdi api to convert the global handle
//
//  History:    16-Nov-93 alexgo    created
//              07-Jan-94 rickhi    copy the metafile
//
//  Notes:
//
//--------------------------------------------------------------------------

void __RPC_USER HMETAFILEPICT_from_xmit( RemHMETAFILEPICT __RPC_FAR *pxmit,
    HMETAFILEPICT __RPC_FAR *pHMetafilePict )
{
#ifdef  NEW_GDI_MARSHALLLING
    //  CODEWORK: we can use this in the Daytona and Local Cairo case,
    //            but not in Chicago or remote Cairo

    long lh;
    memcpy(&lh, pxmit->data, pxmit->cbData);
    *pHMetafilePict = (HMETAFILE)GdiCreateLocalMetaFilePict(
                (HANDLE)lh);
#else

    // allocate memory
    HGLOBAL hGlobal = GlobalAlloc(GMEM_MOVEABLE, sizeof(METAFILEPICT));
    *pHMetafilePict = hGlobal;

    if(hGlobal)
    {
    //copy the data
    METAFILEPICT *pmfp = (METAFILEPICT *)GlobalLock(hGlobal);
    if(pmfp)
    {
        pmfp->mm     = pxmit->mm;
        pmfp->xExt   = pxmit->xExt;
        pmfp->yExt   = pxmit->yExt;

        //  create a windows metatfile from the data
        pmfp->hMF = SetMetaFileBitsEx(pxmit->cbData, pxmit->data);
        GlobalUnlock(hGlobal);
    }
    }
    else
    {
    RpcRaiseException(E_OUTOFMEMORY);
    }

#endif
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_free_xmit
//
//  Synopsis:   Free's the global metafilepict handle that gets remoted
//
//  Arguments:  [pxmit]         -- the transmitted metafilepict handle
//
//  Returns:    void
//
//  History:    16-Nov-93 alexgo    created
//
//  Notes:
//
//--------------------------------------------------------------------------

void __RPC_USER HMETAFILEPICT_free_xmit( RemHMETAFILEPICT __RPC_FAR *pxmit)
{
    if(pxmit != 0)
        NdrOleFree(pxmit);
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_free_inst
//
//  Synopsis:   does nothing, as no memory is allocated
//
//  Arguments:  [pHMetafilePict]        -- pointer to the metafilepict
//
//  Returns:    void
//
//  Algorithm:
//
//  History:    16-Nov-93 alexgo    created
//
//  Notes:
//
//--------------------------------------------------------------------------

void __RPC_USER HMETAFILEPICT_free_inst( HMETAFILEPICT __RPC_FAR *pHMetafilePict)
{
    METAFILEPICT *pmf;

    if(*pHMetafilePict)
    {
    pmf = (METAFILEPICT *) GlobalLock(*pHMetafilePict);
    if(pmf)
    {
        DeleteMetaFile(pmf->hMF);
        GlobalUnlock(*pHMetafilePict);
    }
    GlobalFree(*pHMetafilePict);
    }
}


#ifndef NEW_GDI_MARSHALLLING
//+-------------------------------------------------------------------------
//
//  Function:   GetColorTableSize
//
//  Synopsis:   computes the size of the color table using the info in
//      the supplied BITMAPINFO
//
//  Arguments:  [pbmi]   -- pointer to the BITMAPINFO for the bitmap
//
//  Returns:    size of the color table
//
//+-------------------------------------------------------------------------

ULONG  GetColorTableSize(BITMAPINFO *pbmi)
{
    // compute size of memory needed. it must account for the header
    // info, color table, and bitmap, as well as the RemHBITMAP.

    ULONG ulColorTableSize;
    if (pbmi->bmiHeader.biClrUsed)
    {
    // biClrUsed contains number of RGBQUADs used
    ulColorTableSize = pbmi->bmiHeader.biClrUsed;
    }
    else if (pbmi->bmiHeader.biCompression == BI_BITFIELDS)
    {
    // size is 3 DWORD color masks. sizeof(DWORD) == sizeof(RGBQUAD)
    ulColorTableSize = 3;
    }
    else
    {
    // compute number of RGBQUADs from biBitCount
    ulColorTableSize = (pbmi->bmiHeader.biBitCount == 24) ? 0 :
               (1<<pbmi->bmiHeader.biBitCount);
    }

    return (ulColorTableSize * sizeof(RGBQUAD));
}
#endif


//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_to_xmit
//
//  Synopsis:   Converts a bitmap handle into a global handle
//              that can be remoted
//
//  Arguments:  [pBitmap]       -- pointer to the original bitmap handle
//              [ppxmit]        -- set to point to the transmitted value
//
//  Returns:    void
//
//  Algorithm:  calls a private gdi api to convert the handle
//
//  History:    16-Nov-93 alexgo    created
//              07-Jan-94 rickhi    copy the bitmap
//              12-Aug-94 davepl    Rewrote OLD_GDI_MARSHALLING section
//
//  Notes:      CODEWORK: this code specifically does not account for OS2
//              style DIBs.  Verify this is OK.  Unless the Windows APIs
//              deal with OS2 bitmaps on their own...
//
//--------------------------------------------------------------------------

void __RPC_USER HBITMAP_to_xmit (HBITMAP __RPC_FAR *pBitmap,
    RemHBITMAP __RPC_FAR * __RPC_FAR *ppxmit)
{
#ifdef  NEW_GDI_MARSHALLLING
    //  CODEWORK: we can use this in the Daytona and Local Cairo case,
    //            but not in Chicago or remote Cairo

    //calculate size
    DWORD cbData = sizeof(long);

    //allocate memory
    *ppxmit = (RemHBITMAP *) NdrOleAllocate(sizeof(RemHBITMAP) + cbData);

    if (*ppxmit)
    {
    //copy data
    (*ppxmit)->cbData = cbData;
    long lData = (long)GdiConvertBitmap(*pBitmap);
    memcpy((*ppxmit)->data, &lData, cbData);
    }
    else
    {
    RpcRaiseException(E_OUTOFMEMORY);
    }

#else

    BITMAP bm;
    HBITMAP hBitmap = (HBITMAP) * pBitmap;

    // Get information about the bitmap

#if defined(_CHICAGO_)
    if (FALSE == GetObjectA(hBitmap, sizeof(BITMAP), &bm))
#else
    if (FALSE == GetObject(hBitmap, sizeof(BITMAP), &bm))
#endif
    {
        RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
    }

    // Allocate space for the raw bitmap bits and the bm structure, plus
    // the RemHBITMAP structure all at once.

    DWORD dwCount = bm.bmPlanes * bm.bmHeight * bm.bmWidthBytes;
    *ppxmit = (RemHBITMAP *) (BYTE *) NdrOleAllocate(sizeof(RemHBITMAP)
                                                     + dwCount + sizeof(bm));

    if (NULL == *ppxmit)
    {
        RpcRaiseException(E_OUTOFMEMORY);
    }

    // lpBits points to the portion of the RemHBITMAP structure where
    // we will store the BITMAP structure and raw bits

    BYTE * lpBits = (BYTE *) &(*ppxmit)->data[0];

    // Get the raw bits.  Offset sizeof(BITMAP) into the buffer so
    // that we can stick the BITMAP struct at the front before
    // transmission

    if (0 == GetBitmapBits(hBitmap, dwCount, lpBits + sizeof(bm)))
    {
        NdrOleFree(*ppxmit);
        *ppxmit = NULL;
        RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
    }

    // Stuff the bm structure in before the bits

    memcpy(lpBits, (void *) &bm, sizeof(bm));

    (*ppxmit)->cbData = dwCount + sizeof(bm);

#endif
}

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_from_xmit
//
//  Synopsis:   Converts a global bitmap handle into a bitmap
//              handle that a process can use
//
//  Arguments:  [pxmit]         -- the transmitted global handle
//              [pBitmap]       -- where to put the local bitmap handle
//
//  Returns:    void
//
//  Algorithm:  Creates a local bitmap and then associates the remote
//              bitmap with the local one.
//
//  History:    16-Nov-93 alexgo    created
//              07-Jan-94 rickhi    copy the bitmap
//              12-Aug-94 davepl    rewrote the OLD_GDI_MARSHALLING section
//
//  Notes:
//
//--------------------------------------------------------------------------

void __RPC_USER HBITMAP_from_xmit( RemHBITMAP __RPC_FAR *pxmit,
    HBITMAP __RPC_FAR *pBitmap )
{
#ifdef  NEW_GDI_MARSHALLLING
    //  CODEWORK: we can use this in the Daytona and Local Cairo case,
    //            but not in Chicago or remote Cairo

    ULONG hLocal = (ULONG)GdiCreateLocalBitmap();

    ULONG lh;
    memcpy(&lh, pxmit->data, pxmit->cbData);

    GdiAssociateObject(hLocal, lh);
    *pBitmap = (HBITMAP)hLocal;

#else

    BITMAP * pbm    = (BITMAP *) &(pxmit->data[0]);
    BYTE   * lpBits = ((BYTE *) pbm) + sizeof(BITMAP);

    // Create a bitmap based on the BITMAP structure and the raw bits in
    // the transmission buffer

    *pBitmap = CreateBitmap(pbm->bmWidth,
                            pbm->bmHeight,
                            pbm->bmPlanes,
                            pbm->bmBitsPixel,
                            (void *) lpBits);

    // If no bitmap came back, raise an exception rather than just returning

    if (NULL == *pBitmap)
    {
        RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
    }


#endif
}

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_free_xmit
//
//  Synopsis:   Free's the buffer used to serialize the bitmap
//
//  Effects:
//
//  Arguments:  [pxmit]         -- the transmitted bitmap serialized buffer
//
//  Returns:    void
//
//  History:    dd-mmm-yy Author    Comment
//              16-Nov-93 alexgo    created
//
//  Notes:
//
//--------------------------------------------------------------------------

void __RPC_USER HBITMAP_free_xmit( RemHBITMAP __RPC_FAR *pxmit)
{
    if(pxmit != 0)
        NdrOleFree(pxmit);
}

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_free_inst
//
//  Synopsis:   Destroys the bitmap object
//
//  Arguments:  [pBitmap]       -- pointer to the bitmap handle
//
//  Returns:    void
//
//  History:    dd-mmm-yy Author    Comment
//              16-Nov-93 alexgo    created
//
//  Notes:
//
//--------------------------------------------------------------------------

void __RPC_USER HBITMAP_free_inst( HBITMAP __RPC_FAR *pBitmap)
{
    DeleteObject(*pBitmap);
}


//+-------------------------------------------------------------------------
//
//  Function:   HBRUSH_to_xmit
//
//  Synopsis:   Converts a brush handle into a global handle
//              that can be remoted
//
//  Arguments:  [pBrush]        -- pointer to the original brush handle
//              [ppxmit]        -- set to point to the transmitted value
//
//  Returns:    void
//
//  Algorithm:  calls a private gdi api to convert the handle
//
//  History:    dd-mmm-yy Author    Comment
//              16-Nov-93 alexgo    created
//
//  Notes:
//
//--------------------------------------------------------------------------

void __RPC_USER HBRUSH_to_xmit (HBRUSH __RPC_FAR *pBrush,
    RemHBRUSH __RPC_FAR * __RPC_FAR *ppxmit)
{
#ifndef _CHICAGO_
    //  CODEWORK: we can use this in the Daytona and Local Cairo case,
    //            but not in Chicago or remote Cairo

    //calculate size
    DWORD cbData = sizeof(long);

    //allocate memory
    *ppxmit = (RemHBRUSH *) NdrOleAllocate(sizeof(RemHBRUSH) + cbData);

    if (*ppxmit)
    {
    //copy data
    (*ppxmit)->cbData = cbData;

    // BUGBUG: enable this code!
    //long lData = (long)OleGdiConvertBrush(*pBrush);
    //memcpy((*ppxmit)->data, &lData, cbData);
    }
    else
    {
    RpcRaiseException(E_OUTOFMEMORY);
    }
#endif
}

//+-------------------------------------------------------------------------
//
//  Function:   HBRUSH_from_xmit
//
//  Synopsis:   Converts a global brush handle into a brush
//              handle that a process can use
//
//  Arguments:  [pxmit]         -- the transmitted global handle
//              [pBrush]        -- where to put the local brush handle
//
//  Returns:    void
//
//  Algorithm:  calls a private gdi api to convert the global handle
//
//  History:    dd-mmm-yy Author    Comment
//              16-Nov-93 alexgo    created
//
//  Notes:
//
//--------------------------------------------------------------------------

void __RPC_USER HBRUSH_from_xmit( RemHBRUSH __RPC_FAR *pxmit,
    HBRUSH __RPC_FAR *phBrush )
{
#ifndef _CHICAGO_
    //  CODEWORK: we can use this in the Daytona and Local Cairo case,
    //            but not in Chicago or remote Cairo

    // BUGBUG: enable this code!
    //*phBrush = OleGdiCreateLocalBrush((HBRUSH)(pxmit->data));
    *phBrush = NULL;

#endif
}

//+-------------------------------------------------------------------------
//
//  Function:   HBRUSH_free_xmit
//
//  Synopsis:   Free's the global brush handle that gets remoted
//
//  Arguments:  [pxmit]         -- the transmitted brush handle
//
//  Returns:    void
//
//  History:    dd-mmm-yy Author    Comment
//              16-Nov-93 alexgo    created
//
//  Notes:
//
//--------------------------------------------------------------------------

void __RPC_USER HBRUSH_free_xmit( RemHBRUSH __RPC_FAR *pxmit)
{
#ifndef _CHICAGO_
    if(pxmit != 0)
        NdrOleFree(pxmit);
#endif
}

//+-------------------------------------------------------------------------
//
//  Function:   HBRUSH_free_inst
//
//  Synopsis:   Delete an HBRUSH.
//
//  Arguments:  [pBrush]        -- pointer to the metafile
//
//  Returns:    void
//
//  History:    dd-mmm-yy Author    Comment
//              16-Nov-93 alexgo    created
//
//  Notes:
//
//--------------------------------------------------------------------------

void __RPC_USER HBRUSH_free_inst( HBRUSH __RPC_FAR *pBrush)
{
#ifndef _CHICAGO_
    DeleteObject(*pBrush);
#endif
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CStreamOnMessage::AddRef( THIS )
{
  return ref_count += 1;
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Clone(THIS_ IStream * *ppstm)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Commit(THIS_ DWORD grfCommitFlags)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::CopyTo(THIS_ IStream *pstm,
                  ULARGE_INTEGER cb,
                  ULARGE_INTEGER *pcbRead,
                  ULARGE_INTEGER *pcbWritten)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
CStreamOnMessage::CStreamOnMessage(unsigned char **ppMessageBuffer)
    : ref_count(1), ppBuffer(ppMessageBuffer), cbMaxStreamLength(0xFFFFFFFF)
{
    pStartOfStream = *ppMessageBuffer;
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::LockRegion(THIS_ ULARGE_INTEGER libOffset,
                  ULARGE_INTEGER cb,
                  DWORD dwLockType)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
  if (IsEqualIID(riid, IID_IUnknown))
  {
    *ppvObj = (IUnknown *) this;
    ref_count += 1;
    return ResultFromScode(S_OK);
  }
  else if (IsEqualIID(riid, IID_IStream))
  {
    *ppvObj = (IStream *) this;
    ref_count += 1;
    return ResultFromScode(S_OK);
  }
  else
    return ResultFromScode(E_NOINTERFACE);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Read(THIS_ VOID HUGEP *pv,
                  ULONG cb, ULONG *pcbRead)
{
  memcpy( pv, *ppBuffer, cb );
  *ppBuffer += cb;
  if (pcbRead != NULL)
    *pcbRead = cb;
  return ResultFromScode(S_OK);
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CStreamOnMessage::Release( THIS )
{
  ref_count -= 1;
  if (ref_count == 0)
  {
    delete this;
    return 0;
  }
  else
    return ref_count;

}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Revert(THIS)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Seek(THIS_ LARGE_INTEGER dlibMove,
                  DWORD dwOrigin,
                  ULARGE_INTEGER *plibNewPosition)
{
  ULONG   pos;

  // Verify that the offset isn't out of range.
  if (dlibMove.HighPart != 0)
    return ResultFromScode( E_FAIL );

  // Determine the new seek pointer.
  switch (dwOrigin)
  {
    case STREAM_SEEK_SET:
      pos = dlibMove.LowPart;
      break;

    case STREAM_SEEK_CUR:
      /* Must use signed math here. */
      pos = (ULONG) (*ppBuffer - pStartOfStream);
      if ((long) dlibMove.LowPart < 0 &&
      pos < (unsigned long) - (long) dlibMove.LowPart)
    return ResultFromScode( E_FAIL );
      pos += (long) dlibMove.LowPart;
      break;

    case STREAM_SEEK_END:
        return ResultFromScode(E_NOTIMPL);
    break;

    default:
      return ResultFromScode( E_FAIL );
  }

  // Set the seek pointer.
  *ppBuffer = pStartOfStream + pos;
  if (plibNewPosition != NULL)
  {
    plibNewPosition->LowPart = pos;
    plibNewPosition->HighPart = 0;
  }
  return ResultFromScode(S_OK);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::SetSize(THIS_ ULARGE_INTEGER libNewSize)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Stat(THIS_ STATSTG *pstatstg, DWORD grfStatFlag)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::UnlockRegion(THIS_ ULARGE_INTEGER libOffset,
                  ULARGE_INTEGER cb,
                  DWORD dwLockType)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Write(THIS_ VOID const HUGEP *pv,
                  ULONG cb,
                  ULONG *pcbWritten)
{
  // Write the data.
  memcpy( *ppBuffer, pv, cb );
  if (pcbWritten != NULL)
    *pcbWritten = cb;
  *ppBuffer += cb;
  return ResultFromScode(S_OK);
}


//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_to_xmit
//
//  Synopsis:   Convert an STGMEDIUM to a RemSTGMEDIUM structure so it can be sent
//                              over the network.
//
//                              The marshalled STGMEDIUM looks like this:
//                              RemSTGMEDIUM | data from union | data from pUnkForRelease
//--------------------------------------------------------------------------

void __RPC_USER STGMEDIUM_to_xmit (STGMEDIUM *pinst, RemSTGMEDIUM **ppxmit)
{
    unsigned char *pData;
    RemHGLOBAL *pRemHGLOBAL;
    RemHBITMAP *pRemHBITMAP;
    RemHPALETTE *pRemHPALETTE;
    RemHMETAFILEPICT *pRemHMETAFILEPICT;
    RemHENHMETAFILE *pRemHENHMETAFILE;

    long size;
    unsigned long count;
    unsigned long cbInterface;
    HRESULT hr = S_OK;
    DWORD *pcbData;
    DWORD *pcbSize;
    DWORD cbData;
    unsigned char *pStart;

    // If the TYMED for the STGMEDIUM is TYMED_GDI, we need a bit more information
    // (ie: what _kind_ of GDI object it is).  The field is unused for anything
    // except TYMED_GDI

    DWORD dwHandleType = 0;

    //calculate size of marshalled STGMEDIUM.
    size = sizeof(RemSTGMEDIUM);

    //add the size of data[].
    switch(pinst->tymed)
    {
    case TYMED_NULL:
        break;
    case TYMED_MFPICT:
        HMETAFILEPICT_to_xmit(&pinst->hMetaFilePict, &pRemHMETAFILEPICT);
        size += sizeof(RemHMETAFILEPICT) + pRemHMETAFILEPICT->cbData;
        break;
    case TYMED_ENHMF:
        HENHMETAFILE_to_xmit(&pinst->hEnhMetaFile, &pRemHENHMETAFILE);
        size += sizeof(RemHENHMETAFILE) + pRemHENHMETAFILE->cbData;
        break;
    case TYMED_GDI:

        // A GDI object is not necesarrily a BITMAP.  Therefore, we handle
        // those types we know about based on the object type, and reject
        // those which we do not support.

        switch(GetObjectType( (HGDIOBJ) pinst->hGlobal ))
        {
            case OBJ_BITMAP:

                HBITMAP_to_xmit(&pinst->hBitmap, &pRemHBITMAP);
                size += sizeof(RemHBITMAP) + pRemHBITMAP->cbData;
                dwHandleType = OBJ_BITMAP;
                break;

            case OBJ_PAL:

                HPALETTE_to_xmit((HPALETTE *) &pinst->hBitmap, &pRemHPALETTE);
                size += sizeof(RemHPALETTE) + pRemHPALETTE->cbData;
                dwHandleType = OBJ_PAL;
                break;

            default:
                RpcRaiseException(DV_E_TYMED);
        }
        break;

    case TYMED_HGLOBAL:
        HGLOBAL_to_xmit(&pinst->hGlobal, &pRemHGLOBAL);
        size += sizeof(RemHGLOBAL) + pRemHGLOBAL->cbData;
        break;
    case TYMED_FILE:
        count = wcslen(pinst->lpszFileName) + 1;
        size += 4; //allocate room for character count.
        size += count * sizeof(wchar_t);
        break;
    case TYMED_ISTREAM:
        size += 4;
        if(pinst->pstm)
        {
            //Align the buffer on an 4 byte boundary.
            size += 3;
            size &= (unsigned int)0xfffffffc;

            //Allocate space for the length and array bounds.
            size += 8;

            hr = CoGetMarshalSizeMax(&cbInterface, IID_IStream, pinst->pstm, MSHCTX_LOCAL, 0, MSHLFLAGS_NORMAL);
            if(hr == S_OK)
            size += cbInterface;
        }
        break;
    case TYMED_ISTORAGE:
        size += 4;
        if(pinst->pstg)
        {
            //Align the buffer on an 4 byte boundary.
            size += 3;
            size &= (unsigned int)0xfffffffc;

            //Allocate space for the length and array bounds.
            size += 8;

            hr = CoGetMarshalSizeMax(&cbInterface, IID_IStorage, pinst->pstg, MSHCTX_LOCAL, 0, MSHLFLAGS_NORMAL);
            if(hr == S_OK)
            size += cbInterface;
        }
        break;
    default:
        break;
    }


    //Allocate space for pUnkForRelease.
    if(pinst->pUnkForRelease)
    {
        //Align the buffer on an 4 byte boundary.
        size += 3;
        size &= (unsigned int)0xfffffffc;

        //Allocate space for the length and array bounds.
        size += 8;

        hr = CoGetMarshalSizeMax(&cbInterface, IID_IUnknown, pinst->pUnkForRelease, MSHCTX_NOSHAREDMEM, 0, MSHLFLAGS_NORMAL);
    if(hr == S_OK)
    {
        size += cbInterface;
    }
    }

    //allocate memory
    *ppxmit = (RemSTGMEDIUM *) NdrOleAllocate(size);

    //Marshal STGMEDIUM
    (*ppxmit)->tymed = pinst->tymed;
    //SUNDOWN: typecast problem
    (*ppxmit)->pData = PtrToUlong(pinst->hGlobal);
    (*ppxmit)->pUnkForRelease = PtrToUlong(pinst->pUnkForRelease);
    (*ppxmit)->cbData = size - sizeof(RemSTGMEDIUM);
    (*ppxmit)->dwHandleType = dwHandleType;

    pData = (*ppxmit)->data;

    switch(pinst->tymed)
    {
    case TYMED_NULL:
        break;
    case TYMED_MFPICT:
        //Note that we called HMETAFILEPICT_to_xmit earlier so we could
        //get the size.
        memcpy(pData, pRemHMETAFILEPICT, sizeof(RemHMETAFILEPICT) + pRemHMETAFILEPICT->cbData);
        pData += sizeof(RemHMETAFILEPICT) + pRemHMETAFILEPICT->cbData;
        HMETAFILEPICT_free_xmit(pRemHMETAFILEPICT);
        break;
    case TYMED_ENHMF:
        memcpy(pData, pRemHENHMETAFILE, sizeof(RemHENHMETAFILE) + pRemHENHMETAFILE->cbData);
        pData += sizeof(RemHENHMETAFILE) + pRemHENHMETAFILE->cbData;
        HENHMETAFILE_free_xmit(pRemHENHMETAFILE);
        break;
    case TYMED_HGLOBAL:
        //Note that we called HGLOBAL_to_xmit earlier so we could
        //get the size.
        memcpy(pData, pRemHGLOBAL, sizeof(RemHGLOBAL) + pRemHGLOBAL->cbData);
    pData += sizeof(RemHGLOBAL) + pRemHGLOBAL->cbData;
        HGLOBAL_free_xmit(pRemHGLOBAL);
        break;

    case TYMED_GDI:

        switch(dwHandleType)
        {
        case OBJ_BITMAP:

            memcpy(pData, pRemHBITMAP, sizeof(RemHBITMAP) + pRemHBITMAP->cbData);
            pData += sizeof(RemHBITMAP) + pRemHBITMAP->cbData;
            HBITMAP_free_xmit(pRemHBITMAP);
            break;

        case OBJ_PAL:

            memcpy(pData, pRemHPALETTE, sizeof(RemHPALETTE) + pRemHPALETTE->cbData);
            pData += sizeof(RemHPALETTE) + pRemHPALETTE->cbData;
            HPALETTE_free_xmit(pRemHPALETTE);
        }

        break;

    case TYMED_FILE:
        //copy the length.
        memcpy(pData, &count, sizeof(count));
        pData += sizeof(count);

        //copy the string.
    memcpy(pData, pinst->lpszFileName, count * sizeof(wchar_t));
        pData += count * sizeof(wchar_t);
        break;
    case TYMED_ISTREAM:
        if(pinst->pstm)
        {
            CStreamOnMessage stream((unsigned char **) &pData);

            //Align the buffer on an 4 byte boundary
            *(unsigned long FAR *)&pData += 3;
            *(unsigned long FAR *)&pData &= 0xfffffffc;

            //Leave space for cbData.
            pcbData = (DWORD *) pData;
            *(unsigned long FAR *)&pData += 4;

            //Leave space for size.
            pcbSize = (DWORD *) pData;
        *(unsigned long FAR *)&pData += 4;

            pStart = (unsigned char *) pData;

            hr = CoMarshalInterface(&stream, IID_IStream, pinst->pstm, MSHCTX_LOCAL, 0, MSHLFLAGS_NORMAL);
            if(hr != S_OK)
            {
                RpcRaiseException(hr);
            }

            cbData = (DWORD) (pData - pStart);
            *pcbData = cbData;
            *pcbSize = cbData;
        }
        break;
    case TYMED_ISTORAGE:
        if(pinst->pstg)
        {
            CStreamOnMessage stream((unsigned char **) &pData);

            //Align the buffer on an 4 byte boundary
            *(unsigned long FAR *)&pData += 3;
            *(unsigned long FAR *)&pData &= 0xfffffffc;

            //Leave space for cbData.
            pcbData = (DWORD *) pData;
            *(unsigned long FAR *)&pData += 4;

            //Leave space for size.
            pcbSize = (DWORD *) pData;
            *(unsigned long FAR *)&pData += 4;

            pStart = (unsigned char *) pData;

            hr = CoMarshalInterface(&stream, IID_IStorage, pinst->pstg, MSHCTX_LOCAL, 0, MSHLFLAGS_NORMAL);
            if(hr != S_OK)
            {
                RpcRaiseException(hr);
            }

            cbData = (DWORD) (pData - pStart);
            *pcbData = cbData;
            *pcbSize = cbData;
        }
        break;
    default:
        break;
    }


    if(pinst->pUnkForRelease)
    {
        CStreamOnMessage stream((unsigned char **) &pData);

        //Align the buffer on an 4 byte boundary
        *(unsigned long FAR *)&pData += 3;
        *(unsigned long FAR *)&pData &= 0xfffffffc;

        //Leave space for cbData.
        pcbData = (DWORD *) pData;
        *(unsigned long FAR *)&pData += 4;

        //Leave space for size.
        pcbSize = (DWORD *) pData;
        *(unsigned long FAR *)&pData += 4;

        pStart = (unsigned char *) pData;

        hr = CoMarshalInterface(&stream, IID_IUnknown, pinst->pUnkForRelease, MSHCTX_NOSHAREDMEM, 0, MSHLFLAGS_NORMAL);
        if(hr != S_OK)
        {
            RpcRaiseException(hr);
        }

        cbData = (DWORD) (pData - pStart);
        *pcbData = cbData;
        *pcbSize = cbData;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_from_xmit
//
//  Synopsis:   Convert a RemSTGMEDIUM structure to an STGMEDIUM.
//
//--------------------------------------------------------------------------
void __RPC_USER STGMEDIUM_from_xmit (RemSTGMEDIUM __RPC_FAR *pxmit, STGMEDIUM __RPC_FAR *pinst)
{
    HRESULT hr = S_OK;
    unsigned char *pData;

    pinst->tymed = pxmit->tymed;
    pData = pxmit->data;

    switch(pinst->tymed)
    {
    case TYMED_NULL:
    break;

    case TYMED_MFPICT:
    HMETAFILEPICT_from_xmit((RemHMETAFILEPICT *)pData, &pinst->hMetaFilePict);
    pData += sizeof(RemHMETAFILEPICT) + ((RemHMETAFILEPICT *)pData)->cbData;
    break;

    case TYMED_ENHMF:
    HENHMETAFILE_from_xmit((RemHENHMETAFILE *)pData, &pinst->hEnhMetaFile);
    pData += sizeof(RemHENHMETAFILE) + ((RemHENHMETAFILE *)pData)->cbData;
    break;

    case TYMED_HGLOBAL:
    HGLOBAL_from_xmit((RemHGLOBAL *)pData, &pinst->hGlobal);
    pData += sizeof(RemHGLOBAL) + ((RemHGLOBAL *)pData)->cbData;
    break;

    // When unmarshalling a STGMEDIUM with TYMED_GDI, we need to know
    // what kind of GDI object is packaged, so we inspect the dwHandleType
    // field which was set during the marshalling of the STGMEDIUM

    case TYMED_GDI:

    switch(pxmit->dwHandleType)
    {
        case OBJ_BITMAP:

            HBITMAP_from_xmit((RemHBITMAP *)pData, &pinst->hBitmap);
            pData += sizeof(RemHBITMAP) + ((RemHBITMAP *)pData)->cbData;
            break;

        case OBJ_PAL:

            HPALETTE_from_xmit((RemHPALETTE *)pData, (HPALETTE *) &pinst->hBitmap);
            pData += sizeof(RemHPALETTE) + ((RemHPALETTE *)pData)->cbData;
            break;

        default:

            RpcRaiseException(DV_E_TYMED);
    }
    break;


    case TYMED_FILE:
    {
        unsigned long count;

        //unmarshal the count.
        memcpy(&count, pData, sizeof(count));
        pData += sizeof(count);

        //allocate memory.
        pinst->lpszFileName = (wchar_t *)NdrOleAllocate(count * sizeof(wchar_t));

        //copy the string.
        memcpy(pinst->lpszFileName, pData, count * sizeof(wchar_t));
        pData += count * sizeof(wchar_t);
    }
    break;

    case TYMED_ISTREAM:

    if (pxmit->pData)
    {
    CStreamOnMessage stream(&pData);

    //Align the buffer on an 4 byte boundary
    *(unsigned long FAR *)&pData += 3;
    *(unsigned long FAR *)&pData &= 0xfffffffc;

    //Skip over cbData.
    *(unsigned long FAR *)&pData += 4;

    //Skip over cbSize.
    *(unsigned long FAR *)&pData += 4;

    hr = CoUnmarshalInterface(&stream, IID_IStream,
                  (void **) &pinst->pstm);
    if(hr != S_OK)
    {
        RpcRaiseException(hr);
    }
    }
    else
    {
    pinst->pstm = NULL;
    }
    break;

    case TYMED_ISTORAGE:

    if (pxmit->pData)
    {
    CStreamOnMessage stream(&pData);

    //Align the buffer on an 4 byte boundary
    *(unsigned long FAR *)&pData += 3;
    *(unsigned long FAR *)&pData &= 0xfffffffc;

    //Skip over cbData.
    *(unsigned long FAR *)&pData += 4;

    //Skip over cbSize.
    *(unsigned long FAR *)&pData += 4;

    hr = CoUnmarshalInterface(&stream, IID_IStorage,
                  (void **) &pinst->pstg);
    if(hr != S_OK)
    {
        RpcRaiseException(hr);
    }
    }
    else
    {
    pinst->pstg = NULL;
    }

    break;
    default:
    break;
    }


    pinst->pUnkForRelease = NULL;

    if(pxmit->pUnkForRelease)
    {
    CStreamOnMessage stream(&pData);

    //Align the buffer on an 4 byte boundary
    *(unsigned long FAR *)&pData += 3;
    *(unsigned long FAR *)&pData &= 0xfffffffc;

    //Skip over cbData.
    *(unsigned long FAR *)&pData += 4;

    //Skip over cbSize.
    *(unsigned long FAR *)&pData += 4;

    hr = CoUnmarshalInterface(&stream, IID_IUnknown, (void **) &pinst->pUnkForRelease);
    if(hr != S_OK)
    {
        RpcRaiseException(hr);
    }

    //  replace the punkForRelease with our custom release
    //  handler for special situations.

    if (pinst->tymed == TYMED_HGLOBAL ||
        pinst->tymed == TYMED_MFPICT  ||
        pinst->tymed == TYMED_ENHMF   ||
        pinst->tymed == TYMED_GDI)
    {
        IUnknown *punkTmp = (IUnknown *) new CPunkForRelease(pinst);
        if (!punkTmp)
        {
        RpcRaiseException(E_OUTOFMEMORY);
        }
        pinst->pUnkForRelease = punkTmp;
    }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_free_inst
//
//  Synopsis:   Free the contents of an STGMEDIUM structure.
//
//--------------------------------------------------------------------------

void __RPC_USER STGMEDIUM_free_inst(STGMEDIUM *pinst)
{
    if(pinst)
    {
    if (pinst->tymed == TYMED_FILE)
    {
        NdrOleFree(pinst->lpszFileName);
        pinst->lpszFileName = NULL;

        if (pinst->pUnkForRelease)
        {
        pinst->pUnkForRelease->Release();
        pinst->pUnkForRelease = 0;
        }
    }
    else
    {
        ReleaseStgMedium(pinst);
    }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_free_xmit
//
//  Synopsis:   Free a RemSTGMEDIUM previously obtained from STGMEDIUM_to_xmit.
//
//--------------------------------------------------------------------------
void __RPC_USER STGMEDIUM_free_xmit(RemSTGMEDIUM *pxmit)
{
    if(pxmit)
    {
    NdrOleFree(pxmit);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   SNB_to_xmit
//
//  Synopsis:   Converts an SNB structure to a remotable structure
//
//  Arguments:  [pSNB]   -- pointer to the original SNB
//              [ppxmit] -- set to point to the transmitted value
//
//  Returns:    void
//
//  Algorithm:
//
//  History:    10-01-94    rickhi  Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void __RPC_USER SNB_to_xmit (SNB __RPC_FAR *pSNB,
    RemSNB __RPC_FAR * __RPC_FAR *ppxmit)
{
    // calculate the size of the structure needed. add 1 for the NULL
    // terminator

    ULONG ulCntStr = 0;
    ULONG ulCntChar = 0;

    if (pSNB && *pSNB)
    {
    // compute the number of strings and the total number of
    // characters in all the strings.
    SNB snb = *pSNB;

    WCHAR *psz = *snb;
    while (psz)
    {
        ulCntChar += wcslen(psz) + 1;
        ulCntStr++;
        snb++;
        psz = *snb;
    }
    }

    // allocate memory
    RemSNB *pRemSNB = (RemSNB *) NdrOleAllocate(sizeof(RemSNB) +
                        ulCntChar * sizeof(WCHAR));

    if (pRemSNB)
    {
    // copy the data
    pRemSNB->ulCntStr  = ulCntStr;
    pRemSNB->ulCntChar = ulCntChar;

    if (pSNB && *pSNB)
    {
        // copy the string ptrs into the new structure
        SNB snb = *pSNB;

        WCHAR *pszSrc;
        WCHAR *pszTgt = pRemSNB->rgString;
        while (pszSrc = *snb++)
        {
        ULONG ulLen = wcslen(pszSrc) + 1;
        memcpy(pszTgt, pszSrc, ulLen * sizeof(WCHAR));
        pszTgt += ulLen;
        }
    }

    *ppxmit = pRemSNB;
    }
    else
    {
    RpcRaiseException(E_OUTOFMEMORY);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   SNB_from_xmit
//
//  Synopsis:   converts a RemSNB to an SNB
//
//  Arguments:  [pxmit] -- the transmitted RemSNB
//              [pSNB]  -- where to put the local SNB
//
//  Returns:    void
//
//  History:    10-Jan-94 rickhi    created
//
//  Notes:
//
//--------------------------------------------------------------------------

void __RPC_USER SNB_from_xmit( RemSNB __RPC_FAR *pxmit,
    SNB __RPC_FAR *pSNB )
{
    if (pxmit)
    {
    if (pxmit->ulCntStr == 0)
    {
        *pSNB = NULL;
        return;
    }

    SNB snb = (SNB) NdrOleAllocate((pxmit->ulCntStr+1) * sizeof(WCHAR *) +
            pxmit->ulCntChar * sizeof(WCHAR));

    //  set the out parameter
    *pSNB = snb;

    if (snb)
    {
        // create the pointer array
        WCHAR *pszSrc = pxmit->rgString;
        WCHAR *pszTgt = (WCHAR *)(snb + pxmit->ulCntStr + 1);

        for (ULONG i = pxmit->ulCntStr; i>0; i--)
        {
        *snb++ = pszTgt;

        ULONG ulLen = wcslen(pszSrc) + 1;
        pszSrc += ulLen;
        pszTgt += ulLen;
        }

        *snb++ = NULL;

        // copy the actual strings
        memcpy(snb, pxmit->rgString, pxmit->ulCntChar * sizeof(WCHAR));
    }
    else
    {
        RpcRaiseException(E_OUTOFMEMORY);
    }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   SNB_free_xmit
//
//  Synopsis:   Free's the memory for the RemSNB structure
//
//  Arguments:  [pxmit]  -- the transmitted SNB to free
//
//  Returns:    void
//
//  History:    10-Jan-94 rickhi    created
//
//--------------------------------------------------------------------------

void __RPC_USER SNB_free_xmit( RemSNB __RPC_FAR *pxmit)
{
    if(pxmit != 0)
        NdrOleFree(pxmit);
}

//+-------------------------------------------------------------------------
//
//  Function:   SNB_free_inst
//
//  Synopsis:   Deletes an SNB.
//
//  Arguments:  [pSNB]  -- pointer to the SNB to free
//
//  Returns:    void
//
//  History:    10-Jan-94 created       created
//
//--------------------------------------------------------------------------

void __RPC_USER SNB_free_inst( SNB __RPC_FAR *pSNB)
{
    if (pSNB)
    {
    NdrOleFree(*pSNB);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   HMENU_to_xmit
//
//  Synopsis:   Convert an HMENU to a long.
//
//  Notes:      Both the source process and the destination process must
//              reside on the same machine.  This code assumes that the
//              destination process can use the HMENU received from
//              the source process.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER HMENU_to_xmit(HMENU *pHandle, LONG_PTR **ppLong)
{
    *(ppLong) = (LONG_PTR*) NdrOleAllocate(sizeof(LONG_PTR));
    **ppLong = (LONG_PTR) *(pHandle);
}

//+-------------------------------------------------------------------------
//
//  Function:   HMENU_from_xmit
//
//  Synopsis:   Convert a long to an HMENU.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER HMENU_from_xmit(LONG_PTR *pLong, HMENU *pHandle)
{
    *(pHandle) = (HMENU) *(pLong);
}

//+-------------------------------------------------------------------------
//
//  Function:   HMENU_free_inst
//
//  Synopsis:   Does nothing.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER HMENU_free_inst(HMENU *pHandle)
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HMENU_free_xmit
//
//  Synopsis:   Free a pointer to a long.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER HMENU_free_xmit(long *pLong)
{
    if(pLong != 0)
        NdrOleFree(pLong);
}

EXTERN_C void __RPC_USER HOLEMENU_to_xmit (HOLEMENU *pinst, RemHGLOBAL **ppxmit)
{
    HGLOBAL_to_xmit((HGLOBAL *)pinst, ppxmit);
}

EXTERN_C void __RPC_USER HOLEMENU_from_xmit (RemHGLOBAL __RPC_FAR *pxmit, HOLEMENU __RPC_FAR *pinst)
{
    HGLOBAL_from_xmit (pxmit, (HGLOBAL __RPC_FAR *)pinst);
}

EXTERN_C void __RPC_USER HOLEMENU_free_inst(HOLEMENU *pinst)
{
    HGLOBAL_free_inst((HGLOBAL *)pinst);
}

EXTERN_C void __RPC_USER HOLEMENU_free_xmit(RemHGLOBAL *pxmit)
{
    HGLOBAL_free_xmit(pxmit);
}

//+-------------------------------------------------------------------------
//
//  Function:   HWND_to_xmit
//
//  Synopsis:   Convert an HWND to a long.
//
//  Notes:      Both the source process and the destination process must
//              reside on the same machine.  This code assumes that the
//              destination process can use the HWND received from
//              the source process.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER HWND_to_xmit(HWND *pHandle, LONG_PTR **ppLong)
{
    *(ppLong) = (LONG_PTR*) NdrOleAllocate(sizeof(LONG_PTR));
    **ppLong = (LONG_PTR) *(pHandle);
}

//+-------------------------------------------------------------------------
//
//  Function:   HWND_from_xmit
//
//  Synopsis:   Convert a long to an HWND.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER HWND_from_xmit(LONG_PTR *pLong, HWND *pHandle)
{
    *(pHandle) = (HWND) *(pLong);
}

//+-------------------------------------------------------------------------
//
//  Function:   HWND_free_inst
//
//  Synopsis:   Does nothing.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER HWND_free_inst(HWND *pHandle)
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HWND_free_xmit
//
//  Synopsis:   Free a pointer to a long.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER HWND_free_xmit(long *pLong)
{
    if(pLong != 0)
        NdrOleFree(pLong);
}

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_to_xmit
//
//  Synopsis:   Converts an enhanced metafile handle into a serial buffer
//              that can be remoted
//
//  Arguments:  [pHEnhMetafile] -- pointer to the original emf handle
//              [ppxmit]        -- set to point to the transmitted value
//
//  Returns:    void
//
//  History:    14-Nov-94   DavePl  Created
//
//
//--------------------------------------------------------------------------

void __RPC_USER HENHMETAFILE_to_xmit (HENHMETAFILE __RPC_FAR *pHEnhMetafile,
    RemHENHMETAFILE __RPC_FAR * __RPC_FAR *ppxmit)
{
    // A few inefficient temp vars here to avoid ugly casts later

    HENHMETAFILE hemf = *pHEnhMetafile;

    // Calculate the number of bytes we need in order to serialize the
    // metafile to memory

    DWORD cbData = GetEnhMetaFileBits(hemf, 0, NULL);
    if (cbData == 0)
    {
        RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
    }

    // Allocate the appropriate number of bytes

    *ppxmit = (RemHENHMETAFILE *)
        NdrOleAllocate(sizeof(RemHENHMETAFILE) + cbData);


    // If the allocation was successful, get the bits into our buffer.
    // Otherwise, throw an exception

    if (*ppxmit)
    {
    if (0==GetEnhMetaFileBits(hemf, cbData, &((*ppxmit)->data[0])))
        {
            NdrOleFree(*ppxmit);
            *ppxmit = NULL;

            RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
        }
        (*ppxmit)->cbData = cbData;
    }
    else
    {
        RpcRaiseException(E_OUTOFMEMORY);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_from_xmit
//
//  Synopsis:   Converts a serialized enhanced metafile into an emf handle
//              that is usable by applications
//
//  Arguments:  [pxmit]         -- the transmitted global handle
//              [pHEnhMetafile] -- where to put the local metafilepict handle
//
//  Returns:    void
//
//  History:    14-May-94 DavePl    Created
//
//--------------------------------------------------------------------------

void __RPC_USER HENHMETAFILE_from_xmit( RemHENHMETAFILE __RPC_FAR *pxmit,
    HENHMETAFILE __RPC_FAR *pHEnhMetafile )
{

    // Generate a handle to the enhanced metafile by doing a
    // Setbits on the raw data

    *pHEnhMetafile = SetEnhMetaFileBits(pxmit->cbData, pxmit->data);

    if (NULL == *pHEnhMetafile)
    {
        RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
    }

}

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_free_xmit
//
//  Synopsis:   Free's the remote data
//
//  Arguments:  [pxmit]         -- the transmitted data
//
//  Returns:    void
//
//  History:    14-May-94     DavePl    Created
//
//--------------------------------------------------------------------------

void __RPC_USER HENHMETAFILE_free_xmit( RemHENHMETAFILE __RPC_FAR *pxmit)
{
    if(pxmit != 0)
        NdrOleFree(pxmit);
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_free_inst
//
//  Synopsis:   destroys the metafile
//
//  Arguments:  [pHEnhMetafile]        -- handle to the enhanced metafile
//
//  Returns:    void
//
//  Algorithm:
//
//  History:    14-May-94     DavePl    Created
//
//--------------------------------------------------------------------------

void __RPC_USER HENHMETAFILE_free_inst( HENHMETAFILE __RPC_FAR *pHEnhMetafile)
{
    DeleteEnhMetaFile (*pHEnhMetafile);
}

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_to_xmit
//
//  Synopsis:   Converts a palette into a serialized buffer
//              that can be remoted
//
//  Arguments:  [pHPALETTE] -- pointer to the original palette handle
//              [ppxmit]    -- set to point to the transmitted value
//
//  Returns:    void
//
//  History:    11-Aug-94   DavePl  Created
//
//
//--------------------------------------------------------------------------

void __RPC_USER HPALETTE_to_xmit (HPALETTE __RPC_FAR *pHPALETTE,
    RemHPALETTE __RPC_FAR * __RPC_FAR *ppxmit)
{
    // Determine the number of color entries in the palette
    DWORD cEntries = GetPaletteEntries(*pHPALETTE, 0, 0, NULL);

    // Calculate the resultant data size
    DWORD cbData = cEntries * sizeof(PALETTEENTRY);

    // Allocate space for the struct and the entries
    *ppxmit = (RemHPALETTE *) NdrOleAllocate(sizeof(RemHPALETTE) + cbData);

    if (NULL == *ppxmit)
    {
        RpcRaiseException(E_OUTOFMEMORY);
    }

    if (cbData)
    {
        if (0 == GetPaletteEntries(*pHPALETTE,
                                   0,
                                   cEntries,
                                   (PALETTEENTRY *) &((*ppxmit)->data[0])))
        {
            NdrOleFree(*ppxmit);
            *ppxmit = NULL;
            RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    (*ppxmit)->cbData = cbData;

}

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_from_xmit
//
//  Synopsis:   Converts a serialized palette into an palette handle
//              that is usable by applications
//
//  Arguments:  [pxmit]         -- the transmitted buffer
//              [pHPALETTE]     -- where to put the local palette handle
//
//  Returns:    void
//
//  History:    11-Aug-94 DavePl    Created
//
//--------------------------------------------------------------------------

void __RPC_USER HPALETTE_from_xmit( RemHPALETTE __RPC_FAR *pxmit,
    HPALETTE __RPC_FAR *pHPALETTE )
{
    DWORD cEntries = pxmit->cbData / sizeof(PALETTEENTRY);
    LOGPALETTE * pLogPal;

    // If there are 0 color entries, we need to allocate the LOGPALETTE
    // structure with the one dummy entry (it's a variably sized struct).
    // Otherwise, we need to allocate enough space for the extra n-1
    // entries at the tail of the structure

    if (0 == cEntries)
    {
        pLogPal = (LOGPALETTE *) NdrOleAllocate(sizeof(LOGPALETTE));
    }
    else
    {
        pLogPal = (LOGPALETTE *) NdrOleAllocate(sizeof(LOGPALETTE) +
                                          (cEntries - 1) * sizeof(PALETTEENTRY));

        // If there are entries, and if we have a buffer, move the
        // entries into out LOGPALETTE structure

        if (pLogPal)
        {
            memcpy(&(pLogPal->palPalEntry[0]), pxmit->data, pxmit->cbData);
        }
    }

    // If we didn't get a buffer at all...

    if (NULL == pLogPal)
    {
        RpcRaiseException(E_OUTOFMEMORY);
    }

    // Fill in the rest of the structure

    pLogPal->palVersion = 0x300;
    pLogPal->palNumEntries = (unsigned short) cEntries;

    // Attempt to create the palette

    *pHPALETTE = CreatePalette(pLogPal);

    // Success or failure, we're done with the LOGPALETTE structure

    NdrOleFree(pLogPal);

    // If the creation failed, raise an exception

    if (NULL == *pHPALETTE)
    {
        RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_free_xmit
//
//  Synopsis:   Frees the remote data
//
//  Arguments:  [pxmit]         -- the transmitted data
//
//  Returns:    void
//
//  History:    11-Aug-94     DavePl    Created
//
//--------------------------------------------------------------------------

void __RPC_USER HPALETTE_free_xmit( RemHPALETTE __RPC_FAR *pxmit)
{
    if(NULL != pxmit)
    {
        NdrOleFree(pxmit);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_free_inst
//
//  Synopsis:   destroys the palette
//
//  Arguments:  [pHPALETTE]        -- handle to the palette
//
//  Returns:    void
//
//  Algorithm:
//
//  History:    11-Aug-94     DavePl    Created
//
//--------------------------------------------------------------------------

void __RPC_USER HPALETTE_free_inst( HPALETTE __RPC_FAR *pHPALETTE)
{
    DeleteObject( (HGDIOBJ) *pHPALETTE);
}

//+-------------------------------------------------------------------------
//
//  Function:   HACCEL_to_xmit
//
//  Synopsis:   Convert an HACCEL to a long.
//
//  Notes:      Both the source process and the destination process must
//              reside on the same machine.  This code assumes that the
//              destination process can use the HACCEL received from
//              the source process.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER HACCEL_to_xmit(HACCEL *phAccel, LONG_PTR **ppLong)
{
    *ppLong = (LONG_PTR*) NdrOleAllocate(sizeof(LONG_PTR));
    **ppLong = (LONG_PTR) *phAccel;
}

//+-------------------------------------------------------------------------
//
//  Function:   HACCEL_from_xmit
//
//  Synopsis:   Convert a long to an HACCEL.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER HACCEL_from_xmit(LONG_PTR *pLong, HACCEL *pHandle)
{
    *pHandle = (HACCEL) *pLong;
}

//+-------------------------------------------------------------------------
//
//  Function:   HACCEL_free_inst
//
//  Synopsis:   Does nothing.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER HACCEL_free_inst(HACCEL *pHandle)
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HACCEL_free_xmit
//
//  Synopsis:   Free a pointer to a long.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER HACCEL_free_xmit(long *pLong)
{
    if(pLong != 0)
        NdrOleFree(pLong);
}

//+-------------------------------------------------------------------------
//
//  Function:   UINT_to_xmit
//
//  Synopsis:   Convert a UINT to a 32 bit long.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER UINT_to_xmit(UINT *pUint, unsigned long **ppLong)
{
    *ppLong = (unsigned long *) NdrOleAllocate(sizeof(long));
    **ppLong = (unsigned long) *pUint;
}

//+-------------------------------------------------------------------------
//
//  Function:   UINT_from_xmit
//
//  Synopsis:   Convert a 32 bit long to a UINT.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER UINT_from_xmit(
    unsigned long __RPC_FAR *pLong,
    UINT __RPC_FAR *pUint
    )
{
    *pUint = (UINT) *pLong;
}

//+-------------------------------------------------------------------------
//
//  Function:   UINT_free_inst
//
//  Synopsis:   Does nothing.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER UINT_free_inst(UINT *pHandle)
{
}

//+-------------------------------------------------------------------------
//
//  Function:   UINT_free_xmit
//
//  Synopsis:   Free a pointer to a long.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER UINT_free_xmit(unsigned long *pLong)
{
    if(pLong != 0)
        NdrOleFree(pLong);
}

//+-------------------------------------------------------------------------
//
//  Function:   WPARAM_to_xmit
//
//  Synopsis:   Convert a WPARAM to a 32 bit long.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER WPARAM_to_xmit(WPARAM *pHandle, unsigned long **ppLong)
{
    *ppLong = (unsigned long *) NdrOleAllocate(sizeof(unsigned long));
    **ppLong = (unsigned long) *pHandle;
}

//+-------------------------------------------------------------------------
//
//  Function:   WPARAM_from_xmit
//
//  Synopsis:   Convert a 32 bit long to a WPARAM.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER WPARAM_from_xmit(unsigned long *pLong, WPARAM *pHandle)
{
    *pHandle = (WPARAM) *pLong;
}

//+-------------------------------------------------------------------------
//
//  Function:   WPARAM_free_inst
//
//  Synopsis:   Does nothing.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER WPARAM_free_inst(WPARAM *pHandle)
{
}

//+-------------------------------------------------------------------------
//
//  Function:   WPARAM_free_xmit
//
//  Synopsis:   Free a pointer to a long.
//
//--------------------------------------------------------------------------
EXTERN_C void __RPC_USER WPARAM_free_xmit(unsigned long *pLong)
{
    if(pLong != 0)
        NdrOleFree(pLong);
}


#ifdef UNUSED
//+-------------------------------------------------------------------------
// new code
//+-------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_to_xmit
//
//  Synopsis:   Convert an STGMEDIUM to a RemBINDINFO structure so it can be sent
//                              over the network.
//
//                              The marshalled BINDINFO looks like this:
//                              RemBINDINFO | data from union | data from pUnkForRelease
//--------------------------------------------------------------------------

void __RPC_USER BINDINFO_to_xmit (BINDINFO *pinst, RemBINDINFO **ppxmit)
{
    unsigned char *pData;
    RemHGLOBAL *pRemHGLOBAL;
    RemHBITMAP *pRemHBITMAP;
    RemHPALETTE *pRemHPALETTE;
    RemHMETAFILEPICT *pRemHMETAFILEPICT;
    RemHENHMETAFILE *pRemHENHMETAFILE;

    long size;
    unsigned long count;
    unsigned long cbInterface;
    HRESULT hr = S_OK;
    DWORD *pcbData;
    DWORD *pcbSize;
    DWORD cbData;
    unsigned char *pStart;

    // If the TYMED for the BINDINFO is TYMED_GDI, we need a bit more information
    // (ie: what _kind_ of GDI object it is).  The field is unused for anything
    // except TYMED_GDI

    DWORD dwHandleType = 0;

    //calculate size of marshalled BINDINFO.
    size = sizeof(RemBINDINFO);

    //add the size of data[].
    switch(pinst->tymed)
    {
    case TYMED_NULL:
        break;
    case TYMED_MFPICT:
        HMETAFILEPICT_to_xmit(&pinst->hMetaFilePict, &pRemHMETAFILEPICT);
        size += sizeof(RemHMETAFILEPICT) + pRemHMETAFILEPICT->cbData;
        break;
    case TYMED_ENHMF:
        HENHMETAFILE_to_xmit(&pinst->hEnhMetaFile, &pRemHENHMETAFILE);
        size += sizeof(RemHENHMETAFILE) + pRemHENHMETAFILE->cbData;
        break;
    case TYMED_GDI:

        // A GDI object is not necesarrily a BITMAP.  Therefore, we handle
        // those types we know about based on the object type, and reject
        // those which we do not support.

        switch(GetObjectType( (HGDIOBJ) pinst->hGlobal ))
        {
            case OBJ_BITMAP:

                HBITMAP_to_xmit(&pinst->hBitmap, &pRemHBITMAP);
                size += sizeof(RemHBITMAP) + pRemHBITMAP->cbData;
                dwHandleType = OBJ_BITMAP;
                break;

            case OBJ_PAL:

                HPALETTE_to_xmit((HPALETTE *) &pinst->hBitmap, &pRemHPALETTE);
                size += sizeof(RemHPALETTE) + pRemHPALETTE->cbData;
                dwHandleType = OBJ_PAL;
                break;

            default:
                RpcRaiseException(DV_E_TYMED);
        }
        break;

    case TYMED_HGLOBAL:
        HGLOBAL_to_xmit(&pinst->hGlobal, &pRemHGLOBAL);
        size += sizeof(RemHGLOBAL) + pRemHGLOBAL->cbData;
        break;
    case TYMED_FILE:
        count = wcslen(pinst->lpszFileName) + 1;
        size += 4; //allocate room for character count.
        size += count * sizeof(wchar_t);
        break;
    case TYMED_ISTREAM:
        size += 4;
        if(pinst->pstm)
        {
            //Align the buffer on an 4 byte boundary.
            size += 3;
            size &= (unsigned int)0xfffffffc;

            //Allocate space for the length and array bounds.
            size += 8;

            hr = CoGetMarshalSizeMax(&cbInterface, IID_IStream, pinst->pstm, MSHCTX_LOCAL, 0, MSHLFLAGS_NORMAL);
            if(hr == S_OK)
            size += cbInterface;
        }
        break;
    case TYMED_ISTORAGE:
        size += 4;
        if(pinst->pstg)
        {
            //Align the buffer on an 4 byte boundary.
            size += 3;
            size &= (unsigned int)0xfffffffc;

            //Allocate space for the length and array bounds.
            size += 8;

            hr = CoGetMarshalSizeMax(&cbInterface, IID_IStorage, pinst->pstg, MSHCTX_LOCAL, 0, MSHLFLAGS_NORMAL);
            if(hr == S_OK)
            size += cbInterface;
        }
        break;
    default:
        break;
    }


    //Allocate space for pUnkForRelease.
    if(pinst->pUnkForRelease)
    {
        //Align the buffer on an 4 byte boundary.
        size += 3;
        size &= (unsigned int)0xfffffffc;

        //Allocate space for the length and array bounds.
        size += 8;

        hr = CoGetMarshalSizeMax(&cbInterface, IID_IUnknown, pinst->pUnkForRelease, MSHCTX_NOSHAREDMEM, 0, MSHLFLAGS_NORMAL);
    if(hr == S_OK)
    {
        size += cbInterface;
    }
    }

    //allocate memory
    *ppxmit = (RemBINDINFO *) NdrOleAllocate(size);

    //Marshal BINDINFO
    (*ppxmit)->tymed = pinst->tymed;
    (*ppxmit)->pData = (unsigned long) pinst->hGlobal;
    (*ppxmit)->pUnkForRelease = (unsigned long) pinst->pUnkForRelease;
    (*ppxmit)->cbData = size - sizeof(RemBINDINFO);
    (*ppxmit)->dwHandleType = dwHandleType;

    pData = (*ppxmit)->data;

    switch(pinst->tymed)
    {
    case TYMED_NULL:
        break;
    case TYMED_MFPICT:
        //Note that we called HMETAFILEPICT_to_xmit earlier so we could
        //get the size.
        memcpy(pData, pRemHMETAFILEPICT, sizeof(RemHMETAFILEPICT) + pRemHMETAFILEPICT->cbData);
        pData += sizeof(RemHMETAFILEPICT) + pRemHMETAFILEPICT->cbData;
        HMETAFILEPICT_free_xmit(pRemHMETAFILEPICT);
        break;
    case TYMED_ENHMF:
        memcpy(pData, pRemHENHMETAFILE, sizeof(RemHENHMETAFILE) + pRemHENHMETAFILE->cbData);
        pData += sizeof(RemHENHMETAFILE) + pRemHENHMETAFILE->cbData;
        HENHMETAFILE_free_xmit(pRemHENHMETAFILE);
        break;
    case TYMED_HGLOBAL:
        //Note that we called HGLOBAL_to_xmit earlier so we could
        //get the size.
        memcpy(pData, pRemHGLOBAL, sizeof(RemHGLOBAL) + pRemHGLOBAL->cbData);
    pData += sizeof(RemHGLOBAL) + pRemHGLOBAL->cbData;
        HGLOBAL_free_xmit(pRemHGLOBAL);
        break;

    case TYMED_GDI:

        switch(dwHandleType)
        {
        case OBJ_BITMAP:

            memcpy(pData, pRemHBITMAP, sizeof(RemHBITMAP) + pRemHBITMAP->cbData);
            pData += sizeof(RemHBITMAP) + pRemHBITMAP->cbData;
            HBITMAP_free_xmit(pRemHBITMAP);
            break;

        case OBJ_PAL:

            memcpy(pData, pRemHPALETTE, sizeof(RemHPALETTE) + pRemHPALETTE->cbData);
            pData += sizeof(RemHPALETTE) + pRemHPALETTE->cbData;
            HPALETTE_free_xmit(pRemHPALETTE);
        }

        break;

    case TYMED_FILE:
        //copy the length.
        memcpy(pData, &count, sizeof(count));
        pData += sizeof(count);

        //copy the string.
    memcpy(pData, pinst->lpszFileName, count * sizeof(wchar_t));
        pData += count * sizeof(wchar_t);
        break;
    case TYMED_ISTREAM:
        if(pinst->pstm)
        {
            CStreamOnMessage stream((unsigned char **) &pData);

            //Align the buffer on an 4 byte boundary
            *(unsigned long FAR *)&pData += 3;
            *(unsigned long FAR *)&pData &= 0xfffffffc;

            //Leave space for cbData.
            pcbData = (DWORD *) pData;
            *(unsigned long FAR *)&pData += 4;

            //Leave space for size.
            pcbSize = (DWORD *) pData;
        *(unsigned long FAR *)&pData += 4;

            pStart = (unsigned char *) pData;

            hr = CoMarshalInterface(&stream, IID_IStream, pinst->pstm, MSHCTX_LOCAL, 0, MSHLFLAGS_NORMAL);
            if(hr != S_OK)
            {
                RpcRaiseException(hr);
            }

            cbData = (DWORD) (pData - pStart);
            *pcbData = cbData;
            *pcbSize = cbData;
        }
        break;
    case TYMED_ISTORAGE:
        if(pinst->pstg)
        {
            CStreamOnMessage stream((unsigned char **) &pData);

            //Align the buffer on an 4 byte boundary
            *(unsigned long FAR *)&pData += 3;
            *(unsigned long FAR *)&pData &= 0xfffffffc;

            //Leave space for cbData.
            pcbData = (DWORD *) pData;
            *(unsigned long FAR *)&pData += 4;

            //Leave space for size.
            pcbSize = (DWORD *) pData;
            *(unsigned long FAR *)&pData += 4;

            pStart = (unsigned char *) pData;

            hr = CoMarshalInterface(&stream, IID_IStorage, pinst->pstg, MSHCTX_LOCAL, 0, MSHLFLAGS_NORMAL);
            if(hr != S_OK)
            {
                RpcRaiseException(hr);
            }

            cbData = (DWORD) (pData - pStart);
            *pcbData = cbData;
            *pcbSize = cbData;
        }
        break;
    default:
        break;
    }


    if(pinst->pUnkForRelease)
    {
        CStreamOnMessage stream((unsigned char **) &pData);

        //Align the buffer on an 4 byte boundary
        *(unsigned long FAR *)&pData += 3;
        *(unsigned long FAR *)&pData &= 0xfffffffc;

        //Leave space for cbData.
        pcbData = (DWORD *) pData;
        *(unsigned long FAR *)&pData += 4;

        //Leave space for size.
        pcbSize = (DWORD *) pData;
        *(unsigned long FAR *)&pData += 4;

        pStart = (unsigned char *) pData;

        hr = CoMarshalInterface(&stream, IID_IUnknown, pinst->pUnkForRelease, MSHCTX_NOSHAREDMEM, 0, MSHLFLAGS_NORMAL);
        if(hr != S_OK)
        {
            RpcRaiseException(hr);
        }

        cbData = (DWORD) (pData - pStart);
        *pcbData = cbData;
        *pcbSize = cbData;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   BINDINFO_from_xmit
//
//  Synopsis:   Convert a RemBINDINFO structure to an BINDINFO.
//
//--------------------------------------------------------------------------
void __RPC_USER BINDINFO_from_xmit (RemBINDINFO __RPC_FAR *pxmit, BINDINFO __RPC_FAR *pinst)
{
    HRESULT hr = S_OK;
    unsigned char *pData;

    pinst->tymed = pxmit->tymed;
    pData = pxmit->data;

    switch(pinst->tymed)
    {
    case TYMED_NULL:
    break;

    case TYMED_MFPICT:
    HMETAFILEPICT_from_xmit((RemHMETAFILEPICT *)pData, &pinst->hMetaFilePict);
    pData += sizeof(RemHMETAFILEPICT) + ((RemHMETAFILEPICT *)pData)->cbData;
    break;

    case TYMED_ENHMF:
    HENHMETAFILE_from_xmit((RemHENHMETAFILE *)pData, &pinst->hEnhMetaFile);
    pData += sizeof(RemHENHMETAFILE) + ((RemHENHMETAFILE *)pData)->cbData;
    break;

    case TYMED_HGLOBAL:
    HGLOBAL_from_xmit((RemHGLOBAL *)pData, &pinst->hGlobal);
    pData += sizeof(RemHGLOBAL) + ((RemHGLOBAL *)pData)->cbData;
    break;

    // When unmarshalling a BINDINFO with TYMED_GDI, we need to know
    // what kind of GDI object is packaged, so we inspect the dwHandleType
    // field which was set during the marshalling of the BINDINFO

    case TYMED_GDI:

    switch(pxmit->dwHandleType)
    {
        case OBJ_BITMAP:

            HBITMAP_from_xmit((RemHBITMAP *)pData, &pinst->hBitmap);
            pData += sizeof(RemHBITMAP) + ((RemHBITMAP *)pData)->cbData;
            break;

        case OBJ_PAL:

            HPALETTE_from_xmit((RemHPALETTE *)pData, (HPALETTE *) &pinst->hBitmap);
            pData += sizeof(RemHPALETTE) + ((RemHPALETTE *)pData)->cbData;
            break;

        default:

            RpcRaiseException(DV_E_TYMED);
    }
    break;


    case TYMED_FILE:
    {
        unsigned long count;

        //unmarshal the count.
        memcpy(&count, pData, sizeof(count));
        pData += sizeof(count);

        //allocate memory.
        pinst->lpszFileName = (wchar_t *)NdrOleAllocate(count * sizeof(wchar_t));

        //copy the string.
        memcpy(pinst->lpszFileName, pData, count * sizeof(wchar_t));
        pData += count * sizeof(wchar_t);
    }
    break;

    case TYMED_ISTREAM:

    if (pxmit->pData)
    {
    CStreamOnMessage stream(&pData);

    //Align the buffer on an 4 byte boundary
    *(unsigned long FAR *)&pData += 3;
    *(unsigned long FAR *)&pData &= 0xfffffffc;

    //Skip over cbData.
    *(unsigned long FAR *)&pData += 4;

    //Skip over cbSize.
    *(unsigned long FAR *)&pData += 4;

    hr = CoUnmarshalInterface(&stream, IID_IStream,
                  (void **) &pinst->pstm);
    if(hr != S_OK)
    {
        RpcRaiseException(hr);
    }
    }
    else
    {
    pinst->pstm = NULL;
    }
    break;

    case TYMED_ISTORAGE:

    if (pxmit->pData)
    {
    CStreamOnMessage stream(&pData);

    //Align the buffer on an 4 byte boundary
    *(unsigned long FAR *)&pData += 3;
    *(unsigned long FAR *)&pData &= 0xfffffffc;

    //Skip over cbData.
    *(unsigned long FAR *)&pData += 4;

    //Skip over cbSize.
    *(unsigned long FAR *)&pData += 4;

    hr = CoUnmarshalInterface(&stream, IID_IStorage,
                  (void **) &pinst->pstg);
    if(hr != S_OK)
    {
        RpcRaiseException(hr);
    }
    }
    else
    {
    pinst->pstg = NULL;
    }

    break;
    default:
    break;
    }


    pinst->pUnkForRelease = NULL;

    if(pxmit->pUnkForRelease)
    {
    CStreamOnMessage stream(&pData);

    //Align the buffer on an 4 byte boundary
    *(unsigned long FAR *)&pData += 3;
    *(unsigned long FAR *)&pData &= 0xfffffffc;

    //Skip over cbData.
    *(unsigned long FAR *)&pData += 4;

    //Skip over cbSize.
    *(unsigned long FAR *)&pData += 4;

    hr = CoUnmarshalInterface(&stream, IID_IUnknown, (void **) &pinst->pUnkForRelease);
    if(hr != S_OK)
    {
        RpcRaiseException(hr);
    }

    //  replace the punkForRelease with our custom release
    //  handler for special situations.

    if (pinst->tymed == TYMED_HGLOBAL ||
        pinst->tymed == TYMED_MFPICT  ||
        pinst->tymed == TYMED_ENHMF   ||
        pinst->tymed == TYMED_GDI)
    {
        IUnknown *punkTmp = (IUnknown *) new CPunkForRelease(pinst);
        if (!punkTmp)
        {
        RpcRaiseException(E_OUTOFMEMORY);
        }
        pinst->pUnkForRelease = punkTmp;
    }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   BINDINFO_free_inst
//
//  Synopsis:   Free the contents of an BINDINFO structure.
//
//--------------------------------------------------------------------------

void __RPC_USER BINDINFO_free_inst(BINDINFO *pinst)
{
    if(pinst)
    {
        NdrOleFree(pinst);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   BINDINFO_free_xmit
//
//  Synopsis:   Free a RemBINDINFO previously obtained from BINDINFO_to_xmit.
//
//--------------------------------------------------------------------------
void __RPC_USER BINDINFO_free_xmit(RemBINDINFO *pxmit)
{
    if(pxmit)
    {
        NdrOleFree(pxmit);
    }
}
#endif //UNUSED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\search\plugdll.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       plugdll.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include <stdio.h>
#include <sem.hxx>
#include "urlcf.hxx"
#include "selfreg.hxx"

#define SZNAMESPACEROOT "PROTOCOLS\\Name-Space Handler\\"
#define SZPROTOCOLROOT  "PROTOCOLS\\Handler\\"
#define SZCLASS         "CLSID"


// ==========================================================================================================
//
// THIS IS OUR CLSID
//
GUID CLSID_ResProtocol =     {0x79eaca01, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b}};
//
// ==========================================================================================================


DECLARE_INFOLEVEL(UrlMk)
DECLARE_INFOLEVEL(Trans)
HINSTANCE g_hInst = NULL;

// global variables
CRefCount g_cRef(0);        // global dll refcount


#define DLL_NAME      "b4hook.dll"

STDAPI_(BOOL) TlsDllMain(HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved);


#define HANDLER_HOOK                           SZNAMESPACEROOT"Search Hook"
#define HANDLER_RES                            SZPROTOCOLROOT"search"
#define PROTOCOL_RES_CLSID                     "{79eaca01-baf9-11ce-8c82-00aa004ba90b}"
#define PROTOCOL_RES_CLSID_REGKEY              "CLSID\\"PROTOCOL_RES_CLSID
#define PROTOCOL_HOOK_DESCRIP                  "Search Hook: Asychronous Name-Space Handler"
#define PROTOCOL_RES_DESCRIP                   "search: Asychronous Pluggable Protocol Handler"

#define HANDLER_PROTOCOLS                       HANDLER_HOOK"\\Protocols"

// protocols
//***** PROTOCOL_RES ENTRIES *****
const REGENTRY rgClassesRes[] =
{
    STD_ENTRY(PROTOCOL_RES_CLSID_REGKEY, PROTOCOL_RES_DESCRIP),
    STD_ENTRY(PROTOCOL_RES_CLSID_REGKEY"\\InprocServer32", "%s"DLL_NAME),
        { KEYTYPE_STRING, PROTOCOL_RES_CLSID_REGKEY"\\InprocServer32", "ThreadingModel", REG_SZ, (BYTE*)"Apartment" },
};


const REGENTRY rgHandlerRes   [] = 
{ 
    STD_ENTRY(HANDLER_RES  , PROTOCOL_RES_DESCRIP  ), 
        { KEYTYPE_STRING, HANDLER_RES  , "CLSID", REG_SZ, (BYTE*)PROTOCOL_RES_CLSID   },
    STD_ENTRY(HANDLER_HOOK  , PROTOCOL_HOOK_DESCRIP  ), 
        { KEYTYPE_STRING, HANDLER_HOOK  , "CLSID", REG_SZ, (BYTE*)PROTOCOL_RES_CLSID   },
    STD_ENTRY(HANDLER_PROTOCOLS  , ""  ), 
        { KEYTYPE_STRING, HANDLER_PROTOCOLS  , "http", REG_SZ, (BYTE*)""   }

};

const REGENTRYGROUP rgRegEntryGroups[] = {

    { HKEY_CLASSES_ROOT, rgClassesRes,     ARRAYSIZE(rgClassesRes) },
    { HKEY_CLASSES_ROOT, rgHandlerRes  ,   ARRAYSIZE(rgHandlerRes  ) },
    { NULL, NULL, 0 }       // terminator
};


//+---------------------------------------------------------------------------
//
//  Function:   DllAddRef
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void DllAddRef(void)
{
    g_cRef++;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllRelease
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void DllRelease(void)
{
    UrlMkAssert((g_cRef > 0));
    if (g_cRef > 0)
    {
        g_cRef--;
    }
}

//+---------------------------------------------------------------------------
//
//  Operator:   new
//
//  Synopsis:
//
//  Arguments:  [size] --
//
//  Returns:
//
//  History:    11-07-96   JohannP (Johann Posch)   Created
//
//  Notes:      BUBUG: get and use IMalloc
//
//----------------------------------------------------------------------------
void * _cdecl operator new(size_t size)
{
    void * pBuffer;
    pBuffer = CoTaskMemAlloc(size);
    if (pBuffer)
    {
        memset(pBuffer,0, size);
    }
    return pBuffer;
}

//+---------------------------------------------------------------------------
//
//  Operator:   delete
//
//  Synopsis:
//
//  Arguments:  [lpv] --
//
//  Returns:
//
//  History:    2-14-96   JohannP (Johann Posch)   Created
//
//  Notes:      BUBUG: get and use IMalloc
//
//----------------------------------------------------------------------------
void _cdecl operator delete(void *lpv)
{
    UrlMkAssert((lpv != NULL));
    if (lpv == NULL)
    {
        return;
    }

    CoTaskMemFree(lpv);
}

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Dll entry point
//
//  Arguments:  [clsid] - class id for new class
//              [iid] - interface required of class
//              [ppv] - where to put new interface
//
//  Returns:    S_OK - class object created successfully created.
//
//  History:    11-07-96   JohannP (Johann Posch)   Created
//
//--------------------------------------------------------------------------
STDAPI DllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv)
{
    UrlMkDebugOut((DEB_URLMON, "API _IN DllGetClassObject\n"));

    HRESULT hr = E_FAIL;

    if (clsid == CLSID_ResProtocol)
    {
        /*
        IClassFactory *pCF = NULL;

        //hr = tsaMain.GetClassFactory(&pCF);
        if (hr == NOERROR)
        {
            UrlMkAssert((pCF != NULL));
            hr = pCF->QueryInterface(iid, ppv);
            UrlMkAssert((hr == NOERROR));
            pCF->Release();
        }
        */
        CUrlClsFact *pCF = NULL;
        hr = CUrlClsFact::Create(clsid, &pCF);
        if (hr == NOERROR)
        {
            UrlMkAssert((pCF != NULL));
            hr = pCF->QueryInterface(iid, ppv);
            pCF->Release();
        }


    }


    UrlMkDebugOut((DEB_URLMON, "API OUT DllGetClassObject (hr:%lx, ppv:%p)\n",hr,*ppv));
    return hr;
}
//+-------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:
//
//  Arguments:  [hDll]          - a handle to the dll instance
//              [dwReason]      - the reason LibMain was called
//              [lpvReserved]   - NULL - called due to FreeLibrary
//                              - non-NULL - called due to process exit
//
//  Returns:    TRUE on success, FALSE otherwise
//
//  Notes:
//
//              The officially approved DLL entrypoint name is DllMain. This
//              entry point will be called by the CRT Init function.
//
//  History:    11-07-96   JohannP (Johann Posch)   Created
//
//--------------------------------------------------------------------------
BOOL WINAPI DllMain(HINSTANCE hInstance,DWORD dwReason,LPVOID lpvReserved)
{
    BOOL fResult = TRUE;
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
#if DBG==1
        {
            UrlMkInfoLevel = (DWORD) GetProfileIntA("UrlMon","UrlMk", (DEB_ERROR | DEB_WARN));
            TransInfoLevel = (DWORD) GetProfileIntA("UrlMon","Trans", (DEB_ERROR | DEB_WARN));
        }
#endif //DBG==1
        g_hInst = hInstance;
        //tsaMain.InitApp(NULL);

        //fResult = TlsDllMain(hInstance, dwReason, lpvReserved);
        break;

    case DLL_PROCESS_DETACH:

        // Fall through

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        //fResult = TlsDllMain(hInstance, dwReason, lpvReserved);
        break;

    }
    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
    return (g_cRef ? S_FALSE : S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI DllRegisterServer()
{
    UrlMkDebugOut((DEB_URLMON, "API _IN DllRegisterServer\n"));
    HRESULT hr;


    hr = HrDllRegisterServer(rgRegEntryGroups, g_hInst, NULL /*pfnLoadString*/);


    UrlMkDebugOut((DEB_URLMON, "API OUT DllRegisterServer (hr:%lx)\n",hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllUnregisterServer
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI DllUnregisterServer()
{
    UrlMkDebugOut((DEB_URLMON, "API _IN DllUnregisterServer\n"));
    HRESULT hr;

    hr = HrDllUnregisterServer(rgRegEntryGroups, g_hInst, NULL /*pfnLoadString*/);

    UrlMkDebugOut((DEB_URLMON, "API OUT DllUnregisterServer (hr:%lx)\n",hr));
    return hr;
}


#if DBG==1

#include <sem.hxx>
CMutexSem   mxs;
void TransUrlSpy(int iOption, const char *pscFormat, ...)
{
    static char szOutBuffer[2048];
    CLock       lck(mxs);
    DWORD tid = GetCurrentThreadId();
    DWORD cbBufLen;
    sprintf(szOutBuffer,"%08x> ", tid );
    cbBufLen = strlen(szOutBuffer);

    va_list args;
    if (iOption & TransInfoLevel)
    {
        va_start(args, pscFormat);
        wvsprintf(szOutBuffer + cbBufLen, pscFormat, args);
        va_end(args);
        UrlSpySendEntry(szOutBuffer);
    }
}
void UrlMkUrlSpy(int iOption, const char *pscFormat, ...)
{
    static char szOutBuffer[2048];
    CLock       lck(mxs);
    DWORD tid = GetCurrentThreadId();
    DWORD cbBufLen;
    sprintf(szOutBuffer,"%08x> ", tid );
    cbBufLen = strlen(szOutBuffer);

    va_list args;
    if (iOption & UrlMkInfoLevel)
    {
        va_start(args, pscFormat);
        wvsprintf(szOutBuffer + cbBufLen, pscFormat, args);
        va_end(args);
        UrlSpySendEntry(szOutBuffer);
    }
}

void UrlSpy(int iOption, const char *pscFormat, ...)
{
    static char szOutBuffer[2048];
    CLock       lck(mxs);
    DWORD tid = GetCurrentThreadId();
    DWORD cbBufLen;
    //sprintf(szOutBuffer,"%08x.%08x> ", pid, tid );
    sprintf(szOutBuffer,"%08x> ", tid );
    cbBufLen = strlen(szOutBuffer);

    va_list args;
    //if (   (iOption & DEB_INVOKES) )
    {
        va_start(args, pscFormat);
        wvsprintf(szOutBuffer + cbBufLen, pscFormat, args);
        va_end(args);
        UrlSpySendEntry(szOutBuffer);
    }
}

IDebugOut *v_pDbgOut = NULL;

void UrlSpySendEntry(LPSTR szOutBuffer)
{
    if (v_pDbgOut)
    {
        v_pDbgOut->SendEntry(szOutBuffer);
    }
    {
        OutputDebugString(szOutBuffer);
    }
}

HRESULT RegisterDebugOut(IDebugOut *pDbgOut)
{
    if (v_pDbgOut)
    {
        v_pDbgOut->Release();
        v_pDbgOut = NULL;
    }
    if (pDbgOut)
    {

        v_pDbgOut = pDbgOut;
        pDbgOut->AddRef();
    }
    return NOERROR;
}


#endif //DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\search\resprot.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       resprot.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include <stdio.h>
#include <sem.hxx>
#include <wininet.h>
#include "urlcf.hxx"
#include "protbase.hxx"
#include "resprot.hxx"
#include <tchar.h>

#define MAX_ID 10000


HRESULT LookupProtocolClsIDFromReg(LPCTSTR pszUrl, CLSID *pclsid);

#define SZPROTOCOLROOT  "PROTOCOLS\\Handler\\"
#define SZCLASS         "CLSID"

#define SZMYPROTOCOL    "search"



//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::Start
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pTrans] --
//              [pOIBindInfo] --
//              [grfSTI] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CResProtocol::Start(LPCWSTR pwzUrl, IOInetProtocolSink *pTrans, IOInetBindInfo *pOIBindInfo,
                          DWORD grfSTI, DWORD dwReserved)
{
    TransDebugOut((DEB_PROT, "%p _IN CResProtocol::Start\n", this));
    HRESULT hr = NOERROR;
    CLSID clsid;

    TransAssert((!_pProtSink && pOIBindInfo && pTrans));
    TransAssert((_pszUrl == NULL));

    // have to start the base class to get the bindinfo and the full URL.

    hr = CBaseProtocol::Start(pwzUrl,pTrans, pOIBindInfo, grfSTI, dwReserved);

    if (hr == NOERROR)
    {
        // first, check if this is hookable URL.
        // return E_USEDEFAULTPROTOCAL if not.

        if ((hr = Bind()) == NOERROR)
        {
            // We need to use the new (cooked) URL if Bind() succeeded.

            if ((hr = LookupProtocolClsIDFromReg(_szNewUrl, &clsid)) == NOERROR)
            {
                IClassFactory *pCF = 0;
                hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER,IID_IClassFactory, (void**)&pCF);
                if (hr == NOERROR)
                {
                    // Perf: 
                    // we might want to move Create/Release of the HTTP protocl handler out of
                    // Start/Terminate to Create/Release.
    
                    hr = pCF->CreateInstance(NULL, IID_IOInetProtocol, (void **)&_pProt);
                    if (hr == NOERROR)
                    {
                        // ???
                        // We also may need to implement our own IOInetBindInfo so that we
                        // can give it the new (cooked) BindInfo.

                        // We need to pass down the new (cooked) URL if Bind() succeeded.

                        LPWSTR pwzNewUrl = DupA2W(_szNewUrl);
            
                        if (pwzNewUrl)
                        {
                            hr = _pProt->Start(pwzNewUrl, pTrans, pOIBindInfo, grfSTI, dwReserved);

                            delete pwzNewUrl;
                        }
                    }
    
                    pCF->Release();
                }
    
            }
        }
    }

    TransDebugOut((DEB_PROT, "%p OUT CResProtocol::Start (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::Continue
//
//  Synopsis:
//
//  Arguments:  [pStateInfoIn] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CResProtocol::Continue(PROTOCOLDATA *pStateInfoIn)
{
    TransDebugOut((DEB_PROT, "%p _IN CResProtocol::Continue\n", this));
    HRESULT hr = E_FAIL;

    if (_pProt)
        hr = _pProt->Continue(pStateInfoIn);

    TransDebugOut((DEB_PROT, "%p OUT CResProtocol::Continue (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::Read
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//              [ULONG] --
//              [pcbRead] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CResProtocol::Read(void *pv,ULONG cb,ULONG *pcbRead)
{
    TransDebugOut((DEB_PROT, "%p _IN CResProtocol::Read (cb:%ld)\n", this,cb));
    HRESULT hr = NOERROR;

    if (_pProt)
        hr = _pProt->Read(pv, cb, pcbRead);

    TransDebugOut((DEB_PROT, "%p OUT CResProtocol::Read (pcbRead:%ld, hr:%lx)\n",this,*pcbRead, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::Seek
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [ULARGE_INTEGER] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:      WORK: not done
//
//----------------------------------------------------------------------------
STDMETHODIMP CResProtocol::Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    TransDebugOut((DEB_PROT, "%p _IN CResProtocol::Seek\n", this));
    HRESULT hr = NOERROR;

    if (_pProt)
        hr = _pProt->Seek(dlibMove, dwOrigin, plibNewPosition);

    TransDebugOut((DEB_PROT, "%p OUT CResProtocol::Seek (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::CResProtocol
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CResProtocol::CResProtocol(REFCLSID rclsid, IUnknown *pUnkOuter, IUnknown **ppUnkInner) : CBaseProtocol(rclsid, pUnkOuter, ppUnkInner)
{
    TransDebugOut((DEB_PROT, "%p _IN/OUT CResProtocol::CResProtocol \n", this));
}

//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::~CResProtocol
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CResProtocol::~CResProtocol()
{
    TransDebugOut((DEB_PROT, "%p _IN/OUT CResProtocol::~CResProtocol \n", this));
}


// SUPER HACK FUNCTION because InternetCrackUrl is not very good.
// THIS FUNCTION DOES NOT CHECK THE INPUT BUFFER SIZE.
// AND CALLER MUST PROVIDE lpszUrlPath buffer for us to parse.

BOOL
MyCrackUrl(
    LPCSTR lpszUrl,
    DWORD dwUrlLength,
    DWORD dwFlags,
    LPURL_COMPONENTSA lpUC
)
{
    LPSTR pszBuf = lpUC->lpszUrlPath;
    DWORD dwSize = lpUC->dwUrlPathLength;
    BOOL ret = FALSE;

    if (pszBuf)
    {
        if (InternetCanonicalizeUrl(lpszUrl, pszBuf, &dwSize, ICU_DECODE | ICU_NO_ENCODE))
        {
            // find protocol

            LPSTR pTmp = StrChr(pszBuf, ':');

            if (pTmp)
            {
                *pTmp = '\0';

                if (lpUC->lpszScheme)
                {
                    lstrcpy(lpUC->lpszScheme, pszBuf);
                    lpUC->dwSchemeLength = pTmp - pszBuf;
                }

                pszBuf = ++pTmp;

                // skip '/'s

                while (*pszBuf && (*pszBuf == '/')) 
                    pszBuf++;

                // find host name

                pTmp = StrChr(pszBuf, '/');

                if (lpUC->lpszHostName)
                {
                    if (pTmp)
                        lpUC->dwHostNameLength = pTmp - pszBuf;
                    else
                        lpUC->dwHostNameLength = lstrlen(pszBuf);
    
                    // + 1 for the NULL terminator
    
                    lstrcpyn(lpUC->lpszHostName, pszBuf, lpUC->dwHostNameLength + 1);
                }

                // if a '/' was found, the rest is URL path

                if (pTmp)
                    lpUC->dwUrlPathLength = lstrlen(pTmp);
                else
                    lpUC->dwUrlPathLength = 0;

                lpUC->lpszUrlPath = pTmp;

                ret = TRUE;
            }
        }
    }

    return ret;
}


//+---------------------------------------------------------------------------
//
//  Method:     CResProtocol::Bind
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CResProtocol::Bind()
{
    TransDebugOut((DEB_PROT, "%p _IN CResProtocol::Bind (szUrl >%s< )\n", this, _pszUrl));

    // HRESULT hr = MK_E_SYNTAX;
    // HRESULT hr = INET_E_USE_DEFAULT_PROTOCOLHANDLER;
    HRESULT hr = MK_E_NOPREFIX;
    // HRESULT hr = INET_E_UNKNOWN_PROTOCOL;
    URL_COMPONENTS uc;
    TCHAR szScheme[INTERNET_MAX_SCHEME_LENGTH];
    TCHAR szHost[INTERNET_MAX_HOST_NAME_LENGTH];
    TCHAR szURL[MAX_URL_SIZE];
    DWORD dwNeeded;
    LPSTR lpSearchName;
    LPSTR lpNewName = NULL;

    ZeroMemory(&uc, sizeof(uc));
    uc.dwStructSize = sizeof(uc);
    uc.lpszScheme = szScheme;
    uc.dwSchemeLength = ARRAYSIZE(szScheme);
    uc.lpszHostName = szHost;
    uc.dwHostNameLength = ARRAYSIZE(szHost);
    uc.lpszUrlPath = szURL;
    uc.dwUrlPathLength = ARRAYSIZE(szURL);

    // uc.dwExtraInfoLength ???

    // BUGBUG ???
    // InternetCrackUrl doesn't work with "search:\\..."

    if (MyCrackUrl(_pszUrl, 0, ICU_DECODE, &uc))
    {
        // TODO:
        // process the URL string

        if (!lstrcmpi(szScheme, SZMYPROTOCOL))
        {
            // if this is our "search:" protocol

            // BUGBUG
            // we need to look up the registry for the default protocol to use.

            uc.lpszScheme = NULL;
            uc.nScheme = INTERNET_SCHEME_HTTP;
            uc.nPort = INTERNET_DEFAULT_HTTP_PORT;

            if (uc.dwHostNameLength)
            {
                lpSearchName = uc.lpszHostName;
                uc.dwHostNameLength = 0;

                // ???
                // should we clear the UrlPath and ExtraInfo
            }
            else if (uc.dwUrlPathLength)
            {
                lpSearchName = uc.lpszUrlPath;
                uc.lpszUrlPath = NULL;
            }
            else
                lpSearchName = NULL;

            if (lpSearchName)
            {
                // apply the search.
                // ==========================================================
                if (!lstrcmpi(lpSearchName, "united airline"))
                    lpNewName = "www.ual.com";
                else if (!lstrcmpi(lpSearchName, "foo bar"))
                    lpNewName = "msw";
                // ==========================================================

                if (lpNewName)
                {
                    // this is a searchable string

                    uc.lpszHostName = lpNewName;
    
                    dwNeeded = ARRAYSIZE(_szNewUrl);
        
                    if (InternetCreateUrl(&uc, 0, _szNewUrl, &dwNeeded))
                        hr = NOERROR;
                }
            }
        }
        else if (uc.nScheme == INTERNET_SCHEME_HTTP)
        {
            lpSearchName = uc.lpszHostName;

            // apply search
            // ==========================================================
            if (!lstrcmpi(lpSearchName, "united airline"))
                lpNewName = "www.ual.com";
            else if (!lstrcmpi(lpSearchName, "foo bar"))
                lpNewName = "msw";
            // ==========================================================

            if (lpNewName)
            {
                // if search succeeded
                uc.lpszHostName = lpNewName;
                uc.dwHostNameLength = 0;
    
                dwNeeded = ARRAYSIZE(_szNewUrl);
    
                if (InternetCreateUrl(&uc, 0, _szNewUrl, &dwNeeded))
                    hr = NOERROR;
            }
        }
    }
    else
    {
        DebugBreak();

        DWORD dwError = GetLastError();
    }

    if (hr != NOERROR)
    {
        _pProtSink->ReportResult(hr, 0, 0);
    }

    TransDebugOut((DEB_PROT, "%p OUT CResProtocol::Bind (hr:%lx)\n", this,hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   LookupProtocolClsIDFromReg
//
//  Synopsis:   finds a protocol handler class for a given URL
//
//  Arguments:  [pwzUrl] --
//              [pclsid] --
//
//  Returns:
//
//  History:    11-01-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT LookupProtocolClsIDFromReg(LPCTSTR pszUrl, CLSID *pclsid)
{
    TransDebugOut((DEB_PROT, "API _IN LookupProtocolClsIDFromReg (szUrl >%s< )\n", pszUrl));
    HRESULT hr = INET_E_UNKNOWN_PROTOCOL;
    DWORD dwType;
    TCHAR pszProt[MAX_URL_SIZE + 1];

    TransAssert((pszUrl && pclsid));

    if (pszUrl)
    {
        char szDelimiter = ':';

        lstrcpy(pszProt, pszUrl);

        LPSTR pszDel = StrChr(pszProt, szDelimiter);

        if (pszDel)
        {
            *pszDel = '\0';

            // fail if the protocol is "search" so we don't get call recursively.
            if (lstrcmpi(pszProt, SZMYPROTOCOL))
            {
                HKEY hProtocolKey = NULL;
                DWORD dwLen = 256;
                char szProtocolKey[256];

                lstrcpy(szProtocolKey, SZPROTOCOLROOT);
                lstrcat(szProtocolKey, pszProt);
    
                if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szProtocolKey, 0, KEY_QUERY_VALUE, &hProtocolKey) == ERROR_SUCCESS)
                {
                    if (RegQueryValueEx(hProtocolKey, SZCLASS, NULL, &dwType, (LPBYTE)szProtocolKey, &dwLen) == ERROR_SUCCESS)
                    {
                        LPWSTR pwzClsId = DupA2W(szProtocolKey);
    
                        if (pwzClsId)
                        {
                            hr = CLSIDFromString(pwzClsId, pclsid);
                            TransDebugOut((DEB_PROT, "API FOUND LookupProtocolClsIDFromReg(hr:%lx, ClsId:%ws)\n", hr,pwzClsId));
                            delete pwzClsId;
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                    }
    
                    RegCloseKey(hProtocolKey);
                }
            }
        }
        else
        {
            // look up the registry
            hr = MK_E_SYNTAX;
        }
    }

    TransDebugOut((DEB_PROT, "API OUT LookupProtocolClsIDFromReg(hr:%lx)\n", hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\stg\casynclb.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       CASYNCLB.CXX
//
//  Contents:
//
//  Classes:    Implements the IAsyncLockBytes class.
//
//  Functions:
//
//  History:    12-13-95    JoeS (Joe Souza)    Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include <urlmon.hxx>
#include "casynclb.hxx"

CAsyncLockBytes::CAsyncLockBytes(ILockBytes *pLB) : _CRefs()
{
    _cbFillOffset.QuadPart = 0;
    _fFillDone = FALSE;
    _pLBchain = pLB;
}

STDMETHODIMP CAsyncLockBytes::QueryInterface
    (REFIID riid, LPVOID FAR* ppvObj)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN CAsyncLockBytes::QueryInterface\n", this));

    HRESULT hresult = NOERROR;

    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_ILockBytes)
       )
    {
        *ppvObj = (ILockBytes *)this;
    }
    else if (IsEqualIID(riid, IID_IFillLockBytes))
    {
        *ppvObj = (IFillLockBytes *)this;
    }
    else
    {
        *ppvObj = NULL;
        hresult = E_NOINTERFACE;
    }

    if (*ppvObj)
    {
        AddRef();

        if (_pLBchain)
            _pLBchain->AddRef();
    }

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT CAsyncLockBytes::QueryInterface\n", this));
    return hresult;
}

STDMETHODIMP_(ULONG) CAsyncLockBytes::AddRef(void)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN CAsyncLockBytes::AddRef\n", this));

    LONG lRet = ++_CRefs;

    if (_pLBchain)
        _pLBchain->AddRef();

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT CAsyncLockBytes::AddRef\n", this));
    return lRet;
}

STDMETHODIMP_(ULONG) CAsyncLockBytes::Release(void)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN CAsyncLockBytes::Release\n", this));
    UrlMkAssert((_CRefs > 0));

    LONG lRet = --_CRefs;

    if (_pLBchain)
        _pLBchain->Release();

    if (_CRefs == 0)
    {
        delete this;
    }

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT CAsyncLockBytes::Release\n", this));
    return lRet;
}

HRESULT CAsyncLockBytes::ReadAt(THIS_ ULARGE_INTEGER ulOffset, VOID HUGEP *pv,
    ULONG cb, ULONG FAR *pcbRead)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN CAsyncLockBytes::ReadAt\n", this));

    if (_pLBchain)
    {
#if 0
        while (TRUE)
        {
#endif
            hresult = _pLBchain->ReadAt(ulOffset, pv, cb, pcbRead);
#if 0
            if (hresult != NOERROR)
                break;

            if (*pcbRead == cb || _fFillDone)
                break;

            hresult = BlockOnIFillLockBytes(this);
            if (hresult != S_OK)
                break;
        }
#endif
    }

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT CAsyncLockBytes::ReadAt\n", this));
    return(hresult);
}

HRESULT CAsyncLockBytes::WriteAt(THIS_ ULARGE_INTEGER ulOffset, VOID const HUGEP *pv,
    ULONG cb, ULONG FAR *pcbWritten)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN CAsyncLockBytes::WriteAt\n", this));

    if (_pLBchain)
        hresult = _pLBchain->WriteAt(ulOffset, pv, cb, pcbWritten);

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT CAsyncLockBytes::WriteAt\n", this));
    return(hresult);
}

HRESULT CAsyncLockBytes::Flush()
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN CAsyncLockBytes::Flush\n", this));

    if (_pLBchain)
        hresult = _pLBchain->Flush();

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT CAsyncLockBytes::Flush\n", this));
    return(hresult);
}

HRESULT CAsyncLockBytes::SetSize(THIS_ ULARGE_INTEGER cb)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN CAsyncLockBytes::SetSize\n", this));

    if (_pLBchain)
        hresult = _pLBchain->SetSize(cb);

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT CAsyncLockBytes::SetSize\n", this));
    return(hresult);
}

HRESULT CAsyncLockBytes::LockRegion(THIS_ ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb, DWORD dwLockType)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN CAsyncLockBytes::LockRegion\n", this));

    if (_pLBchain)
        hresult = _pLBchain->LockRegion(libOffset, cb, dwLockType);

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT CAsyncLockBytes::LockRegion\n", this));
    return(hresult);
}

HRESULT CAsyncLockBytes::UnlockRegion(THIS_ ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb, DWORD dwLockType)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN CAsyncLockBytes::UnlockRegion\n", this));

    if (_pLBchain)
        hresult = _pLBchain->UnlockRegion(libOffset, cb, dwLockType);

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT CAsyncLockBytes::UnlockRegion\n", this));
    return(hresult);
}

HRESULT CAsyncLockBytes::Stat(THIS_ STATSTG FAR *pStatStg, DWORD grfStatFlag)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN CAsyncLockBytes::Stat\n", this));

    if (_pLBchain)
        hresult = _pLBchain->Stat(pStatStg, grfStatFlag);

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT CAsyncLockBytes::Stat\n", this));
    return(hresult);
}

HRESULT CAsyncLockBytes::FillAppend(void const *pv, ULONG cb, ULONG *pcbWritten)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN CAsyncLockBytes::FillAppend\n", this));

    if (!_fFillDone)
    {
        hresult = WriteAt(_cbFillOffset, pv, cb, pcbWritten);
        _cbFillOffset.QuadPart += *pcbWritten;
    }

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT CAsyncLockBytes::FillAppend\n", this));
    return(hresult);
}

HRESULT CAsyncLockBytes::Terminate(BOOL bCanceled)
{
    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN CAsyncLockBytes::Terminate\n", this));

    _fFillDone = TRUE;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT CAsyncLockBytes::Terminate\n", this));
    return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\stg\clockbyt.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       CLOCKBYT.CXX
//
//  Contents:
//
//  Classes:    Implements the ILockBytes base class.
//
//  Functions:
//
//  History:    12-01-95    JoeS (Joe Souza)    Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include <urlmon.hxx>
#include "clockbyt.hxx"

CLockBytes::CLockBytes() : _CRefs()
{
}

STDMETHODIMP CLockBytes::QueryInterface
    (REFIID riid, LPVOID FAR* ppvObj)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN CLockBytes::QueryInterface\n", this));

    HRESULT hresult = NOERROR;

    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_ILockBytes)
       )
    {
        *ppvObj = this;
    }
    else
    {
        *ppvObj = NULL;
        hresult = E_NOINTERFACE;
    }

    if (*ppvObj)
        AddRef();

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT CLockBytes::QueryInterface\n", this));
    return hresult;
}

STDMETHODIMP_(ULONG) CLockBytes::AddRef(void)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN CLockBytes::AddRef\n", this));

    LONG lRet = ++_CRefs;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT CLockBytes::AddRef\n", this));
    return lRet;
}

HRESULT CLockBytes::Flush()
{
    UrlMkDebugOut((DEB_ILOCKBYTES, "%p CLockBytes::Flush (NoOp)\n", this));
    return(NOERROR);
}

HRESULT CLockBytes::LockRegion(THIS_ ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    UrlMkDebugOut((DEB_ILOCKBYTES, "%p CLockBytes::LockRegion (NoOp)\n", this));
    return(NOERROR);
}

HRESULT CLockBytes::UnlockRegion(THIS_ ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb, DWORD dwLockType)
{
    UrlMkDebugOut((DEB_ILOCKBYTES, "%p CLockBytes::UnlockRegion (NoOp)\n", this));
    return(NOERROR);
}

HRESULT CLockBytes::Stat(THIS_ STATSTG FAR *pStatStg, DWORD grfStatFlag)
{
    UrlMkDebugOut((DEB_ILOCKBYTES, "%p CLockBytes::Stat (NoOp)\n", this));
    return(STG_E_UNKNOWN);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\search\urlcf.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       urlcf.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include <stdio.h>
#include "urlcf.hxx"

extern GUID CLSID_ResProtocol;


//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::Create
//
//  Synopsis:
//
//  Arguments:  [clsid] --
//              [ppCF] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CUrlClsFact::Create(REFCLSID clsid, CUrlClsFact **ppCF)
{
    UrlMkDebugOut((DEB_URLMON, "NULL _IN CUrlClsFact::Create\n"));
    HRESULT hr = NOERROR;
    CUrlClsFact * pCF =  NULL;

    if (    (clsid == CLSID_ResProtocol) )
    {
        pCF = (CUrlClsFact *) new CUrlClsFact(clsid);
    }

    if (pCF == NULL)
    {
        UrlMkAssert((pCF));
        hr = E_OUTOFMEMORY;
    }
    else
    {
        *ppCF = pCF;
    }

    UrlMkDebugOut((DEB_URLMON, "%p OUT CUrlClsFact::Create (hr:%lx\n", pCF,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::CUrlClsFact
//
//  Synopsis:   constructor
//
//  Arguments:  [clsid] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:      we need to keep a refcount on the dll if for each object given to
//              outside, including ClassFactories.
//              The corresponding DllRelease is in the destructor
//
//----------------------------------------------------------------------------
CUrlClsFact::CUrlClsFact(REFCLSID clsid) : _CRefs(), _CLocks(0)
{
    _ClsID =  clsid;
    DllAddRef();
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::~CUrlClsFact
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CUrlClsFact::~CUrlClsFact()
{
    DllRelease();
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::CreateInstance
//
//  Synopsis:   creates an instance of an Explode Object
//
//  Arguments:  [pUnkOuter] -- controlling unknown (must be NULL)
//              [riid] --      id of desired interface
//              [ppv] --       pointer to receive the interface
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:      S_OK - success
//              CLASS_E_NOAGGREATION - the caller tried to aggregate
//              CLASS_E_CLASSNOTAVAILABLE - couldn't initialize the class
//              E_OUTOFMEMORY - not enough memory to instantiate class
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlClsFact::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppv)
{
    UrlMkDebugOut((DEB_URLMON, "%p _IN CUrlClsFact::CreateInstance\n", this));
    HRESULT hr = NOERROR;
    // Class factory init time, the pointer to the creation function of
    // the object is given.  Use that to create the object

    //DumpIID(riid);
    //DumpIID(_rClsID);

    if (riid == IID_IClassFactory)
    {
        *ppv = (IClassFactory *)this;
        AddRef();
    }
    else if (_ClsID == CLSID_ResProtocol)
    {

        hr = CreateAPP(_ClsID, pUnkOuter, riid, (IUnknown **)ppv);

    }

    UrlMkDebugOut((DEB_URLMON, "%p OUT CUrlClsFact::CreateInstance (hr:%lx)\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::LockServer
//
//  Synopsis:   locks the server, preventing it from being unloaded
//
//  Arguments:  [fLock] -- TRUE to lock, FALSE to unlock
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlClsFact::LockServer(BOOL fLock)
{
    UrlMkDebugOut((DEB_URLMON, "%p _IN CUrlClsFact::LockServer\n", this));
    HRESULT hr = NOERROR;
    if (fLock)
    {
        if (++_CLocks == 1)
        {
            DllAddRef();
        }
    }
    else
    {
        UrlMkAssert((_CLocks > 0));
        if (_CLocks > 0)
        {
            if (--_CLocks == 0)
            {
                DllRelease();
            }
        }
    }

    UrlMkDebugOut((DEB_URLMON, "%p OUT CUrlClsFact::LockServer (hr:%lx)\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CUrlClsFact::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CUrlClsFact::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    HRESULT hr = NOERROR;
    UrlMkDebugOut((DEB_URLMON, "%p _IN CUrlClsFact::QueryInterface\n", this));

    if (   riid == IID_IUnknown
        || riid == IID_IClassFactory)
    {
        *ppvObj = this;
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }
    if (hr == NOERROR)
    {
        AddRef();
    }

    UrlMkDebugOut((DEB_URLMON, "%p OUT CUrlClsFact::QueryInterface (hr:%lx\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CUrlClsFact::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CUrlClsFact::AddRef(void)
{
    UrlMkDebugOut((DEB_URLMON, "%p _IN CUrlClsFact::AddRef\n", this));

    LONG lRet = ++_CRefs;

    UrlMkDebugOut((DEB_URLMON, "%p OUT CUrlClsFact::AddRef (cRefs:%ld)\n", this,lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CUrlClsFact::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CUrlClsFact::Release(void)
{
    UrlMkDebugOut((DEB_URLMON, "%p _IN CUrlClsFact::Release\n", this));

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        delete this;
    }

    UrlMkDebugOut((DEB_URLMON, "%p OUT CUrlClsFact::Release (cRefs:%ld)\n", this,lRet));
    return lRet;
}

#if DBG==1
HRESULT DumpIID(REFIID riid)
{

    HRESULT hr;
    LPOLESTR pszStr = NULL;
    hr = StringFromCLSID(riid, &pszStr);
    UrlMkDebugOut((DEB_BINDING, "API >>> DumpIID (riid:%ws) \n", pszStr));

    if (pszStr)
    {
        delete pszStr;
    }
    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\search\protbase.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       protbase.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include <stdio.h>
#include <sem.hxx>
#include <wininet.h>
#include "urlcf.hxx"
#include "protbase.hxx"
#include "resprot.hxx"


extern GUID CLSID_ResProtocol;


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::QueryInterface\n", this));

    hr = _pUnkOuter->QueryInterface(riid, ppvObj);

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::QueryInterface (hr:%lx\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CBaseProtocol::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBaseProtocol::AddRef(void)
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::AddRef\n", this));

    LONG lRet = _pUnkOuter->AddRef();

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::AddRef (cRefs:%ld)\n", this,lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CBaseProtocol::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBaseProtocol::Release(void)
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::Release\n", this));

    LONG lRet = _pUnkOuter->Release();

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::Release (cRefs:%ld)\n",this,lRet));
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Start
//
//  Synopsis:
//
//  Arguments:  [pwzUrl] --
//              [pTrans] --
//              [pOIBindInfo] --
//              [grfSTI] --
//              [dwReserved] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Start(LPCWSTR pwzUrl, IOInetProtocolSink *pTrans, IOInetBindInfo *pOIBindInfo,
                          DWORD grfSTI, DWORD dwReserved)
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::Start\n", this));
    HRESULT hr = NOERROR;

    TransAssert((!_pProtSink && pOIBindInfo && pTrans));
    TransAssert((_pszUrl == NULL));

    _pProtSink = pTrans;
    _pProtSink->AddRef();

    _BndInfo.cbSize = sizeof(BINDINFO);

    _pOIBindInfo =  pOIBindInfo;
    _pOIBindInfo->AddRef();

    hr = pOIBindInfo->GetBindInfo(&_grfBindF, &_BndInfo);

    // save the URL
    _pszUrl = DupW2A(pwzUrl);

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::Start (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Continue
//
//  Synopsis:
//
//  Arguments:  [pStateInfoIn] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Continue(PROTOCOLDATA *pStateInfoIn)
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::Continue\n", this));

    HRESULT hr = E_FAIL;

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::Continue (hr:%lx)\n",this, hr));
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Abort
//
//  Synopsis:
//
//  Arguments:  [hrReason] --
//              [dwOptions] --
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Abort(HRESULT hrReason, DWORD dwOptions)
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::Abort\n", this));
    HRESULT hr = NOERROR;

    if (_pProt)
        return _pProt->Abort(hrReason, dwOptions);

    TransAssert((_pProtSink));

    hr = _pProtSink->ReportResult(E_ABORT, 0, 0);

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::Abort (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Terminate
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Terminate(DWORD dwOptions)
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::Terminate\n", this));
    HRESULT hr = NOERROR;

    if (_pProt)
    {
        hr = _pProt->Terminate(dwOptions);

        if (FAILED(hr))
            return hr;

        _pProt->Release();
        _pProt = NULL;
    }

    TransAssert((_pProtSink));

    if (_pOIBindInfo)
    {
        _pOIBindInfo->Release();
        _pOIBindInfo = NULL;
    }
    if (_pProtSink)
    {
        _pProtSink->Release();
        _pProtSink = NULL;
    }

#if DBG == 1
    if ( _BndInfo.stgmedData.tymed != TYMED_NULL )
        TransDebugOut((DEB_TRANS, "%p --- CBaseProtocol::Stop ReleaseStgMedium (%p)\n", this,_BndInfo.stgmedData));
#endif

    ReleaseBindInfo(&_BndInfo);

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::Terminate (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Suspend
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Suspend()
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::Suspend\n", this));

    HRESULT hr = E_NOTIMPL;

    if (_pProt)
        hr = _pProt->Suspend();

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::Suspend (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Resume
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Resume()
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::Resume\n", this));

    HRESULT hr = E_NOTIMPL;

    if (_pProt)
        hr = _pProt->Resume();

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::Resume (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::SetPriority
//
//  Synopsis:
//
//  Arguments:  [nPriority] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::SetPriority(LONG nPriority)
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::SetPriority\n", this));

    HRESULT hr = E_NOTIMPL;

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::SetPriority (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::GetPriority
//
//  Synopsis:
//
//  Arguments:  [pnPriority] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::GetPriority(LONG * pnPriority)
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::GetPriority\n", this));

    HRESULT hr = E_NOTIMPL;

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::GetPriority (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Read
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//              [ULONG] --
//              [pcbRead] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Read(void *pv,ULONG cb,ULONG *pcbRead)
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::Read\n", this));

    HRESULT hr = E_FAIL;

    if (_pProt)
        hr = _pProt->Read(pv, cb, pcbRead);

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::Read (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Seek
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [ULARGE_INTEGER] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Seek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::Seek\n", this));

    HRESULT hr = E_FAIL;

    if (_pProt)
        hr = _pProt->Seek(dlibMove, dwOrigin, plibNewPosition);

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::Seek (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::LockRequest
//
//  Synopsis:
//
//  Arguments:  [dwOptions] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::LockRequest(DWORD dwOptions)
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::LockRequest\n", this));

    HRESULT hr = NOERROR;

    if (_pProt)
        hr = _pProt->LockRequest(dwOptions);

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::LockRequest (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::UnlockRequest
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::UnlockRequest()
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::UnlockRequest\n", this));

    HRESULT hr = NOERROR;

    if (_pProt)
        hr = _pProt->UnlockRequest();

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::UnlockRequest (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Prepare
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Prepare()
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::Prepare\n", this));
    HRESULT hr = NOERROR;

    TransAssert((  IsApartmentThread() ));


    TransDebugOut((DEB_PROT,"%p OUT CBaseProtocol::Prepare (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::Continue
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::Continue()
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::Continue\n", this));
    HRESULT hr = NOERROR;

    TransAssert((  !IsApartmentThread() ));

    _dwThreadID = GetCurrentThreadId();

    TransDebugOut((DEB_PROT,"%p OUT CBaseProtocol::Continue (hr:%lx)\n",this, hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::CBaseProtocol
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    1-27-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CBaseProtocol::CBaseProtocol(REFCLSID rclsid, IUnknown *pUnkOuter, IUnknown **ppUnkInner) : _CRefs(), _pclsidProtocol(rclsid), _Unknown()
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::CBaseProtocol \n", this));
    _dwThreadID = GetCurrentThreadId();
    _bscf = BSCF_FIRSTDATANOTIFICATION;
    _pOIBindInfo = 0;

    _pszUrl = 0;
    _pProt = 0;

    if (!pUnkOuter)
    {
        pUnkOuter = &_Unknown;
    }
    else
    {
        TransAssert((ppUnkInner));
        if (ppUnkInner)
        {
            *ppUnkInner =  &_Unknown;
            _CRefs = 0;
        }
    }

    _pUnkOuter = pUnkOuter;

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::CBaseProtocol \n", this));
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::~CBaseProtocol
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CBaseProtocol::~CBaseProtocol()
{
    if (_pszUrl)
        delete _pszUrl;

    TransDebugOut((DEB_PROT, "%p _IN/OUT CBaseProtocol::~CBaseProtocol \n", this));
}

//+---------------------------------------------------------------------------
//
//  Method:     CBaseProtocol::CPrivUnknown::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBaseProtocol::CPrivUnknown::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::CPrivUnknown::QueryInterface\n", this));
    CBaseProtocol *pCBaseProtocol = GETPPARENT(this, CBaseProtocol, _Unknown);

    *ppvObj = NULL;

    if ((riid == IID_IUnknown) || (riid == IID_IOInetProtocol) || (riid == IID_IOInetProtocolRoot) )
    {
        *ppvObj = (IOInetProtocol *) pCBaseProtocol;
        pCBaseProtocol->AddRef();
    }
    else if (riid == IID_IOInetThreadSwitch)
    {
        *ppvObj = (IOInetThreadSwitch *)pCBaseProtocol;
        pCBaseProtocol->AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::CPrivUnknown::QueryInterface (hr:%lx\n", this,hr));
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CBaseProtocol::CPrivUnknown::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBaseProtocol::CPrivUnknown::AddRef(void)
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::CPrivUnknown::AddRef\n", this));

    LONG lRet = ++_CRefs;

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::CPrivUnknown::AddRef (cRefs:%ld)\n", this,lRet));
    return lRet;
}
//+---------------------------------------------------------------------------
//
//  Function:   CBaseProtocol::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBaseProtocol::CPrivUnknown::Release(void)
{
    TransDebugOut((DEB_PROT, "%p _IN CBaseProtocol::CPrivUnknown::Release\n", this));

    CBaseProtocol *pCBaseProtocol = GETPPARENT(this, CBaseProtocol, _Unknown);

    LONG lRet = --_CRefs;

    if (lRet == 0)
    {
        delete pCBaseProtocol;
    }

    TransDebugOut((DEB_PROT, "%p OUT CBaseProtocol::CPrivUnknown::Release (cRefs:%ld)\n",this,lRet));
    return lRet;
}


//+---------------------------------------------------------------------------
//
//  Function:   OLESTRDuplicate
//
//  Synopsis:
//
//  Arguments:  [ws] --
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPWSTR OLESTRDuplicate(LPWSTR ws)
{
    LPWSTR wsNew = NULL;

    if (ws)
    {
        wsNew = (LPWSTR) new  WCHAR [wcslen(ws) + 1];
        if (wsNew)
        {
            wcscpy(wsNew, ws);
        }
    }

    return wsNew;
}

//+---------------------------------------------------------------------------
//
//  Function:   DupW2A
//
//  Synopsis:   duplicates a wide string to an ansi string
//
//  Arguments:  [pwz] --
//
//  History:    7-20-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPSTR DupW2A(const WCHAR *pwz)
{
    LPSTR szNew = NULL;

    if (pwz)
    {
        DWORD dwlen = wcslen(pwz) + 1;
        szNew = (LPSTR) new char [dwlen];
        if (szNew)
        {
            W2A(pwz, szNew, dwlen);
        }
    }

    return szNew;
}


//+---------------------------------------------------------------------------
//
//  Function:   DupA2W
//
//  Synopsis:   duplicates an ansi string to a wide string
//
//  Arguments:  [lpszAnsi] --
//
//  History:    7-20-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPWSTR DupA2W(const LPSTR psz)
{
    LPWSTR wzNew = NULL;

    if (psz)
    {
        DWORD dwlen = strlen(psz) + 1;
        wzNew = (LPWSTR) new WCHAR [dwlen];
        if (wzNew)
        {
            A2W(psz, wzNew, dwlen);
        }
    }

    return wzNew;
}


//BUG-WORK remove this and link to lib
const GUID IID_IOInet                = { 0x79eac9e0, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b} };
const GUID IID_IOInetBindInfo        = { 0x79eac9e1, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b} };
const GUID IID_IOInetBindClient      = { 0x79eac9e2, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b} };
const GUID IID_IOInetProtocolRoot    = { 0x79eac9e3, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b} };
const GUID IID_IOInetProtocol        = { 0x79eac9e4, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b} };
const GUID IID_IOInetProtocolSink    = { 0x79eac9e5, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b} };
const GUID IID_IOInetBinding         = { 0x79eac9e6, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b} };
const GUID IID_IOInetSession         = { 0x79eac967, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b} };
const GUID IID_IOInetThreadSwitch    = { 0x79eac968, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b} };
const GUID IID_IOInetBindSink        = { 0x79eac9e9, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b} };
const GUID IID_IOInetCache           = { 0x79eac9ea, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b} };
const GUID IID_IOInetPriority        = { 0x79eac9eb, 0xbaf9, 0x11ce, {0x8c, 0x82, 0x00, 0xaa, 0x00, 0x4b, 0xa9, 0x0b} };


//+---------------------------------------------------------------------------
//
//  Function:   CreateAPP
//
//  Synopsis:
//
//  Arguments:  [rclsid] --
//              [pUnkOuter] --
//              [riid] --
//              [ppUnk] --
//
//  Returns:
//
//  History:    11-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CreateAPP(REFCLSID rclsid, IUnknown *pUnkOuter, REFIID riid, IUnknown **ppUnk)
{
    TransDebugOut((DEB_PROT, "API _IN CreateKnownProtocolInstance\n"));
    HRESULT hr = NOERROR;

    TransAssert((ppUnk));

    if (!ppUnk || (pUnkOuter && (riid != IID_IUnknown)) )
    {
        // Note: aggregation only works if asked for IUnknown
        TransAssert((FALSE && "Dude, look up aggregation rules - need to ask for IUnknown"));
        hr = E_INVALIDARG;
    }
    else
    {
        CBaseProtocol *pCBaseProtocol = NULL;

        if (rclsid == CLSID_ResProtocol)
        {
            pCBaseProtocol = new CResProtocol(CLSID_ResProtocol,pUnkOuter, ppUnk);
        }

        if (pCBaseProtocol)
        {
            if (riid == IID_IUnknown)
            {

            }
            else if (riid == IID_IOInetProtocol)
            {
                // ok, got the right interface already
                *ppUnk = (IOInetProtocol *)pCBaseProtocol;
            }
            else
            {
                hr = pCBaseProtocol->QueryInterface(riid, (void **)ppUnk);
                // remove extra refcount
                pCBaseProtocol->Release();
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    TransDebugOut((DEB_PROT, "API OUT CreateKnownProtocolInstance(hr:%lx)\n", hr));
    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\search\selfreg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       selfreg.cxx
//
//  Contents:   Taken from Office96
//              Source file for the common self registration code used by all the
//              sub projects of Sweeper project. They are
//              UrlMon
//              UrlMnPrx
//
//  Exports:    HrDllRegisterServer()
//              HrDllUnregisterServer()
//
//  Classes:
//
//  Functions:
//
//  History:    5-03-96   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include "selfreg.hxx"

HINSTANCE g_hinstDll = NULL;
PFNLOADSTRING g_pfnLoadString = NULL;

//+---------------------------------------------------------------------------
//
//  Function:   GetDllFullPath
//
//  Synopsis:
//
//  Arguments:  [lpszExeName] --
//              [cch] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL GetDllFullPath( LPSTR lpszExeName, DWORD cch )
{
    if ( NULL == g_hinstDll )
    {
        UrlMkAssert(( FALSE && "NULL hInst"));
        return FALSE;
    }

    *lpszExeName = NULL;

    if ( GetModuleFileName( g_hinstDll, lpszExeName, cch ) == 0)
    {
        UrlMkAssert(( FALSE && "GetModuleFileName Failed"));
        return FALSE;
    }

    return TRUE;
}


inline BOOL IsASeparator( char ch )
{
    return (ch == '\\' || ch == '/' || ch == ':');
}

//+---------------------------------------------------------------------------
//
//  Function:   ParseAFileName
//
//  Synopsis:
//
//  Arguments:  [szFileName] --
//              [piRetLen] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
LPSTR ParseAFileName( LPSTR szFileName, int *piRetLen)
{
    LPSTR pszFile;

    // Start at the end of the filename.
    pszFile = szFileName + ( lstrlen(szFileName) - 1 );

    // Back up to a '\\' or beginning or something!! We just want a file
    // name!. Whatever comes first.
    while ( pszFile > szFileName && !IsASeparator(*pszFile ) )
        pszFile = CharPrev(szFileName, pszFile);

    if ( pszFile != szFileName )
        pszFile = CharNext(pszFile);

    if ( piRetLen )
        *piRetLen = lstrlen(pszFile);

    return pszFile;
}


//+---------------------------------------------------------------------------
//
//  Function:   FRegisterEntries
//
//  Synopsis:   FRegisterEntries: Register a group of reg entries off a base key.
//
//  Arguments:  [hkRoot] --
//              [rgEntries] --
//              [dwEntries] --
//              [pszPath] --
//              [pszBinderName] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL FRegisterEntries(HKEY hkRoot, const REGENTRY rgEntries[],
                    DWORD dwEntries, char *pszPath, char *pszBinderName)
{
    HKEY    hkey = NULL;
    LONG    lRet;
    char    szValue[1024];
    char    szResString[1024];
    char    szKeyName[1024];
    BOOL    fRet = FALSE;
    int         i;

    for (i = 0; i < (int)dwEntries; i++)
    {
        // We work with a copy of the entry, since we might modify it
        REGENTRY reCurrentEntry = rgEntries[i];

        if (reCurrentEntry.iKeyType ==  KEYTYPE_RESID)
        {
            int cch;
            if (g_pfnLoadString == NULL)
                return FALSE;
            cch = g_pfnLoadString(g_hinstDll, (UINT)reCurrentEntry.pszKey, szKeyName,
                    sizeof(szKeyName));
            if (cch > 0 && cch <= 1024)
            {
                reCurrentEntry.pszKey = szKeyName;
            }
            else
            {
                UrlMkAssert(( FALSE && "LoadString Failed ( 1)"));
                continue;
            }
        }

        lRet = RegCreateKey(hkRoot, reCurrentEntry.pszKey, &hkey);

        if (lRet != ERROR_SUCCESS)
        {
            UrlMkAssert(( FALSE && "RegCreateKey Failed ( 1)"));
            continue;
        }

         // If the type is REG_RESID, then pbData holds the resource ID.  We
         // load the resource string, then modify our reCurrentEntry to point
         // to it.

        if (reCurrentEntry.dwType == REG_RESID)
        {
            int cch;
            if (g_pfnLoadString == NULL)
                return FALSE;

            cch = g_pfnLoadString(g_hinstDll, (UINT)reCurrentEntry.pbData, szResString,
                    sizeof(szResString));
            if (cch > 0 && cch <= 1024)
            {
                reCurrentEntry.dwType = REG_SZ;
                reCurrentEntry.pbData = (BYTE*) szResString;
            }
            else
            {
                UrlMkAssert(( FALSE && "LoadString Failed (2)"));
                reCurrentEntry.pbData = NULL;
            }
        }


        // Set the value if there is one
        if (reCurrentEntry.pbData != NULL || reCurrentEntry.dwType != REG_SZ)
        {
            switch (reCurrentEntry.dwType)
            {
                case REG_SZ:
                    // Replace the first %s with the path, and the second
                    // %s with the name of the binder app (may not do anything).
                    if (pszPath != NULL && pszBinderName != NULL)
                    {
                        wsprintf(szValue, (char*)reCurrentEntry.pbData, pszPath,
                            pszBinderName);

                        lRet = RegSetValueEx(hkey, reCurrentEntry.pszValueName, 0,
                            REG_SZ, (BYTE*)szValue, lstrlen(szValue)+1);
#if DBG == 1
                        if ( ERROR_SUCCESS != lRet )
                            UrlMkAssert(( FALSE && "RegSetValueEx Failed ( 1)"));
#endif
                    }
                    break;

                case REG_DWORD:
                    lRet = RegSetValueEx(hkey, reCurrentEntry.pszValueName, 0,
                        REG_DWORD,  (BYTE*)&reCurrentEntry.pbData, sizeof(DWORD));

#if DBG == 1
                    if ( ERROR_SUCCESS != lRet )
                        UrlMkAssert(( FALSE && "RegSetValueEx Failed (2)"));
#endif
                    break;

                default:
                    UrlMkAssert(( FALSE && "Unexpected reg entry type"));
                    // Unexpected type: ignore
                    break;
            }
        }

        // Close the subkey
        RegCloseKey(hkey);
        hkey = NULL;
    }

    fRet = TRUE;

    // Close the base key if it was open
    if (hkey)
        RegCloseKey(hkey);

    return fRet;
}


/*
 * FRegisterEntryGroups: Register several groups of reg entries.
 */
BOOL FRegisterEntryGroups(const REGENTRYGROUP *rgRegEntryGroups,
    char *pszPath, char *pszBinderName)
{
    BOOL fError = FALSE;
    int i;

    // Keep going even if we get some errors
    for (i=0; rgRegEntryGroups[i].hkRoot != NULL; i++)
    {
        if (!FRegisterEntries(rgRegEntryGroups[i].hkRoot, rgRegEntryGroups[i].rgEntries,
            rgRegEntryGroups[i].dwEntries,pszPath, pszBinderName))
        {
            fError = TRUE;
        }
    }

    return !fError;
}

//+---------------------------------------------------------------------------
//
//  Function:   FDeleteEntries
//
//  Synopsis:   Delete a group of reg entries off a base key.
//
//  Arguments:  [hkRoot] --
//              [rgEntries] --
//              [dwEntries] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL FDeleteEntries(HKEY hkRoot, const REGENTRY rgEntries[], DWORD dwEntries)
{
    LONG    lRet;
    int         i;
    char    szKeyName[1024];
    PSTR    pKey;

    // Delete in reverse order, to kill children before parent
    for (i = (int)dwEntries - 1; i >= 0; i--)
    {
        pKey = NULL;

        if (rgEntries[i].iKeyType ==  KEYTYPE_RESID)
        {
            int cch;
            cch = g_pfnLoadString(g_hinstDll, (UINT)rgEntries[i].pszKey, szKeyName,
                    sizeof(szKeyName));
            if (cch > 0 && cch <= 1024)
            {
                pKey = szKeyName;
            }
        else
            {
                UrlMkAssert(( FALSE && "LoadString Failed (FDeleteEntries)"));
                continue;
            }
        }
        else
        {
            if ( KEYTYPE_STRING != rgEntries[i].iKeyType )
            {
                UrlMkAssert(( FALSE && "Unknown Key Type"));
                continue;
            }
            pKey = rgEntries[i].pszKey;
        }

        if (pKey != NULL)
        {
            // Delete the current key if it has no subkeys.
            // Ignore the return value.
            lRet = RegDeleteKey(hkRoot, pKey);
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   FDeleteEntryGroups
//
//  Synopsis:   Delete the base keys of all the given groups.

//
//  Arguments:  [rgRegEntryGroups] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL FDeleteEntryGroups(const REGENTRYGROUP *rgRegEntryGroups)
{
    BOOL fError = FALSE;

    // Keep going even if we get some errors
    for (int i=0; rgRegEntryGroups[i].hkRoot != NULL; i++)
    {
        if (!FDeleteEntries(rgRegEntryGroups[i].hkRoot,
            rgRegEntryGroups[i].rgEntries,
            rgRegEntryGroups[i].dwEntries))
        {
            fError = TRUE;
        }
    }

    return !fError;
}


#ifdef NOT_USED
/*
 * FDeleteSubtree - Delete given key and all subkeys
 */
BOOL FDeleteSubtree(HKEY hkRoot, char *pszKey)
{
    HKEY        hkey = NULL;
    LONG        lRet;
    char        szSubKey[MAX_PATH];

    lRet = RegOpenKey(hkRoot, pszKey, &hkey);
    if (lRet != ERROR_SUCCESS)
        goto End;

    // remove all subkeys
    for (;;)
{
        lRet = RegEnumKey(hkey, 0, szSubKey, sizeof szSubKey);

        if (lRet == ERROR_NO_MORE_ITEMS)
            break;

        if (lRet != ERROR_SUCCESS)
            goto End;

        if (!FDeleteSubtree(hkey, szSubKey))
            goto End;
}

End:
    if (hkey != NULL)
        RegCloseKey (hkey);

    lRet = RegDeleteKey(hkRoot, pszKey);

    return (lRet == ERROR_SUCCESS);
}
#endif // NOT_USED



//+---------------------------------------------------------------------------
//
//  Function:   HrDllRegisterServer
//
//  Synopsis:   registers an entrygroup
//
//  Arguments:  [HINSTANCE] --
//              [hinstDll] --
//              [pfnLoadString] --
//              [pszAppName] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT HrDllRegisterServer(const REGENTRYGROUP *rgRegEntryGroups,HINSTANCE hinstDll,
                            PFNLOADSTRING pfnLoadString, char *pszAppName)
{
    // REVIEW: for Windows dll, do we want to register full path?
    BOOL    fRet = TRUE;
    char    szFullPath[MAX_PATH];
    char    szFileName[MAX_PATH];
    char    *pszFileName;

    g_hinstDll = hinstDll;
    if ((g_pfnLoadString = pfnLoadString) == NULL)
        // set the pointer to windows LoadString() api
        g_pfnLoadString = (PFNLOADSTRING) LoadString;

    if (!GetDllFullPath(szFullPath, MAX_PATH))
        return E_FAIL;

    pszFileName = ParseAFileName(szFullPath, NULL);

    if (pszAppName != NULL)
        lstrcpy(szFileName, pszAppName);
    else
        lstrcpy(szFileName, pszFileName);

    // Terminate the path at the file name
    *pszFileName = '\0';
    fRet = FRegisterEntryGroups(rgRegEntryGroups, szFullPath, szFileName);

    g_hinstDll = NULL;
    g_pfnLoadString = NULL;
    return fRet ? NOERROR : E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrDllUnregisterServer
//
//  Synopsis:   unregisters an entrygroup
//
//  Arguments:  [HINSTANCE] --
//              [hinstDll] --
//              [pfnLoadString] --
//
//  Returns:
//
//  History:         95    OfficeXX                 created
//              5-03-96   JohannP (Johann Posch)   port urlmon
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT HrDllUnregisterServer(const REGENTRYGROUP *rgRegEntryGroups,HINSTANCE hinstDll, PFNLOADSTRING pfnLoadString)
{
    g_hinstDll = hinstDll;
    if ((g_pfnLoadString = pfnLoadString) == NULL)
        // set the pointer to windows LoadString() api
        g_pfnLoadString = (PFNLOADSTRING) LoadString;

    FDeleteEntryGroups(rgRegEntryGroups);

    g_hinstDll = NULL;
    g_pfnLoadString = NULL;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\stg\cstream.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       CSTREAM.CXX
//
//  Contents:
//
//  Classes:    Implements the IStream class.
//
//  Functions:
//
//  History:    12-01-95    JoeS (Joe Souza)    Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include <urlmon.hxx>
#include "cstream.hxx"

CStream::CStream(IStream *pStr) : _CRefs()
{
    _pStream = pStr;
}

STDMETHODIMP CStream::QueryInterface
    (REFIID riid, LPVOID FAR* ppvObj)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStream::QueryInterface\n", this));

    HRESULT hresult = NOERROR;

    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IStream)
       )
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
        *ppvObj = NULL;
        hresult = E_NOINTERFACE;
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStream::QueryInterface\n", this));
    return hresult;
}

STDMETHODIMP_(ULONG) CStream::AddRef(void)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStream::AddRef\n", this));

    LONG lRet = ++_CRefs;

    if (_pStream)
        _pStream->AddRef();

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStream::AddRef\n", this));
    return lRet;
}

STDMETHODIMP_(ULONG) CStream::Release(void)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStream::Release\n", this));
    UrlMkAssert((_CRefs > 0));

    LONG lRet = --_CRefs;

    if (_pStream)
        _pStream->Release();

    if (_CRefs == 0)
    {
        delete this;
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStream::Release\n", this));
    return lRet;
}

HRESULT CStream::Read(THIS_ VOID HUGEP *pv, ULONG cb, ULONG FAR *pcbRead)
{
    HRESULT hresult = E_FAIL;
    ULONG   readcount;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStream::Read\n", this));

    if (_pStream)
    {
#if 0
        while (TRUE)
        {
#endif
            hresult = _pStream->Read(pv, cb, &readcount);
            if (pcbRead)
                *pcbRead = readcount;

#if 0
            if (hresult != NOERROR)
                break;

            if (readcount == cb)
                break;

            hresult = BlockOnIFillLockBytes(this);  // BUGBUG:
            if (hresult != S_OK)
                break;
        }
#endif
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStream::Read\n", this));
    return(hresult);
}

HRESULT CStream::Write(THIS_ VOID const HUGEP *pv, ULONG cb,
            ULONG FAR *pcbWritten)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStream::Write\n", this));

    if (_pStream)
        hresult = _pStream->Write(pv, cb, pcbWritten);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStream::Write\n", this));
    return(hresult);
}

HRESULT CStream::Seek(THIS_ LARGE_INTEGER dlibMove, DWORD dwOrigin,
            ULARGE_INTEGER FAR *plibNewPosition)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStream::Seek\n", this));

    if (_pStream)
        hresult = _pStream->Seek(dlibMove, dwOrigin, plibNewPosition);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStream::Seek\n", this));
    return(hresult);
}

HRESULT CStream::SetSize(THIS_ ULARGE_INTEGER libNewSize)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStream::SetSize\n", this));

    if (_pStream)
        hresult = _pStream->SetSize(libNewSize);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStream::SetSize\n", this));
    return(hresult);
}

HRESULT CStream::CopyTo(THIS_ LPSTREAM pStm, ULARGE_INTEGER cb,
            ULARGE_INTEGER FAR *pcbRead, ULARGE_INTEGER FAR *pcbWritten)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStream::CopyTo\n", this));

    if (_pStream)
        hresult = _pStream->CopyTo(pStm, cb, pcbRead, pcbWritten);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStream::CopyTo\n", this));
    return(hresult);
}

HRESULT CStream::Commit(THIS_ DWORD dwCommitFlags)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStream::Commit\n", this));

    if (_pStream)
        hresult = _pStream->Commit(dwCommitFlags);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStream::Commit\n", this));
    return(hresult);
}

HRESULT CStream::Revert(THIS)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStream::Revert\n", this));

    if (_pStream)
        hresult = _pStream->Revert();

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStream::Revert\n", this));
    return(hresult);
}

HRESULT CStream::LockRegion(THIS_ ULARGE_INTEGER libOffset,
            ULARGE_INTEGER cb, DWORD dwLockType)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStream::LockRegion\n", this));

    if (_pStream)
        hresult = _pStream->LockRegion(libOffset, cb, dwLockType);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStream::LockRegion\n", this));
    return(hresult);
}

HRESULT CStream::UnlockRegion(THIS_ ULARGE_INTEGER libOffset,
            ULARGE_INTEGER cb, DWORD dwLockType)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStream::UnlockRegion\n", this));

    if (_pStream)
        hresult = _pStream->UnlockRegion(libOffset, cb, dwLockType);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStream::UnlockRegion\n", this));
    return(hresult);
}

HRESULT CStream::Stat(THIS_ STATSTG FAR *pStatStg, DWORD grfStatFlag)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStream::Stat\n", this));

    if (_pStream)
        hresult = _pStream->Stat(pStatStg, grfStatFlag);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStream::Stat\n", this));
    return(hresult);
}

HRESULT CStream::Clone(THIS_ LPSTREAM FAR *ppStm)
{
    HRESULT hresult = E_FAIL;
    IStream *pStr, *pStrTop;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStream::Clone\n", this));

    *ppStm = NULL;

    if (_pStream)
    {
        hresult = _pStream->Clone(&pStr);
        if (hresult == S_OK)
        {
            if (!(pStrTop = new CStream(pStr)))
            {
                // BUGBUG: Delete pStr here!

                hresult = E_OUTOFMEMORY;
                goto CloneExit;
            }

            *ppStm = pStrTop;
        }
    }

CloneExit:

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStream::Clone\n", this));
    return(hresult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\stg\cstorage.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       CSTORAGE.CXX
//
//  Contents:
//
//  Classes:    Implements the IStorage class.
//
//  Functions:
//
//  History:    12-20-95    JoeS (Joe Souza)    Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include <urlmon.hxx>
#include "cstorage.hxx"
#include "cstream.hxx"

// Internal Function Prototypes
CStorage    *NewCStorage(IStorage *pStg);


CStorage::CStorage(IStorage *pStorage) : _CRefs()
{
    _pStg = pStorage;
}

STDMETHODIMP CStorage::QueryInterface
    (REFIID riid, LPVOID FAR* ppvObj)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::QueryInterface\n", this));

    HRESULT hresult = NOERROR;

    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IStream)
       )
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
        *ppvObj = NULL;
        hresult = E_NOINTERFACE;
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::QueryInterface\n", this));
    return hresult;
}

STDMETHODIMP_(ULONG) CStorage::AddRef(void)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::AddRef\n", this));

    LONG lRet = ++_CRefs;

    if (_pStg)
        _pStg->AddRef();

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::AddRef\n", this));
    return lRet;
}

STDMETHODIMP_(ULONG) CStorage::Release(void)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::Release\n", this));
    UrlMkAssert((_CRefs > 0));

    LONG lRet = --_CRefs;

    if (_pStg)
        _pStg->Release();

    if (_CRefs == 0)
    {
        delete this;
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::Release\n", this));
    return lRet;
}

HRESULT CStorage::CreateStream(THIS_ const OLECHAR *pwcsName, DWORD grfMode,
            DWORD dwReserved1, DWORD dwReserved2, LPSTREAM FAR *ppStm)
{
    HRESULT hresult = E_FAIL;
    IStream *pStream;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::CreateStream\n", this));

    if (_pStg)
    {
        hresult = _pStg->CreateStream(pwcsName, grfMode, dwReserved1, dwReserved2,
                    &pStream);

        if (hresult == S_OK)
        {
            if (!(*ppStm = new CStream(pStream)))
            {
                hresult = E_OUTOFMEMORY;

                // BUGBUG: Delete pStream!
            }
        }
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::CreateStream\n", this));
    return(hresult);
}

HRESULT CStorage::OpenStream(THIS_ const OLECHAR *pwcsName,
            void FAR *pReserved1, DWORD grfMode, DWORD dwReserved2,
            LPSTREAM FAR *ppStm)
{
    HRESULT hresult = E_FAIL;
    IStream *pStream;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::OpenStream\n", this));

    if (_pStg)
    {
        hresult = _pStg->OpenStream(pwcsName, pReserved1, grfMode, dwReserved2,
                    &pStream);

        if (hresult == S_OK)
        {
            if (!(*ppStm = new CStream(pStream)))
            {
                hresult = E_OUTOFMEMORY;

                // BUGBUG: Delete pStream!
            }
        }
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::OpenStream\n", this));
    return(hresult);
}


HRESULT CStorage::CreateStorage(THIS_ const OLECHAR *pwcsName, DWORD grfMode,
            DWORD dwReserved1, DWORD dwReserved2, LPSTORAGE FAR *ppStg)
{
    HRESULT     hresult = E_FAIL;
    IStorage    *pStorage;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::CreateStorage\n", this));

    if (_pStg)
    {
        hresult = _pStg->CreateStorage(pwcsName, grfMode, dwReserved1, dwReserved2,
                    &pStorage);

        if (hresult == S_OK)
        {
            if (!(*ppStg = ::NewCStorage(pStorage)))
            {
                hresult = E_OUTOFMEMORY;

                // BUGBUG: Delete pStorage!
            }
        }
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::CreateStorage\n", this));
    return(hresult);
}

HRESULT CStorage::OpenStorage(THIS_ const OLECHAR *pwcsName,
            LPSTORAGE pstgPriority, DWORD grfMode, SNB snbExclude,
            DWORD dwReserved, LPSTORAGE FAR *ppStg)
{
    HRESULT     hresult = E_FAIL;
    IStorage    *pStorage;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::OpenStorage\n", this));

    if (_pStg)
    {
        hresult = _pStg->OpenStorage(pwcsName, pstgPriority, grfMode, snbExclude,
                    dwReserved, &pStorage);

        if (hresult == S_OK)
        {
            if (!(*ppStg = ::NewCStorage(pStorage)))
            {
                hresult = E_OUTOFMEMORY;

                // BUGBUG: Delete pStorage!
            }
        }
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::OpenStorage\n", this));
    return(hresult);
}

HRESULT CStorage::CopyTo(THIS_ DWORD dwCiidExclude, IID const FAR *rgiidExclude,
            SNB snbExclude, LPSTORAGE pStgDest)
{
    HRESULT     hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::CopyTo\n", this));

    if (_pStg)
        hresult = _pStg->CopyTo(dwCiidExclude, rgiidExclude, snbExclude, pStgDest);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::CopyTo\n", this));
    return(hresult);
}

HRESULT CStorage::MoveElementTo(THIS_ const OLECHAR *lpszName,
            LPSTORAGE pStgDest, const OLECHAR *lpszNewName, DWORD grfFlags)
{
    HRESULT     hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::MoveElementTo\n", this));

    if (_pStg)
        hresult = _pStg->MoveElementTo(lpszName, pStgDest, lpszNewName, grfFlags);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::MoveElementTo\n", this));
    return(hresult);
}

HRESULT CStorage::Commit(THIS_ DWORD grfCommitFlags)
{
    HRESULT     hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::Commit\n", this));

    if (_pStg)
        hresult = _pStg->Commit(grfCommitFlags);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::Commit\n", this));
    return(hresult);
}

HRESULT CStorage::Revert(THIS)
{
    HRESULT     hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::Revert\n", this));

    if (_pStg)
        hresult = _pStg->Revert();

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::Revert\n", this));
    return(hresult);
}

HRESULT CStorage::EnumElements(THIS_ DWORD dwReserved1, void FAR *pReserved2,
            DWORD dwReserved3, LPENUMSTATSTG FAR *ppenumStatStg)
{
    HRESULT     hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::EnumElements\n", this));

    if (_pStg)
        hresult = _pStg->EnumElements(dwReserved1, pReserved2, dwReserved3,
                    ppenumStatStg);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::EnumElements\n", this));
    return(hresult);
}

HRESULT CStorage::DestroyElement(THIS_ const OLECHAR *pwcsName)
{
    HRESULT     hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::DestroyElement\n", this));

    if (_pStg)
        hresult = _pStg->DestroyElement(pwcsName);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::DestroyElement\n", this));
    return(hresult);
}

HRESULT CStorage::RenameElement(THIS_ const OLECHAR *pwcsOldName,
            const OLECHAR *pwcsNewName)
{
    HRESULT     hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::RenameElement\n", this));

    if (_pStg)
        hresult = _pStg->RenameElement(pwcsOldName, pwcsNewName);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::RenameElement\n", this));
    return(hresult);
}

HRESULT CStorage::SetElementTimes(THIS_ const OLECHAR *lpszName,
            FILETIME const FAR *pctime, FILETIME const FAR *patime,
            FILETIME const FAR *pmtime)
{
    HRESULT     hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::SetElementTimes\n", this));

    if (_pStg)
        hresult = _pStg->SetElementTimes(lpszName, pctime, patime, pmtime);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::SetElementTimes\n", this));
    return(hresult);
}

HRESULT CStorage::SetClass(THIS_ REFCLSID rclsid)
{
    HRESULT     hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::SetClass\n", this));

    if (_pStg)
        hresult = _pStg->SetClass(rclsid);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::SetClass\n", this));
    return(hresult);
}

HRESULT CStorage::SetStateBits(THIS_ DWORD grfStateBits, DWORD grfMask)
{
    HRESULT     hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::SetStateBits\n", this));

    if (_pStg)
        hresult = _pStg->SetStateBits(grfStateBits, grfMask);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::SetStateBits\n", this));
    return(hresult);
}

HRESULT CStorage::Stat(THIS_ STATSTG FAR *pStatStg, DWORD grfStatFlag)
{
    HRESULT     hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CStorage::Stat\n", this));

    if (_pStg)
        hresult = _pStg->Stat(pStatStg, grfStatFlag);

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CStorage::Stat\n", this));
    return(hresult);
}

// Internal functions

CStorage    *NewCStorage(IStorage *pStg)
{
    return(new CStorage(pStg));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\stg\precomp1.inc ===
#//+---------------------------------------------------------------
#//
#//  File:      precomp1.inc
#//
#//  Contents:  directives for global precompiled include file when the
#//             sources file is two directories below com (or wherever
#//             this file is located).  We could easily have precomp3 and
#//             precomp4 for other areas.The urlint.* files should not
#//             otherwise be mentioned in the sources files.
#//
#//
#//----------------------------------------------------------------

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\..\inc\urlint.h
PRECOMPILED_TARGET=$(GPCH_BUILD)\$(_OBJ_DIR)\*\urlint.pch
PRECOMPILED_OPTION=/Yuurlint.h /Fp$(GPCH_BUILD)\$(_OBJ_DIR)\*\urlint.pch
PRECOMPILED_OBJ=$(GPCH_BUILD)\$(_OBJ_DIR)\*\urlint.obj


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\stg\memlb.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       MEMLB.CXX
//
//  Contents:
//
//  Classes:    Implements the memory-based ILockBytes class.
//
//  Functions:
//
//  History:    12-13-95    JoeS (Joe Souza)    Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include <urlmon.hxx>
#include "clockbyt.hxx"
#include "memlb.hxx"

MemLockBytes::MemLockBytes() : _CRefs()
{
    memhandle = NULL;
}

STDMETHODIMP_(ULONG) MemLockBytes::Release(void)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN MemLockBytes::Release\n", this));
    UrlMkAssert((_CRefs > 0));

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        if (memhandle)
            GlobalFree(memhandle);

        delete this;
    }

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT MemLockBytes::Release\n", this));
    return lRet;
}

HRESULT MemLockBytes::ReadAt(THIS_ ULARGE_INTEGER ulOffset, VOID HUGEP *pv,
    ULONG cb, ULONG FAR *pcbRead)
{
    HRESULT hresult = E_FAIL;
    LPVOID  memptr;
    DWORD   memsize;
    ULONG   count;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN MemLockBytes::ReadAt\n", this));

    *pcbRead = 0;

    if (!cb)
        goto ReadAtExit;

    if (!memhandle)
        goto ReadAtExit;

    memsize = GlobalSize(memhandle);

    count = cb;
    if (ulOffset.QuadPart + cb > memsize)
    {
        if (ulOffset.QuadPart > memsize)
        {
            goto ReadAtExit;
        }
        else
        {
            count = memsize - (DWORD)ulOffset.QuadPart;
        }
    }

    memptr = GlobalLock(memhandle);
    if (!memptr)
        goto ReadAtExit;

    *(DWORD *)&memptr += (DWORD)ulOffset.QuadPart;
    memcpy(pv, memptr, count);
    *pcbRead = count;
    GlobalUnlock(memhandle);

    hresult = NOERROR;

ReadAtExit:

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT MemLockBytes::ReadAt\n", this));
    return(hresult);
}

HRESULT MemLockBytes::WriteAt(THIS_ ULARGE_INTEGER ulOffset, VOID const HUGEP *pv,
    ULONG cb, ULONG FAR *pcbWritten)
{
    HRESULT hresult = E_FAIL;
    LPVOID  memptr;
    DWORD   memsize;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN MemLockBytes::WriteAt\n", this));

    *pcbWritten = 0;

    if (!cb)
        goto WriteAtExit;

    if (!memhandle)
    {
        memhandle = GlobalAlloc(GMEM_MOVEABLE | GMEM_DISCARDABLE,
                        cb + (DWORD)ulOffset.QuadPart);
    }

    if (!memhandle)
        goto WriteAtExit;

    while (1)
    {
        memsize = GlobalSize(memhandle);

        if (ulOffset.QuadPart + cb > memsize)
        {
            memhandle = GlobalReAlloc(memhandle, cb + (DWORD)ulOffset.QuadPart,
                            GMEM_MOVEABLE);
        }
        else
            break;
    }

    memptr = GlobalLock(memhandle);
    if (!memptr)
        goto WriteAtExit;

    *(DWORD *)&memptr += (DWORD)ulOffset.QuadPart;
    memcpy(memptr, pv, cb);
    GlobalUnlock(memhandle);
    *pcbWritten = cb;

    hresult = NOERROR;

WriteAtExit:

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT MemLockBytes::WriteAt\n", this));
    return(hresult);
}

HRESULT MemLockBytes::SetSize(THIS_ ULARGE_INTEGER cb)
{
    HRESULT hresult = NOERROR;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN MemLockBytes::SetSize\n", this));

    if (!memhandle)
    {
        memhandle = GlobalAlloc(GMEM_MOVEABLE | GMEM_DISCARDABLE,
                        (DWORD)cb.QuadPart);
    }
    else
    {
        memhandle = GlobalReAlloc(memhandle, (DWORD)cb.QuadPart, GMEM_MOVEABLE);
    }

    if (!memhandle)
        hresult = E_FAIL;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT MemLockBytes::SetSize\n", this));
    return(hresult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\stg\filelb.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       FILELB.CXX
//
//  Contents:
//
//  Classes:    Implements the file-based ILockBytes class.
//
//  Functions:
//
//  History:    12-13-95    JoeS (Joe Souza)    Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include <urlmon.hxx>
#include "clockbyt.hxx"
#include "filelb.hxx"

FileLockBytes::FileLockBytes(HANDLE filehandle) : _CRefs()
{
    _hFileHandle = filehandle;
}

STDMETHODIMP_(ULONG) FileLockBytes::Release(void)
{
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN FileLockBytes::Release\n", this));
    UrlMkAssert((_CRefs > 0));

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        if (_hFileHandle != INVALID_HANDLE_VALUE)
            CloseHandle(_hFileHandle);

        delete this;
    }

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT FileLockBytes::Release\n", this));
    return lRet;
}

HRESULT FileLockBytes::ReadAt(THIS_ ULARGE_INTEGER ulOffset, VOID HUGEP *pv,
    ULONG cb, ULONG FAR *pcbRead)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN FileLockBytes::ReadAt\n", this));

    *pcbRead = 0;

    if (!cb)
        goto ReadAtExit;

    if (_hFileHandle == INVALID_HANDLE_VALUE)
        goto ReadAtExit;

    hresult = seekfile(ulOffset);
    if (hresult != NOERROR)
        goto ReadAtExit;

    if (!ReadFile(_hFileHandle, pv, cb, pcbRead, NULL))
    {
        if (GetLastError() == ERROR_LOCK_VIOLATION)
            hresult = STG_E_ACCESSDENIED;
        else
            hresult = E_FAIL;
    }

ReadAtExit:

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT FileLockBytes::ReadAt\n", this));
    return(hresult);
}

HRESULT FileLockBytes::WriteAt(THIS_ ULARGE_INTEGER ulOffset, VOID const HUGEP *pv,
    ULONG cb, ULONG FAR *pcbWritten)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN FileLockBytes::WriteAt\n", this));

    *pcbWritten = 0;

    if (!cb)
        goto WriteAtExit;

    if (_hFileHandle == INVALID_HANDLE_VALUE)
        goto WriteAtExit;

    hresult = seekfile(ulOffset);
    if (hresult != NOERROR)
        goto WriteAtExit;

    if (!WriteFile(_hFileHandle, pv, cb, pcbWritten, NULL))
    {
        if (GetLastError() == ERROR_LOCK_VIOLATION)
            hresult = STG_E_ACCESSDENIED;
        else
            hresult = E_FAIL;
    }

WriteAtExit:

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT FileLockBytes::WriteAt\n", this));
    return(hresult);
}

HRESULT FileLockBytes::Flush()
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN FileLockBytes::Flush\n", this));

    if (_hFileHandle != INVALID_HANDLE_VALUE)
    {
        if (FlushFileBuffers(_hFileHandle))
            hresult = NOERROR;
    }

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT FileLockBytes::Flush\n", this));
    return(hresult);
}

HRESULT FileLockBytes::SetSize(THIS_ ULARGE_INTEGER cb)
{
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN FileLockBytes::SetSize\n", this));

    if (_hFileHandle == INVALID_HANDLE_VALUE)
        goto SetSizeExit;

    hresult = seekfile(cb);
    if (hresult != NOERROR)
        goto SetSizeExit;

    if (SetEndOfFile(_hFileHandle))
        hresult = NOERROR;

SetSizeExit:

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT FileLockBytes::SetSize\n", this));
    return(hresult);
}

HRESULT FileLockBytes::LockRegion(THIS_ ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb, DWORD dwLockType)
{
    HRESULT hresult = NOERROR;
    DWORD   offslow, offshigh, lenlow, lenhigh;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN FileLockBytes::LockRegion\n", this));

    if (_hFileHandle == INVALID_HANDLE_VALUE)
    {
        hresult = E_FAIL;
        goto LockRegionExit;
    }

    offshigh = *(DWORD *)(&libOffset.QuadPart + sizeof(ULONG));
    offslow = *(DWORD *)(&libOffset.QuadPart);

    lenhigh = *(DWORD *)(&cb.QuadPart + sizeof(ULONG));
    lenlow = *(DWORD *)(&cb.QuadPart);

    if (!LockFile(_hFileHandle, offslow, offshigh, lenlow, lenhigh))
    {
        if (GetLastError() == ERROR_LOCK_FAILED)
            hresult = STG_E_LOCKVIOLATION;
        else
            hresult = E_FAIL;
    }

LockRegionExit:

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT FileLockBytes::LockRegion\n", this));
    return(hresult);
}

HRESULT FileLockBytes::UnlockRegion(THIS_ ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb, DWORD dwLockType)
{
    HRESULT hresult = NOERROR;
    DWORD   offslow, offshigh, lenlow, lenhigh;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN FileLockBytes::UnlockRegion\n", this));

    if (_hFileHandle == INVALID_HANDLE_VALUE)
    {
        hresult = E_FAIL;
        goto UnlockRegionExit;
    }

    offshigh = *(DWORD *)(&libOffset.QuadPart + sizeof(ULONG));
    offslow = *(DWORD *)(&libOffset.QuadPart);

    lenhigh = *(DWORD *)(&cb.QuadPart + sizeof(ULONG));
    lenlow = *(DWORD *)(&cb.QuadPart);

    if (!UnlockFile(_hFileHandle, offslow, offshigh, lenlow, lenhigh))
    {
        if (GetLastError() == ERROR_LOCK_FAILED)
            hresult = STG_E_LOCKVIOLATION;
        else
            hresult = E_FAIL;
    }

UnlockRegionExit:

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT FileLockBytes::UnlockRegion\n", this));
    return(hresult);
}

HRESULT FileLockBytes::Stat(THIS_ STATSTG FAR *pStatStg, DWORD grfStatFlag)
{
    HRESULT hresult = E_FAIL;
    DWORD   sizelow, sizehigh;

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p IN FileLockBytes::Stat\n", this));

    if (!pStatStg)
        goto StatExit;

    if (_hFileHandle == INVALID_HANDLE_VALUE)
        goto StatExit;

    memset(pStatStg, 0, sizeof(STATSTG));

    pStatStg->pwcsName = NULL;
    pStatStg->type = STGTY_LOCKBYTES;

    sizelow = GetFileSize(_hFileHandle, &sizehigh);
    if (sizelow == -1 && GetLastError() != NOERROR)
        goto StatExit;

    *(DWORD *)(&pStatStg->cbSize.QuadPart + sizeof(ULONG)) = sizehigh;
    *(DWORD *)(&pStatStg->cbSize.QuadPart) = sizelow;

    if (GetFileTime(_hFileHandle, &pStatStg->ctime, &pStatStg->atime, &pStatStg->mtime))
    {
        pStatStg->grfMode = GENERIC_READ | GENERIC_WRITE;
        pStatStg->grfLocksSupported = LOCK_WRITE | LOCK_EXCLUSIVE | LOCK_ONLYONCE;
        pStatStg->clsid = IID_ILockBytes;
        pStatStg->grfStateBits = 0;

        hresult = NOERROR;
    }

StatExit:

    UrlMkDebugOut((DEB_ILOCKBYTES, "%p OUT FileLockBytes::Stat\n", this));
    return(hresult);
}

HRESULT FileLockBytes::seekfile(ULARGE_INTEGER offset)
{
    HRESULT hresult = NOERROR;
    DWORD   offslow, offshigh;

    offshigh = *(DWORD *)(&offset.QuadPart + sizeof(ULONG));
    offslow = *(DWORD *)(&offset.QuadPart);

    offslow = SetFilePointer(_hFileHandle, offslow, (LONG *)&offshigh, FILE_BEGIN);
    if (offslow == -1 && GetLastError() != NO_ERROR)
        hresult = E_FAIL;

    return(hresult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\stg\rostmdir.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ROSTMDIR.CXX
//
//  Contents:
//
//  Classes:    Implements the CReadOnlyStreamDirect class.
//
//  Functions:
//
//  History:    12-21-95    JoeS (Joe Souza)    Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#ifndef unix
#include "..\trans\transact.hxx"
#else
#include "../trans/transact.hxx"
#endif /* unix */
#include "rostmdir.hxx"

CReadOnlyStreamDirect::CReadOnlyStreamDirect(CTransData *pCTransData, DWORD grfBindF, BOOL fFile) : _CRefs()
{
    DEBUG_ENTER((DBG_STORAGE,
                None,
                "CReadOnlyStreamDirect::CReadOnlyStreamDirect",
                "this=%#x, %#x, %#x",
                this, pCTransData, grfBindF
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p IN  CReadOnlyStreamDirect::CReadOnlyStreamDirect (pCTransData:%p)\n", NULL,pCTransData));

    _pCTransData = pCTransData;
    _grfBindF = grfBindF;
    _fFile = fFile;

    if (_pCTransData)
    {
        _pCTransData->AddRef();
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamDirect::CReadOnlyStreamDirect \n", this));

    DEBUG_LEAVE(0);
}

CReadOnlyStreamDirect::~CReadOnlyStreamDirect()
{
    DEBUG_ENTER((DBG_STORAGE,
                None,
                "CReadOnlyStreamDirect::~CReadOnlyStreamDirect",
                "this=%#x",
                this
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p IN/OUT  CReadOnlyStreamDirect::~CReadOnlyStreamDirect\n", this));
    if (_pCTransData)
    {
        _pCTransData->Release();
    }

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CReadOnlyStreamDirect::GetFileName
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    7-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPWSTR CReadOnlyStreamDirect::GetFileName()
{
    DEBUG_ENTER((DBG_STORAGE,
                String,
                "CReadOnlyStreamDirect::GetFileName",
                "this=%#x",
                this
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamDirect::GetFileName\n", this));

    LPWSTR pwzFilename = NULL;
    LPWSTR pwzDupname = NULL;

    if (_pCTransData)
    {
        pwzFilename = _pCTransData->GetFileName();
    }

    if (pwzFilename)
    {
        pwzDupname = OLESTRDuplicate(pwzFilename);
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamDirect::GetFileName (Filename:%ws)\n", this, pwzDupname));

    DEBUG_LEAVE(pwzDupname);
    return pwzDupname;
}



STDMETHODIMP CReadOnlyStreamDirect::QueryInterface
    (REFIID riid, LPVOID FAR* ppvObj)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamDirect::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppvObj
                ));
                
    VDATETHIS(this);
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamDirect::QueryInterface\n", this));

    HRESULT hresult = NOERROR;

    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IStream)
       )
    {
        *ppvObj = this;
        AddRef();
    }
    else if (_fFile
               && IsEqualIID(riid, IID_IWinInetFileStream))
    {
        *ppvObj = (void *)(IWinInetFileStream *)this;
        AddRef();
    }
    else
    {
        *ppvObj = NULL;
        hresult = E_NOINTERFACE;
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamDirect::QueryInterface\n", this));

    DEBUG_LEAVE(hresult);
    return hresult;
}

STDMETHODIMP_(ULONG) CReadOnlyStreamDirect::AddRef(void)
{
    DEBUG_ENTER((DBG_STORAGE,
                Dword,
                "CReadOnlyStreamDirect::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    GEN_VDATEPTRIN(this,ULONG,0L);
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamDirect::AddRef\n", this));

    LONG lRet = ++_CRefs;

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamDirect::::AddRef (%ld)\n", this, lRet));

    DEBUG_LEAVE(lRet);
    return lRet;
}

STDMETHODIMP_(ULONG) CReadOnlyStreamDirect::Release(void)
{
    DEBUG_ENTER((DBG_STORAGE,
                Dword,
                "CReadOnlyStreamDirect::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    GEN_VDATEPTRIN(this,ULONG,0L);
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamDirect::Release\n", this));
    UrlMkAssert((_CRefs > 0));

    LONG lRet = --_CRefs;
    if (_CRefs == 0)
    {
        delete this;
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamDirect::Release (%ld)\n", this, lRet));

    DEBUG_LEAVE(lRet);
    return lRet;
}

HRESULT CReadOnlyStreamDirect::Read(THIS_ VOID HUGEP *pv, ULONG cb, ULONG FAR *pcbRead)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamDirect::IStream::Read",
                "this=%#x, %#x, %#x, %#x",
                this, pv, cb, pcbRead
                ));
                
    HRESULT hresult = NOERROR;
    DWORD dwRead = 0;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamDirect::Read\n", this));

    if( _pCTransData )
    {
        hresult = _pCTransData->ReadHere((LPBYTE) pv, cb, &dwRead);
        if( hresult != S_OK && hresult != E_PENDING )
        {
            // break connection with CTransData
            CTransData *pCTD = _pCTransData;
            _pCTransData = 0;
            pCTD->Release();
        }
    }
    else
    {
        hresult = S_FALSE;
        dwRead = 0;
    }

    if (pcbRead)
    {
        *pcbRead = dwRead;
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamDirect::Read\n", this));

    DEBUG_LEAVE(hresult);
    return(hresult);
}

HRESULT CReadOnlyStreamDirect::Write(THIS_ VOID const HUGEP *pv, ULONG cb,
            ULONG FAR *pcbWritten)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamDirect::IStream::Write",
                "this=%#x, %#x, %#x, %#x",
                this, pv, cb, pcbWritten
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p CReadOnlyStreamDirect::Write (NoOp)\n", this));

    DEBUG_LEAVE(STG_E_ACCESSDENIED);
    return(STG_E_ACCESSDENIED);
}

HRESULT CReadOnlyStreamDirect::Seek(THIS_ LARGE_INTEGER dlibMove, DWORD dwOrigin,
            ULARGE_INTEGER FAR *plibNewPosition)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamDirect::IStream::Seek",
                "this=%#x, %#x, %#x, %#x",
                this, dlibMove, dwOrigin, plibNewPosition
                ));
                
    HRESULT hresult = NOERROR;
    UrlMkDebugOut((DEB_ISTREAM, "%p CReadOnlyStreamDirect::Seek (NoOp)\n", this));
    
    // This is a true stream, and thus seeking is not possible.
    if( _pCTransData )
    {
        hresult = _pCTransData->Seek(dlibMove, dwOrigin, plibNewPosition);
    }
    else
    {
        hresult = S_FALSE;
    }

    DEBUG_LEAVE(hresult);
    return hresult;
}

HRESULT CReadOnlyStreamDirect::SetSize(THIS_ ULARGE_INTEGER libNewSize)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamDirect::IStream::SetSize",
                "this=%#x, %#x",
                this, libNewSize
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p CReadOnlyStreamDirect::SetSize (NoOp)\n", this));

    // BUGBUG: Should we just return S_OK here?

    DEBUG_LEAVE(E_FAIL);
    return(E_FAIL);
}

HRESULT CReadOnlyStreamDirect::CopyTo(THIS_ LPSTREAM pStm, ULARGE_INTEGER cb,
            ULARGE_INTEGER FAR *pcbRead, ULARGE_INTEGER FAR *pcbWritten)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamDirect::IStream::CopyTo",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, pStm, cb, pcbRead, pcbWritten
                ));
                
    HRESULT hresult = STG_E_INSUFFICIENTMEMORY;
    LPVOID  memptr = NULL;
    DWORD   readcount, writecount;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamDirect::CopyTo\n", this));

    if (cb.HighPart || (pStm == NULL))
    {
        hresult = E_INVALIDARG;
        goto CopyToExit;
    }

    // do not need to copy to ourself
    if (pStm == this)
    {
        hresult = NOERROR;
        goto CopyToExit;
    }

    memptr = new BYTE [cb.LowPart];

    if (memptr)
    {
        hresult = Read((LPBYTE) memptr, cb.LowPart, &readcount);
        if (hresult)
        {
            goto CopyToExit;
        }

        if (pcbRead)
        {
            pcbRead->HighPart = 0;
            pcbRead->LowPart = readcount;
        }

        hresult = pStm->Write(memptr, readcount, &writecount);

        if (pcbWritten && !hresult)
        {
            pcbWritten->HighPart = 0;
            pcbWritten->LowPart = writecount;
        }
    }

CopyToExit:

    if (memptr)
    {
        delete memptr;
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamDirect::CopyTo\n", this));

    DEBUG_LEAVE(hresult);
    return(hresult);
}

HRESULT CReadOnlyStreamDirect::Commit(THIS_ DWORD dwCommitFlags)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamDirect::IStream::Commit",
                "this=%#x, %#x",
                this, dwCommitFlags
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p CReadOnlyStreamDirect::Commit (NoOp)\n", this));

    // This is a read-only stream, so nothing to commit.

    DEBUG_LEAVE(E_NOTIMPL);
    return(E_NOTIMPL);
}

HRESULT CReadOnlyStreamDirect::Revert(THIS)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamDirect::IStream::Revert",
                "this=%#x",
                this
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p CReadOnlyStreamDirect::Revert (NoOp)\n", this));

    DEBUG_LEAVE(E_NOTIMPL);
    return(E_NOTIMPL);
}

HRESULT CReadOnlyStreamDirect::LockRegion(THIS_ ULARGE_INTEGER libOffset,
            ULARGE_INTEGER cb, DWORD dwLockType)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamDirect::IStream::LockRegion",
                "this=%#x, %#x, %#x, %#x",
                this, libOffset, cb, dwLockType
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p CReadOnlyStreamDirect::LockRegion (NoOp)\n", this));

    DEBUG_LEAVE(E_NOTIMPL);
    return(E_NOTIMPL);
}

HRESULT CReadOnlyStreamDirect::UnlockRegion(THIS_ ULARGE_INTEGER libOffset,
            ULARGE_INTEGER cb, DWORD dwLockType)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamDirect::IStream::UnlockRegion",
                "this=%#x, %#x, %#x, %#x",
                this, libOffset, cb, dwLockType
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p CReadOnlyStreamDirect::UnlockRegion (NoOp)\n", this));

    DEBUG_LEAVE(E_NOTIMPL);
    return(E_NOTIMPL);
}

HRESULT CReadOnlyStreamDirect::Stat(THIS_ STATSTG FAR *pStatStg, DWORD grfStatFlag)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamDirect::IStream::Stat",
                "this=%#x, %#x, %#x",
                this, pStatStg, grfStatFlag
                ));
                
    HRESULT hresult = E_FAIL;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamDirect::Stat\n", this));

    if (pStatStg)
    {
        memset(pStatStg, 0, sizeof(STATSTG));

        pStatStg->type = STGTY_STREAM;
        pStatStg->clsid = IID_IStream;
        pStatStg->pwcsName = GetFileName();

        hresult = NOERROR;
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamDirect::Stat\n", this));

    DEBUG_LEAVE(hresult);
    return(hresult);
}

HRESULT CReadOnlyStreamDirect::Clone(THIS_ LPSTREAM FAR *ppStm)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamDirect::IStream::Clone",
                "this=%#x, %#x",
                this, ppStm
                ));
                
    HRESULT hresult = NOERROR;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamDirect::Clone\n", this));

    if (!(*ppStm = new CReadOnlyStreamDirect(_pCTransData, _grfBindF)))
        hresult = E_OUTOFMEMORY;

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamDirect::Clone\n", this));

    DEBUG_LEAVE(hresult);
    return(hresult);
}

HRESULT CReadOnlyStreamDirect::SetHandleForUnlock(THIS_ DWORD_PTR hWinInetLockHandle, DWORD_PTR dwReserved)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamDirect::IWinInetFileStream::SetHandleForUnlock",
                "this=%#x, handle=%#x",
                this, hWinInetLockHandle
                ));

    DEBUG_LEAVE(E_NOTIMPL);
    return E_NOTIMPL;
}

HRESULT CReadOnlyStreamDirect::SetDeleteFile(THIS_ DWORD_PTR dwReserved)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamDirect::IWinInetFileStream::SetDeleteFile",
                "this=%#x",
                this
                ));

    DEBUG_LEAVE(E_NOTIMPL);
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\stg\rostmfil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       ROSTMFIL.CXX
//
//  Contents:
//
//  Classes:    Implements the CReadOnlyStreamFile class.
//
//  Functions:
//
//  History:    03-02-96    JoeS (Joe Souza)    Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#ifndef unix
#include "..\trans\transact.hxx"
#else
#include "../trans/transact.hxx"
#endif /* unix */
#include "rostmdir.hxx"
#include "rostmfil.hxx"

//+---------------------------------------------------------------------------
//
//  Method:     CReadOnlyStreamFile::GetFileName
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    7-22-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPWSTR CReadOnlyStreamFile::GetFileName()
{
    DEBUG_ENTER((DBG_STORAGE,
                String,
                "CReadOnlyStreamFile::GetFileName",
                "this=%#x",
                this
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamFile::GetFileName\n", this));
    LPWSTR pwzDupname = NULL;

    if (_pszFileName)
    {
        pwzDupname = DupA2W(_pszFileName);
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamFile::GetFileName (Filename:%ws)\n", this, pwzDupname));

    DEBUG_LEAVE(pwzDupname);
    return pwzDupname;
}


HRESULT CReadOnlyStreamFile::Create(LPSTR pszFileName, CReadOnlyStreamFile **ppCRoStm, LPCWSTR pwzURL)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamFile::Create",
                "%.80q, %#x, %.80wq",
                pszFileName, ppCRoStm, pwzURL
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamFile::Create (pszFileName:%s)\n", NULL,pszFileName));
    HRESULT hr = NOERROR;

    *ppCRoStm = NULL;

    if (pszFileName == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        LPSTR  pszStr = new CHAR [strlen(pszFileName) + 1];

        if (pszStr == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {

            HANDLE handle = CreateFileA(pszFileName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

            if (handle == INVALID_HANDLE_VALUE)
            {
                delete pszStr;
                hr = E_FAIL;
            }
            else
            {
                LPWSTR pwzStr = NULL;
                if (pwzURL)
                {
                    pwzStr = OLESTRDuplicate(pwzURL);
                }
                    
                strcpy(pszStr, pszFileName);
                CReadOnlyStreamFile *pCRoStm = new CReadOnlyStreamFile(pszStr, handle, pwzStr);

                if (pCRoStm == NULL)
                {
                    delete pszStr;
                }
                else
                {
                    *ppCRoStm = pCRoStm;
                }
            }
        }
    }
    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamFile::Create (hr:%lx)\n", *ppCRoStm, hr));

    DEBUG_LEAVE(hr);
    return hr;
}

CReadOnlyStreamFile::CReadOnlyStreamFile(LPSTR pszFileName, HANDLE handle, LPWSTR pwzURL)
                        : CReadOnlyStreamDirect(NULL, 0, TRUE)
{
    DEBUG_ENTER((DBG_STORAGE,
                None,
                "CReadOnlyStreamFile::CReadOnlyStreamFile",
                "this=%#x, %.80q, %#x, %.80wq",
                this, pszFileName, handle, pwzURL
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamFile::CReadOnlyStreamFile (pszFileName:%s)\n", NULL,pszFileName));

    _hFileHandle = handle;
    _pszFileName = pszFileName;
    _fDataFullyAvailable = FALSE;
    _hWinInetLockHandle = NULL;
    _pwzURL = pwzURL;
    _fDeleteFile = FALSE;

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamFile::CReadOnlyStreamFile \n", this));

    DEBUG_LEAVE(0);
}

CReadOnlyStreamFile::~CReadOnlyStreamFile(void)
{
    DEBUG_ENTER((DBG_STORAGE,
                None,
                "CReadOnlyStreamFile::~CReadOnlyStreamFile",
                "this=%#x",
                this
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamFile::~CReadOnlyStreamFile (_pszFileName:%s)\n", this,_pszFileName));

    if (_hFileHandle != INVALID_HANDLE_VALUE)
    {
        CloseHandle(_hFileHandle);
    }

    if (_pwzURL)
    {
        if (_fDeleteFile)
        {
            DeleteUrlCacheEntryW(_pwzURL);
        }

        delete [] _pwzURL;
    }

    if (_hWinInetLockHandle)
    {
        InternetUnlockRequestFile(_hWinInetLockHandle);
        _hWinInetLockHandle = NULL;
    }

    if (_pszFileName)
    {
        delete _pszFileName;
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamFile::~CReadOnlyStreamFile\n", this));

    DEBUG_LEAVE(0);
}

HRESULT CReadOnlyStreamFile::Read(THIS_ VOID HUGEP *pv, ULONG cb, ULONG FAR *pcbRead)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamFile::IStream::Read",
                "this=%#x, %#x, %x, %#x",
                this, pv, cb, pcbRead
                ));
                
    HRESULT hresult = NOERROR;
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamFile::Read (cbBuffer:%lx)\n", this,cb));

    DWORD dwRead = 0;

    if (!ReadFile(_hFileHandle, pv, cb, &dwRead, NULL))
    {
        if (GetLastError() == ERROR_LOCK_VIOLATION)
        {
            hresult = STG_E_ACCESSDENIED;
        }
        else
        {
            hresult = E_FAIL;
        }

        if (pcbRead)
        {
            *pcbRead = 0;
        }
    }
    else
    {
        if (pcbRead)
        {
            *pcbRead = dwRead;
        }

        if (dwRead == 0)
        {
            hresult = (_fDataFullyAvailable) ? S_FALSE : E_PENDING;
        }
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamFile::Read (hr:%lx, cdRead:%lx)\n", this, hresult, dwRead));

    DEBUG_LEAVE(hresult);
    return(hresult);
}

HRESULT CReadOnlyStreamFile::Seek(THIS_ LARGE_INTEGER dlibMove, DWORD dwOrigin,
            ULARGE_INTEGER FAR *plibNewPosition)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamFile::IStream::Seek",
                "this=%#x, %#x, %x, %#x",
                this, dlibMove, dwOrigin, plibNewPosition
                ));
                
    HRESULT hresult = NOERROR;
    DWORD   offslow, offshigh;
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamFile::Seek\n", this));

    offshigh = dlibMove.HighPart;
    offslow = dlibMove.LowPart;

    offslow = SetFilePointer(_hFileHandle, offslow, (LONG *)&offshigh, dwOrigin);
    if (offslow == -1 && GetLastError() != NO_ERROR)
    {
        hresult = E_FAIL;
    }
    else if (plibNewPosition)
    {
        plibNewPosition->HighPart = offshigh;
        plibNewPosition->LowPart = offslow;
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamFile::Seek\n", this));

    DEBUG_LEAVE(hresult);
    return(hresult);
}

HRESULT CReadOnlyStreamFile::CopyTo(THIS_ LPSTREAM pStm, ULARGE_INTEGER cb,
            ULARGE_INTEGER FAR *pcbRead, ULARGE_INTEGER FAR *pcbWritten)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamFile::IStream::CopyTo",
                "this=%#x, %#x, %x, %#x, %#x",
                this, pStm, cb, pcbRead, pcbWritten
                ));
                
    HRESULT hresult = STG_E_INSUFFICIENTMEMORY;
    LPVOID  memptr = NULL;
    DWORD   readcount, writecount;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamFile::CopyTo\n", this));

    if (cb.HighPart || (pStm == NULL))
    {
        hresult = E_INVALIDARG;
        goto CopyToExit;
    }

    // do not need to copy to ourself
    if (pStm == this)
    {
        hresult = NOERROR;
        goto CopyToExit;
    }

    memptr = new BYTE [cb.LowPart];

    if (memptr)
    {
        if (!ReadFile(_hFileHandle, memptr, cb.LowPart, &readcount, NULL))
        {
            if (GetLastError() == ERROR_LOCK_VIOLATION)
            {
                hresult = STG_E_ACCESSDENIED;
            }
            else
            {
                hresult = E_FAIL;
            }

            goto CopyToExit;
        }

        if (pcbRead)
        {
            pcbRead->HighPart = 0;
            pcbRead->LowPart = readcount;
        }

        hresult = pStm->Write(memptr, readcount, &writecount);

        if (pcbWritten && !hresult)
        {
            pcbWritten->HighPart = 0;
            pcbWritten->LowPart = writecount;
        }
    }

CopyToExit:

    if (memptr)
    {
        delete memptr;
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamFile::CopyTo\n", this));

    DEBUG_LEAVE(hresult);
    return(hresult);
}

HRESULT CReadOnlyStreamFile::LockRegion(THIS_ ULARGE_INTEGER libOffset,
            ULARGE_INTEGER cb, DWORD dwLockType)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamFile::IStream::LockRegion",
                "this=%#x, %#x, %x, %x",
                this, libOffset, cb, dwLockType
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p CReadOnlyStreamFile::LockRegion (NoOp)\n", this));

    DEBUG_LEAVE(E_NOTIMPL);
    return(E_NOTIMPL);
}

HRESULT CReadOnlyStreamFile::UnlockRegion(THIS_ ULARGE_INTEGER libOffset,
            ULARGE_INTEGER cb, DWORD dwLockType)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamFile::IStream::UnlockRegion",
                "this=%#x, %#x, %x, %x",
                this, libOffset, cb, dwLockType
                ));
                
    UrlMkDebugOut((DEB_ISTREAM, "%p CReadOnlyStreamFile::UnlockRegion (NoOp)\n", this));

    DEBUG_LEAVE(E_NOTIMPL);
    return(E_NOTIMPL);
}

HRESULT CReadOnlyStreamFile::Stat(THIS_ STATSTG FAR *pStatStg, DWORD grfStatFlag)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamFile::IStream::Stat",
                "this=%#x, %#x, %x",
                this, pStatStg, grfStatFlag
                ));
                
    HRESULT hresult = E_FAIL;
    DWORD   sizelow, sizehigh;
    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamFile::Stat\n", this));

    if (pStatStg)
    {
        memset(pStatStg, 0, sizeof(STATSTG));

        pStatStg->type = STGTY_STREAM;
        pStatStg->clsid = IID_IStream;

        sizelow = GetFileSize(_hFileHandle, &sizehigh);
        if (sizelow == -1 && GetLastError() != NOERROR)
        {
            goto StatExit;
        }

        pStatStg->cbSize.HighPart = sizehigh;
        pStatStg->cbSize.LowPart = sizelow;
        pStatStg->pwcsName = GetFileName();

        if (GetFileTime(_hFileHandle, &pStatStg->ctime, &pStatStg->atime, &pStatStg->mtime))
        {
            pStatStg->grfMode = GENERIC_READ;
            pStatStg->grfLocksSupported = 0;
            pStatStg->clsid = IID_IStream;
            pStatStg->grfStateBits = 0;

            hresult = NOERROR;
        }
    }

StatExit:

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamFile::Stat\n", this));

    DEBUG_LEAVE(hresult);
    return(hresult);
}

HRESULT CReadOnlyStreamFile::Clone(THIS_ LPSTREAM FAR *ppStm)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamFile::IStream::Clone",
                "this=%#x, %#x",
                this, ppStm
                ));
                
    HRESULT hr = NOERROR;
    CReadOnlyStreamFile *pCRoStm;

    UrlMkDebugOut((DEB_ISTREAM, "%p IN CReadOnlyStreamFile::Clone\n", this));

    hr = Create(_pszFileName, &pCRoStm, _pwzURL);

    if (hr == NOERROR)
    {
        *ppStm = pCRoStm;
    }
    else
    {
        *ppStm = NULL;
    }

    UrlMkDebugOut((DEB_ISTREAM, "%p OUT CReadOnlyStreamFile::Clone (hr:%lx)\n", this, hr));

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT CReadOnlyStreamFile::SetHandleForUnlock(THIS_ DWORD_PTR hWinInetLockHandle, DWORD_PTR dwReserved)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamFile::IWinInetFileStream::SetHandleForUnlock",
                "this=%#x, handle=%#x",
                this, hWinInetLockHandle
                ));

    HRESULT hr = E_FAIL;

    if (hWinInetLockHandle)
    {
        _hWinInetLockHandle = (HANDLE)hWinInetLockHandle;
        hr = S_OK;
    }

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT CReadOnlyStreamFile::SetDeleteFile(THIS_ DWORD_PTR dwReserved)
{
    DEBUG_ENTER((DBG_STORAGE,
                Hresult,
                "CReadOnlyStreamFile::IWinInetFileStream::SetDeleteFile",
                "this=%#x, URL=%.80wq",
                this, _pwzURL
                ));

    _fDeleteFile = TRUE;

    DEBUG_LEAVE(S_OK);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\stg\stgapi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       STGAPI.CXX
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-15-95    JoeS (Joe Souza)    Created
//
//----------------------------------------------------------------------------
#include <urlint.h>
#include <urlmon.hxx>
#include "clockbyt.hxx"
#include "casynclb.hxx"
#include "filelb.hxx"
#include "memlb.hxx"
#include "stgapi.hxx"


HRESULT StgGetFillLockByteOnMem(IFillLockBytes **pFLB)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "StgGetFillLockByteOnMem",
                    "%#x",
                    pFLB
                    ));

    HRESULT     hresult = NOERROR;
    ILockBytes  *pLB;

    *pFLB = NULL;

    if (!(pLB = new MemLockBytes))
    {
        DEBUG_LEAVE_API(E_OUTOFMEMORY);
        return(E_OUTOFMEMORY);
    }
    
    hresult = StgGetFillLockByteILockBytes(pLB, pFLB);
    if (hresult != NOERROR)
        delete pLB;

    DEBUG_LEAVE_API(hresult);
    return(hresult);
}

HRESULT StgGetFillLockByteOnFile(OLECHAR *pwcFileName, IFillLockBytes **pFLB)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "StgGetFillLockByteOnFile",
                    "%#x, %#x",
                    pwcFileName, pFLB
                    ));
                    
    HRESULT     hresult = NOERROR;
    ILockBytes  *pLB;
    HANDLE      fhandle;

    *pFLB = NULL;

    fhandle = CreateFileW(pwcFileName, GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL, NULL);

    if (fhandle == INVALID_HANDLE_VALUE)
    {
        DEBUG_LEAVE_API(E_FAIL);
        return(E_FAIL);
    }
    
    if (!(pLB = new FileLockBytes(fhandle)))
    {
        CloseHandle(fhandle);

        DEBUG_LEAVE_API(E_OUTOFMEMORY);
        return(E_OUTOFMEMORY);
    }

    hresult = StgGetFillLockByteILockBytes(pLB, pFLB);
    if (hresult != NOERROR)
        delete pLB;

    DEBUG_LEAVE_API(hresult);
    return(hresult);
}

HRESULT StgGetFillLockByteILockBytes(ILockBytes *pLB, IFillLockBytes **pFLB)
{
    DEBUG_ENTER_API((DBG_API,
                    Hresult,
                    "StgGetFillLockByteILockBytes",
                    "%#x, %#x",
                    pLB, pFLB
                    ));
                    
    IFillLockBytes  *flb;

    *pFLB = NULL;

    if (!(flb = new CAsyncLockBytes(pLB)))
    {
        DEBUG_LEAVE_API(E_OUTOFMEMORY);
        return(E_OUTOFMEMORY);
    }
    
    *pFLB = flb;

    DEBUG_LEAVE_API(NOERROR);
    return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\trans\callback.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       callback.cxx
//
//  Contents:   Callback mechanism and thread switching code
//
//  Classes:
//
//  Functions:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <trans.h>
#include "callback.hxx"

HRESULT CreateINetCallback(CBinding *pCBdg, DWORD *pdwContext, PFNCINETCALLBACK *pCB)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CreateINetCallback",
                "%#x, %#x, %#x, %#x",
                pCBdg, pdwContext, pCB
                ));

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

PFNCINETCALLBACK CreateCallback(DWORD dwId, LPVOID pv)
{
    DEBUG_ENTER((DBG_TRANS,
                Pointer,
                "CreateCallback",
                "%#x, %#x",
                dwId, pv
                ));

    DEBUG_LEAVE(NULL);
    return NULL;
}


#ifdef OLD_UNUSED
void Update(CInternetTransaction *pThis,DLD *pdld, char *pszStatusText)
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "Update",
                "%#x, %#x, %#x, %#x",
                pThis, pdld, pszStatusText
                ));
                
    Assert(pThis != NULL);
    Assert(!pThis->m_fComplete);

    if (pdld == NULL)
    {
        DEBUG_LEAVE(0);
        return;
    }
    
    AssertDo(pThis->HrPostNotifications(s_WM_UPDATECALLBACK, pdld,
        pszStatusText, INLERR_OK) == NOERROR);

    DEBUG_LEAVE(0);
}


void Inetdone(CInternetTransaction *pThis, BOOL fInStartTransaction, DLD *pdld, int errCode)
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "Inetdone",
                "%#x, %B, %#x, %d",
                pThis, fInStartTransaction, pdld, errCode
                ));
                
    Assert(pThis != NULL);
    Assert(!pThis->m_fComplete);
    if (!fInStartTransaction)
    {
        Assert(pThis->m_hInet != NULL);
        if (pThis->m_hInet == NULL)
        {
            DEBUG_LEAVE(0);
            return;
        }
    }

    pThis->m_fComplete = TRUE;
    pThis->m_hInet = NULL;

    AssertDo(pThis->HrPostNotifications(s_WM_INETDONECALLBACK, pdld, "",
        errCode) == NOERROR);

    // Release the reference we had added in HrStartDataRetrieval.
    // Note: after this call, the object may no longer exist
    pThis->Release();
    
    DEBUG_LEAVE(0);
}

/*---------------------------------------------------------------------------
    CInternetTransaction::HrPostNotification

    Post a notification message to all the client requests that are
    connected to this internet transaction.
----------------------------------------------------------------- DavidEbb -*/
HRESULT CInternetTransaction::HrPostNotifications(UINT uiMsg,
    DLD *pdld, char *pszStatusText, int errCode)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CInternetTransaction::HrPostNotifications",
                "this=%#x, %#x, %#x, %.80q, %d",
                this, uiMsg, pdld, pszStatusText, errCode
                ));
                
    CALLBACKDATA *pcbd;
    CClientRequest *pcrqTmp = m_pcrqFirst;

    Assert(pdld != NULL);
    Assert(m_pcrqFirst != NULL);

    {
        // Save the file name if we don't already have it.
        if (m_wzFileName[0] == '\0')
            A2W(pdld->szTargetFile, m_wzFileName, MAX_PATH);
    }

    // Traverse the whole linked list
    while (pcrqTmp != NULL)
    {
        // Note: we need to allocate a new CALLBACKDATA structure for each
        // client request in the list, because we are giving up
        // ownership of it when we call PostMessage().
        pcbd = CreateCallBackData(pdld, pszStatusText, errCode);
        if (pcbd == NULL)
        {
            DEBUG_LEAVE(E_OUTOFMEMORY);
            return E_OUTOFMEMORY;
        }
        
        Assert(pcrqTmp->HwndGetStatusWindow() != NULL);

        // Post a message to the hidden window in the main thread.
        PostMessage(pcrqTmp->HwndGetStatusWindow(), uiMsg,(WPARAM)pcrqTmp, (LPARAM)pcbd);

        pcrqTmp = pcrqTmp->GetNextRequest();
    }

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

#endif //OLD_UNUSED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\trans\cbinding.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cbinding.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <trans.h>
#include "oinet.hxx"
#include "cdl.h"    // defined in urlmon\download\

// from helpers.cxx
HRESULT IsMimeHandled(LPCWSTR pwszMimeType);

// From shlwapip.h
LWSTDAPI_(HRESULT) CLSIDFromStringWrap(LPOLESTR lpsz, LPCLSID pclsid);


PerfDbgTag(tagCBinding,     "Urlmon", "Log CBinding",        DEB_BINDING);
DbgTag(tagCBindingErr,  "Urlmon", "Log CBinding Errors", DEB_BINDING|DEB_ERROR);
extern DWORD g_dwSettings;

#define MAX_PROTOCOL_LEN    32  // protocl string length in ASCII BUGBUG is there a standard?
#define PROTOCOL_DELIMITER  ':'
#define REG_PROTOCOL_HANDLER    L"ProtocolHandler"

WCHAR *rglpProto[] =
{
    L"https",
    L"http",
    L"ftp",
    L"gopher",
    L"file",
    L"local",
    L"mk",
    NULL,
};

HRESULT GetTransactionObjects(LPBC pBndCtx, LPCWSTR wzUrl, IUnknown *pUnkOuter, IUnknown **ppUnk, IOInetProtocol **ppCTrans, DWORD dwOption, CTransData **pCTransData);
BOOL PDFNeedProgressiveDownload();

EXTERN_C const GUID CLSID_MsHtml;
EXTERN_C const GUID IID_ITransactionData;


//+---------------------------------------------------------------------------
//
//  Function:   CreateURLBinding
//
//  Synopsis:
//
//  Arguments:  [lpszUrl] --
//              [pbc] --
//              [ppBdg] --
//
//  Returns:
//
//  History:    12-04-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CreateURLBinding(LPWSTR lpszUrl, IBindCtx *pbc, IBinding **ppBdg)
{
    DEBUG_ENTER_API((DBG_BINDING,
                    Hresult,
                    "CreateURLBinding",
                    "%.80wq, %#x, %#x",
                    lpszUrl, pbc, ppBdg
                    ));

    PerfDbgLog(tagCBinding, NULL, "+CreateURLBinding");
    HRESULT  hr = NOERROR;

    PerfDbgLog1(tagCBinding, NULL, "-CreateURLBinding (IBinding:%lx)", *ppBdg);

    DEBUG_LEAVE_API(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::Create
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter] --
//              [LPBC] --
//              [pbc] --
//
//  Returns:
//
//  History:    12-06-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBinding::Create(IUnknown *pUnkOuter, LPCWSTR szUrl, LPBC pbc, REFIID riid, BOOL fBindToObject, CBinding **ppCBdg)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::Create",
                "%#x, %.80wq, %#x, %#x, %B, %#x",
                pUnkOuter, szUrl, pbc, &riid, fBindToObject, ppCBdg
                ));
                    
    PerfDbgLog1(tagCBinding, NULL, "+CBinding::Create (szUrl:%ws)", szUrl);
    HRESULT hr = NOERROR;
    CBinding *pCBdg;

    UrlMkAssert((ppCBdg != NULL));

    // Create and initialize the cbinding object
    pCBdg = new CBinding(NULL);
    if (pCBdg == NULL)
    {
        hr = E_OUTOFMEMORY;
    }

    *ppCBdg = pCBdg;

    PerfDbgLog2(tagCBinding, NULL, "-CBinding::Create (hr:%lx,IBinding:%lx)", hr, pCBdg);

    DEBUG_LEAVE(hr);
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Method:     CBinding::Initialize
//
//  Synopsis:
//
//  Arguments:  [szUrl] --
//              [pbc] --
//
//  Returns:
//
//  History:    12-04-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBinding::Initialize(LPCWSTR szUrl, IBindCtx *pbc, DWORD grfBindF, REFIID riid, BOOL fBindToObject)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::Initialize",
                "this=%#x, %.80wq, %#x, %#x, %#x, %B",
                this, szUrl, pbc, grfBindF, &riid, fBindToObject
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCBinding, this, "+CBinding::Initialize");

    _fBindToObject = fBindToObject;

    if (fBindToObject)
    {

        // Get the bind options from the bind context
        _bindopts.cbStruct = sizeof(BIND_OPTS);
        hr = pbc->GetBindOptions(&_bindopts);
        if (FAILED(hr))
        {
            goto End;
        }
    }

    hr = CBindCtx::Create(&_pBndCtx, pbc);


    if ((hr == NOERROR) && szUrl)
    {
        TransAssert((_pBndCtx));

        int cchWideChar;

        cchWideChar  = wcslen(szUrl) + 2;
        _lpwszUrl = (LPWSTR) new WCHAR [cchWideChar];
        if( !_lpwszUrl )
        {
            hr = E_OUTOFMEMORY;
            goto End;
        }
        wcscpy(_lpwszUrl, szUrl);

        // Try to get an IBindStatusCallback  pointer from the bind context
        hr = GetObjectParam(pbc, REG_BSCB_HOLDER, IID_IBindStatusCallback, (IUnknown**)&_pBSCB);

        UrlMkAssert(( (hr == NOERROR) && _pBSCB ));

        PerfDbgLog2(tagCBinding, this, "=== CBinding::Initialize (pbc:%lx -> _pBSCB:%lx)", pbc, _pBSCB);

        hr = GetTransactionObjects(_pBndCtx, _lpwszUrl, NULL, NULL, &_pOInetBdg,OIBDG_APARTMENTTHREADED, &_pCTransData);

        if (hr == S_OK)
        {
            TransAssert((!_pCTransData));
            // create the transaction data object
            // Note: the transdat object has a refcount
            //       and must be released when done
            hr = CTransData::Create(_lpwszUrl, grfBindF, riid, _pBndCtx, _fBindToObject, &_pCTransData);
            if (FAILED(hr))
            {
                //goto End;
            }
            else
            {
                UrlMkAssert((_pCTransData != NULL && "CTransData invalid"));
                _pBndCtx->SetTransData(_pCTransData);
            }
        }
        else if (hr == S_FALSE)
        {
            UrlMkAssert((_pCTransData != NULL && "CTransData invalid"));
            if (fBindToObject)
                _grfInternalFlags |= BDGFLAGS_BTS_BTO;
            else
                _grfInternalFlags |= BDGFLAGS_ATTACHED;

            hr = _pCTransData->Initialize(_lpwszUrl, grfBindF, riid, _pBndCtx);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if (_fBindToObject)
        {
            _piidRes = (IID *) &riid;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
End:

    PerfDbgLog1(tagCBinding, this, "-CBinding::Initialize (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::CBinding
//
//  Synopsis:
//
//  Arguments:  [pUnk] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CBinding::CBinding(IUnknown *pUnk) : _CRefs()
{
    DEBUG_ENTER((DBG_BINDING,
                None,
                "CBinding::CBinding",
                "this=%#x, %#x",
                this, pUnk
                ));
                
    _pUnk = pUnk;
    if (_pUnk)
    {
        _pUnk->AddRef();
    }
    _dwThreadId   = GetCurrentThreadId();
    _pBSCB        = 0;
    _nPriority    = THREAD_PRIORITY_NORMAL;
    _dwState      = 0;
    _OperationState = OPS_Initialized;
    _hwndNotify   = 0;
    _grfBINDF     = 0;
    _dwLastSize   = 0;
    _lpwszUrl     = 0;
    _pOInetBdg      = 0;
    _fSentLastNotification = 0;
    _fSentFirstNotification = 0;
    _fCreateStgMed = 0;
    _fCompleteDownloadHere = FALSE;
    _fForceBindToObjFail = FALSE;
    _fAcceptRanges = FALSE;
    _fClsidFromProt = FALSE;
    _pMnk = NULL;
    _pBndCtx = NULL;
    _piidRes = (IID*)&IID_IUnknown; // NULL;
    _pUnkObject = NULL;
    _pBasicAuth = NULL;
    _hrBindResult = NOERROR;
    _hrInstantiate = NOERROR;
    _dwBindError = 0;
    _grfInternalFlags = BDGFLAGS_NOTIFICATIONS;
    _pwzRedirectUrl = 0;
    _pwzResult = 0;

    _pBindInfo = 0;
    _clsidIn = CLSID_NULL;   
    
    _fCanGetIWinInetInfo = FALSE;
    _fCanGetIWinInetHttpInfo = FALSE;

    _fBTS_BTO = FALSE;
    DEBUG_LEAVE(0);
}
//+---------------------------------------------------------------------------
//
//  Method:     CBinding::~CBinding
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CBinding::~CBinding()
{
    DEBUG_ENTER((DBG_BINDING,
                None,
                "CBinding::~CBinding",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::~CBinding");

    if (_pBindInfo)
    {
        _pBindInfo->Release();
    }

    if (_pUnk)
    {
        DbgLog(tagCBinding, this, "CBinding::~CBinding Release on _pUnk");
        _pUnk->Release();
    }

    if (_pBasicAuth)
    {
        DbgLog1(tagCBinding, this, "CBinding::~CBinding Release on _pBasicAuth (%lx)", _pBasicAuth);
        _pBasicAuth->Release();
    }

    if (_pBSCB)
    {
        DbgLog1(tagCBinding, this, "CBinding::~CBinding Release on IBSCB (%lx)", _pBSCB);
        _pBSCB->Release();
    }

    if (_pOInetBdg)
    {
        _pOInetBdg->Release();
    }

    if (_pMnk)
    {
        _pMnk->Release();
    }
    if (_pBndCtx)
    {
        _pBndCtx->Release();
    }
    if (_pCTransData)
    {
        DbgLog1(tagCBinding, this, "CBinding::~CBinding Release TransData (%lx)", _pCTransData);
        _pCTransData->Release();
    }

    if (_pUnkObject)
    {
        _pUnkObject->Release();
    }

    if (_lpwszUrl)
    {
        delete [] _lpwszUrl;
    }
    if (_pwzRedirectUrl)
    {
        delete [] _pwzRedirectUrl;
    }
    if (_pwzResult)
    {
        delete [] _pwzResult;
    }

    ReleaseBindInfo(&_BndInfo);

    PerfDbgLog(tagCBinding, this, "-CBinding::~CBinding");

    DEBUG_LEAVE(0);
}

LPWSTR CBinding::GetFileName()
{
    DEBUG_ENTER((DBG_BINDING,
                String,
                "CBinding::GetFileName",
                "this=%#x",
                this
                ));

    LPWSTR wzFilename = _pCTransData->GetFileName();

    DEBUG_LEAVE(wzFilename);
    return wzFilename;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppv] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::QueryInterface( REFIID riid, void **ppv )
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppv
                ));
                
    PerfDbgLog2(tagCBinding, this, "+CBinding::QueryInterface (%lx, %lx)", riid, ppv);
    HRESULT     hr = NOERROR;
    *ppv = NULL;

    //UrlMkAssert(( !IsEqualIID(GetProtocolClassID(),CLSID_NULL) ));

    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IBinding) )
    {
        *ppv = (void FAR *)(IBinding *)this;
        AddRef();
    }
    else if (IsEqualIID(riid, IID_IOInetProtocolSink))
    {
        *ppv = (void FAR *)(IOInetProtocolSink *)this;
        AddRef();
    }
    else if (IsEqualIID(riid, IID_IOInetBindInfo))
    {
        *ppv = (void FAR *)(IOInetBindInfo *)this;
        AddRef();
    }
    else if (IsEqualIID(riid, IID_IServiceProvider))
    {
        *ppv = (void FAR *)(IServiceProvider *)this;
        AddRef();
    }
    else if (IsEqualIID(riid, IID_IWinInetInfo))
    {
        if (_pOInetBdg)
        {
            IWinInetInfo    *pIWinInetInfo;
            hr = _pOInetBdg->QueryInterface(riid, (void **)&pIWinInetInfo);
            if (S_FALSE == hr) 
                hr = E_NOINTERFACE;//see bug 99754
            //dont keep the reference..release it immdly.
            if (SUCCEEDED(hr))
            {
                pIWinInetInfo->Release();
                _fCanGetIWinInetInfo = TRUE;
                *ppv = (void FAR *) (IWinInetInfo *)this;
                AddRef();
            }
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }
    else if (IsEqualIID(riid, IID_IWinInetHttpInfo))
    {
        if (_pOInetBdg)
        {
            IWinInetHttpInfo    *pIWinInetHttpInfo;
            hr = _pOInetBdg->QueryInterface(riid, (void **)&pIWinInetHttpInfo);
            if (S_FALSE == hr)
                hr = E_NOINTERFACE;//see bug 99754
            if (SUCCEEDED(hr))
            {
                pIWinInetHttpInfo->Release();
                _fCanGetIWinInetHttpInfo = TRUE;
                *ppv = (void FAR *) (IWinInetHttpInfo *)this;
                AddRef();
            }         
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
#if DBG==1
        //LPSTR lpszName = GetInterfaceName(riid);
        //DbgLog3(tagCBinding, this, "CBinding::QI(pUnkObj) >%s< hr:%lx [%lx]", lpszName, hr, *ppv));
#endif // DBG==1

    }

    PerfDbgLog2(tagCBinding, this, "-CBinding::QueryInterface (%lx)[%lx]", hr, *ppv);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::AddRef
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBinding::AddRef( void )
{
    DEBUG_ENTER((DBG_BINDING,
                Dword,
                "CBinding::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    LONG lRet = ++_CRefs;
    PerfDbgLog1(tagCBinding, this, "CBinding::AddRef (%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::Release
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBinding::Release( void )
{
    DEBUG_ENTER((DBG_BINDING,
                Dword,
                "CBinding::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::Release");
    LONG lRet = --_CRefs;
    if (_CRefs == 0)
    {
        delete this;
    }
    PerfDbgLog1(tagCBinding, this, "-CBinding::Release (%ld)", lRet);
    
    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::Abort
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::Abort( void )
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IBinding::Abort",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::Abort");
    HRESULT     hr = NOERROR;
    
    // AddRef - Release pair to guard this function since it may 
    // call OnStopBinding() and client will re-enter this 
    // Object with a Release() call.

    AddRef();

    if (   (GetOperationState() < OPS_Abort)
        && (GetOperationState() > OPS_Initialized))
    {
        DbgLog(tagCBindingErr, this, ">>> CBinding::Abort");

        // Abort will call OnStopBinding
        TransAssert((_pOInetBdg));
        hr = _pOInetBdg->Abort(E_ABORT, 0);
        if( hr != INET_E_RESULT_DISPATCHED )
        {
            //
            // only set state to OPS_Abort if the the ReportResult
            // has not been dispatched already
            //
            DbgLog(tagCBindingErr, this, ">>> Result already dispatched");
            SetOperationState(OPS_Abort);
        }
    }
    else
    {
        UrlMkAssert(( (   (GetOperationState() < OPS_Stopped)
                       && (GetOperationState() > OPS_Initialized)) ));
        hr = E_FAIL;
    }

    PerfDbgLog1(tagCBinding, this, "-CBinding::Abort (hr:%lx)", hr);

    // release
    Release();

    DEBUG_LEAVE(hr);
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Method:     CBinding::Suspend
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::Suspend( void )
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IBinding::Suspend",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::Suspend");
    HRESULT     hr = E_FAIL;

#ifdef SUSPEND_WORKING
    if (   (GetOperationState() < OPS_Stopped)
        && (GetOperationState() > OPS_Initialized))
    {
        SetOperationState(OPS_Suspend);
    }
    else
    {
        UrlMkAssert(( (   (GetOperationState() < OPS_Stopped)
                       && (GetOperationState() > OPS_Initialized)) ));
    }
#endif //SUSPEND_WORKING

    hr = _pOInetBdg->Suspend();

#ifdef UNUSED
    UrlMkAssert((_dwState == OPS_Downloading));

    _dwState = OPS_Suspend;
    if (_pOInetBdg)
    {
        _pOInetBdg->SetOperationState(OPS_Suspend);
    }
#endif //UNUSED

    PerfDbgLog1(tagCBinding, this, "-CBinding::Suspend (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Method:     CBinding::Resume
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::Resume( void )
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IBinding::Resume",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::Resume");
    HRESULT     hr = NOERROR;


    if (GetOperationState() == OPS_Suspend)
    {
        SetOperationState(OPS_Downloading);
    }
    else
    {
        UrlMkAssert(( GetOperationState() == OPS_Suspend ));
    }
    hr = _pOInetBdg->Resume();

    PerfDbgLog1(tagCBinding, this, "-CBinding::Resume (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Method:     CBinding::SetPriority
//
//  Synopsis:
//
//  Arguments:  [nPriority] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::SetPriority(LONG nPriority)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IBinding::SetPriority",
                "this=%#x, %d",
                this, nPriority
                ));
                
    PerfDbgLog1(tagCBinding, this, "+CBinding::SetPriority (%ld)", nPriority);
    HRESULT     hr = NOERROR;

    _nPriority = nPriority;

    PerfDbgLog1(tagCBinding, this, "-CBinding::SetPriority (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Method:     CBinding::GetPriority
//
//  Synopsis:
//
//  Arguments:  [pnPriority] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::GetPriority(LONG *pnPriority)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IBinding::GetPriority",
                "this=%#x, %#x",
                this, pnPriority
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::GetPriority");
    HRESULT     hr = NOERROR;

    if (!pnPriority)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *pnPriority = _nPriority;
    }

    PerfDbgLog1(tagCBinding, this, "-CBinding::GetPriority (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::GetBindResult
//
//  Synopsis:
//
//  Arguments:  [pnPriority] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::GetBindResult(CLSID *pclsidProtocol, DWORD *pdwResult, LPWSTR *pszResult,DWORD *pdwReserved)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IBinding::GetBindResult",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, pclsidProtocol, pdwResult, pszResult, pdwReserved
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::GetBindResult");
    HRESULT     hr = NOERROR;

    if (!pdwResult || !pszResult || pdwReserved)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        HRESULT  hrRet = NOERROR;
        *pdwResult = 0;
        *pszResult = 0;
        *pclsidProtocol = CLSID_NULL;

        if ((hrRet = GetInstantiateHresult()) != NOERROR)
        {
            *pdwResult = (DWORD) hrRet;
            TransAssert ((  (_hrBindResult == INET_E_CANNOT_INSTANTIATE_OBJECT)
                         || (_hrBindResult == INET_E_CANNOT_LOAD_DATA) ));
        }
        else if (_hrBindResult != NOERROR)
        {
            *pclsidProtocol = _clsidProtocol;
            *pszResult = OLESTRDuplicate(_pwzResult);

            UrlMkAssert(( (_dwBindError != 0) || (_hrBindResult != NOERROR) ));

            if (_dwBindError == 0)
            {
                _dwBindError = _hrBindResult;
            }
            *pdwResult = _dwBindError;
        }
    }

    PerfDbgLog3(tagCBinding, this, "-CBinding::GetBindResult (hr:%lx,_hrBindResult;%lx, pdwResult:%lx)", hr, _hrBindResult, *pdwResult);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::QueryOption
//
//  Synopsis:   Calls QueryOptions on
//
//  Arguments:  [dwOption] --
//              [pBuffer] --
//              [pcbBuf] --
//
//  Returns:
//
//  History:    4-10-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::QueryOption(DWORD dwOption, LPVOID pBuffer, DWORD *pcbBuf)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IWinInetHttpInfo::QueryOption",
                "this=%#x, %#x, %#x, %#x",
                this, dwOption, pBuffer, pcbBuf
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCBinding, this, "+CBinding::QueryOption");
    VDATEPTROUT(pcbBuf, DWORD*);

    if (   (GetOperationState() < OPS_Stopped)
        && (GetOperationState() > OPS_Initialized))
    {
        TransAssert((_fCanGetIWinInetInfo || _fCanGetIWinInetHttpInfo));
        if (_fCanGetIWinInetInfo)
        {
            IWinInetInfo    *pIWinInetInfo;
            hr = _pOInetBdg->QueryInterface(IID_IWinInetInfo, (void **)&pIWinInetInfo);
            if (S_FALSE == hr) 
                hr = E_NOINTERFACE;//see bug 99754
            if (SUCCEEDED(hr)) 
            {
                hr = pIWinInetInfo->QueryOption(dwOption, pBuffer, pcbBuf);
                //dont keep the reference..release it immdly.
                pIWinInetInfo->Release();
            }
        }
        else if (_fCanGetIWinInetHttpInfo)
        {
            IWinInetHttpInfo    *pIWinInetHttpInfo;
            hr = _pOInetBdg->QueryInterface(IID_IWinInetHttpInfo, (void **)&pIWinInetHttpInfo);
            if (S_FALSE == hr) 
                hr = E_NOINTERFACE;//see bug 99754
            if (SUCCEEDED(hr))
            {
                hr = pIWinInetHttpInfo->QueryOption(dwOption, pBuffer, pcbBuf);
                //dont keep the reference..release it immdly.
                pIWinInetHttpInfo->Release();
            }
        }
    }
    else
    {
        hr = E_FAIL;
    }

    PerfDbgLog1(tagCBinding, this, "-CBinding::QueryOption (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::QueryInfo
//
//  Synopsis:   Calls QueryInfos on
//
//  Arguments:  [dwOption] --
//              [pBuffer] --
//              [pcbBuf] --
//              [pdwFlags] --
//              [pdwReserved] --
//
//  Returns:
//
//  History:    4-10-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::QueryInfo(DWORD dwOption, LPVOID pBuffer, DWORD *pcbBuf, DWORD *pdwFlags, DWORD *pdwReserved)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IWinInetHttpInfo::QueryInfo",
                "this=%#x, %#x, %#x, %#x, %#x, %#x",
                this, dwOption, pBuffer, pcbBuf, pdwFlags, pdwReserved
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCBinding, this, "+CBinding::QueryInfo");
    VDATEPTROUT(pcbBuf, DWORD*);

    if (   (GetOperationState() < OPS_Stopped)
        && (GetOperationState() > OPS_Initialized))
    {
        TransAssert((_fCanGetIWinInetHttpInfo));
        IWinInetHttpInfo    *pIWinInetHttpInfo;
        hr = _pOInetBdg->QueryInterface(IID_IWinInetHttpInfo, (void **)&pIWinInetHttpInfo);
        if (S_FALSE == hr)
            hr = E_NOINTERFACE;//see bug 99754
        if (SUCCEEDED(hr))
        {
            hr = pIWinInetHttpInfo->QueryInfo(dwOption, pBuffer, pcbBuf, pdwFlags, pdwReserved);
            //dont keep the reference..release it immdly.
            pIWinInetHttpInfo->Release();
        }
    }
    else
    {
        hr = E_FAIL;
    }

    PerfDbgLog1(tagCBinding, this, "-CBinding::QueryInfo (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

// IServiceProvider methods

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::QueryService
//
//  Synopsis:   Calls QueryInfos on
//
//  Arguments:  [rsid] --
//              [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    4-10-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT IUnknown_QueryService(IUnknown* punk, REFGUID rsid, REFIID riid, void ** ppvObj)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "IUnknown_QueryService",
                "%#x, %#x, %#x, %#x",
                punk, &rsid, &riid, ppvObj
                ));
                
    HRESULT hr = E_NOINTERFACE;

    *ppvObj = 0;

    if (punk)
    {
        IServiceProvider *pSrvPrv;
        hr = punk->QueryInterface(IID_IServiceProvider, (void **) &pSrvPrv);
        if (hr == NOERROR)
        {
            hr = pSrvPrv->QueryService(rsid,riid, ppvObj);
            pSrvPrv->Release();
        }
    }

    DEBUG_LEAVE(hr);
    return hr;
}

HRESULT CBinding::QueryService(REFGUID rsid, REFIID riid, void ** ppvObj)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IServiceProvider::QueryService",
                "this=%#x, %#x, %#x, %#x",
                this, &rsid, &riid, ppvObj
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::QueryService");
    HRESULT hr = E_NOINTERFACE;
    VDATETHIS(this);
    UrlMkAssert((ppvObj));

    hr = IUnknown_QueryService(_pBSCB, rsid, riid, ppvObj);

    PerfDbgLog1(tagCBinding, this, "-CBinding::QueryService (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//IOInetBindInfo methods
//+---------------------------------------------------------------------------
//
//  Method:     CBinding::GetBindInfo
//
//  Synopsis:
//
//  Arguments:  [pdwBINDF] --
//              [pbindinfo] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBinding::GetBindInfo(DWORD *pdwBINDF, BINDINFO *pbindinfo)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IInternetBindInfo::GetBindInfo",
                "this=%#x, %#x, %#x",
                this, pdwBINDF, pbindinfo
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::GetBindInfo");
    HRESULT hr = NOERROR;

    TransAssert((pdwBINDF && pbindinfo));

    *pdwBINDF = _grfBINDF;
    hr = CopyBindInfo(&_BndInfo, pbindinfo ); // Src->Dest

    //for IE6 bug 1898.
    //For hglobals, copybindinfo allocates new handle and copies over the source data,
    //but uses the source as pUnkForRelease and AddRefs it.. but the source has no reference
    //to the new handle to free.
    //So free the addrefed pUnkForRelease and NULL it, so that ReleaseStgMedium() calls
    //GlobalFree().
    //There is also a bug in ReleaseBindInfo(), where we always call ReleaseStgMedium(),
    //irrespective of the pUnkForRelease member - this fix doesn't depend on that behavior,
    //but it does need the receiver of the stgmed in this bindinfo to ReleaseStgMedium() either
    //indirectly through ReleaseBindInfo() or directly.
    if (SUCCEEDED(hr))
    {
        STGMEDIUM* pStgmed = &(pbindinfo->stgmedData);
        if ( (pStgmed->tymed == TYMED_HGLOBAL) &&
             (pStgmed->hGlobal) &&
             (pStgmed->pUnkForRelease) )
        {
             pStgmed->pUnkForRelease->Release();
             pStgmed->pUnkForRelease = NULL;
        }
    }
    
    PerfDbgLog1(tagCBinding, this, "-CBinding::GetBindInfo (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::GetBindString
//
//  Synopsis:
//
//  Arguments:  [ulStringType] --
//              [ppwzStr] --
//              [cEl] --
//              [pcElFetched] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBinding::GetBindString(ULONG ulStringType, LPOLESTR *ppwzStr, ULONG cEl, ULONG *pcElFetched)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IInternetBindInfo::GetBindString",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, ulStringType, ppwzStr, cEl, pcElFetched
                ));
                
    PerfDbgLog(tagCBinding, this, "+CTransaction::GetBindString");
    HRESULT hr = INET_E_USE_DEFAULT_SETTING;

    switch (ulStringType)
    {
    case BINDSTRING_HEADERS     :
        break;
    case BINDSTRING_ACCEPT_MIMES:
        hr = _pCTransData->GetAcceptMimes(ppwzStr,cEl, pcElFetched);
        break;
    case BINDSTRING_EXTRA_URL   :
        break;
    case BINDSTRING_LANGUAGE    :
        break;
    case BINDSTRING_USERNAME    :
        break;
    case BINDSTRING_PASSWORD    :
        break;
    case BINDSTRING_ACCEPT_ENCODINGS:
        break;
    case BINDSTRING_URL:
        if( _lpwszUrl )
        {
            LPWSTR pwzURL = NULL;
            pwzURL = OLESTRDuplicate(_lpwszUrl);
            if( pwzURL )
            {
                *ppwzStr = pwzURL,
                *pcElFetched = 1;
                hr = NOERROR;
            }
            else
            {
                hr = E_OUTOFMEMORY;
                *pcElFetched = 0;
            }
        }
        break;
    case BINDSTRING_USER_AGENT  :
    case BINDSTRING_POST_COOKIE :
    case BINDSTRING_POST_DATA_MIME:
        {
        hr = NOERROR;
        // QI on IBSC for interface
        if (_pBindInfo == NULL)
        {
            hr = LocalQueryInterface(IID_IInternetBindInfo, (void **)&_pBindInfo);
        }
        
        if ( (hr == NOERROR) && _pBindInfo)
        {
            hr = _pBindInfo->GetBindString(ulStringType, ppwzStr, cEl, pcElFetched);
        }
        }
        break;

    case BINDSTRING_IID:
        TransAssert(_piidRes);
        if (_piidRes)
        {
            hr = StringFromCLSID(*_piidRes, ppwzStr);
            if (pcElFetched)
            {
                *pcElFetched = (SUCCEEDED(hr)) ? (1) : (0);
            }
        }
        else
        {
            hr = E_UNEXPECTED;
            *pcElFetched = 0;
        }
        break;

    case BINDSTRING_FLAG_BIND_TO_OBJECT:
        *ppwzStr = new WCHAR[FLAG_BTO_STR_LENGTH];

        if (*ppwzStr)
        {
            if (_fBindToObject)
            {
                 StrCpyNW(*ppwzStr, FLAG_BTO_STR_TRUE,
                          lstrlenW(FLAG_BTO_STR_TRUE) + 1);
            }
            else
            {
                StrCpyNW(*ppwzStr, FLAG_BTO_STR_FALSE,
                         lstrlenW(FLAG_BTO_STR_FALSE) + 1);
            }
            *pcElFetched = 1;
            hr = S_OK;
        }
        else
        {
            *pcElFetched = 0;
            hr = E_OUTOFMEMORY;
        }
       
        break;

    case BINDSTRING_PTR_BIND_CONTEXT:
        if (!_pBndCtx) {
            hr = E_UNEXPECTED;
            *pcElFetched = 0;
        }
        else {
            *ppwzStr = new WCHAR[MAX_DWORD_DIGITS + 1];
            
            if (*ppwzStr)
            {
                wnsprintfW(*ppwzStr, MAX_DWORD_DIGITS, 
#ifdef _WIN64
                           L"%I64d", 
#else
                           L"%ld", 
#endif
                           (DWORD_PTR)_pBndCtx);

                *pcElFetched = 1;
                _pBndCtx->AddRef();
                hr = S_OK;
            }
            else
            {
                *pcElFetched = 0;
                hr = E_OUTOFMEMORY;
            }
        }

        break;

    default:
        TransAssert((FALSE));
    }

    PerfDbgLog1(tagCBinding, this, "-CBinding::GetBindString (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBindProtocol::CBindProtocol
//
//  Synopsis:
//
//  Arguments:  [pUnk] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CBindProtocol::CBindProtocol() : _CRefs()
{
    DEBUG_ENTER((DBG_BINDING,
                None,
                "CBindProtocol::CBindProtocol",
                "this=%#x",
                this
                ));
                
    _pUnk = NULL;
    
    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindProtocol::~CBindProtocol
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CBindProtocol::~CBindProtocol()
{
    DEBUG_ENTER((DBG_BINDING,
                None,
                "CBindProtocol::~CBindProtocol",
                "this=%#x",
                this
                ));
                
    DEBUG_LEAVE(0);
}
//+---------------------------------------------------------------------------
//
//  Method:     CBindProtocol::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppv] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindProtocol::QueryInterface( REFIID riid, void **ppv )
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBindProtocol::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppv
                ));
                
    HRESULT     hr = NOERROR;

    PerfDbgLog2(tagCBinding, this, "+CBindProtocol::QueryInterface (%lx, %lx)", riid, ppv);

    if (   IsEqualIID(riid, IID_IUnknown)
        || IsEqualIID(riid, IID_IBindProtocol) )
    {
        *ppv = (void FAR *)this;
        AddRef();
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
#if DBG==1
        //LPSTR lpszName = GetInterfaceName(riid);
        //DbgLog3(tagCBinding, this, "CBindProtocol::QI(pUnkObj) >%s< hr:%lx [%lx]", lpszName, hr, *ppv);
#endif // DBG==1

    }

    PerfDbgLog2(tagCBinding, this, "-CBindProtocol::QueryInterface (%lx)[%lx]", hr, *ppv);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindProtocol::AddRef
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBindProtocol::AddRef( void )
{
    DEBUG_ENTER((DBG_BINDING,
                Dword,
                "CBindProtocol::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    LONG lRet = _CRefs++;
    PerfDbgLog1(tagCBinding, this, "CBindProtocol::AddRef (%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindProtocol::Release
//
//  Synopsis:
//
//  Arguments:  [void] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBindProtocol::Release( void )
{
    DEBUG_ENTER((DBG_BINDING,
                Dword,
                "CBindProtocol::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBindProtocol::Release");

    LONG lRet = --_CRefs;
    if (_CRefs == 0)
    {
        if (_pUnk)
        {
            PerfDbgLog(tagCBinding, this, "+CBindProtocol::Release _pUnk");
            _pUnk->Release();
            _pUnk = NULL;
            PerfDbgLog(tagCBinding, this, "-CBindProtocol::Release _pUnk");
        }

        delete this;
    }

    PerfDbgLog1(tagCBinding, this, "-CBindProtocol::Release (%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindProtocol::CreateBinding
//
//  Synopsis:
//
//  Arguments:  [url] --
//              [pBCtx] --
//              [ppBdg] --
//
//  Returns:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindProtocol::CreateBinding(LPCWSTR szUrl, IBindCtx *pBCtx, IBinding **ppBdg)
{
    DEBUG_ENTER((DBG_BINDING,
                Dword,
                "CBindProtocol::IBindProtocol::CreateBinding",
                "this=%#x, %.80wq, %#x, %#x",
                this, szUrl, pBCtx, ppBdg
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBindProtocol::CreateBinding");
    HRESULT hr = NOERROR;

    BIND_OPTS           bindopts;
    CBinding            *pCBdg = NULL;
    VDATEPTROUT(ppBdg, LPVOID);
    VDATEIFACE(pBCtx);

    *ppBdg = NULL;
    // Get the bind options from the bind context
    bindopts.cbStruct = sizeof(BIND_OPTS);
    hr = pBCtx->GetBindOptions(&bindopts);
    ChkHResult(hr);

    hr = CBinding::Create(NULL, szUrl, pBCtx, IID_IStream, FALSE, &pCBdg );
    if (hr != NOERROR)
    {
        DEBUG_LEAVE(hr);
        return hr;
    }

    // Start the download transaction
    {
        LPWSTR pwzExtra = NULL;
        hr = pCBdg->StartBinding(szUrl, pBCtx, IID_IStream, FALSE, &pwzExtra, NULL);
    }

    if (FAILED(hr))
    {
        // the transaction could not be started
        goto End;
    }

    // if the caller doesn't support IBindStatusCallback
    if ( pCBdg->IsAsyncBinding() )
    {
        // Async case: interface is passed on in OnDataAvailable
        *ppBdg = pCBdg;
    }

End:
    if (pCBdg)
    {
        pCBdg->Release();
    }

    PerfDbgLog1(tagCBinding, this, "-CBindProtocol::CreateBinding (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetObjectParam
//
//  Synopsis:
//
//  Arguments:  [pbc] --
//              [pszKey] --
//              [riid] --
//              [ppUnk] --
//
//  Returns:
//
//  History:    12-04-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT GetObjectParam(IBindCtx *pbc, LPOLESTR pszKey, REFIID riid, IUnknown **ppUnk)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "GetObjectParam",
                "%#x, %#x, %#x, %#x",
                pbc, pszKey, &riid, ppUnk
                ));
                
    PerfDbgLog1(tagCBinding, NULL, "+GetObjectParam (IBindCtx:%lx)", pbc);
    HRESULT hr = E_FAIL;
    IUnknown *pUnk;

    // Try to get an IUnknown pointer from the bind context
    if (pbc)
    {
        hr = pbc->GetObjectParam(pszKey, &pUnk);
    }
    if (FAILED(hr))
    {
        *ppUnk = NULL;
    }
    else
    {
        // Query for riid
        hr = pUnk->QueryInterface(riid, (void **)ppUnk);
        pUnk->Release();

        if (FAILED(hr))
        {
            *ppUnk = NULL;
            DumpIID(riid);
        }
    }

    PerfDbgLog2(tagCBinding, NULL, "-GetObjectParam (IBindCtx:%lx, hr:%lx)", pbc, hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::StartBinding
//
//  Synopsis:
//
//  Arguments:  [fBindToObject] --
//
//  Returns:
//
//  History:    12-04-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBinding::StartBinding(LPCWSTR szUrl, IBindCtx *pbc, REFIID riid, BOOL fBindToObject, LPWSTR *ppwzExtra, LPVOID *ppv )
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::StartBinding",
                "this=%#x, %.80wq, %#x, %#x, %B, %#x, %#x",
                this, szUrl, pbc, &riid, fBindToObject, ppwzExtra, ppv
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::StartTransaction");
    //DbgLog1(tagCBindingErr, this, ">>> CBinding::Start(url=%ws)", szUrl);
    HRESULT hr;
    BOOL fBindingStarted = FALSE;

    UrlMkAssert((ppwzExtra));
    UrlMkAssert((_pBSCB == NULL));

    do
    {
        // Try to get an IBindStatusCallback  pointer from the bind context
        hr = GetObjectParam(pbc, REG_BSCB_HOLDER, IID_IBindStatusCallback, (IUnknown**)&_pBSCB);

        if  (FAILED(hr))
        {
            break;
        }
        UrlMkAssert(( (hr == NOERROR) && _pBSCB ));

        if  (_pBSCB == NULL)
        {
            hr = E_INVALIDARG;
            break;
        }
        _fBindToObject = fBindToObject;
        if (_fBindToObject)
        {
            _grfInternalFlags |= BDGFLAGS_PARTIAL;
            _piidRes = (IID *) &riid;

            // Get the bind options from the bind context
            _bindopts.cbStruct = sizeof(BIND_OPTS);
            hr = pbc->GetBindOptions(&_bindopts);
            if (FAILED(hr))
            {
                break;
            }
        }

        hr = CBindCtx::Create(&_pBndCtx, pbc);

        if (FAILED(hr))
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        {
            int cchWideChar;

            cchWideChar  = wcslen(szUrl) + 2;
            _lpwszUrl = (LPWSTR) new WCHAR [cchWideChar];
            if( !_lpwszUrl )
            {
                hr = E_OUTOFMEMORY;
                break;
            }
            wcscpy(_lpwszUrl, szUrl);
        }

        // call GetBindInfo
        _BndInfo.cbSize = sizeof(BINDINFO);

#if DBG==1
        if (_BndInfo.stgmedData.tymed != TYMED_NULL)
        {
            PerfDbgLog1(tagCBinding, this, "CBinding::StartTransaction ReleaseStgMedium (%lx)", _BndInfo.stgmedData);
        }
#endif // DBG==1

        // Make sure the BINDINFO is released and empty
        ReleaseBindInfo(&_BndInfo);

        _grfBINDF = 0;
        // call IBSC::GetBindInfo
        TransAssert((_BndInfo.stgmedData.tymed == TYMED_NULL));

        hr = CallGetBindInfo(&_grfBINDF, &_BndInfo);

        if( hr == NOERROR && !IsAsyncTransaction() )
        {
            // we need to turn off BINDF_ASYNCSTORAGE for sync binding
            _grfBINDF &= ~BINDF_ASYNCSTORAGE;
        }

        // this call should not fail
        if (FAILED(hr))
        {
            break;
        }

        // turn on direct read - not documented yet for APPs
        if (g_dwSettings & 0x20000000)
        {
            _grfBINDF |= BINDF_DIRECT_READ;
        }

        // check for extend binding (rosebud) 

        // get the bind option for extend binding (low bits)
        // the highest 16 bits is used for additional flags (e.g. wininet flag) 
        DWORD dwExtBindOption = _BndInfo.dwOptions & 0x0000ffff;
        if( dwExtBindOption && !fBindToObject)
        {
            // extend binding (rosebud)
            COInetSession* pSession = NULL;
            IOInetProtocol* pProt = NULL;

            hr = GetCOInetSession(0, &pSession, 0);
            if( hr != NOERROR )
            {
                break;
            }

            CLSID clsid = CLSID_NULL;
            DWORD dwLocation = 0;
            hr = pSession->CreateFirstProtocol(
                _lpwszUrl, NULL, NULL, &pProt, &clsid, &dwLocation, dwExtBindOption);
            pSession->Release();

            if( hr != NOERROR )
            {
                break;
            }


            StartParam param;
            param.iid =  riid;
            param.pIBindCtx = pbc; 
            param.pItf = NULL;

            // the interface ptr is returned via param.pItf
            hr = pProt->Start(_lpwszUrl, NULL, NULL, 0, (DWORD_PTR) &param );

            // release the pluggable protocol
            pProt->Release();

            if( hr == NOERROR && param.pItf )
            {
                // we are done, return the pointer
                *ppv = param.pItf;
                hr = INET_E_USE_EXTEND_BINDING;
                break; 
            }
            else
            if( hr != INET_E_USE_DEFAULT_PROTOCOLHANDLER )
            {
                break;
            }
                
            // continue with the normal binding process...
        }
        
        {
            // check for iid (only for BindToStorage)
            if( !fBindToObject && (IsRequestedIIDValid(riid) == FALSE) )
            {
                hr = E_INVALIDARG;
                break;
            }

            if (!IsOInetProtocol(pbc, szUrl))
            { 
                hr = INET_E_UNKNOWN_PROTOCOL;
                break;
            }


            DWORD dwObjectsFlags = OIBDG_APARTMENTTHREADED;
            if (_fBindToObject)
            {
                dwObjectsFlags |= BDGFLAGS_PARTIAL;
            }

            hr = GetTransactionObjects(_pBndCtx, _lpwszUrl, NULL, NULL, &_pOInetBdg, dwObjectsFlags, &_pCTransData);
        }

        if (hr == S_OK)
        {
            TransAssert((!_pCTransData));
            // create the transaction data object
            // Note: the transdat object has a refcount
            //       and must be released when done
            hr = CTransData::Create(_lpwszUrl, _grfBINDF, riid, _pBndCtx, _fBindToObject, &_pCTransData);
            if (SUCCEEDED(hr))
            {
                UrlMkAssert((_pCTransData != NULL && "CTransData invalid"));
                _pBndCtx->SetTransData(_pCTransData);
            }
        }
        else if (hr == S_FALSE)
        {
            // found an existing transaction
            UrlMkAssert((_pCTransData != NULL && "CTransData invalid"));
            if (fBindToObject)
                _grfInternalFlags |= BDGFLAGS_BTS_BTO;
            else
                _grfInternalFlags |= BDGFLAGS_ATTACHED;
    
            hr = _pCTransData->Initialize(_lpwszUrl, _grfBINDF, riid, _pBndCtx, fBindToObject);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if (FAILED(hr))
        {
            break;
        }

        // hand back to pointer to of extra info
        // to update the url
        *ppwzExtra = (_BndInfo.szExtraInfo) ? _BndInfo.szExtraInfo : NULL;

        if (_pCTransData->SetDataSink(_grfBINDF) == DataSink_Unknown)
        {
            hr = E_INVALIDARG;
        }

        if (   (_pCTransData->IsFileRequired())
            || (IsKnownProtocol(_lpwszUrl) == DLD_PROTOCOL_NONE) )
        {
            PerfDbgLog(tagCBinding, this, "---TURN ON NEEDFILE!---");
            // turn on flag to request file from protocol
            _grfBINDF |= BINDF_NEEDFILE;
        }

        if (SUCCEEDED(hr))
        {
            PerfDbgLog(tagCBinding, this, "---BINDF_FROMURLMON---");
            // turn on flag indicating the binding is from urlmon
            _grfBINDF |= BINDF_FROMURLMON;

            if( _fBindToObject )
            {
                _BndInfo.dwOptions |= BINDINFO_OPTIONS_BINDTOOBJECT;
            }
        }

        if (FAILED(hr))
        {
            break;
        }

        // send the OnStartBinding notification
        hr = CallOnStartBinding(NULL, this);
        fBindingStarted = TRUE;

        // check if the user did abort
        if (SUCCEEDED(hr))
        {
            OperationState opSt = GetOperationState();
            UrlMkAssert((opSt > OPS_Initialized));

            if (opSt == OPS_Abort)
            {
                hr = E_ABORT;
            }
        }

        BOOL fIsSync = (IsAsyncTransaction() == FALSE);

        if ( SUCCEEDED(hr))
        {
            // Note: check if url got redirected
            //       and report redirection url

            if (_pwzRedirectUrl)
            {
                PerfDbgLog1(tagCBinding, this, "StartTransaction OnProgress REDIRECTING _pBSCP(%lx)", _pBSCB);
                hr = CallOnProgress( 0, 0, BINDSTATUS_REDIRECTING,_pwzRedirectUrl );
                PerfDbgLog1(tagCBinding, this, "StartTransaction OnProgress REDIRECTING _pBSCP(%lx)", _pBSCB);
            }
        }

        if (    SUCCEEDED(hr))
        {
            DWORD dwBindFlags = OIBDG_APARTMENTTHREADED | PI_MIMEVERIFICATION | PI_DOCFILECLSIDLOOKUP;

            if (fIsSync)
            {
                dwBindFlags |= PI_SYNCHRONOUS;
            }
            if(_grfBINDF & BINDF_PREFERDEFAULTHANDLER)
            {
                dwBindFlags |= BINDF_PREFERDEFAULTHANDLER;
            }
            if (_grfBINDF & BINDF_FREE_THREADED)
            {
                dwBindFlags &= ~OIBDG_APARTMENTTHREADED;
            }
            if (_fBindToObject)
            {
                dwBindFlags |= BDGFLAGS_PARTIAL | PI_CLASSINSTALL;
            }

            if (_grfInternalFlags & BDGFLAGS_BTS_BTO)
            {
                dwBindFlags |= BDGFLAGS_BTS_BTO;
            }
            
            if (_grfInternalFlags & BDGFLAGS_ATTACHED)
            {
                dwBindFlags |= BDGFLAGS_ATTACHED;
            }
            
            if (_pOInetBdg)
            {
                // Just before starting the transaction give it the priority.

                IOInetPriority * pOInetPriority = NULL;
                if (_pOInetBdg->QueryInterface(IID_IOInetPriority, (void **) &pOInetPriority) == S_OK)
                {
                    pOInetPriority->SetPriority(_nPriority);
                    pOInetPriority->Release();
                }
            }

            if (   _pCTransData->InProgress() != S_FALSE
                || !_pCTransData->IsRemoteObjectReady() )
            {
                // guard the transaction object
                // the operation might complete synchronous
                _pOInetBdg->AddRef();

                hr = _pCTransData->OnStart(_pOInetBdg);
                TransAssert((hr == NOERROR));
                if (hr == NOERROR)
                {
                    hr = _pOInetBdg->Start(_lpwszUrl, (IOInetProtocolSink *) this, (IOInetBindInfo *) this, dwBindFlags, 0);
                }

                _pOInetBdg->Release();
            }
            else
            {
                // call OnProgress for mime type and filename
                //
                DWORD dwSize = _pCTransData->GetDataSize();
                if (_pCTransData->GetMimeType())
                {
                    OnTransNotification(BINDSTATUS_MIMETYPEAVAILABLE, dwSize, dwSize, (LPWSTR)_pCTransData->GetMimeType(), NOERROR);
                }
                if (_pCTransData->GetFileName())
                {
                    OnTransNotification(BINDSTATUS_CACHEFILENAMEAVAILABLE, dwSize, dwSize, _pCTransData->GetFileName(), NOERROR );
                }
                // report data - will call OnStopBinding
                OnTransNotification(BINDSTATUS_ENDDOWNLOADDATA, dwSize, dwSize,0 , NOERROR);
            }
        }

        break;
    } while (TRUE);

    if ( FAILED(hr))
    {
        // call OnStopBinding in case of error
        HRESULT hr1 = NOERROR;
        if ((_pBSCB != NULL) && fBindingStarted)
        {
            _hrBindResult = hr;
            hr1 = CallOnStopBinding(hr, NULL);
        }
        
        if (_pOInetBdg)
        {
            _pOInetBdg->Terminate(0);
            _pOInetBdg->Release();
            _pOInetBdg = NULL;
        }
    }

    PerfDbgLog(tagCBinding, this, "-CBinding::StartTransaction");

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::CompleteTransaction
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::CompleteTransaction()
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::CompleteTransaction",
                "this=%#x",
                this
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCBinding, this, "+CBinding::CompleteTransaction");

    if (_hrBindResult != NOERROR)
    {
        hr = _hrBindResult;
    }

    PerfDbgLog1(tagCBinding, this, "-CBinding::CompleteTransaction (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::OnTransNotification
//
//  Synopsis:
//
//  Arguments:  [pCTP] --
//
//  Returns:
//
//  History:    12-11-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(BOOL) CBinding::OnTransNotification(BINDSTATUS NotMsg, DWORD dwCurrentSize, DWORD dwTotalSize,
                                                  LPWSTR pwzStr, HRESULT hrINet)
{
    DEBUG_ENTER((DBG_BINDING,
                Bool,
                "CBinding::OnTransNotification",
                "this=%#x, %#x, %#x, %#x, %.80wq, %#x",
                this, NotMsg, dwCurrentSize, dwTotalSize, pwzStr, hrINet
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::OnTransNotification");
    BOOL fRelease = FALSE;
    HRESULT hr = NOERROR;
    UrlMkAssert((_dwThreadId));

    if (   (   (_dwThreadId == GetCurrentThreadId())
            || (_grfBINDF & BINDF_FREE_THREADED))
        && (_grfInternalFlags & BDGFLAGS_NOTIFICATIONS)
        && (_pBSCB != NULL))
    {
        switch (NotMsg)
        {
        case BINDSTATUS_PROTOCOLCLASSID:
            UrlMkAssert((pwzStr));
            CLSIDFromString(pwzStr, &_clsidProtocol);
            break;

        case BINDSTATUS_MIMETYPEAVAILABLE:
            UrlMkAssert((pwzStr));
            _pCTransData->SetMimeType(pwzStr);
            CallOnProgress(0,0,BINDSTATUS_MIMETYPEAVAILABLE, pwzStr);
            break;

        case BINDSTATUS_CLASSIDAVAILABLE:
            UrlMkAssert((pwzStr));
            CLSIDFromString(pwzStr, &_clsidIn);
            break;

        case BINDSTATUS_IUNKNOWNAVAILABLE:
            if( _fBindToObject )
            {
                IUnknown                  *pUnk = NULL;

                _fClsidFromProt = TRUE;

                // the object should be instantiated now
                if (SUCCEEDED(hr))
                {
                    hr = _pBndCtx->GetObjectParam(SZ_IUNKNOWN_PTR, &pUnk);
                }

                if (SUCCEEDED(hr))
                {
                    // The following four lines of code are a fix for bug#89397.
                    // There are only a couple of clients who are already using
                    // this notification, so we can ensure this state change doesn't
                    // affect their protocols.
                    OperationState opSt = GetOperationState();
                    if (opSt >= OPS_StartBinding && opSt < OPS_Downloading) 
                    {
                        SetOperationState(OPS_Downloading);
                    }

                    hr = CallOnObjectAvailable(*_piidRes, pUnk);
                    pUnk->Release();
                }

                if (hr != NOERROR)
                {
                    SetInstantiateHresult(hr);
                }

                // return the download result in case if no error
                if (hr == NOERROR || GetHResult() != NOERROR)
                {
                    hr = GetHResult();
                }

                _hrBindResult = hr;
                hr = CallOnStopBinding(hr, NULL);
                fRelease = TRUE;
            }
            break;

        case BINDSTATUS_CLSIDCANINSTANTIATE:
            if(IsEqualGUID(_clsidIn, CLSID_NULL) && pwzStr)
            {
                CLSIDFromString(pwzStr, &_clsidIn);
            }
           
            if( _fBindToObject )
            {
                _fClsidFromProt = TRUE;

                // the object should be instantiated now
                hr = OnObjectAvailable(0,dwCurrentSize,dwTotalSize,TRUE);
                if (hr != NOERROR)
                {
                    SetInstantiateHresult(hr);
                }

                // return the download result in case if no error
                if (hr == NOERROR || GetHResult() != NOERROR)
                {
                    hr = GetHResult();
                }

                _hrBindResult = hr;
                hr = CallOnStopBinding(hr, NULL);
                fRelease = TRUE;
            }
            break;


        case BINDSTATUS_PROXYDETECTING :
            // indicate resolving proxyserver
            if (hrINet == NOERROR)
            {
                hr = CallOnProgress(0,0,BINDSTATUS_PROXYDETECTING,NULL );                
            }
            break;

        case BINDSTATUS_CACHEFILENAMEAVAILABLE :
            UrlMkAssert((pwzStr));
            _pCTransData->SetFileName(pwzStr);
            break;

        case BINDSTATUS_FINDINGRESOURCE   :
            // indicate resolving name - pass on server/proxy name
            if (hrINet == NOERROR)
            {
                hr = CallOnProgress(0,0,BINDSTATUS_FINDINGRESOURCE,pwzStr );
                PerfDbgLog1(tagCBinding, this, "OnTransNotification done on OnProgress _pBSCP(%lx)", _pBSCB);
            }
            break;

        case BINDSTATUS_SENDINGREQUEST  :
            // indicate resolving name - pass on server/proxy name
            if (hrINet == NOERROR)
            {
                hr = CallOnProgress(0,0,BINDSTATUS_SENDINGREQUEST,pwzStr );
                PerfDbgLog1(tagCBinding, this, "OnTransNotification done on OnProgress _pBSCP(%lx)", _pBSCB);
            }
            break;


        case BINDSTATUS_CONNECTING      :
            // inidicate progress connecting - pass on address
            if (hrINet == NOERROR)
            {
                hr = CallOnProgress(0,0,BINDSTATUS_CONNECTING, pwzStr);
                PerfDbgLog1(tagCBinding, this, "OnTransNotification done on OnProgress _pBSCP(%lx)", _pBSCB);
            }
            break;

        case BINDSTATUS_REDIRECTING     :
            if (hrINet == NOERROR)
            {
                TransAssert((pwzStr));
                PerfDbgLog1(tagCBinding, this, "OnTransNotification calling OnProgress _pBSCP(%lx)", _pBSCB);
                hr = CallOnProgress(
                            dwCurrentSize,   // ulProgress
                            dwTotalSize,     // ulProgressMax
                            BINDSTATUS_REDIRECTING,
                            pwzStr                  // new url
                            );

                PerfDbgLog1(tagCBinding, this, "OnTransNotification done on OnProgress _pBSCP(%lx)", _pBSCB);

                TransAssert((_lpwszUrl));

                {
                    DWORD dwLenOld = wcslen(_lpwszUrl);
                    DWORD dwLenNew = wcslen(pwzStr);
                    if (dwLenOld < dwLenNew)
                    {
                        delete _lpwszUrl;
                        _lpwszUrl = (LPWSTR) new WCHAR [dwLenNew + 1];

                    }
                    if (_lpwszUrl && pwzStr)
                    {
                        wcscpy(_lpwszUrl, pwzStr);
                    }
                }
                _pCTransData->SetRedirectUrl(pwzStr);
            }
            break;

        case BINDSTATUS_ENDDOWNLOADDATA:
            PerfDbgLog(tagCBinding, this, "CBinding::OnTransNotification Notify_Done");
            // more work here for data notification
            //UrlMkAssert((errCode == INLERR_OK && "Notify_Done with Error"));

            if (hrINet == NOERROR)
            {
                PerfDbgLog1(tagCBinding, this, "OnTransNotification calling OnProgress _pBSCP(%lx)", _pBSCB);

                if (!_fSentFirstNotification)
                {
                    hr = CallOnProgress(dwCurrentSize, dwTotalSize,
                                        BINDSTATUS_BEGINDOWNLOADDATA, _lpwszUrl);

                    LPCWSTR pwzFilename = _pCTransData->GetFileName();

                    // a filename is not always available
                    if (pwzFilename)
                    {
                        hr = CallOnProgress(dwCurrentSize, dwTotalSize,
                                            BINDSTATUS_CACHEFILENAMEAVAILABLE, pwzFilename);
                    }
                }

                hr = CallOnProgress(dwCurrentSize,dwTotalSize,
                                        BINDSTATUS_ENDDOWNLOADDATA,_lpwszUrl);

                PerfDbgLog1(tagCBinding, this, "OnTransNotification done on OnProgress _pBSCP(%lx)", _pBSCB);

                // In some cases (e.g. data is in cache or progress notifications
                // are disbled) we may not get progress notifications
                // We might directly get the DONE notitification

                // In anycase we do not want to send data notification if it is a
                if (!_fBindToObject)
                {
                    hr = OnDataNotification(0,dwCurrentSize,dwTotalSize, TRUE);
                }
                else
                {
                    // the object should be instanciate now
                    hr = OnObjectAvailable(0,dwCurrentSize,dwTotalSize,TRUE);
                    if (hr != NOERROR)
                    {
                        SetInstantiateHresult(hr);
                    }
                }
            }

            if (_fBTS_BTO)
            {
                //special Trident BTS->BTO scenario.
                //Trident needs to get back the INET_E_TERMINATED_BIND error message to
                //realize we understand this is where we don't double-bind
                hr = INET_E_TERMINATED_BIND;
            }
            // return the download result in case if no error
            else if (hr == NOERROR || GetHResult() != NOERROR)
            {
                hr = GetHResult();
            }

            PerfDbgLog2(tagCBinding, this, "OnTransNotification calling OnStopBinding _pBSCP(%lx) HR:%lx", _pBSCB, hr);

            _hrBindResult = hr;
            hr = CallOnStopBinding(hr, NULL);
            fRelease = TRUE;

            PerfDbgLog1(tagCBinding, this, "OnTransNotification done on OnStopBinding _pBSCP(%lx)", _pBSCB);
            break;

        case BINDSTATUS_BEGINDOWNLOADDATA:
        case BINDSTATUS_DOWNLOADINGDATA:


            PerfDbgLog(tagCBinding, this, "CBinding::OnTransNotification Notify_Update");

            // Call OnProgress once if data are from cache
            if (!_fSentFirstNotification)
            {
                if (_pCTransData->IsFromCache())
                {
                    hr = CallOnProgress(0,0,BINDSTATUS_USINGCACHEDCOPY, NULL);
                }
            }

            hr = CallOnProgress(dwCurrentSize, dwTotalSize,
                        (!_fSentFirstNotification) ? BINDSTATUS_BEGINDOWNLOADDATA : BINDSTATUS_DOWNLOADINGDATA,
                        _lpwszUrl);

            if (!_fSentFirstNotification)
            {
                LPCWSTR pwzFilename = _pCTransData->GetFileName();

                // a filename is not always available
                if (pwzFilename)
                {
                    hr = CallOnProgress(dwCurrentSize, dwTotalSize,
                                        BINDSTATUS_CACHEFILENAMEAVAILABLE, pwzFilename);
                }
            }


            PerfDbgLog1(tagCBinding, this, "OnTransNotification done on OnProgress _pBSCP(%lx)", _pBSCB);

            if (!_fBindToObject)
            {
                OnDataNotification(0,dwCurrentSize,dwTotalSize, FALSE);

                if (_fBTS_BTO)
                {
                    //special Trident BTS->BTO scenario.
                    //Trident needs to get back the INET_E_TERMINATED_BIND error message to
                    //realize we understand this is where we don't double-bind
                    
                    _hrBindResult = INET_E_TERMINATED_BIND;
                    hr = CallOnStopBinding(INET_E_TERMINATED_BIND, NULL);
                    fRelease = TRUE;
                }
            }
            else
            {

                // 
                // here is the hack for ms-its:
                // if they are sending dwCurrent==dwTotal, we need to flip
                // the FALSE to TRUE in order to make word/excel doc host
                // working under IE5 (IE5 #71203)
                //
                BOOL fFullData = FALSE;
                if( dwCurrentSize == dwTotalSize &&
                    dwCurrentSize &&
                    _lpwszUrl &&
                    wcslen(_lpwszUrl) > 7 &&
                    !StrCmpNIW(_lpwszUrl, L"ms-its:", 7) )
                {
                    fFullData = TRUE;
                }


                // check here if the object can be create already
                //hr = OnObjectAvailable(pCTP, FALSE);
                hr = OnObjectAvailable(0,dwCurrentSize,dwTotalSize, fFullData);

                // mark the transobject for completion
                if (hr == S_OK)
                {
                    hr = CallOnStopBinding(NOERROR, NULL);
                    fRelease = TRUE;
                }
                else if ((hr != S_OK ) && (hr != S_FALSE))
                {
                    _hrBindResult = hr;
                    hr = CallOnStopBinding(hr, NULL);
                    fRelease = TRUE;
                }

            }
            break;

        case BINDSTATUS_ERROR:

            PerfDbgLog2(tagCBinding, this, "CBinding::OnTransNotification Notify_Error[hr%lx, dwResutl;%lx]", _hrBindResult, _dwBindError);

            // call StopBinding witht error code
            UrlMkAssert(( (_hrBindResult != NOERROR) && (_dwBindError != 0) ));
            hr = CallOnStopBinding(_hrBindResult, NULL);
            fRelease = TRUE;
            break;

        case BINDSTATUS_RESULT:
            PerfDbgLog2(tagCBinding, this, "CBinding::OnTransNotification Notify_Error[hr%lx, dwResutl;%lx]", _hrBindResult, _dwBindError);
            if( _hrBindResult == INET_E_REDIRECT_TO_DIR )
            {
                hr = CallOnStopBinding(_hrBindResult, _pwzResult);
            }
            else
            {
                hr = CallOnStopBinding(_hrBindResult, NULL);
            }
            fRelease = TRUE;
            break;

        case BINDSTATUS_DECODING:
            hr = CallOnProgress(0,0,BINDSTATUS_DECODING,pwzStr );
            break;
            
        case BINDSTATUS_LOADINGMIMEHANDLER:
            hr = CallOnProgress(0,0,BINDSTATUS_LOADINGMIMEHANDLER,pwzStr);
            break;

        case BINDSTATUS_INTERNAL:
        case BINDSTATUS_INTERNALASYNC:
            break;

        case BINDSTATUS_CONTENTDISPOSITIONATTACH:
            _fForceBindToObjFail = TRUE;
            hr = CallOnProgress(0,0,BINDSTATUS_CONTENTDISPOSITIONATTACH, pwzStr);
            break;

        case BINDSTATUS_ACCEPTRANGES:
            _fAcceptRanges= TRUE;
            break;

        case BINDSTATUS_COOKIE_SENT:
        case BINDSTATUS_COMPACT_POLICY_RECEIVED:
        case BINDSTATUS_COOKIE_SUPPRESSED:
        case BINDSTATUS_COOKIE_STATE_UNKNOWN:
        case BINDSTATUS_COOKIE_STATE_ACCEPT:
        case BINDSTATUS_COOKIE_STATE_REJECT:
        case BINDSTATUS_COOKIE_STATE_LEASH:
        case BINDSTATUS_COOKIE_STATE_DOWNGRADE:
        case BINDSTATUS_COOKIE_STATE_PROMPT:
        case BINDSTATUS_POLICY_HREF:
        case BINDSTATUS_P3P_HEADER:
        case BINDSTATUS_SESSION_COOKIE_RECEIVED:
        case BINDSTATUS_PERSISTENT_COOKIE_RECEIVED:
        case BINDSTATUS_SESSION_COOKIES_ALLOWED:
            hr = CallOnProgress(0,0,NotMsg, pwzStr);
            break;
            
        default:
            DbgLog1(tagCBindingErr, this, "CBinding::OnTransNotification Unknown (NMsg:%lx)", NotMsg);
            UrlMkAssert((FALSE));
            break;
        }
    }

    PerfDbgLog(tagCBinding, this, "-CBinding::OnTransNotification");

    DEBUG_LEAVE(fRelease);
    return fRelease;
}




//+---------------------------------------------------------------------------
//
//  Method:     CBinding::OnDataNotification
//
//  Synopsis:
//
//  Arguments:  [pCTP] --
//              [fLastNotification] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::OnDataNotification(DWORD grfBSCF, DWORD dwCurrentSize, DWORD dwTotalSize, BOOL fLastNotification)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::OnDataNotification",
                "this=%#x, %#x, %#x, %#x, %B",
                this, grfBSCF, dwCurrentSize, dwTotalSize, fLastNotification
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog3(tagCBinding, this, "+CBinding::OnDataNotification (dwLastSize:%ld, dwCurrentSize:%ld, dwTotalSize:%ld)",
        _dwLastSize, dwCurrentSize, dwTotalSize);
    STGMEDIUM *pStgMed = 0;
    FORMATETC *pFmtETC = 0;

    // We shouldn't have less data than last time
    #if 0
    UrlMkAssert((   (dwTotalSize == 0)
                 || (dwTotalSize != 0 && dwCurrentSize > _dwLastSize)
                 || (dwTotalSize == dwCurrentSize && dwCurrentSize == _dwLastSize)
                 ));
    #endif // 0
    
    // must be BindToStorage scenario
    UrlMkAssert((!_fBindToObject));
    // should never end up here after the last data notification
    //UrlMkAssert((!_fSentLastNotification));

    if (   ((dwCurrentSize > 0) || fLastNotification)
        && (!_fSentLastNotification))
    {
        grfBSCF = 0;


        // Check if this will be the first data notification
        if (!_fSentFirstNotification)
        {
            grfBSCF |= BSCF_FIRSTDATANOTIFICATION;
            _fSentFirstNotification = TRUE;
        }

        if (fLastNotification)
        {
            // Check if this will be the last data notification
            grfBSCF |= BSCF_LASTDATANOTIFICATION;
            _fSentLastNotification = TRUE;
        }
        // all other notifications are intermediate
        if (grfBSCF == 0)
        {
            grfBSCF |= BSCF_INTERMEDIATEDATANOTIFICATION;
        }

        // get the stgmed for this
        if (_fCreateStgMed == FALSE)
        {
            hr = _pCTransData->GetData(&pFmtETC, &pStgMed, grfBSCF);
            if (hr == S_OK)
            {
            	// BUGBUG: Looks like _fCreateStgMed is always going to be false. 
            	// Either the following line can be de-commented out
            	// or _fCreateStgMed can be eliminated:
                //_fCreateStgMed = TRUE;
                TransAssert((pStgMed));

		        //
		        // hold on to the stream or storage
		        //
		        if ( (_pUnkObject == NULL)
		            && (   pStgMed->tymed == TYMED_ISTREAM
		                || pStgMed->tymed == TYMED_ISTORAGE))
		        {
		            _pUnkObject = pStgMed->pstm;
		            _pUnkObject->AddRef();
		        }
            }
        }

        if ( hr == S_OK && fLastNotification )
        {
            _pCTransData->OnEndofData();
        }

        if (hr == S_OK)
        {
            PerfDbgLog5(tagCBinding, this,
                    ">>> %lx::OnDataNotification (Options:%ld,Size:%ld,FmtEtc:%lx,StgMed:%lx)",
                    _pBSCB, grfBSCF, dwCurrentSize, pFmtETC, pStgMed);

            UrlMkAssert((grfBSCF != 0));

            hr = CallOnDataAvailable(grfBSCF, dwCurrentSize, pFmtETC, pStgMed);

            if (pStgMed)
            {
                DEBUG_ENTER((DBG_BINDING,
                            None,
                            "EXTERNAL::ReleaseStgMedium",
                            "%#x",
                            pStgMed
                            ));

               ReleaseStgMedium(pStgMed);

               DEBUG_LEAVE(0);

               //NOTES:  if tymed was TYMED_FILE, lpszFilename ZEROED out,
               // else   if tymed == TYMED_STREAM, pstm NOT ZEROED out.
               //   We DEPEND on this behavior in CTransDat::GetData()
               //
               // Ideally, we should just do this-> 
               // memset( pStgMed, 0, sizeof(STGMEDIUM) );
               // and save state in the transDat object.
            }
        }
     }

    _dwLastSize = dwCurrentSize;

    PerfDbgLog2(tagCBinding, this, "-CBinding::OnDataNotification (hr:%lx, dwLastSize:%ld)", hr, _dwLastSize);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::OnObjectAvailable
//
//  Synopsis:
//
//  Arguments:  [pCTP] --
//              [fLastNotification] --
//
//  Returns:
//
//  History:    12-22-95   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::OnObjectAvailable(DWORD grfBSCF, DWORD dwCurrentSize, DWORD dwTotalSize, BOOL fLastNotification)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::OnObjectAvailable",
                "this=%#x, %#x, %#x, %#x, %B",
                this, grfBSCF, dwCurrentSize, dwTotalSize, fLastNotification
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog3(tagCBinding, this, "+CBinding::OnObjectAvailable (dwCurrentSize:%ld, dwTotalSize:%ld, LastNotification:%d)",
                                    dwCurrentSize, dwTotalSize, fLastNotification);
    CLSID clsid = CLSID_NULL;

    // We shouldn't have less data than last time
    UrlMkAssert((   (dwTotalSize == 0)
                 || (dwTotalSize != 0 && dwCurrentSize != 0)
                 ));

    // must be BindToObject scenario
    UrlMkAssert((_fBindToObject));

    if (!fLastNotification && !_fSentFirstNotification)
    {
        // check if we've instantiated the object yet
        if (_pUnkObject == NULL)
        {
            hr = _pCTransData->GetClassID(_clsidIn, &clsid);

            if (FAILED(hr)) {

                hr = InstallIEFeature();

                if (SUCCEEDED(hr))
                    hr = _pCTransData->GetClassID(_clsidIn, &clsid);
            }

            if( _fForceBindToObjFail )
            {
                hr = REGDB_E_CLASSNOTREG;
            }
            

            if (hr == S_OK)
            {
                // instantiate the object now and call pass it on in OnDataAvailable
                hr = InstantiateObject(&clsid, *_piidRes, &_pUnkObject, FALSE);

                if (hr == S_FALSE)
                {
                    // switch to datasink file
                    _pCTransData->SwitchDataSink(DataSink_File);

                    if( _pCTransData->IsEOFOnSwitchSink() )
                    {
                        hr = ObjectPersistMnkLoad(_pUnkObject, _fLocal, TRUE);

                        if (hr != NOERROR && hr != E_ABORT)
                        {
                            hr = ObjectPersistFileLoad(_pUnkObject);
                        }
                    }
                }

                // Don't send notifications after the 'last' one.
                if ((hr == S_OK) && (_pUnkObject != NULL))
                {
                    hr = CallOnObjectAvailable(*_piidRes,_pUnkObject);

                    // release the object in case transaction is async
                    // the object is passed back via *ppvObj in sync case
                    if (IsAsyncTransaction())
                    {
                        _pUnkObject->Release();
                        _pUnkObject = NULL;
                    }

                    UrlMkAssert((SUCCEEDED(hr)));
                    hr = S_OK;
                }
                // keep the object until all data here

            }
            else if (hr == S_FALSE)
            {
                //
                // switch the datasink to file
                //
                _pCTransData->SwitchDataSink(DataSink_File);
            }
            else
            {

                hr = REGDB_E_CLASSNOTREG;
            }
        }
        else
        {
            // we got the object loaded but have to wait until all data
            // are available
            hr = S_FALSE;
        }

        if (!_fSentFirstNotification)
        {
            _fSentFirstNotification = TRUE;
        }

    }
    else if (fLastNotification)
    {
        UrlMkAssert((!_fSentLastNotification));
        DWORD grfBSCF = 0;

        // Check if this will be the first data notification

        // Check if this will be the last data notification
        if (fLastNotification)
        {
            grfBSCF |= BSCF_LASTDATANOTIFICATION;
        }

        if (_pUnkObject == NULL)
        {
            if( _fClsidFromProt && !IsEqualGUID(_clsidIn, CLSID_NULL) )
            {
                clsid = _clsidIn;
                hr = NOERROR;
            }
            else
            {
                hr = _pCTransData->GetClassID(_clsidIn, &clsid);
            }

            if (FAILED(hr)) {
                hr = InstallIEFeature();

                if (SUCCEEDED(hr))
                    hr = _pCTransData->GetClassID(_clsidIn, &clsid);
            }

            if( _fForceBindToObjFail )
            {
                hr = REGDB_E_CLASSNOTREG;
            }
            
            if (FAILED(hr))
            {
                hr = REGDB_E_CLASSNOTREG;
            }
            else
            {
                // instanciate the object now and call pass it on in OnDataAvailable
                if( _fClsidFromProt )
                {
                    hr = CreateObject(&clsid, *_piidRes, &_pUnkObject);
                }
                else
                {
                    hr = InstantiateObject(&clsid, *_piidRes, 
                                            &_pUnkObject, TRUE);
                }
            }
        }
        else
        {
            CallOnProgress( 0, 0, BINDSTATUS_BEGINSYNCOPERATION, 0 );

            hr = ObjectPersistMnkLoad(_pUnkObject,_fLocal,TRUE);
            if (hr != NOERROR && hr != E_ABORT)
            {
                // if all bits are available
                hr = ObjectPersistFileLoad(_pUnkObject);
            }

            CallOnProgress( 0, 0, BINDSTATUS_ENDSYNCOPERATION, 0 );

        }

        // Don't send notifications after the 'last' one.
        if (   SUCCEEDED(hr)
            && (_pUnkObject != NULL)
            && !_fSentLastNotification)
        {

            BOOL  bRegisteredTransactionData = FALSE;

            // Note: register the transaction object only
            // in case we are asked to transfer it to the
            // new process/thread where no new download
            // should be started
            if (_grfBINDF & BINDF_COMPLETEDOWNLOAD)
            {
                hr = _pBndCtx->RegisterObjectParam(SZ_TRANSACTIONDATA, (ITransactionData *)_pCTransData);
                if (SUCCEEDED(hr))
                {
                    bRegisteredTransactionData = TRUE;
                }

                PerfDbgLog2(tagCBinding, this, "=== CBinding::OnObjectAvailable RegisterObjectParam SZ_TRANSACTIONDATA: pbndctx:%lx, hr:%lx)", _pBndCtx, hr);
            }

            TransAssert((hr == NOERROR));

            hr = CallOnObjectAvailable(*_piidRes,_pUnkObject);

            if (bRegisteredTransactionData)
            {
                _pBndCtx->RevokeObjectParam(SZ_TRANSACTIONDATA);
            }

            // release the object
            if (IsAsyncTransaction())
            {
                _pUnkObject->Release();
                _pUnkObject = NULL;
            }

            UrlMkAssert((SUCCEEDED(hr)));
        }
        else
        {
            // why did it fail
        }

        if (grfBSCF & BSCF_LASTDATANOTIFICATION)
        {
            _fSentLastNotification = TRUE;
        }
    }
    else
    {
        hr = S_FALSE;
    }

    _dwLastSize = dwCurrentSize;
    PerfDbgLog1(tagCBinding, this, "-CBinding::OnObjectAvailable (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::InstallIEFeature
//
//  Synopsis:
//              called when you can't by comventional registry lookup means
//              find a clsid for a given mime type
//              This code then checks to see if this is an IE feature
//              and if so installs it by calling the IE JIT API.
//
//  Arguments: 
//
//  Returns:
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::InstallIEFeature()
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::InstallIEFeature",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::InstallIEFeature");
    HRESULT     hr  = INET_E_CANNOT_INSTANTIATE_OBJECT;
    uCLSSPEC classpec;
    IWindowForBindingUI *pWindowForBindingUI = NULL;
    HWND hWnd = NULL;
    REFGUID rguidReason = IID_ICodeInstall;
    LPCWSTR pwszMimeType = _pCTransData->GetMimeType();
    DWORD dwJITFlags;

    // BUGBUG: Cannot extern vwzApplicationCDF from datasnif.cxx
    // For some reason, vwzApplicationCDF contains bogus data in some scenarios!
    static WCHAR vwzAppCDF[] = L"application/x-cdf";

    if (!pwszMimeType) {
        DEBUG_LEAVE(hr);
        return hr;
    }

    if (SUCCEEDED(IsMimeHandled(pwszMimeType))) {
        
        // if the mime has been handled by an EXE out of proc
        // then fail to instantiate the obj. shdocvw will call 
        // shellexecute on this url which will succeed.
        // we assume here that we enter InstallIEfeature only
        // after a conversion MimeToClsid has failed!

        hr  = INET_E_CANNOT_INSTANTIATE_OBJECT;

        DEBUG_LEAVE(hr);
        return hr;
    }

    CallOnProgress( 0, 0, BINDSTATUS_BEGINSYNCOPERATION, 0 );

    // Get IWindowForBindingUI ptr
    hr = _pBSCB->QueryInterface(IID_IWindowForBindingUI,
            (LPVOID *)&pWindowForBindingUI);

    if (FAILED(hr)) {
        IServiceProvider *pServProv;
        hr = _pBSCB->QueryInterface(IID_IServiceProvider,
            (LPVOID *)&pServProv);

        if (hr == NOERROR) {
            pServProv->QueryService(IID_IWindowForBindingUI,IID_IWindowForBindingUI,
                (LPVOID *)&pWindowForBindingUI);
            pServProv->Release();
        }
    }

    hr = INET_E_CANNOT_INSTANTIATE_OBJECT; // init to fail

    // get hWnd
    if (pWindowForBindingUI) {
        pWindowForBindingUI->GetWindow(rguidReason, &hWnd);
        pWindowForBindingUI->Release();

        QUERYCONTEXT qc;

        memset(&qc, 0, sizeof(qc));

        // fill in the minimum version number of the component you need
        //qc.dwVersionHi = 
        //qc.dwVersionLo = 


        classpec.tyspec=TYSPEC_MIMETYPE;
        classpec.tagged_union.pMimeType=(LPWSTR)pwszMimeType;

        if (pwszMimeType) {
            dwJITFlags = (!StrCmpIW(pwszMimeType, vwzAppCDF)) ?
                         (FIEF_FLAG_FORCE_JITUI) : (0);
        }
        else {
            dwJITFlags = 0;
        }

        hr = FaultInIEFeature(hWnd, &classpec, &qc, dwJITFlags);

    }

    CallOnProgress( 0, 0, BINDSTATUS_ENDSYNCOPERATION, 0 );

    PerfDbgLog1(tagCBinding, this, "-CBinding::InstallIEFeature (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBinding::InstantiateObject
//
//  Synopsis:
//
//  Arguments:  [pclsid] --
//              [riidResult] --
//              [ppUnk] --
//
//  Returns:
//
//  History:    1-12-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::InstantiateObject(CLSID *pclsid, REFIID riidResult, IUnknown **ppUnk,BOOL fFullyAvailable)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::InstantiateObject",
                "this=%#x, %#x, %#x, %#x, %B",
                this, pclsid, &riidResult, ppUnk, fFullyAvailable
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::InstantiateObject");
    HRESULT     hr;
    IUnknown    *pUnk = NULL;
    LPOLESTR    pszStr = NULL;
    BOOL        fLocal = FALSE;

    //call OnProgress with CLASSID_AVAILABLE
    hr = StringFromCLSID(*pclsid, &pszStr);
    if (hr == NOERROR)
    {
        PerfDbgLog1(tagCBinding, this, "CBinding::InstantiateObject (Class ID:%ws)", pszStr);
        hr = CallOnProgress( 0, 0, BINDSTATUS_CLASSIDAVAILABLE, pszStr );
        if(hr == E_ABORT)
            SetOperationState(OPS_Abort);
        else
            UrlMkAssert((hr == NOERROR));
    }

    if (GetOperationState() == OPS_Abort)
    {
        // stop now - the client aborted the operation
        hr = E_ABORT;
    }
    else
    {

        DumpIID(riidResult);


        CallOnProgress( 0, 0, BINDSTATUS_BEGINSYNCOPERATION, 0 );

        //  If CLSID_MsHtml object had to be created to honor scripting access
        //  before OnObjectAvailable, BINDSTATUS_CLASSIDAVAILABLE OnProgress
        //  message is signal to register such an object in bind context

        hr = _pBndCtx->GetObjectParam(L"__PrecreatedObject", &pUnk);
        if (FAILED(hr))
        {
            // call OleAutoConvert
            {
                CLSID clsidIn = *pclsid;
                CLSID clsidOut;
                hr = OleGetAutoConvert(clsidIn, &clsidOut);
                if (hr == S_OK)
                {
                    *pclsid = clsidOut;
                }
            }

            if (_grfBINDF & BINDF_GETCLASSOBJECT)
            {
                // Just want the class object
                
                DEBUG_ENTER((DBG_BINDING,
                            Hresult,
                            "EXTERNAL::CoGetClassObject",
                            "%#x, CLSCTX_INPROC_SERVER, NULL, %#x, %#x",
                            pclsid, &riidResult, &pUnk
                            ));

                hr = CoGetClassObject(*pclsid, CLSCTX_INPROC_SERVER,
                                      NULL, riidResult, (void **)&pUnk);

                DEBUG_LEAVE(hr);
                
                if (FAILED(hr))
                {
                    DEBUG_ENTER((DBG_BINDING,
                                Hresult,
                                "EXTERNAL::CoGetClassObject",
                                "%#x, CLSCTX_LOCAL_SERVER, NULL, %#x, %#x",
                                pclsid, &riidResult, &pUnk
                                ));

                    hr = CoGetClassObject(
                            *pclsid, CLSCTX_LOCAL_SERVER,
                            NULL, riidResult, (void **)&pUnk);

                    DEBUG_LEAVE(hr);
                    
                    if (FAILED(hr))
                    {
                        DEBUG_ENTER((DBG_BINDING,
                                    Hresult,
                                    "EXTERNAL::CoGetClassObject",
                                    "%#x, CLSCTX_INPROC_HANDLER, NULL, %#x, %#x",
                                    pclsid, &riidResult, &pUnk
                                    ));

                        hr = CoGetClassObject(
                            *pclsid, CLSCTX_INPROC_HANDLER,
                            NULL, riidResult, (void **)&pUnk);

                        DEBUG_LEAVE(hr);
                    }
                }
            }
            else
            {
                DEBUG_ENTER((DBG_BINDING,
                            Hresult,
                            "EXTERNAL::CoCreateInstance",
                            "%#x, CLSCTX_INPROC_SERVER, NULL, %#x, %#x",
                            pclsid, &riidResult, &pUnk
                            ));

                hr = CoCreateInstance(*pclsid, NULL, CLSCTX_INPROC_SERVER,
                                    riidResult, (void**)&pUnk);

                DEBUG_LEAVE(hr);
                
                if (FAILED(hr))
                {
                    DbgLog1(tagCBindingErr, this, "=== CBinding::InstantiateObject InProcServer (hr:%lx)", hr);
                    
                    DEBUG_ENTER((DBG_BINDING,
                                Hresult,
                                "EXTERNAL::CoCreateInstance",
                                "%#x, CLSCTX_LOCAL_SERVER, NULL, %#x, %#x",
                                pclsid, &riidResult, &pUnk
                                ));
                                
                    hr = CoCreateInstance(*pclsid, NULL, CLSCTX_LOCAL_SERVER,
                                        riidResult, (void**)&pUnk);

                    DEBUG_LEAVE(hr);
                    
                    _fLocal = fLocal = TRUE;

                    if (FAILED(hr))
                    {
                        DumpIID(*pclsid);
                        DbgLog1(tagCBindingErr, this, "=== CBinding::InstantiateObject LocalServer (hr:%lx)", hr);

                        DEBUG_ENTER((DBG_BINDING,
                                    Hresult,
                                    "EXTERNAL::CoCreateInstance",
                                    "%#x, CLSCTX_INPROC_HANDLER, NULL, %#x, %#x",
                                    pclsid, &riidResult, &pUnk
                                    ));

                        hr = CoCreateInstance(*pclsid, NULL, CLSCTX_INPROC_HANDLER, riidResult, (void**)&pUnk);

                        DEBUG_LEAVE(hr);
                        
                        _fLocal = fLocal = FALSE;
                        if( FAILED(hr))
                        {
                            DbgLog1(tagCBindingErr, this, "=== CBinding::InstantiateObject InProcHandler (hr:%lx)", hr);
                        }
                    }
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            *ppUnk = pUnk;

            if (   _grfBINDF & BINDF_COMPLETEDOWNLOAD
                && IsEqualGUID(*pclsid, CLSID_MsHtml)
                && fFullyAvailable == FALSE)
            {
                hr = S_FALSE;
            }
            else
            {

                // S_FALSE means try later when all data are available
                hr = ObjectPersistMnkLoad(pUnk,_fLocal,fFullyAvailable, pclsid);

                if (hr == E_NOINTERFACE)
                {
                    if (fFullyAvailable)
                    {
                        hr = ObjectPersistFileLoad(_pUnkObject);
                    }
                    else
                    {
                        // call PersistFile::Load later
                        hr = S_FALSE;
                    }
                }
                else if (hr == S_FALSE)
                {
                    // lock the request
                    _pOInetBdg->LockRequest(0);
                    _fCompleteDownloadHere = TRUE;
                }
                else if (hr != NOERROR && hr != E_ABORT)
                {
                    //
                    // your last chance of being loaded...
                    // this was not needed for IE4 since wininet
                    // ALWAYS return async, start from IE5, wininet
                    // will return SYNC if the file is in cache
                    //
                    if (fFullyAvailable)
                    {
                        HRESULT hr2 = ObjectPersistFileLoad(_pUnkObject);
                        if( hr2 == NOERROR )
                        {
                            // if we succeeded here, needs to return NOERROR
                            hr = hr2;
                        }
                    }
                }
                // else pass back error
            }
        }
        else
        {
            SetInstantiateHresult(hr);
            hr = INET_E_CANNOT_INSTANTIATE_OBJECT;

        }
        CallOnProgress( 0, 0, BINDSTATUS_ENDSYNCOPERATION, 0 );
    }

    if (pszStr)
    {
        delete pszStr;
    }
    PerfDbgLog1(tagCBinding, this, "-CBinding::InstantiateObject (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::ObjectPersistMnkLoad
//
//  Synopsis:
//
//  Arguments:  [pUnk] --
//
//  Returns:
//
//  History:    2-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::ObjectPersistMnkLoad(IUnknown *pUnk, BOOL fLocal, BOOL fFullyAvailable, CLSID *pclsid)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::ObjectPersistMnkLoad",
                "this=%#x, %#x, %B, %B",
                this, pUnk, fLocal, fFullyAvailable
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::ObjectPersistMnkLoad");
    HRESULT          hr;
    IPersistMoniker *pPersistMk = NULL;
    BIND_OPTS        bindopts;
    BOOL             bRegisteredTransactionData = FALSE;

    if (_grfBINDF & BINDF_GETCLASSOBJECT)
    {
        // GetClassObj, which means there is no need to PersistMnkLoad
        PerfDbgLog(tagCBinding, this, " ObjectPersistMnkLoad : GETCLASSOBJ");
        hr = NOERROR;
        goto exit;
    }

    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "EXTERNAL::IUnknown::QueryInterface",
                "this=%#x, IID_IPersistMoniker, %#x",
                pUnk, &pPersistMk
                ));
                            
    hr = pUnk->QueryInterface(IID_IPersistMoniker, (void**)&pPersistMk);

    DEBUG_LEAVE(hr);
    
    if (hr == NOERROR)
    {
        TransAssert((pPersistMk != NULL));
        if (!fLocal)
        {
            hr = _pBndCtx->RegisterObjectParam(SZ_BINDING, (IBinding *)this);
        }

        IUnknown *pUnk = 0;

        // remove the current bindstatuscallback
        hr = _pBndCtx->GetObjectParam(REG_BSCB_HOLDER, &pUnk);
        TransAssert((hr == NOERROR));

        hr = _pBndCtx->RevokeObjectParam(REG_BSCB_HOLDER);
        TransAssert((hr == NOERROR));

        bindopts = _bindopts;

        TransAssert(( bindopts.grfMode & (STGM_READWRITE | STGM_SHARE_EXCLUSIVE) ));

        if ( !(bindopts.grfMode & (STGM_READWRITE | STGM_SHARE_EXCLUSIVE)) )
        {
            bindopts.grfMode |= (STGM_READWRITE | STGM_SHARE_EXCLUSIVE);
        }

        // Note:
        // switch of flag do not receive notifications on this cbinding
        // BindToStorage synchronous might be called
        _grfInternalFlags &= ~BDGFLAGS_NOTIFICATIONS;

        if ( (fFullyAvailable)
             && ( ( !(_grfBINDF & BINDF_COMPLETEDOWNLOAD)
                    && _fCompleteDownloadHere )
                  ||
                  (_fLocal) 
                )
           )
        {
            _grfBINDF |= BINDF_COMPLETEDOWNLOAD;
            hr = _pBndCtx->RegisterObjectParam(SZ_TRANSACTIONDATA, (ITransactionData *)_pCTransData);
            if (SUCCEEDED(hr))
            {
                bRegisteredTransactionData = TRUE;
            }
            PerfDbgLog2(tagCBinding, this, "=== CBinding::OnObjectAvailable RegisterObjectParam SZ_TRANSACTIONDATA: pbndctx:%lx, hr:%lx)", _pBndCtx, hr);

            // swtich the _ds back to StreamOnFile so that the BindToStorage
            // can get the IStream from pbc (inproc server only)
            if( !_fLocal )
            {
                _pCTransData->SetFileAsStmFile();
            } 
        }

        LPCWSTR pwszMimeType = _pCTransData->GetMimeType();
         
        // Now, we try to shove the mimetype down the throat of pPersistMk
        IMonikerProp *pmkp = NULL;

        DEBUG_ENTER((DBG_BINDING,
                    Hresult,
                    "EXTERNAL::IUnknown::QueryInterface",
                    "this=%#x, IID_IMonikerProp, %#x (mimetype = %.80wq)",
                    pPersistMk, &pmkp, pwszMimeType
                    ));

        if (SUCCEEDED(pPersistMk->QueryInterface(IID_IMonikerProp, (void **)&pmkp)))
        {
            DEBUG_LEAVE(NOERROR);
            
            pmkp->PutProperty(MIMETYPEPROP, pwszMimeType);
        }
        else 
            DEBUG_LEAVE(E_FAIL);
        
        if( !fFullyAvailable    && 
            pwszMimeType        &&
            !StrCmpNIW( pwszMimeType, L"application/pdf", 15) )
        {
            // let's find out we are dealing with Acrobat 3.02 and above
            if( _fAcceptRanges && PDFNeedProgressiveDownload() )
            {
                if(pmkp)
                {
                    pmkp->PutProperty(USE_SRC_URL, L"1");
                }
                // this is 3.02 and above, go ahead call PMK::Load
                hr = pPersistMk->Load(
                    fFullyAvailable, GetMoniker(), _pBndCtx, bindopts.grfMode);
                
            }
            else
            {
                //
                // this is 3.0 and 3.01, 
                // or we are dealing with server does not support Range
                // don't call PMK::Load until fully available 
                //
                hr = S_FALSE;
            }
        }
        else
        {

            if( pclsid &&
                  !fFullyAvailable &&
                  IsEqualGUID(*pclsid, CLSID_PluginHost))
            {
                hr = S_FALSE;
            }
            else
            {
                DEBUG_ENTER((DBG_BINDING,
                            Hresult,
                            "EXTERNAL::IPersistMoniker::Load",
                            "this=%#x, %B, %#x, %#x, %#x",
                            pPersistMk, fFullyAvailable, GetMoniker(), _pBndCtx, bindopts.grfMode
                            ));

                hr = pPersistMk->Load(fFullyAvailable, GetMoniker(), _pBndCtx, bindopts.grfMode);

                DEBUG_LEAVE(hr);
            }
        }

        if (bRegisteredTransactionData)
        {
            _pBndCtx->RevokeObjectParam(SZ_TRANSACTIONDATA);
        }

        if (FAILED(hr))
        {
            if (hr == E_FAIL)
            {
                hr = CO_E_SERVER_EXEC_FAILURE;
            }
        }

        // Note: OnStopBinding is still called even
        // even the download finished due sync BindToStorage
        // turn the flag back on
        _grfInternalFlags |= BDGFLAGS_NOTIFICATIONS;

        if (!fLocal)
        {
            _pBndCtx->RevokeObjectParam(SZ_BINDING);
        }

        if (pUnk)
        {
            _pBndCtx->RegisterObjectParam(REG_BSCB_HOLDER, pUnk);
            pUnk->Release();
        }

        pPersistMk->Release();
        
        if(pmkp)
            pmkp->Release();
    }

exit:
    PerfDbgLog1(tagCBinding, this, "-CBinding::ObjectPersistMnkLoad (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::ObjectPersistFileLoad
//
//  Synopsis:
//
//  Arguments:  [pUnk] --
//
//  Returns:
//
//  History:    2-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::ObjectPersistFileLoad(IUnknown *pUnk)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::ObjectPersistFileLoad",
                "this=%#x, %#x",
                this, pUnk
                ));
                
    HRESULT hr;
    PerfDbgLog1(tagCBinding, this, "+CBinding::ObjectPersistFileLoad (filename:%ws)",  GetFileName());

    IPersistFile *pPersistFile = NULL;

    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "EXTERNAL::IUnknown::QueryInterface",
                "this=%#x, IID_IPersistFile, %#x",
                pUnk, &pPersistFile
                ));

    hr = pUnk->QueryInterface(IID_IPersistFile, (void**)&pPersistFile);

    DEBUG_LEAVE(hr);
    
    if (hr == NOERROR)
    {
        DEBUG_ENTER((DBG_BINDING,
                    Hresult,
                    "EXTERNAL::IPersistFile::Load",
                    "this=%#x, %#x, %#x",
                    pPersistFile, GetFileName(), 0
                    ));
                        
        hr = pPersistFile->Load(GetFileName(), 0);

        DEBUG_LEAVE(hr);
        
        if (hr != NOERROR)
        {
            SetInstantiateHresult(hr);
            hr = INET_E_CANNOT_LOAD_DATA;
        }
        PerfDbgLog1(tagCBinding, this, "=== CBinding::ObjectPersistFileLoad (Load returned:%lx)", hr);
        pPersistFile->Release();
    }

    PerfDbgLog1(tagCBinding, this, "-CBinding::ObjectPersistFileLoad (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::CallGetBindInfo
//
//  Synopsis:
//
//  Arguments:  [grfBINDINFOF] --
//              [pBdInfo] --
//
//  Returns:
//
//  History:    2-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::CallGetBindInfo(DWORD *grfBINDINFOF, BINDINFO *pBdInfo)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::CallGetBindInfo",
                "this=%#x, %#x, %#x",
                this, grfBINDINFOF, pBdInfo
                ));
                
    HRESULT hr = E_FAIL;
    UrlMkAssert((grfBINDINFOF != NULL));
    PerfDbgLog1(tagCBinding, this, "+CBinding::CallGetBindInfo (grfBINDINFOF:%ld)", *grfBINDINFOF);

    if (GetOperationState() == OPS_Initialized)
    {
        hr = _pBSCB->GetBindInfo(grfBINDINFOF, pBdInfo);
        SetOperationState(OPS_GetBindInfo);
    }
    else
    {
        UrlMkAssert((GetOperationState() == OPS_Initialized));
    }

    if (   (*grfBINDINFOF & BINDF_ASYNCSTORAGE)
        && (*grfBINDINFOF & BINDF_PULLDATA) )
    {
        PerfDbgLog2(tagCBinding, this, "=== grfBINDINFOF:%lx, (%s)", *grfBINDINFOF, "BINDF_ASYNCSTORAGE | BINDF_PULLDATA");
    }

    PerfDbgLog2(tagCBinding, this, "-CBinding::CallGetBindInfo (grfBINDINFOF:%lx, hr:%lx)", *grfBINDINFOF, hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::CallOnStartBinding
//
//  Synopsis:
//
//  Arguments:  [grfBINDINFOF] --
//              [pib] --
//
//  Returns:
//
//  History:    2-07-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::CallOnStartBinding(DWORD grfBINDINFOF, IBinding * pib)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::CallOnStartBinding",
                "this=%#x, %#x, %#x",
                this, grfBINDINFOF, pib
                ));
                
    HRESULT hr = E_FAIL;
    PerfDbgLog1(tagCBinding, this, "+CBinding::CallOnStartBinding (grfBINDINFOF:%lx)", grfBINDINFOF);

    if (GetOperationState() == OPS_GetBindInfo)
    {
        hr = _pBSCB->OnStartBinding(NULL, this);
        SetOperationState(OPS_StartBinding);
    }
    else
    {
        UrlMkAssert((GetOperationState() == OPS_GetBindInfo));
    }


    PerfDbgLog1(tagCBinding, this, "-CBinding::CallOnStartBinding (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Method:     CBinding::CallOnProgress
//
//  Synopsis:
//
//  Arguments:  [ulProgress] --
//              [ulProgressMax] --
//              [ulStatusCode] --
//              [szStatusText] --
//
//  Returns:
//
//  History:    2-14-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::CallOnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::CallOnProgress",
                "this=%#x, %#x, %#x, %#x, %.80wq",
                this, ulProgress, ulProgressMax, ulStatusCode, szStatusText
                ));
                
    HRESULT hr = NOERROR;
    
    PerfDbgLog(tagCBinding, this, "+CBinding::CallOnProgress");

    if ( GetOperationState() == OPS_StartBinding)
    {
        SetOperationState(OPS_Downloading);
    }

    if (GetOperationState() == OPS_Downloading)
    {
        hr = _pBSCB->OnProgress(ulProgress, ulProgressMax, ulStatusCode, szStatusText);
    }

    PerfDbgLog1(tagCBinding, this, "-CBinding::CallOnProgress hr:%lx", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Method:     CBinding::CallOnStopBinding
//
//  Synopsis:
//
//  Arguments:  [LPCWSTR] --
//              [szError] --
//
//  Returns:
//
//  History:    2-14-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::CallOnStopBinding(HRESULT hrRet,LPCWSTR szError)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::CallOnStopBinding",
                "this=%#x, %#x, %.80wq",
                this, hrRet, szError
                ));
                
    HRESULT hr = E_FAIL;
    PerfDbgLog1(tagCBinding, this, "+CBinding::CallOnStopBinding ->hrRet:%lx", hrRet);

    if (   (GetOperationState() < OPS_Stopped)
        && (GetOperationState() > OPS_Initialized))
    {
        UrlMkAssert((  (hrRet != S_FALSE && hrRet != E_FAIL) ));

        if (hrRet == E_FAIL)
        {
            hrRet = INET_E_DOWNLOAD_FAILURE;
        }
        TransAssert((    ((hr == NOERROR) && _fSentLastNotification)
                      || (hr != NOERROR) ));

        //if( _fBindToObject ) 
        //    DbgLog(tagCBindingErr, this, ">>> OnStopBinding (BindToObject)");
        //else
        //    DbgLog(tagCBindingErr, this, ">>> OnStopBinding (BindToStorage)");
        hr = _pBSCB->OnStopBinding(hrRet, NULL);
        SetOperationState(OPS_Stopped);
    }
    TransAssert((_pBndCtx));

    //TRIDENT BTS->BTO
    //Save the transaction objects for BTO
    if (!_fBTS_BTO) //(hrRet != INET_E_TERMINATED_BIND)
        _pBndCtx->SetTransactionObjects(NULL,NULL);
    

    PerfDbgLog1(tagCBinding, this, "-CBinding::CallOnStopBinding (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::CallOnLowResource
//
//  Synopsis:
//
//  Arguments:  [reserved] --
//
//  Returns:
//
//  History:    2-14-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::CallOnLowResource (DWORD reserved)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::CallOnLowResource",
                "this=%#x, %#x",
                this, reserved
                ));
                
    HRESULT hr = E_FAIL;
    PerfDbgLog(tagCBinding, this, "+CBinding::CallOnLowResource");

    PerfDbgLog1(tagCBinding, this, "-CBinding::CallOnLowResource (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Method:     CBinding::CallGetPriority
//
//  Synopsis:
//
//  Arguments:  [pnPriority] --
//
//  Returns:
//
//  History:    2-14-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::CallGetPriority (LONG * pnPriority)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::CallGetPriority",
                "this=%#x, %#x",
                this, pnPriority
                ));
                
    HRESULT hr = E_FAIL;
    PerfDbgLog(tagCBinding, this, "+CBinding::CallGetPriority");

    PerfDbgLog1(tagCBinding, this, "-CBinding::CallGetPriority (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Method:     CBinding::CallOnDataAvailable
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [FORMATETC] --
//              [STGMEDIUM] --
//              [pStgMed] --
//
//  Returns:
//
//  History:    2-14-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::CallOnDataAvailable(DWORD grfBSC,DWORD dwSize,FORMATETC *pFmtETC,STGMEDIUM *pStgMed)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::CallOnDataAvailable",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, grfBSC, dwSize, pFmtETC, pStgMed
                ));
                
    HRESULT hr = E_FAIL;
    PerfDbgLog(tagCBinding, this, "+CBinding::CallOnDataAvailable");

    if (GetOperationState() == OPS_Downloading)
    { 
        //DbgLog2(tagCBindingErr, this, ">>> OnDataAvailable (BSC=%lx size=%d)",
        //        grfBSC, dwSize);
        hr = _pBSCB->OnDataAvailable(grfBSC, dwSize, pFmtETC, pStgMed);

        if (hr == INET_E_TERMINATED_BIND)
        {
            _fBTS_BTO = TRUE;
            hr = NOERROR; //restore back to value which was previous value being returned
        }
    }
    else if (GetOperationState() == OPS_Abort)
    {
        hr = E_ABORT;
    }

    PerfDbgLog1(tagCBinding, this, "-CBinding::CallOnDataAvailable (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
//+---------------------------------------------------------------------------
//
//  Method:     CBinding::CallOnObjectAvailable
//
//  Synopsis:
//
//  Arguments:  [IUnknown] --
//              [punk] --
//
//  Returns:
//
//  History:    2-14-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::CallOnObjectAvailable (REFIID riid,IUnknown *punk)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::CallOnObjectAvailable",
                "this=%#x, %#x, %#x",
                this, &riid, punk
                ));
                
    HRESULT hr = E_FAIL;
    PerfDbgLog(tagCBinding, this, "+CBinding::CallOnObjectAvailable");

    if (GetOperationState() == OPS_Downloading || _grfBINDF & BINDF_GETCLASSOBJECT)
    {
        hr = _pBSCB->OnObjectAvailable(riid, punk);
        SetOperationState(OPS_ObjectAvailable);
    }
    else
    {
        UrlMkAssert((GetOperationState() == OPS_Downloading));
    }

    PerfDbgLog1(tagCBinding, this, "-CBinding::CallOnObjectAvailable (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::GetRequestedObject
//
//  Synopsis:
//
//  Arguments:  [pbc] --
//              [ppUnk] --
//
//  Returns:
//
//  History:    7-04-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::GetRequestedObject(IBindCtx *pbc, IUnknown **ppUnk)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::GetRequestedObject",
                "this=%#x, %#x, %#x",
                this, pbc, ppUnk
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCBinding, this, "+CBinding::GetRequestedObject");

    UrlMkAssert((ppUnk));
    *ppUnk = NULL;

    if (_pUnkObject)
    {
        *ppUnk = _pUnkObject;
        _pUnkObject->AddRef();
    }
    else if ( IsAsyncTransaction() )
    {
        //object is not available yet
        hr = MK_S_ASYNCHRONOUS;
    }
    else
    {
        // BUGBUG: JohanP - this is bogus for the case of returning a filename in stgmed; either we return a new success code or
        // the punk of the punkforrelease of the stgmed
        hr = NOERROR;
    }

    PerfDbgLog1(tagCBinding, this, "-CBinding::GetRequestedObject (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBinding::CallAuthenticate
//
//  Synopsis:
//
//  Arguments:  [phwnd] --
//              [LPWSTR] --
//              [pszPassword] --
//
//  Returns:
//
//  History:    2-08-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBinding::CallAuthenticate(HWND* phwnd, LPWSTR *pszUsername,LPWSTR *pszPassword)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::CallAuthenticate",
                "this=%#x, %#x, %#x, %#x",
                this, phwnd, pszUsername, pszPassword
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::CallAuthenticate");
    HRESULT         hr = NOERROR;

    if (_pBasicAuth == NULL)
    {
        hr = LocalQueryInterface(IID_IAuthenticate, (void **) &_pBasicAuth);
    }

    if ((hr == NOERROR) && _pBasicAuth)
    {
         hr = _pBasicAuth->Authenticate(phwnd, pszUsername,pszPassword);
    }
    else
    {
        UrlMkAssert((_pBasicAuth == NULL));
        *phwnd = 0;
        *pszUsername = 0;
        *pszPassword = 0;
    }

    PerfDbgLog4(tagCBinding, this, "-CBinding::CallAuthenticate (hr:%lx, hwnd:%lx, username:%ws, password:%ws)",
        hr, *phwnd, *pszUsername?*pszUsername:L"", *pszPassword?*pszPassword:L"");

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::LocalQueryInterface
//
//  Synopsis:
//
//  Arguments:  [iid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    4-09-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::LocalQueryInterface(REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::LocalQueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppvObj
                ));
                
    PerfDbgLog2(tagCBinding, this, "+CBinding::LocalQueryInterface (%lx, %lx)", riid, ppvObj);
    HRESULT hr = E_NOINTERFACE;
    *ppvObj = 0;

    if (_pBSCB)
    {
        IServiceProvider *pSrvPrv;
        hr = _pBSCB->QueryInterface(IID_IServiceProvider, (void **) &pSrvPrv);
        if (hr == NOERROR)
        {
            hr = pSrvPrv->QueryService(riid,riid, ppvObj);
            pSrvPrv->Release();
        }
        else
        {
            hr = E_NOINTERFACE;
            *ppvObj = 0;
        }
    }

    PerfDbgLog2(tagCBinding, this, "-CBinding::LocalQueryInterface (%lx)[%lx]", hr, *ppvObj);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::Switch
//
//  Synopsis:
//
//  Arguments:  [pStateInfo] --
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::Switch(PROTOCOLDATA *pStateInfo)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IInternetProtocolSink::Switch",
                "this=%#x, %#x",
                this, pStateInfo
                ));

    PerfDbgLog(tagCBinding, this, "+CBinding::Switch");
    HRESULT hr = E_FAIL;

    TransAssert((FALSE));

    PerfDbgLog1(tagCBinding, this, "-CBinding::Switch (%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::ReportProgress
//
//  Synopsis:
//
//  Arguments:  [ulStatusCode] --
//              [szStatusText] --
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::ReportProgress(ULONG ulStatusCode, LPCWSTR szStatusText)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IInternetProtocolSink::ReportProgress",
                "this=%#x, %#x, %.80wq",
                this, ulStatusCode, szStatusText
                ));

    PerfDbgLog(tagCBinding, this, "+CBinding::ReportProgress");
    HRESULT hr = NOERROR;

    if (   (ulStatusCode == BINDSTATUS_BEGINDOWNLOADDATA)
        || (ulStatusCode == BINDSTATUS_DOWNLOADINGDATA)
        || (ulStatusCode == BINDSTATUS_ENDDOWNLOADDATA) )
    {
    }
    else
    {
        BOOL fRet = OnTransNotification(
                    (BINDSTATUS) ulStatusCode  //BINDSTATUS NotMsg,
                    ,0 //ulProgress    //DWORD dwCurrentSize,
                    ,0 //ulProgressMax //DWORD dwTotalSize,
                    ,( LPWSTR)szStatusText  //LPWSTR pwzStr,
                    ,NOERROR       //HRESULT hrINet
                    );
    }


    PerfDbgLog1(tagCBinding, this, "-CBinding::ReportProgress (%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::ReportData
//
//  Synopsis:
//
//  Arguments:  [grfBSCF] --
//              [ulProgress] --
//              [ulProgressMax] --
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::ReportData(DWORD grfBSCF, ULONG ulProgress, ULONG ulProgressMax)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IInternetProtocolSink::ReportData",
                "this=%#x, %#x, %#x, %#x",
                this, grfBSCF, ulProgress, ulProgressMax
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::ReportData");
    HRESULT hr = NOERROR;
    BOOL fLastNotification = (grfBSCF & BSCF_LASTDATANOTIFICATION) ? TRUE : FALSE;
    ULONG ulStatusCode = BINDSTATUS_DOWNLOADINGDATA;
    ULONG dwNew;

    AddRef();

    if (grfBSCF & BSCF_LASTDATANOTIFICATION)
    {
        ulStatusCode = BINDSTATUS_ENDDOWNLOADDATA;
    }
    else if (grfBSCF & BSCF_FIRSTDATANOTIFICATION)
    {
        ulStatusCode = BINDSTATUS_BEGINDOWNLOADDATA;
    }

    HRESULT hr1 = _pCTransData->OnDataReceived(grfBSCF, ulProgress, ulProgressMax,&dwNew);
    ulProgress = dwNew;

    if (hr1 == S_FALSE)
    {
        // end of data
        ulStatusCode = BINDSTATUS_ENDDOWNLOADDATA;
    }
    else if (   (hr1 != S_NEEDMOREDATA)
             && (hr1 != E_PENDING)
             && (hr1 != NOERROR))
    {
        ulStatusCode = BINDSTATUS_ERROR;
    }

    if (hr1 != S_NEEDMOREDATA)
    {
        BOOL fRet = OnTransNotification(
                        (BINDSTATUS) ulStatusCode   //BINDSTATUS NotMsg,
                        ,ulProgress                 //DWORD dwCurrentSize,
                        ,ulProgressMax              //DWORD dwTotalSize,
                        ,NULL                       //LPWSTR pwzStr,
                        ,NOERROR                    //HRESULT hrINet
                        );
        if (fRet == TRUE)
        {
            _pCTransData->OnTerminate();
            if (_fBindToObject)
            {
                hr = S_FALSE;
                
                TransAssert((_grfInternalFlags | ~BDGFLAGS_ATTACHED));
                TransAssert((_grfInternalFlags & BDGFLAGS_PARTIAL));
                
                _pOInetBdg->Terminate(BDGFLAGS_PARTIAL);
            }
            else if(_fBTS_BTO)
            {
                _pOInetBdg->Terminate(BDGFLAGS_BTS_BTO);
            }
        }
    }

    //TRIDENT BTS->BTO
    //used to return only NOERROR and S_FALSE(only for certain BTO sitns.-not returned for BTS)
    //Return INET_E_TERMINATED_BIND to let the Trans object know about the transfer.
    if (_fBTS_BTO) 
        hr = INET_E_TERMINATED_BIND;
        
    Release();

    PerfDbgLog1(tagCBinding, this, "-CBinding::ReportData (%lx)", hr);
        
    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBinding::ReportResult
//
//  Synopsis:
//
//  Arguments:  [hrResult] --
//              [dwError] --
//              [pwzResult] --
//
//  Returns:
//
//  History:    4-10-1997   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBinding::ReportResult(HRESULT hrResult, DWORD dwError, LPCWSTR pwzResult)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::IInternetProtocolSink::ReportResult",
                "this=%#x, %#x, %#x, %.80wq",
                this, hrResult, dwError, pwzResult
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::ReportResult");
    HRESULT hr = NOERROR;

    AddRef();

    _dwBindError = dwError;
    _hrBindResult = hrResult;

    if (pwzResult)
    {
        if (_pwzResult)
        {
            delete [] _pwzResult;
        }
        _pwzResult = OLESTRDuplicate((LPWSTR)pwzResult);
    }

    BOOL fRet = OnTransNotification(
                    BINDSTATUS_RESULT           //BINDSTATUS NotMsg,
                    ,0 //ulProgress             //DWORD dwCurrentSize,
                    ,0 //ulProgressMax          //DWORD dwTotalSize,
                    ,(LPWSTR)pwzResult           //LPWSTR pwzStr,
                    ,hrResult                   //HRESULT hrINet
                    );
    if (fRet == TRUE)
    {
        hr = S_FALSE;

        DWORD dwFlags = (_fBindToObject) ? BDGFLAGS_PARTIAL : 0;
        _pCTransData->OnTerminate();
        _pOInetBdg->Terminate(dwFlags);
    }
    Release();

    PerfDbgLog1(tagCBinding, this, "-CBinding::ReportResult (%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


STDMETHODIMP CBinding::CreateObject(CLSID *pclsid, REFIID riidResult, IUnknown **ppUnk)
{
    DEBUG_ENTER((DBG_BINDING,
                Hresult,
                "CBinding::CreateObject",
                "this=%#x, %#x, %#x, %#x",
                this, pclsid, &riidResult, ppUnk
                ));
                
    PerfDbgLog(tagCBinding, this, "+CBinding::CreateObj");
    HRESULT     hr;
    IUnknown    *pUnk = NULL;

    if (GetOperationState() == OPS_Abort)
    {
        // stop now - the client aborted the operation
        hr = E_ABORT;
    }
    else
    {

        DumpIID(riidResult);

        // call OleAutoConvert
        {
            CLSID clsidIn = *pclsid;
            CLSID clsidOut;
            hr = OleGetAutoConvert(clsidIn, &clsidOut);
            if (hr == S_OK)
            {
                *pclsid = clsidOut;
            }
        }

        if (_grfBINDF & BINDF_GETCLASSOBJECT)
        {
            // Just want the class object
            hr = CoGetClassObject(*pclsid, CLSCTX_INPROC_SERVER,
                                  NULL, riidResult, (void **)&pUnk);
            if (FAILED(hr))
            {
                hr = CoGetClassObject(*pclsid, CLSCTX_LOCAL_SERVER,
                                      NULL, riidResult, (void **)&pUnk);
                if (FAILED(hr))
                {
                    hr = CoGetClassObject(*pclsid, CLSCTX_INPROC_HANDLER,
                                          NULL, riidResult, (void **)&pUnk);

                }
            }
        }
        else
        {

            hr = CoCreateInstance(*pclsid, NULL, CLSCTX_INPROC_SERVER,
                                    riidResult, (void**)&pUnk);

            if (FAILED(hr))
            {
                hr = CoCreateInstance(*pclsid, NULL, CLSCTX_LOCAL_SERVER,
                                   riidResult, (void**)&pUnk);

                if (FAILED(hr))
                {

                    hr = CoCreateInstance(*pclsid, NULL, CLSCTX_INPROC_HANDLER, 
                                       riidResult, (void**)&pUnk);

                }
            }
        }

        if (SUCCEEDED(hr))
        {
            *ppUnk = pUnk;
        }
        else
        {
            SetInstantiateHresult(hr);
            hr = INET_E_CANNOT_INSTANTIATE_OBJECT;
        }
        CallOnProgress( 0, 0, BINDSTATUS_ENDSYNCOPERATION, 0 );
    }

    PerfDbgLog1(tagCBinding, this, "-CBinding::CreateObject (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\trans\cdldelg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cdldelg.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    02-20-97   t-alans (Alan Shi)   Created
//
//----------------------------------------------------------------------------

#include <trans.h>
#include <wchar.h>

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::CCDLDelegate
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CCDLDelegate::CCDLDelegate(CBinding *pCBinding, IBindStatusCallback *pBSC)
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CCDLDelegate::CCDLDelegate",
                "this=%#x, %#x, %#x",
                this, pCBinding, pBSC
                ));
                
    _cRef = 1;
    _pCBinding = pCBinding;
    if (_pCBinding != NULL)
    {
        _pCBinding->AddRef();
    }
    _pBSC = pBSC;
    if (_pBSC != NULL)
    {
        _pBSC->AddRef();
    }

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::~CCDLDelegate
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CCDLDelegate::~CCDLDelegate()
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CCDLDelegate::~CCDLDelegate",
                "this=%#x",
                this
                ));
                
    if (_pCBinding != NULL)
    {
        _pCBinding->Release();
    }
    if (_pBSC != NULL)
    {
        _pBSC->Release();
    }

    DEBUG_LEAVE(0);
}

/*
 *
 * IUnknown Methods
 *
 */
 
//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::QueryInterface
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::QueryInterface(REFIID riid, void **ppv)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppv
                ));
                
    HRESULT          hr = E_NOINTERFACE;

    *ppv = NULL;
    if (riid == IID_IUnknown || riid == IID_IBindStatusCallback)
    {
        *ppv = (IBindStatusCallback *)this;
    }
    else if (riid == IID_IBinding)
    {
        *ppv = (IBinding *)this;
    }
    else if (riid == IID_IWindowForBindingUI)
    {
        *ppv = (IWindowForBindingUI *)this;
    }
    
    if (*ppv != NULL)
    {
        ((IUnknown *)*ppv)->AddRef();
        hr = S_OK;
    }

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::AddRef
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CCDLDelegate::AddRef()
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CCDLDelegate::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    ULONG ulRet = ++_cRef;

    DEBUG_LEAVE(ulRet);
    return ulRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::Release
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CCDLDelegate::Release()
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CCDLDelegate::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    if (--_cRef)
    {
        DEBUG_LEAVE(_cRef);
        return _cRef;
    }
    delete this;

    DEBUG_LEAVE(0);
    return 0;
}

/*
 *
 * IBindStatusCallback Methods
 *
 */
 
//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::OnStartBinding
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::OnStartBinding(DWORD grfBSCOption, IBinding *pib)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IBindStatusCallback::OnStartBinding",
                "this=%#x, %#x, %#x",
                this, grfBSCOption, pib
                ));
                
    HRESULT                 hr = S_OK;

#if 0
    if (_pCBinding != NULL)
    {
        hr = _pCBinding->OnTransNotification(BINDSTATUS_???,
                                             0, 0, S_OK);
    }
#endif
    _pBinding = pib;
    if (_pBinding != NULL)
    {
        _pBinding->AddRef();
    }

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::OnStopBinding
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::OnStopBinding(HRESULT hresult, LPCWSTR szError)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IBindStatusCallback::OnStopBinding",
                "this=%#x, %#x, %.80wq",
                this, hresult, szError
                ));
                
    HRESULT              hr = S_OK;

#if 0
    if (_pCBinding != NULL)
    {
        hr = _pCBinding->OnTransNotification(BINDSTATUS_CODEDOWNLOADCOMPLETE,
                                             0, 0, (LPWSTR)szError, hresult);
    }
#endif    
    if (_pBinding != NULL)
    {
        _pBinding->Release();
        _pBinding = NULL;
    }

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::OnObjectAvailable
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IBindStatusCallback::OnObjectAvailable",
                "this=%#x, %#x, %#x",
                this, &riid, punk
                ));

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::OnLowResource
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::OnLowResource(DWORD dwReserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IBindStatusCallback::OnLowResource",
                "this=%#x, %#x",
                this, dwReserved
                ));

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::OnProgress
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::OnProgress(ULONG ulProgress, ULONG ulProgressMax,
                                      ULONG ulStatusCode,
                                      LPCWSTR szStatusText)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IBindStatusCallback::OnProgress",
                "this=%#x, %#x, %#x, %#x, %.80wq",
                this, ulProgress, ulProgressMax ulStatusCode, szStatusText
                ));
                
    HRESULT                hr = S_OK;

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::GetBindInfo
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::GetBindInfo(DWORD *pgrfBINDF,
                                       BINDINFO *pbindInfo)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IBindStatusCallback::GetBindInfo",
                "this=%#x, %#x, %#x",
                this, pgrfBINDF, pbindInfo
                ));
                
    *pgrfBINDF |= BINDF_ASYNCSTORAGE;
    *pgrfBINDF |= BINDF_PULLDATA;
    *pgrfBINDF |= BINDF_ASYNCHRONOUS;

    DEBUG_LEAVE(S_OK);
    return S_OK;
} 

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::OnDataAvailable
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::OnDataAvailable( DWORD grfBSCF, DWORD dwSize,
                                            FORMATETC *pformatetc,
                                            STGMEDIUM *pstgmed )
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IBindStatusCallback::OnDataAvailable",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, grfBSCF, dwSize, pformatetc, pstgmed
                ));
                
    DEBUG_LEAVE(S_OK);
    return S_OK;
}

/*
 *
 * IBinding Methods
 *
 */
 
// delegates all calls back to URLMon

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::Abort
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::Abort(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IBinding::Abort",
                "this=%#x",
                this
                ));
                
    HRESULT              hr = E_NOTIMPL;
    
    if (_pBinding != NULL)
    {
       hr = _pBinding->Abort();
    }

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::Suspend
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::Suspend(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IBinding::Suspend",
                "this=%#x",
                this
                ));
                
    HRESULT              hr = E_NOTIMPL;
    
    if (_pBinding != NULL)
    {
       hr = _pBinding->Suspend();
    }

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::Resume
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::Resume(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IBinding::Resume",
                "this=%#x",
                this
                ));
                
    HRESULT              hr = E_NOTIMPL;
    
    if (_pBinding != NULL)
    {
       hr = _pBinding->Resume();
    }

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::SetPriority
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::SetPriority(LONG nPriority)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IBinding::SetPriority",
                "this=%#x, %#x",
                this, nPriority
                ));
                
    HRESULT              hr = E_NOTIMPL;
    
    if (_pBinding != NULL)
    {
       hr = _pBinding->SetPriority(nPriority);
    }

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::GetPriority
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::GetPriority(LONG *pnPriority)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IBinding::GetPriority",
                "this=%#x, %#x",
                this, pnPriority
                ));
                
    HRESULT              hr = E_NOTIMPL;
    
    if (_pBinding != NULL)
    {
       hr = _pBinding->GetPriority(pnPriority);
    }

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::GetBindResult
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::GetBindResult(CLSID *pclsidProtocol,
                                         DWORD *pdwBindResult,
                                         LPWSTR *pszBindResult,
                                         DWORD *dwReserved )
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IBinding::GetBindResult",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, pclsidProtocol, pdwBindResult, pszBindResult, dwReserved
                ));
                
    HRESULT              hr = E_NOTIMPL;
    
    if (_pBinding != NULL)
    {
       hr = _pBinding->GetBindResult(pclsidProtocol, pdwBindResult,
                                     pszBindResult, dwReserved);
    }

    DEBUG_LEAVE(hr);
    return hr;
}

/*
 *
 * IWindowForBindingUI Methods
 *
 */

//+---------------------------------------------------------------------------
//
//  Method:     CCDLDelegate::GetWindow
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCDLDelegate::GetWindow(REFGUID rguidReason,
                                     HWND __RPC_FAR *phwnd)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCDLDelegate::IWindowForBindingUI::GetWindow",
                "this=%#x, %#x, %#x",
                this, &rguidReason, phwnd
                ));
                
    HRESULT                  hr = S_FALSE;
    IWindowForBindingUI     *pWindowForBindingUI = NULL;
    IServiceProvider        *pIServiceProvider = NULL;
    
    hr = _pBSC->QueryInterface(IID_IWindowForBindingUI,
                               (LPVOID *)&pWindowForBindingUI);
    if (FAILED(hr))
    {
        hr = _pBSC->QueryInterface(IID_IServiceProvider,
                                   (LPVOID *)&pIServiceProvider);
        if (SUCCEEDED(hr))
        {
            pIServiceProvider->QueryService(IID_IWindowForBindingUI,
                                            IID_IWindowForBindingUI,
                                            (LPVOID *)&pWindowForBindingUI);
            pIServiceProvider->Release();
        }
    }

    if (pWindowForBindingUI != NULL)
    {
        hr = pWindowForBindingUI->GetWindow(rguidReason, phwnd);
    }
    else
    {
        hr = S_FALSE;
        *phwnd = (HWND)INVALID_HANDLE_VALUE;
    }

    DEBUG_LEAVE(hr);
    return hr;

}

/*
 *
 * Helper API to do code installation
 *
 */
 
//+---------------------------------------------------------------------------
//
//  Method:     AsyncDLCodeInstall
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP AsyncDLCodeInstall(CBinding *pCBinding,
                                IBindStatusCallback *pIBSC,
                                IBinding **ppIBinding,
                                CCodeDownloadInfo *pCDLInfo)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "AsyncDLCodeInstall",
                "%#x, %#x, %#x, %#x",
                pCBinding, pIBSC, ppIBinding, pCDLInfo
                ));
                
    HRESULT                   hr = E_FAIL;
    CCDLDelegate             *pCDLDelegate = NULL;
    IBindCtx                 *pbc = NULL;
    IMoniker                 *pIMonikerCDL = NULL;
    IStream                  *pIStream = NULL;
    WCHAR                     szDisplayName[3 * (MAX_URL_SIZE + 1)];
    CLSID                     clsid = CLSID_NULL;
    LPWSTR                    pszStr = NULL;
    WCHAR                     pszCodeBase[MAX_URL_SIZE + 1];
    DWORD                     dwMajorVersion = 0;
    DWORD                     dwMinorVersion = 0;

    pCDLDelegate = new CCDLDelegate(pCBinding, pIBSC);
    if (pCDLDelegate == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    *ppIBinding = pCDLDelegate;
    
    hr = CreateBindCtx(0, &pbc);
    if (SUCCEEDED(hr))
    {
        hr = RegisterBindStatusCallback(pbc, pCDLDelegate, NULL, 0);
        if (SUCCEEDED(hr))
        {
            pCDLDelegate->Release();
        }
        else
        {
            pbc->Release();
            goto Exit; 
        }

        // AS TODO: Make this smarter...

        LPWSTR pszPtr = pszCodeBase;
        pCDLInfo->GetCodeBase(&pszPtr);
        pCDLInfo->GetClassID(&clsid);
        pCDLInfo->GetMajorVersion(&dwMajorVersion);
        pCDLInfo->GetMinorVersion(&dwMinorVersion);
        HRESULT succ = StringFromCLSID(clsid, &pszStr);
        swprintf(szDisplayName, L"cdl:codebase=%s;clsid=%s;verMS=%ld;verLS=%ld"
                              , pszCodeBase, pszStr, dwMajorVersion, dwMinorVersion);
        if (pszStr != NULL)
        {
            delete pszStr;
        }

//      assert( strlen( szDisplayName <= 3 * MAX_URL_SIZE ) );
        hr = CreateURLMoniker(NULL, szDisplayName, &pIMonikerCDL);
        if (SUCCEEDED(hr))
        {
            hr = pIMonikerCDL->BindToStorage(pbc, NULL, IID_IStream,
                                             (void **)&pIStream);
            pIMonikerCDL->Release();
        }
        
    }

    if (pbc != NULL)
    {
        pbc->Release();
    }

Exit:

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\trans\cdlinfo.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cdlinfo.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    02-20-97   t-alans (Alan Shi)   Created
//
//----------------------------------------------------------------------------

#include <trans.h>
#include <objbase.h>
#include <wchar.h>

// AS: ICodeDownloadInfo added to urlmon.idl (local change)
//     modified urlint.h to add SZ_CODEDOWNLOADINFO

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDownloadInfo::CCodeDownloadInfo
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CCodeDownloadInfo::CCodeDownloadInfo()
: _szCodeBase( NULL )
, _ulMajorVersion( 0 )
, _ulMinorVersion( 0 )
, _cRefs( 1 )
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CCodeDownloadInfo::CCodeDownloadInfo",
                "this=%#x",
                this
                ));

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDownloadInfo::~CCodeDownloadInfo
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

CCodeDownloadInfo::~CCodeDownloadInfo()
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CCodeDownloadInfo::~CCodeDownloadInfo",
                "this=%#x",
                this
                ));
                
    if (_szCodeBase != NULL)
    {
        CoTaskMemFree((void *)_szCodeBase);
        _szCodeBase = NULL;
    }

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDownloadInfo::QueryInterface
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCodeDownloadInfo::QueryInterface(REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCodeDownloadInfo::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppvObj
                ));
                
    HRESULT          hr = S_OK;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ICodeDownloadInfo))
    {
        *ppvObj = (void *)this;
        AddRef();
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDownloadInfo::AddRef
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CCodeDownloadInfo::AddRef(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CCodeDownloadInfo::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    ULONG ulRet = ++_cRefs;

    DEBUG_LEAVE(hr);
    return ulRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDownloadInfo::Release
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CCodeDownloadInfo::Release(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CCodeDownloadInfo::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    if (!--_cRefs)
    {
        delete this;
    }

    DEBUG_LEAVE(_cRefs);
    return _cRefs;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDownloadInfo::GetCodeBase
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCodeDownloadInfo::GetCodeBase(LPWSTR *szCodeBase)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCodeDownloadInfo::GetCodeBase",
                "this=%#x, %.80wq",
                this, szCodeBase
                ));
                
    wcscpy(*szCodeBase, _szCodeBase);

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDownloadInfo::SetCodeBase
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCodeDownloadInfo::SetCodeBase(LPCWSTR szCodeBase)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCodeDownloadInfo::SetCodeBase",
                "this=%#x, %.80wq",
                this, szCodeBase
                ));
                
    HRESULT               hr = E_FAIL;
    long                  lStrlen = 0;
    
    if (_szCodeBase != NULL)
    {
        CoTaskMemFree((void *)_szCodeBase);
        _szCodeBase = NULL;
    }
#ifndef unix
    lStrlen = 2 * (wcslen(szCodeBase) + 1);
#else
    lStrlen =  sizeof(WCHAR) * (wcslen(szCodeBase) + 1);
#endif /* unix */
    _szCodeBase = (LPWSTR)CoTaskMemAlloc(lStrlen);
    hr = (_szCodeBase == NULL) ? (E_OUTOFMEMORY) : (S_OK);
    if (_szCodeBase != NULL)
    {
        wcscpy(_szCodeBase, szCodeBase);
    }

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDownloadInfo::SetMinorVersion
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCodeDownloadInfo::SetMinorVersion(ULONG ulVersion)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCodeDownloadInfo::SetMinorVersion",
                "this=%#x, %x",
                this, ulVersion
                ));
                
    _ulMinorVersion = ulVersion;

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDownloadInfo::GetMinorVersion
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCodeDownloadInfo::GetMinorVersion(ULONG *pulVersion)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCodeDownloadInfo::GetMinorVersion",
                "this=%#x, %#x",
                this, pulVersion
                ));
                
    *pulVersion = _ulMinorVersion;

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDownloadInfo::SetMajorVersion
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCodeDownloadInfo::SetMajorVersion(ULONG ulVersion)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCodeDownloadInfo::SetMajorVersion",
                "this=%#x, %x",
                this, ulVersion
                ));
                
    _ulMajorVersion = ulVersion;

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDownloadInfo::GetMajorVersion
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCodeDownloadInfo::GetMajorVersion(ULONG *pulVersion)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCodeDownloadInfo::GetMajorVersion",
                "this=%#x, %#x",
                this, pulVersion
                ));
                
    *pulVersion = _ulMajorVersion;

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDownloadInfo::GetClassID
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCodeDownloadInfo::GetClassID(CLSID *clsid)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCodeDownloadInfo::GetClassID",
                "this=%#x, %#x",
                this, clsid
                ));
                
    *clsid = _clsid;

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     CCodeDownloadInfo::SetClassID
//
//  Synopsis:
//
//  Arguments:  
//              
//              
//
//  Returns:
//
//  History:    01-27-1997   t-alans (Alan Shi)   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

STDMETHODIMP CCodeDownloadInfo::SetClassID(CLSID clsid)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CCodeDownloadInfo::SetClassID",
                "this=%#x, %#x",
                this, &clsid
                ));
                
    _clsid = clsid;

    DEBUG_LEAVE(S_OK);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\trans\bindctx.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       bindctx.cxx
//
//  Contents:   CBindCtx methods implementations
//              to support custom marshaling
//
//  Classes:
//
//  Functions:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <trans.h>
#include "bindctx.hxx"

PerfDbgTag(tagCBindCtx, "Urlmon", "Log CBindCtx", DEB_URLMON);

#define OBJECTPARAMKEYCHECK1 (_pbcRem &&  !wcscmp(pszKey, SZ_TRANSACTIONDATA))

#define OBJECTPARAMKEYCHECK2 (_pbcRem && wcscmp(pszKey, SZ_BINDING)         \
                                        && wcscmp(pszKey, REG_BSCB_HOLDER)  \
                                        && wcscmp(pszKey, REG_ENUMFORMATETC)\
                                        && wcscmp(pszKey, REG_MEDIA_HOLDER) \
                                        && wcscmp(pszKey, SZ_TRANSACTIONDATA))


//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::Create
//
//  Synopsis:
//
//  Arguments:  [ppCBCtx] --
//
//  Returns:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBindCtx::Create(CBindCtx **ppCBCtx, IBindCtx *pbc)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::Create",
                "%#x, %#x",
                ppCBCtx, pbc
                ));
                
    PerfDbgLog1(tagCBindCtx, NULL, "+CBindCtx::Create (pbc:%lx)", pbc);
    HRESULT hr = NOERROR;

    *ppCBCtx = NULL;

    if (pbc == NULL)
    {
        hr = CreateBindCtx(0, &pbc);
    }
    else
    {
        // check if this is actually  a wrapped object
        // if so don't wrap it again
        hr = pbc->QueryInterface(IID_IAsyncBindCtx, (void **)ppCBCtx);
        if (hr != NOERROR)
        {
            hr = NOERROR;
            *ppCBCtx = NULL;
        }
        pbc->AddRef();
    }

    if (hr == NOERROR && *ppCBCtx == NULL)
    {
        TransAssert((pbc));
        *ppCBCtx = new CBindCtx(pbc);

        if (*ppCBCtx  == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (pbc)
    {
        pbc->Release();
    }
    PerfDbgLog2(tagCBindCtx, NULL, "-CBindCtx::Create (out:%lx,hr:%lx)", *ppCBCtx, hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::CBindCtx
//
//  Synopsis:
//
//  Arguments:  [pbc] --
//
//  Returns:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CBindCtx::CBindCtx(IBindCtx *pbc)
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CBindCtx::CBindCtx",
                "this=%#x, %#x",
                this, pbc
                ));
                
    _pbcLocal = pbc;
    if (_pbcLocal)
    {
        _pbcLocal->AddRef();
    }
    _pbcRem = NULL;
    _dwThreadId = GetCurrentThreadId();
    _pCTrans = 0;
    _pCTransData = 0;
    
    DllAddRef();

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::~CBindCtx
//
//  Synopsis:
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CBindCtx::~CBindCtx()
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CBindCtx::~CBindCtx",
                "this=%#x",
                this
                ));
                
    //TransAssert(( _dwThreadId == GetCurrentThreadId() ));
    if (_pbcRem)
    {
        _pbcRem->Release();
    }
    if (_pbcLocal)
    {
        _pbcLocal->Release();
    }

    if (_pCTrans)
    {
        _pCTrans->Release();
    }
    if (_pCTransData)
    {
        _pCTransData->Release();
    }


    DllRelease();

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::CanMarshalIID
//
//  Synopsis:   Checks whether this object supports marshalling this IID.
//
//  Arguments:  [riid] --
//
//  Returns:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
inline BOOL CBindCtx::CanMarshalIID(REFIID riid)
{
    DEBUG_ENTER((DBG_TRANS,
                Bool,
                "CBindCtx::CanMarshalIID",
                "this=%#x, %#x",
                this, &riid
                ));
                
    // keep this in sync with the QueryInterface
    BOOL bRet = (BOOL) (riid == IID_IBindCtx);

    DEBUG_LEAVE(bRet);
    return bRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::ValidateMarshalParams
//
//  Synopsis:   Validates the standard set parameters that are passed into most
//              of the IMarshal methods
//
//  Arguments:  [riid] --
//              [pvInterface] --
//              [dwDestContext] --
//              [pvDestContext] --
//              [mshlflags] --
//
//  Returns:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CBindCtx::ValidateMarshalParams(REFIID riid,void *pvInterface,
                    DWORD dwDestContext,void *pvDestContext,DWORD mshlflags)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::ValidateMarshalParams",
                "this=%#x, %#x, %#x, %#x, %#x, %#x",
                this, &riid, pvInterface, dwDestContext, pvDestContext, mshlflags
                ));

    PerfDbgLog(tagCBindCtx, this, "+CBindCtx::ValidateMarshalParams");
    TransAssert(( _dwThreadId == GetCurrentThreadId() ));
    HRESULT hr = NOERROR;

    if (CanMarshalIID(riid))
    {
        UrlMkAssert((dwDestContext == MSHCTX_INPROC || dwDestContext == MSHCTX_LOCAL || dwDestContext == MSHCTX_NOSHAREDMEM));
        UrlMkAssert((mshlflags == MSHLFLAGS_NORMAL || mshlflags == MSHLFLAGS_TABLESTRONG));

        if (   (dwDestContext != MSHCTX_INPROC && dwDestContext != MSHCTX_LOCAL && dwDestContext != MSHCTX_NOSHAREDMEM)
            || (mshlflags != MSHLFLAGS_NORMAL && mshlflags != MSHLFLAGS_TABLESTRONG))
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    PerfDbgLog1(tagCBindCtx, this, "-CBindCtx::ValidateMarshalParams (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindCtx::QueryInterface(REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppvObj
                ));
                
    VDATEPTROUT(ppvObj, void *);
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCBindCtx, this, "+CBindCtx::QueryInterface");

    TransAssert(( _dwThreadId == GetCurrentThreadId() ));

    if (   riid == IID_IUnknown
        || riid == IID_IBindCtx
        || riid == IID_IAsyncBindCtx)
    {
        *ppvObj = this;
    }
    else if (riid == IID_IMarshal)
    {
        *ppvObj = (void*) (IMarshal *) this;
    }
    else
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }
    if (hr == NOERROR)
    {
        AddRef();
    }

    PerfDbgLog1(tagCBindCtx, this, "-CBindCtx::QueryInterface (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CBindCtx::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBindCtx::AddRef(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CBindCtx::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    //TransAssert(( _dwThreadId == GetCurrentThreadId() ));

    LONG lRet = ++_CRefs;

    PerfDbgLog1(tagCBindCtx, this, "CBindCtx::AddRef (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   CBindCtx::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBindCtx::Release(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CBindCtx::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    //TransAssert(( _dwThreadId == GetCurrentThreadId() ));
    PerfDbgLog(tagCBindCtx, this, "+CBindCtx::Release");

    LONG lRet = --_CRefs;

    if (_CRefs == 0)
    {
        delete this;
    }

    PerfDbgLog1(tagCBindCtx, this, "-CBindCtx::Release (cRefs:%ld)", lRet);

    DEBUG_LEAVE(lRet);
    return lRet;
}
                                       
//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::GetObjectParam
//
//  Synopsis:
//
//  Arguments:  [pszKey] --
//              [ppunk] --
//
//  Returns:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindCtx::GetObjectParam(LPOLESTR pszKey, IUnknown **ppunk)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::IBindCtx::GetObjectParam",
                "this=%#x, %#x, %#x",
                this, pszKey, ppunk
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog3(tagCBindCtx, this, "+CBindCtx::GetObjectParam (_pbcLocal:%lx, _pbcRem:%lx, szParam:%ws)", _pbcLocal, _pbcRem, pszKey);
    UrlMkAssert((pszKey && ppunk));

    if (OBJECTPARAMKEYCHECK1)
    {
        // get the interface from the remote object
        PerfDbgLog2(tagCBindCtx, this, "=== CBindCtx::GetObjectParam (_pbcRem:%lx, szParam:%ws)", _pbcRem, pszKey);

        hr =  _pbcLocal->GetObjectParam(pszKey, ppunk);
        
        if (hr != NOERROR)
        {
            hr =  _pbcRem->GetObjectParam(pszKey, ppunk);
        }
    }
    else
    {
        hr =  _pbcLocal->GetObjectParam(pszKey, ppunk);
    }

    if ((hr != NOERROR) && OBJECTPARAMKEYCHECK2)
    {
        hr =  _pbcRem->GetObjectParam(pszKey, ppunk);
    }

    PerfDbgLog1(tagCBindCtx, this, "-CBindCtx::GetObjectParam (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::EnumObjectParam
//
//  Synopsis:
//
//  Arguments:  [ppenum] --
//
//  Returns:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//  Notes:      BUGBUG - this implementation is wrong; need to wrap
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindCtx::EnumObjectParam(IEnumString **ppenum)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::IBindCtx::EnumObjectParam",
                "this=%#x, %#x",
                this, ppenum
                ));
                
    HRESULT hr = _pbcLocal->EnumObjectParam(ppenum);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CBindCtx::RevokeObjectParam(LPOLESTR pszKey)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::IBindCtx::RevokeObjectParam",
                "this=%#x, %#x",
                this, pszKey
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog3(tagCBindCtx, this, "+CBindCtx::RevokeObjectParam (_pbcLocal:%lx, _pbcRem:%lx, szParam:%ws)", _pbcLocal, _pbcRem, pszKey);
    UrlMkAssert(pszKey);

    if (OBJECTPARAMKEYCHECK1)
    {
        // get the interface from the remote object
        PerfDbgLog2(tagCBindCtx, this, "=== CBindCtx::RevokeObjectParam (_pbcRem:%lx, szParam:%ws)", _pbcRem, pszKey);

        hr =  _pbcLocal->RevokeObjectParam(pszKey);
        
        if (hr != NOERROR)
        {
            hr =  _pbcRem->RevokeObjectParam(pszKey);
        }
    }
    else
    {
        hr =  _pbcLocal->RevokeObjectParam(pszKey);
    }

    if ((hr != NOERROR) && OBJECTPARAMKEYCHECK2)
    {
        hr =  _pbcRem->RevokeObjectParam(pszKey);
    }

    PerfDbgLog1(tagCBindCtx, this, "-CBindCtx::RevokeObjectParam (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
// IMarshal methods
//
//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::GetUnmarshalClass
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [pvInterface] --
//              [dwDestContext] --
//              [pvDestContext] --
//              [mshlflags] --
//              [pCid] --
//
//  Returns:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindCtx::GetUnmarshalClass(REFIID riid,void *pvInterface,
        DWORD dwDestContext,void *pvDestContext,DWORD mshlflags,CLSID *pCid)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::IMarshal::GetUnmarshalClass",
                "this=%#x, %#x, %#x, %#x, %#x, %#x, %#x",
                this, &riid, pvInterface, dwDestContext, pvDestContext, mshlflags, pCid
                ));
                
    PerfDbgLog(tagCBindCtx, this, "+CBindCtx::GetUnmarshalClass");
    HRESULT hr;

    hr = ValidateMarshalParams(riid, pvInterface, dwDestContext,pvDestContext, mshlflags);
    if (hr == NOERROR)
    {
        *pCid = (CLSID) CLSID_UrlMkBindCtx;
    }

    PerfDbgLog1(tagCBindCtx, this, "-CBindCtx::GetUnmarshalClass (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::GetMarshalSizeMax
//
//  Synopsis:
//
//  Arguments:  [void] --
//              [pvInterface] --
//              [dwDestContext] --
//              [pvDestContext] --
//              [mshlflags] --
//              [pSize] --
//
//  Returns:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindCtx::GetMarshalSizeMax(REFIID riid,void *pvInterface,
        DWORD dwDestContext,void *pvDestContext,DWORD mshlflags,DWORD *pSize)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::IMarshal::GetMarshalSizeMax",
                "this=%#x, %#x, %#x, %#x, %#x, %#x, %#x",
                this, &riid, pvInterface, dwDestContext, pvDestContext, mshlflags, pSize
                ));
                
    PerfDbgLog(tagCBindCtx, this, "+CBindCtx::GetMarshalSizeMax");
    HRESULT hr;

    if (pSize == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = ValidateMarshalParams(riid, pvInterface, dwDestContext,pvDestContext, mshlflags);
        if (hr == NOERROR)
        {
            hr = CoGetMarshalSizeMax(pSize, IID_IBindCtx, _pbcLocal, dwDestContext,pvDestContext,mshlflags);
            // marshal also the transaction object
            *pSize += sizeof(_pCTrans) + sizeof(DWORD);
        }
    }

    PerfDbgLog1(tagCBindCtx, this, "-CBindCtx::GetMarshalSizeMax (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::MarshalInterface
//
//  Synopsis:
//
//  Arguments:  [REFIID] --
//              [riid] --
//              [DWORD] --
//              [void] --
//              [DWORD] --
//              [mshlflags] --
//
//  Returns:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindCtx::MarshalInterface(IStream *pistm,REFIID riid,
                                void *pvInterface,DWORD dwDestContext,
                                void *pvDestContext,DWORD mshlflags)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::IMarshal::MarshalInterface",
                "this=%#x, %#x, %#x, %#x, %#x, %#x, %#x",
                this, pistm, &riid, pvInterface, dwDestContext, pvDestContext, mshlflags
                ));
                
    PerfDbgLog(tagCBindCtx, this, "+CBindCtx::MarshalInterface");
    HRESULT hr;
    BOOL fTransfered = FALSE;

    hr = ValidateMarshalParams(riid, pvInterface, dwDestContext,pvDestContext, mshlflags);
    if (hr == NOERROR)
    {
        hr = CoMarshalInterface(pistm, IID_IBindCtx, _pbcLocal, dwDestContext, pvDestContext, mshlflags);
    }

    if (   (hr == NOERROR)
        && (dwDestContext == MSHCTX_INPROC)
        && (_pCTrans != NULL) )
    {
        TransAssert((_pCTrans));
        TransAssert((_pCTransData));
        
        hr = _pCTrans->PrepareThreadTransfer();

        if (hr == NOERROR)
        {
            DWORD dwProcessId = GetCurrentProcessId();
            
            // marshal also the transaction object
            hr = pistm->Write(&_pCTrans, sizeof(_pCTrans), NULL);
            TransAssert((hr == NOERROR));
            // addref the pointer here to keep the object alive!
            // 
            _pCTrans->AddRef();

            // marshal also the transdata object
            hr = pistm->Write(&_pCTransData, sizeof(_pCTransData), NULL);
            TransAssert((hr == NOERROR));

            if (_pCTransData)
            {
                _pCTransData->PrepareThreadTransfer();

                // addref the pointer here to keep the object alive!
                // 
                _pCTransData->AddRef();
            }
            
            hr = pistm->Write(&dwProcessId, sizeof(DWORD), NULL);
            TransAssert((hr == NOERROR));
            fTransfered = TRUE;
        }
    }

    if (!fTransfered)
    {
        DWORD dwProcessId = 0;
        LPVOID pNull = NULL;
        // marshal also the transaction object
        hr = pistm->Write(&pNull, sizeof(pNull), NULL);
        TransAssert((hr == NOERROR));
        hr = pistm->Write(&pNull, sizeof(pNull), NULL);
        TransAssert((hr == NOERROR));
        hr = pistm->Write(&dwProcessId, sizeof(DWORD), NULL);
        TransAssert((hr == NOERROR));
    }

    PerfDbgLog1(tagCBindCtx, this, "-CBindCtx::MarshalInterface (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::UnmarshalInterface
//
//  Synopsis:   Unmarshals an Urlmon interface out of a stream
//
//  Arguments:  [REFIID] --
//              [void] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    9-12-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindCtx::UnmarshalInterface(IStream *pistm,REFIID riid,void ** ppvObj)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::IMarshal::UnmarshalInterface",
                "this=%#x, %#x, %#x, %#x",
                this, pistm, &riid, ppvObj
                ));
                
    PerfDbgLog(tagCBindCtx, this, "+CBindCtx::UnmarshalInterface");
    HRESULT hr = NOERROR;

    TransAssert(( _dwThreadId == GetCurrentThreadId() ));

    if (ppvObj == NULL)
    {
        hr = E_INVALIDARG;
    }
    else if (! CanMarshalIID(riid))
    {
        *ppvObj = NULL;
        hr = E_NOINTERFACE;
    }
    else
    {
        *ppvObj = NULL;

        hr = CoUnmarshalInterface(pistm, IID_IBindCtx, (void **) &_pbcRem);

        // call QI to get the requested interface
        if (hr == NOERROR)
        {
            hr = QueryInterface(riid, ppvObj);

            {
                HRESULT hr1;
                DWORD dwProcessId;
                // marshal also the transaction object
                hr1 = pistm->Read(&_pCTrans, sizeof(_pCTrans), NULL);
                // Note: pTrans was addref'd as the object was marshaled            // it is now addref'd
                // keep it since we hold on to the object

                if (FAILED(hr1))
                {
                    _pCTrans = 0;
                }

                // marshal also the transdata object
                hr1 = pistm->Read(&_pCTransData, sizeof(_pCTransData), NULL);
                // Note: pTrans was addref'd as the object was marshaled            // it is now addref'd
                // keep it since we hold on to the object
                if (FAILED(hr1))
                {
                    _pCTransData = 0;
                }

                //TransAssert((hr1 == NOERROR));
                hr1 = pistm->Read(&dwProcessId, sizeof(DWORD), NULL);
                TransAssert((hr1 == NOERROR));
                if (FAILED(hr1))
                {
                    dwProcessId = 0;
                }

            }

        }
        else
        {
            TransAssert(( _pbcRem == 0));
        }

    }

    PerfDbgLog1(tagCBindCtx, this, "-CBindCtx::UnmarshalInterface (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CBindCtx::ReleaseMarshalData(IStream *pStm)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::IMarshal::ReleaseMarshalData",
                "this=%#x, %#x",
                this, pStm
                ));
                
    PerfDbgLog(tagCBindCtx, this, "CBindCtx::ReleaseMarshalData");

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

STDMETHODIMP CBindCtx::DisconnectObject(DWORD dwReserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::IMarshal::DisconnectObject",
                "this=%#x, %#x",
                this, dwReserved
                ));
                
    PerfDbgLog(tagCBindCtx, this, "CBindCtx::DisconnectObject");

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::SetTransactionObject
//
//  Synopsis:
//
//  Arguments:  [pCTrans] --
//
//  Returns:
//
//  History:    10-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindCtx::SetTransactionObject(CTransaction *pCTrans)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::SetTransactionObject",
                "this=%#x, %#x",
                this, pCTrans
                ));
                
    PerfDbgLog(tagCBindCtx, this, "+CBindCtx::SetTransactionObject");
    //TransAssert(( _dwThreadId == GetCurrentThreadId() ));

    if (pCTrans != _pCTrans)
    {
        if (_pCTrans)
        {
            _pCTrans->Release();
        }
        _pCTrans = pCTrans;
        if (_pCTrans)
        {
            _pCTrans->AddRef();
        }
    }

    PerfDbgLog(tagCBindCtx, this, "-CBindCtx::SetTransactionObject (hr:0)");

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::GetTransactionObject
//
//  Synopsis:
//
//  Arguments:  [ppCTrans] --
//
//  Returns:
//
//  History:    10-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindCtx::GetTransactionObject(CTransaction **ppCTrans)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::GetTransactionObject",
                "this=%#x, %#x",
                this, ppCTrans
                ));
                
    PerfDbgLog(tagCBindCtx, this, "+CBindCtx::GetTransactionObject");
    //TransAssert(( _dwThreadId == GetCurrentThreadId() ));

    HRESULT hr = NOERROR;
    if (_pCTrans)
    {

        *ppCTrans = _pCTrans;
        _pCTrans->AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
        *ppCTrans = NULL;
    }

    PerfDbgLog1(tagCBindCtx, this, "-CBindCtx::GetTransactionObject (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::SetTransactionObjects
//
//  Synopsis:
//
//  Arguments:  [pCTrans] --
//
//  Returns:
//
//  History:    10-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindCtx::SetTransactionObjects(CTransaction *pCTrans,CTransData *pCTransData)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::SetTransactionObjects",
                "this=%#x, %#x, %#x",
                this, pCTrans, pCTransData
                ));
                
    PerfDbgLog(tagCBindCtx, this, "+CBindCtx::SetTransactionObjects");
    //TransAssert(( _dwThreadId == GetCurrentThreadId() ));

    if (pCTrans != _pCTrans)
    {
        if (_pCTrans)
        {
            _pCTrans->Release();
        }
        _pCTrans = pCTrans;
        if (_pCTrans)
        {
            _pCTrans->AddRef();
        }
    }

    if (pCTransData != _pCTransData)
    {
        if (_pCTransData)
        {
            _pCTransData->Release();
        }
        _pCTransData = pCTransData;
        if (_pCTransData)
        {
            _pCTransData->AddRef();
        }
    }

    PerfDbgLog(tagCBindCtx, this, "-CBindCtx::SetTransactionObjects (hr:0)");

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::GetTransactionObject
//
//  Synopsis:
//
//  Arguments:  [ppCTrans] --
//
//  Returns:
//
//  History:    10-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindCtx::GetTransactionObjects(CTransaction **ppCTrans,CTransData **ppCTransData)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::GetTransactionObjects",
                "this=%#x, %#x, %#x",
                this, ppCTrans, ppCTransData
                ));
                
    PerfDbgLog(tagCBindCtx, this, "+CBindCtx::GetTransactionObjects");
    TransAssert(( _dwThreadId == GetCurrentThreadId() ));

    HRESULT hr = NOERROR;
    if (_pCTrans)
    {

        *ppCTrans = _pCTrans;
        _pCTrans->AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
        *ppCTrans = NULL;
    }

    if (_pCTransData && ppCTransData)
    {

        *ppCTransData = _pCTransData;
        _pCTransData->AddRef();
    }
    else
    {   
        if (!_pCTrans)
        {
            hr = E_NOINTERFACE;
        }
        if (ppCTransData)
        {
            *ppCTransData = NULL;
        }
    }

    PerfDbgLog1(tagCBindCtx, this, "-CBindCtx::GetTransactionObjects (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::SetTransData
//
//  Synopsis:
//
//  Arguments:  [pCTransData] --
//
//  Returns:
//
//  History:    10-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindCtx::SetTransData(CTransData *pCTransData)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::SetTransData",
                "this=%#x, %#x",
                this, pCTransData
                ));
                
    PerfDbgLog(tagCBindCtx, this, "+CBindCtx::SetTransData");
    TransAssert(( _dwThreadId == GetCurrentThreadId() ));

    if (pCTransData != _pCTransData)
    {
        if (_pCTransData)
        {
            _pCTransData->Release();
        }
        _pCTransData = pCTransData;
        if (_pCTransData)
        {
            _pCTransData->AddRef();
        }
    }

    PerfDbgLog(tagCBindCtx, this, "-CBindCtx::SetTransData (hr:0)");

    DEBUG_LEAVE(NOERROR);
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Method:     CBindCtx::GetTransData
//
//  Synopsis:
//
//  Arguments:  [ppCTransData] --
//
//  Returns:
//
//  History:    10-09-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP CBindCtx::GetTransData(CTransData **ppCTransData)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBindCtx::GetTransData",
                "this=%#x, %#x",
                this, ppCTransData
                ));
                
    PerfDbgLog(tagCBindCtx, this, "+CBindCtx::GetTransData");
    TransAssert(( _dwThreadId == GetCurrentThreadId() ));

    HRESULT hr = NOERROR;
    if (_pCTransData)
    {

        *ppCTransData = _pCTransData;
        _pCTransData->AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
        *ppCTransData = NULL;
    }

    PerfDbgLog1(tagCBindCtx, this, "-CBindCtx::GetTransData (hr:%lx)", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\trans\cnetstrm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cnetstrm.cxx
//
//  Contents:   Implements the stream: protocol
//
//  Classes:    CINetStream
//
//  Functions:
//
//  History:    5/3/96 Created Craig Critchley [craigc]
//
//----------------------------------------------------------------------------
#include <trans.h>


//+---------------------------------------------------------------------------
//
//  Method:     CINetStream::CINetStream
//
//  Synopsis:   Constructs a stream protcol object
//
//  Arguments:  rclsid
//
//  Returns:
//
//  History:    5/3/96 Created Craig Critchley [craigc]
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetStream::CINetStream(REFCLSID rclsid, IUnknown *pUnkOuter) : CINet(rclsid,pUnkOuter)
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CINetStream::CINetStream",
                "this=%#x, %#x, %#x",
                this, &rclsid, pUnkOuter
                ));
                
   _dwIsA = DLD_PROTOCOL_STREAM;
   _pstm = NULL;

   DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetStream::~CINetStream
//
//  Synopsis:   destroys a stream protocol object
//
//  Arguments:
//
//  Returns:
//
//  History:    5/3/96 Created Craig Critchley [craigc]
//
//  Notes:
//
//----------------------------------------------------------------------------
CINetStream::~CINetStream()
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CINetStream::~CINetStream",
                "this=%#x",
                this
                ));
                
    if (_pstm)
    {
        _pstm->Release();
    }

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetStream::INetAsyncOpen
//
//  Synopsis:   opens and synchronously downloads data from a stream
//
//  Arguments:  rclsid
//
//  Returns:
//
//  History:    5/3/96 Created Craig Critchley [craigc]
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetStream::INetAsyncOpen()
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CINetStream::INetAsyncOpen",
                "this=%#x",
                this
                ));
                
   IBindCtx * pbc = 0;
   IMoniker * pmk = 0;
   IStream * pstm = 0;
   IParseDisplayName * pParser = 0;
   STATSTG stat;
   CLSID clsid;
   CHAR szDisplayName[MAX_PATH];
   WCHAR wzDisplayName[MAX_PATH];
   WCHAR wzProgId[MAX_PATH];
   LPSTR pa, psz;
   LPWSTR pwz, pwzI;
   int cch;
   HRESULT hr = E_NOTIMPL;
   ULONG cchE;
   BOOL fGotMIMEType = FALSE;

   ReportNotification(BINDSTATUS_SENDINGREQUEST);

   // need one of these
   //
   if (FAILED(hr = CreateBindCtx(0,&pbc)))
      goto End;

   //   form is mk:@progid:moniker
   //
   strcpy(szDisplayName,GetServerName());
   strcat(szDisplayName,psz = GetObjectName());

   // if the moniker has a file extension, try to
   // determine the MIME type that way...
   //
   psz = FindFileExtension(psz);
   if (psz)
   {
       char szMime[MAX_PATH];
       DWORD cb = MAX_PATH;

       if (SUCCEEDED(GetMimeFromExt(psz,szMime,&cb)))
       {
           ReportNotification(BINDSTATUS_MIMETYPEAVAILABLE, szMime);
           fGotMIMEType = TRUE;
       }
   }

   A2W(szDisplayName,wzDisplayName,MAX_PATH);

   //   find progid
   //
   for (pwz = wzDisplayName, pwzI = wzProgId; *pwz; pwz++)
   {
       if (*pwz == '@')
       {
           pwzI = wzProgId;
       }
       else if (*pwz == ':')
       {
           *pwzI = 0;

           // the remainder may have a filename with a useful
           // extension... just in case, set the filename...
           //
           LPSTR pszStr = DupW2A(pwz+1);
           if (pszStr)
           {
               ReportNotification(BINDSTATUS_CACHEFILENAMEAVAILABLE, pszStr);
               delete pszStr;
           }

           break;
       }
       else
       {
           *pwzI++ = *pwz;
       }
   }

#if 0
   if (FAILED(hr = MkParseDisplayName(pbc,wzDisplayName,&cchE,&pmk)) && pmk)
       goto End;
#else
   // BUGBUG
   //
   //   MkParseDisplayName was opening another instance of app
   //   force inproc server.  ick.
   //

   if (FAILED(hr = CLSIDFromProgID(wzProgId,&clsid)))
   {
       goto End;
   }

   if (FAILED(hr = CoCreateInstance(clsid,0,CLSCTX_INPROC_SERVER,
                                    IID_IParseDisplayName,(void**)&pParser)))
   {
       goto End;
   }

   TransAssert((pParser));

   if (FAILED(hr = pParser->ParseDisplayName(pbc,wzDisplayName,&cchE,&pmk)))
   {
       goto End;
   }

   TransAssert((pmk));

#endif

   if (FAILED(hr = pmk->BindToStorage(pbc,0,IID_IStream,(void**)&pstm)))
   {
      hr = INET_E_RESOURCE_NOT_FOUND;
      goto End;
   }

   TransAssert((hr != MK_S_ASYNCHRONOUS));
   TransAssert((pstm));

   _pstm = pstm;
   _pstm->AddRef();

   // now we have a stream - stuff it into the trans data
   //
   if (FAILED(hr = pstm->Stat(&stat,STATFLAG_NONAME)))
   {
       goto End;
   }

   _cbTotalBytesRead = stat.cbSize.LowPart;
   _cbDataSize = stat.cbSize.LowPart;

   hr = _pCTrans->ReportData(BSCF_FIRSTDATANOTIFICATION | BSCF_LASTDATANOTIFICATION, stat.cbSize.LowPart,stat.cbSize.LowPart);

   _hrError = INET_E_DONE;

End:

   if (FAILED(hr))
   {
        SetCNetBindResult(GetLastError());
        _hrError = INET_E_RESOURCE_NOT_FOUND;
        ReportResultAndStop(_hrError);
   }

   // play nice, no leaks
   //
   if (pParser)
   {
      pParser->Release();
   }

   if (pmk)
   {
      pmk->Release();
   }
   if (pbc)
   {
      pbc->Release();
   }
   if (pstm)
   {
      pstm->Release();
   }

   // make sure I set this any way I get out
   //
   TransAssert((hr != E_NOTIMPL));

   DEBUG_LEAVE(hr);
   return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetStream::ReadDataHere
//
//  Synopsis:
//
//  Arguments:  [pBuffer] --
//              [cbBytes] --
//              [pcbBytes] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetStream::ReadDataHere(BYTE *pBuffer, DWORD cbBytes, DWORD *pcbBytes)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CINetStream::ReadDataHere",
                "this=%#x, %#x, %#x, %#x",
                this, pBuffer, cbBytes, pcbBytes
                ));
            
    TransDebugOut((DEB_PROT, "%p _IN CINetStream::ReadDataHere\n", this));
    HRESULT hr = E_FAIL;

    TransAssert((cbBytes && pcbBytes));


    if (_pstm)
    {
        hr = _pstm->Read(pBuffer,cbBytes,pcbBytes);
    }

    TransDebugOut((DEB_PROT, "%p OUT CINetStream::ReadDataHere (_hrError:%lx, [hr:%lx,cbBytesAsked:%ld,cbBytesReturned:%ld]) \n",
                                this, _hrError, hr, cbBytes, *pcbBytes));

    DEBUG_LEAVE(hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     CINetStream::INetSeek
//
//  Synopsis:
//
//  Arguments:  [DWORD] --
//              [ULARGE_INTEGER] --
//              [plibNewPosition] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetStream::INetSeek(LARGE_INTEGER dlibMove,DWORD dwOrigin,ULARGE_INTEGER *plibNewPosition)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CINetStream::INetSeek",
                "this=%#x, %#x, %#x, %#x",
                this, dlibMove, dwOrigin, plibNewPosition
                ));
                
    TransDebugOut((DEB_PROT, "%p _IN CINetStream::INetSeek\n", this));
    HRESULT hr = E_FAIL;

    if (_pstm)
    {
        hr = _pstm->Seek(dlibMove, dwOrigin, plibNewPosition);
    }

    TransDebugOut((DEB_PROT, "%p OUT CINetStream::INetSeek (hr:%lx) \n",this, hr));

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetStream::LockFile
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  History:    8-13-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetStream::LockFile(BOOL fRetrieve)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CINetStream::LockFile",
                "this=%#x, %B",
                this, fRetrieve
                ));
                
    TransDebugOut((DEB_PROT, "%p _IN CINetStream::LockFile\n", this));
    HRESULT hr = NOERROR;

    // nothing to do for now

    TransDebugOut((DEB_PROT,"%p OUT CINetStream::LockFile (hr:%lx)\n",this, hr));

    DEBUG_LEAVE(hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CINetStream::UnlockFile
//
//  Synopsis:   unlocks the file
//
//  Arguments:  (none)
//
//  Returns:
//
//  History:    8-13-96   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CINetStream::UnlockFile()
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CINetStream::UnlockFile",
                "this=%#x",
                this
                ));
                
    TransDebugOut((DEB_PROT, "%p IN CINetStream::UnlockFile\n", this));
    HRESULT hr = NOERROR;

    // nothing to do for now

    TransDebugOut((DEB_PROT,"%p OUT CINetStream::UnlockFile (hr:%lx)\n", this, hr));

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\trans\datasnif.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       datasnif.cxx
//
//  Contents:   Stream Mime type checking (attempts to guess the MIME type
//              of a buffer by simple pattern matching).
//
//  Classes:    CContentAnalyzer
//
//  Functions:  private:
//                CContentAnalyzer::SampleData
//                CContentAnalyzer::IsBMP
//                CContentAnalyzer::GetDataFormat
//                CContentAnalyzer::FormatAgreesWithData
//                CContentAnalyzer::MatchDWordAtOffset
//                CContentAnalyzer::FindAppFromExt
//                CContentAnalyzer::CheckTextHeaders
//                CContentAnalyzer::CheckBinaryHeaders
//
//              public:
//                CContentAnalyzer::FindMimeFromData
//                ::FindMimeFromData
//
//
//  History:    05-25-96   AdriaanC (Adriaan Canter) Created
//              07-16-96   AdriaanC (Adriaan Canter) Modified
//              08-06-96   AdriaanC (Adriaan Canter) Modified
//              08-14-96   AdriaanC (Adriaan Canter) Modified
//
//----------------------------------------------------------------------------

#include <trans.h>
#include "datasnif.hxx"
#include <shlwapip.h>
#ifdef UNIX
#include <mainwin.h>
#endif

PerfDbgTag(tagDataSniff, "Urlmon", "Log DataSniff", DEB_DATA);

// Max no. bytes to look at
#define SAMPLE_SIZE 256

// Registry Key for app/fileext associations
#define szApplicationRegistryKey "\\Shell\\Open\\Command"
#define szApplicationRegistryKey2 "\\Shell\\Connect To\\Command"
#define szMimeRegistryKey        "MIME\\Database\\Content Type\\"

// Magic header words
#define AU_SUN_MAGIC                    0x2e736e64
#define AU_SUN_INV_MAGIC                0x646e732e
#define AU_DEC_MAGIC                    0x2e736400
#define AU_DEC_INV_MAGIC                0x0064732e
#define AIFF_MAGIC                      0x464f524d
#define AIFF_INV_MAGIC                  0x4d524f46
#define AIFF_MAGIC_MORE_1               'AIFF'
#define AIFF_MAGIC_MORE_2               'AIFC'
#define RIFF_MAGIC                      0x52494646
#define AVI_MAGIC                       0x41564920
#define WAV_MAGIC                       0x57415645
#define JAVA_MAGIC                      0xcafebabe
#define MPEG_MAGIC                      0x000001b3
#define MPEG_MAGIC_2                    0x000001ba
#define EMF_MAGIC_1                     0x01000000
#define EMF_MAGIC_2                     0x20454d46
#define WMF_MAGIC                       0xd7cdc69a
#define JPEG_MAGIC_1                    0xFF
#define JPEG_MAGIC_2                    0xD8

// Magic header text
CHAR vszRichTextMagic[] =                "{\\rtf";
CHAR vszPostscriptMagic[] =              "%!";
CHAR vszBinHexMagic[] =                  "onverted with BinHex";
CHAR vszBase64Magic[] =                  "begin";
CHAR vszGif87Magic[] =                   "GIF87";
CHAR vszGif89Magic[] =                   "GIF89";
CHAR vszTiffMagic[] =                    "MM";
CHAR vszBmpMagic[] =                     "BM";
CHAR vszZipMagic[] =                     "PK";
CHAR vszExeMagic[] =                     "MZ";
CHAR vszPngMagic[] =                     "\211PNG\r\n\032\n";
CHAR vszCompressMagic[] =                "\037\235";
CHAR vszGzipMagic[] =                    "\037\213";
CHAR vszXbmMagic1[] =                    "define";
CHAR vszXbmMagic2[] =                    "width";
CHAR vszXbmMagic3[] =                    "bits";
CHAR vszPdfMagic[] =                     "%PDF";
CHAR vszJGMagic[] =                      "JG";
CHAR vszMIDMagic[] =                     "MThd";

// null MIME type
WCHAR vwzNULL[] =                        L"(null)";

// 7 bit MIME Types
WCHAR vwzTextPlain[] =                   L"text/plain";
WCHAR vwzTextRichText[] =                L"text/richtext";
WCHAR vwzImageXBitmap[] =                L"image/x-xbitmap";
WCHAR vwzApplicationPostscript[] =       L"application/postscript";
WCHAR vwzApplicationBase64[] =           L"application/base64";
WCHAR vwzApplicationMacBinhex[] =        L"application/macbinhex40";
WCHAR vwzApplicationPdf[] =              L"application/pdf";
WCHAR vwzApplicationCDF[] =              L"application/x-cdf";
WCHAR vwzApplicationNETCDF[] =           L"application/x-netcdf";
WCHAR vwzmultipartmixedreplace[] =       L"multipart/x-mixed-replace";
WCHAR vwzmultipartmixed[] =              L"multipart/mixed";
WCHAR vwzTextScriptlet[] =               L"text/scriptlet";
WCHAR vwzTextComponent[] =               L"text/x-component";
WCHAR vwzTextXML[] =                     L"text/xml";
WCHAR vwzApplicationHTA[] =              L"application/hta";

// 8 bit MIME types
WCHAR vwzAudioAiff[] =                   L"audio/x-aiff";
WCHAR vwzAudioBasic[] =                  L"audio/basic";
WCHAR vwzAudioWav[] =                    L"audio/wav";
WCHAR vwzAudioMID[] =                    L"audio/mid";
WCHAR vwzImageGif[] =                    L"image/gif";
WCHAR vwzImagePJpeg[] =                  L"image/pjpeg";
WCHAR vwzImageJpeg[] =                   L"image/jpeg";
WCHAR vwzImageTiff[] =                   L"image/tiff";
WCHAR vwzImagePng[] =                    L"image/x-png";
WCHAR vwzImageBmp[] =                    L"image/bmp";
WCHAR vwzImageJG[] =                     L"image/x-jg";
WCHAR vwzImageEmf[] =                    L"image/x-emf";
WCHAR vwzImageWmf[] =                    L"image/x-wmf";
WCHAR vwzVideoAvi[] =                    L"video/avi";
WCHAR vwzVideoMpeg[] =                   L"video/mpeg";
WCHAR vwzApplicationCompressed[] =       L"application/x-compressed";
WCHAR vwzApplicationZipCompressed[] =    L"application/x-zip-compressed";
WCHAR vwzApplicationGzipCompressed[] =   L"application/x-gzip-compressed";
WCHAR vwzApplicationJava[] =             L"application/java";
WCHAR vwzApplicationMSDownload[] =       L"application/x-msdownload";

// 7 or 8 bit MIME types
WCHAR vwzTextHTML[] =                    L"text/html";
WCHAR vwzApplicationOctetStream[] =      L"application/octet-stream";




//+---------------------------------------------------------------------------
//
//  Method:     CContentAnalyzer::SampleData
//
//  Synopsis:
//
//  Arguments:  (void)
//
//  Returns:    (void)
//
//  History:    5-25-96   AdriaanC (Adriaan Canter) Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void CContentAnalyzer::SampleData()
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CContentAnalyzer::SampleData",
                "this=%#x",
                this
                ));
                
    BOOL fFoundFirstXBitMapTag = FALSE;
    BOOL fFoundSecondXBitMapTag = FALSE;
    BOOL fFoundAsciiChar = FALSE;

    int nHTMLConfidence = 0;

    unsigned char *p = (unsigned char*) _pBuf;

    _cbNL = _cbCR = _cbFF = _cbText = _cbCtrl = _cbHigh = 0;

    // Count incidence of character types.
    for (int i = 0; i < _cbSample - 1; i++)
    {
        fFoundAsciiChar = FALSE;

        if (*p == '\n')           // new line
        {
            _cbNL++;
        }
        else if (*p == '\r')      // carriage return
        {
            _cbCR++;
        }
        else if (*p == '\f')      // form feed
        {
            _cbFF++;
        }
        else if (*p == '\t')      // tab
        {
            _cbText++;
        }
        else if (*p < 32)         // control character
        {
            _cbCtrl++;
        }
        else if (*p >= 32 && *p < 128)        // regular text
        {
            _cbText++;
            fFoundAsciiChar = TRUE;
        }
        else                      // extended text
        {
            _cbHigh++;
        }

        if (fFoundAsciiChar)
        {
            // check for html
            if (*p == '<')
            {
                if (!StrCmpNIC((char*) p+1, "?XML", sizeof("?XML") - 1) &&
                    (
                        (*(p+5) == ':') || 
                        (*(p+5) == ' ') || 
                        (*(p+5) == '\t')) )
                {
                    _fFoundXML = TRUE;
                    // don't break : for CDF
                }
                

                if (!StrCmpNIC((char*) p+1, "SCRIPTLET", sizeof("SCRIPTLET") - 1))
                {
                    _fFoundTextScriptlet = TRUE;
                    break;
                }

                if (!StrCmpNIC((char*) p+1, "HTML", sizeof("HTML") - 1)
                    || !StrCmpNIC((char*) p+1, "HEAD", sizeof("HEAD") - 1)
                    || !StrCmpNIC((char*) p+1, "TITLE", sizeof("TITLE") - 1)
                    || !StrCmpNIC((char*) p+1, "BODY", sizeof("BODY") - 1)
                    || !StrCmpNIC((char*) p+1, "SCRIPT", sizeof("SCRIPT") - 1)
                    || !StrCmpNIC((char*) p+1, "A HREF", sizeof("A HREF") - 1)
                    || !StrCmpNIC((char*) p+1, "PRE", sizeof("PRE") - 1)
                    || !StrCmpNIC((char*) p+1, "IMG", sizeof("IMG") - 1)
                    || !StrCmpNIC((char*) p+1, "PLAINTEXT", sizeof("PLAINTEXT") - 1)
                    || !StrCmpNIC((char*) p+1, "TABLE", sizeof("TABLE") - 1))
                {
                    _fFoundHTML = TRUE;
                    break;
                }
                else if (   !StrCmpNIC((char*) p+1, "HR", sizeof("HR") - 1)
                         || !StrCmpNIC((char*) p+1, "A", sizeof("A") - 1)
                         || !StrCmpNIC((char*) p+1, "/A", sizeof("/A") - 1)
                         || !StrCmpNIC((char*) p+1, "B", sizeof("B") - 1)
                         || !StrCmpNIC((char*) p+1, "/B", sizeof("/B") - 1)
                         || !StrCmpNIC((char*) p+1, "P", sizeof("P") - 1)
                         || !StrCmpNIC((char*) p+1, "/P", sizeof("/P") - 1)
                         || !StrCmpNIC((char*) p+1, "!--", sizeof("!--") - 1)
                        )
                {
                    //
                    // In order for this branch to identify this is HTML 
                    // We have to make sure:
                    //      1. some HTML control char exists
                    //      2. We've scanned the whole data block
                    //      3. 2/3 of the data should be text
                    //
                     
                    nHTMLConfidence += 50;
                    if (    nHTMLConfidence >= 100
                        &&  i == _cbSample - 1 
                        &&  _cbText >= ((_cbSample * 2) / 3)
                       )
                    {
                        _fFoundHTML = TRUE;
                        break;
                    }
                }
                if (!StrCmpNIC((char*) p+1, "CHANNEL", sizeof("CHANNEL") - 1))
                {
                    _fFoundCDF = TRUE;
                    break;
                }
        
            
            }
            else if (!StrCmpNIC((char*) p, "-->", sizeof("-->") - 1))
            {
                // comment begin
                // I really want to make sure that most of the 
                // char are printable 
                // potential issue: International code page?
                nHTMLConfidence += 50;
                if (   (nHTMLConfidence >= 100) 
                    && (i == _cbSample - 1 )
                    && (_cbText > (_cbSample * 2 /3) )
                   )
                {
                    _fFoundHTML = TRUE;
                    break;
                }
            }
            // check for xbitmap
            else if (*p == '#')
            {
                if (!StrCmpNC((char*) p+1, vszXbmMagic1, sizeof(vszXbmMagic1) - 1))
                    fFoundFirstXBitMapTag = TRUE;
            }
            else if (*p == '_' && fFoundSecondXBitMapTag)
            {
                if (!StrCmpNC((char*) p+1, vszXbmMagic3, sizeof(vszXbmMagic3) - 1))
                {
                    _fFoundXBitMap = TRUE;
                    break;
                }
            }
            else if (*p == '_' && fFoundFirstXBitMapTag)
            {
                if (!StrCmpNC((char*) p+1, vszXbmMagic2, sizeof(vszXbmMagic2) - 1))
                    fFoundSecondXBitMapTag = TRUE;
            }

            // MacBinhex
            else if (*p == 'c')
            {
                if (!StrCmpNC((char*) p+1, vszBinHexMagic, sizeof(vszBinHexMagic) - 1))
                {
                    _fFoundMacBinhex = TRUE;
                    break;
                }
            }

        }
        p++;
    }

    DEBUG_LEAVE(0);
}

//+---------------------------------------------------------------------------
//
//  Method:     CContentAnalyzer::IsBMP
//
//  Synopsis:
//
//  Arguments:  (void)
//
//  Returns:    BOOL
//
//  History:    5-25-96   AdriaanC (Adriaan Canter) Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CContentAnalyzer::IsBMP()
{
    DEBUG_ENTER((DBG_TRANS,
                Bool,
                "CContentAnalyzer::IsBMP",
                "this=%#x",
                this
                ));
                
    BOOL bRetVal = TRUE;

    BITMAPFILEHEADER UNALIGNED *pBMFileHdr;

    if (_cbSample < 2)
    {
        bRetVal = FALSE;
    }

    // Check header
    if (StrCmpNC(_pBuf, vszBmpMagic, sizeof(vszBmpMagic) - 1))
    {
        bRetVal = FALSE;
    }

    // Sample size needs to be big enough.
    if (_cbSample < sizeof(BITMAPFILEHEADER))
    {
        bRetVal = FALSE;
    }

    pBMFileHdr = (BITMAPFILEHEADER*)(_pBuf);

#ifdef UNIX

    /* Use 14 on Unix, because we want the size without the padding
     * done on Unix. sizeof(BITMAPFILEHEADER) = 16 on Unix with padding
     */
    #define UNIX_BITMAP_HEADER_SIZE 14
    BITMAPFILEHEADER bmFileHeader;

    if(MwReadBITMAPFILEHEADER((LPBYTE)_pBuf, UNIX_BITMAP_HEADER_SIZE, &bmFileHeader))
        pBMFileHdr = &bmFileHeader;

#endif /* UNIX */

    // The reserved fields must be set to 0
    if (pBMFileHdr->bfReserved1!=0 || pBMFileHdr->bfReserved2!=0)
    {
        bRetVal = FALSE;
    }

    DEBUG_LEAVE(bRetVal);
    return bRetVal;
}

//+---------------------------------------------------------------------------
//
//  Method:     CContentAnalyzer::GetDataFormat
//
//  Synopsis:
//
//  Arguments:  (WCHAR* wzMimeType)
//
//  Returns:    BOOL dwDataFormat
//
//  History:    7-21-96   AdriaanC (Adriaan Canter) Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CContentAnalyzer::GetDataFormat(LPCWSTR wzMimeType)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CContentAnalyzer::GetDataFormat",
                "this=%#x, %.80wq",
                this, wzMimeType
                ));
                
    CLIPFORMAT cfFormat;
    DATAFORMAT dwDataFormat;
    HRESULT hr;

    if (!wzMimeType)
    {
        DEBUG_LEAVE(DATAFORMAT_AMBIGUOUS);
        return DATAFORMAT_AMBIGUOUS;
    }

    if( !_wcsicmp(wzMimeType, vwzNULL) )
    {
        DEBUG_LEAVE(DATAFORMAT_AMBIGUOUS);
        return DATAFORMAT_AMBIGUOUS;
    }


    hr = FindMediaTypeFormat(wzMimeType, &cfFormat, (DWORD *)&dwDataFormat);

    if (hr == S_OK)
    {
        DEBUG_LEAVE(dwDataFormat);
        return dwDataFormat;
    }
    else
    {
        DEBUG_LEAVE(DATAFORMAT_UNKNOWN);
        return DATAFORMAT_UNKNOWN;
    }

}

//+---------------------------------------------------------------------------
//
//  Method:     CContentAnalyzer::FormatAgreesWithData
//
//  Synopsis:
//
//  Arguments:  (void)
//
//  Returns:    BOOL
//
//  History:    8-14-96   AdriaanC (Adriaan Canter) Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CContentAnalyzer::FormatAgreesWithData(DWORD dwFormat)
{
    DEBUG_ENTER((DBG_TRANS,
                Bool,
                "CContentAnalyzer::FormatAgreesWithData",
                "this=%#x, %#x",
                this, dwFormat
                ));
                
    if (dwFormat == DATAFORMAT_TEXT && _fBinary == FALSE
        || dwFormat == DATAFORMAT_BINARY && _fBinary == TRUE
        || dwFormat == DATAFORMAT_TEXTORBINARY)
    {
        DEBUG_LEAVE(TRUE);
        return TRUE;
    }

    DEBUG_LEAVE(FALSE);
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Method:     CContentAnalyzer::MatchDWordAtOffset
//
//  Synopsis:   Determines if a given magic word is found at
//              the specified offset.
//
//  Arguments:  (DWORD magic, int offset)
//
//  Returns:    BOOL
//
//  History:    5-25-96   AdriaanC (Adriaan Canter) Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CContentAnalyzer::MatchDWordAtOffset(DWORD magic, int offset)
{
    DEBUG_ENTER((DBG_TRANS,
                Bool,
                "CContentAnalyzer::MatchDWordAtOffset",
                "this=%#x, %#x, %d",
                this, magic, offset
                ));
                
    BOOL bRetVal = TRUE;

    DWORD dwWord = 0;

    unsigned char* p = (unsigned char*) _pBuf;

    if (_cbSample < offset + (int) sizeof(DWORD))
    {
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }

    dwWord = (p[offset] << 24)
        | (p[offset+1] << 16)
        | (p[offset+2] << 8)
        |  p[offset+3];


    if (magic != dwWord)
    {
        bRetVal = FALSE;
    }

    DEBUG_LEAVE(bRetVal);
    return bRetVal;
}


//+---------------------------------------------------------------------------
//
//  Method:     CContentAnalyzer::FindAppFromExt
//
//  Synopsis:   Determines an associated application from
//              a given file extension
//
//  Arguments:  (LPSTR pszExt, LPSTR pszCommand (command line))
//
//  Returns:    BOOL (Associated Application is found or not)
//
//  History:    7-15-96   AdriaanC (Adriaan Canter) Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CContentAnalyzer::FindAppFromExt(LPSTR pszExt, LPSTR pszCommand, DWORD cbCommand)
{
    DEBUG_ENTER((DBG_TRANS,
                Bool,
                "CContentAnalyzer::FindAppFromExt",
                "this=%#x, %.80q, %.80q, %d",
                this, pszExt, pszCommand, cbCommand
                ));
                
    DWORD cbLen, dwType;
    CHAR szRegPath[MAX_PATH];
    BOOL fReturn = FALSE;
    HKEY hMimeKey = NULL;

    // BUGBUG - Is there a max registry path length?
    cbLen = MAX_PATH;

    // Should be a file extension
    TransAssert((pszExt[0] == '.'));

    // Open key on extension
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, pszExt, 0,
        KEY_QUERY_VALUE, &hMimeKey) == ERROR_SUCCESS)
    {
        // Find file type (txtfile, htmlfile, etc) .
        // These currently utilize a null key.
        if (RegQueryValueEx(hMimeKey, NULL, NULL, &dwType,
            (LPBYTE)szRegPath, &cbLen) == ERROR_SUCCESS)
        {
            strncat(szRegPath, szApplicationRegistryKey, MAX_PATH - strlen(szRegPath) - 1);

            HKEY hAppKey = NULL;
            cbLen = cbCommand;

            // szRegPath should now look similar to
            // "txtfile\Shell\Open\Command". Open key on szRegPath
            if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szRegPath, 0,
                KEY_QUERY_VALUE, &hAppKey) == ERROR_SUCCESS) 
            {
                // Find the application command line - again, null key.
                if (RegQueryValueEx(hMimeKey, NULL, NULL, &dwType,
                    (LPBYTE)pszCommand, &cbLen) == ERROR_SUCCESS)
                {
                    // Success
                    fReturn = TRUE;
                }
                RegCloseKey(hAppKey);
            }

            else 
            {   
                // check "Shell\\Connect To\command" key - used by SmartTerm 

                // dynamic allocate szRegPath2 so that it won't take
                // unnecessary stack space - after all, this is not a 
                // common case
                CHAR* szRegPath2 = NULL;
                HKEY hAppKey2 = NULL;

                szRegPath2 = new CHAR[MAX_PATH];
                if( szRegPath2 )
                {
                    if (RegQueryValueEx(hMimeKey, NULL, NULL, &dwType,
                        (LPBYTE)szRegPath2, &cbLen) == ERROR_SUCCESS)
                    {
                        strncat(szRegPath2, szApplicationRegistryKey2, 
                            MAX_PATH - strlen(szRegPath2) - 1);
                    }
                    else
                    {
                        // this should not happen at all 
                        delete [] szRegPath2;
                        szRegPath2 = NULL;
                    }
                }

                if (szRegPath2 && 
                    RegOpenKeyEx(HKEY_CLASSES_ROOT, szRegPath2, 0, KEY_QUERY_VALUE, &hAppKey2) == ERROR_SUCCESS) 
                {
                    if (RegQueryValueEx(hMimeKey, NULL, NULL, &dwType,
                        (LPBYTE)pszCommand, &cbLen) == ERROR_SUCCESS)
                    {
                        // Success
                        fReturn = TRUE;
                    }
                    RegCloseKey(hAppKey2);

                }

                delete [] szRegPath2;
            }

        }
        RegCloseKey(hMimeKey);
    }

    DEBUG_LEAVE(fReturn);
    return fReturn;
}
//+---------------------------------------------------------------------------
//
//  Method:     CContentAnalyzer::CheckTextHeaders
//
//  Synopsis:
//
//
//  Arguments:  void
//
//  Returns:    void
//
//  History:    7-23-96   AdriaanC (Adriaan Canter) Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CContentAnalyzer::CheckTextHeaders()
{
    DEBUG_ENTER((DBG_TRANS,
                Bool,
                "CContentAnalyzer::CheckTextHeaders",
                "this=%#x",
                this
                ));
                
    BOOL bRet = TRUE;
    // application/pdf (Acrobat)
    if (!StrCmpNC(_pBuf, vszPdfMagic, sizeof(vszPdfMagic) - 1))
    {
        _wzMimeType = vwzApplicationPdf;
    }

    // application/Postscript
    else if (!StrCmpNC(_pBuf, vszPostscriptMagic, sizeof(vszPostscriptMagic) - 1))
    {
        _wzMimeType = vwzApplicationPostscript;
    }

    // text/richtext
    else if (!StrCmpNC(_pBuf, vszRichTextMagic, sizeof(vszRichTextMagic) - 1))
    {
        _wzMimeType = vwzTextRichText;
    }

    // application/base64
    else if (!StrCmpNC(_pBuf, vszBase64Magic, sizeof(vszBase64Magic) - 1))
    {
        _wzMimeType = vwzApplicationBase64;
    }

    // No matches - assume plain text.
    else
    {
        //_wzMimeType = vwzTextPlain;
        bRet = FALSE;
    }

    DEBUG_LEAVE(bRet);
    return bRet;

}

//+---------------------------------------------------------------------------
//
//  Method:     CContentAnalyzer::CheckBinaryHeaders
//
//  Synopsis:
//
//
//  Arguments:  void
//
//  Returns:    void
//
//  History:    7-23-96   AdriaanC (Adriaan Canter) Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CContentAnalyzer::CheckBinaryHeaders()
{
    DEBUG_ENTER((DBG_TRANS,
                Bool,
                "CContentAnalyzer::CheckBinaryHeaders",
                "this=%#x",
                this
                ));
                
    BOOL bRet = TRUE;
    // image/gif
    if (!StrCmpNIC(_pBuf, vszGif87Magic, sizeof(vszGif87Magic) - 1)
        || !StrCmpNIC(_pBuf, vszGif89Magic, sizeof(vszGif89Magic) - 1))
    {
        _wzMimeType = vwzImageGif;
    }

    // image/pjpeg
    else if ((BYTE)_pBuf[0] == JPEG_MAGIC_1 && (BYTE)_pBuf[1] == JPEG_MAGIC_2)
    {
        _wzMimeType = vwzImagePJpeg;
    }

    // img/bmp
    else if (IsBMP())
    {
        _wzMimeType = vwzImageBmp;
    }

    // audio/wav
    else if (MatchDWordAtOffset(RIFF_MAGIC, 0)
        && MatchDWordAtOffset(WAV_MAGIC, 8))
    {
        _wzMimeType = vwzAudioWav;
    }

    // audio/basic (.au files)
    else if (MatchDWordAtOffset(AU_DEC_MAGIC, 0)
           || MatchDWordAtOffset(AU_SUN_MAGIC, 0)
           || MatchDWordAtOffset(AU_DEC_INV_MAGIC, 0)
           || MatchDWordAtOffset(AU_SUN_INV_MAGIC, 0))
    {
       _wzMimeType = vwzAudioBasic;
    }

    // image/tiff
    else if (!StrCmpC(_pBuf, vszTiffMagic)) // "MM" followed by a \0
    {
        _wzMimeType = vwzImageTiff;
    }

    // application/x-msdownload
    else if (!StrCmpNC(_pBuf, vszExeMagic, sizeof(vszExeMagic) - 1))
    {
        _wzMimeType = vwzApplicationMSDownload;
    }

    // image/x-png
    else if (!StrCmpNC(_pBuf, vszPngMagic, sizeof(vszPngMagic) - 1))
    {
        _wzMimeType = vwzImagePng;
    }

    // image/x-jg
    else if (!StrCmpNC(_pBuf, vszJGMagic, sizeof(vszJGMagic) - 1)
        && (int) _pBuf[2] >= 3
        && (int) _pBuf[2] <= 31
        && _pBuf[4] == 0)
    {
        _wzMimeType = vwzImageJG;
    }

    // audio/x-aiff
    else if (MatchDWordAtOffset(AIFF_INV_MAGIC, 0))
    {
       _wzMimeType = vwzAudioAiff;
    }

    else if (MatchDWordAtOffset(AIFF_MAGIC, 0) &&
             ( MatchDWordAtOffset(AIFF_MAGIC_MORE_1, 8) ||
               MatchDWordAtOffset(AIFF_MAGIC_MORE_2, 8) ) )
    {
        //
        // according to DaveMay, the correct AIFF format would be:
        // 'FORM....AIFF' or 'FORM....AIFC'
        // Only check for 'FORM' is incorrect because .sc2 has the 
        // same sig
        //
       _wzMimeType = vwzAudioAiff;
    }

    // video/avi (or video/x-msvedio)
    else if (MatchDWordAtOffset(RIFF_MAGIC, 0)
        && MatchDWordAtOffset(AVI_MAGIC, 8))
    {
        _wzMimeType = vwzVideoAvi;
    }

    // video/mpeg
    else if (MatchDWordAtOffset(MPEG_MAGIC, 0)
            || MatchDWordAtOffset(MPEG_MAGIC_2, 0) )
    {
        _wzMimeType = vwzVideoMpeg;
    }

    // image/x-emf
    else if (MatchDWordAtOffset(EMF_MAGIC_1, 0)
        && MatchDWordAtOffset(EMF_MAGIC_2, 40))
    {
        _wzMimeType = vwzImageEmf;
    }

    // image/x-wmf
    else if (MatchDWordAtOffset(WMF_MAGIC, 0))
    {
        _wzMimeType = vwzImageWmf;
    }

    // application/java
    else if (MatchDWordAtOffset(JAVA_MAGIC, 0))
    {
        _wzMimeType = vwzApplicationJava;
    }

    // application/x-zip-compressed
    else if (!StrCmpNC(_pBuf, vszZipMagic, sizeof(vszZipMagic) - 1))
    {
        _wzMimeType = vwzApplicationZipCompressed;
    }

    // application/x-compress
    else if (!StrCmpNC(_pBuf, vszCompressMagic, sizeof(vszCompressMagic) - 1))
    {
        _wzMimeType = vwzApplicationCompressed;
    }

    // application/x-gzip
    else if (!StrCmpNC(_pBuf, vszGzipMagic, sizeof(vszGzipMagic) - 1))
    {
        _wzMimeType = vwzApplicationGzipCompressed;
    }

    // application/x-zip-compressed
    else if (!StrCmpNC(_pBuf, vszZipMagic, sizeof(vszZipMagic) - 1))
    {
        _wzMimeType = vwzApplicationZipCompressed;
    }

    // audio/mid
    else if (!StrCmpC(_pBuf, vszMIDMagic))
    {
        _wzMimeType = vwzAudioMID;
    }

    // application/pdf (Acrobat)
    else if (!StrCmpNC(_pBuf, vszPdfMagic, sizeof(vszPdfMagic) - 1))
    {
        _wzMimeType = vwzApplicationPdf;
    }

    // don't know what it is.
    else
    {
        //_wzMimeType = vwzApplicationOctetStream;
        bRet = FALSE;
    }

    DEBUG_LEAVE(bRet);
    return bRet;
}



//+---------------------------------------------------------------------------
//
//  Method:     CContentAnalyzer::FindMimeFromData
//
//  Synopsis:   Attempts to guess MIME type from buffer
//
//
//  Arguments:  pBuf, cbSample, wzSuggestedMimeType
//
//  Returns:    LPCWSTR (the MIME type guessed)
//
//  History:    5-25-96   AdriaanC (Adriaan Canter) Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPCWSTR CContentAnalyzer::FindMimeFromData(LPCWSTR wzFileName, char* pBuf,
    int cbSample, LPCWSTR wzSuggestedMimeType, DWORD grfFlags)
{
    DEBUG_ENTER((DBG_TRANS,
                Pointer,
                "CContentAnalyzer::FindMimeFromData",
                "this=%#x, %.80wq, %.80q, %d, %.80wq, %#x",
                this, wzFileName, pBuf, cbSample, wzSuggestedMimeType, grfFlags
                ));
                
    BOOL fSampledData = FALSE;
    BOOL fFoundMimeTypeFromExt = FALSE;

    CHAR* szFileExt = 0;
    CHAR szFileName[MAX_PATH];
    CHAR szMimeTypeFromExt[SZMIMESIZE_MAX];
    CHAR szCommand[MAX_PATH];
    CHAR cLastByte;

    DWORD dwMimeLen = SZMIMESIZE_MAX;
    DWORD dwExtMimeTypeDataFormat;
    DWORD dwSuggestedMimeTypeDataFormat;
    DWORD dwMimeTypeDataFormat;
    DWORD cbCommand = MAX_PATH;
    BOOL  fExtensionChecked = FALSE;

    _grfFlags = grfFlags;

    // BUGBUG - we can use this information for DBCS.
    // Remove any info appended to the suggested mime type
    // such as charset information. This is identified by ';'

    if (wzSuggestedMimeType)
    {
        WCHAR* wptr = wcsstr(wzSuggestedMimeType, L";");
        if (wptr)
        {
            *wptr = L'\0';
        }
    }

    // Check to see if the server is suggesting an unknown mime type
    dwSuggestedMimeTypeDataFormat = GetDataFormat(wzSuggestedMimeType);
    if (dwSuggestedMimeTypeDataFormat == DATAFORMAT_UNKNOWN)
    {
        // server push returns "multipart" content type 
        // this is not the real mimetype, so we have to sniff 
        // to find out the truth 
        if(    wcsicmp(wzSuggestedMimeType, vwzmultipartmixed)
            && wcsicmp(wzSuggestedMimeType, vwzmultipartmixedreplace) )
        {
            // If so, return the suggested mime type.
            _wzMimeType = (WCHAR*) wzSuggestedMimeType;

            DEBUG_LEAVE(_wzMimeType);
            return _wzMimeType;
        }
    }

/*****
    // check if we got an extension and extension mime
    // matches the suggested mime - only for text/plain
    if (    wzSuggestedMimeType 
        &&  wzFileName
        && !wcscmp(wzSuggestedMimeType,vwzTextPlain))
         
    {
        fExtensionChecked = TRUE;
        fFoundMimeTypeFromExt = FindMimeFromExt(
                                        wzFileName,
                                        szFileName,
                                        szMimeTypeFromExt,
                                        &dwExtMimeTypeDataFormat,
                                        &szFileExt
                                        );

        // If there is a mime type associated with the file
        // extension then return it.
        if (   fFoundMimeTypeFromExt
            && (dwExtMimeTypeDataFormat == dwSuggestedMimeTypeDataFormat)
            && !wcscmp(wzSuggestedMimeType,_wzMimeTypeFromExt)
            )
        {
            // If so, return the suggested mime type.
            _wzMimeType = (WCHAR*) wzSuggestedMimeType;
            return _wzMimeType;
        }
    }
*****/

    // Not enough data to tell anything
    if (!pBuf || cbSample <= 0)
    {
        _wzMimeType = (WCHAR*) wzSuggestedMimeType;

        DEBUG_LEAVE(_wzMimeType);
        return _wzMimeType;
    }

    _pBuf = pBuf;
    _cbSample = (cbSample <= SAMPLE_SIZE) ? cbSample : SAMPLE_SIZE;

    // Save off last character. Null terminate the buffer.
    cLastByte = _pBuf[_cbSample - 1];
    _pBuf[_cbSample - 1] = '\0';


    // Common cases first - check the server indicated mime type
    // for text/html, image/gif or image/[p]jpeg.
    if (   wzSuggestedMimeType
        && !StrCmpICW(wzSuggestedMimeType, vwzTextHTML))
    {
        // Sample the data. This routine also checks for the following
        // mime types which require extended scanning through the buffer:
        // text/html, image/x-xbitmap, application/macbinhex
        SampleData();
        fSampledData = TRUE;

        if (_fFoundHTML)
        {
            _wzMimeType = vwzTextHTML;
           goto exit;
        }
    }

    // image/gif
    else if (wzSuggestedMimeType
        && !wcsicmp(wzSuggestedMimeType, vwzImageGif))
    {
        if (!StrCmpNIC(_pBuf, vszGif87Magic, sizeof(vszGif87Magic) - 1)
           || !StrCmpNIC(_pBuf, vszGif89Magic, sizeof(vszGif89Magic) - 1))
        {
            _wzMimeType = vwzImageGif;
            goto exit;
        }
    }

    // image/jpeg or image/pjpeg
    else if (wzSuggestedMimeType
        && (!wcsicmp(wzSuggestedMimeType, vwzImagePJpeg)
        || !wcsicmp(wzSuggestedMimeType, vwzImageJpeg)))
    {
        if ((BYTE)_pBuf[0] == JPEG_MAGIC_1 && (BYTE)_pBuf[1] == JPEG_MAGIC_2)
        {
            _wzMimeType = vwzImagePJpeg;
            goto exit;
        }
    }


    //
    // ********************** BEGIN HACK ******************************* 
    //
    // we will remove this once tridents defined the unique signature
    // for .hta and .htc format
    //
    // DanpoZ (98.08.12) - refer to IE5 SUPERHOT bug 35478
    //
    if (wzFileName )
    {

        CHAR* szExt;
        CHAR szFile[MAX_PATH];
        W2A(wzFileName, szFile, MAX_PATH);

        if( grfFlags & FMFD_URLASFILENAME )
        {
            //
            // remove teh security context '\1' and replace it with '\0'
            // but only do this when we are using URL to replace the filename
            //
            CHAR* pch = StrChr(szFile, '\1');
            if (pch)
            {
                *pch = '\0';
            }
        }

        szExt = FindFileExtension(szFile);
        if( szExt && 
            ( !StrCmpNIC(szExt, ".hta", sizeof(".hta") - 1) ||
              !StrCmpNIC(szExt, ".htc", sizeof(".htc") - 1)  ) )
        {
            fExtensionChecked = TRUE;
            fFoundMimeTypeFromExt = FindMimeFromExt(
                                            wzFileName,
                                            szFileName,
                                            szMimeTypeFromExt,
                                            &dwExtMimeTypeDataFormat,
                                            &szFileExt
                                            );

            // If there is a mime type associated with the file
            // extension then return it.
            if (fFoundMimeTypeFromExt)
            {
                _wzMimeType = _wzMimeTypeFromExt;
                goto exit;
            }
        }
    }
    //
    // ********************** END HACK ********************************* 
    //

    // One of the following is true:

    // 1) The server indicated a common mime type (html, gif or jpeg),
    //    however, verification failed.
    // 2) The server indicated an ambiguous mime type or
    //    a known, but uncommon mime type.

    // If not done so already, sample the data.
    if (!fSampledData)
    {
        SampleData();
        fSampledData = TRUE;
    }

    // Return any mime type that was positively
    // identified during the data sampling
    if( _fFoundCDF )
    {
        _wzMimeType = vwzApplicationCDF;
        goto exit;
    }
    else if( _fFoundXML)
    {
        _wzMimeType = vwzTextXML;
        goto exit;
    }
    else if (_fFoundHTML)
    {
        _wzMimeType = vwzTextHTML;
        goto exit;
    }
    else if (_fFoundXBitMap)
    {
        _wzMimeType = vwzImageXBitmap;
        goto exit;
    }
    else if (_fFoundMacBinhex)
    {
        _wzMimeType = vwzApplicationMacBinhex;
        goto exit;
    }
    else if( _fFoundTextScriptlet )
    {
        _wzMimeType = vwzTextScriptlet;
        goto exit;
    }

    if(    !_fFoundCDF  
        && wzSuggestedMimeType
        && !wcsicmp(wzSuggestedMimeType, vwzApplicationNETCDF) 
      ) 
    {
        // only overwrite application/x-netcdf with aplication/x-cdf
        _wzMimeType = vwzApplicationNETCDF; 
        goto exit;
    }
    

    // Decide if buffer is primarily text or binary. Conduct
    // pattern matching to determine a mime type depending on the
    // finding.
    if (!_cbCtrl || _cbText + _cbFF >= 16 * (_cbCtrl + _cbHigh))
    {
        _fBinary = FALSE;
        if( !CheckTextHeaders() )
        {
            if( !CheckBinaryHeaders() )
            {
                _wzMimeType = vwzTextPlain;
            }
        }
    }
    else
    {
        _fBinary = TRUE;
        if( !CheckBinaryHeaders() )
        {
            if( !CheckTextHeaders() )
            {
                _wzMimeType = vwzApplicationOctetStream;
            }
        }
    }

    // Determine format of the mime type from data
    dwMimeTypeDataFormat = GetDataFormat(_wzMimeType);

    // If the format of the mime type found from examining the data
    // is not ambiguous, then return this mime type.
    if (dwMimeTypeDataFormat != DATAFORMAT_AMBIGUOUS)
    {
        goto exit;
    }

    // Examination of data is inconclusive.
    else
    {
        // If the suggested mime type is not ambiguous and does
        // not conflict with the data format then return it.
        if (dwSuggestedMimeTypeDataFormat != DATAFORMAT_AMBIGUOUS
            && FormatAgreesWithData(dwSuggestedMimeTypeDataFormat))
        {
            _wzMimeType = (WCHAR*) wzSuggestedMimeType;
            goto exit;
        }

        // Otherwise, attempt to obtain a mime type from any
        // file extension. If none is found, but an application
        // is registered for the file extension, return
        // application/octet-stream.


        // If there is a file extension, find any
        // associated mime type.
        if (wzFileName && !fExtensionChecked)
        {
            fExtensionChecked = TRUE;

            fFoundMimeTypeFromExt = FindMimeFromExt(
                                            wzFileName,
                                            szFileName,
                                            szMimeTypeFromExt,
                                            &dwExtMimeTypeDataFormat,
                                            &szFileExt
                                            );
        }

        // If there is a mime type associated with the file
        // extension then return it.
        if (fFoundMimeTypeFromExt)
        {
            if (dwExtMimeTypeDataFormat == DATAFORMAT_UNKNOWN)
            {
                _wzMimeType = _wzMimeTypeFromExt;
                goto exit;
            }
            else
            {
                goto exit;
            }
        }

        // Otherwise, check to see if there is an associated application.
        if (szFileExt && FindAppFromExt(szFileExt, szCommand, cbCommand))
        {
            // Found an associated application.
            _wzMimeType = vwzApplicationOctetStream;
            goto exit;
        }

        // No suggested mime type, no mime type from file extension
        // and no registered application found. Fall through and return
        // mime type found from the data
    }


    exit:
        // Replace the null termination with
        // the original character.
        _pBuf[_cbSample - 1] = cLastByte;


        DEBUG_LEAVE(_wzMimeType);
        return _wzMimeType;
}

//+---------------------------------------------------------------------------
//
//  Method:     CContentAnalyzer::FindMimeFromExt
//
//  Synopsis:
//
//  Arguments:  [wzFileName] --
//              [szFileName] --
//              [szMimeTypeFromExt] --
//              [pdwExtMimeTypeDataFormat] --
//
//  Returns:
//
//  History:    5-25-96   AdriaanC (Adriaan Canter)
//              1-28-1997   JohannP (Johann Posch)   made separate function
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL CContentAnalyzer::FindMimeFromExt(
                        LPCWSTR wzFileName,
                        CHAR *szFileName,
                        CHAR *szMimeTypeFromExt,
                        DWORD *pdwExtMimeTypeDataFormat,
                        CHAR  **ppszFileExt)
{
    DEBUG_ENTER((DBG_TRANS,
                Bool,
                "CContentAnalyzer::FindMimeFromExt",
                "this=%#x, %.80wq, %.80q, %.80q, %#x, %#x",
                this, wzFileName, szFileName, szMimeTypeFromExt, pdwExtMimeTypeDataFormat, ppszFileExt
                ));
                
    BOOL fFoundMimeTypeFromExt = FALSE;
    UrlMkAssert((wzFileName && szFileName && pdwExtMimeTypeDataFormat));
    DWORD dwMimeLen = SZMIMESIZE_MAX;
    CHAR* szFileExt = 0;

    // If there is a file extension, find any
    // associated mime type.
    W2A(wzFileName, szFileName, MAX_PATH);
    szFileExt = FindFileExtension(szFileName);
    if (szFileExt && GetMimeFromExt(szFileExt,
        szMimeTypeFromExt, &dwMimeLen) == ERROR_SUCCESS)
    {
        fFoundMimeTypeFromExt = TRUE;
        A2W(szMimeTypeFromExt, _wzMimeTypeFromExt, SZMIMESIZE_MAX);
        *pdwExtMimeTypeDataFormat = GetDataFormat(_wzMimeTypeFromExt);
    }
    if (szFileExt && ppszFileExt)
    {
        *ppszFileExt = szFileExt;
    }

    DEBUG_LEAVE(fFoundMimeTypeFromExt);
    return fFoundMimeTypeFromExt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\trans\ibsc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cbinding.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-11-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

#include <trans.h>

PerfDbgTag(tagCBSC, "Urlmon", "Log CBSC", DEB_BINDING);

CBSC::CBSC(Medium medium)
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CBSC::CBSC",
                "this=%#x, %#x",
                this, medium
                ));
                
    PerfDbgLog(tagCBSC, this, "+CBSC::CBSC");
    _cRef   = 1;
    _pBdg = NULL;
    _fBindToObject = (medium == Medium_Unknown) ? TRUE : FALSE;
    _fGotStopBinding = FALSE;
    _Medium = medium;
    _pStm = NULL;
    _pStg = NULL;
    _pUnk = NULL;
    _hrResult = NOERROR;
    PerfDbgLog(tagCBSC, this, "-CBSC::CBSC");

    DEBUG_LEAVE(0);
}

CBSC::~CBSC()
{
    DEBUG_ENTER((DBG_TRANS,
                None,
                "CBSC::~CBSC",
                "this=%#x",
                this
                ));
                
    PerfDbgLog(tagCBSC, this, "+CBSC::~CBSC");
    if (_pStm)
    {
        _pStm->Release();
    }
    if (_pUnk)
    {
        _pUnk->Release();
    }
    PerfDbgLog(tagCBSC, this, "-CBSC::~CBSC");

    DEBUG_LEAVE(0);
}

HRESULT CBSC::GetRequestedObject(IBindCtx *pbc, void **ppvObj)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBSC::GetRequestedObject",
                "this=%#x, %#x, %#x",
                this, pbc, ppvObj
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog1(tagCBSC, this, "+CBSC::GetRequestedObject (_wzPath:%ws)", _wzPath);

    if (_Medium == Medium_Stream)
    {
        *ppvObj = _pStm;
        //TransAssert((_pStm));
        if (_pStm)
        {
            _pStm->AddRef();
        }
        else if (_hrResult != NOERROR)
        {
            hr = _hrResult;
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else if (_Medium == Medium_Storage)
    {
        BIND_OPTS bindopts;
        bindopts.cbStruct = sizeof(BIND_OPTS);

        hr = pbc->GetBindOptions(&bindopts);
        if (hr == NOERROR)
        {
            hr = StgOpenStorage(_wzPath, NULL, bindopts.grfMode, NULL, 0, (LPSTORAGE FAR*)ppvObj );
            if (hr != NOERROR)
            {
                hr = StgOpenStorage(_wzPath, NULL, STGM_READWRITE | STGM_SHARE_DENY_NONE, NULL, 0, (LPSTORAGE FAR*)ppvObj );
            }
            if (hr != NOERROR)
            {
                hr = StgOpenStorage(_wzPath, NULL, STGM_READ | STGM_SHARE_DENY_WRITE, NULL, 0, (LPSTORAGE FAR*)ppvObj );
            }
        }
    }
    else if (_Medium == Medium_Unknown)
    {
        *ppvObj = _pUnk;
        TransAssert((_pUnk));
        if (_pUnk)
        {
            _pUnk->AddRef();
        }
        else
        {
            hr = E_FAIL;
        }
    }

    PerfDbgLog1(tagCBSC, this, "-CBSC::GetRequestedObject hr:%lx", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CBSC::QueryInterface(REFIID riid, void **ppvObj)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBSC::IUnknown::QueryInterface",
                "this=%#x, %#x, %#x",
                this, &riid, ppvObj
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCBSC, this, "+CBSC::QueryInterface");

    if (   IsEqualIID(riid, IID_IBindStatusCallback)
        || IsEqualIID(riid, IID_IUnknown))
    {
         _cRef++;   // A pointer to this object is returned
         *ppvObj = (void *)(IBindStatusCallback *)this;
    }
    else
    {
         *ppvObj = NULL;
         hr = E_NOINTERFACE;
    }

    PerfDbgLog1(tagCBSC, this, "-CBSC::QueryInterface hr:%lx", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
STDMETHODIMP_(ULONG) CBSC::AddRef(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CBSC::IUnknown::AddRef",
                "this=%#x",
                this
                ));
                
    ULONG cRef = ++_cRef;
    PerfDbgLog1(tagCBSC, this, "CBSC::AddRef (cRef:%ld)", cRef);

    DEBUG_LEAVE(cRef);
    return cRef;
}
STDMETHODIMP_(ULONG) CBSC::Release(void)
{
    DEBUG_ENTER((DBG_TRANS,
                Dword,
                "CBSC::IUnknown::Release",
                "this=%#x",
                this
                ));
                
    ULONG cRef = 0;
    PerfDbgLog(tagCBSC, this, "+CBSC::Release");

    cRef = --_cRef;
    if (cRef == 0)
    {
        delete this;
    }

    PerfDbgLog1(tagCBSC, this, "-CBSC::Release cref:%ld", cRef);

    DEBUG_LEAVE(cRef);
    return cRef;
}


STDMETHODIMP  CBSC::GetBindInfo(
    /* [out] */ DWORD  *grfBINDINFOF,
    /* [out] */ BINDINFO  *pbindinfo)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBSC::IBindStatusCallback::GetBindInfo",
                "this=%#x, %#x, %#x",
                this, grfBINDINFOF, pbindinfo
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCBSC, this, "+CBSC::GetBindInfo");

    if (   (grfBINDINFOF == NULL)
        || (pbindinfo == NULL)
        || (pbindinfo->cbSize == 0)
       )

    {
        DEBUG_LEAVE(E_INVALIDARG);
        return E_INVALIDARG;
    }

    //  Nuke BINDINFO preserving cbSize;
    DWORD cbSize = pbindinfo->cbSize;
    memset(pbindinfo, 0, cbSize);
    pbindinfo->cbSize = cbSize;

    if (_Medium == Medium_Storage)
    {
        *grfBINDINFOF = 0;

    }
    else
    {
        *grfBINDINFOF = 0;
        *grfBINDINFOF |= BINDF_ASYNCSTORAGE;
        *grfBINDINFOF |= BINDF_PULLDATA;
        *grfBINDINFOF |= BINDF_NEEDFILE;

    }


    PerfDbgLog1(tagCBSC, this, "-CBSC::GetBindInfo hr:%lx", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP  CBSC::OnStartBinding(DWORD grfBINDINFOF, IBinding  *pib)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBSC::IBindStatusCallback::OnStartBinding",
                "this=%#x, %#x, %#x",
                this, grfBINDINFOF, pib
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCBSC, this, "+CBSC::OnStartBinding");
    if (pib)
    {
        _pBdg = pib;
        _pBdg->AddRef();
    }

    PerfDbgLog1(tagCBSC, this, "-CBSC::OnStartBinding hr:%lx", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP  CBSC::GetPriority(
    /* [out] */ LONG  *pnPriority)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBSC::IBindStatusCallback::GetPriority",
                "this=%#x, %#x",
                this, pnPriority
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCBSC, this, "+CBSC::GetPriority");

    if (pnPriority == NULL)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *pnPriority = THREAD_PRIORITY_NORMAL;
    }

    PerfDbgLog1(tagCBSC, this, "-CBSC::GetPriority hr:%lx", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP  CBSC::OnProgress(
    /* [in] */ ULONG ulProgress,
    /* [in] */ ULONG ulProgressMax,
    /* [in] */ ULONG ulStatusCode,
    /* [in] */ LPCWSTR szStatusText)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBSC::IBindStatusCallback::OnProgress",
                "this=%#x, %#x, %#x, %#x, %.80wq",
                this, ulProgress, ulProgressMax, ulStatusCode, szStatusText
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog4(tagCBSC, this, "+CBSC::OnProgress (StatusCode:%ld/%lx, Progress:%ld ProgressMax:%ld))",
        ulStatusCode, ulStatusCode, ulProgress, ulProgressMax);

    PerfDbgLog1(tagCBSC, this, "-CBSC::OnProgress hr:%lx", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP  CBSC::OnDataAvailable(
    /* [in] */ DWORD grfBSC,
    /* [in] */ DWORD dwSize,
    /* [in] */ FORMATETC  *pFmtetc,
    /* [in] */ STGMEDIUM  *pstgmed)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBSC::IBindStatusCallback::OnDataAvailable",
                "this=%#x, %#x, %#x, %#x, %#x",
                this, grfBSC, dwSize, pFmtetc, pstgmed
                ));
                
    HRESULT hr = NOERROR;
    HRESULT hr1 = NOERROR;
    PerfDbgLog(tagCBSC, this, "+CBSC::OnDataAvailable");

    UrlMkAssert((dwSize > 0));
    UrlMkAssert((pFmtetc != NULL && pstgmed != NULL));

    // if this is the first notification then make sure that the proper formatetc
    // is passed in.
    if (grfBSC & BSCF_FIRSTDATANOTIFICATION)
    {
        if (pFmtetc->tymed & TYMED_ISTREAM ||
            pstgmed->tymed == TYMED_ISTREAM )
        {
            STATSTG statstg;

            PerfDbgLog1(tagCBSC, this, "CBSC::OnDataAvailable - received IStream %lx", pstgmed->pstm);
            _pStm = pstgmed->pstm;
            _pStm->AddRef();

            if (pstgmed->pUnkForRelease)
            {
                _pUnk = pstgmed->pUnkForRelease;
                _pUnk->AddRef();
            }
        }
    }

    if (grfBSC & BSCF_LASTDATANOTIFICATION)
    {
        // if this is the final notification then get the data and display it

        if (_pStm)
        {
            UrlMkAssert((pFmtetc->tymed & TYMED_ISTREAM));
            //_pStm->Release();
            //_pStm = 0;
        }

        // if this is the final notification then get the data and display it

        if (pFmtetc->tymed & TYMED_FILE)
        {
            PerfDbgLog1(tagCBSC, this, "CBSC::OnDataAvailable - received File:%ws", pstgmed->lpszFileName);
            wcscpy(_wzPath, pstgmed->lpszFileName);
        }

        UrlMkAssert((_wzPath ));
    }

    PerfDbgLog1(tagCBSC, this, "-CBSC::OnDataAvailable hr:%lx", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP  CBSC::OnLowResource(
    /* [in] */ DWORD reserved)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBSC::IBindStatusCallback::OnLowResource",
                "this=%#x, %#x",
                this, reserved
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCBSC, this, "+CBSC::OnLowResource");
    PerfDbgLog1(tagCBSC, this, "-CBSC::OnLowResource hr:%lx", hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP CBSC::OnStopBinding(HRESULT hresult, LPCWSTR szError)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBSC::IBindStatusCallback::OnStopBinding",
                "this=%#x, %#x, %.80wq",
                this, hresult, szError
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog1(tagCBSC, this, "+CBSC::OnStopBinding (hresult:%lx)", hresult);

    _fGotStopBinding = TRUE;
    _hrResult = hresult;
    if (_pBdg)
    {
        _pBdg->Release();
        _pBdg = NULL;
    }

    PerfDbgLog2(tagCBSC, this, "-CBSC::OnStopBinding (hresult:%lx) hr:%lx", hresult, hr);

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP  CBSC::OnObjectAvailable(REFIID riid, IUnknown  *punk)
{
    DEBUG_ENTER((DBG_TRANS,
                Hresult,
                "CBSC::IBindStatusCallback::OnObjectAvailable",
                "this=%#x, %#x, %#x",
                this, &riid, punk
                ));
                
    HRESULT hr = NOERROR;
    PerfDbgLog(tagCBSC, this, "+CBSC::OnObjectAvailable");

    UrlMkAssert((_Medium == Medium_Unknown));
    UrlMkAssert((punk));

    punk->AddRef();
    _pUnk = punk;

    PerfDbgLog1(tagCBSC, this, "-CBSC::OnObjectAvailable hr:%lx", hr);

    DEBUG_LEAVE(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\urlmon\trans\prothndl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       transact.cxx
//
//  Contents:   Class that performs the download of a particular request.
//
//  Classes:
//
//  Functions:
//
//  History:    12-04-95   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include <trans.h>
#include <shlwapi.h>

#include "oinet.hxx"

PerfDbgTag(tagCTransaction,    "Urlmon", "Log CTransaction",        DEB_TRANS);
    DbgTag(tagCTransactionErr, "Urlmon", "Log CTransaction Errors", DEB_TRANS|DEB_ERROR);
    
HRESULT GetClassDocFileBuffer(LPVOID pbuffer, DWORD dwSize, CLSID *pclsid);
HRESULT GetCodeBaseFromDocFile(LPBYTE pBuffer, ULONG ulSize, LPWSTR *pwzClassStr, 
                               LPWSTR pwzBaseUrl, DWORD *lpdwVersionMS, DWORD *lpdwVersionLS);
HRESULT IsHandlerAvailable(LPWSTR pwzUrl, LPWSTR pwzMime, CLSID *pclsid, 
                                LPBYTE pBuffer, ULONG cbSize);

#if 0
//+---------------------------------------------------------------------------
//
//  Method:     COInetProtSnk::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [riid] --
//              [ppvObj] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProtSnk::QueryInterface(REFIID riid, void **ppvObj)
{
    VDATEPTROUT(ppvObj, void *);
    VDATETHIS(this);
    HRESULT hr = NOERROR;

    PerfDbgLog(tagCTransaction, this, "+COInetProtSnk::QueryInterface");

    *ppvObj = NULL;
    if (_pUnk)
    {
        hr = _pUnk->QueryInterface(riid, ppvObj);
    }
    else
    {
        if (   (riid == IID_IUnknown)
            || (riid == IID_IOInetProtocol))
        {
            *ppvObj = (IOInetProtocol *) this;
            AddRef();
        }
        else if (riid == IID_IOInetProtocolSink)
        {
            *ppvObj = (IOInetProtocolSink *) this;
            AddRef();
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }

    PerfDbgLog1(tagCTransaction, this, "-COInetProtSnk::QueryInterface (hr:%lx)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   COInetProtSnk::AddRef
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COInetProtSnk::AddRef(void)
{
    PerfDbgLog(tagCTransaction, this, "+COInetProtSnk::AddRef");

    LONG lRet = _pProtSnk->AddRef();

    PerfDbgLog1(tagCTransaction, this, "-COInetProtSnk::AddRef (cRefs:%ld)", lRet);
    return lRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   COInetProtSnk::Release
//
//  Synopsis:
//
//  Arguments:  [ULONG] --
//
//  Returns:
//
//  History:    10-29-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COInetProtSnk::Release(void)
{
    PerfDbgLog(tagCTransaction, this, "+COInetProtSnk::Release");

    LONG lRet = _pProtSnk->Release();

    PerfDbgLog1(tagCTransaction, this, "-COInetProtSnk::Release (cRefs:%ld)", lRet);
    return lRet;
}


//+---------------------------------------------------------------------------
//
//  Method:     COInetProtSnk::Switch
//
//  Synopsis:
//
//  Arguments:  [pStateInfo] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProtSnk::Switch(PROTOCOLDATA *pStateInfo)
{
    PerfDbgLog(tagCTransaction, this, "+COInetProtSnk::Switch");
    HRESULT hr = NOERROR;

    hr = _pProtSnk->Switch(pStateInfo);
   
    PerfDbgLog1(tagCTransaction, this, "-COInetProtSnk::Switch (hr:%lx)", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Method:     COInetProtSnk::ReportProgress
//
//  Synopsis:
//
//  Arguments:  [NotMsg] --
//              [szStatusText] --
//
//  Returns:
//
//  History:    11-07-1996   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP COInetProtSnk::ReportProgress(ULONG NotMsg, LPCWSTR pwzStatusText)
{
    PerfDbgLog1(tagCTransaction, this, "+COInetProtSnk::ReportProgress pwzStatusText:%ws", pwzStatusText);
    HRESULT hr = NOERROR;

    hr = _pProtSnk->ReportProgress(NotMsg, pwzStatusText);

    PerfDbgLog2(tagCTransaction, this, 