f,
        IN      TCHAR_t    *psAppName,
        IN      TCHAR_t    *psAppGUID,
        IN      TCHAR_t    *psClass,
        IN      TCHAR_t    *psQosName,
        IN      TCHAR_t    *psPolicyLocator
    );

/* Qos App ID defaults */
const WCHAR *g_sAppGUID =
             L"www.microsoft.com";
const WCHAR *g_sPolicyLocator =
             L",SAPP=MICROSOFT REAL-TIME COMMUNICATIONS,VER=1.0,SAPP=";

const TCHAR_t *g_psRsvpStyle[] = {
    _T("DEFAULT"),
    _T("WF"),
    _T("FF"),
    _T("SE")
};

DWORD GetRegistryQosSetting(
        DWORD           *pEnabled,
        char            *pName,
        DWORD            NameLen,
        DWORD           *pdwDisableFlags,
        DWORD           *pdwEnableFlags
    );


#define RTP_HDR         12
#define RTP_UDP_IP_HDR  40

/**********************************************************************
 * Miscelaneous: QOS templates, registry
 **********************************************************************/

/*
 * The extra information is used when a frame size (in milliseconds)
 * is provided to RtpSetQosByName, to derive several flowspec
 * parameters to be closer to what is really needed, currently this
 * information is enabled ONLY for audio
  
      3                   2                   1                 
    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |E| |Basic time | Basic frame |    PT       | eXtra 2 | eXtra 1 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    v v \----v----/ \-----v-----/ \-----v-----/ \---v---/ \---v---/
    | |      |            |             |           |         |
    | |      |            |             |           |         Extra1 (5)
    | |      |            |             |           |
    | |      |            |             |           Extra2 (5)
    | |      |            |             |
    | |      |            |             Payload type (7)
    | |      |            |
    | |      |            Basic Frame (7)
    | |      | 
    | |      Basic Time (6)
    | |
    | Reserved (1)
    |
    Enabled (1)

 */

#define QOS_EI(e, bt, bf, pt, x2, x1)  \
        (((e  & 0x01) << 31) | \
         ((bt & 0x3f) << 24) | \
         ((bf & 0x7f) << 17) | \
         ((pt & 0x7f) << 10) | \
         ((x2 & 0x1f) <<  5) | \
         ((x1 & 0x1f)))


#define QOS_USEINFO(_pQosInfo)    \
        (((_pQosInfo)->dwQosExtraInfo >> 31) & 0x01)

#define QOS_BASICTIME(_pQosInfo)  \
        (((_pQosInfo)->dwQosExtraInfo >> 24) & 0x3f)  /* in millisecs */

#define QOS_BASICFRAME(_pQosInfo) \
        (((_pQosInfo)->dwQosExtraInfo >> 17) & 0x7f)  /* in bytes */

#define QOS_PT(_pQosInfo) \
        (((_pQosInfo)->dwQosExtraInfo >> 10) & 0x7f)

#define QOS_EXTRA2(_pQosInfo)   \
        (((_pQosInfo)->dwQosExtraInfo >> 5) & 0x1f)

#define QOS_EXTRA1(_pQosInfo)   \
        (((_pQosInfo)->dwQosExtraInfo) & 0x1f)

#define QOS_ADD_MIN(_pQosInfo) QOS_EXTRA1(_pQosInfo)
#define QOS_ADD_MAX(_pQosInfo) QOS_EXTRA2(_pQosInfo)

#if 0
typedef struct _flowspec {
    /* Flowspec */
    ULONG            TokenRate;              /* In Bytes/sec */
    ULONG            TokenBucketSize;        /* In Bytes */
    ULONG            PeakBandwidth;          /* In Bytes/sec */
    ULONG            Latency;                /* In microseconds */
    ULONG            DelayVariation;         /* In microseconds */
    SERVICETYPE      ServiceType;
    ULONG            MaxSduSize;             /* In Bytes */
    ULONG            MinimumPolicedSize;     /* In Bytes */
} FLOWSPEC;
#endif

/* NOTE TokenRate is computed as 103% of the nominal byterate
 * including RTP/UP/IP headers. The TokenBucketSize is computed to be
 * enough big to hold 6 packets while using the maximum number of
 * frames a packet may have (MaxSduSize) also including RTP/UDP/IP
 * headers */
const QosInfo_t g_QosInfo[] = {
    {
        RTPQOSNAME_G711,
        QOS_EI(1, 1, 8, RTPPT_PCMU, 0, 0),
        {
            10000,         /* Assume 20ms */
            (80*9+RTP_UDP_IP_HDR)*6,
            10000*17/10,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            SERVICETYPE_GUARANTEED,
            80*10+RTP_HDR, /* 100 ms */
            80*2+RTP_HDR   /* 20 ms */
        }
    },
    {
        RTPQOSNAME_G711,
        QOS_EI(1, 1, 8, RTPPT_PCMA, 0, 0),
        {
            10000,         /* Assume 20ms */
            (80*9+RTP_UDP_IP_HDR)*6,
            10000*17/10,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            SERVICETYPE_GUARANTEED,
            80*10+RTP_HDR, /* 100 ms */
            80*2+RTP_HDR   /* 20 ms */
        }
    },
    {
        RTPQOSNAME_G723_1,
        QOS_EI(1, 30, 20, RTPPT_G723, 4, 0),
        {
            2198,          /* Assume 30ms */
            (24*3+RTP_UDP_IP_HDR)*6,
            2198*17/10,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            SERVICETYPE_GUARANTEED,
            24*3+RTP_HDR,  /* 90 ms */
            20+RTP_HDR     /* 30 ms */
        }
    },
    {
        RTPQOSNAME_GSM6_10,
        QOS_EI(1, 40, 66, RTPPT_GSM, 1, 0),
        {
            2729,          /* Assume 40ms */
            (66*3+RTP_UDP_IP_HDR)*6,
            2729*17/10,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            SERVICETYPE_GUARANTEED,
            66*3+RTP_HDR,  /* 120 ms */
            65+RTP_HDR     /* 40 ms */
        }
    },
    {
        RTPQOSNAME_DVI4_8,
        QOS_EI(1, 10, 40, RTPPT_DVI4_8000, 4, 4),
        {
            6386,          /* Assume 20ms */
            (40*9+RTP_UDP_IP_HDR)*6,
            6386*17/10,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            SERVICETYPE_GUARANTEED,
            40*10+4+RTP_HDR,/* 100 ms */
            40*1+RTP_HDR    /* 10 ms */
        }
    },
    {
        RTPQOSNAME_DVI4_16,
        QOS_EI(1, 10, 80, RTPPT_DVI4_16000, 4, 4),
        {
            10506,         /* Assume 20ms */
            (80*9+RTP_UDP_IP_HDR)*6,
            10506*17/10,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            SERVICETYPE_GUARANTEED,
            80*10+4+RTP_HDR,/* 100 ms */
            80*2+RTP_HDR    /* 20 ms */
        }
    },
    {
        RTPQOSNAME_SIREN,
        QOS_EI(1, 20, 40, 111, 0, 0),
        {
            4120,          /* Assume 20ms */
            (40*5+RTP_UDP_IP_HDR)*6,
            4120*17/10,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            SERVICETYPE_GUARANTEED,
            40*5+RTP_HDR,  /* 100 ms */
            40*1+RTP_HDR   /* 20 ms */
        }
    },
    {
        RTPQOSNAME_G722_1,
        QOS_EI(1, 20, 60, 112, 0, 0),
        {
            5150,          /* Assume 20ms */
            (60*5+RTP_UDP_IP_HDR)*6,
            5150*17/10,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            SERVICETYPE_GUARANTEED,
            60*5+RTP_HDR,  /* 100 ms */
            60+RTP_HDR     /* 20 ms */
        }
    },
    {
        RTPQOSNAME_MSAUDIO,
        QOS_EI(1, 32, 64, 113, 0, 0),
        {
            3348,          /* Assume 32ms */
            (64*3+RTP_UDP_IP_HDR)*6,
            3348*17/10,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            SERVICETYPE_GUARANTEED,
            64*3+RTP_HDR,  /* 96 ms */
            64*1+RTP_HDR   /* 32 ms */
        }
    },
    {
        RTPQOSNAME_H263QCIF,
        QOS_EI(0, 0, 0, RTPPT_H263, 0, 0),
        {
            16000,
            1500*4,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            SERVICETYPE_CONTROLLEDLOAD,
            1500,
            64
        }
    },
    {
        RTPQOSNAME_H263CIF,
        QOS_EI(0, 0, 0, RTPPT_H263, 0, 0),
        {
            32000,
            1500*4,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            SERVICETYPE_CONTROLLEDLOAD,
            1500,
            64
        }
    },
    {
        RTPQOSNAME_H261QCIF,
        QOS_EI(0, 0, 0, RTPPT_H261, 0, 0),
        {
            16000,
            1500*4,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            SERVICETYPE_CONTROLLEDLOAD,
            1500,
            64
        }
    },
    {
        RTPQOSNAME_H261CIF,
        QOS_EI(0, 0, 0, RTPPT_H261, 0, 0),
        {
            32000,
            1500*4,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            QOS_NOT_SPECIFIED,
            SERVICETYPE_CONTROLLEDLOAD,
            1500,
            64
        }
    }
};

#define QOS_NAMES (sizeof(g_QosInfo)/sizeof(g_QosInfo[0]))

const QosInfo_t *RtpGetQosInfoByName(
        TCHAR_t         *psQosName
    )
{
    DWORD            i;
    const QosInfo_t *pQosInfo;
    
    for(i = 0, pQosInfo = (QosInfo_t *)NULL; i < QOS_NAMES; i++)
    {
        if (!lstrcmp(psQosName, g_QosInfo[i].pName))
        {
            pQosInfo = &g_QosInfo[i];
            
            break;
        }
    }

    return(pQosInfo);
}

const QosInfo_t *RtpGetQosInfoByPT(
        DWORD           dwPT
    )
{
    DWORD            i;
    const QosInfo_t *pQosInfo;
    
    for(i = 0, pQosInfo = (QosInfo_t *)NULL; i < QOS_NAMES; i++)
    {
        if (dwPT == QOS_PT(&g_QosInfo[i]))
        {
            pQosInfo = &g_QosInfo[i];
            
            break;
        }
    }

    return(pQosInfo);
}


/**********************************************************************
 * QOS reservations
 **********************************************************************/

/* NOTE assumes that redundancy is added as a duplicate of the main
 * data, and only one redundancy */
void RtpAdjustQosFlowSpec(
        FLOWSPEC        *pFlowSpec,
        const QosInfo_t *pQosInfo,
        DWORD            dwFrameSize, /* in milliseconds */
        BOOL             bUseRed
    )
{
    DWORD            dwFrameSizeBytes;
    DWORD            dwMaxSduSize;
    DWORD            dwMinimumPolicedSize;
#if DBG > 0
    TCHAR_t          str[256];
#endif
    
    TraceFunctionName("RtpAdjustQosFlowSpec");
    
    dwFrameSizeBytes =
        (dwFrameSize / QOS_BASICTIME(pQosInfo)) * QOS_BASICFRAME(pQosInfo);

    if (bUseRed)
    {
        dwFrameSizeBytes = (dwFrameSizeBytes * 2) + sizeof(RtpRedHdr_t) + 1;
    }

    /* TokenRate uses the RTP, UDP, IP headers and adds 3% to the
     * estimated value */
    pFlowSpec->TokenRate =
        dwFrameSizeBytes + QOS_ADD_MAX(pQosInfo) + RTP_UDP_IP_HDR;

    pFlowSpec->TokenRate =
        ((pFlowSpec->TokenRate * 1000 / dwFrameSize) * 103) / 100;

    /* TokenBucketSize uses the RTP, UDP, IP headers and gives a
     * tolerance of 6 times the computed amount */
    pFlowSpec->TokenBucketSize =
        (dwFrameSizeBytes + QOS_ADD_MAX(pQosInfo) + RTP_UDP_IP_HDR) * 6;

    /* PeakBandwidth is estimated as 17/10 of the TokenRate */
    pFlowSpec->PeakBandwidth = (pFlowSpec->TokenRate * 17) / 10;

    /* MaxSduSize uses the second extra data, and gives a tolerance of
     * 2 times the computed amount */
    dwMaxSduSize =
        ((dwFrameSizeBytes + QOS_ADD_MAX(pQosInfo)) * 2) + RTP_HDR;

    /* MinimumPolicedSize uses the first extra data */
    dwMinimumPolicedSize =
        dwFrameSizeBytes + QOS_ADD_MIN(pQosInfo) + RTP_HDR;

#if 0
    pFlowSpec->MaxSduSize = dwMaxSduSize;

    pFlowSpec->MinimumPolicedSize = dwMinimumPolicedSize;
#else
    /* Use always the maximum value for MaxSduSize, and the minimum
     * value for MinimumPolicedSize */
    if (dwMaxSduSize > pFlowSpec->MaxSduSize)
    {
        pFlowSpec->MaxSduSize = dwMaxSduSize;
    }

    if (dwMinimumPolicedSize < pFlowSpec->MinimumPolicedSize)
    {
        pFlowSpec->MinimumPolicedSize = dwMinimumPolicedSize;
    }
#endif

#if DBG > 0
    dumpFlowSpec(str, pFlowSpec);

    TraceDebug((
            CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
            _T("%s: flowspec(%s)"),
            _fname, str
        ));
#endif
}

DWORD RtpSetQosFlowSpec(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwRecvSend
    )
{
    DWORD            dwFrameSize;
    DWORD            dwFrameSizeBytes;
    BOOL             bUseRed;
    FLOWSPEC        *pFlowSpec;
    const QosInfo_t *pQosInfo;
    RtpQosReserve_t *pRtpQosReserve;

    bUseRed = FALSE;
    
    pRtpQosReserve = pRtpAddr->pRtpQosReserve;
    
    if (dwRecvSend == RECV_IDX)
    {
        dwFrameSize = pRtpQosReserve->dwFrameSizeMS[RECV_IDX];

        pFlowSpec = &pRtpQosReserve->qos.ReceivingFlowspec;

        pQosInfo = pRtpQosReserve->pQosInfo[RECV_IDX];

        if (RtpBitTest(pRtpAddr->dwAddrFlagsR, FGADDRR_QOSREDRECV))
        {
            bUseRed = TRUE;
        }
    }
    else
    {
        dwFrameSize = pRtpQosReserve->dwFrameSizeMS[SEND_IDX];

        pFlowSpec = &pRtpQosReserve->qos.SendingFlowspec;

        pQosInfo = pRtpQosReserve->pQosInfo[SEND_IDX];

        if (RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSREDSENDON))
        {
            bUseRed = TRUE;
        }

        /* Save the basic frame information if available */
        if (dwFrameSize && pRtpAddr->RtpNetSState.dwSendSamplingFreq)
        {
            pRtpAddr->RtpNetSState.dwSendSamplesPerPacket =
                pRtpAddr->RtpNetSState.dwSendSamplingFreq * dwFrameSize /
                1000;
        }
    }

    /* Copy basic flowspec */
    CopyMemory(pFlowSpec, &pQosInfo->FlowSpec, sizeof(FLOWSPEC));

    if (dwFrameSize && QOS_USEINFO(pQosInfo))
    {
        /* Adjust the flowspec only if we have a value for the frame
         * size, and the QOS info is valid */
        RtpAdjustQosFlowSpec(pFlowSpec, pQosInfo, dwFrameSize, bUseRed);
    }

    return(NOERROR);
}

/* Select a QOS template (flowspec) by passing its name in psQosName,
 * dwResvStyle specifies the RSVP style (e.g RTPQOS_STYLE_WF,
 * RTPQOS_STYLE_FF), dwMaxParticipants specifies the max number of
 * participants (1 for unicast, N for multicast), this number is used
 * to scale up the flowspec. dwQosSendMode specifies the send mode
 * (has to do with allowed/not allowed to send)
 * (e.g. RTPQOSSENDMODE_UNRESTRICTED,
 * RTPQOSSENDMODE_RESTRICTED1). dwFrameSize is the frame size (in ms),
 * used to derive several flowspec parameters, 0 makes this parameter
 * be ignored. bInternal indicates if this function was called
 * internally or from the API.
 * */
HRESULT RtpSetQosByNameOrPT(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwRecvSend,
        TCHAR_t         *psQosName,
        DWORD            dwPT,
        DWORD            dwResvStyle,
        DWORD            dwMaxParticipants,
        DWORD            dwQosSendMode,
        DWORD            dwFrameSize,
        BOOL             bInternal
    )
{
    HRESULT          hr;
    DWORD            i;
    DWORD            dwQosOnFlag;
    QOS             *pqos;
    RtpQosReserve_t *pRtpQosReserve;
    const QosInfo_t *pQosInfo;
    
    TraceFunctionName("RtpSetQosByNameOrPT");

    if (!pRtpAddr)
    {
        /* Having this as a NULL pointer means Init hasn't been
         * called, return this error instead of RTPERR_POINTER to be
         * consistent */
        hr = RTPERR_NOTINIT;
        goto end;
    }

    if (!psQosName && !IsDWValueSet(dwPT))
    {
        hr = RTPERR_INVALIDARG;
        goto end;
    }

    /* verify object ID in RtpAddr_t */
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QOS, S_QOS_PROVIDER,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        return(RTPERR_INVALIDRTPADDR);
    }

    if (!RtpBitTest(pRtpAddr->dwIRtpFlags, FGADDR_IRTP_QOS))
    {
        /* Report error if this is not a QOS enabled session */
        hr = RTPERR_INVALIDSTATE;
        goto end;
    }
    
    if (psQosName && !lstrlen(psQosName))
    {
        hr = RTPERR_INVALIDARG;
        goto end;
    }

    pRtpQosReserve = pRtpAddr->pRtpQosReserve;
    
    if (!pRtpQosReserve)
    {
        hr = RTPERR_NOQOS;
        goto end;
    }

    if ( IsDWValueSet(dwResvStyle) && (dwResvStyle >= RTPQOS_STYLE_LAST) )
    {
        return(RTPERR_INVALIDARG);
    }

    if (dwRecvSend == SEND_IDX)
    {
        if ( IsDWValueSet(dwQosSendMode) &&
             (!dwQosSendMode || dwQosSendMode >= RTPQOSSENDMODE_LAST) )
        {
            hr = RTPERR_INVALIDARG;
            goto end;
       }
    }

    if (IsDWValueSet(dwResvStyle))
    {
        pRtpQosReserve->dwStyle = dwResvStyle;
    }
    else
    {
        dwResvStyle = pRtpQosReserve->dwStyle;
    }

    if (IsDWValueSet(dwMaxParticipants) && dwMaxParticipants)
    {
        RtpSetMaxParticipants(pRtpAddr, dwMaxParticipants);
    }

    /* Lookup flowspec to use */
    if (psQosName)
    {
        pQosInfo = RtpGetQosInfoByName(psQosName);
    }
    else
    {
        pQosInfo = RtpGetQosInfoByPT(dwPT);
        psQosName = _T("NONE");
    }
    
    TraceRetail((
            CLASS_INFO, GROUP_QOS, S_QOS_PROVIDER,
            _T("%s: pRtpAddr[0x%p] %s QOS Name:%s PT:%d Style:%s ")
            _T("Max:%d SendMode:%d FrameSize:%d ms"),
            _fname, pRtpAddr,
            RTPRECVSENDSTR(dwRecvSend),
            psQosName, dwPT, g_psRsvpStyle[dwResvStyle],
            dwMaxParticipants,
            dwQosSendMode,
            dwFrameSize
        ));

    if (!pQosInfo)
    {
        hr = RTPERR_INVALIDARG;
    }
    else
    {
        hr = NOERROR;

        dwRecvSend &= RECVSENDMASK;
        
        pqos = &pRtpQosReserve->qos;

        /* Set the flowspec to use */
        if (dwRecvSend == RECV_IDX)
        {
            /* Receiver */

            pRtpQosReserve->pQosInfo[RECV_IDX] = pQosInfo;

            /* Ignore the frame size, will be computed while receiving
             * packets */

            if (!bInternal)
            {
                /* If internal, the flowspec will be set when the time
                 * comes to redo the reservation, i.e. when the frame
                 * size was computed again, otherwise update now, as
                 * the reservation will be done by the end of this
                 * function */
                RtpSetQosFlowSpec(pRtpAddr, RECV_IDX);
            }
            
            RtpBitSet(pRtpAddr->dwAddrFlagsQ, FGADDRQ_RECVFSPEC_DEFINED);

            dwQosOnFlag = FGADDR_QOSRECVON;
        }
        else
        {
            /* Sender */
            
            pRtpQosReserve->pQosInfo[SEND_IDX] = pQosInfo;

            if (IsDWValueSet(dwFrameSize) && dwFrameSize)
            {
                pRtpQosReserve->dwFrameSizeMS[SEND_IDX] = dwFrameSize;
            }

            /* Set the QOS send mode */
            if (IsDWValueSet(dwFrameSize))
            {
                RtpSetQosSendMode(pRtpAddr, dwQosSendMode);
            }

            /* Currently this function is not called internally for
             * SEND, only via API, so I don't need to do the same test
             * as for RECV */
            RtpSetQosFlowSpec(pRtpAddr, SEND_IDX);
            
            RtpBitSet(pRtpAddr->dwAddrFlagsQ, FGADDRQ_SENDFSPEC_DEFINED);

            dwQosOnFlag = FGADDR_QOSSENDON;
        }
        
        TraceRetail((
                CLASS_INFO, GROUP_QOS, S_QOS_PROVIDER,
                _T("%s: pRtpAddr[0x%p] %s QOS Name:%s PT:%d Style:%s ")
                _T("Max:%d FrameSize:%d ms"),
                _fname, pRtpAddr,
                RTPRECVSENDSTR(dwRecvSend),
                pRtpQosReserve->pQosInfo[dwRecvSend]->pName,
                QOS_PT(pRtpQosReserve->pQosInfo[dwRecvSend]),
                g_psRsvpStyle[pRtpQosReserve->dwStyle],
                pRtpQosReserve->dwMaxFilters,
                pRtpQosReserve->dwFrameSizeMS[dwRecvSend]
            ));

        /* Now direct the RTCP thread to issue a reservation if this
         * was called from the API and the session has been started
         * and QOS is ON */
        if (!bInternal && RtpBitTest(pRtpAddr->dwAddrFlags, dwQosOnFlag))
        {
            RtcpThreadCmd(&g_RtcpContext,
                          pRtpAddr,
                          RTCPTHRD_RESERVE,
                          dwRecvSend,
                          DO_NOT_WAIT);
        }
    }

 end:
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QOS, S_QOS_PROVIDER,
                _T("%s: pRtpAddr[0x%p] failed: %s (0x%X)"),
                _fname, pRtpAddr, RTPERR_TEXT(hr), hr
            ));
    }
    
    return(hr);
}

void RtpSetQosSendMode(RtpAddr_t *pRtpAddr, DWORD dwQosSendMode)
{
    switch(dwQosSendMode)
    {
    case RTPQOSSENDMODE_UNRESTRICTED:
        /* Send no matter what */
        RtpBitReset(pRtpAddr->dwAddrFlagsQ, FGADDRQ_CHKQOSSEND);
        RtpBitSet  (pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSUNCONDSEND);
        RtpBitReset(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSCONDSEND);
        break;
    case RTPQOSSENDMODE_REDUCED_RATE:
        /* Ask permission to send, if denied, keep sending at a
         * reduced rate */
        RtpBitSet  (pRtpAddr->dwAddrFlagsQ, FGADDRQ_CHKQOSSEND);
        RtpBitReset(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSUNCONDSEND);
        RtpBitSet  (pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSCONDSEND);
        break;
    case RTPQOSSENDMODE_DONT_SEND:
        /* Ask permission to send, if denied, DON'T SEND at all */
        RtpBitSet  (pRtpAddr->dwAddrFlagsQ, FGADDRQ_CHKQOSSEND);
        RtpBitReset(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSUNCONDSEND);
        RtpBitReset(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSCONDSEND);
        break;
    case RTPQOSSENDMODE_ASK_BUT_SEND:
        /* Ask permission to send, send at normal rate no matter what,
         * the application is supposed to stop passing data to RTP or
         * to pass the very minimum (this is the mode that should be
         * used) */
        RtpBitSet  (pRtpAddr->dwAddrFlagsQ, FGADDRQ_CHKQOSSEND);
        RtpBitSet  (pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSUNCONDSEND);
        RtpBitReset(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSCONDSEND);
        break;
    }
}
 
/* Not implemented yet, will have same functionality as
 * SetQosByName, except that instead of passing a name to use a
 * predefined flowspec, the caller will pass enough information in
 * the RtpQosSpec structure to obtain the customized flowspec to
 * use */
HRESULT RtpSetQosParameters(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwRecvSend,
        RtpQosSpec_t    *pRtpQosSpec,
        DWORD            dwMaxParticipants,
        DWORD            dwQosSendMode
    )
{
    return(RTPERR_NOTIMPL);
}

/* If AppName is specified, it will replace the default AppName with
 * the new UNICODE string. If psPolicyLocator is specified, it will be
 * appended to the base policy locator */
HRESULT RtpSetQosAppId(
        RtpAddr_t   *pRtpAddr,
        WCHAR       *psAppName,
        WCHAR       *psAppGUID,
        WCHAR       *psPolicyLocator
    )
{
    int              len;
    RtpQosReserve_t *pRtpQosReserve;

    TraceFunctionName("RtpSetQosAppId");

    if (!pRtpAddr)
    {
        /* Having this as a NULL pointer means Init hasn't been
         * called, return this error instead of RTPERR_POINTER to be
         * consistent */
        return(RTPERR_INVALIDSTATE);
    }

    /* verify object ID in RtpAddr_t */
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QOS, S_QOS_PROVIDER,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        return(RTPERR_INVALIDRTPADDR);
    }

    if (!psAppName && !psAppGUID && !psPolicyLocator)
    {
        return(RTPERR_POINTER);
    }

    pRtpQosReserve = pRtpAddr->pRtpQosReserve;
    
    if (!pRtpQosReserve)
    {
        return(RTPERR_INVALIDSTATE);
    }

    /* Application name */
    if (pRtpQosReserve->psAppName)
    {
        RtpHeapFree(g_pRtpQosBufferHeap, pRtpQosReserve->psAppName);

        pRtpQosReserve->psAppName = NULL;
    }
    
    if (psAppName)
    {
        len = lstrlen(psAppName);

        if (len <= 0)
        {
            return(RTPERR_INVALIDARG);
        }

        if (len > MAX_QOS_APPID)
        {
            return(RTPERR_SIZE);
        }
        
        /* Acount for the NULL terminating character */
        len += 1;

        pRtpQosReserve->psAppName =
            RtpHeapAlloc(g_pRtpQosBufferHeap, len * sizeof(TCHAR_t));
    
        if (!pRtpQosReserve->psAppName)
        {
            return(RTPERR_MEMORY);
        }

        lstrcpy(pRtpQosReserve->psAppName, psAppName);
    }

    /* Application GUID */
    if (pRtpQosReserve->psAppGUID)
    {
        RtpHeapFree(g_pRtpQosBufferHeap, pRtpQosReserve->psAppGUID);

        pRtpQosReserve->psAppGUID = NULL;
    }

    if (psAppGUID)
    {
        len = lstrlen(psAppGUID);

        if (len <= 0)
        {
            return(RTPERR_INVALIDARG);
        }

        if (len > MAX_QOS_APPID)
        {
            return(RTPERR_SIZE);
        }
        
        /* Acount for the NULL terminating character */
        len += 1;

        pRtpQosReserve->psAppGUID =
            RtpHeapAlloc(g_pRtpQosBufferHeap, len * sizeof(TCHAR_t));
    
        if (!pRtpQosReserve->psAppGUID)
        {
            return(RTPERR_MEMORY);
        }

        lstrcpy(pRtpQosReserve->psAppGUID, psAppGUID);
    }
    
    /* Policy locator */
    if (pRtpQosReserve->psPolicyLocator)
    {
        /* Release previous buffer */
        RtpHeapFree(g_pRtpQosBufferHeap, pRtpQosReserve->psPolicyLocator);

        pRtpQosReserve->psPolicyLocator = NULL;
    }
    
    if (psPolicyLocator)
    {
        len = lstrlen(psPolicyLocator);
        
        if (len <= 0)
        {
            return(RTPERR_INVALIDARG);
        }

        if (len > MAX_QOS_POLICY)
        {
            return(RTPERR_SIZE);
        }
        
        /* Account for the NULL terminating character */
        len += 1;

        /* Find out the size for the default part (base + ',' + qos
           name + ',') */
        len +=
            lstrlen(g_sPolicyLocator) +
            lstrlen(_T(",SAPP=")) + MAX_QOS_NAME +
            1;
        
        pRtpQosReserve->psPolicyLocator =
            RtpHeapAlloc(g_pRtpQosBufferHeap, len * sizeof(TCHAR_t));

        if (!pRtpQosReserve->psPolicyLocator)
        {
            return(RTPERR_MEMORY);
        }

        /* Copy policy */
        lstrcpy((TCHAR *)pRtpQosReserve->psPolicyLocator, psPolicyLocator);
    }

    return(NOERROR);
}

/* Adds/removes a single SSRC to/from the shared explicit list of
 * participants who receive reservation (i.e. it is used when the
 * ResvStyle=RTPQOS_STYLE_SE). */
HRESULT RtpSetQosState(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwSSRC,
        BOOL             bEnable
    )
{
    HRESULT          hr;
    DWORD            dwNumber;
    DWORD            dwOperation;

    dwNumber = 1;

    if (bEnable)
    {
        dwOperation = RtpBitPar2(RTPQOS_QOSLIST_ENABLE, RTPQOS_QOSLIST_ADD);
    }
    else
    {
        dwOperation = RtpBitPar(RTPQOS_QOSLIST_ENABLE);
    }

    hr = RtpModifyQosList(pRtpAddr, &dwSSRC, &dwNumber, dwOperation);
    
    return(hr);
}

/* Adds/removes a number of SSRCs to/from the shared explicit list
 * of participants who receive reservation (i.e. it is used when
 * the ResvStyle=RTPQOS_STYLE_SE). dwNumber is the number of SSRCs
 * to add/remove, and returns the actual number of SSRCs
 * added/removed */
HRESULT RtpModifyQosList(
        RtpAddr_t       *pRtpAddr,
        DWORD           *pdwSSRC,
        DWORD           *pdwNumber,
        DWORD            dwOperation
    )
{
    HRESULT          hr;
    DWORD            dwNumber;
    DWORD            i;
    BOOL             bAddDel;
    RtpQosReserve_t *pRtpQosReserve;
    
    TraceFunctionName("RtpModifyQosList");

    if (!pRtpAddr)
    {
        /* Having this as a NULL pointer means Init hasn't been
         * called, return this error instead of RTPERR_POINTER to be
         * consistent */
        hr = RTPERR_INVALIDSTATE;

        goto bail;
    }

    if (!pdwNumber)
    {
        hr = RTPERR_POINTER;

        goto bail;
    }
    
    /* verify object ID in RtpAddr_t */
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QOS, S_QOS_LIST,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        hr = RTPERR_INVALIDRTPADDR;

        goto bail;
    }

    if (RtpBitTest2(pRtpAddr->dwAddrFlagsQ,
                    FGADDRQ_REGQOSDISABLE, FGADDRQ_QOSNOTALLOWED))
    {
        /* If QOS is forced disabled in the registry, or was disabled
         * because the user doesn't have the right to start RSVP do
         * nothing but succeed the call */
        hr = NOERROR;

        goto bail;
    }
    
    if (!RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_QOSRECVON))
    {
        hr = RTPERR_NOQOS;
        
        goto bail;
    }

    pRtpQosReserve = pRtpAddr->pRtpQosReserve;

    if (!pRtpQosReserve)
    {
        hr = RTPERR_INVALIDSTATE;

        goto bail;
    }

    if (pRtpQosReserve->dwStyle != RTPQOS_STYLE_SE)
    {
        hr = RTPERR_INVALIDSTATE;

        goto bail;
    }
    
    hr = NOERROR;
    
    if (RtpBitTest(dwOperation, RTPQOS_QOSLIST_FLUSH))
    {
        /* Empty the current list */
        pRtpQosReserve->dwNumFilters = 0;
    }

    if (RtpBitTest(dwOperation, RTPQOS_QOSLIST_ENABLE))
    {
        /* Add or Delete SSRCs */
        bAddDel = RtpBitTest(dwOperation, RTPQOS_QOSLIST_ADD)? 1:0;
        dwNumber = *pdwNumber;
        *pdwNumber = 0;
        
        for(i = 0; i < dwNumber; i++)
        {
            /* SSRCs ire handled in NETWORK order */
            *pdwNumber += RtpAddDeleteSSRC(pRtpAddr,
                                           pRtpQosReserve,
                                           pdwSSRC[i],
                                           bAddDel);
        }

        if (*pdwNumber == 0)
        {
            hr = RTPERR_QOS;
        }
        else
        {
            RtcpThreadCmd(&g_RtcpContext,
                          pRtpAddr,
                          RTCPTHRD_RESERVE,
                          RECV_IDX,
                          DO_NOT_WAIT);
        }
    }
    
 bail:
    return(hr);
}

/* Initialize to not specified a flowspec */
void InitializeFlowSpec(
        FLOWSPEC        *pFlowSpec,
        SERVICETYPE      ServiceType
	)
{
    pFlowSpec->TokenRate          = QOS_NOT_SPECIFIED;
    pFlowSpec->TokenBucketSize    = QOS_NOT_SPECIFIED;
    pFlowSpec->PeakBandwidth      = QOS_NOT_SPECIFIED;
    pFlowSpec->Latency            = QOS_NOT_SPECIFIED;
    pFlowSpec->DelayVariation     = QOS_NOT_SPECIFIED;
    pFlowSpec->ServiceType        = ServiceType;
    pFlowSpec->MaxSduSize         = QOS_NOT_SPECIFIED;
    pFlowSpec->MinimumPolicedSize = QOS_NOT_SPECIFIED;
}

/* Allocates a RtpQosReserve_t structure */
RtpQosReserve_t *RtpQosReserveAlloc(
        RtpAddr_t       *pRtpAddr
    )
{
    RtpQosReserve_t *pRtpQosReserve;
    
    pRtpQosReserve = (RtpQosReserve_t *)
        RtpHeapAlloc(g_pRtpQosReserveHeap, sizeof(RtpQosReserve_t));

    if (!pRtpQosReserve)
    {
        /* TODO log error */
        return((RtpQosReserve_t *)NULL);
    }

    ZeroMemory(pRtpQosReserve, sizeof(RtpQosReserve_t));
    
    pRtpQosReserve->dwObjectID = OBJECTID_RTPRESERVE;

    pRtpQosReserve->pRtpAddr = pRtpAddr;
    
    InitializeFlowSpec(&pRtpQosReserve->qos.ReceivingFlowspec,
                       SERVICETYPE_NOTRAFFIC);
    
    InitializeFlowSpec(&pRtpQosReserve->qos.SendingFlowspec,
                       SERVICETYPE_NOTRAFFIC);

    pRtpQosReserve->dwMaxFilters = 1;

    return(pRtpQosReserve);
}

/* Frees a RtpQosReserve_t structure */
RtpQosReserve_t *RtpQosReserveFree(RtpQosReserve_t *pRtpQosReserve)
{
    TraceFunctionName("RtpQosReserveFree");

    if (!pRtpQosReserve)
    {
        return(pRtpQosReserve);
    }
    
    if (pRtpQosReserve->dwObjectID != OBJECTID_RTPRESERVE)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QOS, S_QOS_RESERVE,
                _T("%s: pRtpQosReserve[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpQosReserve,
                pRtpQosReserve->dwObjectID, OBJECTID_RTPRESERVE
            ));

        return(NULL);
    }

    if (pRtpQosReserve->psAppName)
    {
        RtpHeapFree(g_pRtpQosBufferHeap, pRtpQosReserve->psAppName);
        pRtpQosReserve->psAppName = NULL;
    }

    if (pRtpQosReserve->psAppGUID)
    {
        RtpHeapFree(g_pRtpQosBufferHeap, pRtpQosReserve->psAppGUID);
        pRtpQosReserve->psAppGUID = NULL;
    }

    if (pRtpQosReserve->psPolicyLocator)
    {
        RtpHeapFree(g_pRtpQosBufferHeap, pRtpQosReserve->psPolicyLocator);
        pRtpQosReserve->psPolicyLocator = NULL;
    }

    if (pRtpQosReserve->pdwRsvpSSRC)
    {
        RtpHeapFree(g_pRtpQosReserveHeap, pRtpQosReserve->pdwRsvpSSRC);

        pRtpQosReserve->pdwRsvpSSRC = NULL;
    }

    if (pRtpQosReserve->pRsvpFilterSpec)
    {
        RtpHeapFree(g_pRtpQosReserveHeap, pRtpQosReserve->pRsvpFilterSpec);

        pRtpQosReserve->pRsvpFilterSpec = NULL;
    }
    
    /* Invalidate object */
    INVALIDATE_OBJECTID(pRtpQosReserve->dwObjectID);
    
    RtpHeapFree(g_pRtpQosReserveHeap, pRtpQosReserve);

    return(pRtpQosReserve);
}

/* Find the protocol info for a QOS enabled protocol */
HRESULT RtpGetQosEnabledProtocol(WSAPROTOCOL_INFO *pProtoInfo)
{
    HRESULT          hr;
    DWORD            dwSize;
    DWORD            dwError;
    DWORD            dwStatus;
    DWORD            dwIndex;
    int              Protocols[2];
    WSAPROTOCOL_INFO *pAllProtoInfo;

    TraceFunctionName("RtpGetQosEnabledProtocol");
    
    if (!pProtoInfo) {
        return(RTPERR_POINTER);
    }

    dwSize = sizeof(WSAPROTOCOL_INFO) * 16;
    
    pAllProtoInfo = (WSAPROTOCOL_INFO *)
        RtpHeapAlloc(g_pRtpQosBufferHeap, dwSize);

    if (!pAllProtoInfo)
    {
        return(RTPERR_MEMORY);
    }
    
    hr = RTPERR_QOS;

    Protocols[0] = IPPROTO_UDP;
    Protocols[1] = 0;
    
    ZeroMemory((char *)pAllProtoInfo, dwSize);
        
    dwStatus = WSAEnumProtocols(Protocols, pAllProtoInfo, &dwSize);

    if (dwStatus == SOCKET_ERROR) {
        
        TraceRetailWSAGetError(dwError);
        
        TraceRetail((
                CLASS_ERROR, GROUP_QOS, S_QOS_PROVIDER,
                _T("%s: WSAEnumProtocols ")
                _T("failed: %u (0x%X)\n"),
                _fname, dwError, dwError
            ));
        
    } else {
            
        for(dwIndex = 0; dwIndex < dwStatus; dwIndex++) {

            if (pAllProtoInfo[dwIndex].dwServiceFlags1 & XP1_QOS_SUPPORTED)
                break;
        }
            
        if (dwIndex >= dwStatus) {
            
            TraceRetail((
                    CLASS_ERROR, GROUP_QOS, S_QOS_PROVIDER,
                    _T("%s: WSAEnumProtocols ")
                    _T("failed: Unable to find QOS capable protocol"),
                    _fname
                ));
        } else {
            
            TraceDebug((
                    CLASS_INFO, GROUP_QOS, S_QOS_PROVIDER,
                    _T("%s: WSAEnumProtocols: QOS capable protocol found"),
                    _fname
                ));

            CopyMemory(pProtoInfo,
                       &pAllProtoInfo[dwIndex],
                       sizeof(WSAPROTOCOL_INFO));

            hr = NOERROR;
        }
    }
    
    RtpHeapFree(g_pRtpQosBufferHeap, pAllProtoInfo);
    
    return(hr);
}
            
/*
 * Make a reservation if a receiver (RESV messages), specify the
 * flowspec for a sender (PATH messages)
 * */
HRESULT RtpReserve(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwRecvSend
    )
{
    HRESULT            hr;
    DWORD              dwStatus;
    DWORD              dwError;
    
    int                len;
    DWORD              dwBufferSize;
    DWORD              dwImageNameSize;
    TCHAR_t           *psAppGUID;
    TCHAR_t           *psQosName;
    TCHAR_t           *psClass;
    
    QOS               *pQos;
    char              *ptr;
    RtpQosReserve_t   *pRtpQosReserve;

    /* Sender */
    QOS_DESTADDR      *pQosDestAddr;
    SOCKADDR_IN       *pSockAddrIn;
    QOS_SD_MODE       *pQosSdMode;
    
    /* Receiver */
    RSVP_RESERVE_INFO *pRsvpReserveInfo;
    FLOWDESCRIPTOR    *pFlowDescriptor;
    RSVP_FILTERSPEC   *pRsvpFilterspec;
    DWORD              dwStyle;
    DWORD              dwMaxBandwidth;

    DWORD              dwOutBufSize;

    TCHAR_t            sAddr[16];
    
    TraceFunctionName("RtpReserve");

    pRtpQosReserve = pRtpAddr->pRtpQosReserve;

    if (!pRtpQosReserve)
    {
        return(RTPERR_INVALIDSTATE);
    }

    dwRecvSend &= RECVSENDMASK;
    
    /* Decide buffer size to allocate */

    if (dwRecvSend == SEND_IDX)
    {
        dwMaxBandwidth = pRtpAddr->RtpNetSState.dwOutboundBandwidth;
        
        dwBufferSize =
            sizeof(QOS) +
            sizeof(QOS_DESTADDR) +
            sizeof(QOS_SD_MODE) +
            sizeof(SOCKADDR_IN) +
            sizeof(RSVP_RESERVE_INFO);
    }
    else
    {
        dwMaxBandwidth = pRtpAddr->RtpNetSState.dwInboundBandwidth;
        
        dwBufferSize =
            sizeof(QOS) +
            sizeof(RSVP_RESERVE_INFO) +
            sizeof(FLOWDESCRIPTOR) +
            sizeof(RSVP_FILTERSPEC) * pRtpQosReserve->dwMaxFilters;
    }

    if (pRtpQosReserve->psAppName)
    {
        dwImageNameSize = lstrlen(pRtpQosReserve->psAppName);
    }
    else
    {
        /* If we don't have an app name, generate a default from the
         * binary name */
        dwImageNameSize = 0;
        
        RtpGetImageName(NULL, &dwImageNameSize);

        dwImageNameSize++;
        
        pRtpQosReserve->psAppName =
            RtpHeapAlloc(g_pRtpQosBufferHeap,
                         dwImageNameSize  * sizeof(TCHAR_t));

        /* RtpGetImageName tests for NULL passed */
        RtpGetImageName(pRtpQosReserve->psAppName, &dwImageNameSize);
    }

    /*
     * Will compose a policy locator with a format similar to this:
     *     GUID=WWW.USERDOMAIN.COM,APP=RTCAPP.EXE,\
     *     SAPP=MICROSOFT REAL-TIME COMMUNICATIONS,VER=1.0,\
     *     SAPP=AUDIO,SAPP=G723.1,SAPP=THE USER STRING
     *
     * And an application name with a format similar to:
     *     RTCAPP.EXE
     */

    dwBufferSize +=
        sizeof(RSVP_POLICY_INFO) -
        sizeof(RSVP_POLICY) +
        RSVP_POLICY_HDR_LEN +
            
        RSVP_BYTE_MULTIPLE(IDPE_ATTR_HDR_LEN +
                           ((4 /* sizeof(_T("APP="))/sizeof(TCHAR) */ +
                             dwImageNameSize +
                             lstrlen(g_sPolicyLocator) +
                             MAX_QOS_CLASS +
                             6 /* sizeof(_T(",SAPP="))/sizeof(TCHAR) */ +
                             MAX_QOS_NAME +
                             1 +
                             MAX_QOS_APPGUID +
                             1 +
                             MAX_QOS_POLICY +
                             1) * sizeof(TCHAR_t))) +
        RSVP_BYTE_MULTIPLE(IDPE_ATTR_HDR_LEN +
                           ((dwImageNameSize + 1) * sizeof(TCHAR_t)));

    /* Allocate buffer */
    pQos = (QOS *) RtpHeapAlloc(g_pRtpQosBufferHeap, dwBufferSize);

    if (!pQos)
    {
        return(RTPERR_MEMORY);
    }

    CopyMemory(pQos, &pRtpQosReserve->qos, sizeof(QOS));

    /* Set as default No provider specific information */
    pQos->ProviderSpecific.len = 0;
    pQos->ProviderSpecific.buf = NULL;
    ptr = (char *)(pQos + 1);

    if (dwRecvSend == SEND_IDX)
    {
        TraceRetail((
                CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
                _T("%s: pRtpAddr[0x%p] SEND"),
                _fname, pRtpAddr
            ));
            
        /* Init the destination object if unicast */
        if (IS_UNICAST(pRtpAddr->dwAddr[REMOTE_IDX]))
        {
            if (pRtpAddr->dwAddr[REMOTE_IDX] && pRtpAddr->wRtpPort[REMOTE_IDX])
            {
                /* Initialize destination adddress */
                ZeroMemory(ptr, sizeof(QOS_DESTADDR) + sizeof(SOCKADDR_IN));

                pQosDestAddr = (QOS_DESTADDR *)ptr;
                pSockAddrIn = (SOCKADDR_IN *)(pQosDestAddr + 1);
                ptr += sizeof(QOS_DESTADDR) + sizeof(SOCKADDR_IN);

                /* Initialize QOS_DESTADDR */
                pQosDestAddr->ObjectHdr.ObjectType = QOS_OBJECT_DESTADDR;
                pQosDestAddr->ObjectHdr.ObjectLength =
                    sizeof(QOS_DESTADDR) +
                    sizeof(SOCKADDR_IN);
                pQosDestAddr->SocketAddress = (SOCKADDR *)pSockAddrIn;
                pQosDestAddr->SocketAddressLength = sizeof(SOCKADDR_IN);

                /* Initialize SOCKADDR_IN */
                pSockAddrIn->sin_family = AF_INET;
                pSockAddrIn->sin_addr.s_addr = pRtpAddr->dwAddr[REMOTE_IDX];
                pSockAddrIn->sin_port = pRtpAddr->wRtpPort[REMOTE_IDX];
            }
            else
            {
                TraceRetail((
                        CLASS_WARNING, GROUP_QOS, S_QOS_RESERVE,
                        _T("%s: pRtpAddr[0x%p] QOS_DESTADDR not added %s/%u"),
                        _fname, pRtpAddr,
                        RtpNtoA(pRtpAddr->dwAddr[REMOTE_IDX], sAddr),
                        ntohs(pRtpAddr->wRtpPort[REMOTE_IDX])
                    ));
            }
        }

        /* Init the ShapeDiscard structure if class AUDIO */
        if ( (RtpGetClass(pRtpAddr->dwIRtpFlags) == RTPCLASS_AUDIO) &&
             
             ( !IsRegValueSet(g_RtpReg.dwQosFlags) ||
               !RtpBitTest(g_RtpReg.dwQosFlags,
                           FGREGQOS_DONOTSET_BORROWMODE) ) )
        {
            pQosSdMode = (QOS_SD_MODE *)ptr;
            ptr += RTP_ALIGNED_SIZEOF(QOS_SD_MODE);
           
            /* Select borrow mode */
            pQosSdMode->ObjectHdr.ObjectType = QOS_OBJECT_SD_MODE;
            pQosSdMode->ObjectHdr.ObjectLength =
                RTP_ALIGNED_SIZEOF(QOS_SD_MODE);
            pQosSdMode->ShapeDiscardMode = TC_NONCONF_BORROW;
        }
        
        pRsvpReserveInfo = (RSVP_RESERVE_INFO *)ptr;
        
        /* Do not change the receiver */
        pQos->ReceivingFlowspec.ServiceType = SERVICETYPE_NOCHANGE;

        /* Scale the flow spec for the sender (if needed) */
        RtpScaleFlowSpec(&pQos->SendingFlowspec,
                         1,
                         1,
                         dwMaxBandwidth);

        /* Partially Init RSVP_RESERVE_INFO */
        ZeroMemory(pRsvpReserveInfo, sizeof(RSVP_RESERVE_INFO));
        pRsvpReserveInfo->ObjectHdr.ObjectType = RSVP_OBJECT_RESERVE_INFO;
        /* TODO expose a way to select confirmation, right now always
         * ask for confirmation */
        pRsvpReserveInfo->ConfirmRequest = 1;

        dwStyle = pRtpQosReserve->dwStyle;

        switch(dwStyle)
        {
        case RTPQOS_STYLE_DEFAULT:
            pRsvpReserveInfo->Style = RSVP_DEFAULT_STYLE;
            break;
        case RTPQOS_STYLE_WF:
            pRsvpReserveInfo->Style = RSVP_WILDCARD_STYLE;
            break;
        case RTPQOS_STYLE_FF:
            pRsvpReserveInfo->Style = RSVP_FIXED_FILTER_STYLE;
            break;
        case RTPQOS_STYLE_SE:
            pRsvpReserveInfo->Style = RSVP_SHARED_EXPLICIT_STYLE;
            break;
        default:
            pRsvpReserveInfo->Style = RSVP_DEFAULT_STYLE;
        }
        
        ptr += sizeof(RSVP_RESERVE_INFO);

        /*
         * Add QOS app ID later at ptr
         */
    }
    else
    {
        pRsvpReserveInfo = (RSVP_RESERVE_INFO *)ptr;

        /* Do not change the sender */
        pQos->SendingFlowspec.ServiceType = SERVICETYPE_NOCHANGE;

        /* Partially initialize RSVP_RESERVE_INFO */
        ZeroMemory(pRsvpReserveInfo, sizeof(RSVP_RESERVE_INFO));
        pRsvpReserveInfo->ObjectHdr.ObjectType = RSVP_OBJECT_RESERVE_INFO;
        /* MAYDO expose a way to select confirmation, right now always
         * ask for confirmation */
        pRsvpReserveInfo->ConfirmRequest = 1;

        dwStyle = pRtpQosReserve->dwStyle;

        if (dwStyle == RTPQOS_STYLE_SE)
        {
            /* Shared Explicit filter -- SE */

            if (pRtpQosReserve->pRsvpFilterSpec &&
                pRtpQosReserve->dwNumFilters > 0)
            {
                pRsvpReserveInfo->Style = RSVP_SHARED_EXPLICIT_STYLE;
                
                /* We have some filters */
                TraceRetail((
                        CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
                        _T("%s: pRtpAddr[0x%p] RECV ")
                        _T("Multicast(SE, %d)"),
                        _fname, pRtpAddr,
                        pRtpQosReserve->dwNumFilters
                    ));

                /* Scale the flow descriptor to dwNumFilters */
                RtpScaleFlowSpec(&pQos->ReceivingFlowspec,
                                 pRtpQosReserve->dwNumFilters,
                                 pRtpQosReserve->dwMaxFilters,
                                 dwMaxBandwidth);
                
                pFlowDescriptor = (FLOWDESCRIPTOR *)(pRsvpReserveInfo + 1);

                pRsvpFilterspec = (RSVP_FILTERSPEC *)(pFlowDescriptor + 1);

                /* Init RSVP_RESERVE_INFO */
                pRsvpReserveInfo->ObjectHdr.ObjectLength =
                    sizeof(RSVP_RESERVE_INFO) +
                    sizeof(FLOWDESCRIPTOR) +
                    (sizeof(RSVP_FILTERSPEC) * pRtpQosReserve->dwNumFilters);
                pRsvpReserveInfo->NumFlowDesc = 1;
                pRsvpReserveInfo->FlowDescList = pFlowDescriptor;
                    
                /* Init FLOWDESCRIPTOR */
                CopyMemory(&pFlowDescriptor->FlowSpec,
                           &pQos->ReceivingFlowspec,
                           sizeof(pQos->ReceivingFlowspec));
                pFlowDescriptor->NumFilters = pRtpQosReserve->dwNumFilters;
                pFlowDescriptor->FilterList = pRsvpFilterspec;

                /* Init RSVP_FILTERSPEC */
                CopyMemory(pRsvpFilterspec,
                           pRtpQosReserve->pRsvpFilterSpec,
                           pRtpQosReserve->dwNumFilters *
                           sizeof(RSVP_FILTERSPEC));

                /* Add QOS app ID later at ptr */
                ptr = (char *)pRsvpFilterspec +
                    pRtpQosReserve->dwNumFilters * sizeof(RSVP_FILTERSPEC);
            }
            else
            {
                /* No filters selected yet, use BEST_EFFORT */
                TraceRetail((
                        CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
                        _T("%s: pRtpAddr[0x%p] RECV ")
                        _T("Multicast(SE, %d) pass to BEST EFFORT"),
                        _fname, pRtpAddr,
                        pRtpQosReserve->dwNumFilters
                    ));

                pQos->ReceivingFlowspec.ServiceType = SERVICETYPE_BESTEFFORT;

                /* No pRsvpReserveInfo needed, hence do not add QOS
                 * app ID */
                pRsvpReserveInfo = (RSVP_RESERVE_INFO *)NULL;
            }
        }
        else if (dwStyle == RTPQOS_STYLE_WF)
        {
            /* Share N*FlowSpec -- WF */

            pRsvpReserveInfo->Style = RSVP_WILDCARD_STYLE;
            
            TraceRetail((
                    CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
                    _T("%s: pRtpAddr[0x%p] RECV Multicast(WF)"),
                    _fname, pRtpAddr
                ));

            /* Scale the flow spec to dwMaxFilters */
            RtpScaleFlowSpec(&pQos->ReceivingFlowspec,
                             pRtpQosReserve->dwMaxFilters,
                             pRtpQosReserve->dwMaxFilters,
                             dwMaxBandwidth);
            
            /* Init RSVP_RESERVE_INFO */
            pRsvpReserveInfo->ObjectHdr.ObjectLength =
                sizeof(RSVP_RESERVE_INFO);

            /* Add QOS app ID later at ptr */
            ptr = (char *)(pRsvpReserveInfo + 1);
        }
        else
        {
            /* RSVP_DEFAULT_STYLE || RSVP_FIXED_FILTER_STYLE */
            /* Unicast -- FF */

            pRsvpReserveInfo->Style = RSVP_DEFAULT_STYLE;
            
            TraceRetail((
                    CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
                    _T("%s: pRtpAddr[0x%p] RECV ")
                    _T("Unicast/Multicast(DEF STYLE)"),
                    _fname, pRtpAddr
                ));
            
            /* Scale the flow spec to dwMaxFilters */
            RtpScaleFlowSpec(&pQos->ReceivingFlowspec,
                             pRtpQosReserve->dwMaxFilters,
                             pRtpQosReserve->dwMaxFilters,
                             dwMaxBandwidth);
            
            /* Add QOS app ID later at ptr */
            ptr = (char *)(pRsvpReserveInfo + 1);
       }
    }

    /* Add QOS APP ID if reserve info was defined */
    if (pRsvpReserveInfo)
    {
        psAppGUID = pRtpQosReserve->psAppGUID;

        if (!psAppGUID)
        {
            /* Use default */
            psAppGUID = (TCHAR_t *)g_sAppGUID;
        }
        
        psQosName = NULL;

        if (pRtpQosReserve->pQosInfo[dwRecvSend])
        {
            psQosName = pRtpQosReserve->pQosInfo[dwRecvSend]->pName;
        }

        psClass = (TCHAR_t *)
            g_psRtpStreamClass[RtpGetClass(pRtpAddr->dwIRtpFlags)];

        len = AddQosAppID(ptr,
                          pRtpQosReserve->psAppName,
                          psAppGUID,
                          psClass,
                          psQosName,
                          pRtpQosReserve->psPolicyLocator);

        if (len > 0)
        {
            pRsvpReserveInfo->PolicyElementList = (RSVP_POLICY_INFO *)ptr;
            ptr += len;
        }

        pRsvpReserveInfo->ObjectHdr.ObjectLength = (DWORD)
            (ptr - (char *)pRsvpReserveInfo);
            
        /* Init ProviderSpecific */
        pQos->ProviderSpecific.len = (DWORD)(ptr - (char *)(pQos + 1));
        pQos->ProviderSpecific.buf = (char *)(pQos + 1);
    }

    hr = NOERROR;
    dwOutBufSize = 0;

    dwStatus = WSAIoctl(pRtpAddr->Socket[dwRecvSend],
                        SIO_SET_QOS,
                        pQos,
                        sizeof(QOS),
                        NULL,
                        0,
                        &dwOutBufSize,
                        NULL,
                        NULL);

    if (dwStatus)
    {
        hr = RTPERR_QOS;

        TraceRetailWSAGetError(dwError);
        
        TraceRetail((
                CLASS_ERROR, GROUP_QOS, S_QOS_RESERVE,
                _T("%s: pRtpAddr[0x%p] %s WSAIoctl(%u, SIO_SET_QOS) ")
                _T("failed: %u (0x%X)"),
                _fname, pRtpAddr,
                RTPRECVSENDSTR(dwRecvSend),
                pRtpAddr->Socket[dwRecvSend],
                dwError, dwError
            ));
    }
    else
    {
        TraceRetail((
                CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
                _T("%s: pRtpAddr[0x%p] %s WSAIoctl(%u, SIO_SET_QOS) ")
                _T("succeeded"),
                _fname, pRtpAddr,
                RTPRECVSENDSTR(dwRecvSend),
                pRtpAddr->Socket[dwRecvSend]
            ));
    }
    
    RtpHeapFree(g_pRtpQosBufferHeap, pQos);
    
    return(hr);
}

/*
 * Set to no traffic a receiver or sender leaving the other unchanged
 * */
HRESULT RtpUnreserve(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwRecvSend
    )
{

    HRESULT            hr;
    DWORD              dwStatus;
    DWORD              dwError;
    
    QOS                qos;
    RtpQosReserve_t   *pRtpQosReserve;

    DWORD              dwOutBufSize ;
    
    TraceFunctionName("RtpUnreserve");

    pRtpQosReserve = pRtpAddr->pRtpQosReserve;

    if (!pRtpQosReserve) {
        return(RTPERR_INVALIDSTATE);
    }

    dwRecvSend &= RECVSENDMASK;
    
    CopyMemory(&qos, &pRtpQosReserve->qos, sizeof(qos));
    
    qos.ProviderSpecific.len = 0;
    qos.ProviderSpecific.buf = NULL;
    
    if (dwRecvSend) {
        qos.SendingFlowspec.ServiceType   = SERVICETYPE_NOTRAFFIC;
        qos.ReceivingFlowspec.ServiceType = SERVICETYPE_NOCHANGE;
    } else {
        qos.SendingFlowspec.ServiceType   = SERVICETYPE_NOCHANGE;
        qos.ReceivingFlowspec.ServiceType = SERVICETYPE_NOTRAFFIC;
    }

    hr = NOERROR;
    dwOutBufSize = 0;

    dwStatus = WSAIoctl(pRtpAddr->Socket[dwRecvSend],
                        SIO_SET_QOS,
                        (LPVOID)&qos,
                        sizeof(qos),
                        NULL,
                        0,
                        &dwOutBufSize,
                        NULL,
                        NULL);

    if (dwStatus)
    {
        hr = RTPERR_QOS;

        TraceRetailWSAGetError(dwError);
        
        TraceRetail((
                CLASS_ERROR, GROUP_QOS, S_QOS_RESERVE,
                _T("%s: pRtpAddr[0x%p] %s WSAIoctl(%u, SIO_SET_QOS) ")
                _T("failed: %u (0x%X)"),
                _fname, pRtpAddr,
                RTPRECVSENDSTR(dwRecvSend),
                pRtpAddr->Socket[dwRecvSend],
                dwError, dwError
            ));
    }
    else
    {
        TraceRetail((
                CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
                _T("%s: pRtpAddr[0x%p] %s WSAIoctl(%u, SIO_SET_QOS) ")
                _T("succeeded"),
                _fname, pRtpAddr,
                RTPRECVSENDSTR(dwRecvSend),
                pRtpAddr->Socket[dwRecvSend]
            ));
    }

    return(hr);
}

/* Scales the flowspec based on the max bandwidth to be used, the
 * maximum number of participants that will share the bandwidth, and
 * the current number of participants sharing the bandwidth. In
 * multicast, the bandwidth allocated is always proportional to the
 * maximum number of participants, i.e. for max participants = 5, and
 * max bandwidth = 100k, 2 participants will receive 20k, 3 will
 * receive 30k, and not the max of 100k. This is so to maintain a
 * consistent resource allocation for each participant independent of
 * the current number */
HRESULT RtpScaleFlowSpec(
        FLOWSPEC        *pFlowSpec,
        DWORD            dwNumParticipants,
        DWORD            dwMaxParticipants,
        DWORD            dwBandwidth
    )
{
    DWORD            dwOverallBW;
    DWORD            factor1;
    DWORD            factor2;
    DWORD            RSVPTokenRate;
    DWORD            RSVPPeakBandwidth;

    TraceFunctionName("RtpScaleFlowSpec");

    dwBandwidth /= 8;  /* flowspec is in bytes/sec */
    dwOverallBW = pFlowSpec->TokenRate * dwMaxParticipants;

    TraceRetail((
            CLASS_INFO, GROUP_QOS, S_QOS_FLOWSPEC,
            _T("%s: NumPars:%u, MaxPars:%u, Bandwidth:%u b/s)"),
            _fname, dwNumParticipants, dwMaxParticipants, dwBandwidth*8
        ));            
    TraceRetail((
            CLASS_INFO, GROUP_QOS, S_QOS_FLOWSPEC,
            _T("%s: Initial flowspec(TokenRate:%6u, TokenBucketSize:%u, ")
            _T("PeakBandW:%6u, ServiceType:%u, ")
            _T("MaxSDU:%u MinSize:%u)"),
            _fname,
            pFlowSpec->TokenRate, pFlowSpec->TokenBucketSize,
            pFlowSpec->PeakBandwidth, pFlowSpec->ServiceType,
            pFlowSpec->MaxSduSize, pFlowSpec->MinimumPolicedSize
        ));

    if (!dwBandwidth || !dwOverallBW)
    {
        return(RTPERR_INVALIDARG);
    }
    
    if (dwOverallBW <= dwBandwidth)
    {
        /* use as it is, scale up to dwNumParticipants */
        pFlowSpec->TokenRate *= dwNumParticipants;
        pFlowSpec->TokenBucketSize *= dwNumParticipants;
        if (pFlowSpec->PeakBandwidth != QOS_NOT_SPECIFIED)
        {
            pFlowSpec->PeakBandwidth *= dwNumParticipants;
        }
    }
    else
    {
        /* don't have all we need, scale according to number of
         * participants */
        
        if (dwNumParticipants == dwMaxParticipants)
        {
            /* use all the bandwidth available */

            /* TokenRate = Bw
             * TokenRate = Bw * 1
             * TokenRate = Bw * [ TokenRate1 / TokenRate ]
             * TokenRate = TokenRate * [ Bw / TokenRate ]
             * TokenRate = TokenRate * [ factor1 / factor2 ]
             * */

            factor1 = dwBandwidth;
            factor2 = pFlowSpec->TokenRate;
        }
        else
        {
            /* use the bandwidth according to number of participants */
            
            /* TokenRate = Bw * (Num / Max)
             * TokenRate = [ Bw * (Num / Max) ] * 1
             * TokenRate = [ Bw * (Num / Max) ] * [ TokenRate / TokenRate ]
             * TokenRate = TokenRate * [ Bw * (Num / Max) ] / TokenRate
             * TokenRate = TokenRate * [ Bw * Num ] / [ Max * TokenRate ]
             * TokenRate = TokenRate * factor1 / factor2
             * */
            
            factor1 = dwBandwidth * dwNumParticipants;
            factor2 = pFlowSpec->TokenRate * dwMaxParticipants;
        }

        /* scale TokenRate up or down */
        pFlowSpec->TokenRate =
            (pFlowSpec->TokenRate * factor1) / factor2;
            
        if (factor1 > factor2)
        {
            /* can still scale up the other parameters */
                
            pFlowSpec->TokenBucketSize =
                ((pFlowSpec->TokenBucketSize * factor1) / factor2);

            if (pFlowSpec->PeakBandwidth != QOS_NOT_SPECIFIED)
            {
                pFlowSpec->PeakBandwidth =
                    ((pFlowSpec->PeakBandwidth * factor1) / factor2);
            }
        }
    }

    /* The bandwidth we request includes RTP/UDP/IP headers overhead,
     * but RSVP also scales up to consider headers overhead, to ovoid
     * requesting more bandwidth than we intend, pass to RSVP a
     * smaller value such that the final one RSVP comes up with would
     * be the original value we requested.
     *
     * UDP+IP = 28 bytes
     * RSVPSP Applies the following scale up:
     *
     * NewTokenRate = TokenRate * [ (MinPolizedSize + 28) / MinPolizedSize ]
     *
     * So we do here the reverse scale down to cancel the scale up:
     *
     * NewTokenRate = TokenRate * [ MinPolizedSize / (MinPolizedSize + 28) ]
     */

    if (pFlowSpec->MinimumPolicedSize > 0)
    {
        RSVPTokenRate =
            (pFlowSpec->TokenRate * 1000) /
            (1000 + 28000/pFlowSpec->MinimumPolicedSize);
    }

    RSVPPeakBandwidth = pFlowSpec->PeakBandwidth;

    if (RSVPPeakBandwidth != QOS_NOT_SPECIFIED)
    {
        RSVPPeakBandwidth =
            (pFlowSpec->PeakBandwidth * 1000) /
            (1000 + 28000/pFlowSpec->MinimumPolicedSize);
    }

    TraceRetail((
            CLASS_INFO, GROUP_QOS, S_QOS_FLOWSPEC,
            _T("%s: Scaled  flowspec(TokenRate:%6u, TokenBucketSize:%u, ")
            _T("PeakBandW:%6u, ServiceType:%u, ")
            _T("MaxSDU:%u MinSize:%u)"),
            _fname,
            pFlowSpec->TokenRate, pFlowSpec->TokenBucketSize,
            pFlowSpec->PeakBandwidth, pFlowSpec->ServiceType,
            pFlowSpec->MaxSduSize, pFlowSpec->MinimumPolicedSize
        ));
    
    TraceRetail((
            CLASS_INFO, GROUP_QOS, S_QOS_FLOWSPEC,
            _T("%s: Applied flowspec(TokenRate:%6u, TokenBucketSize:%u, ")
            _T("PeakBandW:%6u, ServiceType:%u, ")
            _T("MaxSDU:%u MinSize:%u)"),
            _fname,
            RSVPTokenRate, pFlowSpec->TokenBucketSize,
            RSVPPeakBandwidth, pFlowSpec->ServiceType,
            pFlowSpec->MaxSduSize, pFlowSpec->MinimumPolicedSize
        ));
    
    pFlowSpec->TokenRate = RSVPTokenRate;
    pFlowSpec->PeakBandwidth = RSVPPeakBandwidth;

    return(NOERROR);
}

/**********************************************************************
 * QOS notifications
 **********************************************************************/
HRESULT StartRtcpQosNotify(
        RtcpContext_t  *pRtcpContext,
        RtcpAddrDesc_t *pRtcpAddrDesc
    )
{
    HRESULT         hr;
    DWORD           dwStatus;
    DWORD           dwError;
    DWORD           dwMaxTry;
    BOOL            bPending;
    RtpQosNotify_t *pRtpQosNotify;
    RtpAddr_t      *pRtpAddr;

    TraceFunctionName("StartRtcpQosNotify");

    if (RtpBitTest(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_NOTIFYPENDING))
    {
        /* Already started, do nothhing */
        return(NOERROR);
    }
        
    pRtpQosNotify = pRtcpAddrDesc->pRtpQosNotify;
    pRtpAddr = pRtcpAddrDesc->pRtpAddr;
    
    /* Overlapped structure */
    pRtpQosNotify->Overlapped.hEvent = pRtpQosNotify->hQosNotifyEvent;

    bPending = FALSE;
    
    for(dwError = WSAENOBUFS, dwMaxTry = 3;
        (dwError == WSAENOBUFS) && dwMaxTry;
        dwMaxTry--)
    {
        TraceDebug((
                CLASS_INFO, GROUP_QOS, S_QOS_NOTIFY,
                _T("%s: pRtcpAddrDesc[0x%p]: pBuffer[0x%p] Size: %u"),
                _fname, pRtcpAddrDesc,
                pRtpQosNotify->ProviderInfo,
                pRtpQosNotify->dwProviderLen
            ));
        
        if (pRtpQosNotify->ProviderInfo)
        {
            /* post request for asynchronous QOS notification */
            dwStatus = WSAIoctl(
                    pRtpAddr->Socket[SOCK_RECV_IDX],
                    SIO_GET_QOS,
                    NULL,
                    0, 
                    pRtpQosNotify->ProviderInfo,
                    pRtpQosNotify->dwProviderLen,
                    &pRtpQosNotify->dwTransfered,
                    &pRtpQosNotify->Overlapped,
                    NULL);
        }
        else
        {
            /* no buffer yet, allocate one */
            ReallocateQosBuffer(pRtpQosNotify);
            continue;
        }
        
        if (!dwStatus)
        {
            /* Operation succeeded */
            dwError = 0;

            /* I/O will complete later */
            bPending = TRUE;
            
            TraceDebug((
                    0, GROUP_QOS, S_QOS_NOTIFY,
                    _T("%s: pRtcpAddrDesc[0x%p]: ")
                    _T("Status: 0 (0x0) I/O will complete later"),
                    _fname, pRtcpAddrDesc
                ));
        }
        else
        {
            TraceRetailWSAGetError(dwError);
            
            if (dwError == WSA_IO_PENDING)
            {
                /* I/O will complete later */
                TraceDebug((
                        CLASS_INFO, GROUP_QOS, S_QOS_NOTIFY,
                        _T("%s: pRtcpAddrDesc[0x%p]: ")
                        _T("Status: %u (0x%X), Error: %u (0x%X)"),
                        _fname, pRtcpAddrDesc,
                        dwStatus, dwStatus, dwError, dwError
                    ));

                bPending = TRUE;
            }
            else if (dwError == WSAENOBUFS)
            {
                /* Reallocate a bigger buffer */
                TraceRetail((
                        CLASS_WARNING, GROUP_QOS, S_QOS_NOTIFY,
                        _T("%s: pRtcpAddrDesc[0x%p]: ")
                        _T("Buffer too small"),
                        _fname, pRtcpAddrDesc
                    ));
                
                ReallocateQosBuffer(pRtpQosNotify);
                
            }
            else if (dwError == WSAEOPNOTSUPP)
            {
                TraceRetail((
                        CLASS_WARNING, GROUP_QOS, S_QOS_NOTIFY,
                        _T("%s: pRtcpAddrDesc[0x%p]: ")
                        _T("Notifications not supported: %u (0x%X)"),
                        _fname, pRtcpAddrDesc,
                        dwError, dwError
                    ));
            }
            else
            {
                TraceRetail((
                        CLASS_ERROR, GROUP_QOS, S_QOS_NOTIFY,
                        _T("%s: pRtcpAddrDesc[0x%p]: ")
                        _T("overlapped notification ")
                        _T("failed to start: %u (0x%X)"),
                        _fname, pRtcpAddrDesc,
                        dwError, dwError
                    ));
                /*
                 * !!! WARNING !!!
                 *
                 * Unexpected error, try to start notifications later
                 *
                 * May notify (send event) about this.
                 * */
            }
        }
    }

    if (bPending)
    {
        hr = NOERROR;
        
        RtpBitSet(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_NOTIFYPENDING);
            
        pRtcpAddrDesc->lQosPending = 1;

        if (!RtpBitTest(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_NOTIFYBUSY)) {

            /* Currently in StartQ, move to BusyQ */
            move2ql(&pRtcpContext->QosBusyQ,
                    &pRtcpContext->QosStartQ,
                    NULL,
                    &pRtcpAddrDesc->QosQItem);

            RtpBitSet(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_NOTIFYBUSY);
        }
    }
    else
    {
        /* Failed to start, schedule for later */
        hr = RTPERR_QOS;

        RtpBitReset(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_NOTIFYPENDING);
        
        /* MAYDO Be able to schedule failed notifications later and
         * define time somewhere else rather than defining a hardcoded
         * value.
         *
         * Currently the RTCP thread doesn't do a periodic checking
         * for failed notifications that need another "try", I'm not
         * shure if that is even needed, so far failure to start
         * notifications other than because we are currently using
         * best-effort, will also continue to fail later. Some part of
         * the code (e.g. this one) behave (with no bad side effect)
         * as if future scheduling were in place.  Currently,
         * notifications, once failed, will not be attempted later,
         * the exception is when using SE, but in that case they will
         * be explicitly re-started. */

        pRtpQosNotify->dNextStart = RtpGetTimeOfDay((RtpTime_t *)NULL) + 1;

        /* If was in BusyQ, move back to StartQ */
        if (RtpBitTest(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_NOTIFYBUSY))
        {
            /* Currently in BusyQ, move back to StartQ */
            dequeue(&pRtcpContext->QosBusyQ,
                    NULL,
                    &pRtcpAddrDesc->QosQItem);

            RtpBitReset(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_NOTIFYBUSY);
        }
        else
        {
            /* Currently in StartQ, remove from there */
            dequeue(&pRtcpContext->QosStartQ,
                    NULL,
                    &pRtcpAddrDesc->QosQItem);
        }

        /* Enqueue in order */
        enqueuedK(&pRtcpContext->QosStartQ,
                  NULL,
                  &pRtcpAddrDesc->QosQItem,
                  pRtpQosNotify->dNextStart);
    }
     
    return(hr);
}

HRESULT ConsumeRtcpQosNotify(
        RtcpContext_t  *pRtcpContext,
        RtcpAddrDesc_t *pRtcpAddrDesc
    )
{
    HRESULT         hr;
    BOOL            bStatus;
    DWORD           dwError;
    BOOL            bRestart;
    char            str[256];
    
    RtpQosNotify_t *pRtpQosNotify;
    RtpAddr_t      *pRtpAddr;

    TraceFunctionName("ConsumeRtcpQosNotify");
    
    pRtpQosNotify = pRtcpAddrDesc->pRtpQosNotify;
    pRtpAddr = pRtcpAddrDesc->pRtpAddr;

    hr       = NOERROR;
    bRestart = FALSE;
    dwError  = NOERROR;
    
    bStatus = WSAGetOverlappedResult(
            pRtcpAddrDesc->Socket[SOCK_RECV_IDX], /* SOCKET s */
            &pRtpQosNotify->Overlapped,  /* LPWSAOVERLAPPED lpOverlapped */
            &pRtpQosNotify->dwTransfered,/* LPDWORD lpcbTransfer */
            FALSE,                       /* BOOL fWait */
            &pRtpQosNotify->dwNotifyFlags /* LPDWORD lpdwFlags */
        );
            
    if (!bStatus)
    {
        TraceRetailWSAGetError(dwError);

        if (dwError == WSA_OPERATION_ABORTED ||
            dwError == WSAEINTR ||
            dwError == WSAENOBUFS ||
            dwError == WSAEMSGSIZE)
        {
            TraceRetail((
                    CLASS_WARNING, GROUP_QOS, S_QOS_NOTIFY,
                    _T("%s: pRtcpAddrDesc[0x%p] Transfered:%u ")
                    _T("Error: %u (0x%X)"),
                    _fname, pRtcpAddrDesc, pRtpQosNotify->dwTransfered,
                    dwError, dwError
                ));
        }
        else
        {
            /* If sockets were closed I will get error WSAENOTSOCK */
            if (dwError == WSAENOTSOCK &&
                RtpBitTest(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_SHUTDOWN1))
            {
                /* Use FGADDRD_SHUTDOWN1 because FGADDRD_SHUTDOWN2 is
                 * set after the sockets were closed. */
                TraceRetail((
                        CLASS_WARNING, GROUP_QOS, S_QOS_NOTIFY,
                        _T("%s: pRtcpAddrDesc[0x%p] Transfered:%u ")
                        _T("Error: %u (0x%X) shutting down"),
                        _fname, pRtcpAddrDesc, pRtpQosNotify->dwTransfered,
                        dwError, dwError
                    ));
            }
            else
            {
                TraceRetail((
                        CLASS_ERROR, GROUP_QOS, S_QOS_NOTIFY,
                        _T("%s: pRtcpAddrDesc[0x%p] Transfered:%u ")
                        _T("Error: %u (0x%X)"),
                        _fname, pRtcpAddrDesc, pRtpQosNotify->dwTransfered,
                        dwError, dwError
                    ));
            }
        }

        if (dwError == WSA_IO_INCOMPLETE)
        {
            /* I/O hasn't completed yet */
        }
        else if ( (dwError == WSA_OPERATION_ABORTED) ||
                  (dwError == WSAEINTR) )
        {
            /* Socket closed, I/O completed */
            RtpBitReset(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_NOTIFYPENDING);

            pRtcpAddrDesc->lQosPending = 0;
        }
        else if (dwError == WSAENOBUFS)
        {
            /* ProviderSpecific buffer not enough big, reallocate a
             * big one */

            /* Buffer not enough big, I/O completed */
            RtpBitReset(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_NOTIFYPENDING);
            
            pRtcpAddrDesc->lQosPending = 0;
            
            TraceRetail((
                    CLASS_WARNING, GROUP_QOS, S_QOS_NOTIFY,
                    _T("%s: pRtcpAddrDesc[0x%p] Buffer too small: %u"),
                    _fname, pRtcpAddrDesc, pRtpQosNotify->dwProviderLen
                ));
            
            ReallocateQosBuffer(pRtpQosNotify);

            bRestart = TRUE;
        }
        else
        {
            /* Error, I/O completed */
            RtpBitReset(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_NOTIFYPENDING);

            pRtcpAddrDesc->lQosPending = 0;

            /* On any other error, including WSAECONNRESET and
             * WSAEMSGSIZE, re-start I/O */
            bRestart = TRUE;
        }

        pRtpQosNotify->dwError = dwError;
    }
    else
    {
        /* I/O completed normally */
        pRtpQosNotify->dwError = dwError;
        
        RtpBitReset(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_NOTIFYPENDING);

        pRtcpAddrDesc->lQosPending = 0;

        if (pRtpQosNotify->dwTransfered > 0)
        {
            TraceRetail((
                    CLASS_INFO, GROUP_QOS, S_QOS_NOTIFY,
                    _T("%s: pRtcpAddrDesc[0x%p] I/O completed fine, ")
                    _T("Transfered:%u"),
                    _fname, pRtcpAddrDesc, pRtpQosNotify->dwTransfered
                ));
            
            bRestart = TRUE;
        
            /* packet received, scan header */
            RtcpOnReceiveQosNotify(pRtcpAddrDesc);
        }
        else
        {
            /* Something is wrong as there are zero transfered
             * bytes. QOS notifications will stop */
            TraceRetail((
                    CLASS_ERROR, GROUP_QOS, S_QOS_NOTIFY,
                    _T("%s: pRtcpAddrDesc[0x%p] I/O completed fine, ")
                    _T("but Transfered=%u, QOS notifications will stop"),
                    _fname, pRtcpAddrDesc, pRtpQosNotify->dwTransfered
                ));
        }
    }

    if (RtpBitTest(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_SHUTDOWN2))
    {
        /* Shutting down, we were waiting for this completion to
         * happen, remove from QosStopQ. No need to move it to a free
         * list as the pRtcpAddrDesc lives also in other lists on
         * which there is a free list like AddrDescFreeQ */
        dequeue(&pRtcpContext->QosStopQ,
                NULL,
                &pRtcpAddrDesc->QosQItem);
    }
    else
    {
        if (bRestart &&
            !RtpBitTest(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_SHUTDOWN1))
        {
            hr = StartRtcpQosNotify(pRtcpContext, pRtcpAddrDesc); 
        }
        else
        {
            /* Item is left in QosBusyQ, it will be removed by
             * RtcpAddrDescDel (if the I/O is not pending) */
            /* Empty body */
        }
    }

    return(hr);
}

DWORD RtcpOnReceiveQosNotify(RtcpAddrDesc_t *pRtcpAddrDesc)
{
    DWORD            dwError;
    RtpAddr_t       *pRtpAddr;
    RtpQosNotify_t  *pRtpQosNotify;
    QOS             *pQos;
    DWORD            dwEvent;
    DWORD            i;

    TraceFunctionName("RtcpOnReceiveQosNotify");

    pRtpQosNotify = pRtcpAddrDesc->pRtpQosNotify;
    
    /* If notification is valid, pRtpQosNotify->dwError contains the
     * status code (aka the QOS notification) */
    dwError = RtpValidateQosNotification(pRtpQosNotify);

    if (dwError == NOERROR)
    {
        pRtpAddr = pRtcpAddrDesc->pRtpAddr;
        
        pQos = (QOS *)pRtpQosNotify->ProviderInfo;

        /* Obtain the QOS notification */
        dwEvent = pRtpQosNotify->dwError;

        TraceRetail((
                CLASS_INFO, GROUP_QOS, S_QOS_NOTIFY,
                _T("%s: pRtcpAddrDesc[0x%p] pRtpAddr[0x%p] ")
                _T("processing QOS notification: %u"),
                _fname, pRtcpAddrDesc, pRtpAddr, dwEvent
            ));
        
        if (dwEvent >= WSA_QOS_RECEIVERS &&
            dwEvent <= WSA_QOS_RESERVED_PETYPE)
        {
            /* Known QOS notification */
            
            dwEvent -= (WSA_QOS_RECEIVERS - RTPQOS_RECEIVERS);

            /* Update state if needed */
            RtcpUpdateSendState(pRtpAddr, dwEvent);
            
            /* Post event if allowed */
            RtpPostEvent(pRtpAddr,
                         NULL,
                         RTPEVENTKIND_QOS,
                         dwEvent,
                         0,
                         0);

#if DBG > 0
            dumpQOS(_fname, pQos);

            if (pQos->ProviderSpecific.len > 0)
            {
            
                dumpObjectType(_fname,
                               pQos->ProviderSpecific.buf,
                               pQos->ProviderSpecific.len);
            }
#endif
        }
        else
        {
            /* Unknown QOS notification */
            
            TraceRetail((
                    CLASS_ERROR, GROUP_QOS, S_QOS_NOTIFY,
                    _T("%s: pRtcpAddrDesc[0x%p] ")
                    _T("QOS notification out of range: %u (0x%X)"),
                    _fname, pRtcpAddrDesc, dwEvent, dwEvent
                ));
        }
    }
    else
    {
        /* Bad constructed QOS notification */
        TraceRetail((
                CLASS_WARNING, GROUP_QOS, S_QOS_NOTIFY,
                _T("%s: pRtcpAddrDesc[0x%p] ")
                _T("Invalid QOS notification: %s (0x%X)"),
                _fname, pRtcpAddrDesc, RTPERR_TEXT(dwError), dwError
            ));
    }

    return(dwError);
}

/* Buffer is not enough big, obtain one big enough, return TRUE if
 * buffer is available, FALSE otherwise */
BOOL ReallocateQosBuffer(RtpQosNotify_t *pRtpQosNotify)
{
    DWORD            dwNewSize;
    
    TraceFunctionName("ReallocateQosBuffer");

    dwNewSize = 0;
    
    /* Buffer not enough big */
    if (pRtpQosNotify->ProviderInfo)
    {
        dwNewSize = *(DWORD *)pRtpQosNotify->ProviderInfo;

        TraceRetail((
                CLASS_WARNING, GROUP_QOS, S_QOS_NOTIFY,
                _T("%s: pRtpQosNotify[0x%p]: ")
                _T("Buffer not enough big 0x%p/%u, requested: %u"),
                _fname, pRtpQosNotify,
                pRtpQosNotify->ProviderInfo, pRtpQosNotify->dwProviderLen,
                dwNewSize
            ));
    }
                
    if (dwNewSize < QOS_BUFFER_SIZE)
    {
        dwNewSize = QOS_BUFFER_SIZE;
    }
                
    if (dwNewSize > QOS_MAX_BUFFER_SIZE)
    {
        dwNewSize = QOS_MAX_BUFFER_SIZE;
    }
                
    if (dwNewSize > pRtpQosNotify->dwProviderLen)
    {
        /* Free old buffer */
        if (pRtpQosNotify->ProviderInfo)
        {
            RtpHeapFree(g_pRtpQosBufferHeap, pRtpQosNotify->ProviderInfo);
            
            pRtpQosNotify->dwProviderLen = 0;
        }
                    
        /* Allocate new buffer */
        pRtpQosNotify->ProviderInfo = (char *)
            RtpHeapAlloc(g_pRtpQosBufferHeap, dwNewSize);
                    
        if (pRtpQosNotify->ProviderInfo)
        {
            pRtpQosNotify->dwProviderLen = dwNewSize;

            TraceRetail((
                    CLASS_INFO, GROUP_QOS, S_QOS_NOTIFY,
                    _T("%s: pRtpQosNotify[0x%p]: New buffer 0x%p/%u"),
                    _fname, pRtpQosNotify,
                    pRtpQosNotify->ProviderInfo, pRtpQosNotify->dwProviderLen
                ));
            
            return(TRUE);
        }
    }

    return(FALSE);
}

/*
 * Creates and initialize a RtpQosNotify_t structure
 * */
RtpQosNotify_t *RtpQosNotifyAlloc(
        RtcpAddrDesc_t  *pRtcpAddrDesc
    )
{
    DWORD            dwError;
    RtpQosNotify_t  *pRtpQosNotify;
    TCHAR            Name[128];
    
    TraceFunctionName("RtpQosNotifyAlloc");
  
    pRtpQosNotify = RtpHeapAlloc(g_pRtpQosNotifyHeap, sizeof(RtpQosNotify_t));

    if (!pRtpQosNotify) {

        TraceRetail((
                CLASS_ERROR, GROUP_QOS, S_QOS_NOTIFY,
                _T("%s: pRtcpAddrDesc[0x%p failed to allocate memory"),
                _fname, pRtcpAddrDesc
            ));
 
        goto bail;
    }
    
    ZeroMemory(pRtpQosNotify, sizeof(RtpQosNotify_t));

    pRtpQosNotify->dwObjectID = OBJECTID_RTPNOTIFY;

    pRtpQosNotify->pRtcpAddrDesc = pRtcpAddrDesc;
    
    /* Create a named event for overlapped completion */
    _stprintf(Name, _T("%X:pRtpQosNotify[0x%p]->hQosNotifyEvent"),
              GetCurrentProcessId(), pRtpQosNotify);

    pRtpQosNotify->hQosNotifyEvent = CreateEvent(
            NULL,  /* LPSECURITY_ATTRIBUTES lpEventAttributes */
            FALSE, /* BOOL bManualReset */
            FALSE, /* BOOL bInitialState */
            Name   /* LPCTSTR lpName */
        );
    
    if (!pRtpQosNotify->hQosNotifyEvent)
    {
        TraceRetailGetError(dwError);
        
        TraceRetail((
                CLASS_ERROR, GROUP_QOS, S_QOS_NOTIFY,
                _T("%s: pRtcpAddrDesc[0x%p] failed to create ")
                _T("hQosNotifyEvent %u (0x%X)"),
                _fname, pRtcpAddrDesc, dwError, dwError
            ));
        
        goto bail;
    }

    /* Create initial Provider buffer */
    ReallocateQosBuffer(pRtpQosNotify);
    
    return(pRtpQosNotify);

 bail:
    if (pRtpQosNotify)
    {
        RtpQosNotifyFree(pRtpQosNotify);
    }

    return((RtpQosNotify_t *)NULL);
}

/*
 * Deinitilize and frees a RtpQosNotify_t structure
 * */
RtpQosNotify_t *RtpQosNotifyFree(RtpQosNotify_t *pRtpQosNotify)
{
    TraceFunctionName("RtpQosNotifyFree");

    if (!pRtpQosNotify)
    {
        /* TODO may be log */
        return(pRtpQosNotify);
    }
    
    if (pRtpQosNotify->dwObjectID != OBJECTID_RTPNOTIFY)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QOS, S_QOS_NOTIFY,
                _T("%s: pRtpQosNotify[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpQosNotify,
                pRtpQosNotify->dwObjectID, OBJECTID_RTPNOTIFY
            ));

        return(NULL);
    }

    /* Close event for asynchronous QOS notifications */
    if (pRtpQosNotify->hQosNotifyEvent)
    {
        CloseHandle(pRtpQosNotify->hQosNotifyEvent);
        pRtpQosNotify->hQosNotifyEvent = NULL;
    }

    /* Release provider buffer */
    if (pRtpQosNotify->ProviderInfo)
    {
        RtpHeapFree(g_pRtpQosBufferHeap, pRtpQosNotify->ProviderInfo);
        
        pRtpQosNotify->ProviderInfo = NULL;
        
        pRtpQosNotify->dwProviderLen = 0;
    }

    /* Invalidate object */
    INVALIDATE_OBJECTID(pRtpQosNotify->dwObjectID);
    
    /* Release main block */
    RtpHeapFree(g_pRtpQosNotifyHeap, pRtpQosNotify);

    return(pRtpQosNotify);
}

/*+++

  Description:

        This routine generates the application identity PE given the
        name and policy locator strings for the application.

        szAppName is used to construct the CREDENTIAL attribute of the
        Identity PE. Its subtype is set to ASCII_ID.

        szPolicyLocator is used to construct the POLICY_LOCATOR
        attribute of the Identity PE. Its subtype is set to ASCII_DN.

        Refer to draft-ietf-rap-rsvp-identity-03.txt and
        draft-bernet-appid-00.txt for details on the Identity Policy
        Elements.  Also draft-bernet-appid-00.txt conatins some
        examples for arguments szPolicyLocator and szAppName.

        The PE is generated in the supplied buffer. If the length of
        the buffer is not enough, zero is returned.

    Parameters:  szAppName          app name, string, caller supply
                 szPolicyLocator    Policy Locator string, caller supply
                 wBufLen            length of caller allocated buffer
                 pAppIdBuf          pointer to caller allocated buffer

    Return Values:
        Number of bytes used from buffer
---*/
DWORD AddQosAppID(
        IN OUT  char       *pAppIdBuf,
        IN      TCHAR_t    *psAppName,
        IN      TCHAR_t    *psAppGUID,
        IN      TCHAR_t    *psClass,
        IN      TCHAR_t    *psQosName,
        IN      TCHAR_t    *psPolicyLocator
    )
{
    int              len;
    RSVP_POLICY_INFO *pPolicyInfo;
    RSVP_POLICY     *pPolicy;
    IDPE_ATTR       *pAttr;
    TCHAR_t         *ptr;
    USHORT           nAppIdAttrLen;
    USHORT           nPolicyLocatorAttrLen;
    USHORT           nTotalPaddedLen;

    TraceFunctionName("AddQosAppID");

    /* Set the RSVP_POLICY_INFO header */
    pPolicyInfo = (RSVP_POLICY_INFO *)pAppIdBuf;
    
    /* Now set up RSVP_POLICY object header */
    pPolicy = pPolicyInfo->PolicyElement;

    /* The first application id attribute is the policy locator string */
    pAttr = ( IDPE_ATTR * )( (char *)pPolicy + RSVP_POLICY_HDR_LEN );

    /*
     * Policy locator = GUID + App name + Default policy + class + codec name
     *                  [+ Append]
     */

    /* Fill up the attribute policy locator */
    ptr = (TCHAR_t *)pAttr->PeAttribValue;
    len = 0;

    if (psAppGUID)
    {
        len = _stprintf(ptr, _T("GUID=%s,"), psAppGUID);
        ptr += len;
    }
    
    len = _stprintf(ptr, _T("APP=%s%s%s,SAPP=%s"),
                    psAppName, g_sPolicyLocator, psClass, psQosName);
    ptr += len;

    if (psPolicyLocator)
    {
        _stprintf(ptr, _T(",%s"), psPolicyLocator);
    }
    
    nPolicyLocatorAttrLen = (USHORT)
        (lstrlen((TCHAR_t *)pAttr->PeAttribValue) + 1) * sizeof(TCHAR_t);

    nPolicyLocatorAttrLen += IDPE_ATTR_HDR_LEN;

    /* Attribute length must be in network order. */
    pAttr->PeAttribType     = PE_ATTRIB_TYPE_POLICY_LOCATOR;
    pAttr->PeAttribSubType  = POLICY_LOCATOR_SUB_TYPE_UNICODE_DN;
    pAttr->PeAttribLength   = htons(nPolicyLocatorAttrLen);

    TraceRetail((
            CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
            _T("%s: Setting policy to:[%s]"),
            _fname, (TCHAR_t *)pAttr->PeAttribValue
        ));

    /*
     * Application name = default | psAppName
     */
  
    pAttr = ( IDPE_ATTR * )( (char *)pAttr +
                             RSVP_BYTE_MULTIPLE( nPolicyLocatorAttrLen ) );

    lstrcpy((TCHAR_t *)pAttr->PeAttribValue, psAppName);

    nAppIdAttrLen = (SHORT) ((lstrlen(psAppName) + 1) * sizeof(TCHAR_t));

    nAppIdAttrLen += IDPE_ATTR_HDR_LEN;

    pAttr->PeAttribType     = PE_ATTRIB_TYPE_CREDENTIAL;
    pAttr->PeAttribSubType  = CREDENTIAL_SUB_TYPE_UNICODE_ID;
    pAttr->PeAttribLength   = htons(nAppIdAttrLen);
    
    TraceRetail((
            CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
            _T("%s: Setting app ID to:[%s]"),
            _fname, (TCHAR_t *)pAttr->PeAttribValue
        ));

    /*
     * Fill up QOS headers
     */
    nTotalPaddedLen =
        sizeof(RSVP_POLICY_INFO) -
        sizeof(RSVP_POLICY) +
        RSVP_POLICY_HDR_LEN +
        RSVP_BYTE_MULTIPLE( nAppIdAttrLen ) +
        RSVP_BYTE_MULTIPLE( nPolicyLocatorAttrLen );

    pPolicyInfo->ObjectHdr.ObjectType = RSVP_OBJECT_POLICY_INFO;
    pPolicyInfo->ObjectHdr.ObjectLength = nTotalPaddedLen;
    pPolicyInfo->NumPolicyElement = 1;

    pPolicy->Type = PE_TYPE_APPID;
    pPolicy->Len =
        RSVP_POLICY_HDR_LEN + 
        RSVP_BYTE_MULTIPLE( nAppIdAttrLen ) +
        RSVP_BYTE_MULTIPLE( nPolicyLocatorAttrLen );

    return(nTotalPaddedLen);
}

/**********************************************************************
 * Validate QOS buffer
 **********************************************************************/
DWORD RtpValidateQosNotification(RtpQosNotify_t *pRtpQosNotify)
{
    DWORD            dwError;
    QOS_OBJECT_HDR  *pObjHdr;
    QOS             *pQos;
    RSVP_STATUS_INFO *pRsvpStatusInfo;
    int              len;

    TraceFunctionName("RtpValidateQosNotification");

    dwError = RTPERR_UNDERRUN;

    len = (int)pRtpQosNotify->dwTransfered;
    
    if (len == 0)
    {
        /* Underrun error, a non empty buffer was expected */

        TraceRetail((
                CLASS_WARNING, GROUP_QOS, S_QOS_NOTIFY,
                _T("%s: pRtpQosNotify[0x%p] failed: ")
                _T("notification with size:%u"),
                _fname, pRtpQosNotify, pRtpQosNotify->dwTransfered
            ));
        
        goto end;
    }
    
    if (len > (int)pRtpQosNotify->dwProviderLen)
    {
        /* Overrun error, transfered more than the buffer size ! */
        dwError = RTPERR_OVERRUN;

        TraceRetail((
                CLASS_WARNING, GROUP_QOS, S_QOS_NOTIFY,
                _T("%s: pRtpQosNotify[0x%p] failed: transfered more ")
                _T("than the provider size: %u > %u"),
                _fname, pRtpQosNotify, len, pRtpQosNotify->dwTransfered
            ));
        
        goto end;
    }
    
    len -= sizeof(QOS);

    if (len < 0)
    {
        /* Underrun error, size not enough to contain the expected QOS
         * structure at the begining of buffer */

        TraceRetail((
                CLASS_WARNING, GROUP_QOS, S_QOS_NOTIFY,
                _T("%s: pRtpQosNotify[0x%p] failed: ")
                _T("not enough data for a QOS structure: %u < %u"),
                _fname, pRtpQosNotify, pRtpQosNotify->dwTransfered, sizeof(QOS)
            ));
        
        goto end;
    }

    pQos = (QOS *)pRtpQosNotify->ProviderInfo;
    
    if ((pQos->ProviderSpecific.len == 0) || !pQos->ProviderSpecific.buf)
    {
        /* No provider buffer, finish */
        dwError = NOERROR;
        goto end;
    }
    
    if (len < (int)pQos->ProviderSpecific.len)
    {
        /* Underrun error, transfered data is not enough to contain
         * what the provider specific claims */

        TraceRetail((
                CLASS_WARNING, GROUP_QOS, S_QOS_NOTIFY,
                _T("%s: pRtpQosNotify[0x%p] ")
                _T("failed: invalid provider len: %u > %u"),
                _fname, pRtpQosNotify, pQos->ProviderSpecific.len, len
            ));
        
        goto end;
    }

    pObjHdr = (QOS_OBJECT_HDR *)(pQos + 1);
    
    while(len >= (int)sizeof(QOS_OBJECT_HDR))
    {
        len -= pObjHdr->ObjectLength;

        if (len >= 0)
        {
            if (pObjHdr->ObjectLength == 0)
            {
                /* Safety exit */
                break;
            }
            
            if (pObjHdr->ObjectType == QOS_OBJECT_END_OF_LIST)
            {
                /* Finish */
                break;
            }
            else if (pObjHdr->ObjectType == RSVP_OBJECT_STATUS_INFO)
            {
                /* Update pRtpQosNotify->dwError with the status code
                 * (aka the QOS notification) */
                pRsvpStatusInfo = (RSVP_STATUS_INFO *)pObjHdr;

                pRtpQosNotify->dwError = pRsvpStatusInfo->StatusCode;
            }

            pObjHdr = (QOS_OBJECT_HDR *)
                ((char *)pObjHdr + pObjHdr->ObjectLength);
        }
        else
        {
            /* Underrun error, remaining data is not enough to contain
             * what the QOS object header indicates */
            TraceRetail((
                    CLASS_WARNING, GROUP_QOS, S_QOS_NOTIFY,
                    _T("%s: pRtpQosNotify[0x%p] ")
                    _T("failed: invalid object size: %u > %u"),
                    _fname, pRtpQosNotify, pObjHdr->ObjectLength,
                    pObjHdr->ObjectLength + len
                ));
        }
    }

    if (len >= 0)
    {
        dwError = NOERROR;
    }

 end:
    
    return(dwError);
}

DWORD RtpSetMaxParticipants(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwMaxParticipants
    )
{
    DWORD            dwError;
    RtpQosReserve_t *pRtpQosReserve;

    TraceFunctionName("RtpSetMaxParticipants");

    dwError = NOERROR;
    
    pRtpQosReserve = pRtpAddr->pRtpQosReserve;

    if (pRtpQosReserve->dwMaxFilters == dwMaxParticipants)
    {
        /* Number of filters hasn't changed */
        goto bail;
    }

    /* MAYDO check for a number of participants too big */

    if (pRtpQosReserve->dwStyle == RTPQOS_STYLE_SE)
    {
        /* This ONLY used in SE style */
        
        /* If have previously allocated memory, free it */
        if (pRtpQosReserve->pdwRsvpSSRC)
        {
            RtpHeapFree(g_pRtpQosReserveHeap, pRtpQosReserve->pdwRsvpSSRC);
        
            RtpHeapFree(g_pRtpQosReserveHeap, pRtpQosReserve->pRsvpFilterSpec);
        }

        pRtpQosReserve->pdwRsvpSSRC = (DWORD *)
            RtpHeapAlloc(g_pRtpQosReserveHeap,
                         dwMaxParticipants * sizeof(DWORD));

        pRtpQosReserve->pRsvpFilterSpec = (RSVP_FILTERSPEC *)
            RtpHeapAlloc(g_pRtpQosReserveHeap,
                         dwMaxParticipants * sizeof(RSVP_FILTERSPEC));

        if (!pRtpQosReserve->pdwRsvpSSRC || !pRtpQosReserve->pRsvpFilterSpec)
        {
            if (pRtpQosReserve->pdwRsvpSSRC)
            {
                RtpHeapFree(g_pRtpQosReserveHeap, pRtpQosReserve->pdwRsvpSSRC);

                pRtpQosReserve->pdwRsvpSSRC = NULL;
            }

            if (pRtpQosReserve->pRsvpFilterSpec)
            {
                RtpHeapFree(g_pRtpQosReserveHeap,
                            pRtpQosReserve->pRsvpFilterSpec);

                pRtpQosReserve->pRsvpFilterSpec = NULL;
            }
        
            pRtpQosReserve->dwMaxFilters = 0;

            dwError = RTPERR_MEMORY;

            goto bail;
        }
    }

    pRtpQosReserve->dwMaxFilters = dwMaxParticipants;

    TraceRetail((
            CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
            _T("%s: pRtpQosReserve[0x%p] Max filters:%u"),
            _fname, pRtpQosReserve,
            dwMaxParticipants
        ));
    
 bail:
    if (dwError != NOERROR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QOS, S_QOS_RESERVE,
                _T("%s: pRtpQosReserve[0x%p] failed: %u (0x%X)"),
                _fname, pRtpQosReserve,
                dwError, dwError
            ));
    }
    
    return(dwError);
}

/* Add/Delete one SSRC (participant) to the Shared Explicit Filter
 * (SEF) list 0==delete; other==add */
DWORD RtpAddDeleteSSRC(
        RtpAddr_t       *pRtpAddr,
        RtpQosReserve_t *pRtpQosReserve,
        DWORD            dwSSRC,
        BOOL             bAddDel
    )
{
    DWORD            dwNumber;
    DWORD            i;
    DWORD           *pdwRsvpSSRC;
    RSVP_FILTERSPEC *pRsvpFilterSpec;

    DWORD           *dwSSRC1;
    DWORD           *dwSSRC2;
    RSVP_FILTERSPEC *pRsvp1;
    RSVP_FILTERSPEC *pRsvp2;

    RtpUser_t       *pRtpUser;
    BOOL             bCreate;
    
    TraceFunctionName("RtpAddDeleteSSRC");

    dwNumber = 1;
    
    /* Lookup the SSRC and find out if it is already in the priority
     * list */

    pdwRsvpSSRC = pRtpQosReserve->pdwRsvpSSRC;
    pRsvpFilterSpec = pRtpQosReserve->pRsvpFilterSpec;
    
    for(i = 0;
        (i < pRtpQosReserve->dwNumFilters) && (dwSSRC != pdwRsvpSSRC[i]);
        i++)
    {
        ;
    }

    if (i < pRtpQosReserve->dwNumFilters)
    {
        /* SSRC is in list */

        if (bAddDel)
        {
            /*
             * ******* ADD *******
             */
            
            /* do nothing, already in list */
            TraceDebug((
                    CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
                    _T("%s: pRtpAddr[0x%p] pRtpReserve[0x%p] ")
                    _T("ADD SSRC:0x%X ")
                    _T("Already in priority list"),
                    _fname, pRtpAddr, pRtpQosReserve,
                    ntohl(dwSSRC)
                ));
        }
        else
        {
            /*
             * ******* DELETE *******
             */

            /* remove from list */
            pRsvp1 = &pRsvpFilterSpec[i];
            pRsvp2 = pRsvp1 + 1;

            dwSSRC1 = &pdwRsvpSSRC[i];
            dwSSRC2 = dwSSRC1 + 1;
                
            for(pRtpQosReserve->dwNumFilters--;
                i < pRtpQosReserve->dwNumFilters;
                pRsvp1++, pRsvp2++, dwSSRC1++, dwSSRC2++, i++)
            {
                MoveMemory(pRsvp1, pRsvp2, sizeof(*pRsvp1));
                *dwSSRC1 = *dwSSRC2;
            }

            TraceDebug((
                    CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
                    _T("%s: pRtpAddr[0x%p] pRtpReserve[0x%p] ")
                    _T("DEL SSRC:0x%X ")
                    _T("Deleted from priority list"),
                    _fname, pRtpAddr, pRtpQosReserve,
                    ntohl(dwSSRC)
                ));
        }
    }
    else
    {
        /* SSRC not in list */

        if (bAddDel)
        {
            /*
             * ******* ADD *******
             */
 
            /* add to the list */

            dwNumber = 0;
            
            /* Check if we can add 1 more SSRC to the list */
            if (pRtpQosReserve->dwNumFilters < pRtpQosReserve->dwMaxFilters)
            {
                bCreate = FALSE;
                
                pRtpUser = LookupSSRC(pRtpAddr, dwSSRC, &bCreate);

                if (pRtpUser)
                {
                    if (RtpBitTest(pRtpUser->dwUserFlags, FGUSER_RTPADDR))
                    {
                        pRsvp1 =
                            &pRsvpFilterSpec[pRtpQosReserve->dwNumFilters];

                        ZeroMemory(pRsvp1, sizeof(*pRsvp1));
                        
                        pRsvp1->Type = FILTERSPECV4;

                        pRsvp1->FilterSpecV4.Address.Addr =
                            pRtpUser->dwAddr[RTP_IDX];

                        pRsvp1->FilterSpecV4.Port =
                            pRtpUser->wPort[RTP_IDX];

                        pdwRsvpSSRC[pRtpQosReserve->dwNumFilters] = dwSSRC;
                            
                        pRtpQosReserve->dwNumFilters++;

                        TraceDebug((
                                CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
                                _T("%s: pRtpAddr[0x%p] pRtpReserve[0x%p] ")
                                _T("ADD SSRC:0x%X ")
                                _T("Added to the priority list"),
                                _fname, pRtpAddr, pRtpQosReserve,
                                ntohl(dwSSRC)
                            ));
                        
                        dwNumber = 1;
                    }
                    else
                    {
                        TraceRetail((
                                CLASS_WARNING, GROUP_QOS, S_QOS_RESERVE,
                                _T("%s: pRtpAddr[0x%p] pRtpReserve[0x%p] ")
                                _T("ADD SSRC:0x%X ")
                                _T("No address available yet"),
                                _fname, pRtpAddr, pRtpQosReserve,
                                ntohl(dwSSRC)
                            ));
                    }
                }
                else
                {
                    TraceRetail((
                            CLASS_WARNING, GROUP_QOS, S_QOS_RESERVE,
                            _T("%s: pRtpAddr[0x%p] pRtpReserve[0x%p] ")
                            _T("ADD SSRC:0x%X ")
                            _T("Unknown SSRC"),
                            _fname, pRtpAddr, pRtpQosReserve,
                            ntohl(dwSSRC)
                        ));
                }
            }
        }
        else
        {
            /*
             * ******* DELETE *******
             */

            /* do nothing, not in list */
            TraceDebug((
                    CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
                    _T("%s: pRtpAddr[0x%p] pRtpReserve[0x%p] ")
                    _T("DEL SSRC:0x%X ")
                    _T("Not in priority list"),
                    _fname, pRtpAddr, pRtpQosReserve,
                    ntohl(dwSSRC)
                ));
        }
    } /* not in list */

    return(dwNumber);
}

BOOL RtcpUpdateSendState(
        RtpAddr_t   *pRtpAddr,
        DWORD        dwEvent
    )
{
    BOOL             bSendState;

    bSendState = TRUE;
    
    if (!RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSSENDON) ||
        !RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_CHKQOSSEND))
    {
        /* If QOS is not set yet for senders, or we are not asked to
         * check for allowed to send, just return */
        goto end;
    }
    
    if (dwEvent == RTPQOS_RECEIVERS)
    {
        /* Enable sending at full rate */
        RtpBitSet(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSSEND);

        if (RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSEVENTPOSTED))
        {
            /* Post allowed to send only if not allowed to send was
             * posted before */
            RtpPostEvent(pRtpAddr,
                         NULL,
                         RTPEVENTKIND_QOS,
                         RTPQOS_ALLOWEDTOSEND,
                         0,
                         0);

            RtpBitReset(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSEVENTPOSTED);
        }
    }
    else if (dwEvent == RTPQOS_NO_RECEIVERS)
    {
        /* Check for permission to send again */
        bSendState = RtpIsAllowedToSend(pRtpAddr);

        if (bSendState)
        {
            RtpBitSet(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSSEND); 
        }
        else
        {
            if (!RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSEVENTPOSTED))
            {
                /* Post allowed to send only if not allowed to send
                 * was posted before */
                RtpPostEvent(pRtpAddr,
                             NULL,
                             RTPEVENTKIND_QOS,
                             RTPQOS_NOT_ALLOWEDTOSEND,
                             0,
                             0);

                RtpBitSet(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSEVENTPOSTED);
            }

            RtpBitReset(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSSEND);
        }
    }
    else
    {
        bSendState = RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSSEND)?
            TRUE : FALSE;
    }

 end:
    return(bSendState);
}

BOOL RtpIsAllowedToSend(RtpAddr_t *pRtpAddr)
{
    bool_t           bFail;
    bool_t           bAllowedToSend;
    DWORD            dwError;
    DWORD            dwRequest;
    DWORD            dwResult;
    DWORD            dwBytesReturned;

    TraceFunctionName("RtpIsAllowedToSend");

    dwRequest = ALLOWED_TO_SEND_DATA;
    dwBytesReturned = 0;

    if (IsRegValueSet(g_RtpReg.dwQosFlags) &&
        RtpBitTest(g_RtpReg.dwQosFlags, FGREGQOS_FORCE_ALLOWEDTOSEND))
    {
        /* Force the result of the query to be a certain value */
        bFail = 0;
        dwResult = RtpBitTest(g_RtpReg.dwQosFlags,
                              FGREGQOS_FORCE_ALLOWEDTOSEND_RESULT);

        TraceRetail((
                CLASS_WARNING, GROUP_QOS, S_QOS_RESERVE,
                _T("%s: pRtpAddr[0x%p] ")
                _T("Result being forced from the registry"),
                _fname, pRtpAddr
            ));
    }
    else
    {
        /* Really query RSVPSP */
        bFail = WSAIoctl(pRtpAddr->Socket[SOCK_SEND_IDX],
                         SIO_CHK_QOS,
                         (LPVOID)&dwRequest,
                         sizeof(dwRequest),
                         (LPVOID)&dwResult,
                         sizeof(dwResult),
                         &dwBytesReturned,
                         NULL,
                         NULL);
    }

    if (bFail)
    {
        TraceRetailWSAGetError(dwError);

        TraceRetail((
                CLASS_WARNING, GROUP_QOS, S_QOS_RESERVE,
                _T("%s: pRtpAddr[0x%p] ")
                _T("WSAIoctl(%u, SIO_CHK_QOS) failed: %u (0x%X)"),
                _fname, pRtpAddr,
                pRtpAddr->Socket[SOCK_SEND_IDX],
                dwError, dwError
            ));
        
        /* For safety, on failure say allowed */
        bAllowedToSend = TRUE;
    }
    else
    {
        bAllowedToSend = dwResult? TRUE : FALSE;
    }

    TraceRetail((
            CLASS_INFO, GROUP_QOS, S_QOS_RESERVE,
            _T("%s: pRtpAddr[0x%p] ")
            _T("Allowed to send:%s"),
            _fname, pRtpAddr, bAllowedToSend? _T("YES") : _T("NO")
        ));

    return(bAllowedToSend);
}

/**********************************************************************
 * Dump QOS structures
 **********************************************************************/
#if DBG > 0
void dumpFlowSpec(TCHAR_t *str, FLOWSPEC *pFlowSpec)
{
    _stprintf(str,
              _T("TokenRate:%d, ")
              _T("TokenBucketSize:%d, ")
              _T("PeakBandwidth:%d, ")
              _T("ServiceType:%d ")
              _T("MaxSduSize:%d ")
              _T("MinPolicedSize:%d"),
              pFlowSpec->TokenRate,
              pFlowSpec->TokenBucketSize,
              pFlowSpec->PeakBandwidth,
              pFlowSpec->ServiceType,
              pFlowSpec->MaxSduSize,
              pFlowSpec->MinimumPolicedSize
        );
}

void dumpQOS(const TCHAR_t *msg, QOS *pQOS)
{
    TCHAR_t          str[256];
    
    dumpFlowSpec(str, &pQOS->SendingFlowspec);
    TraceDebug((
            CLASS_INFO, GROUP_QOS, S_QOS_DUMPOBJ,
            _T("%s: SendingFlowspec:   %s"),
            msg, str
        ));

    dumpFlowSpec(str, &pQOS->ReceivingFlowspec);
    TraceDebug((
            CLASS_INFO, GROUP_QOS, S_QOS_DUMPOBJ,
            _T("%s: ReceivingFlowspec: %s"),
            msg, str
        ));
}

void dumpSTATUS_INFO(const TCHAR_t *msg, RSVP_STATUS_INFO *object)
{
    DWORD            dwIndex;

    dwIndex = object->StatusCode - WSA_QOS_RECEIVERS + RTPQOS_RECEIVERS;
    
    if (dwIndex >= RTPQOS_LAST)
    {
        dwIndex = 0;
    }
        
    TraceDebug((
            CLASS_INFO, GROUP_QOS, S_QOS_DUMPOBJ,
            _T("%s: RSVP_STATUS_INFO: ")
            _T("StatusCode: %d %s, ")
            _T("ExStatus1: %d, ")
            _T("ExStatus2: %d"),
            msg, object->StatusCode, g_psRtpQosEvents[dwIndex],
            object->ExtendedStatus1, 
            object->ExtendedStatus2
        ));
}

void dumpRESERVE_INFO(const TCHAR_t *msg, RSVP_RESERVE_INFO *object)
{
    TraceDebug((
            CLASS_INFO, GROUP_QOS, S_QOS_DUMPOBJ,
            _T("%s: RSVP_RESERVE_INFO: ")
            _T("Style: %d, ")
            _T("ConfirmRequest: %d, ")
            _T("PolicyElementList: %s, ")
            _T("NumFlowDesc: %d"),
            msg, object->Style,
            object->ConfirmRequest,
            (object->PolicyElementList)? _T("Yes") : _T("No"),
            object->NumFlowDesc
        ));
}

#define MAX_SERVICES 8

void dumpADSPEC(const TCHAR_t *msg, RSVP_ADSPEC *object)
{
    TCHAR_t          str[256];
    DWORD            i;

    TraceDebug((
            CLASS_INFO, GROUP_QOS, S_QOS_DUMPOBJ,
            _T("%s: RSVP_ADSPEC: %d Service(s)"),
            msg, object->NumberOfServices
        ));

    str[0] = _T('\0');
    
    for(i = 0; i < object->NumberOfServices && i < MAX_SERVICES; i++)
    {
        _stprintf(str,
                  _T("Service[%d]: %d, Guaranteed: ")
                  _T("CTotal: %d, ")
                  _T("DTotal: %d, ")
                  _T("CSum: %d, ")
                  _T("DSum: %d"),
                i,
                object->Services[i].Service,
                object->Services[i].Guaranteed.CTotal,
                object->Services[i].Guaranteed.DTotal,
                object->Services[i].Guaranteed.CSum,
                object->Services[i].Guaranteed.DSum);

        TraceDebug((
                CLASS_INFO, GROUP_QOS, S_QOS_DUMPOBJ,
                _T("%s: %s"),
                msg, str
            ));
    }
}

void dumpPE_ATTR(const TCHAR_t *msg, IDPE_ATTR *pIdpeAttr, DWORD len)
{
    TCHAR_t          str[1024];
    USHORT           slen;
    TCHAR_t         *psFormat;

    while(len >= sizeof(IDPE_ATTR))
    {
        if (pIdpeAttr->PeAttribSubType == POLICY_LOCATOR_SUB_TYPE_UNICODE_DN)
        {
            psFormat =
                _T("IDPE_ATTR: ")
                _T("PeAttribLength:%u PeAttribType:%u ")
                _T("PeAttribSubType:%u PeAttribValue[%ls]");
        }
        else
        {
            psFormat =
                _T("IDPE_ATTR: ")
                _T("PeAttribLength:%u PeAttribType:%u ")
                _T("PeAttribSubType:%u PeAttribValue[%hs]");
        }

        _stprintf(str, psFormat,
                  (DWORD)ntohs(pIdpeAttr->PeAttribLength),
                  (DWORD)pIdpeAttr->PeAttribType,
                  (DWORD)pIdpeAttr->PeAttribSubType,
                  pIdpeAttr->PeAttribValue);
        
        TraceDebug((
                CLASS_INFO, GROUP_QOS, S_QOS_DUMPOBJ,
                _T("%s: %s"),
                msg, str
            ));
        
        slen = ntohs(pIdpeAttr->PeAttribLength);
        
        slen = RSVP_BYTE_MULTIPLE(slen);

        if (!slen || slen > (USHORT)len)
        {
            break;  /* Safety exit */
        }
        
        len -= slen;
        
        pIdpeAttr = (IDPE_ATTR *) ((char *)pIdpeAttr + slen);
    }
  
}

void dumpPOLICY(const TCHAR_t *msg, RSVP_POLICY *pRsvpPolicy)
{
    TCHAR_t          str[256];
    DWORD            len;
    IDPE_ATTR       *pIdpeAttr;
    
    _stprintf(str,
              _T("RSVP_POLICY: Len:%u Type:%u"),
              (DWORD)pRsvpPolicy->Len, (DWORD)pRsvpPolicy->Type);

    TraceDebug((
            CLASS_INFO, GROUP_QOS, S_QOS_DUMPOBJ,
            _T("%s: %s"),
            msg, str
        ));

    len = pRsvpPolicy->Len - RSVP_POLICY_HDR_LEN;
    
    pIdpeAttr = (IDPE_ATTR *)
        ((char *)pRsvpPolicy + RSVP_POLICY_HDR_LEN);
    
    dumpPE_ATTR(msg, pIdpeAttr, len);
}

void dumpPOLICY_INFO(const TCHAR_t *msg, RSVP_POLICY_INFO *object)
{
    TCHAR_t         str[256];
    char            *ptr;
    DWORD            i;
    int              len;
    RSVP_POLICY     *pRsvpPolicy;

    TraceDebug((
            CLASS_INFO, GROUP_QOS, S_QOS_DUMPOBJ,
            _T("%s: RSVP_POLICY_INFO: NumPolicyElement: %u"),
            msg, object->NumPolicyElement
        ));

    ptr = (char *)&object->PolicyElement[0];

    len = object->ObjectHdr.ObjectLength;
    
    len -= (PtrToUlong(ptr) - PtrToUlong(object));

    for(i = object->NumPolicyElement;
        (i > 0) && (len >= sizeof(RSVP_POLICY));
        i--)
    {
        pRsvpPolicy = (RSVP_POLICY *)ptr;

        if (len < pRsvpPolicy->Len)
        {
            /* Unexpected condition */
            TraceDebug((
                    CLASS_ERROR, GROUP_QOS, S_QOS_DUMPOBJ,
                    _T("%s: UNDERRUN error found by dumpPOLICY_INFO"),
                    msg
                ));
            /* Usually all the ERROR logs are retail, but this
             * function is availiable only in debug builds, that's why
             * I have the above TraceDebug sending an ERROR message */
            return;
        }
        
        dumpPOLICY(msg, pRsvpPolicy);

        ptr += pRsvpPolicy->Len;

        len -= pRsvpPolicy->Len;
    }
}

void dumpObjectType(const TCHAR_t *msg, char *ptr, unsigned int len)
{
    QOS_OBJECT_HDR  *pObjHdr;
        
    while(len >= sizeof(QOS_OBJECT_HDR))
    {
        pObjHdr = (QOS_OBJECT_HDR *)ptr;

        if (len >= pObjHdr->ObjectLength)
        {
            switch(pObjHdr->ObjectType) {
            case RSVP_OBJECT_STATUS_INFO:
                dumpSTATUS_INFO(msg, (RSVP_STATUS_INFO *)pObjHdr);
                break;
            case RSVP_OBJECT_RESERVE_INFO:
                dumpRESERVE_INFO(msg, (RSVP_RESERVE_INFO *)pObjHdr);
                break;
            case RSVP_OBJECT_ADSPEC:
                dumpADSPEC(msg, (RSVP_ADSPEC *)pObjHdr);
                break;
            case RSVP_OBJECT_POLICY_INFO:
                dumpPOLICY_INFO(msg, (RSVP_POLICY_INFO *)pObjHdr);
                break;
            case QOS_OBJECT_END_OF_LIST:
                len = pObjHdr->ObjectLength; // Finish
                break;
            default:
                // don't have code to decode this, skip it
                break;
            }

            ptr += pObjHdr->ObjectLength;

            if (!pObjHdr->ObjectLength || pObjHdr->ObjectLength > len)
            {
                break; /* Safety exit */
            }
            
            len -= pObjHdr->ObjectLength;
        }
        else
        {
            // Error
            len = 0;
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\funcs\rtpph.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpph.c
 *
 *  Abstract:
 *
 *    Implements the Payload Handling family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#include "struct.h"
#include "rtpph.h"

HRESULT ControlRtpPh(RtpControlStruct_t *pRtpControlStruct)
{

    return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\funcs\rtpfwrap.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpfwrap.c
 *
 *  Abstract:
 *
 *    Implements the RTP function wrapper.
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/01 created
 *
 **********************************************************************/

#include "struct.h"
#include "rtperr.h"

#include "rtpfwrap.h"

#include "rtpaddr.h"
#include "rtpglob.h"
#include "rtprtp.h"
#include "rtpdemux.h"
#include "rtpph.h"
#include "rtppinfo.h"
#include "rtpqos.h"
#include "rtpcrypt.h"
#include "rtpncnt.h"

/**********************************************************************
 *
 * Helper macros to build the validation mask for all the family of
 * functions
 *
 **********************************************************************/
#define _P1(_wr, _rd, _Zero) \
    ((_wr << 10) | (_rd << 9)  | (_Zero << 8))

#define _P2(_wr, _rd, _Zero) \
    ((_wr << 14) | (_rd << 13) | (_Zero << 12))

#define _S(_en,_p2,_lk,_p1,_fg) \
    (((_en<<15)|(_p2<<12)|(_lk<<11)|(_p1<<8)|(_fg))<<16)

#define _G(_en,_p2,_lk,_p1,_fg) \
    ((_en<<15)|(_p2<<12)|(_lk<<11)|(_p1<<8)|(_fg))

#define _FGS(b7,b6,b5,b4,b3,b2,b1,b0) \
    ((b7<<7)|(b6<<6)|(b5<<5)|(b4<<4)|(b3<<3)|(b2<<2)|(b1<<1)|b0)


/**********************************************************************
 *
 * Validation masks for all the family of functions
 *
 **********************************************************************/
                                                                       
/*
 * Control word validation mask for:
 * RTPF_ADDR - RTP Adress family of functions */
const DWORD g_dwControlRtpAddr[] = {
    /*---------------------------------------------------------------*/
    /* Enable Par 2     Lock   Par 1          Flags                  */
    /* |      |-----|   |      |-----|        |--------------------+ */
    /* |      w  r  z   |      w  r  z        |  |  |  |  |  |  |  | */
    /* 1      1  1  1   1      1  0  0        0  0  0  0  0  0  0  0 */
    /* 5      4  3  2   1      0  9  8        7  6  5  4  3  2  1  0 */
    /* |      |  |  |   |      |  |  |        |  |  |  |  |  |  |  | */
    /* v      v  v  v   v      v  v  v        v  v  v  v  v  v  v  v */
    _S(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)) |
    _G(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)),

    /* RTPADDR_CREATE */
    _S(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1)) |
    _G(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1))
    
};

/*
 * Control word validation mask for:
 * RTPF_GLOB - RTP Global family of functions */
const DWORD g_dwControlRtpGlob[] = {
    /*---------------------------------------------------------------*/
    /* Enable Par 2     Lock   Par 1          Flags                  */
    /* |      |-----|   |      |-----|        |--------------------+ */
    /* |      w  r  z   |      w  r  z        |  |  |  |  |  |  |  | */
    /* 1      1  1  1   1      1  0  0        0  0  0  0  0  0  0  0 */
    /* 5      4  3  2   1      0  9  8        7  6  5  4  3  2  1  0 */
    /* |      |  |  |   |      |  |  |        |  |  |  |  |  |  |  | */
    /* v      v  v  v   v      v  v  v        v  v  v  v  v  v  v  v */
    _S(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)) |
    _G(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)),
    
    _S(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1)) |
    _G(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1))
    
    
};

/*
 * Control word validation mask for:
 * RTPF_RTP - RTP specific family of functions */
/* TODO fill in the right values */
const DWORD g_dwControlRtpRtp[] = {
    /*---------------------------------------------------------------*/
    /* Enable Par 2     Lock   Par 1          Flags                  */
    /* |      |-----|   |      |-----|        |--------------------+ */
    /* |      w  r  z   |      w  r  z        |  |  |  |  |  |  |  | */
    /* 1      1  1  1   1      1  0  0        0  0  0  0  0  0  0  0 */
    /* 5      4  3  2   1      0  9  8        7  6  5  4  3  2  1  0 */
    /* |      |  |  |   |      |  |  |        |  |  |  |  |  |  |  | */
    /* v      v  v  v   v      v  v  v        v  v  v  v  v  v  v  v */
    _S(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)) |
    _G(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)),
    
    _S(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1)) |
    _G(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1))
    
    
};

/*
 * Control word validation mask for:
 * RTPF_DEMUX - Demultiplexing family of functions */
/* TODO fill in the right values */
const DWORD g_dwControlRtpDemux[] = {
    /*---------------------------------------------------------------*/
    /* Enable Par 2     Lock   Par 1          Flags                  */
    /* |      |-----|   |      |-----|        |--------------------+ */
    /* |      w  r  z   |      w  r  z        |  |  |  |  |  |  |  | */
    /* 1      1  1  1   1      1  0  0        0  0  0  0  0  0  0  0 */
    /* 5      4  3  2   1      0  9  8        7  6  5  4  3  2  1  0 */
    /* |      |  |  |   |      |  |  |        |  |  |  |  |  |  |  | */
    /* v      v  v  v   v      v  v  v        v  v  v  v  v  v  v  v */
    _S(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)) |
    _G(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)),
    
    _S(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1)) |
    _G(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1))
    
    
};

/*
 * Control word validation mask for:
 * RTPF_PH - Payload Handling family of functions */
/* TODO fill in the right values */
const DWORD g_dwControlRtpPh[] = {
    /*---------------------------------------------------------------*/
    /* Enable Par 2     Lock   Par 1          Flags                  */
    /* |      |-----|   |      |-----|        |--------------------+ */
    /* |      w  r  z   |      w  r  z        |  |  |  |  |  |  |  | */
    /* 1      1  1  1   1      1  0  0        0  0  0  0  0  0  0  0 */
    /* 5      4  3  2   1      0  9  8        7  6  5  4  3  2  1  0 */
    /* |      |  |  |   |      |  |  |        |  |  |  |  |  |  |  | */
    /* v      v  v  v   v      v  v  v        v  v  v  v  v  v  v  v */
    _S(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)) |
    _G(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)),
    
    _S(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1)) |
    _G(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1))
    
    
};

/*
 * Control word validation mask for:
 * RTPF_PARINFO - Participants Info family of functions */
/* TODO fill in the right values */
const DWORD g_dwControlRtpParInfo[] = {
    /*---------------------------------------------------------------*/
    /* Enable Par 2     Lock   Par 1          Flags                  */
    /* |      |-----|   |      |-----|        |--------------------+ */
    /* |      w  r  z   |      w  r  z        |  |  |  |  |  |  |  | */
    /* 1      1  1  1   1      1  0  0        0  0  0  0  0  0  0  0 */
    /* 5      4  3  2   1      0  9  8        7  6  5  4  3  2  1  0 */
    /* |      |  |  |   |      |  |  |        |  |  |  |  |  |  |  | */
    /* v      v  v  v   v      v  v  v        v  v  v  v  v  v  v  v */
    _S(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)) |
    _G(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)),
    
    _S(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1)) |
    _G(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1))
    
    
};

/*
 * Control word validation mask for:
 * RTPF_QOS - Quality of Service family of functions */
/* TODO fill in the right values */
const DWORD g_dwControlRtpQos[] = {
    /*---------------------------------------------------------------*/
    /* Enable Par 2     Lock   Par 1          Flags                  */
    /* |      |-----|   |      |-----|        |--------------------+ */
    /* |      w  r  z   |      w  r  z        |  |  |  |  |  |  |  | */
    /* 1      1  1  1   1      1  0  0        0  0  0  0  0  0  0  0 */
    /* 5      4  3  2   1      0  9  8        7  6  5  4  3  2  1  0 */
    /* |      |  |  |   |      |  |  |        |  |  |  |  |  |  |  | */
    /* v      v  v  v   v      v  v  v        v  v  v  v  v  v  v  v */
    _S(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)) |
    _G(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)),
    
    _S(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1)) |
    _G(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1))
    
    
};

/*
 * Control word validation mask for:
 * RTPF_CRYPT - Cryptography family of functions */
/* TODO fill in the right values */
const DWORD g_dwControlRtpCrypt[] = {
    /*---------------------------------------------------------------*/
    /* Enable Par 2     Lock   Par 1          Flags                  */
    /* |      |-----|   |      |-----|        |--------------------+ */
    /* |      w  r  z   |      w  r  z        |  |  |  |  |  |  |  | */
    /* 1      1  1  1   1      1  0  0        0  0  0  0  0  0  0  0 */
    /* 5      4  3  2   1      0  9  8        7  6  5  4  3  2  1  0 */
    /* |      |  |  |   |      |  |  |        |  |  |  |  |  |  |  | */
    /* v      v  v  v   v      v  v  v        v  v  v  v  v  v  v  v */
    _S(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)) |
    _G(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)),
    
    _S(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1)) |
    _G(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1))
    
    
};

/*
 * Control word validation mask for:
 * RTPF_STATS - Statistics family of functions */
/* TODO fill in the right values */
const DWORD g_dwControlRtpStats[] = {
    /*---------------------------------------------------------------*/
    /* Enable Par 2     Lock   Par 1          Flags                  */
    /* |      |-----|   |      |-----|        |--------------------+ */
    /* |      w  r  z   |      w  r  z        |  |  |  |  |  |  |  | */
    /* 1      1  1  1   1      1  0  0        0  0  0  0  0  0  0  0 */
    /* 5      4  3  2   1      0  9  8        7  6  5  4  3  2  1  0 */
    /* |      |  |  |   |      |  |  |        |  |  |  |  |  |  |  | */
    /* v      v  v  v   v      v  v  v        v  v  v  v  v  v  v  v */
    _S(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)) |
    _G(0, _P2(0, 0, 0), 0, _P1(0, 0, 0), _FGS(0, 0, 0, 0, 0, 0, 0, 0)),
    
    _S(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1)) |
    _G(1, _P2(1, 0, 1), 1, _P1(1, 1, 1), _FGS(0, 0, 0, 1, 1, 1, 1, 1))
    
    
};

/**********************************************************************
 *
 * Put together all the per family entries, i.e. on each of the next
 * global arrays, there are as many entries as families exist plus 1
 * (the zero/NULL first entry)
 *
 **********************************************************************/

/*
 * Control words
 *
 * All the array of control words are held together here */
const DWORD *g_pdwControlWords[] = {
    (DWORD *)NULL,
    g_dwControlRtpAddr,
    g_dwControlRtpGlob,
    g_dwControlRtpRtp,
    g_dwControlRtpDemux,
    g_dwControlRtpPh,
    g_dwControlRtpParInfo,
    g_dwControlRtpQos,
    g_dwControlRtpCrypt,
    g_dwControlRtpStats
    
};

/*
 * Family functions
 *
 * Array of pointers to the functions that serve every family of
 * functions */
const RtpFamily_f g_fRtpFamilyFunc[] = {
    (RtpFamily_f)NULL,
    ControlRtpAddr,
    ControlRtpGlob,
    ControlRtpRtp,
    ControlRtpDemux,
    ControlRtpPh,
    ControlRtpParInfo,
    ControlRtpQos,
    ControlRtpCrypt,
    ControlRtpStats
};

/*
 * Number of functions on each family
 *
 * Arrays of DWORD containing the number of functions each family has
 * */
const DWORD g_dwLastFunction[] = {
    0,
    RTPADDR_LAST,
    RTPGLOB_LAST,
    RTPRTP_LAST,
    RTPDEMUX_LAST,
    RTPPH_LAST,
    RTPPARINFO_LAST,
    RTPQOS_LAST,
    RTPCRYPT_LAST,
    RTPSTATS_LAST
};

/**********************************************************************
 **********************************************************************/

/* Act upon the input control DWORD */
#define GETFAMILY(Control)   ((Control >> 20) & 0xf)
#define GETFUNCTION(Control) ((Control >> 16) & 0xf)
#define GETDIR(Control)      (Control & 0x01000000)

/*
 * Validates the control word, parameters, and if all the tests
 * succeed, call the proper function that does the work */
HRESULT RtpValidateAndExecute(RtpControlStruct_t *pRtpControlStruct)
{
    DWORD        dwControl;  /* control DWORD passed by the user */
    DWORD        dwCtrlWord; /* control WORD word looked up */
    DWORD        dwFamily;   /* Family of functions */
    DWORD        dwFunction; /* Function in family */
    DWORD_PTR    dwPar;
    
    dwControl = pRtpControlStruct->dwControlWord;
    
    /* Validate family */
    dwFamily = GETFAMILY(dwControl);
    pRtpControlStruct->dwFamily = dwFamily;
    
    if (!dwFamily || (dwFamily >= RTPF_LAST)) {
        return(RTPERR_INVALIDFAMILY);
    }

    /* Validate function range in family */
    dwFunction = GETFUNCTION(dwControl);
    pRtpControlStruct->dwFunction = dwFunction;
    
    if (!dwFunction || dwFunction >= g_dwLastFunction[dwFamily]) {
        return(RTPERR_INVALIDFUNCTION);
    }

    /* Obtain control word */
    dwCtrlWord = *(g_pdwControlWords[dwFamily] + dwFunction);

    /* Get direction */
    pRtpControlStruct->dwDirection = 0;

    if (GETDIR(dwControl)) {
        dwCtrlWord >>= 16;
        pRtpControlStruct->dwDirection = 0;
    }

    /* Get the real control WORD for the specific direction */
    dwCtrlWord &= 0xffff;
    pRtpControlStruct->dwControlWord = dwCtrlWord;

    /* Check if function is allowed for this direction */
    if (!RTPCTRL_ENABLED(dwCtrlWord)) {
        return(RTPERR_INVALIDDIRECTION);
    }
    
    /* Validate flags */
    if ((dwControl & 0xff & dwCtrlWord) != (dwControl & 0xff)) {
        return(RTPERR_INVALIDFLAGS);
    }

    /*************************************/
    /* Validate parameters Par1 and Par2 */
    /*************************************/

    /* Validate parameter 1 */
    dwPar = pRtpControlStruct->dwPar1;
    
    if (RTPCTRL_TEST(dwCtrlWord, PAR1_ZERO)) {
        if (!dwPar) {
            /* set error RTP_E_ZERO */
            return(RTPERR_ZEROPAR1);
        }
    } else {
        if (RTPCTRL_TEST(dwCtrlWord, PAR1_RDPTR)) {
            if (IsBadReadPtr((void *)dwPar, sizeof(DWORD))) {
                return(RTPERR_RDPTRPAR1);
            }
        }

        if (RTPCTRL_TEST(dwCtrlWord, PAR1_WRPTR)) {
            if (IsBadWritePtr((void *)dwPar, sizeof(DWORD))) {
                return(RTPERR_WRPTRPAR1);
            }
        }
    }
    
    /* Validate parameter 2 */
    dwPar = pRtpControlStruct->dwPar2;
    
    if (RTPCTRL_TEST(dwCtrlWord, PAR2_ZERO)) {
        if (!dwPar) {
            /* set error RTP_E_ZERO */
            return(RTPERR_ZEROPAR2);
        }
    } else {
        if (RTPCTRL_TEST(dwCtrlWord, PAR2_RDPTR)) {
            if (IsBadReadPtr((void *)dwPar, sizeof(DWORD))) {
                return(RTPERR_RDPTRPAR2);
            }
        }

        if (RTPCTRL_TEST(dwCtrlWord, PAR2_WRPTR)) {
            if (IsBadWritePtr((void *)dwPar, sizeof(DWORD))) {
                return(RTPERR_WRPTRPAR2);
            }
        }
    }
    

    
    /* All tests passed, update and call function */
    pRtpControlStruct->RtpFamilyFunc = g_fRtpFamilyFunc[dwFamily];

    return( g_fRtpFamilyFunc[dwFamily](pRtpControlStruct) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\funcs\rtppinfo.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtppinfo.c
 *
 *  Abstract:
 *
 *    Implements the Participants Information family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#include "struct.h"
#include "rtpuser.h"
#include "rtpevent.h"
#include "rtpdemux.h"
#include "lookup.h"
#include "rtpglobs.h"

#include "rtppinfo.h"

HRESULT ControlRtpParInfo(RtpControlStruct_t *pRtpControlStruct)
{

    return(NOERROR);
}

/* Some local definitions of longer names */
#define CREATED           RTPPARINFO_CREATED
#define SILENT            RTPPARINFO_SILENT
#define TALKING           RTPPARINFO_TALKING
#define WAS_TKING         RTPPARINFO_WAS_TALKING
#define STALL             RTPPARINFO_STALL
#define BYE               RTPPARINFO_BYE
#define DEL               RTPPARINFO_DEL

#define EVENT_CREATED     RTPPARINFO_CREATED
#define EVENT_SILENT      RTPPARINFO_SILENT
#define EVENT_TALKING     RTPPARINFO_TALKING
#define EVENT_WAS_TKING   RTPPARINFO_WAS_TALKING
#define EVENT_STALL       RTPPARINFO_STALL
#define EVENT_BYE         RTPPARINFO_BYE
#define EVENT_DEL         RTPPARINFO_DEL

#define NOQ        0
#define NO_EVENT   0

/**********************************************************************
 * Control word structure (used to direct the participant's state
 * machine)
 **********************************************************************

      3                   2                   1                 
    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |E|X| Tmr | Move| State | Event |    Source     |  Destination  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    v v \-v-/ \-v-/ \--v--/ \--v--/ \------v------/ \------v------/
    | |   |     |      |       |           |               |
    | |   |     |      |       |           |    Destination Queue (8)
    | |   |     |      |       |           | 
    | |   |     |      |       |     Source Queue (8)
    | |   |     |      |       |
    | |   |     |      |       Event to generate (4)
    | |   |     |      |
    | |   |     |      Next state (4)
    | |   |     |
    | |   |     Type of move in queues (3)
    | |   |
    | |   Timer to use (3)
    | |
    | Need to do eXtra processing (1)
    |
    Enable this word (1)

 **********************************************************************
 * Participant's states machine:
 *
 *   \_ user events: RTP, RTCP, BYE, Timeout, DEL
 *     \_  
 *       \_
 * states  \   RTP             RTCP           BYE            Timeout(T)
 *-------------------------------------------------------------------------
 * CREATED     TALKING         SILENT         X              X
 *             AliveQ->Cache1Q       
 *             T1->T           T2->T
 *             EVENT_CREATED   EVENT_CREATED
 *-------------------------------------------------------------------------
 * SILENT      TALKING                        BYE            T3:STALL
 *             AliveQ->Cache1Q AliveQ         AliveQ->ByeQ   AliveQ->ByeQ
 *             T1->T           T3->T          T4->T          T4->T
 *             EVENT_TALKING                  EVENT_BYE      EVENT_STALL
 *-------------------------------------------------------------------------
 * TALKING                                    BYE            T1:WAS_TKING
 *             Cache1Q                        Cache1Q->ByeQ  Cache1Q->Cache2Q
 *             T1->T                          T4->T          T2->T
 *                                            EVENT_BYE      EVENT_WAS_TKING
 *-------------------------------------------------------------------------
 * WAS_TKING   TALKING                        BYE            T2:SILENT
 *             Cache2Q->Cache1Q               Cache2Q->ByeQ  Cache2Q->AliveQ
 *             T1->T                          T4->T          T3->T
 *             EVENT_TALKING                  EVENT_BYE      EVENT_SILENT
 *-------------------------------------------------------------------------
 * STALL       TALKING         SILENT         BYE            T4:DEL
 *             ByeQ->Cache1Q   ByeQ->AliveQ                  ByeQ->
 *                                                           Hash->
 *             T1->T           T3->T          T4->T
 *             EVENT_TALKING   EVENT_SILENT   EVENT_BYE      EVENT_DEL
 *-------------------------------------------------------------------------
 * BYE         ---             ---            ---            T4:DEL
 *                                                           ByeQ->
 *                                                           Hash->
 *                                                           EVENT_DEL
 *-------------------------------------------------------------------------
 * DEL         ---             ---            ---            ---
 *-------------------------------------------------------------------------
 *
 * NOTE On event DEL (that event is not displayed in the chart
 * above. Don't be confused with the state DEL) for all the states,
 * remove user from Cache1Q, Cache2Q, AliveQ or ByeQ, as well as
 * removing it from Hash
 *
 * Cache1Q->AliveQ - move from Cache1Q to AliveQ
 * ByeQ->          - remove from ByeQ
 * Cache1Q         - move to head of Cache1Q
 * T1->T           - set timer to T1
 * X               - invalid
 * ---             - ignore user event
 *
 * */

/*
 * en   - enable this word
 * x    - extra processing
 * ns   - next state
 * move - type of move in queues (1:to head;2:src->dst;3:remove)
 * src  - source queue
 * dst  - destination queue
 * ev   - event to generate
 * tmr  - timer to use */

/*
 * !!! WARNING !!!
 *
 * The offset to Cache1Q, ..., ByeQ MUST NOT be bigger than 1023 and
 * MUST be DWORD aligned (the offset value is stored as number of
 * DWORDS in rtppinfo.c using 8 bits)
 * */
#define TR(en, x, ns, move,  src, dst,  ev, tmr) \
        ((en << 31) | (x << 30) | (ns << 20) | (move << 24) | \
        (((src >> 2) & 0xff) << 8) | ((dst >> 2) & 0xff) | \
        (ev << 16) | (tmr << 27))

#define IsEnabled(dw)   (dw & (1<<31))
#define HasExtra(dw)    (dw & (1<<30))
#define GetTimer(dw)    ((dw >> 27) & 0x7)
#define MoveType(dw)    ((dw >> 24) & 0x7)
#define NextState(dw)   ((dw >> 20) & 0xf)
#define Event(dw)       ((dw >> 16) & 0xf)
#define SrcQ(_addr, dw) \
        ((RtpQueue_t *) ((char *)_addr + (((dw >> 8) & 0xff) << 2)))
#define DstQ(_addr, dw) \
        ((RtpQueue_t *) ((char *)_addr + ((dw & 0xff) << 2)))

const DWORD            g_dwRtpUserTransition[][6] = {
    /*                  en,x,ns,    move, src,    dst,    event,       tmr */
    {
        /*         */ TR(0,0, 0,       0, NOQ,    NOQ,    NO_EVENT,      0),
        /* RTP     */ TR(0,0, 0,       0, NOQ,    NOQ,    NO_EVENT,      0),
        /* RTCP    */ TR(0,0, 0,       0, NOQ,    NOQ,    NO_EVENT,      0),
        /* BYE     */ TR(0,0, 0,       0, NOQ,    NOQ,    NO_EVENT,      0),
        /* TIMEOUT */ TR(0,0, 0,       0, NOQ,    NOQ,    NO_EVENT,      0),
        /* DEL     */ TR(0,0, 0,       0, NOQ,    NOQ,    NO_EVENT,      0)
    },

    /* CREATED */
    {
        /*         */ TR(0,0, 0,       0, NOQ,    NOQ,    NO_EVENT,      0),
        /* RTP     */ TR(1,1, TALKING, 2, ALIVEQ, CACHE1Q,EVENT_CREATED, 0),
        /* RTCP    */ TR(1,0, SILENT,  0, NOQ,    NOQ,    EVENT_CREATED, 0),
        /* BYE     */ TR(0,0, 0,       0, NOQ,    NOQ,    NO_EVENT,      0),
        /* TIMEOUT */ TR(0,0, 0,       0, NOQ,    NOQ,    NO_EVENT,      0),
        /* DEL     */ TR(1,0, DEL,     3, ALIVEQ, NOQ,    NO_EVENT,      0)
    },
    
    /* SILENT */
    {
        /*         */ TR(0,0, 0,       0, NOQ,    NOQ,    NO_EVENT,      0),
        /* RTP     */ TR(1,0, TALKING, 2, ALIVEQ, CACHE1Q,EVENT_TALKING, 0),
        /* RTCP    */ TR(1,0, SILENT,  1, ALIVEQ, NOQ,    NO_EVENT,      0),
        /* BYE     */ TR(1,1, BYE,     2, ALIVEQ, BYEQ,   EVENT_BYE,     0),
        /* TIMEOUT */ TR(1,1, STALL,   2, ALIVEQ, BYEQ,   EVENT_STALL,   3),
        /* DEL     */ TR(1,0, DEL,     3, ALIVEQ, NOQ,    NO_EVENT,      0)
    },

    /* TALKING */
    {
        /*         */ TR(0,0, 0,       0, NOQ,    NOQ,    NO_EVENT,      0),
        /* RTP     */ TR(1,0, TALKING, 1, CACHE1Q,NOQ,    NO_EVENT,      0),
        /* RTCP    */ TR(1,0, TALKING, 0, NOQ,    NOQ,    NO_EVENT,      0),
        /* BYE     */ TR(1,1, BYE,     2, CACHE1Q,BYEQ,   EVENT_BYE,     0),
        /* TIMEOUT */ TR(1,0, WAS_TKING,2,CACHE1Q,CACHE2Q,EVENT_WAS_TKING,1),
        /* DEL     */ TR(1,0, DEL,     3, CACHE1Q,NOQ,    NO_EVENT,      0)
    },

    /* WAS_TKING */
    {
        /*         */ TR(0,0, 0,       0, NOQ,    NOQ,    NO_EVENT,      0),
        /* RTP     */ TR(1,0, TALKING, 2, CACHE2Q,CACHE1Q,EVENT_TALKING, 0),
        /* RTCP    */ TR(1,0, WAS_TKING,0,NOQ,    NOQ,    NO_EVENT,      0),
        /* BYE     */ TR(1,1, BYE,     2, CACHE2Q,BYEQ,   EVENT_BYE,     0),
        /* TIMEOUT */ TR(1,1, SILENT,  2, CACHE2Q,ALIVEQ, EVENT_SILENT,  2),
        /* DEL     */ TR(1,0, DEL,     3, CACHE2Q,NOQ,    NO_EVENT,      0)
    },

    /* STALL */
    {
        /*         */ TR(0,0, 0,       0, NOQ,    NOQ,    NO_EVENT,      0),
        /* RTP     */ TR(1,0, TALKING, 2, BYEQ,   CACHE1Q,EVENT_TALKING, 0),
        /* RTCP    */ TR(1,0, SILENT,  2, BYEQ,   ALIVEQ, EVENT_SILENT,  0),
        /* BYE     */ TR(1,1, BYE,     1, BYEQ,   NOQ,    EVENT_BYE,     0),
        /* TIMEOUT */ TR(1,0, DEL,     3, BYEQ,   NOQ,    EVENT_DEL,     4),
        /* DEL     */ TR(1,0, DEL,     3, BYEQ,   NOQ,    NO_EVENT,      0)
    },

    /* BYE */
    {
        /*         */ TR(0,0, 0,       0, NOQ,    NOQ,    NO_EVENT,      0),
        /* RTP     */ TR(1,0, BYE,     0, NOQ,    NOQ,    NO_EVENT,      0),
        /* RTCP    */ TR(1,0, BYE,     0, NOQ,    NOQ,    NO_EVENT,      0),
        /* BYE     */ TR(1,0, BYE,     0, NOQ,    NOQ,    NO_EVENT,      0),
        /* TIMEOUT */ TR(1,0, DEL,     3, BYEQ,   NOQ,    EVENT_DEL,     4),
        /* DEL     */ TR(1,0, DEL,     3, BYEQ,   NOQ,    NO_EVENT,      0)
    }
};

/* User states are the same as event names. An event may be generated
 * when going to each state, i.e. an event RTPPARINFO_EVENT_SILENT is
 * generated when going to the SILENT state */
const TCHAR_t        **g_psRtpUserStates = &g_psRtpPInfoEvents[0];

const TCHAR_t         *g_psRtpUserEvents[] = {
    _T("invalid"),
    _T("RTP"),
    _T("RTCP"),
    _T("BYE"),
    _T("TIMEOUT"),
    _T("DEL"),
    _T("invalid")
};

const TCHAR_t *g_psFlagValue[] = {
    _T("value"),
    _T("flag")
};


/*
 * WARNING
 *
 * This array is indexed by the user's state, not by the timer to use
 * */
const DWORD            g_dwTimesRtcpInterval[] = {
    /*    first     */  -1,
    /*    created   */  -1,
    /* T3 SILENT    */  5,
    /* T1 talking   */  1, /* Not suposed to be used */
    /* T2 WAS_TKING */  2,
    /* T4 STALL     */  10,
    /* T4 BYE       */  10,
    /*    del       */  -1
};

/* Access the states machine to obtain the next state based on the
 * current state and the user event */
DWORD RtpGetNextUserState(
        DWORD            dwCurrentState,
        DWORD            dwUserEvent
    )
{
    DWORD            dwControl;
    
    dwControl = g_dwRtpUserTransition[dwCurrentState][dwUserEvent];

    return(NextState(dwControl));
}

/*
 * This function can be called from:
 *      1. The thread starting/stoping a session
 *      2. The RTP (reception) thread
 *      3. The RTCP thread
 * */
DWORD RtpUpdateUserState(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        /* The user event is one of RTP, RTCP, BYE, Timeout, DEL */
        DWORD            dwUserEvent
    )
{
    BOOL             bOk1;
    BOOL             bOk2;
    BOOL             bDelUser;
    DWORD            dwError;
    DWORD            i;
    DWORD            dwControl;
    DWORD            dwCurrentState;
    /* The event is one of SILENT, TALKING, etc. */
    DWORD            dwEvent;
    DWORD            dwMoveType;
    DWORD_PTR        dwPar2;
    RtpSess_t       *pRtpSess;
    RtpQueue_t      *pSrcQ;
    RtpQueue_t      *pDstQ;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpOutput_t     *pRtpOutput;

    TraceFunctionName("RtpUpdateUserState");

    bDelUser = FALSE;
    
    bOk1 = RtpEnterCriticalSection(&pRtpAddr->PartCritSect);
    
    bOk2 = RtpEnterCriticalSection(&pRtpUser->UserCritSect);

    if (bOk1 && bOk2)
    {
        dwError = NOERROR;
        dwCurrentState = pRtpUser->dwUserState;

        dwControl = g_dwRtpUserTransition[dwCurrentState][dwUserEvent];

        if (IsEnabled(dwControl))
        {
            dwError = NOERROR;
            pSrcQ = SrcQ(pRtpAddr, dwControl);
            pDstQ = DstQ(pRtpAddr, dwControl);
            dwEvent = Event(dwControl);
            dwMoveType = MoveType(dwControl);
            
            pRtpUser->dwUserState = NextState(dwControl);
        
            switch(dwMoveType)
            {
            case 1:
                /* Move to first place */
                pRtpQueueItem = move2first(pSrcQ,
                                           NULL,
                                           &pRtpUser->UserQItem);
                
                if (!pRtpQueueItem)
                {
                    /* Error */
                    TraceRetail((
                            CLASS_ERROR, GROUP_USER, S_USER_STATE,
                            _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X")
                            _T("move2first failed"),
                            _fname, pRtpAddr, pRtpUser,
                            ntohl(pRtpUser->dwSSRC)
                        ));
                    
                    dwError = RTPERR_QUEUE;
                }
                
                break;
                
            case 2:
                /* Move from pSrcQ to pDstQ */
                pRtpQueueItem = move2ql(pDstQ,
                                        pSrcQ,
                                        NULL,
                                        &pRtpUser->UserQItem);
                
                if (!pRtpQueueItem)
                {
                    /* Error */
                    TraceRetail((
                            CLASS_ERROR, GROUP_USER, S_USER_STATE,
                            _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X")
                            _T("move2ql failed"),
                            _fname, pRtpAddr, pRtpUser, pRtpUser->dwSSRC
                        ));
                    
                    dwError = RTPERR_QUEUE;
                }
                
                break;
                
            case 3:
                /* Remove from pSrcQ (Cache1Q, Cache2Q, ActiveQ or
                 * ByeQ) and Hash */

                /* Remove from Queue ... */
                pRtpQueueItem = dequeue(pSrcQ, NULL, &pRtpUser->UserQItem);
                    
                if (pRtpQueueItem)
                {
                    /* ... then remove from Hash */
                    pRtpQueueItem =
                        removeHdwK(&pRtpAddr->Hash, NULL, pRtpUser->dwSSRC);
                        
                    if (&pRtpUser->HashItem == pRtpQueueItem)
                    {
                        /* This user has to be deleted */
                        bDelUser = TRUE;
                    }
                    else
                    {
                        /* Error */
                        TraceRetail((
                                CLASS_ERROR, GROUP_USER, S_USER_STATE,
                                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] ")
                                _T("SSRC:0x%X removeHK failed"),
                                _fname,
                                pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC)
                            ));

                        dwError = RTPERR_QUEUE;
                    }
                }
                else
                {
                    /* Error */
                    TraceRetail((
                            CLASS_ERROR, GROUP_USER, S_USER_STATE,
                            _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] ")
                            _T("SSRC:0x%X dequeue failed"),
                            _fname, pRtpAddr, pRtpUser,
                            ntohl(pRtpUser->dwSSRC)
                        ));
                    
                    dwError = RTPERR_QUEUE;
                }
                    
                break;
            } /* switch(dwMoveType) */

            if (dwEvent)
            {
                /* Post event */
                pRtpSess = pRtpAddr->pRtpSess;
                
                TraceRetailAdvanced((
                        0, GROUP_USER, S_USER_EVENT,
                        _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] ")
                        _T("SSRC:0x%X %+7s,%u:%s->%s Event:%s"),
                        _fname,
                        pRtpAddr, pRtpUser,
                        ntohl(pRtpUser->dwSSRC),
                        g_psRtpUserEvents[dwUserEvent],
                        dwMoveType,
                        g_psRtpUserStates[dwCurrentState],
                        g_psRtpUserStates[pRtpUser->dwUserState],
                        g_psRtpUserStates[dwEvent]
                    ));

                dwPar2 = 0;
                
                if (dwEvent == USER_EVENT_RTP_PACKET)
                {
                    /* When event is due to an RTP packet received,
                     * pass the payload type encoded in parameter 2,
                     * can not pass just zero as it is a valid payload
                     * type value */
                    dwPar2 = (DWORD_PTR)
                        pRtpUser->RtpNetRState.dwPt | 0x80010000;
                }
                
                RtpPostEvent(pRtpAddr,
                             pRtpUser,
                             RTPEVENTKIND_PINFO,
                             dwEvent,
                             pRtpUser->dwSSRC, /* dwPar1 */
                             dwPar2            /* dwPar2 */ );

                if (HasExtra(dwControl))
                {
                    if (dwCurrentState == RTPPARINFO_CREATED)
                    {
                        if (dwUserEvent == USER_EVENT_RTP_PACKET)
                        {
                            /* In addition to event CREATED, I also
                             * need to post TALKING */
                            RtpPostEvent(pRtpAddr,
                                         pRtpUser,
                                         RTPEVENTKIND_PINFO,
                                         RTPPARINFO_TALKING,
                                         pRtpUser->dwSSRC, /* dwPar1 */
                                         dwPar2            /* dwPar2 */ );
                        }
                    }
                    else
                    {
                        /* Check if we need to test if the user has to
                         * release its output (if it has one assigned)
                         * */
                        pRtpOutput = pRtpUser->pRtpOutput;
                    
                        if (pRtpOutput)
                        {
                            /* Unmap if enabled, OR any time we receive
                             * BYE event, OR if the previous state was
                             * silent (we got timeout) */
                            if (RtpBitTest(pRtpOutput->dwOutputFlags,
                                           RTPOUTFG_ENTIMEOUT) ||
                                dwEvent == EVENT_BYE           ||
                                dwCurrentState == SILENT)
                            {
                                /* Unassign output */
                                RtpOutputUnassign(pRtpSess,
                                                  pRtpUser,
                                                  pRtpOutput);
                            }
                        }
                    }
                }
            }
        }
        else
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_USER, S_USER_STATE,
                    _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] 0x%X ")
                    _T("Invalid transition %+7s,0:%s->???? Event:NONE"),
                    _fname, pRtpAddr, pRtpUser,
                    ntohl(pRtpUser->dwSSRC),
                    g_psRtpUserEvents[dwUserEvent],
                    g_psRtpUserStates[dwCurrentState]
                ));
            
            dwError = RTPERR_INVALIDUSRSTATE;
        }
    }
    else
    {
        dwError = RTPERR_CRITSECT;
    }

    if (bOk2)
    {
        RtpLeaveCriticalSection(&pRtpUser->UserCritSect);
    }

    if (bOk1)
    {
        RtpLeaveCriticalSection(&pRtpAddr->PartCritSect);
    }

    if (bDelUser)
    {
        DelRtpUser(pRtpAddr, pRtpUser);
    }
     
    return(dwError);
}

/* pdwSSRC points to an array of DWORDs where to copy the SSRCs,
 * pdwNumber contains the maximum entries to copy, and returns the
 * actual number of SSRCs copied. If pdwSSRC is NULL, pdwNumber
 * will return the current number of SSRCs (i.e. the current
 * number of participants) */
HRESULT RtpEnumParticipants(
        RtpAddr_t       *pRtpAddr,
        DWORD           *pdwSSRC,
        DWORD           *pdwNumber
    )
{
    HRESULT          hr;
    BOOL             bOk;
    DWORD            dwMax;
    DWORD            i;
    RtpQueueItem_t  *pRtpQueueItem;

    TraceFunctionName("RtpEnumParticipants");

    if (!pRtpAddr)
    {
        /* Having this as a NULL pointer means Init hasn't been
         * called, return this error instead of RTPERR_POINTER to be
         * consistent */
        hr = RTPERR_INVALIDSTATE;

        goto end;
    }

    if (!pdwSSRC && !pdwNumber)
    {
        hr = RTPERR_POINTER;

        goto end;
    }
    
    /* verify object ID */
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_USER, S_USER_ENUM,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        hr = RTPERR_INVALIDRTPADDR;

        goto end;
    }

    hr = NOERROR;
    
    if (!pdwSSRC)
    {
        /* Just want to know how many participants we have */
        *pdwNumber = GetHashCount(&pRtpAddr->Hash);
    }
    else
    {
        /* Copy as many SSRCs as they fit */
        bOk = RtpEnterCriticalSection(&pRtpAddr->PartCritSect);

        if (bOk)
        {
            dwMax = GetHashCount(&pRtpAddr->Hash);

            if (dwMax > *pdwNumber)
            {
                dwMax = *pdwNumber;
            }
            
            for(i = 0, pRtpQueueItem = pRtpAddr->Hash.pFirst;
                i < dwMax;
                i++, pRtpQueueItem = pRtpQueueItem->pNext)
            {
                pdwSSRC[i] = pRtpQueueItem->dwKey;
            }
            
            RtpLeaveCriticalSection(&pRtpAddr->PartCritSect);

            *pdwNumber = dwMax;
        }
        else
        {
            hr = RTPERR_CRITSECT;
        }
    }
    
 end:
    if (SUCCEEDED(hr))
    {
        TraceDebug((
                CLASS_INFO, GROUP_USER, S_USER_ENUM,
                _T("%s: pRtpAddr[0x%p] Number of SSRCs: %u"),
                _fname, pRtpAddr,
                *pdwNumber
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_USER, S_USER_ENUM,
                _T("%s: pRtpAddr[0x%p] Enumeration failed: %u (0x%X)"),
                _fname, pRtpAddr,
                hr, hr
            ));
    }
    
    return(hr);
}

/* Get the participant state and/or get or set its mute state. piState
 * if not NULL, will return the participant's state (e.g. TALKING,
 * SILENT). If piMuted is not NULL, and < 0, will query the mute
 * state, otherwise will set it (= 0 unmute, > 0 mute) */
HRESULT RtpMofifyParticipantInfo(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwSSRC,
        DWORD            dwControl,
        DWORD           *pdwValue
    )
{
    HRESULT          hr;
    BOOL             bOk;
    BOOL             bCreate;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpUser_t       *pRtpUser;

    DWORD            dwBit;
    DWORD            dwSize;
    DWORD           *pDWORD;
    DWORD            dwValue;

    double dCurTime;

    TraceFunctionName("RtpMofifyParticipantInfo");

    dwValue = 0;
    
    pRtpUser = (RtpUser_t *)NULL;
    
    /* Get bit to act uppon (if needed) */
    dwBit = RTPUSER_GET_BIT(dwControl);

    /* Get size of bytes to act upon */
    dwSize = RTPUSER_GET_SIZE(dwControl);
    
    if (!pRtpAddr)
    {
        /* Having this as a NULL pointer means Init hasn't been
         * called, return this error instead of RTPERR_POINTER to be
         * consistent */
        hr = RTPERR_INVALIDSTATE;

        goto end;
    }
    
    /* verify object ID */
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_USER, S_USER_INFO,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        hr = RTPERR_INVALIDRTPADDR;

        goto end;
    }

    if (!pdwValue)
    {
        hr = RTPERR_POINTER;

        goto end;
    }

    dwValue = *pdwValue;
    
    bOk = RtpEnterCriticalSection(&pRtpAddr->PartCritSect);

    if (!bOk)
    {
        hr = RTPERR_CRITSECT;

        goto end;
    }

    hr = NOERROR;

    if (dwSSRC == 0)
    {
        /* If SSRC==0, it means the caller wants to enable this
         * for any and all SSRCs */

        /* Get DWORD to act upon */
        pDWORD = RTPDWORDPTR(pRtpAddr, RTPUSER_GET_OFF(dwControl));
        
        if (*pdwValue)
        {
            /* Set flag */
            RtpBitSet(*pDWORD, dwBit);
        }
        else
        {
            /* Reset flag */
            RtpBitReset(*pDWORD, dwBit);
        }

        TraceRetail((
                CLASS_INFO, GROUP_USER, S_USER_INFO,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                _T("%s %s bit:%u value:%u (0x%X)"),
                _fname, pRtpAddr, pRtpUser, dwSSRC,
                g_psGetSet[(dwControl >> RTPUSER_BIT_SET) & 0x1],
                g_psFlagValue[(dwControl >> RTPUSER_BIT_FLAG) & 0x1],
                dwBit, *pdwValue, *pdwValue
            ));
    }
    else if (dwSSRC == NO_DW_VALUESET)
    {
        /* With SSRC=-1, choose the first participant */

        /* Try first the most recently talking */
        pRtpQueueItem = pRtpAddr->Cache1Q.pFirst;

        if (!pRtpQueueItem)
        {
            /* If none, try second level cache */
            pRtpQueueItem = pRtpAddr->Cache2Q.pFirst;

            if (!pRtpQueueItem)
            {
                /* If none, try just the first one */
                pRtpQueueItem = pRtpAddr->AliveQ.pFirst;
            }
        }

        if (pRtpQueueItem)
        {
            pRtpUser = CONTAINING_RECORD(pRtpQueueItem, RtpUser_t, UserQItem);
        }
        else
        {
            pRtpUser = (RtpUser_t *)NULL;
        }
    }
    else
    {
        /* Look up the participant */
        bCreate = FALSE;
        pRtpUser = LookupSSRC(pRtpAddr, dwSSRC, &bCreate);
    }

    if (pRtpUser)
    {
        bOk = RtpEnterCriticalSection(&pRtpUser->UserCritSect);

        if (bOk)
        {
            /* Decide if this is a set or query */

            /* Get DWORD to act upon */
            pDWORD = RTPDWORDPTR(pRtpUser, RTPUSER_GET_OFF(dwControl));
            
            if (RTPUSER_IsSetting(dwControl))
            {
                /*
                 * Setting a new flag or DWORD
                 */
                
                if (RTPUSER_IsFlag(dwControl))
                {
                    /* Setting a flag */
                    
                    if (*pdwValue)
                    {
                        /* Set flag */
                        RtpBitSet(*pDWORD, dwBit);
                    }
                    else
                    {
                        /* Reset flag */
                        RtpBitReset(*pDWORD, dwBit);
                    }
                }
                else
                {
                    /* Setting bytes */
                    CopyMemory(pDWORD, (BYTE *)pdwValue, dwSize);
                }
            }
            else
            {
                /*
                 * Querying current value
                 */
                
                if (RTPUSER_IsFlag(dwControl))
                {
                    /* Querying a flag */

                    *pdwValue = RtpBitTest(*pDWORD, dwBit)? TRUE : FALSE;
                }
                else
                {
                    /* Querying a DWORD */
                    CopyMemory((BYTE *)pdwValue, pDWORD, dwSize);
                }

                if (dwControl == RTPUSER_GET_NETINFO)
                {
                    dCurTime = RtpGetTimeOfDay(NULL);

                    /* The stored time is that of the last update,
                     * transform that so it is rather its age */
                    ((RtpNetInfo_t *)pdwValue)->dMetricAge =
                        dCurTime - ((RtpNetInfo_t *)pdwValue)->dLastUpdate;
                }
            }

            RtpLeaveCriticalSection(&pRtpUser->UserCritSect);

            TraceRetail((
                    CLASS_INFO, GROUP_USER, S_USER_INFO,
                    _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                    _T("%s %s bit:%u value:%u (0x%X)"),
                    _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                    g_psGetSet[(dwControl >> RTPUSER_BIT_SET) & 0x1],
                    g_psFlagValue[(dwControl >> RTPUSER_BIT_FLAG) & 0x1],
                    dwBit, *pdwValue, *pdwValue
                ));
        }
        else
        {
            hr = RTPERR_CRITSECT;
        }
    }
    else if (dwSSRC)
    {
        hr = RTPERR_NOTFOUND;
        
        TraceRetail((
                CLASS_WARNING, GROUP_USER, S_USER_INFO,
                _T("%s: pRtpAddr[0x%p] SSRC:0x%X not found"),
                _fname, pRtpAddr, ntohl(dwSSRC)
            ));
    }
    
    RtpLeaveCriticalSection(&pRtpAddr->PartCritSect);

end:
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_USER, S_USER_INFO,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                _T("%s %s bit:%u value:%u (0x%X) ")
                _T("failed: %u (0x%X)"),
                _fname, pRtpAddr, pRtpUser, ntohl(dwSSRC),
                g_psGetSet[(dwControl >> RTPUSER_BIT_SET) & 0x1],
                g_psFlagValue[(dwControl >> RTPUSER_BIT_FLAG) & 0x1],
                dwBit, dwValue, dwValue,
                hr, hr
            ));
    }
    
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\funcs\rtprtp.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtprtp.c
 *
 *  Abstract:
 *
 *    Implements the RTP specific family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#include "struct.h"
#include "rtprtp.h"
#include "rtcpthrd.h"

HRESULT ControlRtpRtp(RtpControlStruct_t *pRtpControlStruct)
{

    return(NOERROR);
}

/* Set the bandwidth limits. A value of -1 will make the parameter
 * to be ignored.
 *
 * All the parameters are in bits/sec */
DWORD RtpSetBandwidth(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwInboundBw,
        DWORD            dwOutboundBw,
        DWORD            dwReceiversRtcpBw,
        DWORD            dwSendersRtcpBw
    )
{
    RtpNetSState_t  *pRtpNetSState;
    DWORD            dwOverallBw;
    
    TraceFunctionName("RtpSetBandwidth");
    
    pRtpNetSState = &pRtpAddr->RtpNetSState;
    
    if (IsDWValueSet(dwInboundBw))
    {
        if (pRtpNetSState->dwInboundBandwidth != dwInboundBw)
        {
            pRtpNetSState->dwInboundBandwidth = dwInboundBw;

            /* Need to update reservations if receiver has QOS ON */
            if (RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSRECVON))
            {
                /* Make a new QOS reservation */
                RtcpThreadCmd(&g_RtcpContext,
                              pRtpAddr,
                              RTCPTHRD_RESERVE,
                              RECV_IDX,
                              DO_NOT_WAIT);
            }
        }
    }

    if (IsDWValueSet(dwOutboundBw))
    {
        if (pRtpNetSState->dwOutboundBandwidth != dwOutboundBw)
        {
            pRtpNetSState->dwOutboundBandwidth = dwOutboundBw;

            /* Need to update the sender flowspec if sender has QOS ON */
            if (RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSSENDON))
            {
                /* Modify the flowspec sent in PATH messages */
                RtcpThreadCmd(&g_RtcpContext,
                              pRtpAddr,
                              RTCPTHRD_RESERVE,
                              SEND_IDX,
                              DO_NOT_WAIT);
            }
        }
    }

    dwOverallBw =
        pRtpNetSState->dwInboundBandwidth + pRtpNetSState->dwOutboundBandwidth;
    
    if (IsDWValueSet(dwReceiversRtcpBw))
    {
        if (pRtpNetSState->dwRtcpBwReceivers != dwReceiversRtcpBw)
        {
            pRtpNetSState->dwRtcpBwReceivers = dwReceiversRtcpBw;

            RtpBitSet(pRtpNetSState->dwNetSFlags, FGNETS_RTCPRECVBWSET);
        }
    }
    else
    {
        /* Compute a default value if none has been set */
        if (!RtpBitTest(pRtpNetSState->dwNetSFlags, FGNETS_RTCPRECVBWSET))
        {
            /* Give to receivers 25% out of the 5% used for RTCP */
            pRtpNetSState->dwRtcpBwReceivers =
                dwOverallBw * (25 * 5) / 10000;  
        }
    }

    if (IsDWValueSet(dwSendersRtcpBw))
    {
        if (pRtpNetSState->dwRtcpBwSenders != dwSendersRtcpBw)
        {
            pRtpNetSState->dwRtcpBwSenders = dwSendersRtcpBw;

            RtpBitSet(pRtpNetSState->dwNetSFlags, FGNETS_RTCPSENDBWSET);
        }
    }
    else
    {
        /* Compute a default value if none has been set */
        if (!RtpBitTest(pRtpNetSState->dwNetSFlags, FGNETS_RTCPSENDBWSET))
        {
            /* Give to senders 75% out of the 5% used for RTCP */
            pRtpNetSState->dwRtcpBwReceivers =
                dwOverallBw * (75 * 5) / 10000;  
        }
    }

    TraceRetail((
            CLASS_INFO, GROUP_RTP, S_RTP_SETBANDWIDTH,
            _T("%s: pRtpAddr[0x%p] ")
            _T("Inbound:%d/%d Outbound:%d/%d ")
            _T("RTCP Receivers:%d/%d RTCP Senders:%d/%d"),
            _fname, pRtpAddr,
            dwInboundBw, pRtpNetSState->dwInboundBandwidth,
            dwOutboundBw, pRtpNetSState->dwOutboundBandwidth,
            dwReceiversRtcpBw, pRtpNetSState->dwRtcpBwReceivers,
            dwSendersRtcpBw, pRtpNetSState->dwRtcpBwSenders
        ));
    
    return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\funcs\rtpstats.c ===
/**********************************************************************
 *
 *  Copyright (c) 1999 Microsoft Corporation
 *
 *  File name:
 *
 *    rtpstats.c
 *
 *  Abstract:
 *
 *    Implements the Statistics family of functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/07 created
 *
 **********************************************************************/

#include "struct.h"
#include "rtpheap.h"
#include "rtpglobs.h"

#include "rtpstats.h"

HRESULT ControlRtpStats(RtpControlStruct_t *pRtpControlStruct)
{

    return(NOERROR);
}

/* Helper function to update counters */
BOOL UpdateRtpStat(RtpStat_t *pRtpStat,/* structure where to update */
                   DWORD      dwRtpRtcp, /* 0=RTP or 1=RTCP stats */
                   DWORD      dwBytes, /* bytes toupdate */
                   DWORD      dwTime)  /* time packet recv/send */
{
    if (pRtpStat) {
        if (!dwRtpRtcp) { /* RTP */
            pRtpStat->dwRTPBytes += dwBytes;
            pRtpStat->dwRTPPackets++;
            pRtpStat->dwRTPLastTime = dwTime;
        } else {          /* RTCP */
            pRtpStat->dwRTCPBytes += dwBytes;
            pRtpStat->dwRTCPPackets++;
            pRtpStat->dwRTCPLastTime = dwTime;
        }
    }

    return(pRtpStat != NULL);
}

#if 0
/* Creates and initializes a RtpStat_t structure */
RtpStat_t *RtpStatAlloc(void)
{
    RtpStat_t *pRtpStat;

    pRtpStat = (RtpStat_t *)
        RtpHeapAlloc(g_pRtpStatHeap, sizeof(RtpStat_t));

    if (pRtpStat) {
        
        ZeroMemory(pRtpStat, sizeof(RtpStat_t));

        pRtpStat->dwObjectID = OBJECTID_RTPSTAT;
    }
    
    return(pRtpStat);
}

/* Frees a RtpStat_t structure */
void RtpStatFree(RtpStat_t *pRtpStat)
{
    if (pRtpStat->dwObjectID != OBJECTID_RTPSTAT) {
        /* TODO log error */
        return;
    }
    
    RtpHeapFree(g_pRtpStatHeap, pRtpStat);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\funcs\rtpred.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpred.c
 *
 *  Abstract:
 *
 *    Implements functionality to support redundant encoding (rfc2198)
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2000/10/19 created
 *
 **********************************************************************/

#include "gtypes.h"
#include "rtphdr.h"
#include "struct.h"
#include "rtpglobs.h"
#include "rtprand.h"
#include "rtpreg.h"
#include "rtpdejit.h"
#include "rtpqos.h"
#include "rtcpthrd.h"

#include "rtpred.h"

typedef struct _RtpLossRateThresh_t {
    int              LossRateLowThresh;
    int              LossRateHigThresh;
} RtpLossRateThresh_t;

RtpLossRateThresh_t g_RtpLossRateThresh[] =
{
    /* 0 */ { RED_LT_0, RED_HT_0},
    /* 1 */ { RED_LT_1, RED_HT_1},
    /* 2 */ { RED_LT_2, RED_HT_2},
    /* 3 */ { RED_LT_3, RED_HT_3},
    /*   */ {       -1, -1}
};

/* The timeout used when scheduling a received packet to be posted at
 * a later time will be decreased by this value */
double           g_dRtpRedEarlyTimeout = RTP_RED_EARLY_TIMEOUT;
/* Will post immediatly (instead of scheduling for later) if the due
 * time is at least this close. This value can not be smaller than the
 * early timeout */
double           g_dRtpRedEarlyPost = RTP_RED_EARLY_POST;


/* Configures redundancy. For a receiver only parameter dwPT_Red
 * is used (the other are ignored) and may be set to -1 to ignore
 * it if it was already set or to assign the default. For a
 * sender, parameters dwPT_Red, dwInitialRedDistance, and
 * dwMaxRedDistance can be set to -1 to ignore the parameter if it
 * was already set or to assign the default value */
DWORD RtpSetRedParameters(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwFlags,
        DWORD            dwPT_Red,
        DWORD            dwInitialRedDistance,
        DWORD            dwMaxRedDistance
    )
{
    DWORD            dwError;
    RtpNetSState_t  *pRtpNetSState;
    
    TraceFunctionName("RtpSetRedParameters");  

    /* Validate parameters */
    dwError = RTPERR_INVALIDARG;
    
    if (IsDWValueSet(dwPT_Red) && ((dwPT_Red & 0x7f) != dwPT_Red))
    {
        goto end;
    }

    /* This is only valid for audio */
    if (RtpGetClass(pRtpAddr->dwIRtpFlags) != RTPCLASS_AUDIO)
    {
        dwError = RTPERR_INVALIDSTATE;
        
        goto end;
    }
    
    
    if (RtpBitTest(dwFlags, RECV_IDX))
    {
        /* Receiver parameters */

        if ( IsRegValueSet(g_RtpReg.dwRedEnable) &&
             ((g_RtpReg.dwRedEnable & 0x03) == 0x02) )
        {
            /* Redundancy at the receiver is forced disabled */

            dwError = NOERROR;

            TraceRetail((
                    CLASS_WARNING, GROUP_RTP, S_RTP_REDINIT,
                    _T("%s: pRtpAddr[0x%p] RECV redundancy ")
                    _T("being forced disabled from the regisrty"),
                    _fname, pRtpAddr
                ));

            goto end;
        }
        
        if (IsDWValueSet(dwPT_Red))
        {
            pRtpAddr->bPT_RedRecv = (BYTE)dwPT_Red;
        }
        else if (pRtpAddr->bPT_RedRecv == NO_PAYLOADTYPE)
        {
            pRtpAddr->bPT_RedRecv = RTP_RED_DEFAULTPT;
        }

        dwError = NOERROR;
        
        RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_REDRECV);

        TraceRetail((
                CLASS_INFO, GROUP_RTP, S_RTP_REDINIT,
                _T("%s: pRtpAddr[0x%p] RECV PT:%u"),
                _fname, pRtpAddr, pRtpAddr->bPT_RedRecv
            ));
    }

    if (RtpBitTest(dwFlags, SEND_IDX))
    {
        /* Sender parameters */

        if ( (IsDWValueSet(dwMaxRedDistance) &&
              (dwMaxRedDistance > RTP_RED_MAXDISTANCE)) ||
             (IsDWValueSet(dwInitialRedDistance) &&
              (dwInitialRedDistance > RTP_RED_MAXDISTANCE)) )
        {
            goto end;
        }

        if ( IsRegValueSet(g_RtpReg.dwRedEnable) &&
             ((g_RtpReg.dwRedEnable & 0x30) == 0x20) )
        {
            /* Redundancy at the sender is forced disabled */

            dwError = NOERROR;

            TraceRetail((
                    CLASS_WARNING, GROUP_RTP, S_RTP_REDINIT,
                    _T("%s: pRtpAddr[0x%p] SEND redundancy ")
                    _T("being forced disabled from the regisrty"),
                    _fname, pRtpAddr
                ));

            goto end;
        }
        
        pRtpNetSState = &pRtpAddr->RtpNetSState;

        if (IsDWValueSet(dwPT_Red))
        {
            pRtpNetSState->bPT_RedSend = (BYTE)dwPT_Red;
        }
        else if (pRtpNetSState->bPT_RedSend == NO_PAYLOADTYPE)
        {
            pRtpNetSState->bPT_RedSend = RTP_RED_DEFAULTPT;
        }

        if (IsDWValueSet(dwInitialRedDistance))
        {
            pRtpNetSState->dwInitialRedDistance = dwInitialRedDistance;
        }
        else if (!pRtpNetSState->dwInitialRedDistance)
        {
            pRtpNetSState->dwInitialRedDistance = RTP_RED_INITIALDISTANCE;
        }
            
        if (IsDWValueSet(dwMaxRedDistance))
        {
            pRtpNetSState->dwMaxRedDistance = dwMaxRedDistance;
        }
        else if (!pRtpNetSState->dwMaxRedDistance)
        {
            pRtpNetSState->dwMaxRedDistance = RTP_RED_MAXDISTANCE;
        }

        dwError = NOERROR;
        
        if (pRtpNetSState->dwMaxRedDistance > 0)
        {
            if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_REDSEND))
            {
                /* Redundancy descriptors were already allocated */
            }
            else
            {
                /* Allocate redundancy structures only the first time the
                 * function is called */
                dwError = RtpRedAllocBuffs(pRtpAddr);
        
                if (pRtpNetSState->bPT_RedSend != NO_PAYLOADTYPE &&
                    dwError == NOERROR)
                {
                    /* This flag (FGADDR_REDSEND) will enable use of
                     * redundancy for sending, the actual redundancy will
                     * be sent or not depending on the current value of
                     * flag FGSEND_USERED
                     * */
                    RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_REDSEND);
                }
            }
        }
        else
        {
            /* dwMaxRedDistance == 0 means NO redundancy */
            RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_REDSEND);
        }

        if (dwError == NOERROR)
        {
            TraceRetail((
                    CLASS_INFO, GROUP_RTP, S_RTP_REDINIT,
                    _T("%s: pRtpAddr[0x%p] SEND PT:%u Distance:%u/%u"),
                    _fname, pRtpAddr,
                    pRtpNetSState->bPT_RedSend,
                    pRtpNetSState->dwInitialRedDistance,
                    pRtpNetSState->dwMaxRedDistance
                ));
        }
    }

 end:
    if (dwError != NOERROR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTP, S_RTP_REDINIT,
                _T("%s: pRtpAddr[0x%p] failed PT:%u ")
                _T("Distance:%u/%u %u (0x%X)"),
                _fname, pRtpAddr,
                dwPT_Red, dwInitialRedDistance,
                dwMaxRedDistance,
                dwError, dwError
            ));
    }

    return(dwError);
}

/* Determine if the playout bounds need to be updated */
DWORD RtpUpdatePlayoutBounds(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        RtpRecvIO_t     *pRtpRecvIO
    )
{
    RtpNetRState_t  *pRtpNetRState;
    
    TraceFunctionName("RtpUpdatePlayoutBounds");  

    if ( RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_REDRECV) &&
         (pRtpUser->RtpNetRState.iAvgLossRateR >= RED_LT_1) )
    {
        pRtpNetRState = &pRtpUser->RtpNetRState;
            
        if (pRtpRecvIO->lRedHdrSize)
        {
            /* Had redundancy */
            
            pRtpNetRState->dwNoRedCount = 0;

            /* Update the minimum playout if needed */
            
            if (pRtpRecvIO->dwMaxTimeStampOffset ==
                pRtpNetRState->dwMaxTimeStampOffset)
            {
                pRtpNetRState->dwRedCount = 0;
            }
            else
            {
                pRtpNetRState->dwRedCount++;
                
                if ( (pRtpRecvIO->dwMaxTimeStampOffset >
                      pRtpNetRState->dwMaxTimeStampOffset) ||
                     (pRtpNetRState->dwRedCount >= RTP_RED_MAXDISTANCE * 4) )
                {
                    /* Update playout bounds immediatly if the
                     * distance has grown, or if we have seen at least
                     * a certian number of packets with the new
                     * shorter distance */
                    pRtpNetRState->dwMaxTimeStampOffset =
                        pRtpRecvIO->dwMaxTimeStampOffset;

                    pRtpNetRState->dRedPlayout =
                        (double)pRtpRecvIO->dwMaxTimeStampOffset /
                        pRtpNetRState->dwRecvSamplingFreq;
                
                    pRtpNetRState->dMinPlayout =
                        pRtpNetRState->dRedPlayout + g_dMinPlayout;
                    
                    if (pRtpNetRState->dMaxPlayout <
                        pRtpNetRState->dMinPlayout)
                    {
                        pRtpNetRState->dMaxPlayout =
                            pRtpNetRState->dMinPlayout + g_dMaxPlayout/4;
                    }

                    pRtpNetRState->dwRedCount = 0;

                    TraceRetail((
                        CLASS_INFO, GROUP_RTP, S_RTP_REDRECV,
                        _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                        _T("receive new red distance:%u (%0.3f) ")
                        _T("playout(%0.3f,%0.3f)"),
                        _fname, pRtpAddr, pRtpUser,
                        ntohl(pRtpUser->dwSSRC),
                        (pRtpNetRState->dwRecvSamplesPerPacket > 0)?
                        pRtpNetRState->dwMaxTimeStampOffset/
                        pRtpNetRState->dwRecvSamplesPerPacket:7,
                        pRtpNetRState->dRedPlayout,
                        pRtpNetRState->dMinPlayout,
                        pRtpNetRState->dMaxPlayout
                    ));
                }
            }
        }
        else if (pRtpNetRState->dwMaxTimeStampOffset)
        {
            /* Didn't have redundancy */

            pRtpNetRState->dwNoRedCount++;

            if (pRtpNetRState->dwNoRedCount >= RTP_RED_MAXDISTANCE * 4)
            {
                pRtpNetRState->dwRedCount = 0;
                
                pRtpNetRState->dRedPlayout = 0;

                pRtpNetRState->dMinPlayout = g_dMinPlayout;

                pRtpNetRState->dMaxPlayout = g_dMaxPlayout;
                
                pRtpNetRState->dwMaxTimeStampOffset = 0;

                TraceRetail((
                        CLASS_INFO, GROUP_RTP, S_RTP_REDRECV,
                        _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                        _T("stopped receiving redundancy"),
                        _fname, pRtpAddr, pRtpUser,
                        ntohl(pRtpUser->dwSSRC)
                    ));
            }
        }
    }

    return(NOERROR);
}

/* Adjust redundancy level at the sender */
DWORD RtpAdjustSendRedundancyLevel(RtpAddr_t *pRtpAddr)
{
    RtpNetSState_t  *pRtpNetSState;
    DWORD            dwCurRedDistance;
    DWORD            dwNewRedDistance;
    DWORD            i;
    BOOL             bUpdateQOS;

    TraceFunctionName("RtpAdjustSendRedundancyLevel");  

    bUpdateQOS = FALSE;
    pRtpNetSState = &pRtpAddr->RtpNetSState;
    dwNewRedDistance = pRtpNetSState->dwNxtRedDistance;

    if (pRtpNetSState->iAvgLossRateS >
        g_RtpLossRateThresh[dwNewRedDistance].LossRateHigThresh)
    {
        /* High loss rate, increase the redundancy level to match the
         * current loss rate if possible */
        if (dwNewRedDistance < pRtpNetSState->dwMaxRedDistance)
        {
            for(;
                dwNewRedDistance < pRtpNetSState->dwMaxRedDistance;
                dwNewRedDistance++)
            {
                if (pRtpNetSState->iAvgLossRateS <
                    g_RtpLossRateThresh[dwNewRedDistance].LossRateHigThresh)
                {
                    break;
                }
            }

            if (RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSSENDON) &&
                !RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSREDSENDON))
            {
                /* QOS in the sender is enabled but we haven't updated the
                 * reservation to include the redundancy, update it
                 * now. Set the following flag first as it is used to let
                 * QOS know that redundancy is used and the flowspec needs
                 * to be set accordingly */
                RtpBitSet(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSREDSENDON);

                bUpdateQOS = TRUE;
            }
        }
    }
    else if (pRtpNetSState->iAvgLossRateS <
             g_RtpLossRateThresh[dwNewRedDistance].LossRateLowThresh)
    {
        if (dwNewRedDistance > 0)
        {
            /* Decrease the redundancy level */
            dwNewRedDistance--;

            if (!dwNewRedDistance)
            {
                /* Not using redundancy at all */

                if (RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSSENDON) &&
                    RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSREDSENDON))
                {
                    /* QOS in the sender is enabled but we haven't updated
                     * the reservation to include the redundancy, update
                     * it now. Reset the following flag first as it is
                     * used to let QOS know that redundancy is not used
                     * and the flowspec needs to be set accordingly */
                    RtpBitReset(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSREDSENDON);

                    bUpdateQOS = TRUE;
                }
            }
        }
    }

    if (dwNewRedDistance != pRtpNetSState->dwNxtRedDistance)
    {
        if ( IsRegValueSet(g_RtpReg.dwRedEnable) &&
             ((g_RtpReg.dwRedEnable & 0x0300) == 0x0200) )
        {
            /* Updating sender's redundancy distance is disabled from
             * the registry */
            TraceRetail((
                    CLASS_WARNING, GROUP_RTP, S_RTP_REDSEND,
                    _T("%s: pRtpAddr[0x%p] New redundancy distance %u ")
                    _T("required but forced fix to %u from the registry"),
                    _fname, pRtpAddr,
                    dwNewRedDistance, pRtpNetSState->dwNxtRedDistance
                ));
        }
        else
        {
            TraceRetail((
                    CLASS_INFO, GROUP_RTP, S_RTP_REDSEND,
                    _T("%s: pRtpAddr[0x%p] New (%c) redundancy distance:%u ")
                    _T("average send loss rate:%0.2f%%"),
                    _fname, pRtpAddr,
                    (dwNewRedDistance > pRtpNetSState->dwNxtRedDistance)?
                    _T('+'):_T('-'),
                    dwNewRedDistance,
                    (double)pRtpNetSState->iAvgLossRateS/LOSS_RATE_FACTOR
                ));

            /* Update new redundancy distance */
            pRtpNetSState->dwNxtRedDistance = dwNewRedDistance;

            if (!pRtpNetSState->dwNxtRedDistance)
            {
                /* If redundancy is not needed any more, update
                 * current value right away */
                pRtpNetSState->dwCurRedDistance =
                    pRtpNetSState->dwNxtRedDistance;
            }
            
            if (bUpdateQOS)
            {
                /* Update the flowspec... */
                RtpSetQosFlowSpec(pRtpAddr, SEND_IDX);
                
                /* ...and do a new reservation */
                RtcpThreadCmd(&g_RtcpContext,
                              pRtpAddr,
                              RTCPTHRD_RESERVE,
                              SEND_IDX,
                              DO_NOT_WAIT);
            }
        }
    }

    return(NOERROR);
}

/* Add a buffer for the sender to use as redundancy.
 *
 * NOTE that the dwTimeStamp passed doesn't have yet the random offset
 * added */
DWORD RtpAddRedundantBuff(
        RtpAddr_t       *pRtpAddr,
        WSABUF          *pWSABuf,
        DWORD            dwTimeStamp
    )
{
    DWORD            dwIndex;
    RtpNetSState_t  *pRtpNetSState;
    RtpRedEntry_t   *pRtpRedEntry;

    TraceFunctionName("RtpAddRedundantBuff");  

    pRtpNetSState = &pRtpAddr->RtpNetSState;

    dwIndex = pRtpNetSState->dwRedIndex;
    pRtpRedEntry = &pRtpNetSState->pRtpRedEntry[dwIndex];

    dwTimeStamp += pRtpNetSState->dwTimeStampOffset;
    
    pRtpRedEntry->bValid = TRUE;
    pRtpRedEntry->bRedPT = pRtpNetSState->bPT;
    /* At this point the sequence number was already incremented in
     * UpdateRtpRedHdr */
    pRtpRedEntry->dwSeq  = pRtpNetSState->dwSeq - 1;
    pRtpRedEntry->dwTimeStamp = dwTimeStamp;
    pRtpRedEntry->WSABuf.buf = pWSABuf->buf;
    pRtpRedEntry->WSABuf.len = pWSABuf->len;

    pRtpNetSState->dwRedIndex = (dwIndex + 1) % RTP_RED_MAXDISTANCE;

    TraceDebugAdvanced((
            0, GROUP_RTP, S_RTP_REDSENDPKT,
            _T("%s: pRtpAddr[0x%p] Store Red[%u] PT:%u seq:%u ts:%u len:%u"),
            _fname, pRtpAddr,
            dwIndex, pRtpRedEntry->bRedPT,
            pRtpRedEntry->dwSeq,
            pRtpRedEntry->dwTimeStamp,
            pRtpRedEntry->WSABuf.len
        ));
    
    return(NOERROR);
}

/* Clear all the sender's redundant buffers */
DWORD RtpClearRedundantBuffs(RtpAddr_t *pRtpAddr)
{
    DWORD            i;
    RtpNetSState_t  *pRtpNetSState;
    RtpRedEntry_t   *pRtpRedEntry;
    
    TraceFunctionName("RtpClearRedundantBuffs");  

    pRtpNetSState = &pRtpAddr->RtpNetSState;
    pRtpRedEntry = pRtpNetSState->pRtpRedEntry;
    
    if (pRtpRedEntry)
    {
        for(i = 0; i < pRtpNetSState->dwRedEntries; i++)
        {
            pRtpRedEntry[i].bValid = FALSE;
            pRtpRedEntry[i].bRedPT = NO_PAYLOADTYPE;
            pRtpRedEntry[i].WSABuf.len = 0;
            pRtpRedEntry[i].WSABuf.buf = NULL;
        }

        TraceDebugAdvanced((
                0, GROUP_RTP, S_RTP_REDSEND,
                _T("%s: pRtpAddr[0x%p] All redundancy has been invalidated"),
                _fname, pRtpAddr
            ));
    }

    pRtpNetSState->dwRedIndex = 0;
    
    return(NOERROR);
}

/* Allocte the buffer descriptors for the sender to use redundancy */
DWORD RtpRedAllocBuffs(RtpAddr_t *pRtpAddr)
{
    DWORD            dwError;
    RtpNetSState_t  *pRtpNetSState;
    
    TraceFunctionName("RtpRedAllocBuffs");  

    pRtpNetSState = &pRtpAddr->RtpNetSState;
    
    if (pRtpNetSState->pRtpRedEntry)
    {
        RtpRedFreeBuffs(pRtpAddr);
    }

    dwError = RTPERR_MEMORY;
    
    pRtpNetSState->pRtpRedEntry =
        RtpHeapAlloc(g_pRtpAddrHeap,
                     sizeof(RtpRedEntry_t) * RTP_RED_MAXDISTANCE);

    if (pRtpNetSState->pRtpRedEntry)
    {
        pRtpNetSState->dwRedEntries = RTP_RED_MAXDISTANCE;

        pRtpNetSState->dwRedIndex = 0;
        
        dwError = NOERROR;
    }

    if (dwError == NOERROR)
    {
        TraceRetail((
                CLASS_INFO, GROUP_RTP, S_RTP_REDINIT,
                _T("%s: pRtpAddr[0x%p] allocated %d redundancy entries"),
                _fname, pRtpAddr, pRtpNetSState->dwRedEntries
            ));
    }
    else
    {
         TraceRetail((
                CLASS_ERROR, GROUP_RTP, S_RTP_REDINIT,
                _T("%s: pRtpAddr[0x%p] failed to allocate entries: ")
                _T("%s (0x%X)"),
                _fname, pRtpAddr, RTPERR_TEXT(dwError), dwError
             ));
    }
    
    return(dwError);
}

/* Free the buffer descriptors used by the sender for redundancy */
DWORD RtpRedFreeBuffs(RtpAddr_t *pRtpAddr)
{
    DWORD            dwError;
    DWORD            dwRedEntries;
    RtpNetSState_t  *pRtpNetSState;
    
    TraceFunctionName("RtpRedFreeBuffs");  

    pRtpNetSState = &pRtpAddr->RtpNetSState;
    dwRedEntries = pRtpNetSState->dwRedEntries;
    
    if (pRtpNetSState->pRtpRedEntry)
    {
        RtpHeapFree(g_pRtpAddrHeap, pRtpNetSState->pRtpRedEntry);

        pRtpNetSState->pRtpRedEntry = (RtpRedEntry_t *)NULL;

        pRtpNetSState->dwRedEntries = 0;
    }
    
    TraceRetail((
            CLASS_INFO, GROUP_RTP, S_RTP_REDINIT,
            _T("%s: pRtpAddr[0x%p] freed  %d redundancy entries"),
            _fname, pRtpAddr, dwRedEntries
        ));
    
    return(NOERROR);
}    

int RtpUpdateLossRate(
        int              iAvgLossRate,
        int              iCurLossRate
    )
{
    /* Smooth the loss rate */

    if (iAvgLossRate > iCurLossRate)
    {
        iAvgLossRate += ((iCurLossRate - iAvgLossRate) / LOSS_RATE_ALPHA_UP);
    }
    else
    {
        iAvgLossRate += ((iCurLossRate - iAvgLossRate) / LOSS_RATE_ALPHA_DN);
    }

    return(iAvgLossRate);
}

#if USE_GEN_LOSSES > 0
BOOL RtpRandomLoss(DWORD dwRecvSend)
{
    BOOL             bLossIt;
    DWORD            dwRand;

    bLossIt = FALSE;

    if (IsRegValueSet(g_RtpReg.dwGenLossEnable))
    {
        if (!dwRecvSend)
        {
            /* Receiver */
            if (IsRegValueSet(g_RtpReg.dwRecvLossRate) &&
                ((g_RtpReg.dwGenLossEnable & 0x03) == 0x03))
            {
                dwRand = RtpRandom32((DWORD_PTR)&bLossIt) & 0xFFFFFF;

                if ((dwRand * 100 / 0xFFFFFF) <= g_RtpReg.dwRecvLossRate)
                {
                    bLossIt = TRUE; 
                }
            }
        }
        else
        {
            /* Sender */
            if (IsRegValueSet(g_RtpReg.dwSendLossRate) &&
                ((g_RtpReg.dwGenLossEnable & 0x30) == 0x30))
            {
                dwRand = RtpRandom32((DWORD_PTR)&bLossIt) & 0xFFFFFF;

                if ((dwRand * 100 / 0xFFFFFF) <= g_RtpReg.dwSendLossRate)
                {
                    bLossIt = TRUE; 
                }
            }
        }
    }

    return(bLossIt);
}
#endif /* USE_GEN_LOSSES > 0 */

void RtpSetRedParametersFromRegistry(void)
{
    DWORD           *dwPtr;
    DWORD            i;
    int              thresh;

    /* Redundancy thresholds */
    if (IsRegValueSet(g_RtpReg.dwRedEnable) &&
        ((g_RtpReg.dwRedEnable & 0x3000) == 0x3000))
    {
        for(dwPtr = &g_RtpReg.dwLossRateThresh0, i = 0;
            i <= RTP_RED_MAXDISTANCE;
            dwPtr++, i++)
        {
            if (IsRegValueSet(*dwPtr))
            {
                /* Low threshold */
                thresh = (int)(*dwPtr & 0xffff);
                if (thresh > 100)
                {
                    thresh = 100;
                }
                g_RtpLossRateThresh[i].LossRateLowThresh =
                    thresh * LOSS_RATE_FACTOR;

                /* High threshold */
                thresh = (int)((*dwPtr >> 16) & 0xffff);
                if (thresh > 100)
                {
                    thresh = 100;
                }
                g_RtpLossRateThresh[i].LossRateHigThresh =
                    thresh * LOSS_RATE_FACTOR;
            }
        }
    }

    /* Early timeout and early post times */
    if (IsRegValueSet(g_RtpReg.dwRedEarlyTimeout) &&
        g_RtpReg.dwRedEarlyTimeout != 0)
    {
        g_dRtpRedEarlyTimeout = (double)g_RtpReg.dwRedEarlyTimeout / 1000;
    }
    if (IsRegValueSet(g_RtpReg.dwRedEarlyPost) &&
        g_RtpReg.dwRedEarlyPost != 0)
    {
        g_dRtpRedEarlyPost = (double)g_RtpReg.dwRedEarlyPost / 1000;
    }

    if (g_dRtpRedEarlyTimeout >= g_dRtpRedEarlyPost)
    {
        g_dRtpRedEarlyPost = g_dRtpRedEarlyTimeout + 5e-3;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\misc\gtypes.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    gtypes.c
 *
 *  Abstract:
 *
 *    Some global strings
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2001/03/09 created
 *
 **********************************************************************/

#include "gtypes.h"

const TCHAR_t *g_psRtpRecvSendStr[] = {
    _T("RECV"),
    _T("SEND")
};

const TCHAR_t *g_psRtpStreamClass[] = {
    _T("UNKNOWN"),
    _T("AUDIO"),
    _T("VIDEO"),
    _T("UNKNOWN"),
    _T("UNKNOWN"),
    _T("UNKNOWN"),
    _T("UNKNOWN"),
    _T("UNKNOWN")
};

const TCHAR_t *g_psGetSet[] = {
    _T("GET"),
    _T("SET")
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\misc\lookup.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    lookup.c
 *
 *  Abstract:
 *
 *    Helper functions to look up SSRCs
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/17 created
 *
 **********************************************************************/

#include "lookup.h"
#include "rtpuser.h"
/*
 * Looks up an SSRC in RtpAddr_t
 *
 * Look first in Cache1Q, if Cache1Q size is bigger than
 * MAX_QUEUE2HASH_ITEMS, then look up directly from Hash, if not found
 * there, check ByeQ, if the item is there, the packet must be
 * discarded as it belongs to a left or stalled participant, if the
 * the participant is indeed alive, it will be created again once its
 * descriptor expires and is removed from ByeQ */
RtpUser_t *LookupSSRC(RtpAddr_t *pRtpAddr, DWORD dwSSRC, BOOL *pbCreate)
{
    HRESULT          hr;
    BOOL             bOk;
    BOOL             bCreate;
    long             lCount;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpUser_t       *pRtpUser;
    
    TraceFunctionName("LookupSSRC");

    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    pRtpUser = (RtpUser_t *)NULL;

    bCreate = *pbCreate;

    *pbCreate = FALSE;
    
    bOk = RtpEnterCriticalSection(&pRtpAddr->PartCritSect);

    if (bOk)
    {
        if (pRtpAddr->Cache1Q.lCount <= MAX_QUEUE2HASH_ITEMS) {
            /* look in Cache1Q */
            pRtpQueueItem = findQdwK(&pRtpAddr->Cache1Q, NULL, dwSSRC);

            if (pRtpQueueItem)
            {
                pRtpUser =
                    CONTAINING_RECORD(pRtpQueueItem, RtpUser_t, UserQItem);
                
                goto end;
            }
        }

        if (!pRtpQueueItem)
        {
            /* look up in ByeQ */
            pRtpQueueItem = findQdwK(&pRtpAddr->ByeQ, NULL, dwSSRC);

            if (pRtpQueueItem)
            {
                /* If in ByeQ, return saying we didn't find it */
                goto end;
            }

            /* look in hash */
            pRtpQueueItem = findHdwK(&pRtpAddr->Hash, NULL, dwSSRC);

            if (pRtpQueueItem)
            {
                pRtpUser =
                    CONTAINING_RECORD(pRtpQueueItem, RtpUser_t, HashItem);

                goto end;
            }
        }

        if (!pRtpQueueItem && bCreate == TRUE)
        {
            /* SSRC not found, create a new one */
            hr = GetRtpUser(pRtpAddr, &pRtpUser, 0);

            if (SUCCEEDED(hr))
            {
                pRtpUser->dwSSRC = dwSSRC;
                pRtpUser->UserQItem.dwKey = dwSSRC;
                pRtpUser->HashItem.dwKey = dwSSRC;

                /* When a user has been created, it is in the CREATED
                 * state (the state initialized during creation), then
                 * it has to be put in the AliveQ and Hash */

                /* Insert in head of AliveQ */
                enqueuef(&pRtpAddr->AliveQ,
                         NULL,
                         &pRtpUser->UserQItem);

                /* Insert in Hash according to its SSRC */
                insertHdwK(&pRtpAddr->Hash,
                           NULL,
                           &pRtpUser->HashItem,
                           dwSSRC);

                /* A new participant is created */
                *pbCreate = TRUE;
                
                TraceDebug((
                        CLASS_INFO,
                        GROUP_USER,
                        S_USER_LOOKUP,
                        _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X"),
                        _fname, pRtpAddr, pRtpUser, ntohl(dwSSRC)
                    ));

                goto end;
            }
        }
    }

 end:
    if (bOk)
    {
        RtpLeaveCriticalSection(&pRtpAddr->PartCritSect);
    }

    return(pRtpUser);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\glob\rtpsess.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpsess.c
 *
 *  Abstract:
 *
 *    Get, Initialize and Delete RTP session (RtpSess_t), RTP address
 *    (RtpAddr_t)
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/02 created
 *
 **********************************************************************/

#include "gtypes.h"
#include "rtpheap.h"
#include "rtpglobs.h"
#include "struct.h"
#include "rtpcrit.h"

#include "rtprtp.h"
#include "rtpqos.h"
#include "rtppinfo.h"
#include "rtcpsdes.h"
#include "rtpncnt.h"
#include "rtpuser.h"
#include "rtpcrypt.h"
#include "rtpaddr.h"
#include "rtpdemux.h"
#include "rtprecv.h"
#include "rtpred.h"

#include "rtpsess.h"

/*
 * Create an RTP session
 * */
HRESULT GetRtpSess(RtpSess_t **ppRtpSess)
{
    HRESULT          hr;
    BOOL             bOk1;
    BOOL             bOk2;
    RtpSess_t       *pRtpSess;
    DWORD            i;
    long             lNumSess;

    TraceFunctionName("GetRtpSess");

    bOk1 = FALSE;
    bOk2 = FALSE;
    pRtpSess = (RtpSess_t *)NULL;
    
    if (!ppRtpSess)
    {
        hr = RTPERR_POINTER;

        goto bail;
    }
    
    *ppRtpSess = (RtpSess_t *)NULL;

    pRtpSess = RtpHeapAlloc(g_pRtpSessHeap, sizeof(RtpSess_t));

    if (!pRtpSess)
    {
        hr = RTPERR_MEMORY;

        goto bail;
    }

    ZeroMemory(pRtpSess, sizeof(RtpSess_t));

    pRtpSess->dwObjectID = OBJECTID_RTPSESS;

    bOk1 = RtpInitializeCriticalSection(&pRtpSess->SessCritSect,
                                        pRtpSess,
                                        _T("SessCritSect"));

    bOk2 = RtpInitializeCriticalSection(&pRtpSess->OutputCritSect,
                                        pRtpSess,
                                        _T("OutputCritSect"));

    if (!bOk1 || !bOk2)
    {
        hr = RTPERR_CRITSECT;
        
        goto bail;
    }

    hr = NOERROR;
    
    /*
     * Create SDES block for this address
     */
    pRtpSess->pRtpSdes = RtcpSdesAlloc();

    if (pRtpSess->pRtpSdes)
    {
        /* Set defaultSDES items */
        pRtpSess->dwSdesPresent = RtcpSdesSetDefault(pRtpSess->pRtpSdes);
    }

    /*
     * Create statistics containers
     * Makes sense if there several addresses per session
     *
    for(i = 0; i < 2; i++) {
        pRtpSess->pRtpSessStat[i] = RtpNetCountAlloc();
    }
    */

    /* Set default features mask */
    pRtpSess->dwFeatureMask = 0; /* NONE YET */

    /* Set default event mask */
    pRtpSess->dwEventMask[RECV_IDX] = RTPRTP_EVENT_RECV_DEFAULT;
    pRtpSess->dwEventMask[SEND_IDX] = RTPRTP_EVENT_SEND_DEFAULT;

    /* Set the default participant events mask */
    pRtpSess->dwPartEventMask[RECV_IDX] = RTPPARINFO_MASK_RECV_DEFAULT;
    pRtpSess->dwPartEventMask[SEND_IDX] = RTPPARINFO_MASK_SEND_DEFAULT;
    
    /* Set default QOS event mask */
    pRtpSess->dwQosEventMask[RECV_IDX] = RTPQOS_MASK_RECV_DEFAULT;
    pRtpSess->dwQosEventMask[SEND_IDX] = RTPQOS_MASK_SEND_DEFAULT;

    /* Set the default SDES events mask */
    pRtpSess->dwSdesEventMask[RECV_IDX] = RTPSDES_EVENT_RECV_DEFAULT;
    pRtpSess->dwSdesEventMask[SEND_IDX] = RTPSDES_EVENT_SEND_DEFAULT;
    
    /* Set default SDES mask */
    pRtpSess->dwSdesMask[LOCAL_IDX]  = RTPSDES_LOCAL_DEFAULT;
    pRtpSess->dwSdesMask[REMOTE_IDX] = RTPSDES_REMOTE_DEFAULT;

    enqueuel(&g_RtpContext.RtpSessQ,
             &g_RtpContext.RtpContextCritSect,
             &pRtpSess->SessQItem);

    lNumSess = InterlockedIncrement(&g_RtpContext.lNumRtpSessions);
    if (lNumSess > g_RtpContext.lMaxNumRtpSessions)
    {
        g_RtpContext.lMaxNumRtpSessions = lNumSess;
    }
    
    /*
     * TODO replace this static single address by a dynamic mechanism
     * where addresses can be added at any time */
    
    /* update returned session */
    *ppRtpSess = pRtpSess;

    TraceRetail((
            CLASS_INFO, GROUP_SETUP, S_SETUP_SESS,
            _T("%s: pRtpSess[0x%p] created"),
            _fname, pRtpSess
        ));

    return(hr);
    
 bail:

    if (bOk1)
    {
        RtpDeleteCriticalSection(&pRtpSess->SessCritSect);
    }

    if (bOk2)
    {
        RtpDeleteCriticalSection(&pRtpSess->OutputCritSect);
    }

    if (pRtpSess)
    {
        RtpHeapFree(g_pRtpSessHeap, pRtpSess);
    }

    TraceRetail((
            CLASS_ERROR, GROUP_SETUP, S_SETUP_SESS,
            _T("%s: failed: %u (0x%X)"),
            _fname, hr, hr
        ));
    
    return(hr);
}

/*
 * Delete an RTP session
 * */
HRESULT DelRtpSess(RtpSess_t *pRtpSess)
{
    DWORD            i;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpOutput_t     *pRtpOutput;
    
    TraceFunctionName("DelRtpSess");

    /* check NULL pointer */
    if (!pRtpSess)
    {
        return(RTPERR_POINTER);
    }

    /* verify object ID */
    if (pRtpSess->dwObjectID != OBJECTID_RTPSESS)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_SETUP, S_SETUP_SESS,
                _T("%s: pRtpSess[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpSess,
                pRtpSess->dwObjectID, OBJECTID_RTPSESS
            ));

        return(RTPERR_INVALIDRTPSESS);
    }

    /* Invalidate object */
    INVALIDATE_OBJECTID(pRtpSess->dwObjectID);
    
    if (pRtpSess->pRtpSdes)
    {
        RtcpSdesFree(pRtpSess->pRtpSdes);
        pRtpSess->pRtpSdes = (RtpSdes_t *)NULL;
    }

    /*
     * Delete session's stats
     * Makes sense if there are several addresses per session
    for(i = 0; i < 2; i++) {
        if (pRtpSess->pRtpSessStat[i]) {
            RtpNetCountFree(pRtpSess->pRtpSessStat[i]);
            pRtpSess->pRtpSessStat[i] = (RtpNetCount_t *)NULL;
        }
    }
    */

    /* Remove all the Outputs */
    do
    {
        pRtpQueueItem = dequeuef(&pRtpSess->OutputQ, NULL);

        if (pRtpQueueItem)
        {
            pRtpOutput =
                CONTAINING_RECORD(pRtpQueueItem, RtpOutput_t, OutputQItem);

            RtpOutputFree(pRtpOutput);
        }
        
    } while(pRtpQueueItem);

    RtpDeleteCriticalSection(&pRtpSess->OutputCritSect);
    
    RtpDeleteCriticalSection(&pRtpSess->SessCritSect);

    dequeue(&g_RtpContext.RtpSessQ,
            &g_RtpContext.RtpContextCritSect,
            &pRtpSess->SessQItem);

    InterlockedDecrement(&g_RtpContext.lNumRtpSessions);
    
    RtpHeapFree(g_pRtpSessHeap, (void *)pRtpSess);
    
    TraceRetail((
            CLASS_INFO, GROUP_SETUP, S_SETUP_SESS,
            _T("%s: pRtpSess[0x%p] deleted"),
            _fname, pRtpSess
        ));
    
    return(NOERROR);
}

/*
 * Create a new RTP address for an existing RtpSess_t
 *
 * Parameter checking is not required as this function is only called
 * internally */
HRESULT GetRtpAddr(
        RtpSess_t  *pRtpSess,
        RtpAddr_t **ppRtpAddr,
        DWORD       dwFlags
    )
{
    HRESULT          hr;
    DWORD            i;
    RtpAddr_t       *pRtpAddr;
    BOOL             bOk1;
    BOOL             bOk2;
    BOOL             bOk3;
    BOOL             bOk4;
    RtpNetSState_t  *pRtpNetSState;
    TCHAR            Name[128];

    TraceFunctionName("GetRtpAddr");

    if (!pRtpSess || !ppRtpAddr)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_SETUP, S_SETUP_ADDR,
                _T("%s: Null pointer"),
                _fname
            ));

        return(E_POINTER);
    }

    /* verify object ID in RtpSess_t */
    if (pRtpSess->dwObjectID != OBJECTID_RTPSESS)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_SETUP, S_SETUP_SESS,
                _T("%s: pRtpSess[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpSess,
                pRtpSess->dwObjectID, OBJECTID_RTPSESS
            ));

        return(RTPERR_INVALIDRTPSESS);
    }
    
    *ppRtpAddr = (RtpAddr_t *)NULL;
    
    pRtpAddr = (RtpAddr_t *) RtpHeapAlloc(g_pRtpAddrHeap, sizeof(RtpAddr_t));

    if (!pRtpAddr)
    {
        /* TODO log error */
        return(E_OUTOFMEMORY);
    }

    ZeroMemory(pRtpAddr, sizeof(RtpAddr_t));
    
    /*
     * Initialize new RtpAddr_t structure
     * */

    hr = NOERROR;
    
    pRtpAddr->dwObjectID = OBJECTID_RTPADDR;
    
    /* RtpAddr_t critical section */
    bOk1 = RtpInitializeCriticalSection(&pRtpAddr->AddrCritSect,
                                        pRtpAddr,
                                        _T("AddrCritSect"));
    
    /* Participants handling critical section */
    bOk2 = RtpInitializeCriticalSection(&pRtpAddr->PartCritSect,
                                        pRtpAddr,
                                        _T("PartCritSect"));
        
    /* Initialize section for Ready/Pending queues */
    bOk3 = RtpInitializeCriticalSection(&pRtpAddr->RecvQueueCritSect,
                                        pRtpAddr,
                                        _T("RecvQueueCritSect"));

    /* Initialize section for RtpNetSState structure */
    bOk4 = RtpInitializeCriticalSection(&pRtpAddr->NetSCritSect,
                                        pRtpAddr,
                                        _T("NetSCritSect"));

    if (!bOk1 || !bOk2 || !bOk3 || !bOk4)
    {
        hr = RTPERR_CRITSECT;
        goto bail;
    }

    /*
     * Create statistics containers (global receiver/sender
     * statistics)
     */
    /*
    for(i = 0; i < 2; i++) {
        pRtpAddr->pRtpAddrStat[i] = RtpNetCountAlloc();
    }
    */
    
    /*
     * Begin Reception only initialization
     */

    /* Create a named event for asynchronous receive completion */
    _stprintf(Name, _T("%X:pRtpAddr[0x%p]->hRecvCompletedEvent"),
              GetCurrentProcessId(), pRtpAddr);
    
    pRtpAddr->hRecvCompletedEvent = CreateEvent(
            NULL,  /* LPSECURITY_ATTRIBUTES lpEventAttributes */
            TRUE,  /* BOOL bManualReset */
            FALSE, /* BOOL bInitialState */
            Name   /* LPCTSTR lpName */
        );

    if (!pRtpAddr->hRecvCompletedEvent)
    {
        hr = RTPERR_EVENT; /* TODO log error */
        goto bail;
    }
    
    /*
     * End Reception only initialization
     */

    /* Allocate RtpQosReserve_t structure if needed */
    if (RtpBitTest(dwFlags, FGADDR_IRTP_QOS))
    {
        pRtpAddr->pRtpQosReserve = RtpQosReserveAlloc(pRtpAddr);

        /* TODO can not have QOS if this allocation fails, report or
         * fail all, right now just continue */
    }

    pRtpAddr->pRtpSess = pRtpSess; /* Set what session owns this address */

    /* Add this address to the session's list of addresses */
    enqueuel(&pRtpSess->RtpAddrQ,
             &pRtpSess->SessCritSect,
             &pRtpAddr->AddrQItem);

    /* Some defaults */

    /* MCast loopback */
    RtpSetMcastLoopback(pRtpAddr, DEFAULT_MCAST_LOOPBACK, NO_FLAGS);
    
    pRtpNetSState = &pRtpAddr->RtpNetSState;
    
    /* Bandwidth */
    pRtpNetSState->dwOutboundBandwidth = DEFAULT_SESSBW / 2;
    pRtpNetSState->dwInboundBandwidth = DEFAULT_SESSBW / 2;
    pRtpNetSState->dwRtcpBwReceivers = DEFAULT_BWRECEIVERS;
    pRtpNetSState->dwRtcpBwSenders = DEFAULT_BWSENDERS;

    /* Minimum RTCP interval report */
    pRtpNetSState->dRtcpMinInterval = DEFAULT_RTCP_MIN_INTERVAL;

    /* Set an invalid payload type */
    pRtpNetSState->bPT = NO_PAYLOADTYPE;
    pRtpNetSState->bPT_Dtmf = NO_PAYLOADTYPE;
    pRtpNetSState->bPT_RedSend = NO_PAYLOADTYPE;
    pRtpAddr->bPT_RedRecv = NO_PAYLOADTYPE;
    
    /* Default weighting factor */
    pRtpAddr->dAlpha = DEFAULT_ALPHA;

    /* Initialize to empty the PT -> Frequency mapping table */
    RtpFlushPt2FrequencyMaps(pRtpAddr, RECV_IDX);

    /* Initialize sockets */
    for(i = 0; i <= SOCK_RTCP_IDX; i++)
    {
        pRtpAddr->Socket[i] = INVALID_SOCKET;
    }
    
    *ppRtpAddr = pRtpAddr;

    TraceRetail((
            CLASS_INFO, GROUP_SETUP, S_SETUP_ADDR,
            _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] created"),
            _fname, pRtpSess, pRtpAddr
        ));
    
    return(hr);

 bail:
    /* fail */
    TraceRetail((
            CLASS_ERROR, GROUP_SETUP, S_SETUP_ADDR,
            _T("%s: pRtpSess[0x%p] failed: %u (0x%X)"),
            _fname, pRtpSess,
            hr, hr
        ));

    DelRtpAddr(pRtpSess, pRtpAddr);
    
    return(hr);
}

/*
 * Delete a RTP address from an existing RtpSess_t
 */
HRESULT DelRtpAddr(
        RtpSess_t *pRtpSess,
        RtpAddr_t *pRtpAddr
    )
{
    RtpQueueItem_t  *pRtpQueueItem;
    RtpRecvIO_t     *pRtpRecvIO;
    DWORD            i;

    TraceFunctionName("DelRtpAddr");

    if (!pRtpSess || !pRtpAddr)
    {
        /* TODO log error */
        return(RTPERR_POINTER);
    }

    /* verify object ID in RtpSess_t */
    if (pRtpSess->dwObjectID != OBJECTID_RTPSESS)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_SETUP, S_SETUP_SESS,
                _T("%s: pRtpSess[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpSess,
                pRtpSess->dwObjectID, OBJECTID_RTPSESS
            ));

        return(RTPERR_INVALIDRTPSESS);
    }
    
    /* verify object ID in RtpAddr_t */
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_SETUP, S_SETUP_SESS,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        return(RTPERR_INVALIDRTPADDR);
    }

    /* Address may not be in queue if we are comming here from a
     * failure in GetRtpAddr(), this would generate another error in
     * the log, but that is OK */
    dequeue(&pRtpSess->RtpAddrQ,
            &pRtpSess->SessCritSect,
            &pRtpAddr->AddrQItem);

    /* The RtpAddr_t might have never been started, and yet the
     * sockets might have been created if the application queried for
     * local ports. By the same token the address will not be stopped,
     * so I need to call RtpDelSockets here. The function will check
     * if sockets really need to be deleted */
    /* destroy sockets */
    RtpDelSockets(pRtpAddr);

    RtpRecvIOFreeAll(pRtpAddr);

    /* Close event to signal reception completed */
    if (pRtpAddr->hRecvCompletedEvent)
    {
        CloseHandle(pRtpAddr->hRecvCompletedEvent);
        pRtpAddr->hRecvCompletedEvent = NULL;
    }

    /* Free statistics containers */
    /*
    for(i = 0; i < 2; i++) {
        if (pRtpAddr->pRtpAddrStat[i]) {
            RtpNetCountFree(pRtpAddr->pRtpAddrStat[i]);
            pRtpAddr->pRtpAddrStat[i] = (RtpNetCount_t *)NULL;
        }
    }
    */
    
    /* QOS */
    if (pRtpAddr->pRtpQosReserve)
    {
        RtpQosReserveFree(pRtpAddr->pRtpQosReserve);
        pRtpAddr->pRtpQosReserve = (RtpQosReserve_t *)NULL;
    }

    /* Cryptography */
    if (pRtpAddr->dwCryptMode)
    {
        RtpCryptCleanup(pRtpAddr);
    }
    
    /* Delete all participants (there shouldn't be any left) */
    DelAllRtpUser(pRtpAddr);

    /* Release redundancy buffers if they were allocated */
    RtpRedFreeBuffs(pRtpAddr);
    
    RtpDeleteCriticalSection(&pRtpAddr->RecvQueueCritSect);

    RtpDeleteCriticalSection(&pRtpAddr->PartCritSect);

    RtpDeleteCriticalSection(&pRtpAddr->AddrCritSect);

    RtpDeleteCriticalSection(&pRtpAddr->NetSCritSect);
    
    /* Invalidate object */
    INVALIDATE_OBJECTID(pRtpAddr->dwObjectID);
    
    RtpHeapFree(g_pRtpAddrHeap, pRtpAddr);

    TraceRetail((
            CLASS_INFO, GROUP_SETUP, S_SETUP_ADDR,
            _T("%s: pRtpSess[0x%p], pRtpAddr[0x%p] deleted"),
            _fname, pRtpSess, pRtpAddr
        ));

    return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\glob\rtpuser.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpuser.c
 *
 *  Abstract:
 *
 *    Creates/initializes/deletes a RtpUser_t structure
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/10/02 created
 *
 **********************************************************************/

#include "rtpglobs.h"
#include "lookup.h"
#include "rtcpsdes.h"
#include "rtpncnt.h"
#include "rtppinfo.h"
#include "struct.h"
#include "rtpdejit.h"
#include "rtprecv.h"
#include "rtpthrd.h"

#include "rtpuser.h"

/*
 * TODO add time this was created, times we last received RTP data and
 * RTCP, time it stalled, time it left */
HRESULT GetRtpUser(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t      **ppRtpUser,
        DWORD            dwFlags
    )
{
    HRESULT          hr;
    BOOL             bError1;
    double           dTime;
    RtpUser_t       *pRtpUser;

    TraceFunctionName("GetRtpUser");
    
    if (!pRtpAddr || !ppRtpUser)
    {
        /* TODO log error */
        return(RTPERR_POINTER);
    }

    *ppRtpUser = (RtpUser_t *)NULL;

    /* verify object ID in RtpAddr_t */
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_USER, S_USER_INIT,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        return(RTPERR_INVALIDRTPADDR);
    }

    /* TODO a separate heap to be used by multicast conferences, and a
     * common heap (this one) for all unicast calls. Right now using
     * the common users heap */
    pRtpUser = (RtpUser_t *) RtpHeapAlloc(g_pRtpUserHeap, sizeof(RtpUser_t));

    if (!pRtpUser)
    {
        /* TODO log error */
        return(RTPERR_MEMORY);
    }

    ZeroMemory(pRtpUser, sizeof(RtpUser_t));
    /*
     * Initialize new RtpUser_t structure
     * */

    hr = NOERROR;
    
    pRtpUser->dwObjectID = OBJECTID_RTPUSER;
    
    /* RtpUser_t critical section */
    bError1 = RtpInitializeCriticalSection(&pRtpUser->UserCritSect,
                                           pRtpUser,
                                           _T("UserCritSect"));

    if (!bError1)
    {
        hr = RTPERR_CRITSECT;
        goto bail;
    }

    /* Time this RtpUser was created */
    dTime = RtpGetTimeOfDay((RtpTime_t *)NULL);
    
    pRtpUser->RtpNetRState.dCreateTime = dTime;
    
    pRtpUser->RtpNetRState.dwPt = NO_PAYLOADTYPE;
    
    /* Add SDES information container */
    /* Do not fail if container can not be allocated */
    pRtpUser->pRtpSdes = RtcpSdesAlloc();

    /* Allocate reception statistics container */
    /* Do not fail if container can not be allocated */
    /*
    pRtpUser->pRtpUserStat = RtpNetCountAlloc();

    if (pRtpUser->pRtpUserStat)
    {
        pRtpUser->pRtpUserStat->dRTCPLastTime = dTime;
    }
    */
    pRtpUser->RtpUserCount.dRTCPLastTime = dTime;
    
    /* Set owner address */
    pRtpUser->pRtpAddr = pRtpAddr;

    /* Set initial state to CREATED, in this state the RtpUser_t
     * structure will be immediatly put in AliveQ and Hash (later
     * during the lookup that produced this creation)
     * */
    pRtpUser->dwUserState = RTPPARINFO_CREATED;

    pRtpUser->RtpNetRState.dMinPlayout = g_dMinPlayout;
    pRtpUser->RtpNetRState.dMaxPlayout = g_dMaxPlayout;

    *ppRtpUser = pRtpUser;
    
    TraceDebug((
            CLASS_INFO,
            GROUP_USER,
            S_USER_LOOKUP,
            _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] New user"),
            _fname, pRtpAddr, pRtpUser
        ));
    
    return(hr);

 bail:

    DelRtpUser(pRtpAddr, pRtpUser);

    return(hr);
}

HRESULT DelRtpUser(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser
    )
{
    HRESULT          hr;
    RtpQueueItem_t  *pRtpQueueItem;

    TraceFunctionName("DelRtpUser");
    
    if (!pRtpAddr || !pRtpUser)
    {
        /* TODO log error */
        return(RTPERR_POINTER);
    }

    /* verify object ID in RtpAddr_t */
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_USER, S_USER_INIT,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        return(RTPERR_INVALIDRTPADDR);
    }
    
    /* verify object ID in RtpUser_t */
    if (pRtpUser->dwObjectID != OBJECTID_RTPUSER)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_USER, S_USER_INIT,
                _T("%s: pRtpUser[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpUser,
                pRtpUser->dwObjectID, OBJECTID_RTPUSER
            ));

        return(RTPERR_INVALIDRTPUSER);
    }

    /* If there is pending IO (items in RecvIOWaitRedQ associated to
     * this user) flush them. This can only happen if we are still
     * receiving, i.e. the RTP reception thread is still running,
     * otherwise we would have already called FlushRtpRecvFrom, and
     * any pending packets had been flushed (i.e. posted with an error
     * code) and hence have ZERO pending packets */
    if (pRtpUser->lPendingPackets > 0)
    {
        RtpThreadFlushUser(pRtpAddr, pRtpUser);
    }
    
    RtpDeleteCriticalSection(&pRtpUser->UserCritSect);

    /* Free SDES information */
    if (pRtpUser->pRtpSdes)
    {
        RtcpSdesFree(pRtpUser->pRtpSdes);

        pRtpUser->pRtpSdes = (RtpSdes_t *)NULL;
    }

    /* Free reception statistics */
    /*
    if (pRtpUser->pRtpUserStat)
    {
        RtpNetCountFree(pRtpUser->pRtpUserStat);

        pRtpUser->pRtpUserStat = (RtpNetCount_t *)NULL;
    }
    */

    /* Invalidate object */
    INVALIDATE_OBJECTID(pRtpUser->dwObjectID);
    
    TraceDebug((
            CLASS_INFO, GROUP_USER, S_USER_INIT,
            _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X Del user"),
            _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC)
        ));
    
    RtpHeapFree(g_pRtpUserHeap, pRtpUser);
    
    return(NOERROR);
}

/* Delete All RTP users, this happens when the RTP session is
 * terminated (RtpRealStop) */
DWORD DelAllRtpUser(RtpAddr_t *pRtpAddr)
{
    BOOL             bOk;
    DWORD            dwCount;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpUser_t       *pRtpUser;

    dwCount = 0;
    
    bOk = RtpEnterCriticalSection(&pRtpAddr->PartCritSect);

    if (bOk)
    {
        /* Remove participants from Cache1Q, Cache2Q, AliveQ, ByeQ and
           Hash */
        do
        {
            pRtpQueueItem = peekH(&pRtpAddr->Hash, NULL);
            
            if (pRtpQueueItem)
            {
                pRtpUser =
                    CONTAINING_RECORD(pRtpQueueItem, RtpUser_t, HashItem);

                /* This function with event DEL will remove the user
                 * from Cache1Q, Cache2Q, AliveQ or ByeQ, and will
                 * also remove it from Hash. After that, will call
                 * DelRtpUser()
                 * */
                RtpUpdateUserState(pRtpAddr, pRtpUser, USER_EVENT_DEL);
                
                dwCount++;
            }
        } while(pRtpQueueItem);

        RtpLeaveCriticalSection(&pRtpAddr->PartCritSect); 
    }

    return(dwCount);
}

/* Makes all the participants appear as if the next packet that will
 * be received were the very first packet ever received, or ever sent
 * */
DWORD ResetAllRtpUser(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwFlags   /* Recv, Send */
    )
{
    BOOL             bOk;
    long             lUsers;
    DWORD            dwCountR;
    DWORD            dwCountS;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpUser_t       *pRtpUser;

    dwCountR = 0;
    dwCountS = 0;
    
    bOk = RtpEnterCriticalSection(&pRtpAddr->PartCritSect);

    if (bOk)
    {
        for(lUsers = GetQueueSize(&pRtpAddr->AliveQ),
                pRtpQueueItem = pRtpAddr->AliveQ.pFirst;
            lUsers > 0 && pRtpQueueItem;
            lUsers--, pRtpQueueItem = pRtpQueueItem->pNext)
        {
            pRtpUser =
                CONTAINING_RECORD(pRtpQueueItem, RtpUser_t, UserQItem);
            
            if (RtpBitTest(dwFlags, RECV_IDX))
            {
                /* Reset receiver. The reset consist in preparing the
                 * participants so when new data arrives, they behave as
                 * if that were the first packet received */

                pRtpUser->RtpNetRState.dwPt = NO_PAYLOADTYPE;
                
                RtpBitReset(pRtpUser->dwUserFlags, FGUSER_FIRST_RTP);
                
                dwCountR++;
            }

            if (RtpBitTest(dwFlags, SEND_IDX))
            {
                /* Reset sender */
                /* NOTHING FOR NOW */
            }
        }

        RtpLeaveCriticalSection(&pRtpAddr->PartCritSect); 
    }

    return( ((dwCountS & 0xffff) << 16) | (dwCountR & 0xffff) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\glob\rtpglobs.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpglobs.c
 *
 *  Abstract:
 *
 *    Global heaps, etc.
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/25 created
 *
 **********************************************************************/

#include "rtptags.h"
#include "struct.h"
#include "rtpglobs.h"

#include <mmsystem.h> /* timeGetTime() */
#include <sys/timeb.h> /* void _ftime( struct _timeb *timeptr ); */

/* Global heaps */

/* Heap used to allocate objects for a source */
RtpHeap_t *g_pRtpSourceHeap = NULL;

/* Heap used to allocate media sample objects for a source */
RtpHeap_t *g_pRtpSampleHeap = NULL;

/* Heap used to allocate objects for a render */
RtpHeap_t *g_pRtpRenderHeap = NULL;

/* Heap used to obtain RtpSess_t structures */
RtpHeap_t *g_pRtpSessHeap = NULL;

/* Heap used to obtain RtpAddr_t structures */
RtpHeap_t *g_pRtpAddrHeap = NULL;

/* Heap used to obtain RtpUser_t structures */
RtpHeap_t *g_pRtpUserHeap = NULL;

/* Heap used to obtain RtpSdes_t structures */
RtpHeap_t *g_pRtpSdesHeap = NULL;

/* Heap used to obtain RtpNetCount_t structures */
RtpHeap_t *g_pRtpNetCountHeap = NULL;

/* Heap used to obtain RtpRecvIO_t structures */
RtpHeap_t *g_pRtpRecvIOHeap = NULL;

/* Heap used to obtain RtpChannelCmd_t structures */
RtpHeap_t *g_pRtpChannelCmdHeap = NULL;

/* Heap used to obtain RtcpAddrDesc_t structures */
RtpHeap_t *g_pRtcpAddrDescHeap = NULL;

/* Heap used to obtain RtcpRecvIO_t structures */
RtpHeap_t *g_pRtcpRecvIOHeap = NULL;

/* Heap used to obtain RtcpSendIO_t structures */
RtpHeap_t *g_pRtcpSendIOHeap = NULL;

/* Heap used to obtain RtpQosReserve_t structures */
RtpHeap_t *g_pRtpQosReserveHeap = NULL;

/* Heap used to obtain RtpQosNotify_t structures */
RtpHeap_t *g_pRtpQosNotifyHeap = NULL;

/* Heap used to obtain buffers used by QOS/RSVPSP */
RtpHeap_t *g_pRtpQosBufferHeap = NULL;

/* Heap used to obtain RtpCrypt_t structures */
RtpHeap_t *g_pRtpCryptHeap = NULL;

/* Heap used to obtain variable size structures structures */
RtpHeap_t *g_pRtpGlobalHeap = NULL;

/* Contains some general information */
RtpContext_t g_RtpContext;

typedef struct _RtpGlobalheapArray_t
{
    RtpHeap_t      **ppRtpHeap;
    BYTE             bTag;
    DWORD            dwSize;
} RtpGlobalHeapArray_t;

const RtpGlobalHeapArray_t g_RtpGlobalHeapArray[] =
{
    {&g_pRtpSourceHeap,     TAGHEAP_RTPSOURCE,    0},
    {&g_pRtpSampleHeap,     TAGHEAP_RTPSAMPLE,    0},
    {&g_pRtpRenderHeap,     TAGHEAP_RTPRENDER,    0},
    {&g_pRtpSessHeap,       TAGHEAP_RTPSESS,      sizeof(RtpSess_t)},
    {&g_pRtpAddrHeap,       TAGHEAP_RTPADDR,      sizeof(RtpAddr_t)},
    {&g_pRtpUserHeap,       TAGHEAP_RTPUSER,      sizeof(RtpUser_t)},
    {&g_pRtpSdesHeap,       TAGHEAP_RTPSDES,      sizeof(RtpSdes_t)},
    {&g_pRtpNetCountHeap,   TAGHEAP_RTPNETCOUNT,  sizeof(RtpNetCount_t)},
    {&g_pRtpRecvIOHeap,     TAGHEAP_RTPRECVIO,    sizeof(RtpRecvIO_t)},
    {&g_pRtpChannelCmdHeap, TAGHEAP_RTPCHANCMD,   sizeof(RtpChannelCmd_t)},
    {&g_pRtcpAddrDescHeap,  TAGHEAP_RTCPADDRDESC, sizeof(RtcpAddrDesc_t)},
    {&g_pRtcpRecvIOHeap,    TAGHEAP_RTCPRECVIO,   sizeof(RtcpRecvIO_t)},
    {&g_pRtcpSendIOHeap,    TAGHEAP_RTCPSENDIO,   sizeof(RtcpSendIO_t)},
    {&g_pRtpQosReserveHeap, TAGHEAP_RTPRESERVE,   sizeof(RtpQosReserve_t)},
    {&g_pRtpQosNotifyHeap,  TAGHEAP_RTPNOTIFY,    sizeof(RtpQosNotify_t)},
    {&g_pRtpQosBufferHeap,  TAGHEAP_RTPQOSBUFFER, 0},
    {&g_pRtpCryptHeap,      TAGHEAP_RTPCRYPT,     sizeof(RtpCrypt_t)},
    {&g_pRtpGlobalHeap,     TAGHEAP_RTPGLOBAL,    0},
    {NULL,                  0,                    0}
};

/*
 * Creates all the global heaps
 *
 * Return TRUE on success, and destroy all created heaps and return
 * FALSE on failure */
BOOL RtpCreateGlobHeaps(void)
{
    int              i;
    
    TraceFunctionName("RtpCreateGlobHeaps");

    for(i = 0; g_RtpGlobalHeapArray[i].ppRtpHeap; i++)
    {
        if (*g_RtpGlobalHeapArray[i].ppRtpHeap)
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_RTP, S_RTP_INIT,
                    _T("%s: pRtpHeap[0x%p] %s appears to be initialized"),
                    _fname, *g_RtpGlobalHeapArray[i].ppRtpHeap, g_psRtpTags[i]
                ));

            /* Heap appears to be already initialized, destroy it */
            RtpHeapDestroy(*g_RtpGlobalHeapArray[i].ppRtpHeap);
        }

        /* Create heap */
        *g_RtpGlobalHeapArray[i].ppRtpHeap = 
            RtpHeapCreate(g_RtpGlobalHeapArray[i].bTag,
                          g_RtpGlobalHeapArray[i].dwSize);

        if (!*g_RtpGlobalHeapArray[i].ppRtpHeap)
        {
            goto bail;
        }
    }

    return(TRUE);

 bail:
    RtpDestroyGlobHeaps();
    
    return(FALSE);
}

/*
 * Destroys all the global heaps */
BOOL RtpDestroyGlobHeaps(void)
{
    int              i;
    
    for(i = 0; g_RtpGlobalHeapArray[i].ppRtpHeap; i++)
    {
        if (*g_RtpGlobalHeapArray[i].ppRtpHeap)
        {
            RtpHeapDestroy(*g_RtpGlobalHeapArray[i].ppRtpHeap);
            
            *g_RtpGlobalHeapArray[i].ppRtpHeap = NULL;
        }
    }
    
    return(TRUE);
}

HRESULT RtpInit(void)
{
    BOOL             bStatus;
    HRESULT          hr;

    TraceFunctionName("RtpInit");

    g_RtpContext.dwObjectID = OBJECTID_RTPCONTEXT;
    
    bStatus =
        RtpInitializeCriticalSection(&g_RtpContext.RtpContextCritSect,
                                     (void *)&g_RtpContext,
                                     _T("RtpContextCritSect"));

    hr = NOERROR;
    
    if (!bStatus)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTP, S_RTP_INIT,
                _T("%s: pRtpContext[0x%p] critical section ")
                _T("failed to initialize"),
                _fname, &g_RtpContext
            ));

        hr = RTPERR_CRITSECT;
    }

    return(hr);
}

HRESULT RtpDelete(void)
{
    HRESULT          hr;

    TraceFunctionName("RtpDelete");

    hr = NOERROR;

    /* RtpContext de-initialization */
    RtpDeleteCriticalSection(&g_RtpContext.RtpContextCritSect);

    INVALIDATE_OBJECTID(g_RtpContext.dwObjectID);
        
    return(hr);
}

/* Init reference time */
void RtpInitReferenceTime(void)
{
    struct _timeb    timeb;
    SYSTEM_INFO      si;
    
    /* NOTE This should be in RtpInit(), but RtpInit needs the
     * debugger to be already initialized and the latter in turn needs
     * the reference time also to be already initialized, which will
     * use variables from g_RtpContex, and to avoid adding one more
     * function just to zero that structure, I moved the zeroing here
     * */
    /* Initialize RtpContext */
    ZeroMemory(&g_RtpContext, sizeof(g_RtpContext));

    GetSystemInfo(&si);
    
    if (si.dwNumberOfProcessors == 1)
    {
        /* NOTE The fact that having multiprocessor makes the
         * performance counter to be unreliable (in some machines)
         * unless I set the processor affinity, which I can not
         * because any thread can request the time, so use it only on
         * uniprocessor machines */
        /* MAYDO Would be nice to enable this also in multiprocessor
         * machines, if I could specify what procesor's performance
         * counter to read or if I had a processor independent
         * performance counter */
        QueryPerformanceFrequency((LARGE_INTEGER *)&
                                  g_RtpContext.lPerfFrequency);
    }

    _ftime(&timeb);
    
    if (g_RtpContext.lPerfFrequency)
    {
        QueryPerformanceCounter((LARGE_INTEGER *)&g_RtpContext.lRtpRefTime);
    }
    else
    {
        g_RtpContext.dwRtpRefTime = timeGetTime();
    }
    
    g_RtpContext.dRtpRefTime = timeb.time + (double)timeb.millitm/1000.0;
}

LONGLONG RtpGetTime(void)
{
    DWORD            dwCurTime;
    LONGLONG         lCurTime;
    LONGLONG         lTime;

    if (g_RtpContext.lPerfFrequency)
    {
        QueryPerformanceCounter((LARGE_INTEGER *)&lTime);

        lCurTime =  lTime - g_RtpContext.lRtpRefTime;
        
        /* NOTE: There is a chance for this variable to be corrupted, but
         * it is not used but kept only to know, while debugging, what was
         * the last time this function was called */
        g_RtpContext.lRtpCurTime = lCurTime;
    }
    else
    {
        dwCurTime = timeGetTime() - g_RtpContext.dwRtpRefTime;
        
        /* NOTE: There is a chance for this variable to be corrupted, but
         * it is not used but kept only to know, while debugging, what was
         * the last time this function was called */
        g_RtpContext.dwRtpCurTime = dwCurTime;

        lCurTime = dwCurTime;
    }

    return(lCurTime);
}

double RtpGetTimeOfDay(RtpTime_t *pRtpTime)
{
    DWORD            dwCurTime;
    LONGLONG         lCurTime;
    double           dTime;
    LONGLONG         lTime;

    if (g_RtpContext.lPerfFrequency)
    {
        QueryPerformanceCounter((LARGE_INTEGER *)&lTime);

        lCurTime = lTime - g_RtpContext.lRtpRefTime;

        dTime = g_RtpContext.dRtpRefTime +
            (double) lCurTime / g_RtpContext.lPerfFrequency;

        g_RtpContext.lRtpCurTime = lCurTime;
    }
    else
    {
        dwCurTime = timeGetTime() - g_RtpContext.dwRtpRefTime;
        
        dTime = g_RtpContext.dRtpRefTime +
            (double) dwCurTime / 1000.0;
        
        g_RtpContext.dwRtpCurTime = dwCurTime;
    }

    if (pRtpTime)
    {
        /* Seconds */
        pRtpTime->dwSecs = (DWORD)dTime;

        /* Micro seconds */
        pRtpTime->dwUSecs = (DWORD)
            ( (dTime - (double)pRtpTime->dwSecs) * 1000000.0 );
    }

    return(dTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\misc\rtpcrit.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpcrit.c
 *
 *  Abstract:
 *
 *    Wrap for the Rtl critical sections
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/25 created
 *
 **********************************************************************/

#include "gtypes.h"

#include "rtpcrit.h"

BOOL RtpInitializeCriticalSection(
        RtpCritSect_t   *pRtpCritSect,
        void            *pvOwner,
        TCHAR           *pName
    )
{
    DWORD            SpinCount;
    
    TraceFunctionName("RtpInitializeCriticalSection");

    if (pvOwner &&
        pRtpCritSect->dwObjectID != OBJECTID_RTPCRITSECT)
    {
        pRtpCritSect->pvOwner = pvOwner;

        pRtpCritSect->pName = pName;

        /* Set bit 31 to 1 to preallocate the event object, and set
         * the spin count that is used in multiprocessor environments
         * */
        SpinCount = 0x80000000 | 1000;
        
        if (!InitializeCriticalSectionAndSpinCount(&pRtpCritSect->CritSect,
                                                   SpinCount))
        {
            /* if the initialization fails, set pvOwner to NULL */
            pRtpCritSect->pvOwner = NULL;

            return (FALSE);
        }

        pRtpCritSect->dwObjectID = OBJECTID_RTPCRITSECT;
        
        return(TRUE);
    }
    else
    {
        if (!pvOwner)
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_CRITSECT, S_CRITSECT_INIT,
                    _T("%s: pRtpCritSect[0x%p] Invalid argument"),
                    _fname, pRtpCritSect
                ));
        }

        if (pRtpCritSect->dwObjectID == OBJECTID_RTPCRITSECT)
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_CRITSECT, S_CRITSECT_INIT,
                    _T("%s: pRtpCritSect[0x%p] seems to be initialized"),
                    _fname, pRtpCritSect
                ));
        }
    }
    
    return(FALSE);
}

BOOL RtpDeleteCriticalSection(RtpCritSect_t *pRtpCritSect)
{
    TraceFunctionName("RtpDeleteCriticalSection");

    if (pRtpCritSect->pvOwner &&
        pRtpCritSect->dwObjectID == OBJECTID_RTPCRITSECT)
    {
        /* Invalidate object */
        INVALIDATE_OBJECTID(pRtpCritSect->dwObjectID);

        DeleteCriticalSection(&pRtpCritSect->CritSect);
    }
    else
    {
        if (!pRtpCritSect->pvOwner)
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_CRITSECT, S_CRITSECT_INIT,
                    _T("%s: pRtpCritSect[0x%p] not initialized"),
                    _fname, pRtpCritSect
                ));
        }

        if (pRtpCritSect->dwObjectID != OBJECTID_RTPCRITSECT)
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_CRITSECT, S_CRITSECT_INIT,
                    _T("%s: pRtpCritSect[0x%p] Invalid object ID 0x%X != 0x%X"),
                    _fname, pRtpCritSect,
                    pRtpCritSect->dwObjectID, OBJECTID_RTPCRITSECT
                ));
        }

        return(FALSE);
    }

    return(TRUE);
}

BOOL RtpEnterCriticalSection(RtpCritSect_t *pRtpCritSect)
{
    BOOL             bOk;
    
    TraceFunctionName("RtpEnterCriticalSection");

    if (pRtpCritSect->pvOwner &&
        pRtpCritSect->dwObjectID == OBJECTID_RTPCRITSECT)
    {
        EnterCriticalSection(&pRtpCritSect->CritSect);

        bOk = TRUE;
    }
    else
    {
        bOk = FALSE;

        if (!pRtpCritSect->pvOwner)
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_CRITSECT, S_CRITSECT_ENTER,
                    _T("%s: pRtpCritSect[0x%p] not initialized"),
                    _fname, pRtpCritSect
                ));
        }

        if (pRtpCritSect->dwObjectID != OBJECTID_RTPCRITSECT)
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_CRITSECT, S_CRITSECT_ENTER,
                    _T("%s: pRtpCritSect[0x%p] Invalid object ID 0x%X != 0x%X"),
                    _fname, pRtpCritSect,
                    pRtpCritSect->dwObjectID, OBJECTID_RTPCRITSECT
                ));
        }
    }

    return(bOk);
}

BOOL RtpLeaveCriticalSection(RtpCritSect_t *pRtpCritSect)
{
    BOOL             bOk;

    TraceFunctionName("RtpLeaveCriticalSection");

    if (pRtpCritSect->pvOwner &&
        pRtpCritSect->dwObjectID == OBJECTID_RTPCRITSECT)
    {
        LeaveCriticalSection(&pRtpCritSect->CritSect);

        bOk = TRUE;
    }
    else
    {
        bOk = FALSE;

        if (!pRtpCritSect->pvOwner)
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_CRITSECT, S_CRITSECT_ENTER,
                    _T("%s: pRtpCritSect[0x%p] not initialized"),
                    _fname, pRtpCritSect
                ));
        }

        if (pRtpCritSect->dwObjectID != OBJECTID_RTPCRITSECT)
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_CRITSECT, S_CRITSECT_ENTER,
                    _T("%s: pRtpCritSect[0x%p] Invalid object ID 0x%X != 0x%X"),
                    _fname, pRtpCritSect,
                    pRtpCritSect->dwObjectID, OBJECTID_RTPCRITSECT
                ));
        }
    }

    return(bOk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\misc\rtpdbg.c ===
#include "gtypes.h"

#include <stdarg.h>
#include <rtutils.h>
#include <stdio.h>
#include <stdlib.h>

#include "rtpglobs.h"

#define USE_TRACING_FILE 0

#if DBG > 0
const char          *rcs_rtpdbg="RTC RTP/RTCP stack chk 2001/08/09";
const BOOL           g_bRtpIsDbg = TRUE;
#else
const char          *rcs_rtpdbg="RTC RTP/RTCP stack fre 2001/08/09";
const BOOL           g_bRtpIsDbg = FALSE;
#endif

void RtpDebugReadRegistry(RtpDbgReg_t *pRtpDbgReg);

void MSRtpTrace(
        TCHAR           *lpszFormat,
                         ...
    );

void MSRtpTraceInternal(
        TCHAR           *psClass,
        DWORD            dwMask,
        TCHAR           *lpszFormat,
        va_list          arglist
    );

#if USE_TRACING_FILE > 0
FILE            *g_dwRtpDbgTraceID = NULL;
#else
DWORD            g_dwRtpDbgTraceID = INVALID_TRACEID;
#endif

#define MAXDEBUGSTRINGLENGTH   512
#define RTPDBG_ROOTKEY         HKEY_LOCAL_MACHINE
#define RTPDBG_ROOTPATH        _T("SOFTWARE\\Microsoft\\Tracing\\")
#define RTPDBG_OPENKEYFLAGS    KEY_ALL_ACCESS
#define RTPDBG_OPENREADONLY    KEY_READ

/*
      3                   2                   1                 
    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |O|C|           | Path  |   |Class|E|   |       Offset          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    v v \----v----/ \--v--/ \v/ \-v-/ v \v/ \----------v----------/
    | |      |         |     |    |   |  |             |
    | |      |         |     |    |   |  |            Offset (12)
    | |      |         |     |    |   |  |
    | |      |         |     |    |   |  Unused (2)
    | |      |         |     |    |   |
    | |      |         |     |    |   This is a class (1)
    | |      |         |     |    |
    | |      |         |     |   Class (3)
    | |      |         |     |
    | |      |         |    Unused (2) 
    | |      |         |
    | |      |        Registry path index (4)
    | |      |
    | |     Unused (6)
    | |
    | Registry Close flag (1)
    |
    Registry Open flag (1)
*/
/*
 * Encoding macros
 */
/* Offset to field */
#define OFF(_f) ( (DWORD) ((ULONG_PTR) &((RtpDbgReg_t *)0)->_f) )

/* REG(RegOpen flag, key path, RegClose flag) */
#define REG(_fo, _p, _fc) (((_fo) << 31) | ((_fc) << 30) | ((_p) << 20))

/* CLASS(Class, Enable) */
#define CLASS(_C, _E)     (((_C) << 15) | ((_E) << 14))

/* ENTRY(REG, Class, Offset) */
#define ENTRY(_r, _c, _o) ((_r) | (_c) | (_o))
/*
 * Decoding macros
 * */
#define REGOPEN(_ctrl)    (RtpBitTest(_ctrl, 31))
#define REGCLOSE(_ctrl)   (RtpBitTest(_ctrl, 30))
#define REGPATH(_ctrl)    g_psRtpDbgRegPath[((_ctrl >> 20) & 0xf)]
#define REGOFFSET(_ctrl)  (_ctrl & 0xfff)
#define REGISCLASS(_ctrl) (RtpBitTest(_ctrl, 14))
#define REGCLASS(_ctrl)   (((_ctrl) >> 15) & 0x7)

#define PDW(_ptr, _ctrl)  ((DWORD  *) ((char *)_ptr + REGOFFSET(_ctrl)))

/* Class name as printed in log */
const TCHAR_t   *g_psRtpDbgClass[] = {
    _T("NONE "),
    _T("ERROR"),
    _T("WARN "),
    _T("INFO "),
    _T("INFO2"),
    _T("INFO3"),
    NULL
};

/* Sockets' name */
const TCHAR_t   *g_psSockIdx[] = {
    _T("RTP RECV"),
    _T("RTP SEND"),
    _T("RTCP")
};

/* Module name, e.g. dxmrtp.dll */
TCHAR            g_sRtpDbgModule[16];

/* Registry module name, e.g. dxmrtp */
TCHAR            g_sRtpDbgModuleNameID[16];

/* Complementary path (added to base path+ModuleNameID */
const TCHAR     *g_psRtpDbgRegPath[] =
{
    _T(""),
    _T("\\AdvancedTracing"),
    _T("\\AdvancedTracing\\Group"),
    NULL
};

/*
 * WARNING
 *
 * Modifying CLASSES needs to keep matched the enum CLASS_*
 * (rtpdbg.h), the variables in RtpDbgReg_t (rtpdbg.h), the class
 * items in g_psRtpDbgInfo (rtpdbg.c) and its respective entries
 * g_dwRtpDbgRegCtrl (rtpdbg.c), as well as the printed class name
 * g_psRtpDbgClass (rtpdbg.c).
 *
 * For each entry in g_psRtpDbgInfo, there MUST be an entry in
 * g_dwRtpDbgRegCtrl in the same position.
 * */

/* DWORD values read that are stored */
const TCHAR     *g_psRtpDbgInfo[] =
{
    _T("AdvancedOptions"),
    _T("EnableFileTracing"),
    _T("EnableConsoleTracing"),
    _T("EnableDebuggerTracing"),
    _T("ConsoleTracingMask"),
    _T("FileTracingMask"),   
    _T("UseAdvancedTracing"),

    _T("ERROR"),
    _T("WARNING"),
    _T("INFO"),
    _T("INFO2"),
    _T("INFO3"),

    _T("DisableClass"),
    _T("DisableGroup"),

    _T("Setup"),
    _T("CritSect"),
    _T("Heap"),
    _T("Queue"),
    _T("RTP"),
    _T("RTCP"),
    _T("Channel"),
    _T("Network"),
    _T("AddrDesc"),
    _T("Demux"),
    _T("User"),
    _T("DShow"),
    _T("QOS"),
    _T("Crypto"),
    
    NULL
};

/* Control words */
const DWORD g_dwRtpDbgRegCtrl[] =
{
    /* ENTRY(REG(Open,Path,Close), CLASS(Class,Enable), Offset) */
    
    /* ...\Tracing\dxmrtp */
    ENTRY(REG(1,0,0), CLASS(0            , 0), OFF(dwAdvancedOptions)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwEnableFileTracing)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwEnableConsoleTracing)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwEnableDebuggerTracing)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwConsoleTracingMask)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwFileTracingMask)),
    ENTRY(REG(0,0,1), CLASS(0            , 0), OFF(dwUseAdvancedTracing)),

    /* ...\Tracing\dxmrtp\AdvancedTracing */
    ENTRY(REG(1,1,0), CLASS(CLASS_ERROR  , 1), OFF(dwERROR)),
    ENTRY(REG(1,0,0), CLASS(CLASS_WARNING, 1), OFF(dwWARNING)),
    ENTRY(REG(1,0,0), CLASS(CLASS_INFO   , 1), OFF(dwINFO)),
    ENTRY(REG(1,0,0), CLASS(CLASS_INFO2  , 1), OFF(dwINFO2)),
    ENTRY(REG(1,0,0), CLASS(CLASS_INFO3  , 1), OFF(dwINFO3)),
    ENTRY(REG(1,0,0), CLASS(0            , 0), OFF(dwDisableClass)),
    ENTRY(REG(1,0,1), CLASS(0            , 0), OFF(dwDisableGroup)),

    /* ...\Tracing\dxmrtp\AdvancedTracing\Group */
    ENTRY(REG(1,2,0), CLASS(0            , 0), OFF(dwSetup)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwCritSect)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwHeap)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwQueue)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwRTP)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwRTCP)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwChannel)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwNetwork)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwAddrDesc)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwDemux)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwUser)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwDShow)),
    ENTRY(REG(0,0,0), CLASS(0            , 0), OFF(dwQOS)),
    ENTRY(REG(0,0,1), CLASS(0            , 0), OFF(dwCrypto)),

    /* End */
    0
};

RtpDbgReg_t      g_RtpDbgReg;

void MSRtpTraceDebug(
        IN DWORD         dwClass,
        IN DWORD         dwGroup,
        IN DWORD         dwSelection,
        IN TCHAR        *lpszFormat,
        IN               ...
    )
{
    BOOL             bOk;
    DWORD            dwMask;
    va_list          arglist;

    /* Allow the class not be specified (e.g. when we want to enable
     * log only based on group and selection) */
    if (dwClass >= CLASS_LAST)
    {
        return;
    }

    /* If the group is not specified, only the class will be take
     * effect (i.e. the selection will be ignored when the group is
     * not specified , i.e. group=0) */
    if (dwGroup >= GROUP_LAST)
    {
        return;
    }

#if USE_TRACING_FILE > 0
    if ((!g_dwRtpDbgTraceID) &&
        !g_RtpDbgReg.dwEnableDebuggerTracing)
    {
        /* FileTracing could be enabled but TraceRegister failed, so
         * for file I check against the TraceID instead */
        goto end;
    }
#else
    if ((g_dwRtpDbgTraceID == INVALID_TRACEID) &&
        !g_RtpDbgReg.dwEnableDebuggerTracing)
    {
        /* FileTracing could be enabled but TraceRegister failed, so
         * for file I check against the TraceID instead */
        goto end;
    }
#endif
    
    /* Decide if debug output is going to be generated */

    if (IsAdvancedTracingUsed())
    {
        /* Ignore current tracing registry masks */

        if (g_RtpDbgReg.dwGroupArray2[dwGroup] & dwSelection & 0x00ffffff)
        {
            /* Exclude this from tracing */
            goto end;
        }
        
        if (g_RtpDbgReg.dwGroupArray[dwGroup] &
            ( (1 << (dwClass + 24)) | (dwSelection & 0x00ffffff) ) )
        {
            dwMask = TRACE_NO_STDINFO;
        }
        else
        {
            goto end;
        }
    }
    else
    {
        /* Control is done by using ONLY the class, mapping them to
         * bits 16 to 23 (up to 7 classes) in the mask passed,
         * e.g. CLASS_ERROR goes to bit 17 */
        if (dwClass > CLASS_FIRST)
        {
            dwMask = 1 << (dwClass + 16);
            
            if (dwMask & g_RtpDbgReg.dwFileTracingMask)
            {
                dwMask |= TRACE_NO_STDINFO | TRACE_USE_MASK;
            }
            else
            {
                goto end;
            }
        }
        else
        {
            goto end;
        }
    }

    va_start(arglist, lpszFormat);

    MSRtpTraceInternal((TCHAR *)g_psRtpDbgClass[dwClass],
                       dwMask,
                       lpszFormat,
                       arglist);

    va_end(arglist);

 end:
    if ((dwClass == CLASS_ERROR) &&
        (IsSetDebugOption(OPTDBG_BREAKONERROR)))
    {
        DebugBreak();
    }
}

/* This debug output will be controlled only by the
 * EnableFileTracing and EnableDebuggerTracing flags. */
void MSRtpTrace(
        TCHAR           *lpszFormat,
                         ...
    )
{
    va_list          arglist;

    va_start(arglist, lpszFormat);

    MSRtpTraceInternal((TCHAR *)g_psRtpDbgClass[CLASS_FIRST],
                       0xffff0000 | TRACE_NO_STDINFO ,
                       lpszFormat,
                       arglist);
    
    va_end(arglist);
}


void MSRtpTraceInternal(
        TCHAR           *psClass,
        DWORD            dwMask,
        TCHAR           *lpszFormat,
        va_list          arglist
    )
{
    SYSTEMTIME       SystemTime;
    char             sRtpDbgBuff[MAXDEBUGSTRINGLENGTH];
    TCHAR            sFormat[MAXDEBUGSTRINGLENGTH];
    int              len;

    double           dBeginTrace;
    
    TraceFunctionName("MSRtpTraceInternal");  
   
    if (IsSetDebugOption(OPTDBG_SPLITTIME))
    {
        /* retrieve local time */
        GetLocalTime(&SystemTime);

        len = sprintf(sRtpDbgBuff, "%02u:%02u:%02u.%03u ",
                      SystemTime.wHour,
                      SystemTime.wMinute,
                      SystemTime.wSecond,
                      SystemTime.wMilliseconds);
    }
    else
    {
        len = sprintf(sRtpDbgBuff,"%0.6f ",RtpGetTimeOfDay((RtpTime_t *)NULL));
    }

    _vsntprintf(sFormat, MAXDEBUGSTRINGLENGTH-1, lpszFormat, arglist);
    sFormat[MAXDEBUGSTRINGLENGTH-1] = 0;

    /* The output to file needs CR, LF (0xd, 0xa), otherwise notepad
     * will display a single long line, all the other editors are fine
     * with just LF */
    
#if defined(UNICODE)
    sprintf(&sRtpDbgBuff[len],
            "%hs %3X %3X %ls %ls%c%c",
            (char *)g_sRtpDbgModuleNameID,
            GetCurrentProcessId(),
            GetCurrentThreadId(),
            psClass,
            sFormat,
            0xd, 0xa);
#else
    sprintf(&sRtpDbgBuff[len],
            "%s %3X %3X %s %s%c%c",
            g_sRtpDbgModuleNameID,
            GetCurrentProcessId(),
            GetCurrentThreadId(),
            psClass,
            sFormat,
            0xd, 0xa);
#endif

    if (g_RtpDbgReg.dwEnableDebuggerTracing)
    {
        OutputDebugStringA(sRtpDbgBuff);
    }

#if USE_TRACING_FILE > 0
    if(g_dwRtpDbgTraceID)
    {
        dBeginTrace = RtpGetTimeOfDay(NULL);

        fputs(sRtpDbgBuff, g_dwRtpDbgTraceID);

        dBeginTrace = RtpGetTimeOfDay(NULL) - dBeginTrace;

        if (dBeginTrace > 0.1)
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                    _T("%s: fputs took %0.3f seconds for: %hs"),
                    _fname, dBeginTrace, sRtpDbgBuff
                ));
        }
    }
#else
    if (g_dwRtpDbgTraceID != INVALID_TRACEID)
    {
        dBeginTrace = RtpGetTimeOfDay(NULL);

        /* Actually either file OR console tracing */
        TracePutsExA(g_dwRtpDbgTraceID, dwMask, sRtpDbgBuff);

        dBeginTrace = RtpGetTimeOfDay(NULL) - dBeginTrace;

        if (dBeginTrace > 0.1)
        {
            TraceDebug((
                    CLASS_ERROR, GROUP_DSHOW, S_DSHOW_CIRTP,
                    _T("%s: TracePutsExA took %0.3f seconds for: %hs"),
                    _fname, dBeginTrace, sRtpDbgBuff
                ));
        }
    }
#endif
}

HRESULT RtpDebugInit(TCHAR *psModuleName)
{
    BOOL             bOk;
    DWORD            dwMask;
    DWORD            dwError;
    TCHAR            sRtpDbgBuff[MAXDEBUGSTRINGLENGTH];

    /* Copy module name */
    lstrcpyn(g_sRtpDbgModuleNameID,
             psModuleName,
             sizeof(g_sRtpDbgModuleNameID)/sizeof(TCHAR));

    /* Read Advanced registry entries */
    RtpDebugReadRegistry(&g_RtpDbgReg);
    
    if (!g_RtpDbgReg.dwEnableFileTracing &&
        !g_RtpDbgReg.dwEnableDebuggerTracing)
    {
        /* If tracing is not enabled, don't even bother with more
         * initialization */
        return(NOERROR);
    }

    /* Register tracing using a modified name, e.g. dxmrtp_rtp */
    if (g_RtpDbgReg.dwEnableFileTracing)
    {
#if USE_TRACING_FILE > 0
        g_dwRtpDbgTraceID = fopen("c:\\tracing\\dxmrtp_rtp.log", "a+");
        
        if (!g_dwRtpDbgTraceID)
        {
            dwError = GetLastError();

            if (!g_RtpDbgReg.dwEnableDebuggerTracing)
            {
                return(RTPERR_FAIL);
            }
            else
            {
                /* Otherwise continue as debugger output is enabled */
            }
        }
#else
        g_dwRtpDbgTraceID = TraceRegister(g_sRtpDbgModuleNameID);

        if (g_dwRtpDbgTraceID == INVALID_TRACEID)
        {
            dwError = GetLastError();

            
            if (!g_RtpDbgReg.dwEnableDebuggerTracing)
            {
                return(RTPERR_FAIL);
            }
            else
            {
                /* Otherwise continue as debugger output is enabled */
            }
        }
#endif
    }
    
    /* This debug output will be controlled only by the
     * EnableFileTracing and EnableDebuggerTracing flags. */
    if (IsAdvancedTracingUsed())
    {
        dwMask = (g_RtpDbgReg.dwSetup >> 24) & 0xff;
    }
    else
    {
        dwMask = (g_RtpDbgReg.dwFileTracingMask >> 16) & 0xffff;
    }

    MSRtpTrace(_T("+=+=+=+=+=+=+= Initialize ")
               _T("0x%04X 0x%08X %u %hs ")
               _T("=+=+=+=+=+=+=+"),
               dwMask,
               g_RtpDbgReg.dwAdvancedOptions,
               g_RtpDbgReg.dwUseAdvancedTracing,
               rcs_rtpdbg
        );

    return(NOERROR);
}

HRESULT RtpDebugDeinit(void)
{
#if USE_TRACING_FILE > 0
    if (g_dwRtpDbgTraceID)
    {
        fclose(g_dwRtpDbgTraceID);
    }
#else
    /* Deregister tracing */
    if (g_dwRtpDbgTraceID != INVALID_TRACEID)
    {
        /* This will be a one time leak, which is of no consequence
         * when we are about to unload the DLL */
        TraceDeregister(g_dwRtpDbgTraceID);
        g_dwRtpDbgTraceID = INVALID_TRACEID;
    }
#endif
    return(NOERROR);
}

void RtpDebugReadRegistry(RtpDbgReg_t *pRtpDbgReg)
{
    DWORD            dwError;
    HKEY             hk;
    unsigned long    hkDataType;
    BYTE             hkData[64*sizeof(TCHAR_t)];
    TCHAR            sPath[64];
    unsigned long    hkDataSize;
    DWORD            i;
    DWORD            dwControl;
    DWORD            dwClassMask;

    /* Initialize structure */
    ZeroMemory(&g_RtpDbgReg, sizeof(g_RtpDbgReg));

    dwClassMask = 0;
    
    /* Read registry and assign values to g_RtpDbgReg */
    for(i = 0; g_dwRtpDbgRegCtrl[i]; i++)
    {
        dwControl = g_dwRtpDbgRegCtrl[i];

        if (REGOPEN(dwControl))
        {
            /* Build path */
            lstrcpy(sPath, RTPDBG_ROOTPATH);
            lstrcat(sPath, g_sRtpDbgModuleNameID);
            lstrcat(sPath, REGPATH(dwControl));
            
            /* Open root key, try read only first */
            dwError = RegOpenKeyEx(RTPDBG_ROOTKEY,
                                   sPath,
                                   0,
                                   RTPDBG_OPENREADONLY,
                                   &hk);
            
            /* if key doesn't exist try to create it */
            if (dwError !=  ERROR_SUCCESS)
            {
                dwError = RegCreateKeyEx(RTPDBG_ROOTKEY,
                                         sPath,
                                         0,
                                         NULL,
                                         0,
                                         RTPDBG_OPENKEYFLAGS,
                                         NULL,
                                         &hk,
                                         NULL);
            }
            
            if (dwError !=  ERROR_SUCCESS)
            {
                /* Move forward to next close */
                while(!REGCLOSE(dwControl))
                {
                    i++;
                    dwControl = g_dwRtpDbgRegCtrl[i];
                }

                continue;
            }
        }

        /* Read each key value in group */
        while(1)
        {
            /* Read key */
            hkDataSize = sizeof(hkData);
            dwError = RegQueryValueEx(hk,
                                      g_psRtpDbgInfo[i],
                                      0,
                                      &hkDataType,
                                      hkData,
                                      &hkDataSize);
            
            if ((dwError != ERROR_SUCCESS) || (hkDataType != REG_DWORD))
            {
                /* Try to create entry and set it to 0 */
                *(DWORD *)hkData = 0;
                
                RegSetValueEx(hk,
                              g_psRtpDbgInfo[i],
                              0,
                              REG_DWORD,
                              hkData,
                              sizeof(DWORD));

                /* Can not report errors yet */
                /* If this fails, assume the value is 0 */
            }

            *PDW(pRtpDbgReg, dwControl) = *(DWORD *)hkData;

            if (REGISCLASS(dwControl) && *PDW(pRtpDbgReg, dwControl))
            {
                /* Update the class mask for the entries that define a
                 * class and its registry value is non zero */
                RtpBitSet(dwClassMask, REGCLASS(dwControl) + 24);
            }
            
            if (REGCLOSE(dwControl))
            {
                break;
            }

            i++;
            dwControl = g_dwRtpDbgRegCtrl[i];
        }

        RegCloseKey(hk);
    }

    /* The following settings assume advanced tracing is enabled */
    if (pRtpDbgReg->dwDisableGroup)
    {
        /* If group is not used, reset bits */
        ZeroMemory(pRtpDbgReg->dwGroupArray,
                   sizeof(pRtpDbgReg->dwGroupArray));
        ZeroMemory(pRtpDbgReg->dwGroupArray2,
                   sizeof(pRtpDbgReg->dwGroupArray2));
    }
    else
    {
        if (IsSetDebugOption(OPTDBG_UNSELECT))
        {
            for(i = GROUP_FIRST + 1; i < GROUP_LAST; i++)
            {
                pRtpDbgReg->dwGroupArray2[i] =
                    pRtpDbgReg->dwGroupArray[i] & 0x00ffffff;

                pRtpDbgReg->dwGroupArray[i] = 0;
            }
        }
    }
    
    if (!pRtpDbgReg->dwDisableClass)
    {
        /* If class is not disabled, update it. Include group 0 for
         * the cases where group is not specified */
        for(i = GROUP_FIRST; i < GROUP_LAST; i++)
        {
            pRtpDbgReg->dwGroupArray[i] |= dwClassMask;
        }
    }

    if (pRtpDbgReg->dwEnableFileTracing || pRtpDbgReg->dwEnableConsoleTracing)
    {
        pRtpDbgReg->dwEnableFileTracing = 1;
    }

    /* I will use only one merged mask */
    pRtpDbgReg->dwFileTracingMask |= pRtpDbgReg->dwConsoleTracingMask;

    pRtpDbgReg->dwFileTracingMask &= 0xffff0000;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\misc\rtpevent.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpevent.c
 *
 *  Abstract:
 *
 *    Post RTP/RTCP specific events
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/11/29 created
 *
 **********************************************************************/

#include "rtpmisc.h"

#include "rtpevent.h"
/*
      3                   2                   1                 
    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Last event   |       |  Adj  |            Offset             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    \------v------/ \--v--/ \--v--/ \--------------v--------------/
           |           |       |                   |
           |           |       |                Offset (16)
           |           |       |
           |           |  Adjustment to the event (4)
           |           |
           |        Unused (4)
           |
      Last event (8)
*/
/*
 * Encoding macros
 */
#define CTRL(_last, _adj, _off) (((_last) << 24) | ((_adj) << 16) | (_off))
/* Offset to field */
#define OFF(_f)    ((DWORD) (((ULONG_PTR) &((RtpSess_t *)0)->_f) & 0xffff))

/*
 * Decoding macros
 * */
#define LAST(_ctrl)         (((_ctrl) >> 24) & 0xff)
#define ADJ(_ctrl)          (((_ctrl) >> 16) & 0xf)
#define OFFSET(_ctrl)       ((_ctrl) & 0xffff)
#define PDW(_sess,_ctrl)    ((DWORD *) ((char *)_sess + OFFSET(_ctrl)))

/*
 * WARNING
 *
 * The Adjustment is only a convinience to match the WSA QOS error to
 * the respective QOS event.
 * */
const DWORD g_dwEventControl[] = {
    CTRL(RTPRTP_LAST,     0,           OFF(dwEventMask)),    /* RTP */
    CTRL(RTPPARINFO_LAST, 0,           OFF(dwPartEventMask)),/* Participants */
    CTRL(RTPQOS_LAST,    RTPQOS_ADJUST,OFF(dwQosEventMask)), /* QOS */
    CTRL(RTPSDES_LAST,    0,           OFF(dwSdesEventMask)),/* SDES info */
    0
};

/*
 * WARNING
 *
 * The order in the following global arrays MUST be matched with the
 * entries in the enumerations in the public file msrtp.h
 * */

const TCHAR_t *g_psEventControlName[] = {
    _T("RTP"),
    _T("PINFO"),
    _T("QOS"),
    _T("SDES")
};

const TCHAR_t *g_psRtpRtpEvents[] = {
    _T("invalid"),
    _T("RR_RECEIVED"),
    _T("SR_RECEIVED"),
    _T("LOCAL_COLLISION"),
    _T("WS_RECV_ERROR"),
    _T("WS_SEND_ERROR"),
    _T("WS_NET_FAILURE"),
    _T("RECV_LOSSRATE"),
    _T("SEND_LOSSRATE"),
    _T("BANDESTIMATION"),
    _T("CRYPT_RECV_ERROR"),
    _T("CRYPT_SEND_ERROR"),
    _T("invalid")
};

const TCHAR_t *g_psRtpPInfoEvents[] = {
    _T("invalid"),
    _T("CREATED"),
    _T("SILENT"),
    _T("TALKING"),
    _T("WAS_TALKING"),
    _T("STALL"),
    _T("BYE"),
    _T("DEL"),
    _T("MAPPED"),
    _T("UNMAPPED"),
    _T("NETWORKCONDITION"),
    _T("invalid")
};

const TCHAR_t *g_psRtpQosEvents[] = {
    _T("invalid"),
    _T("NOQOS"),
    _T("RECEIVERS"),
    _T("SENDERS"),
    _T("NO_SENDERS"),
    _T("NO_RECEIVERS"),
    _T("REQUEST_CONFIRMED"),
    _T("ADMISSION_FAILURE"),
    _T("POLICY_FAILURE"),
    _T("BAD_STYLE"),
    _T("BAD_OBJECT"),
    _T("TRAFFIC_CTRL_ERROR"),
    _T("GENERIC_ERROR"),
    _T("ESERVICETYPE"),
    _T("EFLOWSPEC"),
    _T("EPROVSPECBUF"),
    _T("EFILTERSTYLE"),
    _T("EFILTERTYPE"),
    _T("EFILTERCOUNT"),
    _T("EOBJLENGTH"),
    _T("EFLOWCOUNT"),
    _T("EUNKOWNPSOBJ"),
    _T("EPOLICYOBJ"),
    _T("EFLOWDESC"),
    _T("EPSFLOWSPEC"),
    _T("EPSFILTERSPEC"),
    _T("ESDMODEOBJ"),
    _T("ESHAPERATEOBJ"),
    _T("RESERVED_PETYPE"),
    _T("NOT_ALLOWEDTOSEND"),
    _T("ALLOWEDTOSEND"),
    _T("invalid")
};

const TCHAR_t *g_psRtpSdesEvents[] = {
    _T("END"),
    _T("CNAME"),
    _T("NAME"),
    _T("EMAIL"),
    _T("PHONE"),
    _T("LOC"),
    _T("TOOL"),
    _T("NOTE"),
    _T("PRIV"),
    _T("ANY"),
    _T("invalid")
};

const TCHAR_t **g_ppsEventNames[] = {
    g_psRtpRtpEvents,
    g_psRtpPInfoEvents,
    g_psRtpQosEvents,
    g_psRtpSdesEvents
};
  
BOOL RtpPostEvent(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        DWORD            dwEventKind,
        DWORD            dwEvent,
        DWORD_PTR        dwPar1,
        DWORD_PTR        dwPar2
    )
{
    BOOL             bPosted;
    RtpSess_t       *pRtpSess;
    DWORD           *pdwEventMask;
    DWORD            dwControl;
    DWORD            dwSSRC;
    DWORD            i;

    TraceFunctionName("RtpPostEvent");

    if (dwEventKind >= RTPEVENTKIND_LAST)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTP, S_RTP_EVENT,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] ")
                _T("Invalid Kind:%u Event:%u Par1:0x%p Par2:0x%p"),
                _fname, pRtpAddr, pRtpUser,
                dwEventKind, dwEvent,
                dwPar1, dwPar2
            ));
  
        return(FALSE);
    }

    dwControl = g_dwEventControl[dwEventKind];

    if ((dwEvent < 1) || (dwEvent >= LAST(dwControl)))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTP, S_RTP_EVENT,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] ")
                _T("Kind:%s Invalid Event:%u Par1:0x%p Par2:0x%p"),
                _fname, pRtpAddr, pRtpUser,
                g_psEventControlName[dwEventKind], dwEvent,
                dwPar1, dwPar2
            ));
  
        return(FALSE);
    }
    
    pRtpSess = pRtpAddr->pRtpSess;

    if (pRtpUser)
    {
        dwSSRC = pRtpUser->dwSSRC;
    }
    else
    {
        dwSSRC = 0;
    }

    /* Event mask are in RtpSess_t */
    pdwEventMask = PDW(pRtpSess, dwControl);

    bPosted = FALSE;
    
    for(i = 0; i < 2; i++)
    {
        if (RtpBitTest(pRtpSess->dwSessFlags, FGSESS_EVENTRECV + i) &&
            RtpBitTest(pdwEventMask[i], dwEvent))
        {
            TraceDebug((
                    CLASS_INFO, GROUP_RTP, S_RTP_EVENT,
                    _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                    _T("%s Kind:%s Event:%s Par1:0x%p Par2:0x%p"),
                    _fname, pRtpAddr, pRtpUser, ntohl(dwSSRC),
                    RTPRECVSENDSTR(i),
                    g_psEventControlName[dwEventKind],
                    *(g_ppsEventNames[dwEventKind] + dwEvent),
                    dwPar1, dwPar2
                ));
            
            pRtpSess->pHandleNotifyEvent(
                    pRtpSess->pvSessUser[i],
                    RTPEVENTBASE +
                    RTPEVNTRANGE * dwEventKind +
                    ADJ(dwControl) + dwEvent,
                    dwPar1,
                    dwPar2);

            bPosted = TRUE;
        }
        else
        {
            TraceDebugAdvanced((
                    0, GROUP_RTP, S_RTP_EVENT,
                    _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                    _T("%s Kind:%s Unposted Event:%s Par1:0x%p Par2:0x%p"),
                    _fname, pRtpAddr, pRtpUser, ntohl(dwSSRC),
                    RTPRECVSENDSTR(i),
                    g_psEventControlName[dwEventKind],
                    *(g_ppsEventNames[dwEventKind] + dwEvent),
                    dwPar1, dwPar2
                ));
        }
    }

    return(bPosted);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\misc\rtperr.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 2000
 *
 *  File name:
 *
 *    rtperr.c
 *
 *  Abstract:
 *
 *    Error codes
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2000/03/21 created
 *
 **********************************************************************/

#include "gtypes.h"

/*
 * WARNING
 *
 * The *_ENUM_* values in rtperr.h and the array g_psRtpErr in
 * rtperr.c MUST have their entries matched
 * */
const TCHAR      *g_psRtpErr[] =
{
    _T("NOERROR"),
    _T("FAIL"),
    _T("MEMORY"),
    _T("POINTER"),
    _T("INVALIDRTPSESS"),
    _T("INVALIDRTPADDR"),
    _T("INVALIDRTPUSER"),
    _T("INVALIDRTPCONTEXT"),
    _T("INVALIDRTCPCONTEXT"),
    _T("INVALIDOBJ"),
    _T("INVALIDSTATE"),
    _T("NOTINIT"),
    _T("INVALIDARG"),
    _T("INVALIDHDR"),
    _T("INVALIDPT"),
    _T("INVALIDVERSION"),
    _T("INVALIDPAD"),
    _T("INVALIDRED"),
    _T("INVALIDSDES"),
    _T("INVALIDBYE"),
    _T("INVALIDUSRSTATE"),
    _T("INVALIDREQUEST"),
    _T("SIZE"),
    _T("MSGSIZE"),
    _T("OVERRUN"),
    _T("UNDERRUN"),
    _T("PACKETDROPPED"),
    _T("CRYPTO"),
    _T("ENCRYPT"),
    _T("DECRYPT"),
    _T("CRITSECT"),
    _T("EVENT"),
    _T("WS2RECV"),
    _T("WS2SEND"),
    _T("NOTFOUND"),
    _T("UNEXPECTED"),
    _T("REFCOUNT"),
    _T("THREAD"),
    _T("HEAP"),
    _T("WAITTIMEOUT"),
    _T("CHANNEL"),
    _T("CHANNELCMD"),
    _T("RESOURCES"),
    _T("QOS"),
    _T("NOQOS"),
    _T("QOSSE"),
    _T("QUEUE"),
    _T("NOTIMPL"),
    _T("INVALIDFAMILY"),
    _T("LAST")
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\misc\rtpmask.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpmask.c
 *
 *  Abstract:
 *
 *    Used to modify or test the different masks in a RtpSess_t
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/11/24 created
 *
 **********************************************************************/

#include "rtpmask.h"

#define SESSOFFSET(_f) ((DWORD) ((ULONG_PTR) &((RtpSess_t *)0)->_f))

/* Features mask */
#define FEATURE   SESSOFFSET(dwFeatureMask)

/* RTP events masks */
#define RTPEVENTR SESSOFFSET(dwEventMask[0])
#define RTPEVENTS SESSOFFSET(dwEventMask[1])

/* Participant events mask */
#define PARTEVENTR SESSOFFSET(dwPartEventMask[0])
#define PARTEVENTS SESSOFFSET(dwPartEventMask[1])

/* QOS events masks */
#define QOSEVENTR SESSOFFSET(dwQosEventMask[0])
#define QOSEVENTS SESSOFFSET(dwQosEventMask[1])

/* SDES events mask */
#define SDESEVENTR SESSOFFSET(dwSdesEventMask[0])
#define SDESEVENTS SESSOFFSET(dwSdesEventMask[1])

/* SDES information masks */
#define SDESMASKL SESSOFFSET(dwSdesMask[0])
#define SDESMASKR SESSOFFSET(dwSdesMask[1])

#define PDWORDMASK(_sess, _off) RTPDWORDPTR(_sess, _off)

/*
 * !!! WARNING !!!
 *
 * Order in the enumeration in public file msrtp.h (RTPMASK_FIRST,
 * RTPMASK_FEATURES_MASK, RTPMASK_RECV_EVENTS, etc) MUST match the
 * offsets in global array g_dwRtpSessionMask (rtpmask.c)
 * */
const DWORD g_dwRtpSessionMask[] =
{
    -1,

    /* Features mask */
    FEATURE,

    /* RTP events masks */
    RTPEVENTR,
    RTPEVENTS,

    /* Participant events mask */
    PARTEVENTR,
    PARTEVENTS,

    /* QOS events masks */
    QOSEVENTR,
    QOSEVENTS,

    /* SDES events mask */
    SDESEVENTR,
    SDESEVENTS,
    
    /* SDES information masks */
    SDESMASKL,
    SDESMASKR,
    
    -1
};

const TCHAR *g_sRtpMaskName[] =
{
    _T("invalid"),
    
    _T("FEATURES_MASK"),
    
    _T("RECV_EVENTS"),
    _T("SEND_EVENTS"),
    
    _T("PINFOR_EVENTS"),
    _T("PINFOS_EVENTS"),
    
    _T("QOSRECV_EVENTS"),
    _T("QOSSEND_EVENTS"),
    
    _T("SDESRECV_EVENTS"),
    _T("SDESSEND_EVENTS"),
    
    _T("SDESLOCAL_MASK"),
    _T("SDESREMOTE_MASK"),

    _T("invalid")
};

/* Modify the mask specified by dwKind (e.g. RTPMASK_RECV_EVENTS,
 * RTPMASK_SDES_LOCMASK).
 *
 * dwMask is the mask of bits to be set or reset depending on dwValue
 * (reset if 0, set otherwise).
 *
 * pdwModifiedMask will return the resulting mask if the pointer is
 * not NULL. You can just query the current mask value by passing
 * dwMask=0 */
HRESULT RtpModifyMask(
        RtpSess_t       *pRtpSess,
        DWORD            dwKind,
        DWORD            dwMask,
        DWORD            dwValue,
        DWORD           *pdwModifiedMask
    )
{
    HRESULT          hr;
    BOOL             bOk;
    DWORD            dwError;
    DWORD           *pdwMask;

    TraceFunctionName("RtpModifyMask");

    if (!pRtpSess)
    {
        /* Having this as a NULL pointer means Init hasn't been
         * called, return this error instead of RTPERR_POINTER to be
         * consistent */
        hr = RTPERR_INVALIDSTATE;

        goto end;
    }

    if (pRtpSess->dwObjectID != OBJECTID_RTPSESS)
    {
        hr = RTPERR_INVALIDRTPSESS;

        TraceRetail((
                CLASS_ERROR, GROUP_SETUP, S_SETUP_GLOB,
                _T("%s: pRtpSess[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpSess,
                pRtpSess->dwObjectID, OBJECTID_RTPSESS
            ));

        goto end;
    }

    if (dwKind <= RTPMASK_FIRST || dwKind >= RTPMASK_LAST)
    {
        hr = RTPERR_INVALIDARG;
        
        TraceRetail((
                CLASS_ERROR, GROUP_SETUP, S_SETUP_GLOB,
                _T("%s: pRtpSess[0x%p] Invalid mask kind: %u"),
                _fname, pRtpSess,
                dwKind
            ));
        goto end;
    }

    bOk = RtpEnterCriticalSection(&pRtpSess->SessCritSect);

    if (!bOk)
    {
        hr = RTPERR_CRITSECT;

        TraceRetail((
                CLASS_ERROR, GROUP_SETUP, S_SETUP_GLOB,
                _T("%s: pRtpSess[0x%p] Critical section failed"),
                _fname, pRtpSess
            ));

        goto end;
    }

    hr = NOERROR;
    
    pdwMask = PDWORDMASK(pRtpSess, g_dwRtpSessionMask[dwKind]);

    if (dwValue)
    {
        /* Set */
        *pdwMask |= dwMask;

        dwValue = 1;
        
        TraceDebug((
                CLASS_INFO, GROUP_SETUP, S_SETUP_GLOB,
                _T("%s: pRtpSess[0x%p] Set bits in %s: 0x%X ")
                _T("(0x%X)"),
                _fname, pRtpSess,
                g_sRtpMaskName[dwKind],
                dwMask,
                *pdwMask
            ));
    }
    else
    {
        /* Reset */
        *pdwMask &= ~dwMask;

        TraceDebug((
                CLASS_INFO, GROUP_SETUP, S_SETUP_GLOB,
                _T("%s: pRtpSess[0x%p] Reset bits in %s: 0x%X ")
                _T("(0x%X)"),
                _fname, pRtpSess,
                g_sRtpMaskName[dwKind],
                dwMask,
                *pdwMask
            ));
    }

    if (pdwModifiedMask)
    {
        /* Query */
        *pdwModifiedMask = *pdwMask;
    }

    TraceRetailAdvanced((
            CLASS_INFO, GROUP_SETUP, S_SETUP_GLOB,
            _T("%s: pRtpSess[0x%p] Current %s:0x%X mask:0x%X/%u"),
            _fname, pRtpSess,
            g_sRtpMaskName[dwKind], *pdwMask,
            dwMask, dwValue
        ));
    
    RtpLeaveCriticalSection(&pRtpSess->SessCritSect);

 end:
    
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\misc\rtpheap.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpheap.c
 *
 *  Abstract:
 *
 *    Implements the private heaps handling
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/24 created
 *
 **********************************************************************/

#include "rtpque.h"
#include "rtpcrit.h"
#include "rtpdbg.h"
#include "rtpglobs.h"

#include "rtpheap.h"

/*
 * The master heap is used to create unique global RTP heaps, all the
 * heaps created are kept together in the free and busy queues */
RtpHeap_t      g_RtpHeapMaster;
RtpHeap_t     *g_pRtpHeapMaster = NULL;
RtpQueue_t     g_RtpHeapsQ;
RtpCritSect_t  g_RtpHeapsCritSect;

/* Forward declaration of helper functions */
BOOL RtpHeapInit(RtpHeap_t *pRtpHeap, BYTE bTag, long lSize, void *pvOwner);
BOOL RtpHeapDelete(RtpHeap_t *pRtpHeap);
BOOL RtpHeapVerifySignatures(
        RtpHeap_t       *pRtpHeap,
        RtpHeapBlockBegin_t *pBlockBegin,
        DWORD            dwSignature /* BSY | FRE */
    );

/*
 * Helper function for RtpHeapCreate.
 *
 * Initializes a RTP heap. The real heap is created, the critical
 * section initialized, and the other fields properly initialized. */
BOOL RtpHeapInit(RtpHeap_t *pRtpHeap, BYTE bTag, long lSize, void *pvOwner)
{
    ZeroMemory(pRtpHeap, sizeof(RtpHeap_t));

    /* set object ID */
    pRtpHeap->dwObjectID = OBJECTID_RTPHEAP;

    /* save tag to apply to each block allocated */
    pRtpHeap->bTag = bTag;

    if (lSize > 0)
    {
        lSize = (lSize + sizeof(DWORD) - 1) & ~(sizeof(DWORD) - 1);
    
        pRtpHeap->lSize = lSize;
    }

    /* create real heap, initial size of 1 will be rounded up to the
     * page size */
    if ( !(pRtpHeap->hHeap = HeapCreate(HEAP_NO_SERIALIZE, 1, 0)) )
    {
        /* TODO log error */
        goto bail;
    }

    /* initialize critical section */
    if ( !(RtpInitializeCriticalSection(&pRtpHeap->RtpHeapCritSect,
                                        pvOwner,
                                        _T("RtpHeapCritSect"))) )
    {
        /* TODO log error */
        goto bail;
    }

    enqueuef(&g_RtpHeapsQ,
             &g_RtpHeapsCritSect,
             &pRtpHeap->QueueItem);
            
    return(TRUE);
    
 bail:
    if (pRtpHeap->hHeap) {
        
        HeapDestroy(pRtpHeap->hHeap);
    }

    pRtpHeap->hHeap = NULL;
    
    RtpDeleteCriticalSection(&pRtpHeap->RtpHeapCritSect);

    return(FALSE);
}

/*
 * Helper function for RtpHeapDestroy.
 *
 * Destroys real heap and deletes critical section. Testing the object
 * is not necessary, this function is not exposed, instead, test in
 * RtpHeapDestroy */
BOOL RtpHeapDelete(RtpHeap_t *pRtpHeap)
{
    DWORD            bTag;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpHeapBlockBegin_t *pBlockBegin;
    
    TraceFunctionName("RtpHeapDelete");

    dequeue(&g_RtpHeapsQ,
            &g_RtpHeapsCritSect,
            &pRtpHeap->QueueItem);
    
    /* Check if BusyQ is empty */
    if ( !IsQueueEmpty(&pRtpHeap->BusyQ) )
    {
        bTag = 0;

        if (pRtpHeap->bTag < TAGHEAP_LAST)
        {
            bTag = pRtpHeap->bTag;
        }
        
        TraceRetail((
                CLASS_ERROR, GROUP_HEAP, S_HEAP_INIT,
                _T("%s: Heap[0x%p] tag:0x%X:%s ")
                _T("Busy queue is not empty:%d"),
                _fname, pRtpHeap,
                bTag, g_psRtpTags[bTag], GetQueueSize(&pRtpHeap->BusyQ)
            ));

        /* In debug builds dump the objects */
        while( (pRtpQueueItem = dequeuef(&pRtpHeap->BusyQ,
                                         &pRtpHeap->RtpHeapCritSect)) )
        {
            pBlockBegin = (RtpHeapBlockBegin_t *)
                ( (char *)pRtpQueueItem -
                  sizeof(RtpHeapBlockBegin_t) );
                
            TraceRetailAdvanced((
                    CLASS_INFO, GROUP_HEAP, S_HEAP_INIT,
                    _T("%s: Heap[0x%p] block[0x%p:%u] ")
                    _T("0x%X 0x%X 0x%X 0x%X"),
                    _fname, pRtpHeap, pBlockBegin, pBlockBegin->lSize,
                    ((DWORD *)(pRtpQueueItem + 1))[0],
                    ((DWORD *)(pRtpQueueItem + 1))[1],
                    ((DWORD *)(pRtpQueueItem + 1))[2],
                    ((DWORD *)(pRtpQueueItem + 1))[3]
                ));
        }
    }

    /* Invalidate object ID */
    INVALIDATE_OBJECTID(pRtpHeap->dwObjectID);

    /* Make segments inaccessible */
    ZeroMemory(&pRtpHeap->FreeQ, sizeof(RtpQueue_t));

    ZeroMemory(&pRtpHeap->BusyQ, sizeof(RtpQueue_t));

    if (pRtpHeap->hHeap)
    {
        HeapDestroy(pRtpHeap->hHeap);
    }

    pRtpHeap->hHeap = NULL;
    
    RtpDeleteCriticalSection(&pRtpHeap->RtpHeapCritSect);

    return(TRUE);
}

/*
 * The master heap must be created before any private RTP heap can be
 * created */
BOOL RtpCreateMasterHeap(void)
{
    BOOL bStatus;
    
    if (g_pRtpHeapMaster)
    {
        /* TODO log error */
        return(FALSE);
    }

    bStatus = RtpInitializeCriticalSection(&g_RtpHeapsCritSect,
                                           (void *)&g_pRtpHeapMaster,
                                           _T("g_RtpHeapsCritSect"));

    if (bStatus)
    {
        ZeroMemory(&g_RtpHeapsQ, sizeof(g_RtpHeapsQ));
    
        bStatus = RtpHeapInit(&g_RtpHeapMaster, TAGHEAP_RTPHEAP,
                              sizeof(RtpHeap_t), &g_RtpHeapMaster);

        if (bStatus)
        {
            g_pRtpHeapMaster = &g_RtpHeapMaster;
            
            return(TRUE);
        }
    }

    return(FALSE);
}

/*
 * The master heap is deleted when none of the memory allocated from
 * any private heap is in use. It is expected that when this function
 * is called, there will not be any heap left in the busy queue. */
BOOL RtpDestroyMasterHeap(void)
{
    if (!g_pRtpHeapMaster)
    {
        /* TODO log error */
        return(FALSE);
    }

    RtpHeapDelete(g_pRtpHeapMaster);
    
    RtpDeleteCriticalSection(&g_RtpHeapsCritSect);
    
    g_pRtpHeapMaster = NULL;

    return(TRUE);
}

/*
 * Creates a private heap from the master heap. The structure is
 * obtained from the master heap, the real heap is created, the
 * critical section initialized, and the other fields properly
 * initialized. */
RtpHeap_t *RtpHeapCreate(BYTE bTag, long lSize)
{
    BOOL       bStatus;
    RtpHeap_t *pNewHeap;
    long       lNewSize;
    
    if (!g_pRtpHeapMaster)
    {
        /* TODO log error */
        return(NULL);
    }
    
    if ( (pNewHeap = (RtpHeap_t *)
          RtpHeapAlloc(g_pRtpHeapMaster, sizeof(RtpHeap_t))) ) {
        /* initialize heap */

        bStatus = RtpHeapInit(pNewHeap, bTag, lSize, g_pRtpHeapMaster);

        if (bStatus)
        {
            return(pNewHeap);
        }
    }

    /* failure */
    if (pNewHeap)
    {
        RtpHeapFree(g_pRtpHeapMaster, (void *)pNewHeap);
        pNewHeap = NULL;
    }

    /* TODO log error */
    return(pNewHeap);
}

/*
 * Destroys a private heap. The structure is returned to the master
 * heap, the real heap is destroyed and the critical section
 * deleted. It is expected that the busy queue be empty.
 * */
BOOL RtpHeapDestroy(RtpHeap_t *pRtpHeap)
{
    BOOL       bStatus;
    
    TraceFunctionName("RtpHeapDestroy");

    if (!pRtpHeap || !g_pRtpHeapMaster)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_HEAP, S_HEAP_INIT,
                _T("%s: Heap[0x%p] Master[0x%p] Null pointer"),
                _fname, pRtpHeap, g_pRtpHeapMaster
            ));

        return(FALSE);
    }

    /* verify object ID */
    if (pRtpHeap->dwObjectID != OBJECTID_RTPHEAP)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_HEAP, S_HEAP_INIT,
                _T("%s: Heap[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpHeap,
                pRtpHeap->dwObjectID, OBJECTID_RTPHEAP
            ));

        return(FALSE);
    }

    bStatus = RtpHeapDelete(pRtpHeap);

    if (bStatus)
    {
        bStatus = RtpHeapFree(g_pRtpHeapMaster, (void *)pRtpHeap);
        
        if (bStatus) {
            return(TRUE);
        }
    }

    /* TODO log error */
    return(FALSE);
}

/*
 * If the size requested is the same as the heap's initially set, then
 * look first in the free list then create a new block. If the size is
 * different, just create a new block. In both cases the block will be
 * left in the busy queue. */
void *RtpHeapAlloc(RtpHeap_t *pRtpHeap, long lSize)
{
    BOOL                 bSigOk;
    long                 lNewSize;
    long                 lTotalSize;
    RtpHeapBlockBegin_t *pBlockBegin;
    RtpHeapBlockEnd_t   *pBlockEnd;
    DWORD                bTag;
    long                 lMaxMem;
    
    char            *pcNew;
    char            *ptr;
    DWORD           dwSignature;
    
    TraceFunctionName("RtpHeapAlloc");
    
    if (!pRtpHeap)
    {
        /* TODO log error */
        return(NULL);
    }

    /* verify object ID */
    if (pRtpHeap->dwObjectID != OBJECTID_RTPHEAP)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_HEAP, S_HEAP_ALLOC,
                _T("%s: Heap[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpHeap,
                pRtpHeap->dwObjectID, OBJECTID_RTPHEAP
            ));

        return(NULL);
    }
    
    pcNew = NULL;
    lNewSize = RTP_ALIGNED_SIZE(lSize);
    lTotalSize =
        lNewSize +
        sizeof(RtpHeapBlockBegin_t) +
        sizeof(RtpQueueItem_t) +
        sizeof(RtpHeapBlockEnd_t);

    if (!RtpEnterCriticalSection(&pRtpHeap->RtpHeapCritSect))
    {
        /* TODO log error */
        return(NULL);
    }

    if (!pRtpHeap->lSize)
    {
        /* Heap was initialized to size 0, keep objects allocated that
         * are the size of the first object allocated */
        pRtpHeap->lSize = lNewSize;
    }
   
    if (lNewSize == pRtpHeap->lSize && pRtpHeap->FreeQ.lCount > 0)
    {
        /* get from free queue */
        ptr = (char *)dequeuef(&pRtpHeap->FreeQ, NULL);

        /* move pointer back to begining of block */
        pBlockBegin = (RtpHeapBlockBegin_t *)
            (ptr - sizeof(RtpHeapBlockBegin_t));

        /* Verify that signatures are fine, i.e. buffer must be marked
         * as free */
        bSigOk = RtpHeapVerifySignatures(pRtpHeap, pBlockBegin, TAGHEAP_FRE);

        if (!bSigOk)
        {
            goto bail;
        }
    }
    else
    {
        /* get a new block from real heap */
        /* TODO obtain 1 memory page and insert in FreeQ as many
           objects as can be obtained from that page */
        pBlockBegin = (RtpHeapBlockBegin_t *)
            HeapAlloc(pRtpHeap->hHeap, 0, lTotalSize);

        if (pBlockBegin)
        {
            lMaxMem = InterlockedExchangeAdd(&g_RtpContext.lMemAllocated,
                                             lTotalSize);

            if (lMaxMem > g_RtpContext.lMaxMemAllocated)
            {
                g_RtpContext.lMaxMemAllocated = lMaxMem;
            }
        }
    }

    if (pBlockBegin)
    {
        /* initialize block */

        /* begin signature */
        dwSignature = TAGHEAP_BSY; /* RTP */
        dwSignature |= (pRtpHeap->bTag << 24);
        pBlockBegin->BeginSig = dwSignature;
        pBlockBegin->InvBeginSig = ~dwSignature;

        /* initialize other fields of block */
        pBlockBegin->lSize = lNewSize;
        pBlockBegin->dwFlag = 0;
        
        /* insert item into busy queue */
        ptr = (char *) (pBlockBegin + 1);
        ZeroMemory(ptr, sizeof(RtpQueueItem_t));
        enqueuel(&pRtpHeap->BusyQ, NULL, (RtpQueueItem_t *)ptr);
        ptr += sizeof(RtpQueueItem_t);

        /* set begining of buffer returned */
        pcNew = ptr;

        /* set end signature */
        pBlockEnd = (RtpHeapBlockEnd_t *)(ptr + lNewSize);
        dwSignature = TAGHEAP_END; /* END */
        dwSignature |= (pRtpHeap->bTag << 24);
        pBlockEnd->EndSig = dwSignature;
        pBlockEnd->InvEndSig = ~dwSignature;

        TraceDebugAdvanced((
                0, GROUP_HEAP, S_HEAP_ALLOC,
                _T("%s: Heap[0x%p] %s/%d Begin[0x%p] Data[0x%p] Size:%d/%d"),
                _fname, pRtpHeap, g_psRtpTags[pRtpHeap->bTag], pRtpHeap->lSize,
                pBlockBegin, pcNew, lTotalSize, lNewSize
            ));
    }
    else
    {
        bTag = 0;

        if (pRtpHeap->bTag < TAGHEAP_LAST)
        {
            bTag = pRtpHeap->bTag;
        }

        TraceRetail((
                CLASS_ERROR, GROUP_HEAP, S_HEAP_ALLOC,
                _T("%s: Heap[0x%p] tag:0x%X:%s ")
                _T("failed to allocate memory: %d/%d/%d"),
                _fname, pRtpHeap, bTag, g_psRtpTags[bTag],
                lSize, lNewSize, lTotalSize
            ));
    }

 bail:
    RtpLeaveCriticalSection(&pRtpHeap->RtpHeapCritSect);

    return((void *)pcNew);
}

/*
 * If the block is the same size as the heap's initially set, put it
 * in the free queue, otherwise destroy it. */
BOOL RtpHeapFree(RtpHeap_t *pRtpHeap, void *pvMem)
{
    BOOL                 bSigOk;
    DWORD                dwSignature;
    RtpQueueItem_t      *pRtpQueueItem;
    RtpHeapBlockBegin_t *pBlockBegin;
    RtpHeapBlockEnd_t   *pBlockEnd;
    DWORD                bTag;
    long                 lTotalSize;

    TraceFunctionName("RtpHeapFree");

    if (!pRtpHeap || !pvMem)
    {
        /* TODO log error */
        return(FALSE);
    }

    /* verify object ID */
    if (pRtpHeap->dwObjectID != OBJECTID_RTPHEAP)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_HEAP, S_HEAP_FREE,
                _T("%s: Heap[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpHeap,
                pRtpHeap->dwObjectID, OBJECTID_RTPHEAP
            ));
        
        return(FALSE);
    }
    
    pBlockBegin = (RtpHeapBlockBegin_t *)
        ( (char *)pvMem -
          sizeof(RtpQueueItem_t) -
          sizeof(RtpHeapBlockBegin_t) );

    if (!RtpEnterCriticalSection(&pRtpHeap->RtpHeapCritSect))
    {
        /* TODO log error */
        return(FALSE);
    }

    /* move from busy to free, dequeue and enqueue */

    pRtpQueueItem = dequeue(&pRtpHeap->BusyQ,
                            NULL,
                            (RtpQueueItem_t *)(pBlockBegin + 1));

    /* If the block was not in BusyQ, fail */
    if (!pRtpQueueItem)
    {
        bTag = 0;

        if (pRtpHeap->bTag < TAGHEAP_LAST)
        {
            bTag = pRtpHeap->bTag;
        }
        
        TraceRetail((
                CLASS_ERROR, GROUP_HEAP, S_HEAP_FREE,
                _T("%s: Heap[0x%p] tag:0x%X:%s ")
                _T("block[0x%p] was not in busy queue"),
                _fname, pRtpHeap,
                bTag, g_psRtpTags[bTag], pBlockBegin
            ));
        
        goto bail;
    }

    /* Verify signatures are valid (must be busy) */
    bSigOk = RtpHeapVerifySignatures(pRtpHeap, pBlockBegin, TAGHEAP_BSY);

    if (!bSigOk)
    {
        goto bail;
    }
                                     
    /* modify begin signature */
    dwSignature = TAGHEAP_FRE; /* FREE */
    dwSignature |= (pRtpHeap->bTag << 24);
    pBlockBegin->BeginSig = dwSignature;
    pBlockBegin->InvBeginSig = ~dwSignature;

    /* Total size that was allocated */
    lTotalSize = pBlockBegin->lSize + (sizeof(RtpHeapBlockBegin_t) +
                                       sizeof(RtpQueueItem_t) +
                                       sizeof(RtpHeapBlockEnd_t));

    TraceDebugAdvanced((
            0, GROUP_HEAP, S_HEAP_FREE,
            _T("%s: Heap[0x%p] %s/%d Begin[0x%p] Data[0x%p] Size:%d/%d"),
            _fname, pRtpHeap, g_psRtpTags[pRtpHeap->bTag], pRtpHeap->lSize,
            pBlockBegin, pvMem, lTotalSize, pBlockBegin->lSize
        ));
    
    if (pRtpHeap->lSize == pBlockBegin->lSize &&
        !IsSetDebugOption(OPTDBG_FREEMEMORY))
    {
        /* If same size, save in FreeQ for reuse */
        
        enqueuef(&pRtpHeap->FreeQ,
                 NULL,
                 pRtpQueueItem);
    }
    else
    {
        /* Otherwise release block to real heap */

        HeapFree(pRtpHeap->hHeap, 0, (void *)pBlockBegin);

        InterlockedExchangeAdd(&g_RtpContext.lMemAllocated, -lTotalSize);
    }
    
    RtpLeaveCriticalSection(&pRtpHeap->RtpHeapCritSect);

    return(TRUE);

 bail:
    RtpLeaveCriticalSection(&pRtpHeap->RtpHeapCritSect);

    return(FALSE);
}

BOOL RtpHeapVerifySignatures(
        RtpHeap_t       *pRtpHeap,
        RtpHeapBlockBegin_t *pBlockBegin,
        DWORD            dwSignature /* BSY | FRE */
    )
{
    BOOL             bSigOk;
    DWORD            bTag;
    DWORD            dwDbgSelection;
    RtpHeapBlockEnd_t *pBlockEnd;
    TCHAR_t          *_fname;

    bSigOk = TRUE;

    if (dwSignature == TAGHEAP_BSY)
    {
        /* Called from RtpHeapFree */
        dwDbgSelection = S_HEAP_FREE;
        _fname = _T("RtpHeapFree");
    }
    else /* dwSignature == TAGHEAP_FRE */
    {
        /* Called from RtpHeapAlloc */
        dwDbgSelection = S_HEAP_ALLOC;
        _fname = _T("RtpHeapAlloc");
    }
    
    /* Verify if begin signature is valid  */
    
    dwSignature |= (pRtpHeap->bTag << 24);

    if ( (pBlockBegin->BeginSig != dwSignature) ||
         (pBlockBegin->InvBeginSig != ~dwSignature) )
    {
        bTag = 0;

        if (pRtpHeap->bTag < TAGHEAP_LAST)
        {
            bTag = pRtpHeap->bTag;
        }
        
        TraceRetail((
                CLASS_ERROR, GROUP_HEAP, dwDbgSelection,
                _T("%s: Heap[0x%p] tag:0x%X:%s ")
                _T("block[0x%p:%u] has invalid begin signature 0x%X != 0x%X"),
                _fname, pRtpHeap, pBlockBegin->lSize,
                bTag, g_psRtpTags[bTag],
                pBlockBegin, pBlockBegin->BeginSig, dwSignature
            ));

        bSigOk = FALSE;
        
        goto end;
    }

    /* Verify if ending signature is valid  */

    pBlockEnd = (RtpHeapBlockEnd_t *)
        ((char *)(pBlockBegin + 1) +
         sizeof(RtpQueueItem_t) +
         pBlockBegin->lSize);

    dwSignature = TAGHEAP_END; /* END */
    dwSignature |= (pRtpHeap->bTag << 24);

    if ( (pBlockEnd->EndSig != dwSignature) ||
         (pBlockEnd->InvEndSig != ~dwSignature) )
    {
        bTag = 0;

        if (pRtpHeap->bTag < TAGHEAP_LAST)
        {
            bTag = pRtpHeap->bTag;
        }

        TraceRetail((
                CLASS_ERROR, GROUP_HEAP, dwDbgSelection,
                _T("%s: Heap[0x%p] tag:0x%X:%s ")
                _T("block[0x%p/0x%p:%u] has invalid end signature 0x%X != 0x%X"),
                _fname, pRtpHeap,
                bTag, g_psRtpTags[bTag],
                pBlockBegin, pBlockEnd, pBlockBegin->lSize,
                pBlockEnd->EndSig, dwSignature
            ));

        bSigOk = FALSE;
        
        goto end;
    }

 end:
    return(bSigOk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\misc\rtpmisc.c ===
/**********************************************************************
 *
 *  Copyright (C) 1999 Microsoft Corporation
 *
 *  File name:
 *
 *    rtpmisc.c
 *
 *  Abstract:
 *
 *    Some networking miscellaneous functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/07/13 created
 *
 **********************************************************************/

#include <winsock2.h>
#include <psapi.h>

#include "rtpglobs.h"

#include "rtpmisc.h"

/* Used to cache some user and system information */
#define RTPMASUSERNAME  256
#define RTPMAXHOSTNAME  256
#define RTPMAXPLATFORM  256
#define RTPMAXIMAGENAME 256

TCHAR_t g_sRtpUserName[RTPMASUSERNAME];
TCHAR_t g_sRtpHostName[RTPMAXHOSTNAME];
TCHAR_t g_sRtpPlatform[RTPMAXPLATFORM];
TCHAR_t g_sRtpImageName[RTPMAXIMAGENAME];

DWORD   g_dwRtpUserSysInfo = 0;

enum {
    RTPINFO_FIRST,
    
    RTPINFO_USERNAME,
    RTPINFO_HOSTNAME,
    RTPINFO_PLATFORM,
    RTPINFO_IMAGENAME,
    
    RTPINFO_LAST
};

/*
 * WARNING
 *
 * In the following functions, dwSize is in TCHARs
 * */

BOOL RtpGetUserName(TCHAR_t *pUser, DWORD dwSize)
{
    BOOL            bOk;
    DWORD           dwError;
    unsigned long   strLen;

    TraceFunctionName("RtpGetUserName");

    bOk = FALSE;

    if (RtpBitTest(g_dwRtpUserSysInfo, RTPINFO_USERNAME))
    {
        bOk = TRUE;

        goto end;
    }

    strLen = sizeof(g_sRtpUserName)/sizeof(TCHAR_t);
        
    if (GetUserName(g_sRtpUserName, &strLen) > 0)
    {
        bOk = TRUE;

        RtpBitSet(g_dwRtpUserSysInfo, RTPINFO_USERNAME);

        TraceDebug((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_HOST,
                _T("%s: %s"),
                _fname, g_sRtpUserName
            ));
    }
    else
    {
        TraceRetailGetError(dwError);
        
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_HOST,
                _T("%s: GetUserName failed: %u (0x%X)"),
                _fname, dwError, dwError
            ));
        
        *pUser = _T('\0');
    }

 end:
    if (bOk)
    {
        _tcsncpy(pUser, g_sRtpUserName, dwSize);
    }
    
    return(bOk);
}

BOOL RtpGetHostName(TCHAR_t *pHost, DWORD dwSize)
{
    BOOL            bOk;
    DWORD           dwError;
    char           *sHostName;
    struct hostent *he;

    TraceFunctionName("RtpGetHostName");
    
    bOk = FALSE;

    /* Get host name */
    if (RtpBitTest(g_dwRtpUserSysInfo, RTPINFO_HOSTNAME))
    {
        bOk = TRUE;
        
        goto done;
    }
    
    sHostName = RtpHeapAlloc(g_pRtpGlobalHeap, dwSize);

    if (!sHostName)
    {
        return(bOk);
    }
    
    if (gethostname(sHostName, dwSize))
    {
        TraceRetailWSAGetError(dwError);
        
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_HOST,
                _T("%s: gethostname failed: %u (0x%X)"),
                _fname, dwError, dwError
            ));
        
        sHostName[0] = '\0';
    }
    else
    {
        bOk = TRUE;

        TraceDebug((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_HOST,
                _T("%s: gethostname %hs"),
                _fname, sHostName
            ));
        
        if ( !(he = gethostbyname(sHostName)) )
        {
            TraceRetailWSAGetError(dwError);
        
            TraceRetail((
                    CLASS_ERROR, GROUP_NETWORK, S_NETWORK_HOST,
                    _T("%s: gethostbyname failed: %u (0x%X)"),
                    _fname, dwError, dwError
             ));
        }
        else
        {
            strncpy(sHostName, he->h_name, dwSize);
        }

#if defined(UNICODE)
        /* Convert ASCII to UNICODE */
        MultiByteToWideChar(CP_ACP,
                            0,
                            sHostName,
                            -1,
                            g_sRtpHostName,
                            sizeof(g_sRtpHostName)/sizeof(TCHAR_t));
#else
        strncpy(g_sRtpHostName, sHostName, sizeof(g_sRtpHostName));
#endif

        RtpBitSet(g_dwRtpUserSysInfo, RTPINFO_HOSTNAME);
        
        TraceDebug((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_HOST,
                _T("%s: gethostbyname: %s"),
                _fname, g_sRtpHostName
            ));
    }

    RtpHeapFree(g_pRtpGlobalHeap, sHostName);
    
 done:

    if (bOk)
    {
        _tcsncpy(pHost, g_sRtpHostName, dwSize);
    }
    
    return(bOk);
}

BOOL RtpGetPlatform(TCHAR_t *pPlatform)
{
    OSVERSIONINFO  os;
    BOOL           bOk;
    DWORD          dwError;

    TraceFunctionName("RtpGetPlatform");

    bOk = FALSE;

    if (RtpBitTest(g_dwRtpUserSysInfo, RTPINFO_PLATFORM))
    {
        bOk = TRUE;

        goto done;
    }
    
    os.dwOSVersionInfoSize = sizeof(os);
    
    if (GetVersionEx(&os))
    {
        _stprintf(g_sRtpPlatform,
#if defined(_X86_) 
                  _T("Windows%s-x86-%u.%u.%u"),
#elif defined(_IA64_)
                  _T("Windows%s-ia64-%u.%u.%u"),
#else
                  _T("Windows%s-%u.%u.%u"),
#endif               
                  (os.dwPlatformId == VER_PLATFORM_WIN32_NT)?
                  ((os.dwBuildNumber <= 2200)? _T("2000"):_T("XP")):_T("9x"),
                  os.dwMajorVersion,
                  os.dwMinorVersion,
                  os.dwBuildNumber);
        
        bOk = TRUE;

        RtpBitSet(g_dwRtpUserSysInfo, RTPINFO_PLATFORM);

        TraceDebug((
                CLASS_INFO, GROUP_NETWORK, S_NETWORK_HOST,
                _T("%s: %s"),
                _fname, g_sRtpPlatform
            ));
    }
    else
    {
        TraceRetailGetError(dwError);
        
        TraceRetail((
                CLASS_ERROR, GROUP_NETWORK, S_NETWORK_HOST,
                _T("%s: GetVersionEx failed: %u (0x%X)"),
                _fname, dwError, dwError
            ));
    }

 done:
    if (bOk)
    {
        lstrcpy(pPlatform, g_sRtpPlatform);   
    }
    
    return(bOk);
}

BOOL RtpGetImageName(TCHAR_t *pImageName, DWORD *pdwSize)
{
    BOOL            bOk;
    DWORD           dwLen;
    TCHAR_t         psWholeName[RTPMAXIMAGENAME];
    TCHAR_t        *psName;

    bOk = FALSE;
    
    if (RtpBitTest(g_dwRtpUserSysInfo, RTPINFO_IMAGENAME))
    {
        bOk = TRUE;

        goto end;
    }

    dwLen = GetModuleFileNameEx(GetCurrentProcess(),
                                0,
                                psWholeName,
                                RTPMAXIMAGENAME);

    if (dwLen)
    {
        bOk = TRUE;
        
        psName = _tcsrchr(psWholeName, _T('\\'));

        if (psName)
        {
            psName++;
        }
        else
        {
            psName = psWholeName;
        }

        lstrcpy(g_sRtpImageName, psName);
        
        RtpBitSet(g_dwRtpUserSysInfo, RTPINFO_IMAGENAME);
    }

 end:
    if (bOk)
    {
        if (pdwSize)
        {
            if (pImageName)
            {
                _tcsncpy(pImageName, g_sRtpImageName, *pdwSize);
            }

            *pdwSize = lstrlen(g_sRtpImageName);
        }
    }

    return(bOk);
}

/* Converts an IP v4 address (NETWORK ORDER) to its dot form */
TCHAR_t *RtpNtoA(DWORD dwAddr, TCHAR_t *sAddr)
{
    _stprintf(sAddr, _T("%u.%u.%u.%u"),
              (dwAddr & 0xff),
              (dwAddr >> 8) & 0xff,
              (dwAddr >> 16) & 0xff,
              (dwAddr >> 24) & 0xff);
            
    return(sAddr);
}

/* Converts an IP v4 address in dot form to a 4bytes word (NETWORK
 * ORDER) */
DWORD RtpAtoN(TCHAR_t *sAddr)
{
    int              iStatus;
    DWORD            dwB0;
    DWORD            dwB1;
    DWORD            dwB2;
    DWORD            dwB3;
    DWORD            dwAddr;
    
    iStatus = _stscanf(sAddr, _T("%u.%u.%u.%u"), &dwB0, &dwB1, &dwB2, &dwB3);

    if (iStatus == 4)
    {
        dwAddr =
            ((dwB3 & 0xff) << 24) |
            ((dwB2 & 0xff) << 16) |
            ((dwB1 & 0xff) <<  8) |
            (dwB0  & 0xff);
    }
    else
    {
        dwAddr = 0;
    }

    return(dwAddr);
}

/* Compare memory */
BOOL RtpMemCmp(BYTE *pbMem0, BYTE *pbMem1, long lMemSize)
{
    BOOL             bResult;

    if (lMemSize <= 0 || !pbMem0 || !pbMem1)
    {
        return(FALSE);
    }

    bResult = TRUE;
    
    for(; lMemSize > 0; lMemSize--, pbMem0++, pbMem1++)
    {
        if (*pbMem0 != *pbMem1)
        {
            bResult = FALSE;
            
            break;
        }
    }

    return(bResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\misc\rtpreg.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 2000
 *
 *  File name:
 *
 *    rtpreg.c
 *
 *  Abstract:
 *
 *    Registry initialization and configuration
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2000/01/21 created
 *
 **********************************************************************/

#include "rtpmisc.h"
#include "rtphdr.h"
#include "rtcpsdes.h"
#include "rtpheap.h"
#include "rtpglobs.h"

#include "rtpreg.h"

RtpReg_t         g_RtpReg;
RtpReg_t        *g_pRtpReg = (RtpReg_t *)NULL;

/*
 * WARNING
 *
 * Note that arrays have ORDER which is to be matched with the fields
 * in RtpReg_t. ENTRY macro below describes each field in RtpReg_t
 * RESPECTING the ORDER
 * */

#define RTP_KEY_OPEN_FLAGS (KEY_QUERY_VALUE|KEY_ENUMERATE_SUB_KEYS)

/*
      3                   2                   1                 
    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |O|C| Max Size  | Path  |             |W|       Offset          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    v v \----v----/ \--v--/ \-----v-----/ v \----------v----------/
    | |      |         |          |       |            |
    | |      |         |          |       |        Offset (12)
    | |      |         |          |       | 
    | |      |         |          |     DWORD/TCHAR* flag (1)
    | |      |         |          |
    | |      |         |       Unused (7)
    | |      |         |
    | |      |      Key and Registry path index (4)
    | |      |
    | |   Maximum size in 16 bytes blocks (6)
    | |
    | Registry Close flag (1)
    |     
    Registry Open flag (1)
*/
/*
 * Encoding macros
 */
/* Offset to field */
#define OFF(_f) ( (DWORD) ((ULONG_PTR) &((RtpReg_t *)0)->_f) )

/* REG(RegOpen flag, key path, RegClose flag, max size in TCHARs) */
#define SIZ(_s) ((((_s) * sizeof(TCHAR)) >> 4) << 24)
#define REG(_fo, _p, _fc, _s) \
        (((_fo) << 31) | ((_fc) << 30) | ((_p) << 20) | SIZ(_s))

/* ENTRY(REG, DWORD/TCHAR, Offset) */
#define ENTRY(_r, _w, _o) ((_r) | ((_w) << 12) | (_o))
/*
 * Decoding macros
 * */
#define REGOPEN(_ctrl)    (RtpBitTest(_ctrl, 31))
#define REGCLOSE(_ctrl)   (RtpBitTest(_ctrl, 30))
#define REGDWORD(_ctrl)   (RtpBitTest(_ctrl, 12))
#define REGMAXSIZE(_ctrl) ((_ctrl >> 20) & 0x3f0)
#define REGKEY(_ctrl)     g_hRtpKey[((_ctrl >> 20) & 0xf)]
#define REGPATH(_ctrl)    g_psRtpRegPath[((_ctrl >> 20) & 0xf)]
#define REGOFFSET(_ctrl)  (_ctrl & 0xfff)

#define PDW(_ptr, _ctrl)  ((DWORD  *) ((char *)_ptr + REGOFFSET(_ctrl)))       
#define PTC(_ptr, _ctrl)  ((TCHAR **) ((char *)_ptr + REGOFFSET(_ctrl)))       

/* Key for each group */
const HKEY             g_hRtpKey[] =
{
    /* Address     */ HKEY_CURRENT_USER,
    /* QOS         */ HKEY_CURRENT_USER,
    /* SdesInfo    */ HKEY_CURRENT_USER,
    /* Crypto      */ HKEY_CURRENT_USER,
    /* Events      */ HKEY_CURRENT_USER,
    /* Playout     */ HKEY_CURRENT_USER,
    /* Red         */ HKEY_CURRENT_USER,
    /* Losses      */ HKEY_CURRENT_USER,
    /* Band est    */ HKEY_CURRENT_USER,
    /* Net quality */ HKEY_CURRENT_USER,
    /*             */ (HKEY)NULL
};

/* Registry path name for each group */
const TCHAR           *g_psRtpRegPath[] =
{
    _T("RTP\\Generic"),  /* Default IP address and port */
    _T("RTP\\QOS"),      /* QOS enable/disable */
    _T("RTP\\SdesInfo"), /* SDES information */
    _T("RTP\\Crypto"),   /* Crypto information */
    _T("RTP\\Events"),   /* Events */
    _T("RTP\\Playout"),  /* Playout */
    _T("RTP\\Red"),      /* Redundancy */
    _T("RTP\\GenLosses"),/* Losses */
    _T("RTP\\BandEstimation"),/* Bandwidth estimation */
    _T("RTP\\NetQuality"),/*  Network quality */
    NULL
};

/* Registry key names for all groups.
 *
 * WARNING
 *
 * Each name in g_psRtpRegFields MUST match an ENTRY in
 * g_dwRegistryControl
 * */
const TCHAR           *g_psRtpRegFields[] =
{
    /* Generic */
    _T("DefaultIPAddress"),
    _T("DefaultLocalPort"),
    _T("DefaultRemotePort"),
    _T("LoopbackMode"),

    /* QOS */
    _T("Enable"),
    _T("Flags"),
    _T("RsvpStyle"),
    _T("MaxParticipants"),
    _T("SendMode"),
    _T("PayloadType"),
    _T("AppName"),
    _T("AppGUID"),
    _T("PolicyLocator"),
    
    /* SDES */
    _T("Enable"),
    _T("CNAME"),
    _T("NAME"),
    _T("EMAIL"),
    _T("PHONE"),
    _T("LOC"),
    _T("TOOL"),
    _T("NOTE"),
    _T("PRIV"),
    _T("BYE"),
    
    /* Crypto */
    _T("Enable"),
    _T("Mode"),
    _T("HashAlg"),
    _T("DataAlg"),
    _T("PassPhrase"),

    /* Events */
    _T("Receiver"),
    _T("Sender"),
    _T("Rtp"),
    _T("PInfo"),
    _T("Qos"),
    _T("Sdes"),

    /* Playout */
    _T("Enable"),
    _T("MinPlayout"),
    _T("MaxPlayout"),
    
    /* Redundancy */
    _T("Enable"),
    _T("PT"),
    _T("InitialDistance"),
    _T("MaxDistance"),
    _T("EarlyTimeout"),
    _T("EarlyPost"),
    _T("Threshold0"),
    _T("Threshold1"),
    _T("Threshold2"),
    _T("Threshold3"),

    /* Losses */
    _T("Enable"),
    _T("RecvLossRate"),
    _T("SendLossRate"),

    /* Bandwidth estimation */
    _T("Enable"),
    _T("Modulo"),
    _T("TTL"),
    _T("WaitEstimation"),
    _T("MaxGap"),
    _T("Bin0"),
    _T("Bin1"),
    _T("Bin2"),
    _T("Bin3"),
    _T("Bin4"),

    /* Network quality */
    _T("Enable"),
    
    NULL
};

#define DW      1   /* DWORD   */
#define TC      0   /* TCHAR * */

/* Registry Entries
 *
 * WARNING
 *
 * Each name in g_psRtpRegFields (above) MUST match an ENTRY in
 * g_dwRegistryControl
 * */
const DWORD g_dwRegistryControl[] =
{
    /* ENTRY(REG(Open,Path,Close,Size), DWORD/TCHAR, Offset) */
    /* Address */
    ENTRY(REG(1,0,0, 16), TC,  OFF(psDefaultIPAddress)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwDefaultLocalPort)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwDefaultRemotePort)),
    ENTRY(REG(0,0,1,  0), DW,  OFF(dwMcastLoopbackMode)),

    /* QOS */
    ENTRY(REG(1,1,0,  0), DW,  OFF(dwQosEnable)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwQosFlags)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwQosRsvpStyle)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwQosMaxParticipants)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwQosSendMode)),
    ENTRY(REG(0,0,0, 16), TC,  OFF(psQosPayloadType)),
    ENTRY(REG(0,0,0,128), TC,  OFF(psQosAppName)),
    ENTRY(REG(0,0,0,128), TC,  OFF(psQosAppGUID)),
    ENTRY(REG(0,0,1,128), TC,  OFF(psQosPolicyLocator)),

    /* SDES */
    ENTRY(REG(1,2,0,  0), DW,  OFF(dwSdesEnable)),
    ENTRY(REG(0,0,0,256), TC,  OFF(psCNAME)),
    ENTRY(REG(0,0,0,256), TC,  OFF(psNAME)),
    ENTRY(REG(0,0,0,256), TC,  OFF(psEMAIL)),
    ENTRY(REG(0,0,0,256), TC,  OFF(psPHONE)),
    ENTRY(REG(0,0,0,256), TC,  OFF(psLOC)),
    ENTRY(REG(0,0,0,256), TC,  OFF(psTOOL)),
    ENTRY(REG(0,0,0,256), TC,  OFF(psNOTE)),
    ENTRY(REG(0,0,0,256), TC,  OFF(psPRIV)),
    ENTRY(REG(0,0,1,256), TC,  OFF(psBYE)),

    /* Crypto */
    ENTRY(REG(1,3,0,  0), DW,  OFF(dwCryptEnable)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwCryptMode)),
    ENTRY(REG(0,0,0, 16), TC,  OFF(psCryptHashAlg)),
    ENTRY(REG(0,0,0, 16), TC,  OFF(psCryptDataAlg)),
    ENTRY(REG(0,0,1,256), TC,  OFF(psCryptPassPhrase)),

    /* Events */
    ENTRY(REG(1,4,0,  0), DW,  OFF(dwEventsReceiver)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwEventsSender)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwEventsRtp)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwEventsPInfo)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwEventsQos)),
    ENTRY(REG(0,0,1,  0), DW,  OFF(dwEventsSdes)),

    /* Playout delay */
    ENTRY(REG(1,5,0,  0), DW,  OFF(dwPlayoutEnable)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwMinPlayout)),
    ENTRY(REG(0,0,1,  0), DW,  OFF(dwMaxPlayout)),
    
    /* Redundancy */
    ENTRY(REG(1,6,0,  0), DW,  OFF(dwRedEnable)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwRedPT)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwInitialRedDistance)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwMaxRedDistance)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwRedEarlyTimeout)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwRedEarlyPost)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwLossRateThresh0)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwLossRateThresh1)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwLossRateThresh2)),
    ENTRY(REG(0,0,1,  0), DW,  OFF(dwLossRateThresh3)),

    /* GenLosses */
    ENTRY(REG(1,7,0,  0), DW,  OFF(dwGenLossEnable)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwRecvLossRate)),
    ENTRY(REG(0,0,1,  0), DW,  OFF(dwSendLossRate)),
  
    /* Bandwidth estimation */
    ENTRY(REG(1,8,0,  0), DW,  OFF(dwBandEstEnable)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwBandEstModulo)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwBandEstTTL)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwBandEstWait)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwBandEstMaxGap)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwBandEstBin0)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwBandEstBin1)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwBandEstBin2)),
    ENTRY(REG(0,0,0,  0), DW,  OFF(dwBandEstBin3)),
    ENTRY(REG(0,0,1,  0), DW,  OFF(dwBandEstBin4)),

    /* Network quality */
    ENTRY(REG(1,9,1,  0), DW,  OFF(dwNetQualityEnable)),
    
    /* End */
    0
};

void *RtpRegCopy(TCHAR **dst, TCHAR *src, DWORD dwSize);

void RtpRegSetDefaults(RtpReg_t *pRrtpReg);

void RtpRegistryInit(RtpReg_t *pRtpReg)
{
    DWORD            dwError;
    HKEY             hk;
    unsigned long    hkDataType;
    BYTE             hkData[128*sizeof(TCHAR_t)];
    unsigned long    hkDataSize;
    DWORD            dwVal;
    DWORD            i;
    DWORD            dwControl;

    /* Initialize structure */
    for(i = 0; g_dwRegistryControl[i]; i++)
    {
        dwControl = g_dwRegistryControl[i];
        if (REGDWORD(dwControl))
        {
            *PDW(pRtpReg, dwControl) = RTPREG_NOVALUESET;
        }
        else
        {
            *PTC(pRtpReg, dwControl) = (TCHAR *)NULL;
        }
    }

    /* Assign defaults */
    RtpRegSetDefaults(pRtpReg);

    /* Read registry and assign values to g_RtpReg */
    for(i = 0; g_dwRegistryControl[i]; i++)
    {
        dwControl = g_dwRegistryControl[i];

        if (REGOPEN(dwControl))
        {
            /* Open root key (Group, i.e. addr, qos, sdes, etc)) */
            dwError = RegOpenKeyEx(REGKEY(dwControl),
                                   REGPATH(dwControl),
                                   0,
                                   RTP_KEY_OPEN_FLAGS,
                                   &hk);
    
            if (dwError !=  ERROR_SUCCESS)
            {
                /* Move forward to next close */
                while(!REGCLOSE(dwControl))
                {
                    i++;
                    dwControl = g_dwRegistryControl[i];
                }

                continue;
            }
        }

        /* Read each key value in group */
        while(1)
        {
            /* Read key */
            hkDataSize = sizeof(hkData);
            dwError = RegQueryValueEx(hk,
                                      g_psRtpRegFields[i],
                                      0,
                                      &hkDataType,
                                      hkData,
                                      &hkDataSize);
            
            if (dwError == ERROR_SUCCESS)
            {
                /* Set read value in RtpReg_t */
                if (REGDWORD(dwControl))
                {
                    *PDW(pRtpReg, dwControl) = *(DWORD *)hkData;
                }
                else
                {
                    if ( (hkDataSize > sizeof(TCHAR)) &&
                         (hkDataSize <= REGMAXSIZE(dwControl)) )
                    {
                        RtpRegCopy(PTC(pRtpReg, dwControl),
                                   (TCHAR *)hkData,
                                   hkDataSize);
                    }
                }
            }

            if (REGCLOSE(dwControl))
            {
                break;
            }

            i++;
            dwControl = g_dwRegistryControl[i];
        }

        RegCloseKey(hk);
    }

    /* Initialize some global variables that depend on the registry
     * readings */
    RtpSetRedParametersFromRegistry();
    RtpSetMinMaxPlayoutFromRegistry();
    RtpSetBandEstFromRegistry();
}

/* Release the memory for al the TCHAR* type fields */
void RtpRegistryDel(RtpReg_t *pRtpReg)
{
    DWORD            i;
    DWORD            dwControl;
    TCHAR          **ppTCHAR;

    for(i = 0; g_dwRegistryControl[i]; i++)
    {
        dwControl = g_dwRegistryControl[i];

        if (!REGDWORD(dwControl))
        {
            ppTCHAR = PTC(pRtpReg, dwControl);

            if (*ppTCHAR)
            {
                RtpHeapFree(g_pRtpGlobalHeap, *ppTCHAR);

                *ppTCHAR = (TCHAR *)NULL;
            }
        }
    }
}

void RtpRegSetDefaults(RtpReg_t *pRtpReg)
{
    /*
     * Default address and port
     * */
    /* 224.5.5.0/10000 */
    RtpRegCopy(&pRtpReg->psDefaultIPAddress,
               _T("224.5.5.3"),
               0);
    pRtpReg->dwDefaultLocalPort  = 10000;
    pRtpReg->dwDefaultRemotePort = 10000;
}

void *RtpRegCopy(TCHAR **dst, TCHAR *src, DWORD dwSize)
{
    if (*dst)
    {
        RtpHeapFree(g_pRtpGlobalHeap, *dst);
    }

    if (!dwSize)
    {
        /* Get the size in bytes (including the NULL terminating
         * character) */
        dwSize = (lstrlen(src) + 1) * sizeof(TCHAR);
    }
    
    *dst = RtpHeapAlloc(g_pRtpGlobalHeap, dwSize);

    if (*dst)
    {
        CopyMemory(*dst, src, dwSize);
    }

    return(*dst);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\misc\rtpque.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpque.h
 *
 *  Abstract:
 *
 *    Queues and Hash implementation
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/24 created
 *
 **********************************************************************/

#include "gtypes.h"
#include "rtpque.h"

/*
 * The queue/hash support uses the same structure to keep items in a
 * queue or a hash.
 *
 * A queue is just a circular double linked list.
 *
 * A hash includes a hash table, and each entry is either the head of
 * another hash table or a queue's head. Items in a hash will end
 * always in a queue. A queue will become a new hash when a size of
 * MAX_QUEUE2HASH_ITEMS is reached. A hash will be destroyed (become a
 * queue) once it is emptied.
 *
 * All the functions return either a pointer to the item
 * enqueud/inserted or the item just dequeued/removed. If an error
 * condition is detected, NULL is returned. */

/*
 * Queue functions
 */

/* enqueue after pPos item */
RtpQueueItem_t *enqueuea(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem,
        RtpQueueItem_t  *pPos
    )
{
    BOOL             bOk;
    DWORD            dwError;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpQueue_t      *pPospHead;
    RtpQueue_t      *pItempHead;

    TraceFunctionName("enqueuea");  

    dwError = NOERROR;
    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    pPospHead = (RtpQueue_t *)NULL;
    pItempHead = (RtpQueue_t *)NULL;
    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }
    
    if (bOk)
    {
        if (!pHead || !pHead->pFirst || !pItem || !pPos)
        {
            dwError = RTPERR_POINTER;
            goto error;
        }

        if (pPos->pHead != pHead || pItem->pHead)
        {
            pPospHead = pPos->pHead;
            pItempHead = pItem->pHead;
            dwError = RTPERR_INVALIDSTATE;
            goto error;
        }

        pItem->pNext = pPos->pNext;
        pItem->pPrev = pPos;
        pPos->pNext->pPrev = pItem;
        pPos->pNext = pItem;
        pHead->lCount++;

        pItem->pHead = pHead;

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }

        pRtpQueueItem = pItem;
    }
    
    return(pRtpQueueItem);

 error:
    if (pRtpCritSect)
    {
        RtpLeaveCriticalSection(pRtpCritSect);
    }
    
    if (dwError == RTPERR_INVALIDSTATE)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_ENQUEUE,
                _T("%s: failed: pPos->pHead[0x%p] != pHead[0x%p] || ")
                _T("pItem->pHead[0x%p]"),
                _fname, pPospHead, pHead, pItempHead
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_ENQUEUE,
                _T("%s: pHead[0x%p] failed: %s (0x%X"),
                _fname, pHead, RTPERR_TEXT(dwError), dwError
            ));
    }
    
    return(pRtpQueueItem);
}

/* enqueue before pPos item */
RtpQueueItem_t *enqueueb(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem,
        RtpQueueItem_t  *pPos
    )
{
    BOOL             bOk;
    DWORD            dwError;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpQueue_t      *pPospHead;
    RtpQueue_t      *pItempHead;
    
    TraceFunctionName("enqueueb");  

    dwError = NOERROR;
    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    pPospHead = (RtpQueue_t *)NULL;
    pItempHead = (RtpQueue_t *)NULL;
    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }

    if (bOk)
    {
        if (!pHead || !pHead->pFirst || !pItem || !pPos)
        {
            dwError = RTPERR_POINTER;
            goto error;
        }

        if (pPos->pHead != pHead || pItem->pHead)
        {
            pPospHead = pPos->pHead;
            pItempHead = pItem->pHead;
            dwError = RTPERR_INVALIDSTATE;
            goto error;
        }

        pItem->pNext = pPos;
        pItem->pPrev = pPos->pPrev;
        pPos->pPrev->pNext = pItem;
        pPos->pPrev = pItem;
        pHead->lCount++;

        pItem->pHead = pHead;

        if (pHead->pFirst == pPos)
        {
            /* update first item */
            pHead->pFirst = pItem;
        }

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }

        pRtpQueueItem = pItem;
    }
    
    return(pRtpQueueItem);

 error:
    if (pRtpCritSect)
    {
        RtpLeaveCriticalSection(pRtpCritSect);
    }
    
    if (dwError == RTPERR_INVALIDSTATE)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_ENQUEUE,
                _T("%s: failed: pPos->pHead[0x%p] != pHead[0x%p] || ")
                _T("pItem->pHead[0x%p]"),
                _fname, pPospHead, pHead, pItempHead
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_ENQUEUE,
                _T("%s: pHead[0x%p] failed: %s (0x%X"),
                _fname, pHead, RTPERR_TEXT(dwError), dwError
            ));
    }
    
    return(pRtpQueueItem);
}

/* enqueue as first */
RtpQueueItem_t *enqueuef(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    )
{
    BOOL             bOk;
    DWORD            dwError;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpQueue_t      *pItempHead;

    TraceFunctionName("enqueuef");  

    dwError = NOERROR;
    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    pItempHead = (RtpQueue_t *)NULL;
    bOk = TRUE;

    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }

    if (bOk)
    {
        if (!pHead || !pItem)
        {
            dwError = RTPERR_POINTER;
            goto error;
        }
    
        if (pItem->pHead)
        {
            pItempHead = pItem->pHead;
            dwError = RTPERR_INVALIDSTATE;
            goto error;
        }

        if (pHead->pFirst)
        {
            /* not empty */
            pItem->pNext = pHead->pFirst;
            pItem->pPrev = pHead->pFirst->pPrev;
            pItem->pPrev->pNext = pItem;
            pItem->pNext->pPrev = pItem;
            pHead->pFirst = pItem;
            pHead->lCount++;
        }
        else
        {
            /* empty */
            pHead->lCount = 1;
            pHead->pFirst = pItem;
            pItem->pNext  = pItem;
            pItem->pPrev  = pItem;
        }

        pItem->pHead = pHead;
    
        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }

        pRtpQueueItem = pItem;
    }
    
    return(pRtpQueueItem);

 error:
    if (pRtpCritSect)
    {
        RtpLeaveCriticalSection(pRtpCritSect);
    }
    
    if (dwError == RTPERR_INVALIDSTATE)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_ENQUEUE,
                _T("%s: failed: pItem->pHead[0x%p]"),
                _fname, pItempHead
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_ENQUEUE,
                _T("%s: pHead[0x%p] failed: %s (0x%X"),
                _fname, pHead, RTPERR_TEXT(dwError), dwError
            ));
    }

    return(pRtpQueueItem);
}

/* enqueue at the end */
RtpQueueItem_t *enqueuel(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    )
{
    BOOL             bOk;
    DWORD            dwError;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpQueue_t      *pItempHead;

    TraceFunctionName("enqueuel");  

    dwError = NOERROR;
    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    pItempHead = (RtpQueue_t *)NULL;
    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }
    
    if (bOk)
    {
        if (!pHead || !pItem)
        {
            dwError = RTPERR_POINTER;
            goto error;
        }

        if (pItem->pHead)
        {
            pItempHead = pItem->pHead;
            dwError = RTPERR_INVALIDSTATE;
            goto error;
        }
    
        if (pHead->pFirst)
        {
            /* not empty */
            pItem->pNext = pHead->pFirst;
            pItem->pPrev = pHead->pFirst->pPrev;
            pItem->pPrev->pNext = pItem;
            pItem->pNext->pPrev = pItem;
            pHead->lCount++;
        }
        else
        {
            /* empty */
            pHead->lCount = 1;
            pHead->pFirst = pItem;
            pItem->pNext  = pItem;
            pItem->pPrev  = pItem;
        }

        pItem->pHead = pHead;
    
        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }

        pRtpQueueItem = pItem;
    }
    
    return(pRtpQueueItem);

 error:
    if (pRtpCritSect)
    {
        RtpLeaveCriticalSection(pRtpCritSect);
    }
    
    if (dwError == RTPERR_INVALIDSTATE)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_ENQUEUE,
                _T("%s: failed: pItem->pHead[0x%p]"),
                _fname, pItempHead
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_ENQUEUE,
                _T("%s: pHead[0x%p] failed: %s (0x%X"),
                _fname, pHead, RTPERR_TEXT(dwError), dwError
            ));
    }

    return(pRtpQueueItem);
}

/* dequeue item pItem */
RtpQueueItem_t *dequeue(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    )
{
    BOOL             bOk;
    DWORD            dwError;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpQueue_t      *pItempHead;

    TraceFunctionName("dequeue");  

    dwError = NOERROR;
    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    pItempHead = (RtpQueue_t *)NULL;
    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }
    
    if (bOk)
    {
        if (!pHead || !pItem)
        {
            dwError = RTPERR_POINTER;
            goto error;
        }
        
        if (pItem->pHead != pHead)
        {
            pItempHead = pItem->pHead;
            dwError = RTPERR_INVALIDSTATE;
            goto error;
        }

        if (pHead->lCount > 1)
        {
            /* 2 or more items */
            if (pHead->pFirst == pItem)
            {
                pHead->pFirst = pItem->pNext;
            }
            pItem->pPrev->pNext = pItem->pNext;
            pItem->pNext->pPrev = pItem->pPrev;
            pHead->lCount--;
        }
        else
        {
            /* just 1 item */
            pHead->pFirst = (RtpQueueItem_t *)NULL;
            pHead->lCount = 0;
        }

        pItem->pNext = (RtpQueueItem_t *)NULL;
        pItem->pPrev = (RtpQueueItem_t *)NULL;
        pItem->pHead = NULL;

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }
    
        pRtpQueueItem = pItem;
    }
    
    return(pRtpQueueItem);

 error:
    if (pRtpCritSect)
    {
        RtpLeaveCriticalSection(pRtpCritSect);
    }
    
    if (dwError == RTPERR_INVALIDSTATE)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_DEQUEUE,
                _T("%s: failed: pHead[0x%p] != pItem->pHead[0x%p]"),
                _fname, pHead, pItempHead
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_DEQUEUE,
                _T("%s: pHead[0x%p] failed: %s (0x%X"),
                _fname, pHead, RTPERR_TEXT(dwError), dwError
            ));
    }

    return(pRtpQueueItem);
}

/* dequeue first item */
RtpQueueItem_t *dequeuef(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect
    )
{
    BOOL             bOk;
    DWORD            dwError;
    RtpQueueItem_t  *pItem;
    RtpQueueItem_t  *pRtpQueueItem;

    TraceFunctionName("dequeuef");  

    dwError = NOERROR;
    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }
    
    if (bOk)
    {
        if (!pHead)
        {
            dwError = RTPERR_POINTER;
            goto error;
        }
    
        pItem = pHead->pFirst;
    
        if (!pItem)
        {
            goto error;
        }
            
        if (pHead->lCount > 1)
        {
            /* 2 or more items */
            pHead->pFirst = pItem->pNext;
            pItem->pPrev->pNext = pItem->pNext;
            pItem->pNext->pPrev = pItem->pPrev;
            pHead->lCount--;
        }
        else
        {
            /* just 1 item */
            pHead->pFirst = (RtpQueueItem_t *)NULL;
            pHead->lCount = 0;
        }

        pItem->pNext = (RtpQueueItem_t *)NULL;
        pItem->pPrev = (RtpQueueItem_t *)NULL;
        pItem->pHead = NULL;

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }
    
        pRtpQueueItem = pItem;
    }
    
    return(pRtpQueueItem);

 error:
    if (pRtpCritSect)
    {
        RtpLeaveCriticalSection(pRtpCritSect);
    }
   
    if (dwError == NOERROR)
    {
        TraceRetail((
                CLASS_WARNING, GROUP_QUEUE, S_QUEUE_DEQUEUE,
                _T("%s: pHead[0x%p] failed: empty"),
                _fname, pHead
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_DEQUEUE,
                _T("%s: pHead[0x%p] failed: %s (0x%X"),
                _fname, pHead, RTPERR_TEXT(dwError), dwError
            ));
    }

    return(pRtpQueueItem);
}

/* dequeue last item */
RtpQueueItem_t *dequeuel(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect
    )
{
    BOOL             bOk;
    DWORD            dwError;
    RtpQueueItem_t  *pItem;
    RtpQueueItem_t  *pRtpQueueItem;

    TraceFunctionName("dequeuel");  

    dwError = NOERROR;
    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }
    
    if (bOk)
    {
        if (!pHead)
        {
            dwError = RTPERR_POINTER;
            goto error;
        }

        if (!pHead->pFirst)
        {
            goto error;
        }

        pItem = pHead->pFirst->pPrev;
    
        if (pHead->lCount > 1)
        {
            /* 2 or more items */
            pItem->pPrev->pNext = pItem->pNext;
            pItem->pNext->pPrev = pItem->pPrev;
            pHead->lCount--;
        }
        else
        {
            /* just 1 item */
            pHead->pFirst = (RtpQueueItem_t *)NULL;
            pHead->lCount = 0;
        }

        pItem->pNext = (RtpQueueItem_t *)NULL;
        pItem->pPrev = (RtpQueueItem_t *)NULL;
        pItem->pHead = NULL;

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }
    
        pRtpQueueItem = pItem;
    }
    
    return(pRtpQueueItem);
    
 error:
    if (pRtpCritSect)
    {
        RtpLeaveCriticalSection(pRtpCritSect);
    }
   
    if (dwError == NOERROR)
    {
        TraceRetail((
                CLASS_WARNING, GROUP_QUEUE, S_QUEUE_DEQUEUE,
                _T("%s: pHead[0x%p] failed: empty"),
                _fname, pHead
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_DEQUEUE,
                _T("%s: pHead[0x%p] failed: %s (0x%X"),
                _fname, pHead, RTPERR_TEXT(dwError), dwError
            ));
    }

    return(pRtpQueueItem);
}

/* move item so it becomes the first one in the queue */
RtpQueueItem_t *move2first(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    )
{
    BOOL             bOk;
    DWORD            dwError;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpQueue_t      *pItempHead;
    
    TraceFunctionName("move2first");  

    dwError = NOERROR;
    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    pItempHead = (RtpQueue_t *)NULL;
    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }
    
    if (bOk)
    {
        if (!pHead || !pItem)
        {
            dwError = RTPERR_POINTER;
            goto error;
        }

        if (pItem->pHead != pHead)
        {
            pItempHead = pItem->pHead;
            dwError = RTPERR_INVALIDSTATE;
            goto error;
        }

        if (pHead->pFirst->pPrev == pItem)
        {
            /* Item is last one, just move pFirst 1 place */
            pHead->pFirst = pHead->pFirst->pPrev;
        }
        else if (pHead->pFirst != pItem)
        {
            /* Item is not already the first one */
            
            /* dequeue */
            pItem->pPrev->pNext = pItem->pNext;
            pItem->pNext->pPrev = pItem->pPrev;

            /* enqueue as first */
            pItem->pNext = pHead->pFirst;
            pItem->pPrev = pHead->pFirst->pPrev;
            pItem->pPrev->pNext = pItem;
            pItem->pNext->pPrev = pItem;
            pHead->pFirst = pItem;
        }

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }

        pRtpQueueItem = pItem;
    }
    
    return(pRtpQueueItem);

 error:
    if (pRtpCritSect)
    {
        RtpLeaveCriticalSection(pRtpCritSect);
    }
    
    if (dwError == RTPERR_INVALIDSTATE)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_MOVE,
                _T("%s: failed: pHead[0x%p] != pItem->pHead[0x%p]"),
                _fname, pHead, pItempHead
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_MOVE,
                _T("%s: pHead[0x%p] failed: %s (0x%X"),
                _fname, pHead, RTPERR_TEXT(dwError), dwError
            ));
    }

    return(pRtpQueueItem);
}

/* move item so it becomes the last one in the queue */
RtpQueueItem_t *move2last(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    )
{
    BOOL             bOk;
    DWORD            dwError;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpQueue_t      *pItempHead;

    TraceFunctionName("move2last");  

    dwError = NOERROR;
    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    pItempHead = (RtpQueue_t *)NULL;
    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }
    
    if (bOk)
    {
        if (!pHead || !pItem)
        {
            dwError = RTPERR_POINTER;
            goto error;
        }

        if (pItem->pHead != pHead)
        {
            pItempHead = pItem->pHead;
            dwError = RTPERR_INVALIDSTATE;
            goto error;
        }

        if (pHead->pFirst == pItem)
        {
            /* Item is first one, just move pFirst 1 place */
            pHead->pFirst = pHead->pFirst->pNext;
        }
        else if (pHead->pFirst->pPrev != pItem)
        {
            /* Item is not already the last one */
            
            /* dequeue */
            pItem->pPrev->pNext = pItem->pNext;
            pItem->pNext->pPrev = pItem->pPrev;

            /* enqueue as last */
            pItem->pNext = pHead->pFirst;
            pItem->pPrev = pHead->pFirst->pPrev;
            pItem->pPrev->pNext = pItem;
            pItem->pNext->pPrev = pItem;
        }

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }

        pRtpQueueItem = pItem;
    }
    
    return(pRtpQueueItem);

 error:
    if (pRtpCritSect)
    {
        RtpLeaveCriticalSection(pRtpCritSect);
    }
    
    if (dwError == RTPERR_INVALIDSTATE)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_MOVE,
                _T("%s: failed: pHead[0x%p] != pItem->pHead[0x%p]"),
                _fname, pHead, pItempHead
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_MOVE,
                _T("%s: pHead[0x%p] failed: %s (0x%X"),
                _fname, pHead, RTPERR_TEXT(dwError), dwError
            ));
    }

    return(pRtpQueueItem);
}

/* move item from FromQ to the beginning of ToQ */
RtpQueueItem_t *move2qf(
        RtpQueue_t      *pToQ,
        RtpQueue_t      *pFromQ,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    )
{
    BOOL             bOk;
    DWORD            dwError;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpQueue_t      *pItempHead;

    TraceFunctionName("move2qf");  

    dwError = NOERROR;
    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    pItempHead = (RtpQueue_t *)NULL;
    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }

    if (bOk)
    {
        if (!pToQ || !pFromQ || !pItem)
        {
            dwError = RTPERR_POINTER;
            goto error;
        }

        if (pItem->pHead != pFromQ)
        {
            pItempHead = pItem->pHead;
            dwError = RTPERR_INVALIDSTATE;
            goto error;
        }

        /* Remove from FromQ */
        if (pFromQ->lCount > 1)
        {
            /* 2 or more items */
            if (pFromQ->pFirst == pItem)
            {
                pFromQ->pFirst = pItem->pNext;
            }
            pItem->pPrev->pNext = pItem->pNext;
            pItem->pNext->pPrev = pItem->pPrev;
            pFromQ->lCount--;
        }
        else
        {
            /* just 1 item */
            pFromQ->pFirst = (RtpQueueItem_t *)NULL;
            pFromQ->lCount = 0;
        }

        /* Add to the beginning of ToQ */
        if (pToQ->pFirst)
        {
            /* not empty */
            pItem->pNext = pToQ->pFirst;
            pItem->pPrev = pToQ->pFirst->pPrev;
            pItem->pPrev->pNext = pItem;
            pItem->pNext->pPrev = pItem;
            pToQ->pFirst = pItem;
            pToQ->lCount++;
        }
        else
        {
            /* empty */
            pToQ->lCount = 1;
            pToQ->pFirst = pItem;
            pItem->pNext  = pItem;
            pItem->pPrev  = pItem;
        }

        pItem->pHead = pToQ;

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }

        pRtpQueueItem = pItem;
    }
    
    return(pRtpQueueItem);

 error:
    if (pRtpCritSect)
    {
        RtpLeaveCriticalSection(pRtpCritSect);
    }
    
    if (dwError == RTPERR_INVALIDSTATE)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_MOVE,
                _T("%s: failed: pFromQ[0x%p] != pItem->pHead[0x%p]"),
                _fname, pFromQ, pItempHead
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_MOVE,
                _T("%s: pToQ[0x%p] pFromQ[0x%p] failed: %s (0x%X"),
                _fname, pToQ, pFromQ, RTPERR_TEXT(dwError), dwError
            ));
    }

    return(pRtpQueueItem);
}

/* move item from FromQ to the end of ToQ */
RtpQueueItem_t *move2ql(
        RtpQueue_t      *pToQ,
        RtpQueue_t      *pFromQ,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    )
{
    BOOL             bOk;
    DWORD            dwError;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpQueue_t      *pItempHead;

    TraceFunctionName("move2ql");  

    dwError = NOERROR;
    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    pItempHead = (RtpQueue_t *)NULL;
    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }

    if (bOk)
    {
        if (!pToQ || !pFromQ || !pItem)
        {
            dwError = RTPERR_POINTER;
            goto error;
        }

        if (pItem->pHead != pFromQ)
        {
            pItempHead = pItem->pHead;
            dwError = RTPERR_INVALIDSTATE;
            goto error;
        }

        /* Remove from FromQ */
        if (pFromQ->lCount > 1)
        {
            /* 2 or more items */
            if (pFromQ->pFirst == pItem)
            {
                pFromQ->pFirst = pItem->pNext;
            }
            pItem->pPrev->pNext = pItem->pNext;
            pItem->pNext->pPrev = pItem->pPrev;
            pFromQ->lCount--;
        }
        else
        {
            /* just 1 item */
            pFromQ->pFirst = (RtpQueueItem_t *)NULL;
            pFromQ->lCount = 0;
        }

        /* Add to the end of ToQ */
        if (pToQ->pFirst)
        {
            /* not empty */
            pItem->pNext = pToQ->pFirst;
            pItem->pPrev = pToQ->pFirst->pPrev;
            pItem->pPrev->pNext = pItem;
            pItem->pNext->pPrev = pItem;
            pToQ->lCount++;
        }
        else
        {
            /* empty */
            pToQ->lCount = 1;
            pToQ->pFirst = pItem;
            pItem->pNext  = pItem;
            pItem->pPrev  = pItem;
        }

        pItem->pHead = pToQ;

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }

        pRtpQueueItem = pItem;
    }
    
    return(pRtpQueueItem);

 error:
    if (pRtpCritSect)
    {
        RtpLeaveCriticalSection(pRtpCritSect);
    }
    
    if (dwError == RTPERR_INVALIDSTATE)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_MOVE,
                _T("%s: failed: pFromQ[0x%p] != pItem->pHead[0x%p]"),
                _fname, pFromQ, pItempHead
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_MOVE,
                _T("%s: pToQ[0x%p] pFromQ[0x%p] failed: %s (0x%X"),
                _fname, pToQ, pFromQ, RTPERR_TEXT(dwError), dwError
            ));
    }

    return(pRtpQueueItem);
}


/* find first item that matches the pvOther parameter */
RtpQueueItem_t *findQO(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        void            *pvOther
    )
{
    BOOL             bOk;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpQueueItem_t  *pRtpQueueItem2;
    long             lCount;

    TraceFunctionName("findQO");  

    pRtpQueueItem2 = (RtpQueueItem_t *)NULL;

    if (!pHead)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_MOVE,
                _T("%s: NULL pointer"),
                _fname
            ));
        
        return(pRtpQueueItem2);
    }

    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }
    
    if (bOk)
    {
        for(pRtpQueueItem = pHead->pFirst, lCount = pHead->lCount;
            lCount > 0;
            pRtpQueueItem = pRtpQueueItem->pNext, lCount--)
        {

            if (pRtpQueueItem->pvOther == pvOther)
            {
                pRtpQueueItem2 = pRtpQueueItem;
                break;
            }
        }

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }
    }
    
    return(pRtpQueueItem2);
}

/* find first item that matches the dwKey parameter */
RtpQueueItem_t *findQdwK(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        DWORD            dwKey
    )
{
    BOOL             bOk;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpQueueItem_t  *pRtpQueueItem2;
    long             lCount;

    TraceFunctionName("findQdwK");  

    pRtpQueueItem2 = (RtpQueueItem_t *)NULL;

    if (!pHead)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_MOVE,
                _T("%s: NULL pointer"),
                _fname
            ));
        
        return(pRtpQueueItem2);
    }
    
    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }
    
    if (bOk)
    {
        for(pRtpQueueItem = pHead->pFirst, lCount = pHead->lCount;
            lCount > 0;
            pRtpQueueItem = pRtpQueueItem->pNext, lCount--)
        {
            if (pRtpQueueItem->dwKey == dwKey)
            {
                pRtpQueueItem2 = pRtpQueueItem;
                break;
            }
        }

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }
    }
    
    return(pRtpQueueItem2);
}

/* find first item that matches the dKey parameter */
RtpQueueItem_t *findQdK(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        double           dKey
    )
{
    BOOL             bOk;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpQueueItem_t  *pRtpQueueItem2;
    long             lCount;

    TraceFunctionName("findQdK");  

    pRtpQueueItem2 = (RtpQueueItem_t *)NULL;

    if (!pHead)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_MOVE,
                _T("%s: NULL pointer"),
                _fname
            ));
        
        return(pRtpQueueItem2);
    }
    
    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }
    
    if (bOk)
    {
        for(pRtpQueueItem = pHead->pFirst, lCount = pHead->lCount;
            lCount > 0;
            pRtpQueueItem = pRtpQueueItem->pNext, lCount--)
        {
            if (pRtpQueueItem->dKey == dKey)
            {
                pRtpQueueItem2 = pRtpQueueItem;
                break;
            }
        }

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }
    }
    
    return(pRtpQueueItem2);
}

/* find the Nth item in the queue (items are counted 0,1,2,...) */
RtpQueueItem_t *findQN(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        long             lNth
    )
{
    BOOL             bOk;
    RtpQueueItem_t  *pRtpQueueItem;

    TraceFunctionName("findQN");  

    bOk = TRUE;
    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    
    if (!pHead)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_MOVE,
                _T("%s: NULL pointer"),
                _fname
            ));
        
        return(pRtpQueueItem);
    }
   
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }

    if (bOk)
    {
        if (GetQueueSize(pHead) > lNth)
        {
            for(pRtpQueueItem = pHead->pFirst;
                lNth > 0;
                lNth--, pRtpQueueItem = pRtpQueueItem->pNext)
            {
                /* Empty body */;
            }
        }

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }
    }

    return(pRtpQueueItem);
}


/*
 * Ordered Queue insertion
 */

/* enqueue in ascending key order */
RtpQueueItem_t *enqueuedwK(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem,
        DWORD            dwKey
    )
{
    BOOL             bOk;
    DWORD            dwError;
    long             lCount;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpQueue_t      *pItempHead;

    TraceFunctionName("enqueuedwK");  

    dwError = NOERROR;
    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    pItempHead = (RtpQueue_t *)NULL;
    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }

    if (bOk)
    {
        if (!pHead || !pItem)
        {
            dwError = RTPERR_POINTER;
            goto error;
        }

        if (pItem->pHead)
        {
            pItempHead = pItem->pHead;
            dwError = RTPERR_INVALIDSTATE;
            goto error;
        }

        pItem->dwKey = dwKey;

        for(pRtpQueueItem = pHead->pFirst, lCount = pHead->lCount;
            lCount && (dwKey >= pRtpQueueItem->dwKey);
            pRtpQueueItem = pRtpQueueItem->pNext, lCount--)
        {
            /* Empty body */ ;
        }

        if (!lCount)
        {
            enqueuel(pHead, NULL, pItem);
        }
        else
        {
            enqueueb(pHead, NULL, pItem, pRtpQueueItem);
        }
    
        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }

        pRtpQueueItem = pItem;
    }
    
    return(pRtpQueueItem);

 error:
    if (pRtpCritSect)
    {
        RtpLeaveCriticalSection(pRtpCritSect);
    }
    
    if (dwError == RTPERR_INVALIDSTATE)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_ENQUEUE,
                _T("%s: failed: pItem->pHead[0x%p]"),
                _fname, pItempHead
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_ENQUEUE,
                _T("%s: pHead[0x%p] failed: %s (0x%X"),
                _fname, pHead, RTPERR_TEXT(dwError), dwError
            ));
    }

    return(pRtpQueueItem);
}

/* enqueue in ascending key order */
RtpQueueItem_t *enqueuedK(
        RtpQueue_t      *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem,
        double           dKey
    )
{
    BOOL             bOk;
    DWORD            dwError;
    long             lCount;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpQueue_t      *pItempHead;

    TraceFunctionName("enqueuedK");  

    dwError = NOERROR;
    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    pItempHead = (RtpQueue_t *)NULL;
    bOk = TRUE;
    
    if (pRtpCritSect)
    {
        bOk = RtpEnterCriticalSection(pRtpCritSect);
    }

    if (bOk)
    {
        if (!pHead || !pItem)
        {
            dwError = RTPERR_POINTER;
            goto error;
        }

        if (pItem->pHead)
        {
            pItempHead = pItem->pHead;
            dwError = RTPERR_INVALIDSTATE;
            goto error;
        }

        pItem->dKey = dKey;

        for(pRtpQueueItem = pHead->pFirst, lCount = pHead->lCount;
            lCount && (dKey >= pRtpQueueItem->dKey);
            pRtpQueueItem = pRtpQueueItem->pNext, lCount--)
        {
            /* Empty body */ ;
        }

        if (!lCount)
        {
            enqueuel(pHead, NULL, pItem);
        }
        else
        {
            enqueueb(pHead, NULL, pItem, pRtpQueueItem);
        }
    
        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }

        pRtpQueueItem = pItem;
    }
    
    return(pRtpQueueItem);

 error:
    if (pRtpCritSect)
    {
        RtpLeaveCriticalSection(pRtpCritSect);
    }
    
    if (dwError == RTPERR_INVALIDSTATE)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_ENQUEUE,
                _T("%s: failed: pItem->pHead[0x%p]"),
                _fname, pItempHead
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_ENQUEUE,
                _T("%s: pHead[0x%p] failed: %s (0x%X"),
                _fname, pHead, RTPERR_TEXT(dwError), dwError
            ));
    }

    return(pRtpQueueItem);
}

/*
 * Queue/Hash functions
 */

/* TODO a real hash implementation is needed, right now just use
   queues */

/* insert in hash using key */
RtpQueueItem_t *insertHdwK(
        RtpQueueHash_t   *pHead,
        RtpCritSect_t    *pRtpCritSect,
        RtpQueueItem_t   *pItem,
        DWORD             dwKey
    )
{
    return(enqueuedwK((RtpQueue_t *)pHead, pRtpCritSect, pItem, dwKey));
}

/* remove from hash first item matching dwKey */
RtpQueueItem_t *removeHdwK(
        RtpQueueHash_t  *pHead,
        RtpCritSect_t   *pRtpCritSect,
        DWORD            dwKey
    )
{
    BOOL             bOK;
    RtpQueueItem_t  *pRtpQueueItem;

    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    bOK = TRUE;
    
    if (pRtpCritSect)
    {
        bOK = RtpEnterCriticalSection(pRtpCritSect);
    }

    if (bOK)
    {
        pRtpQueueItem = findQdwK((RtpQueue_t *)pHead, NULL, dwKey);

        if (pRtpQueueItem)
        {
            dequeue((RtpQueue_t *)pHead, NULL, pRtpQueueItem);
        }

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }
    }
    
    return(pRtpQueueItem);
}

/* remove item from hash */
RtpQueueItem_t *removeH(
        RtpQueueHash_t  *pHead,
        RtpCritSect_t   *pRtpCritSect,
        RtpQueueItem_t  *pItem
    )
{
    return(dequeue((RtpQueue_t *)pHead, pRtpCritSect, pItem));
}

/* remove "first" item from hash */
RtpQueueItem_t *removefH(
        RtpQueueHash_t  *pHead,
        RtpCritSect_t   *pRtpCritSect
    )
{
    return(dequeuef((RtpQueue_t *)pHead, pRtpCritSect));
}

/* find first item whose key matches dwKey */
RtpQueueItem_t *findHdwK(
        RtpQueueHash_t  *pHead,
        RtpCritSect_t   *pRtpCritSect,
        DWORD            dwKey
    )
{
    return(findQdwK((RtpQueue_t *)pHead, pRtpCritSect, dwKey));
}

/* Peek the "first" item from hash */
RtpQueueItem_t *peekH(
        RtpQueueHash_t  *pHead,
        RtpCritSect_t   *pRtpCritSect
    )
{
    BOOL             bOK;
    RtpQueueItem_t  *pRtpQueueItem;

    TraceFunctionName("peekH");  

    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    bOK = TRUE;

    if (!pHead)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_QUEUE, S_QUEUE_DEQUEUE,
                _T("%s: NULL pointer"),
                _fname
            ));
        
        return(pRtpQueueItem);
    }

    if (pRtpCritSect)
    {
        bOK = RtpEnterCriticalSection(pRtpCritSect);
    }

    if (bOK)
    {
        pRtpQueueItem = pHead->pFirst;

        if (pRtpCritSect)
        {
            RtpLeaveCriticalSection(pRtpCritSect);
        }
    }
    
    return(pRtpQueueItem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\msrtp\msrtp.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    msrtp.c
 *
 *  Abstract:
 *
 *    MS RTP entry point
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/26 created
 *
 **********************************************************************/

#include <winsock2.h>

#include "msrtpapi.h"

/**********************************************************************
 *
 * Public procedures
 *
 **********************************************************************/

BOOL WINAPI DllMain(
        HINSTANCE hInstance, 
        ULONG     ulReason, 
        LPVOID    pv)
{
    BOOL error = TRUE;
    
    switch(ulReason) {
    case DLL_PROCESS_ATTACH:
        /* RTP global initialization */
        /* TODO check for return error */
        MSRtpInit1(hInstance);
        break;
    case DLL_PROCESS_DETACH:
        /* RTP global de-initialization */
        /* TODO check for return error */
        MSRtpDelete1();
        break;
    default:
        error = FALSE;
    }

    return(error);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\rtcp\rtcpdec.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtcpdec.c
 *
 *  Abstract:
 *
 *    Decode RTCP packets
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/11/08 created
 *
 **********************************************************************/

#include "lookup.h"
#include "rtppinfo.h"
#include "rtpglobs.h"
#include "rtpncnt.h"
#include "rtpevent.h"
#include "rtpred.h"
#include "rtcpband.h"

#include "rtcpdec.h"

DWORD RtcpProcessSInfo(
        RtpUser_t       *pRtpUser,
        RtcpSInfo_t     *pRtcpSInfo,
        int              iPacketSize
    );

DWORD RtcpProcessRBlock(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        RtcpRBlock_t    *pRtcpRBlock
    );

DWORD RtcpProcessProfileExt(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        char            *hdr,
        int              len
    );

DWORD RtcpValidateSdes(
        RtcpCommon_t    *pRtcpCommon
    );

DWORD RtcpValidateBYE(
        RtcpCommon_t    *pRtcpCommon
    );

BOOL RtcpUpdateSdesItem(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        RtcpSdesItem_t  *pRtcpSdesItem
    );

typedef struct _RtpNetMetric_t {
    double           dLow;
    double           dHigh;
} RtpNetMetric_t;

DWORD RtpComputNetworkMetrics(
        RtpUser_t       *pRtpUser,
        const RtpNetMetric_t  *pRtpNetMetric
    );

DWORD RtcpSelectBin(double dBandwidth);

DWORD RtcpBestBin(RtpNetRState_t *pRtpNetRState);

const RtpNetMetric_t g_RtpNetMetric[][3] =
{                 /* values defined in struct.h */
    {   /* ================= Audio ================= */
        /* RTT    */  {NETQA_RTT_MIN,    NETQA_RTT_MAX},
        /* Jitter */  {NETQA_JITTER_MIN, NETQA_JITTER_MAX},
        /* Losess */  {NETQA_LOSSES_MIN, NETQA_LOSSES_MAX}
    },
    {   /* ================= Video ================= */
        /* RTT    */  {NETQV_RTT_MIN,    NETQV_RTT_MAX},
        /* Jitter */  {NETQV_JITTER_MIN, NETQV_JITTER_MAX},
        /* Losess */  {NETQV_LOSSES_MIN, NETQV_LOSSES_MAX}
    }
};

/* Sdes names are the same as the Sdes event names */
const TCHAR_t        **g_psSdesNames = &g_psRtpSdesEvents[0];

/* Process AND validates SR and RR packets */
DWORD RtcpProcessSR_RR(
        RtcpAddrDesc_t  *pRtcpAddrDesc,
        char            *hdr,
        int              iPacketSize,
        SOCKADDR_IN     *FromIn
    )
{
    BOOL             bOk;
    BOOL             bCreate;
    DWORD            dwError;
    DWORD            dwSSRC;
    double           dTime;
    
    RtcpCommon_t    *pRtcpCommon;
    RtpAddr_t       *pRtpAddr;
    RtpUser_t       *pRtpUser;

    DWORD            dwCount;
    int              len;
    int              iPcktSize;
    int              iRemaining;
    BOOL             isSR;
    RtpTime_t       *pRtpTime;
    RtpTime_t       *pRtpTimePrev;

    TraceFunctionName("RtcpProcessSR_RR");
    
    pRtcpCommon = (RtcpCommon_t *)hdr;
    hdr += sizeof(RtcpCommon_t);
    len = (int) (ntohs(pRtcpCommon->length) + 1) * sizeof(DWORD);

    dTime = pRtcpAddrDesc->pRtcpRecvIO->dRtcpRecvTime;
    pRtpTime = &pRtcpAddrDesc->pRtcpRecvIO->RtcpRecvTime;
    
    /*
     * Validate RTCP SR/RR packet size
     * */
    
    /* RTCP common header + SSRC */
    iPcktSize = sizeof(RtcpCommon_t) + sizeof(DWORD);

    isSR = (pRtcpCommon->pt == RTCP_SR);

    /* Sender info */
    if (isSR)
    {
        iPcktSize += sizeof(RtcpSInfo_t);
    }

    /* Report blocks */
    dwCount = pRtcpCommon->count;
    iPcktSize += (dwCount * sizeof(RtcpRBlock_t));

    /* Check size is valid */
    if (iPcktSize > len)
    {
        dwError = RTPERR_INVALIDHDR;

        goto bail;
    }

    /*
     * Packet is valid
     * */
    
    dwSSRC = *(DWORD *)hdr;
    pRtpAddr = pRtcpAddrDesc->pRtpAddr;
    hdr += sizeof(DWORD);
    
    /*
     * Look up SSRC, create new one if not exist yet
     * */
    bCreate = TRUE;
    pRtpUser = LookupSSRC(pRtpAddr, dwSSRC, &bCreate);

    if (pRtpUser)
    {
        bOk = RtpEnterCriticalSection(&pRtpUser->UserCritSect);

        if (bOk)
        {
            if (bCreate)
            {
                /* Increase the number of not yet validated
                 * participants, the bit FGUSER_VALIDATED is reset
                 * when the RtpUser_t structure is just created */
                InterlockedIncrement(&pRtpAddr->lInvalid);

                TraceDebug((
                        CLASS_INFO, GROUP_RTCP, S_RTCP_RECV,
                        _T("%s: pRtpAddr[0x%p] ")
                        _T("SSRC:0x%X new user"),
                        _fname, pRtpAddr,
                        ntohl(pRtpUser->dwSSRC)
                    ));
            }

            /* Store the RTCP source address/port */
            if (!RtpBitTest(pRtpUser->dwUserFlags, FGUSER_RTCPADDR))
            {
                pRtpUser->dwAddr[RTCP_IDX] = (DWORD) FromIn->sin_addr.s_addr;
                                
                pRtpUser->wPort[RTCP_IDX] = FromIn->sin_port;

                RtpBitSet(pRtpUser->dwUserFlags, FGUSER_RTCPADDR);
            }

            /* Check if need to make participant valid */
            if (!RtpBitTest(pRtpUser->dwUserFlags, FGUSER_VALIDATED))
            {
                /* The participant has been validated and was invalid */
                InterlockedDecrement(&pRtpAddr->lInvalid);
                RtpBitSet(pRtpUser->dwUserFlags, FGUSER_VALIDATED);
            }

            RtpLeaveCriticalSection(&pRtpUser->UserCritSect);
        }
        
        TraceDebugAdvanced((
                0, GROUP_RTCP, S_RTCP_RRSR,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                _T("CC:%u RTCP %s packet received at %0.3f"),
                _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                dwCount, isSR? _T("SR") : _T("RR"),
                pRtpTime->dwSecs + (double)pRtpTime->dwUSecs/1000000.0
            ));
        
        /* Update time this SR/RR report was received */
        pRtpUser->RtpNetRState.TimeLastXRRecv = *pRtpTime;

        if (isSR)
        {
            /* Compute the gap between the reception time of this and
             * the previous SR packet received */
            pRtpTimePrev = &pRtpUser->RtpNetRState.TimeLastSRRecv;
            
            pRtpUser->RtpNetRState.dInterSRRecvGap =
                (double) (pRtpTime->dwSecs - pRtpTimePrev->dwSecs) +
                (double) (pRtpTime->dwUSecs - pRtpTimePrev->dwUSecs) /
                1000000.0;
            
            /* Update time this SR report was received */
            pRtpUser->RtpNetRState.TimeLastSRRecv = *pRtpTime;
            
            /* Process sender info */
            RtcpProcessSInfo(pRtpUser, (RtcpSInfo_t *)hdr, iPacketSize);
        }
        
        RtpUpdateNetCount(&pRtpUser->RtpUserCount,
                          &pRtpUser->UserCritSect,
                          RTCP_IDX,
                          iPacketSize,
                          NO_FLAGS,
                          dTime);
        
        /* If created, add this user to AliveQ and Hash,
         * if already existed, move it to AliveQ */
        RtpUpdateUserState(pRtpAddr,
                           pRtpUser,
                           USER_EVENT_RTCP_PACKET);
    }

    if (isSR)
    {
        hdr += sizeof(RtcpSInfo_t);
    }

    /* Process report blocks */
    for(; dwCount > 0; dwCount--, hdr += sizeof(RtcpRBlock_t))
    {
        RtcpProcessRBlock(pRtpAddr, pRtpUser, (RtcpRBlock_t *)hdr);
    }

    iRemaining = len - iPcktSize;

    if (iRemaining > 0)
    {
        /* Process the profile-specific extension */
        RtcpProcessProfileExt(pRtpAddr, pRtpUser, hdr, iRemaining);
    }

    /* Post event if allowed */
    RtpPostEvent(pRtpAddr,
                 pRtpUser,
                 RTPEVENTKIND_RTP,
                 isSR? RTPRTP_SR_RECEIVED : RTPRTP_RR_RECEIVED,
                 dwSSRC,
                 0);

    dwError = NOERROR;

 bail:

    if (dwError != NOERROR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_RECV,
                _T("%s: Invalid packet"),
                _fname
            ));
    }
    
    return(dwError);
}

DWORD RtcpProcessSDES(
        RtcpAddrDesc_t  *pRtcpAddrDesc,
        char            *hdr
    )
{
    BOOL             bCreate;
    DWORD            dwError;
    DWORD            dwSSRC;
    RtcpCommon_t    *pRtcpCommon;
    RtpAddr_t       *pRtpAddr;
    RtpUser_t       *pRtpUser;
    RtcpSdesItem_t  *pRtcpSdesItem;
    DWORD            dwCount;
    BOOL             bNewChunk; /* TRUE when begining a chunk */
    int              pad;

    pRtpAddr = pRtcpAddrDesc->pRtpAddr;

    if (RtpBitTest2(pRtpAddr->dwAddrFlags,
                    FGADDR_MUTERTPRECV, FGADDR_MUTERTPSEND))
    {
        /* If either the receiver or sender or both are muted, stop
         * processing SDES data. This is needed because in the mute
         * state, events generation is disabled, hence the application
         * would not be informed when new SDES data arrives, and it
         * may happen that while in the mute state, all the SDES data
         * that was going to be received actually arrives, then the
         * app wil not ever be notified about the existence of new
         * SDES data, unless the app explicitly queries for that */
        
        return(NOERROR);
    }
        
    /*
     * WARNING
     * 
     * RtcpValidateSdes() and RtcpProcessSDES() use the same structure
     * to validate and update the SDES items (i.e. the body of both
     * functions are identical but differ only in that one contains
     * validation predicates but no actions are taken, in the other
     * one, the validation predicates are assumed true, and only the
     * actions are executed), they MUST maintain that relationship
     * */

    pRtcpCommon = (RtcpCommon_t *)hdr;
    
    /* Validate SDES chunks */
    dwError = RtcpValidateSdes(pRtcpCommon);

    if (dwError == NOERROR)
    {
        /*
         * Update SDES items
         * */

        dwCount = pRtcpCommon->count;
        
        /* Move pointer to first chunk (a chunk starts with a SSRC) */
        hdr = (char *)(pRtcpCommon + 1);
    
        bNewChunk = TRUE;
    
        while(dwCount > 0)
        {
            if (bNewChunk)
            {
                dwSSRC = *(DWORD *)hdr;
                /* Look up SSRC, DO NOT create if not exist yet */
                bCreate = FALSE;
                pRtpUser = LookupSSRC(pRtpAddr, dwSSRC, &bCreate);

                /* Move hdr to first item (i.e. skip SSRC) */
                hdr += sizeof(DWORD);
                bNewChunk = FALSE;
            }

            /* Set pointer to current item */
            pRtcpSdesItem = (RtcpSdesItem_t *)hdr;
        
            if (pRtcpSdesItem->type == RTCP_SDES_END)
            {
                /* END item, i.e. end of chunk, advance pointer to
                 * next 32-bits boundary */
                pad = sizeof(DWORD) - (DWORD) ((ULONG_PTR)hdr & 0x3);
                hdr += pad;
                dwCount--;
                bNewChunk = TRUE;
            }
            else
            {
                /* Item */
                if (pRtpUser && (pRtcpSdesItem->length > 0))
                {
                    RtcpUpdateSdesItem(pRtpAddr, pRtpUser, pRtcpSdesItem);
                }
                
                /* Move pointer to next item */
                hdr += (sizeof(RtcpSdesItem_t) + pRtcpSdesItem->length);
            }
        }
    }

    return(dwError);
}

/* Validate the SDES chunks in a RTCP SDES packet
 *
 * NOTE that a zero length item is valid but useless */
DWORD RtcpValidateSdes(
        RtcpCommon_t    *pRtcpCommon
    )
{
    DWORD            dwError;
    char            *hdr;
    RtcpSdesItem_t  *pRtcpSdesItem;
    DWORD            dwCount;
    BOOL             bNewChunk; /* TRUE when begining a chunk */
    int              len;
    int              pad;

    TraceFunctionName("RtcpValidateSdes");
  
    /*
     * WARNING
     * 
     * RtcpValidateSdes() and RtcpProcessSDES() use the same structure
     * to validate and update the SDES items, they MUST maintain that
     * relationship
     * */
    
    dwCount = pRtcpCommon->count;
        
    /* Move pointer to first chunk (a chunk starts with a SSRC) */
    hdr = (char *)(pRtcpCommon + 1);
    len = (int) ((ntohs(pRtcpCommon->length) + 1) * sizeof(DWORD)) -
        sizeof(RtcpCommon_t);

    bNewChunk = TRUE;
    
    while(dwCount > 0 && len > 0)
    {
        if (bNewChunk)
        {
            if (len < (sizeof(DWORD) * 2))
            {
                len -= (sizeof(DWORD) * 2);
                /* There must have been at least the SSRC and the 4
                 * bytes length item(s) (to the next 32-bits word
                 * boundary) on which at least the last byte must have
                 * been the END item */
                break;
            }
            
            /* Move hdr to first item (i.e. skip SSRC) */
            hdr += sizeof(DWORD);
            len -= sizeof(DWORD);
            bNewChunk = FALSE;
        }

        /* Set pointer to current item */
        pRtcpSdesItem = (RtcpSdesItem_t *)hdr;
        
        if (pRtcpSdesItem->type == RTCP_SDES_END)
        {
            /* END item, i.e. end of chunk, advance pointer to next
             * 32-bits boundary */
            pad = sizeof(DWORD) - (DWORD) ((ULONG_PTR)hdr & 0x3);
            hdr += pad;
            len -= pad;
            dwCount--;
            bNewChunk = TRUE;
        }
        else
        {
            /* Item */
            /* Move pointer to data */
            hdr += sizeof(RtcpSdesItem_t);
            len -= sizeof(RtcpSdesItem_t);
                
            if ( len >= (sizeof(DWORD) - sizeof(RtcpSdesItem_t)) )
            {
                hdr += pRtcpSdesItem->length;
                len -= pRtcpSdesItem->length;

                if (len < 0)
                {
                    /* Went past the buffer */
                    break;
                }
            }
            else
            {
                len -= (sizeof(DWORD) - sizeof(RtcpSdesItem_t));
                /* There must have been at least the 2 bytes padding
                 * to the next 32-bits word boundary, at least the
                 * last one must have been the END item
                 * */
                break;
            }
        }
    }
    
    if (dwCount > 0 || len < 0)
    {
        /* NOTE accept as valid a packet having not used data at the
         * end, i.e. len > 0 */
        
        /* dwCount > 0   == Underrun error */
        /* len < 0       == Overrun error */
        dwError = RTPERR_INVALIDSDES;
    }
    else
    {
        dwError = NOERROR;
    }

    return(dwError);
}

BOOL RtcpUpdateSdesItem(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        RtcpSdesItem_t  *pRtcpSdesItem
    )
{
    /* NOTE that RtpSdesItem_t is different from RtcpSdesItem_t */
    RtpSdesItem_t   *pRtpSdesItem;
    DWORD            dwType;
    DWORD            dwLen;
    char            *sSdesData;
    DWORD            dwSdesMask;

    TraceFunctionName("RtcpUpdateSdesItem");
    
    /* What we allow to store */
    dwSdesMask = pRtpAddr->pRtpSess->dwSdesMask[REMOTE_IDX];
    dwType = pRtcpSdesItem->type;

    if (dwType <= RTCP_SDES_FIRST || dwType >= RTCP_SDES_LAST)
    {
        /* Ignore non recognized SDES items */
        return(FALSE);
    }
    
    if (RtpBitPar(dwType) & dwSdesMask & ~pRtpUser->dwSdesPresent)
    {
        if (pRtpUser->pRtpSdes)
        {
            dwLen = pRtcpSdesItem->length;
            sSdesData = (char *)pRtcpSdesItem + sizeof(RtcpSdesItem_t);

            pRtpSdesItem = &pRtpUser->pRtpSdes->RtpSdesItem[dwType];

            if (pRtpSdesItem->dwBfrLen < dwLen)
            {
                /* Save only what fits in our buffer */
                dwLen = pRtpSdesItem->dwBfrLen;
            }

            if (pRtpSdesItem->pBuffer)
            {
                CopyMemory(pRtpSdesItem->pBuffer,
                           (char *)pRtcpSdesItem + sizeof(RtcpSdesItem_t),
                           dwLen);

                if (sSdesData[dwLen - 1] && (dwLen < pRtpSdesItem->dwBfrLen))
                {
                    /* Last byte is not a NULL, and we still have room
                     * for it, add it! */
                    pRtpSdesItem->pBuffer[dwLen] = 0;
                    dwLen++;
                }

                pRtpSdesItem->dwDataLen = dwLen;
                
                RtpBitSet(pRtpUser->dwSdesPresent, dwType);
                
                TraceDebug((
                        CLASS_INFO, GROUP_RTCP, S_RTCP_SDES,
                        _T("%s: pRtpAddr[0x%p] ")
                        _T("pRtpUser[0x%p] SSRC:0x%X SDES[%5s] [%hs]"),
                        _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                        g_psSdesNames[dwType], pRtpSdesItem->pBuffer
                    ));

                /* Generate event, attempt to post with any first,
                 * then attempt to post with the particular SDES
                 * event. It is up to the application to enable ANY, a
                 * specific one, or both
                 * */
                RtpPostEvent(pRtpAddr,
                             pRtpUser,
                             RTPEVENTKIND_SDES,
                             RTPSDES_ANY,
                             pRtpUser->dwSSRC,
                             dwType);

                RtpPostEvent(pRtpAddr,
                             pRtpUser,
                             RTPEVENTKIND_SDES,
                             dwType,
                             pRtpUser->dwSSRC,
                             dwType);
                                  
                return(TRUE);
            }
        }
    }
    
    return(FALSE);
}

DWORD RtcpProcessBYE(
        RtcpAddrDesc_t  *pRtcpAddrDesc,
        char            *hdr
    )
{
    BOOL             bCreate;
    DWORD            dwError;
    DWORD            dwSSRC;
    RtcpCommon_t    *pRtcpCommon;
    RtpAddr_t       *pRtpAddr;
    RtpUser_t       *pRtpUser;
    int              len;
   
    TraceFunctionName("RtcpProcessBYE");
    
    pRtcpCommon = (RtcpCommon_t *)hdr;
    
    /* Validate BYE packet */
    dwError = RtcpValidateBYE(pRtcpCommon);

    if (dwError == NOERROR)
    {
        if (pRtcpCommon->count > 0)
        {
            /* Can only do something if I have at least 1 SSRC */
            hdr = (char *)(pRtcpCommon + 1);
            len = (int) (ntohs(pRtcpCommon->length) + 1) * sizeof(DWORD);

            dwSSRC = *(DWORD *)hdr;
            hdr += (pRtcpCommon->count * sizeof(DWORD));
            len -= (sizeof(RtcpCommon_t) + pRtcpCommon->count * sizeof(DWORD));
            
            pRtpAddr = pRtcpAddrDesc->pRtpAddr;
            
            /* Look up participant leaving */
            bCreate = FALSE;
            pRtpUser = LookupSSRC(pRtpAddr, dwSSRC, &bCreate);

            if (len > 0)
            {
                /* We have a reason field */
                len = *hdr;
                hdr++;
            }
            
            if (pRtpUser)
            {
                if (len > 0)
                {
                    /* TODO save in RTCP_SDES_BYE the reason */
                }
                
                TraceDebug((
                        CLASS_INFO, GROUP_RTCP, S_RTCP_BYE,
                        _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                        _T("BYE received, reason:[%hs]"),
                        _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                        (len > 0)? hdr : "NONE"
                    ));
                /* TODO convert the reason from UTF-8 to UNICODE then
                 * pass it to the TraceDebug */

                pRtpUser->RtpNetRState.dByeTime = RtpGetTimeOfDay(NULL);
                
                RtpUpdateUserState(pRtpAddr, pRtpUser, USER_EVENT_BYE);
            }
            else
            {
                TraceRetail((
                        CLASS_WARNING, GROUP_RTCP, S_RTCP_BYE,
                        _T("%s: pRtpAddr[0x%p] anonimous ")
                        _T("BYE received, reason:[%hs]"),
                        _fname, pRtpAddr,
                        (len > 0)? hdr : "NONE"
                    ));
            }
        }
        else
        {
        }
    }
    
    return(dwError);
}

/* Validate the SDES chunks in a RTCP SDES packet */
DWORD RtcpValidateBYE(
        RtcpCommon_t    *pRtcpCommon
    )
{
    DWORD            dwError;
    char            *hdr;
    DWORD            dwCount;
    int              len;

    TraceFunctionName("RtcpValidateBYE");
    
    dwCount = pRtcpCommon->count;
    
    /* Move pointer to first SSRC/CSRC */
    hdr = (char *)(pRtcpCommon + 1);
    len = (int) ((ntohs(pRtcpCommon->length) + 1) * sizeof(DWORD)) -
        sizeof(RtcpCommon_t);

    /* Account for the SSRC/CSRCs included */
    hdr += (pRtcpCommon->count * sizeof(DWORD));
    len -= (pRtcpCommon->count * sizeof(DWORD));

    dwError = NOERROR;
    
    if (len < 0)
    {
         dwError = RTPERR_INVALIDBYE;
    }
    else
    {
        if (len > 0)
        {
            /* We have a reason field */
            len -= *hdr;
            len--;

            if (len < 0)
            {
                dwError = RTPERR_INVALIDBYE;
            }
        }
    }

    return(dwError);
}

DWORD RtcpProcessAPP(
        RtcpAddrDesc_t  *pRtcpAddrDesc,
        char            *hdr
    )
{
    return(0);
}

DWORD RtcpProcessDefault(
        RtcpAddrDesc_t  *pRtcpAddrDesc,
        char            *hdr
    )
{
    return(0);
}

DWORD RtcpProcessSInfo(
        RtpUser_t       *pRtpUser,
        RtcpSInfo_t     *pRtcpSInfo,
        int              iPacketSize
    )
{
    BOOL             bOk;
    DWORD            dwError;
    double           dBandwidth;
    double           dGap;
    DWORD            dwBin;
    DWORD            dwFreq;
    DWORD            dwBestBin;
    DWORD            dwBestFrequency;
    RtpNetRState_t  *pRtpNetRState;

    TraceFunctionName("RtcpProcessSInfo");

    pRtpNetRState = &pRtpUser->RtpNetRState;

    dwError = RTPERR_CRITSECT;
    
    bOk = RtpEnterCriticalSection(&pRtpUser->UserCritSect);

    if (bOk == TRUE)
    {
        if (pRtcpSInfo->ntp_sec)
        {
            /* Update the NTP/ts pair only if we have received a valid
             * NTP time */
            
            /* Save the send time in the last SR packet received */
            pRtpNetRState->dInterSRSendGap =
                (double) pRtpNetRState->NTP_sr_rtt.dwSecs +
                (double) pRtpNetRState->NTP_sr_rtt.dwUSecs / 1000000.0;

            /* Now update the send time for this SR packet */
            pRtpNetRState->NTP_sr_rtt.dwSecs = ntohl(pRtcpSInfo->ntp_sec);
        
            pRtpNetRState->NTP_sr_rtt.dwUSecs = (DWORD)
                ( ( (double) ntohl(pRtcpSInfo->ntp_frac) / 4294967296.0 ) *
                  1000000.0 );
        
            pRtpNetRState->t_sr_rtt = ntohl(pRtcpSInfo->rtp_ts);

            /* Compute the gap between the sending time of this and
             * the previous SR packet received */
            pRtpNetRState->dInterSRSendGap =
                (double) pRtpNetRState->NTP_sr_rtt.dwSecs +
                ((double) pRtpNetRState->NTP_sr_rtt.dwUSecs / 1000000.0) -
                pRtpNetRState->dInterSRSendGap;

            if (pRtpNetRState->dInterSRSendGap <= g_dRtcpBandEstMaxGap)
            {
                /* Do bandwidth estimation only when we have small
                 * gaps between 2 consecutive SR reports */

                dGap = pRtpNetRState->dInterSRRecvGap -
                    pRtpNetRState->dInterSRSendGap;

                if (dGap <= 0)
                {
                    /* Discard this reading */
                    dBandwidth =
                        g_dRtcpBandEstBin[RTCP_BANDESTIMATION_MAXBINS];

                    dwBin = RTCP_BANDESTIMATION_NOBIN;
                }
                else
                {
                    /* Compute current bandwidth estimation */
                    dBandwidth =
                        (double) ((iPacketSize + SIZEOF_UDP_IP_HDR) * 8) /
                        dGap;

                    /* Select bin */
                    dwBin = RtcpSelectBin(dBandwidth);
                }

                if (dwBin != RTCP_BANDESTIMATION_NOBIN)
                {
                    /* Update bin */
                    pRtpNetRState->dwBinFrequency[dwBin]++;

                    dwFreq = pRtpNetRState->dwBinFrequency[dwBin];

                    pRtpNetRState->dBinBandwidth[dwBin] += dBandwidth;

                    /* Increase count of valid estimations done */
                    pRtpNetRState->dwBandEstRecvCount++;
                
                    if (pRtpNetRState->dwBandEstRecvCount <=
                        g_dwRtcpBandEstMinReports)
                    {
                        if (pRtpNetRState->dwBandEstRecvCount ==
                            g_dwRtcpBandEstMinReports)
                        {
                            /* We reached the initial count, select
                             * highest frequency bin */

                            pRtpNetRState->dwBestBin =
                                RtcpBestBin(pRtpNetRState);

                            dwBestBin = pRtpNetRState->dwBestBin;
                            
                            RtpBitReset(pRtpNetRState->dwNetRStateFlags2,
                                        FGNETRS2_BANDESTNOTREADY);
                        }
                        else
                        {
                            dwBestBin = dwBin;
                            
                            /* Report BANDESTNOTREADY while we are doing
                             * the initial average */
                            RtpBitSet(pRtpNetRState->dwNetRStateFlags2,
                                      FGNETRS2_BANDESTNOTREADY);
                        }
                    }
                    else
                    {
                        /* Update the best bin if different */
                        if (dwBin != pRtpNetRState->dwBestBin)
                        {
                            if (pRtpNetRState->dwBinFrequency[dwBin] >
                                pRtpNetRState->
                                dwBinFrequency[pRtpNetRState->dwBestBin])
                            {
                                pRtpNetRState->dwBestBin = dwBin;
                            }
                            else if (pRtpNetRState->dwBinFrequency[dwBin] ==
                                     pRtpNetRState->
                                     dwBinFrequency[pRtpNetRState->dwBestBin])
                            {
                                /* If same frequency, keep the smaller */
                                if (dwBin < pRtpNetRState->dwBestBin)
                                {
                                    pRtpNetRState->dwBestBin = dwBin;
                                }
                            }
                        }

                        dwBestBin = pRtpNetRState->dwBestBin;
                        
                        RtpBitReset(pRtpNetRState->dwNetRStateFlags2,
                                    FGNETRS2_BANDWIDTHUNDEF);
                    }

                    dwBestFrequency = pRtpNetRState->dwBinFrequency[dwBestBin];
                }
                else
                {
                    /* If this estimation is undefined, i.e. the gap
                     * between the 2 consecutive packets is 0 or
                     * negative, will report RTP_BANDWIDTH_UNDEFINED
                     * as the estimated bandwidth if best frequency is 0 or 1 */

                    dwFreq = (DWORD)-1;
                    
                    dwBestBin = pRtpNetRState->dwBestBin;
                    dwBestFrequency = pRtpNetRState->dwBinFrequency[dwBestBin];

                    // Need to return the best bin instead of -1
                    if (dwBestFrequency < 2)
                    {
                        /* Just to avoid zero div exception if logging */
                        dwBestFrequency = 1;

                        RtpBitSet(pRtpNetRState->dwNetRStateFlags2,
                                  FGNETRS2_BANDWIDTHUNDEF);
                    }
                    else
                    {
                        RtpBitReset(pRtpNetRState->dwNetRStateFlags2,
                                  FGNETRS2_BANDWIDTHUNDEF);
                    }
                }

                pRtpNetRState->dLastTimeEstimation = RtpGetTimeOfDay(NULL);

                
                TraceRetailAdvanced((
                        0, GROUP_RTCP, S_RTCP_BANDESTIMATION,
                        _T("%s: pRtpUser[0x%p] SSRC:0x%X ")
                        _T("Bandwidth: cur:%d/%d/%0.3fKbps ")
                        _T("best:%u/%u/%0.3fKbps"),
                        _fname, pRtpUser, ntohl(pRtpUser->dwSSRC),
                        dwBin, dwFreq, dBandwidth/1000.0,
                        dwBestBin, dwBestFrequency, 
                        pRtpNetRState->dBinBandwidth[dwBestBin] /
                        (dwBestFrequency * 1000.0)
                    ));
             }
            
            if (!RtpBitTest(pRtpUser->dwUserFlags, FGUSER_SR_RECEIVED))
            {
                /* Very first SR received */
                RtpBitSet(pRtpUser->dwUserFlags, FGUSER_SR_RECEIVED);
            }
        }

        RtpLeaveCriticalSection(&pRtpUser->UserCritSect);

        TraceRetailAdvanced((
                0, GROUP_RTCP, S_RTCP_NTP,
                _T("%s: pRtpUser[0x%p] SSRC:0x%X ")
                _T("SInfo: %sNTP:%0.3f/ts:%u packets:%u bytes:%u"),
                _fname, pRtpUser, ntohl(pRtpUser->dwSSRC),
                pRtcpSInfo->ntp_sec? _T("") : _T("X"),
                (double)pRtpNetRState->NTP_sr_rtt.dwSecs +
                (double)pRtpNetRState->NTP_sr_rtt.dwUSecs/1000000.0,
                pRtpNetRState->t_sr_rtt,
                ntohl(pRtcpSInfo->psent),
                ntohl(pRtcpSInfo->bsent)
            ));
        
        dwError = NOERROR;
    }

    return(dwError);
}

/* WARNING The pRtpUser may be NULL as we could have received a report
 * from a participant that is in the ByeQ, in that case, the lookup
 * will not create a new participant as the participant indeed existed
 * but has stalled or sent already a BYE packet */
DWORD RtcpProcessRBlock(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        RtcpRBlock_t    *pRtcpRBlock
    )
{
    DWORD            dwError;
    
    DWORD            dwLSR;
    DWORD            dwDLSR;
    double           LSR;
    double           DLSR;
    double           TimeLastRR;
    DWORD            frac_cumlost;
    DWORD            frac_lost;      /* Last fraction lost reported */
    int              cum_lost;       /* Last cumulative lost reported */
    DWORD            dwNetMetrics;
    int              iNetChange;
    double           dCurTime;
    double           dRTT;
    double           dJitter;
    double           dLossRate;
    DWORD            dwValue;
    BOOL             bEnableNetQuality;
    int              iClass;         /* Audio, Video, ... */
    
    RtpNetSState_t  *pRtpNetSState;
    RtpNetRState_t  *pRtpNetRState;
    RtpNetInfo_t    *pRtpNetInfo;

    TraceFunctionName("RtcpProcessRBlock");
    
    dwError = NOERROR;

    pRtpNetSState = &pRtpAddr->RtpNetSState;
    
    if (pRtpUser && pRtpNetSState->dwSendSSRC == pRtcpRBlock->ssrc)
    {
        /*
         * This participant is reporting about us and is a valid
         * participant (i.e. we have a context for it)
         * */

        pRtpNetRState = &pRtpUser->RtpNetRState;
        pRtpNetInfo = &pRtpUser->RtpNetInfo;

        LSR = 0.0;

        DLSR = 0.0;
        
        if (pRtcpRBlock->lsr && pRtcpRBlock->dlsr)
        {
            /* Compute the RTT only if we have a LSR and DLSR. This
             * report's sender must have had received a SR (SInfo)
             * from us in order to be able to send back in a RBlock
             * valid values for LSR and DLSR */
            
            dwLSR = ntohl(pRtcpRBlock->lsr);

            LSR = (double) ((dwLSR >> 16) & 0xffff);

            LSR += (double) (dwLSR & 0xffff) / 65536.0;
        
            dwDLSR = ntohl(pRtcpRBlock->dlsr);

            DLSR = (double) ((dwDLSR >> 16) & 0xffff);

            DLSR += (double) (dwDLSR & 0xffff) / 65536.0;

            TimeLastRR =
                (double) (pRtpNetRState->TimeLastXRRecv.dwSecs & 0xffff);

            TimeLastRR +=
                (double) pRtpNetRState->TimeLastXRRecv.dwUSecs / 1000000.0;
            
            dRTT = TimeLastRR - DLSR - LSR;

            if (dRTT < 0)
            {
                /* A negative value is possible because of clock
                 * differences when the RTT is very small */
                dRTT = 0;
            }
            
            /* Compute average RTT */
            pRtpNetInfo->dAvg[NETQ_RTT_IDX] +=
                (1.0 - RTP_GENERIC_ALPHA) *
                (dRTT - pRtpNetInfo->dAvg[NETQ_RTT_IDX]);
        }

        frac_cumlost = ntohl(pRtcpRBlock->frac_cumlost);

        /* Obtain the cumulative lost */
        if (frac_cumlost & 0x800000)
        {
            /* extend the sign */
            cum_lost = (int) ((-1 & ~0x7fffff) | (frac_cumlost & 0x7fffff));
        }
        else
        {
            cum_lost = (int) (frac_cumlost & 0x7fffff);
        }

        /* Obtain the fraction lost (in 1/256th units) */
        frac_lost = frac_cumlost >> 24;

        pRtpNetSState->iLastLossRateS =
            (frac_lost * 100 * LOSS_RATE_FACTOR) / 256;
    
        /* Update our average lost rate to control redundancy */
        pRtpNetSState->iAvgLossRateS =
            RtpUpdateLossRate(pRtpNetSState->iAvgLossRateS,
                              pRtpNetSState->iLastLossRateS);

        /* Loss rate in 0 - 100 scale */
        dLossRate = (double) pRtpNetSState->iLastLossRateS / LOSS_RATE_FACTOR;
        
        /* ... and the average loss rate for network metrics */
        pRtpNetInfo->dAvg[NETQ_LOSSRATE_IDX] +=
            (1.0 - RTP_GENERIC_ALPHA) *
            (dLossRate - pRtpNetInfo->dAvg[NETQ_LOSSRATE_IDX]);

        /* Update the redundancy level if needed */
        if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_REDSEND))
        {
            RtpAdjustSendRedundancyLevel(pRtpAddr);
        }
        
        /* Obtain jitter in seconds */
        dJitter =
            (double) ntohl(pRtcpRBlock->jitter) /
            pRtpNetSState->dwSendSamplingFreq;

        /* Compute average jitter */
        pRtpNetInfo->dAvg[NETQ_JITTER_IDX] +=
            (1.0 - RTP_GENERIC_ALPHA) *
            (dJitter - pRtpNetInfo->dAvg[NETQ_JITTER_IDX]);
        
        TraceRetailAdvanced((
                0, GROUP_RTCP, S_RTCP_RTT,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                _T("RTT:%0.3f (LRR:%0.3f,DLSR:%0.3f,LSR:%0.3f)"),
                _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                dRTT, TimeLastRR, DLSR, LSR
            ));
        
        TraceRetailAdvanced((
                0, GROUP_RTCP, S_RTCP_LOSSES,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                _T("Losses: avg:%0.2f%% cum:%d fraction:%u%% ")
                _T("Jitter:%u bytes (%0.3f secs)"),
                _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                pRtpNetInfo->dAvg[NETQ_LOSSRATE_IDX],
                cum_lost, (frac_lost * 100) / 256,
                (DWORD) (dJitter * pRtpNetSState->dwSendSamplingFreq),
                dJitter
            ));

        /* Post loss rate as an event */
        RtpPostEvent(pRtpAddr,
                     pRtpUser,
                     RTPEVENTKIND_RTP,
                     RTPRTP_SEND_LOSSRATE,
                     pRtpUser->dwSSRC,
                     pRtpNetSState->iAvgLossRateS);

        dCurTime = RtpGetTimeOfDay((RtpTime_t *)NULL);

        /* NOTE that the estimation is *global* for all the
         * participants, once we really support multicast (I mean RTC)
         * this scheme might be better implemented on a per receiver
         * basis, then come up with a global metric, may be a
         * percentil */
        if (!pRtpNetSState->dLastTimeEstimationPosted)
        {
            /* First time initialize to the time the first RB is
             * received, there is no point in doing that before as
             * that means that even if we are sending, no body is
             * listening */
            pRtpNetSState->dLastTimeEstimationPosted = dCurTime;
        }
        else if (!RtpBitTest(pRtpNetSState->dwNetSFlags, FGNETS_NOBANDPOSTED))
        {
            if (RtpBitTest(pRtpNetSState->dwNetSFlags, FGNETS_1STBANDPOSTED))
            {
                /* If I had at least one estimation, prevent the
                 * posting of event RTP_BANDWIDTH_NOTESTIMATED */
                RtpBitSet(pRtpNetSState->dwNetSFlags, FGNETS_NOBANDPOSTED);
            }
            else if ( ((dCurTime - pRtpNetSState->dLastTimeEstimationPosted) >=
                       g_dRtcpBandEstWait) )
            {
                /* If I haven't received bandwidth estimation, I need to
                 * generate an event to let the upper layer know that the
                 * bandwidth is undetermined so that layer can use another
                 * mechanism to come up with the bandwidth to use. */
                RtpBitSet2(pRtpNetSState->dwNetSFlags,
                           FGNETS_NOBANDPOSTED, FGNETS_DONOTSENDPROBE);

                /* Post bandwidth estimation event */
                RtpPostEvent(pRtpAddr,
                             pRtpUser,
                             RTPEVENTKIND_RTP,
                             RTPRTP_BANDESTIMATION,
                             pRtpNetSState->dwSendSSRC, /* My own SSRC */
                             RTP_BANDWIDTH_NOTESTIMATED);
            }
        }

        /* Decide if network condition updates event is being reported
         * for this SSRC */
        if (RtpBitTest(pRtpAddr->dwAddrRegFlags, FGADDRREG_NETQFORCED))
        {
            /* Force enabled/disabled from the registry */
            bEnableNetQuality =
                RtpBitTest(pRtpAddr->dwAddrRegFlags,FGADDRREG_NETQFORCEDVALUE);
        }
        else
        {
            /* Use the per user settings or the global setting */
            bEnableNetQuality =
                RtpBitTest(pRtpUser->dwUserFlags2, FGUSER2_NETEVENTS)
                ||
                RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_NETMETRIC);
        }
        
        if (bEnableNetQuality)
        {
            pRtpUser->RtpNetInfo.dLastUpdate = dCurTime;

            iClass = (int)RtpGetClass(pRtpAddr->dwIRtpFlags) - 1;

            if (iClass < 0 || iClass > 1)
            {
                iClass = 0;
            }
            
            dwNetMetrics = RtpComputNetworkMetrics(pRtpUser,
                                                   &g_RtpNetMetric[iClass][0]);

            iNetChange = (int)dwNetMetrics - pRtpNetInfo->dwNetMetrics;

            if (iNetChange < 0)
            {
                iNetChange = -iNetChange;
            }
            
            /* Decide if the network conditions have changed to
             * justify an update */
            if (iNetChange >= RTPNET_MINNETWORKCHANGE)
            {
                /* Update new metric */
                pRtpNetInfo->dwNetMetrics = dwNetMetrics;
                
                /* Encode all the metrics in a single DWORD */
                /* The global metric is a 0 - 100 value */
                dwNetMetrics &= 0xff;

                /* RTT is encoded as 10's of milliseconds */
                dwValue = (DWORD) (pRtpNetInfo->dAvg[NETQ_RTT_IDX] * 100);
                if (dwValue > 0xff)
                {
                    dwValue = 0xff;
                }
                dwNetMetrics |= (dwValue << 8);
                
                /* Jitter is encoded in milliseconds */
                dwValue = (DWORD) (pRtpNetInfo->dAvg[NETQ_JITTER_IDX] * 1000);
                if (dwValue > 0xff)
                {
                    dwValue = 0xff; 
                }
                dwNetMetrics |= (dwValue << 16);

                /* Loss rate is encoded in 1/256 units */
                dwValue = (DWORD)
                    ((pRtpNetInfo->dAvg[NETQ_LOSSRATE_IDX] * 256) / 100);
                dwValue &= 0xff;
                dwNetMetrics |= (dwValue << 24);

                TraceRetail((
                        CLASS_INFO, GROUP_RTCP, S_RTCP_NETQUALITY,
                        _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                        _T("Global:%u RTT:%0.3f/%1.0f Jitter:%0.3f/%1.0f ")
                        _T("Losses:%1.0f/%1.0f"),
                        _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                        pRtpNetInfo->dwNetMetrics,
                        pRtpNetInfo->dAvg[NETQ_RTT_IDX],
                        pRtpNetInfo->dHowGood[NETQ_RTT_IDX],
                        pRtpNetInfo->dAvg[NETQ_JITTER_IDX],
                        pRtpNetInfo->dHowGood[NETQ_JITTER_IDX],
                        pRtpNetInfo->dAvg[NETQ_LOSSRATE_IDX],
                        pRtpNetInfo->dHowGood[NETQ_LOSSRATE_IDX]
                    ));
                
                /* Post event */
                RtpPostEvent(pRtpAddr,
                             pRtpUser,
                             RTPEVENTKIND_PINFO,
                             RTPPARINFO_NETWORKCONDITION,
                             pRtpUser->dwSSRC,
                             dwNetMetrics);

            }
        }
    }
    else
    {
        TraceDebugAdvanced((
                0, GROUP_RTCP, S_RTCP_RRSR,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] ")
                _T("RBlock SSRC:0x%X ignored"),
                _fname, pRtpAddr, pRtpUser, ntohl(pRtcpRBlock->ssrc)
            ));
    }

    return(dwError);
}

DWORD RtcpProcessProfileExt(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        char            *hdr,
        int              len
    )
{
    DWORD            dwError;
    int              len0;
    char            *ptr;
    DWORD            dwType;
    DWORD            dwLen;
    DWORD            dwSSRC;
    DWORD            dwBandwidth;
    RtpPEHdr_t      *pRtpPEHdr;
    RtpBandEst_t    *pRtpBandEst;

    dwError = NOERROR;
    len0 = len;
    ptr = hdr;

    /* Validate extensions */
    while(len >= sizeof(RtpPEHdr_t))
    {
        pRtpPEHdr = (RtpPEHdr_t *)hdr;

        dwLen = ntohs(pRtpPEHdr->len);
        len -= dwLen;
        ptr += dwLen;

        if (len < 0)
        {
            dwError = RTPERR_OVERRUN;
            goto end;
        }

        switch(ntohs(pRtpPEHdr->type))
        {
        case RTPPE_BANDESTIMATION:
            if (dwLen != sizeof(RtpBandEst_t))
            {
                dwError = RTPERR_INVALIDHDR;
                goto end;
            }
            break;
        }
    }
    
    len = len0; 
    while(len >= sizeof(RtpPEHdr_t))
    {
        pRtpPEHdr = (RtpPEHdr_t *)hdr;
        
        dwType = ntohs(pRtpPEHdr->type);
        dwLen = ntohs(pRtpPEHdr->len);
        
        switch(dwType)
        {
        case RTPPE_BANDESTIMATION:
            pRtpBandEst = (RtpBandEst_t *)pRtpPEHdr;
            
            /* dwSendSSRC is already in NETWORK order */
            if (pRtpAddr->RtpNetSState.dwSendSSRC == pRtpBandEst->dwSSRC)
            {
                dwBandwidth = ntohl(pRtpBandEst->dwBandwidth);
                
                /* This report concers us */
                /* Post bandwidth estimation event */
                RtpPostEvent(pRtpAddr,
                             pRtpUser,
                             RTPEVENTKIND_RTP,
                             RTPRTP_BANDESTIMATION,
                             pRtpBandEst->dwSSRC,
                             dwBandwidth);

                pRtpAddr->RtpNetSState.dLastTimeEstimationPosted =
                    RtpGetTimeOfDay((RtpTime_t *)NULL);

                /* Indicate we have valid estimation and hence prevent
                 * the posting of the RTP_BANDWIDTH_NOTESTIMATED event */
                RtpBitSet(pRtpAddr->RtpNetSState.dwNetSFlags,
                          FGNETS_1STBANDPOSTED);
            }
            break;
        }

        hdr += dwLen;
        len -= dwLen;
    }

 end:
    return(dwError);
}

/* Using the average of the RTT, jitter and losses, compute a network
 * quality metric given in a [0 - 100] scale */
DWORD RtpComputNetworkMetrics(
        RtpUser_t       *pRtpUser,
        const RtpNetMetric_t  *pRtpNetMetric
    )
{
    DWORD            i;
    double           dHowBad[3];
    double           dVal;
    double           dAllBad;
    double           dTotalBad;
    RtpNetInfo_t    *pRtpNetInfo;

    pRtpNetInfo = &pRtpUser->RtpNetInfo;

    dAllBad = 0;
    dTotalBad = 0;
    
    for(i = 0; i < NETQ_LAST_IDX; i++)
    {
        if (pRtpNetInfo->dAvg[i])
        {
            if (pRtpNetInfo->dAvg[i] < pRtpNetMetric[i].dLow)
            {
                dHowBad[i] = 0;
            }
            else if (pRtpNetInfo->dAvg[i] > pRtpNetMetric[i].dHigh)
            {
                dHowBad[i] = 100;
            }
            else
            {
                dHowBad[i] =
                    (pRtpNetInfo->dAvg[i] - pRtpNetMetric[i].dLow) * 100 /
                    (pRtpNetMetric[i].dHigh - pRtpNetMetric[i].dLow);
            }

            dAllBad += dHowBad[i];
        }
        else
        {
            dHowBad[i] = 0;
        }

        pRtpNetInfo->dHowGood[i] = 100 - dHowBad[i];
    }

    if (dAllBad > 0)
    {
        for(i = 0; i < NETQ_LAST_IDX; i++)
        {
            if (pRtpNetInfo->dAvg[i])
            {
                dTotalBad += (dHowBad[i] * dHowBad[i]) / dAllBad;
            }
        }
    }
    
    return(100 - (DWORD)dTotalBad);
}

/* Helper functions for bandwidth estimation */

/* Given a bandwidth, select the corresponding bin */
DWORD RtcpSelectBin(double dBandwidth)
{
    DWORD            i;

    for(i = 0; i < RTCP_BANDESTIMATION_MAXBINS; i++)
    {
        if (dBandwidth > g_dRtcpBandEstBin[i] &&
            dBandwidth <= g_dRtcpBandEstBin[i + 1])
        {
            return(i);
        }
    }

    return(RTCP_BANDESTIMATION_NOBIN);
}

/* Select bin with highest frequency */
DWORD RtcpBestBin(RtpNetRState_t *pRtpNetRState)
{
    DWORD            dwBestBin;
    DWORD            i;

    for(i = 0, dwBestBin = 0; i < RTCP_BANDESTIMATION_MAXBINS; i++)
    {
        if (pRtpNetRState->dwBinFrequency[i] > 
            pRtpNetRState->dwBinFrequency[dwBestBin])
        {
            dwBestBin = i;
        }
    }

    return(dwBestBin);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\rtcp\rtcpint.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtcpint.c
 *
 *  Abstract:
 *
 *    Computes the RTCP report interval time
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/12/07 created
 *
 **********************************************************************/

#include "stdlib.h" /* rand() */
#include "rtpglobs.h"
#include "rtprand.h"

#include "rtcpint.h"

double rtcp_interval(RtpAddr_t *pRtpAddr, int initial);

/* Return the interval time (in seconds) for the next report */
double RtcpNextReportInterval(RtpAddr_t *pRtpAddr)
{
    double           interval;
    
    if (pRtpAddr->RtpAddrCount[SEND_IDX].dRTCPLastTime)
    {
        interval = rtcp_interval(pRtpAddr, 0);
    }
    else
    {
        /* We haven't sent any  RTCP packet */
        interval = rtcp_interval(pRtpAddr, 1);
    }

    return(interval);
}

double rtcp_interval(RtpAddr_t *pRtpAddr, int initial)
{
    BOOL             bOk;
    double           rtcp_bw;
    int              members;
    int              senders;
    BOOL             we_sent;
    double           avg_rtcp_size;
    RtpNetSState_t  *pRtpNetSState;
    double           rtcp_min_time;
    double           t;   /* interval */
    int              n;   /* no. of members for computation */
    double           dCurrTime;   /* current time */

    TraceFunctionName("rtcp_interval");

    pRtpNetSState = &pRtpAddr->RtpNetSState;

    if (initial)
    {
        t = DEFAULT_RTCP_MIN_INTERVAL / 2.0;

        /* Save the estimated interval rather than the randomized */
        pRtpNetSState->dRtcpInterval = t;

        t = t * ( ((double)rand() / RAND_MAX) + 0.5);
        t = t / (2.71828182846 - 1.5); /* divide by COMPENSATION */
        
        pRtpNetSState->bWeSent = FALSE;

        return(t);
    }
    
    dCurrTime = RtpGetTimeOfDay((RtpTime_t *)NULL);

    bOk = RtpEnterCriticalSection(&pRtpAddr->PartCritSect);

    if (bOk)
    {
        members =
            GetHashCount(&pRtpAddr->Hash) -
            GetQueueSize(&pRtpAddr->ByeQ) + 1;
    
        senders =
            GetQueueSize(&pRtpAddr->Cache1Q) +
            GetQueueSize(&pRtpAddr->Cache2Q);

        RtpLeaveCriticalSection(&pRtpAddr->PartCritSect);

        members -= InterlockedExchangeAdd(&pRtpAddr->lInvalid, 0);
    }
    else
    {
        /* Use the last computed interval time */
        t = pRtpNetSState->dRtcpInterval;

        goto randomize;
    }

    we_sent = FALSE;
    
    bOk = RtpEnterCriticalSection(&pRtpAddr->NetSCritSect);

    if (bOk)
    {
        we_sent = ( pRtpAddr->RtpNetSState.dTimeLastRtpSent >=
                    (dCurrTime - (2 * pRtpNetSState->dRtcpInterval)) );

        RtpLeaveCriticalSection(&pRtpAddr->NetSCritSect);
    }

    pRtpNetSState->bWeSent = we_sent;
    
    if (we_sent)
    {
        senders++;
    }
    
    /*
     * Minimum average time between RTCP packets from this site (in
     * seconds).  This time prevents the reports from `clumping' when
     * sessions are small and the law of large numbers isn't helping
     * to smooth out the traffic.  It also keeps the report interval
     * from becoming ridiculously small during transient outages like
     * a network partition.
     */
    /* double const RTCP_MIN_TIME = 5.; */
    /* Use pRtpNetSState->RtcpMinInterval */
    
    /*
     * Fraction of the RTCP bandwidth to be shared among active
     * senders.  (This fraction was chosen so that in a typical
     * session with one or two active senders, the computed report
     * time would be roughly equal to the minimum report time so that
     * we don't unnecessarily slow down receiver reports.) The
     * receiver fraction must be 1 - the sender fraction.  */
    /* double const RTCP_SENDER_BW_FRACTION = 0.25; */
    /* Use pRtpNetSState->RtcpBwReceivers */
    /* double const RTCP_RCVR_BW_FRACTION = (1-RTCP_SENDER_BW_FRACTION); */
    /* Use pRtpNetSState->RtcpBwSenders */
    
    /* To compensate for "unconditional reconsideration" converging to a
     * value below the intended average.
     */
    /* double const COMPENSATION = 2.71828182846 - 1.5; */

    rtcp_min_time = pRtpNetSState->dRtcpMinInterval;

    /*
     * Very first call at application start-up uses half the min
     * delay for quicker notification while still allowing some time
     * before reporting for randomization and to learn about other
     * sources so the report interval will converge to the correct
     * interval more quickly.
     */
    if (initial) {
        rtcp_min_time /= 2;
    }

    /*
     * If there were active senders, give them at least a minimum
     * share of the RTCP bandwidth.  Otherwise all participants share
     * the RTCP bandwidth equally.
     * */
    n = members;
    if ((senders > 0) && (senders < (members * 0.25))) {
        if (we_sent) {
            rtcp_bw = pRtpNetSState->dwRtcpBwSenders;
            n = senders;
        } else {
            rtcp_bw = pRtpNetSState->dwRtcpBwReceivers;
            n -= senders;
        }
    } else {
        rtcp_bw =
            pRtpNetSState->dwRtcpBwReceivers + pRtpNetSState->dwRtcpBwSenders;
    }
    
    /*
     * The effective number of sites times the average packet size is
     * the total number of octets sent when each site sends a report.
     * Dividing this by the effective bandwidth gives the time
     * interval over which those packets must be sent in order to
     * meet the bandwidth target, with a minimum enforced.  In that
     * time interval we send one report so this time is also our
     * average time between reports.
     */
    t = pRtpNetSState->avg_rtcp_size * n / rtcp_bw;
    if (t < rtcp_min_time) t = rtcp_min_time;

    /* Save the estimated interval rather than the randomized */
    pRtpNetSState->dRtcpInterval = t;
    
    /*
     * To avoid traffic bursts from unintended synchronization with
     * other sites, we then pick our actual next report interval as a
     * random number uniformly distributed between 0.5*t and 1.5*t.
     */
 randomize:
    t *= ( ((double)RtpRandom32((DWORD_PTR)&t) /
            (unsigned int)0xffffffff) + 0.5);
    t /= (2.71828182846 - 1.5); /* divide by COMPENSATION */

    if (t < 0.102)
    {
        /* I will send RTCP reports if within 100ms, so don't schedule
         * closer than 100ms as that would produce consecutive RTCP
         * reports */
        t = 0.102;
    }
    else if (t > (10*60.0))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_RAND,
                _T("%s: pRtpAddr[0x%p] interval:%0.3f"),
                _fname, pRtpAddr, t
            ));
    }
    
    return t;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\misc\rtptags.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtptags.c
 *
 *  Abstract:
 *
 *    Strings used for each tagged object, when debugging, display the
 *    object name by using 1 byte in the tag
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/25 created
 *
 **********************************************************************/

#include "rtptags.h"

/*
 * WARNING
 *
 * When modifying the tags, each enum TAGHEAP_* in rtptags.h MUST have
 * its own name in g_psRtpTags[], defined in rtptags.c
 * */
 
const TCHAR *g_psRtpTags[] = {
    _T("unknown"),
    
    _T("CIRTP"),
    _T("RTPOPIN"),
    _T("RTPALLOCATOR"),
    _T("RTPSAMPLE"),
    _T("RTPSOURCE"),
    _T("RTPIPIN"),
    _T("RTPRENDER"),
    
    _T("RTPHEAP"),
    
    _T("RTPSESS"),
    _T("RTPADDR"),
    _T("RTPUSER"),
    _T("RTPOUTPUT"),
    _T("RTPNETCOUNT"),
    
    _T("RTPSDES"),
    _T("RTPCHANNEL"),
    _T("RTPCHANCMD"),
    _T("RTPCRITSECT"),
    
    _T("RTPRESERVE"),
    _T("RTPNOTIFY"),
    _T("RTPQOSBUFFER"),

    _T("RTPCRYPT"),
    
    _T("RTPCONTEXT"),    
    _T("RTCPCONTEXT"),
    _T("RTCPADDRDESC"),
    
    _T("RTPRECVIO"),
    _T("RTPSENDIO"),
    
    _T("RTCPRECVIO"),
    _T("RTCPSENDIO"),
    
    _T("RTPGLOBAL"),
    
    NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\rtcp\rtcprecv.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtcprecv.c
 *
 *  Abstract:
 *
 *    Asynchronous RTCP packet reception
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/07/07 created
 *
 **********************************************************************/

#include "struct.h"
#include "rtpglobs.h"
#include "rtpheap.h"
#include "rtpncnt.h"
#include "rtcpdec.h"
#include "rtcpsend.h"
#include "rtpcrypt.h"
#include "rtpevent.h"

#include "rtcprecv.h"

DWORD RtcpValidatePacket(
        RtcpAddrDesc_t  *pRtcpAddrDesc,
        RtcpRecvIO_t    *pRtcpRecvIO
    );

DWORD RtcpProcessPacket(
        RtcpAddrDesc_t  *pRtcpAddrDesc,
        RtcpRecvIO_t    *pRtcpRecvIO
    );

HRESULT StartRtcpRecvFrom(
        RtcpContext_t   *pRtcpContext,
        RtcpAddrDesc_t  *pRtcpAddrDesc
    )
{
    HRESULT          hr;
    DWORD            dwStatus;
    DWORD            dwError;
    RtcpRecvIO_t    *pRtcpRecvIO;
    RtpAddr_t       *pRtpAddr;

    TraceFunctionName("StartRtcpRecvFrom");
    
    pRtcpRecvIO = pRtcpAddrDesc->pRtcpRecvIO;
    pRtpAddr = pRtcpAddrDesc->pRtpAddr;
    
    /* Overlapped structure */
    pRtcpRecvIO->Overlapped.hEvent = pRtcpRecvIO->hRtcpCompletedEvent;

    do {
        dwError = NOERROR;
        
        pRtcpRecvIO->Overlapped.Internal = 0;
            
        pRtcpRecvIO->Fromlen = sizeof(pRtcpRecvIO->From);
        
        pRtcpRecvIO->WSABuf.len = sizeof(pRtcpRecvIO->RecvBuffer);
        pRtcpRecvIO->WSABuf.buf = pRtcpRecvIO->RecvBuffer;
            
        dwStatus = WSARecvFrom(
                pRtpAddr->Socket[SOCK_RTCP_IDX], /* SOCKET s */
                &pRtcpRecvIO->WSABuf,   /* LPWSABUF lpBuffers */
                1,                      /* DWORD dwBufferCount */
                &pRtcpRecvIO->dwTransfered,/*LPDWORD lpNumberOfBytesRecvd*/
                &pRtcpRecvIO->dwRecvIOFlags,/* LPDWORD lpFlags */
                &pRtcpRecvIO->From,      /* struct sockaddr FAR *lpFrom */
                &pRtcpRecvIO->Fromlen,   /* LPINT lpFromlen */
                &pRtcpRecvIO->Overlapped,/* LPWSAOVERLAPPED lpOverlapped */
                NULL              /* LPWSAOVERLAPPED_COMPLETION_ROUTINE */
            );
            
        if (dwStatus)
        {
            dwError = WSAGetLastError();
        }
    } while(dwStatus &&
            ( (dwError == WSAECONNRESET) ||
              (dwError == WSAEMSGSIZE) )   );

    if (!dwStatus || (dwError == WSA_IO_PENDING))
    {
        RtpBitSet(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_RECVPENDING);

        pRtcpAddrDesc->lRtcpPending = 1;

        hr = NOERROR;
        
    }
    else
    {
        /* TODO I may put this AddrDesc in a queue and attempt to
         * start async I/O again later, or visit all the descriptors
         * periodically and start asynchronous reception in those that
         * failed the first time */

        RtpBitReset(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_RECVPENDING);

        hr = RTPERR_WS2RECV;
        
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_RECV,
                _T("%s: overlaped reception ")
                _T("failed to start: %u (0x%X)"),
                _fname, dwError, dwError
            ));

        RtpPostEvent(pRtpAddr,
                     NULL,
                     RTPEVENTKIND_RTP,
                     RTPRTP_WS_RECV_ERROR,
                     RTCP_IDX,
                     dwError);
    }

    return(hr);
}

HRESULT ConsumeRtcpRecvFrom(
        RtcpContext_t   *pRtcpContext,
        RtcpAddrDesc_t  *pRtcpAddrDesc
    )
{
    HRESULT          hr;
    BOOL             bStatus;
    DWORD            dwError;
    BOOL             bRestart;
    DWORD            dwTransfered;
    DWORD            dwSSRC;
    DWORD            dwSendSSRC;
    DWORD            dwFlags;
    
    RtcpRecvIO_t    *pRtcpRecvIO;
    RtpAddr_t       *pRtpAddr;
    SOCKADDR_IN     *pFromIn;

    TraceFunctionName("ConsumeRtcpRecvFrom");

    pRtcpRecvIO = pRtcpAddrDesc->pRtcpRecvIO;
    pRtpAddr = pRtcpAddrDesc->pRtpAddr;

    hr       = NOERROR;
    bRestart = FALSE;
    dwError  = NOERROR;
    
    bStatus = WSAGetOverlappedResult(
            pRtcpAddrDesc->Socket[SOCK_RTCP_IDX],    /* SOCKET s */
            &pRtcpRecvIO->Overlapped,  /* LPWSAOVERLAPPED lpOverlapped */
            &pRtcpRecvIO->dwTransfered,/* LPDWORD lpcbTransfer */
            FALSE,                     /* BOOL fWait */
            &pRtcpRecvIO->dwRecvIOFlags /* LPDWORD lpdwFlags */
        );
            
    if (!bStatus)
    {
        /* I/O error */
        
        dwError = WSAGetLastError();
                
        if (dwError == WSA_IO_INCOMPLETE)
        {
            /* I/O hasn't completed yet */
            /* TODO log error UNEXPECTED condition */
        }
        else if ( (dwError == WSA_OPERATION_ABORTED) ||
                  (dwError == WSAEINTR) )
        {
            /* Socket closed, I/O completed */
            RtpBitReset(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_RECVPENDING);

            pRtcpAddrDesc->lRtcpPending = 0;
        }
        else
        {
            /* On any other error, including WSAECONNRESET and
             * WSAEMSGSIZE, re-start I/O */
            bRestart = TRUE;

            /* Error, I/O completed */
            RtpBitReset(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_RECVPENDING);

            pRtcpAddrDesc->lRtcpPending = 0;
        }
    }
    else
    {
        /* I/O completed normally */

        pRtcpRecvIO->dRtcpRecvTime =
            RtpGetTimeOfDay(&pRtcpRecvIO->RtcpRecvTime);
        
        /* Save original value of dwTransfered to be used later as it
         * may be modified in RtcpValidatePacket if packet is
         * decrypted */
        dwTransfered = pRtcpRecvIO->dwTransfered;
        
        RtpBitReset(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_RECVPENDING);

        pRtcpAddrDesc->lRtcpPending = 0;

        bRestart = TRUE;
        
        pRtcpRecvIO->dwError = dwError;

        dwFlags = 0;
        
        /* Validate packet */
        dwError = RtcpValidatePacket(pRtcpAddrDesc, pRtcpRecvIO);

        if (dwError == NOERROR)
        {
            pFromIn = (SOCKADDR_IN *)&pRtcpRecvIO->From;
            
            /* Filter explicitly loopback packets if needed */
            /* Decide if we need to detect collisions */
            if ( RtpBitTest2(pRtpAddr->dwAddrFlags,
                             FGADDR_COLLISION, FGADDR_ISMCAST) ==
                 RtpBitPar2(FGADDR_COLLISION, FGADDR_ISMCAST) )
            {
                dwSSRC = * (DWORD *)
                    (pRtcpRecvIO->WSABuf.buf + sizeof(RtcpCommon_t));

                dwSendSSRC = pRtpAddr->RtpNetSState.dwSendSSRC;
                
                if (dwSSRC == dwSendSSRC)
                {
                    if (RtpDropCollision(pRtpAddr, pFromIn, FALSE))
                    {
                        dwFlags = RtpBitPar2(FGRECV_DROPPED, FGRECV_LOOP);
                    }
                }
            }

            if (RtpBitTest(pRtpAddr->dwIRtpFlags, FGADDR_IRTP_MATCHRADDR))
            {
                if (pFromIn->sin_addr.s_addr != pRtpAddr->dwAddr[REMOTE_IDX])
                {
                    dwFlags = RtpBitPar2(FGRECV_DROPPED, FGRECV_MISMATCH);
                }
            }

            /* Process packet */
            if (!RtpBitTest(dwFlags, FGRECV_DROPPED))
            {
                RtcpProcessPacket(pRtcpAddrDesc, pRtcpRecvIO);
            }
        }

        /* NOTE should I update counters and compute average size only
         * if the packet was processed (not discarded)? */
        
        /* Update RTCP reception counters */
        RtpUpdateNetCount(&pRtcpAddrDesc->pRtpAddr->RtpAddrCount[RECV_IDX],
                          NULL,
                          RTCP_IDX,
                          dwTransfered,
                          dwFlags,
                          pRtcpRecvIO->dRtcpRecvTime);

        /* Update average RTCP packet size */
        RtcpUpdateAvgPacketSize(pRtcpAddrDesc->pRtpAddr, dwTransfered);
    }

    if (RtpBitTest(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_SHUTDOWN2))
    {
        TraceDebug((
                CLASS_INFO, GROUP_RTCP, S_RTCP_RECV,
                _T("%s: pRtcpAddrDesc[0x%p] pRtpAddr[0x%p] ")
                _T("I/O:%d AddrDescStopQ->"),
                _fname, pRtcpAddrDesc, pRtpAddr,
                pRtcpAddrDesc->lRtcpPending
            ));

        /* Shutting down, remove from AddrDescStopQ, it will be moved
         * to AddrDescFreeQ in RtcpRemoveFromVector() */
        dequeue(&pRtcpContext->AddrDescStopQ,
                NULL,
                &pRtcpAddrDesc->AddrDescQItem);

        pRtcpAddrDesc->AddrDescQItem.pvOther = NULL;
    }
    else
    {
        if (bRestart &&
            !RtpBitTest(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_SHUTDOWN1))
        {
            hr = StartRtcpRecvFrom(pRtcpContext, pRtcpAddrDesc); 
        }
    }

    return(hr);
}

DWORD RtcpValidatePacket(
        RtcpAddrDesc_t  *pRtcpAddrDesc,
        RtcpRecvIO_t    *pRtcpRecvIO
    )
{
    RtpAddr_t       *pRtpAddr;
    RtpCrypt_t      *pRtpCrypt;
    RtcpCommon_t    *pRtcpCommon;
    char            *hdr;
    char            *end;
    int              len;
    WORD             len2;

    TraceFunctionName("RtcpValidatePacket");

    pRtpAddr = pRtcpAddrDesc->pRtpAddr;
    pRtpCrypt = pRtpAddr->pRtpCrypt[CRYPT_RTCP_IDX];
    
    if ( pRtpCrypt &&
         (RtpBitTest2(pRtpCrypt->dwCryptFlags, FGCRYPT_INIT, FGCRYPT_KEY) ==
          RtpBitPar2(FGCRYPT_INIT, FGCRYPT_KEY)) )
    {
        if ((pRtpAddr->dwCryptMode & 0xffff) == RTPCRYPTMODE_ALL)
        {
            /* Decrypt whole RTCP packet */

            pRtcpRecvIO->dwError = RtpDecrypt(
                    pRtpAddr,
                    pRtpCrypt,
                    pRtcpRecvIO->WSABuf.buf,
                    &pRtcpRecvIO->dwTransfered
                );

            if (pRtcpRecvIO->dwError == NOERROR)
            {
                /* remove random 32bits number */
                pRtcpRecvIO->WSABuf.buf += sizeof(DWORD);
                pRtcpRecvIO->WSABuf.len -= sizeof(DWORD);
                pRtcpRecvIO->dwTransfered -= sizeof(DWORD);
            }
            else
            {
                if (!pRtpCrypt->CryptFlags.DecryptionError)
                {
                    /* Post an event only the first time */
                    pRtpCrypt->CryptFlags.DecryptionError = 1;
                
                    RtpPostEvent(pRtpAddr,
                                 NULL,
                                 RTPEVENTKIND_RTP,
                                 RTPRTP_CRYPT_RECV_ERROR,
                                 RTCP_IDX,
                                 pRtpCrypt->dwCryptLastError);
                }

                goto bail;
            }
        }
    }
    
    len = (int)pRtcpRecvIO->dwTransfered;

    /*
     * Check minimal size
     * */
    if (len < (sizeof(RtcpCommon_t) + sizeof(DWORD)))
    {
        /* packet too short */

        pRtcpRecvIO->dwError = RTPERR_MSGSIZE;

        TraceRetail((
                CLASS_WARNING, GROUP_RTCP, S_RTCP_RECV,
                _T("%s: Packet too short: %d"),
                _fname, len
            ));
        
        goto bail;
    }

    hdr = pRtcpRecvIO->WSABuf.buf;

    end = NULL;

    while(len > sizeof(RtcpCommon_t))
    {
        pRtcpCommon = (RtcpCommon_t *)hdr;
        
        if (!end)
        {
            /* Set the end of the buffer */
            end = hdr + len;
            
            /* Test version (must be RTP_VERSION), padding (must be 0)
             * and payload type (must be SR or RR) */
            if ( (*(DWORD *)hdr & RTCP_VALID_MASK) != RTCP_VALID_VALUE )
            {
                /* invalid packet */

                pRtcpRecvIO->dwError = RTPERR_INVALIDHDR;
        
                TraceRetail((
                        CLASS_WARNING, GROUP_RTCP, S_RTCP_RECV,
                        _T("%s: Invalid mask 0x%X != 0x%X"),
                        _fname,
                        (*(DWORD *)hdr & RTCP_VALID_MASK),
                        RTCP_VALID_VALUE
                    ));
                
                goto bail;
            }
        }
        else
        {
            /* Only test version */
            if (pRtcpCommon->version != RTP_VERSION)
            {
                pRtcpRecvIO->dwError = RTPERR_INVALIDVERSION;
        
                TraceRetail((
                        CLASS_WARNING, GROUP_RTCP, S_RTCP_RECV,
                        _T("%s: Invalid version: %u"),
                        _fname, pRtcpCommon->version
                    ));
                
                goto bail;
            }
        }
        
        len2 = pRtcpCommon->length;
        
        len2 = (ntohs(len2) + 1) * sizeof(DWORD);

        hdr += len2;
        
        if (hdr > end)
        {
            /* Overrun error */
            pRtcpRecvIO->dwError = RTPERR_INVALIDHDR;
            
            TraceRetail((
                    CLASS_WARNING, GROUP_RTCP, S_RTCP_RECV,
                    _T("%s: Overrun error: +%u"),
                    _fname, (DWORD)(hdr-end)
                ));
            
            goto bail;
        }

        len -= len2;
    }

    /* NOTE, at this point, if we have extra bytes, i.e. len!=0,
     * either the sender included provider specific extensions, or we
     * have a bad formed packet */

    pRtcpRecvIO->dwError = NOERROR;

 bail:
    if (pRtcpRecvIO->dwError != NOERROR)
    {
        TraceRetail((
                CLASS_WARNING, GROUP_RTCP, S_RTCP_RECV,
                _T("%s: pRtcpAddrDesc[0x%p] pRtcpRecvIO[0x%p] ")
                _T("Invalid packet: %u (0x%X)"),
                _fname, pRtcpAddrDesc, pRtcpRecvIO,
                pRtcpRecvIO->dwError, pRtcpRecvIO->dwError
            ));
    }
    
    return(pRtcpRecvIO->dwError);
}

DWORD RtcpProcessPacket(
        RtcpAddrDesc_t  *pRtcpAddrDesc,
        RtcpRecvIO_t    *pRtcpRecvIO
    )
{
    RtcpCommon_t    *pRtcpCommon;
    char            *hdr;
    char            *end;
    int              len;
    short            len2;

    /* NOTE Compound packet was already validated, yet individual
     * packets (e.g. SR, RR, SDES) may need more validation and will
     * be ignored if errors were found */
    
    len = (int)pRtcpRecvIO->dwTransfered;

    hdr = pRtcpRecvIO->WSABuf.buf;

    end = hdr + len;

    while(len > sizeof(RtcpCommon_t))
    {
        pRtcpCommon = (RtcpCommon_t *)hdr;

        switch(pRtcpCommon->pt)
        {
        case RTCP_SR:
        case RTCP_RR:
            RtcpProcessSR_RR(pRtcpAddrDesc, hdr, len,
                             (SOCKADDR_IN *)&pRtcpRecvIO->From);
            break;
            
        case RTCP_SDES:
            RtcpProcessSDES(pRtcpAddrDesc, hdr);
            break;
            
        case RTCP_BYE:
            RtcpProcessBYE(pRtcpAddrDesc, hdr);
            break;
            
         case RTCP_APP:
            RtcpProcessAPP(pRtcpAddrDesc, hdr);
            break;

        default:
            RtcpProcessDefault(pRtcpAddrDesc, hdr);
        }
        
        len2 = pRtcpCommon->length;
        
        len2 = (ntohs(len2) + 1) * sizeof(DWORD);

        hdr += len2;
        
        len -= len2;
    }
    
    return(NOERROR);
}

/*
 * Creates and initialize a RtcpRecvIO_t structure
 * */
RtcpRecvIO_t *RtcpRecvIOAlloc(
        RtcpAddrDesc_t  *pRtcpAddrDesc
    )
{
    DWORD            dwError;
    RtcpRecvIO_t    *pRtcpRecvIO;
    TCHAR            Name[128];
    
    TraceFunctionName("RtcpRecvIOAlloc");

    pRtcpRecvIO = (RtcpRecvIO_t *)
        RtpHeapAlloc(g_pRtcpRecvIOHeap, sizeof(RtcpRecvIO_t));

    if (!pRtcpRecvIO) {
        
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_ALLOC,
                _T("%s: pRtcpAddrDesc[0x%p] failed to allocate memory"),
                _fname, pRtcpAddrDesc
            ));

        goto bail;
    }

    ZeroMemory(pRtcpRecvIO, sizeof(RtcpRecvIO_t) - RTCP_RECVDATA_BUFFER);

    pRtcpRecvIO->dwObjectID = OBJECTID_RTCPRECVIO;

    pRtcpRecvIO->pRtcpAddrDesc = pRtcpAddrDesc;

    /* Create a named event for overlapped completion */
    _stprintf(Name, _T("%X:pRtcpAddrDesc[0x%p] pRtcpRecvIO->hQosNotifyEvent"),
              GetCurrentProcessId(), pRtcpAddrDesc);
    
    pRtcpRecvIO->hRtcpCompletedEvent = CreateEvent(
            NULL,  /* LPSECURITY_ATTRIBUTES lpEventAttributes */
            FALSE, /* BOOL bManualReset */
            FALSE, /* BOOL bInitialState */
            Name   /* LPCTSTR lpName */
        );

    if (!pRtcpRecvIO->hRtcpCompletedEvent) {

        TraceRetailGetError(dwError);
        
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_RECV,
                _T("%s: failed to create hRtcpCompletedEvent %u (0x%X)"),
                _fname, dwError, dwError
            ));

        goto bail;
    }

    return(pRtcpRecvIO);

 bail:
    RtcpRecvIOFree(pRtcpRecvIO);

    return((RtcpRecvIO_t *)NULL);
}

/*
 * Deinitilize and frees a RtcpRecvIO_t structure
 * */
void RtcpRecvIOFree(RtcpRecvIO_t *pRtcpRecvIO)
{
    TraceFunctionName("RtcpRecvIOFree");
    
    if (!pRtcpRecvIO)
    {
        /* TODO may be log */
        return;
    }
    
    if (pRtcpRecvIO->dwObjectID != OBJECTID_RTCPRECVIO)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_ALLOC,
                _T("%s: pRtcpRecvIO[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtcpRecvIO,
                pRtcpRecvIO->dwObjectID, OBJECTID_RTCPRECVIO
            ));

        return;
    }

    /* Close event for asynchronous RTCP reception */
    if (pRtcpRecvIO->hRtcpCompletedEvent)
    {
        CloseHandle(pRtcpRecvIO->hRtcpCompletedEvent);
        pRtcpRecvIO->hRtcpCompletedEvent = NULL;
    }

    /* Invalidate object */
    INVALIDATE_OBJECTID(pRtcpRecvIO->dwObjectID);

    RtpHeapFree(g_pRtcpRecvIOHeap, pRtcpRecvIO);  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\msrtp\msrtpapi.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    msrtpapi.c, dsrtpapi.c
 *
 *  Abstract:
 *
 *    Contains the raw RTP implementation API, can be linked as a
 *    library (rtp.lib), linked into a DLL (msrtp.dll), or linked into
 *    a DShow DLL (dsrtp.dll).
 *
 *    This file is edited as msrtpapi.c and duplicated as dsrtpapi.c,
 *    each version is compiled with different flags
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/05/18 created
 *
 **********************************************************************/

#include <winsock2.h>

#include "gtypes.h"
#include "struct.h"
#include "rtphdr.h"
#include "rtpheap.h"
#include "rtprand.h"
#include "rtpglobs.h"
#include "rtpreg.h"
#include "rtcpsdes.h"

#include "rtpfwrap.h"
#include "rtpsess.h"

#include "rtpstart.h"
#include "rtprecv.h"
#include "rtpsend.h"

#include "rtcpthrd.h"

#include "rtpaddr.h"

#include "msrtpapi.h"

RTPSTDAPI CreateRtpSess(
        RtpSess_t **ppRtpSess
    )
{
    HRESULT hr;
    
    hr = GetRtpSess(ppRtpSess);

    return(hr);
}

RTPSTDAPI DeleteRtpSess(
        RtpSess_t *pRtpSess
    )
{
    HRESULT hr;
    
    hr = DelRtpSess(pRtpSess);

    return(hr);
}

/* TODO this two shouldn't be exposed, but I need them before I can
   use Control */

RTPSTDAPI CreateRtpAddr(
        RtpSess_t  *pRtpSess,
        RtpAddr_t **ppRtpAddr,
        DWORD       dwFlags
    )
{
    HRESULT hr;

    hr = GetRtpAddr(pRtpSess, ppRtpAddr, dwFlags);

    return(hr);
}

RTPSTDAPI DeleteRtpAddr(
        RtpSess_t *pRtpSess,
        RtpAddr_t *pRtpAddr
    )
{
    HRESULT hr;

    hr = DelRtpAddr(pRtpSess, pRtpAddr);

    return(hr);
}


RTPSTDAPI RtpControl(RtpSess_t *pRtpSess,
                     DWORD      dwControl,
                     DWORD_PTR  dwPar1,
                     DWORD_PTR  dwPar2)
{
    RtpControlStruct_t RtpControlStruct;
    
    if (!pRtpSess)
    {
        return(RTPERR_POINTER);
    }

    /*
     * TODO (may be) validate RtpSess by verifying that the memory
     * block is an item in the BusyQ in the g_pRtpSessHeap */
    if (pRtpSess->dwObjectID != OBJECTID_RTPSESS)
    {
        return(RTPERR_INVALIDRTPSESS);
    }

    /* Initialize Control structure */
    ZeroMemory(&RtpControlStruct, sizeof(RtpControlStruct_t));
    RtpControlStruct.pRtpSess = pRtpSess;
    RtpControlStruct.dwControlWord = dwControl;
    RtpControlStruct.dwPar1 = dwPar1;
    RtpControlStruct.dwPar2 = dwPar2;

    return( RtpValidateAndExecute(&RtpControlStruct) );
}

RTPSTDAPI RtpGetLastError(RtpSess_t *pRtpSess)
{
    return(NOERROR);
}
        
RTPSTDAPI RtpRegisterRecvCallback(
        RtpAddr_t       *pRtpAddr,
        PRTP_RECVCOMPLETIONFUNC pRtpRecvCompletionFunc
    )
{
    if (!pRtpAddr)
    {
        return(RTPERR_POINTER);
    }
    
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        return(RTPERR_INVALIDRTPSESS);
    }

    pRtpAddr->pRtpRecvCompletionFunc = pRtpRecvCompletionFunc;

    return(NOERROR);
}

RTPSTDAPI RtpRecvFrom(
        RtpAddr_t *pRtpAddr,
        WSABUF    *pWSABuf,
        void      *pvUserInfo1,
        void      *pvUserInfo2
    )
{
    HRESULT hr;
    
    hr = RtpRecvFrom_(pRtpAddr,
                      pWSABuf,
                      pvUserInfo1,
                      pvUserInfo2
        );

    return(hr);
}


RTPSTDAPI RtpSendTo(
        RtpAddr_t *pRtpAddr,
        WSABUF    *pWSABuf,
        DWORD      dwWSABufCount,
        DWORD      dwTimeStamp,
        DWORD      dwSendFlags
    )
{
    HRESULT hr;
    
    hr = RtpSendTo_(pRtpAddr, pWSABuf, dwWSABufCount, dwTimeStamp,dwSendFlags);

    return(hr);
}

RTPSTDAPI RtpStart(
        RtpSess_t *pRtpSess,
        DWORD      dwFlags
    )
{
    HRESULT hr;

    hr = RtpStart_(pRtpSess, dwFlags);

    return(hr);
}

RTPSTDAPI RtpStop(
        RtpSess_t *pRtpSess,
        DWORD      dwFlags
    )
{
    HRESULT hr;

    hr = RtpStop_(pRtpSess, dwFlags);

    return(hr);
}

/*
 * Initializes all the modules that require initialization. This
 * function can be called from DllMain(PROCESS_ATTACH) if linked as a
 * DLL, or explicitly from an application initializing the RTP stack
 * if linked as a library. */
RTPSTDAPI MSRtpInit1(HINSTANCE hInstance)
{
    HRESULT          hr1;
    HRESULT          hr2;
    BOOL             bOk1;
    BOOL             bOk2;
    BOOL             bOk3;
    BOOL             bOk4;

    /* One time operation that doesn't need de-init */
    /* NOTE this function will zero g_RtpContext */
    RtpInitReferenceTime();
    
    hr1 = RtpInit();
    
    /* initialize heaps */
    bOk1 = RtpCreateMasterHeap();
    bOk2 = RtpCreateGlobHeaps();
    
    bOk3 = RtpInitializeCriticalSection(&g_RtpContext.RtpWS2CritSect,
                                        &g_RtpContext,
                                        _T("g_RtpContext.RtpWS2CritSect"));

    bOk4 = RtpInitializeCriticalSection(&g_RtpContext.RtpPortsCritSect,
                                        &g_RtpContext,
                                        _T("g_RtpContext.RtpPortsCritSect"));


    hr2 = RtcpInit();

    if (!bOk1 || !bOk2 || !bOk3 || !bOk4 ||
        (hr1 != NOERROR) || (hr2 != NOERROR))
    {
        MSRtpDelete1();
        return(RTPERR_FAIL);
    }

    return(NOERROR);
}

/*
 * This function does initialization not allowed during process
 * attach, e.g. initialize winsock2 */
RTPSTDAPI MSRtpInit2(void)
{
    HRESULT          hr;
    BOOL             bOk;
    DWORD            dwError;
    WSADATA          WSAData;
    WORD             VersionRequested;
    

    hr = RTPERR_FAIL;

    /* Critical section was initialized during process attach by
     * MSRtpInit1 */
    bOk = RtpEnterCriticalSection(&g_RtpContext.RtpWS2CritSect);

    if (bOk)
    {
        if (g_RtpContext.lRtpWS2Users <= 0)
        {
            /* Initialize some debug variables */
            hr = RtpDebugInit(RTPDBG_MODULENAME);

            /* initialize winsock */
            VersionRequested = MAKEWORD(2,0);
            
            dwError = WSAStartup(VersionRequested, &WSAData);

            if (dwError == 0)
            {
                /* socket used to query destination address */
                g_RtpContext.RtpQuerySocket = WSASocket(
                        AF_INET,    /* int af */
                        SOCK_DGRAM, /* int type */
                        IPPROTO_IP, /* int protocol */
                        NULL,       /* LPWSAPROTOCOL_INFO lpProtocolInfo */
                        0,          /* GROUP g */
                        NO_FLAGS    /* DWORD dwFlags */
                    );
        
                if (g_RtpContext.RtpQuerySocket == INVALID_SOCKET)
                {
                    WSACleanup();
                }
                else
                {
                    RtpRegistryInit(&g_RtpReg);

                    /* Needs to be called after RtpRegistryInit so the
                     * possible registry defaults are already read */
                    RtcpSdesInit(&g_RtpSdesDefault);
                    RtcpSdesSetDefault(&g_RtpSdesDefault);

                    RtpRandInit();
                    
                    g_RtpContext.lRtpWS2Users = 1;

                    hr = NOERROR;
                }
            }
        }
        else
        {
            g_RtpContext.lRtpWS2Users++;

            hr = NOERROR;
        }

        RtpLeaveCriticalSection(&g_RtpContext.RtpWS2CritSect);
    }

    return(hr);
}

            
/*
 * Complementary function of MSRtpInit(). Can be called from
 * DllMain(PROCESS_DETACH) if linked as a DLL, or explicitly from an
 * application de-initializing the RTP stack if linked as a
 * library. */
RTPSTDAPI MSRtpDelete1(void)
{
    HRESULT          hr1;
    HRESULT          hr2;
    BOOL             bOk1;
    BOOL             bOk2;
    BOOL             bOk3;
    BOOL             bOk4;

    hr1 = RtpDelete();
    hr2 = RtcpDelete();

    bOk1 = RtpDestroyGlobHeaps();
    bOk2 = RtpDestroyMasterHeap();

    bOk3 = RtpDeleteCriticalSection(&g_RtpContext.RtpWS2CritSect);

    bOk4 = RtpDeleteCriticalSection(&g_RtpContext.RtpPortsCritSect);
    
    if ((hr1 != NOERROR) || (hr2 != NOERROR) ||
        !bOk1 || !bOk2 || !bOk3 || !bOk4)
    {
        return(RTPERR_FAIL);
    }
    else
    {
        return(NOERROR);
    }
}

/*
 * Complementary function of MSRtpInit2(). */
RTPSTDAPI MSRtpDelete2(void)
{
    HRESULT          hr;
    DWORD            dwError;
    BOOL             bOk;

    dwError = NOERROR;
    
    /* Critical section was initialized during process attach by
     * MSRtpInit1 */
    bOk = RtpEnterCriticalSection(&g_RtpContext.RtpWS2CritSect);

    if (bOk)
    {
        g_RtpContext.lRtpWS2Users--;

        if (g_RtpContext.lRtpWS2Users <= 0)
        {
            if (g_RtpContext.RtpQuerySocket != INVALID_SOCKET)
            {
                closesocket(g_RtpContext.RtpQuerySocket);
                g_RtpContext.RtpQuerySocket = INVALID_SOCKET;
            }
        
            dwError = WSACleanup();

            RtpRandDeinit();

            RtpRegistryDel(&g_RtpReg);

            RtpDebugDeinit();
        }

        RtpLeaveCriticalSection(&g_RtpContext.RtpWS2CritSect);
    }

    if ((bOk == FALSE) || (dwError != NOERROR))
    {
        return(RTPERR_FAIL);
    }
    else
    {
        return(NOERROR);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\rtcp\rtcpsend.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtcpsend.c
 *
 *  Abstract:
 *
 *    Format and send RTCP reports
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/07/10 created
 *
 **********************************************************************/

#include <winsock2.h>

#include "struct.h"
#include "rtpheap.h"
#include "rtpglobs.h"
#include "rtpncnt.h"
#include "rtprand.h"
#include "rtpcrypt.h"
#include "rtpevent.h"
#include "rtpmisc.h"
#include "rtpred.h"
#include "rtpreg.h"
#include "rtcpband.h"

#include "rtcpsend.h"

/*
 * Forward declaration of helper functions
 * */

HRESULT RtcpXmitPacket(RtpAddr_t *pRtpAddr, WSABUF *pWSABuf);

DWORD RtcpFillXRReport(RtpAddr_t *pRtpAddr, char *pBuffer, DWORD len);

DWORD RtcpFillProbe(RtpAddr_t *pRtpAddr, char *pBuffer, DWORD len);

void RtcpFillCommon(
        RtcpCommon_t    *pRtcpCommon,
        long             lCount,
        DWORD            dwPad,
        BYTE             bPT,
        DWORD            dwLen
    );

DWORD RtcpFillSInfo(RtpAddr_t *pRtpAddr, char *pBuffer, DWORD len);

DWORD RtcpFillReportBlocks(
        RtpAddr_t       *pRtpAddr,
        char            *pBuffer,
        DWORD            len,
        long            *plCount
    );

DWORD RtcpFillRBlock(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        char            *pBuffer
    );

DWORD RtcpFillSdesInfo(RtpAddr_t *pRtpAddr, char *pBuffer, DWORD len);

DWORD RtcpFillSdesItem(
        RtpSdes_t       *pRtpSdes,
        char            *pBuffer,
        DWORD            len,
        DWORD            dwItem);

DWORD ScheduleSdes(RtpSess_t *pRtpSess);

DWORD RtcpFillBye(RtpAddr_t *pRtpAddr, char *pBuffer, DWORD len);

DWORD RtcpFillPEBand(RtpAddr_t *pRtpAddr, char *pBuffer, DWORD len);

/*
 * Bandwidth estimation
 */
/* The initial count is the number of reports that will use
 * MOD_INITIAL to decide if a probe packet is sent, after that
 * MOD_FINAL will be used. */
DWORD            g_dwRtcpBandEstInitialCount =
                                RTCP_BANDESTIMATION_INITIAL_COUNT;

/* Number or valid reports received before the estimation is posted
 * for the first time */
DWORD            g_dwRtcpBandEstMinReports =
                                RTCP_BANDESTIMATION_MINREPORTS;
/* Initial modulo */
DWORD            g_dwRtcpBandEstModInitial = RTCP_BANDESTIMATION_MOD_INITIAL;

/* Final modulo */
DWORD            g_dwRtcpBandEstModNormal = RTCP_BANDESTIMATION_MOD_FINAL;

/*
 * WARNING
 *
 * Make sure to keep the number of individual bins to be
 * RTCP_BANDESTIMATION_MAXBINS+1 (same thing in rtpreg.h and rtpreg.c)
 *
 * Boundaries for each bin (note there is 1 more than the number of
 * bins) */
double           g_dRtcpBandEstBin[RTCP_BANDESTIMATION_MAXBINS + 1] =
{
    RTCP_BANDESTIMATION_BIN0,
    RTCP_BANDESTIMATION_BIN1,
    RTCP_BANDESTIMATION_BIN2,
    RTCP_BANDESTIMATION_BIN3,
    RTCP_BANDESTIMATION_BIN4
};

/* Estimation is valid if updated within this time (seconds) */
double           g_dRtcpBandEstTTL = RTCP_BANDESTIMATION_TTL;

/* An event is posted if no estimation is available within this
 * seconds after the first RB has been received */
double           g_dRtcpBandEstWait = RTCP_BANDESTIMATION_WAIT;

/* Maximum time gap between 2 consecutive RTCP SR reports to do
 * bandwidth estimation (seconds) */
double           g_dRtcpBandEstMaxGap = RTCP_BANDESTIMATION_MAXGAP;

/************************/

/**********************************************************************
 * Functions implementation
 **********************************************************************/

HRESULT RtcpSendReport(RtcpAddrDesc_t *pRtcpAddrDesc)
{
    char            *ptr;
    double           dRTCPLastTime;
    DWORD            used;
    DWORD            len;
    HRESULT          hr;
    WSABUF           WSABuf;
    DWORD            dwPacketSize;
    RtpAddr_t       *pRtpAddr;

    TraceFunctionName("RtcpSendReport");
    
    pRtpAddr = pRtcpAddrDesc->pRtpAddr;

    /* NOTE Reserve space for the 32bits random number used for
     * encryption, reserve it no matter we are actually encrypting or
     * not */
    
    ptr = pRtcpAddrDesc->pRtcpSendIO->SendBuffer + sizeof(DWORD);
    WSABuf.buf = ptr;
    len = sizeof(pRtcpAddrDesc->pRtcpSendIO->SendBuffer) - sizeof(DWORD);

    /* Bandwidth estimation is performed only when we are sending, it
     * hasn't been disabled because the other end is responding, it is
     * enabled, and the class is defined as audio */
    if (pRtpAddr->RtpNetSState.bWeSent
        &&
        !RtpBitTest(pRtpAddr->RtpNetSState.dwNetSFlags, FGNETS_DONOTSENDPROBE)
        &&
        RtpBitTest(pRtpAddr->pRtpSess->dwFeatureMask, RTPFEAT_BANDESTIMATION)
        &&
        (RtpGetClass(pRtpAddr->dwIRtpFlags) == RTPCLASS_AUDIO)
        )
    {
        /* If doing bandwidth estimation, decide if a probe packet
         * needs to be sent now */
        if ( !(pRtpAddr->RtpAddrCount[SEND_IDX].dwRTCPPackets %
               pRtpAddr->RtpNetSState.dwBandEstMod) )
        {
            /* Send a bandwidth probe RTCP SR packet */
            used = RtcpFillProbe(pRtpAddr, ptr, len);

            WSABuf.len = used;

            /* Update average RTCP report */
            RtcpUpdateAvgPacketSize(pRtpAddr, WSABuf.len);

            /* Save the time last RTCP was sent. I must use that one
             * to decide what participants (if any) will be included
             * in the report blocks in the legitimate RTCP report
             * (this been the probe RTCP report). If I don't, then
             * that time will be updated when this probe packet is
             * sent in RtcpXmitPacket and there is a good chance that
             * during a few milliseconds after that, enough to send
             * the ligitimate RTCP report, I would have not received
             * any more RTP packets hence preventing the inclusion of
             * that partipant in the report blocks which otherwise
             * would have been included */
            dRTCPLastTime = pRtpAddr->RtpAddrCount[SEND_IDX].dRTCPLastTime;
            
            hr = RtcpXmitPacket(pRtpAddr, &WSABuf);

            /* Restore the saved time */
            pRtpAddr->RtpAddrCount[SEND_IDX].dRTCPLastTime = dRTCPLastTime;
            
            pRtpAddr->RtpNetSState.dwBandEstCount++;
            
            TraceDebugAdvanced((
                    0, GROUP_RTCP, S_RTCP_RRSR,
                    _T("%s:  pRtpAddr[0x%p] RTCP SR probe packet sent ")
                    _T("at %0.3f"),
                    _fname, pRtpAddr, RtpGetTimeOfDay((RtpTime_t *)NULL)
                ));

            /* Now decide if the modulo needs to be updated */
#if 0
            /* Removing this code makes the probing packet to be sent
             * on every SR report sent if the initial modulo is kept
             * as 2 */
            if (pRtpAddr->RtpNetSState.dwBandEstCount ==
                g_dwRtcpBandEstInitialCount)
            {
                pRtpAddr->RtpNetSState.dwBandEstMod = g_dwRtcpBandEstModNormal;
            }
#endif       
            /* Restore ptr and len before going ahead to send next packet */
            ptr = WSABuf.buf;
            len =
                sizeof(pRtcpAddrDesc->pRtcpSendIO->SendBuffer) - sizeof(DWORD);
        }
    }
    
    /* Fill RR or SR */
    used = RtcpFillXRReport(pRtpAddr, ptr, len);
    ptr += used;
    len -= used;
    
    /* Fill SDES (new RTCP packet, same compound packet) */
    used = RtcpFillSdesInfo(pRtpAddr, ptr, len);
    ptr += used;
    
    WSABuf.len = (DWORD) (ptr - WSABuf.buf);

    /* Update average RTCP report */
    RtcpUpdateAvgPacketSize(pRtpAddr, WSABuf.len);

    hr = RtcpXmitPacket(pRtpAddr, &WSABuf);
    
    TraceDebug((
            0, GROUP_RTCP, S_RTCP_RRSR,
            _T("%s:  pRtpAddr[0x%p] RTCP packet sent at %0.3f"),
            _fname, pRtpAddr, RtpGetTimeOfDay((RtpTime_t *)NULL)
        ));

    return(hr);
}

/* TODO implement section 6.3.7 (Transmitting a BYE packet) from
 * draft-ietf-avt-rtp-new-05 that applies when sessions have more than
 * 50 participants and the sending of BYE is delayed */
HRESULT RtcpSendBye(RtcpAddrDesc_t *pRtcpAddrDesc)
{
    char          *ptr;
    DWORD          used;
    DWORD          len;
    HRESULT        hr;
    WSABUF         WSABuf;
    RtpAddr_t     *pRtpAddr;

    TraceFunctionName("RtcpSendBye");

    pRtpAddr = pRtcpAddrDesc->pRtpAddr;

    /* NOTE Reserve space for the 32bits random number used for
     * encryption, reserve it no matter we are actually encrypting or
     * not */
    
    ptr = pRtcpAddrDesc->pRtcpSendIO->SendBuffer + sizeof(DWORD);
    WSABuf.buf = ptr;
    len = sizeof(pRtcpAddrDesc->pRtcpSendIO->SendBuffer) - sizeof(DWORD);

    /* Fill RR or SR */
    used = RtcpFillXRReport(pRtpAddr, ptr, len);
    ptr += used;
    len -= used;
    
    /* Fill BYE (new RTCP packet, same compound packet) */
    used = RtcpFillBye(pRtpAddr, ptr, len);
    ptr += used;

    WSABuf.len = (DWORD) (ptr - WSABuf.buf);

    hr = RtcpXmitPacket(pRtpAddr, &WSABuf);
    
    TraceDebug((
            0, GROUP_RTCP, S_RTCP_RRSR,
            _T("%s:  pRtpAddr[0x%p] RTCP packet sent at %0.3f"),
            _fname, pRtpAddr, RtpGetTimeOfDay((RtpTime_t *)NULL)
        ));

    return(hr);
}


HRESULT RtcpXmitPacket(RtpAddr_t *pRtpAddr, WSABUF *pWSABuf)
{
    DWORD            dwEvent;
    RtpCrypt_t      *pRtpCrypt;
    SOCKADDR_IN      saddr;
    DWORD            dwStatus;
    DWORD            dwError;
    DWORD            dwNumBytesSent;
    double           dTime;
    TCHAR_t          sAddr[16];

    TraceFunctionName("RtcpXmitPacket");

    saddr.sin_family = AF_INET;
    saddr.sin_addr.s_addr = pRtpAddr->dwAddr[REMOTE_IDX];
    saddr.sin_port = pRtpAddr->wRtcpPort[REMOTE_IDX];

    dwError = NOERROR;
        
    if (!RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_RADDR) ||
        !pRtpAddr->wRtcpPort[REMOTE_IDX])
    {
        /* Do not send packet if remote address is not specified or
         * remote port is zero */
        TraceRetail((
                CLASS_WARNING, GROUP_RTCP, S_RTCP_SEND,
                _T("%s: pRtpAddr[0x%p] WSASendTo(len:%u, %s/%u) ")
                _T("failed: no destination address/port"), 
                _fname, pRtpAddr, pWSABuf->len,
                RtpNtoA(saddr.sin_addr.s_addr, sAddr),
                (DWORD)(ntohs(saddr.sin_port))
            ));
        
        goto end;
    }

    pRtpCrypt = pRtpAddr->pRtpCrypt[CRYPT_RTCP_IDX];
    
    if ( pRtpCrypt &&
         (RtpBitTest2(pRtpCrypt->dwCryptFlags, FGCRYPT_INIT, FGCRYPT_KEY) ==
          RtpBitPar2(FGCRYPT_INIT, FGCRYPT_KEY)) )
    {

        /* If using encryption, insert the random 32bits word at the
         * bigining of buffer */
        pWSABuf->buf -= sizeof(DWORD);
        pWSABuf->len += sizeof(DWORD);

        *(DWORD *)pWSABuf->buf = RtpRandom32((DWORD_PTR)pWSABuf);
        
        dwError = RtpEncrypt(
                pRtpAddr,
                pRtpAddr->pRtpCrypt[CRYPT_RTCP_IDX],
                pWSABuf,
                1,
                pRtpAddr->CryptBuffer[RTCP_IDX],
                pRtpAddr->dwCryptBufferLen[RTCP_IDX]
            );

        if (dwError)
        {
            if (!pRtpCrypt->CryptFlags.EncryptionError)
            {
                /* Post an event only the first time */
                pRtpCrypt->CryptFlags.EncryptionError = 1;
            
                RtpPostEvent(pRtpAddr,
                             NULL,
                             RTPEVENTKIND_RTP,
                             RTPRTP_CRYPT_SEND_ERROR,
                             RTCP_IDX,
                             pRtpCrypt->dwCryptLastError);
            }

            goto end;
        }
    }

    dwStatus = WSASendTo(
            pRtpAddr->Socket[SOCK_RTCP_IDX],/* SOCKET    s */
            pWSABuf,             /* LPWSABUF  lpBuffers */
            1,                   /* DWORD dwBufferCount */    
            &dwNumBytesSent,     /* LPDWORD lpNumberOfBytesSent */    
            0,                   /* DWORD dwFlags*/    
            (SOCKADDR *)&saddr,  /* const struct sockaddr FAR *lpTo */
            sizeof(saddr),       /* int iToLen*/
            NULL,                /* LPWSAOVERLAPPED lpOverlapped */
            NULL /* LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionROUTINE */
        );

    dTime = RtpGetTimeOfDay((RtpTime_t *)NULL);
    
    if (dwStatus)
    {
        TraceRetailWSAGetError(dwError);

        dwEvent = RTPRTP_WS_SEND_ERROR;
        
        if (dwError == WSAEADDRNOTAVAIL)
        {
            dwEvent = RTPRTP_WS_NET_FAILURE;
        }

        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_SEND,
                _T("%s: pRtpAddr[0x%p] WSASendTo(len:%u, %s/%u) ")
                _T("failed: %u (0x%X)"), 
                _fname, pRtpAddr, pWSABuf->len,
                RtpNtoA(saddr.sin_addr.s_addr, sAddr),
                (DWORD)(ntohs(saddr.sin_port)),
                dwError, dwError
            ));
        
        RtpPostEvent(pRtpAddr,
                     NULL,
                     RTPEVENTKIND_RTP,
                     dwEvent,
                     RTCP_IDX,
                     dwError);
        
        dwError = RTPERR_WS2SEND;
    }
    else
    {
        RtpUpdateNetCount(&pRtpAddr->RtpAddrCount[SEND_IDX],
                          NULL,
                          RTCP_IDX,
                          dwNumBytesSent,
                          NO_FLAGS,
                          dTime);
    }

 end:
    return(dwError);
}

DWORD RtcpFillXRReport(RtpAddr_t *pRtpAddr, char *pBuffer, DWORD len)
{
    DWORD          len2;
    DWORD          used;
    RtcpCommon_t  *pRtcpCommon;
    long           lCount;
    BYTE           bPT;
    
    TraceFunctionName("RtcpFillXRReport");

    /* Decide if SR or RR */
    bPT = pRtpAddr->RtpNetSState.bWeSent ? RTCP_SR : RTCP_RR;
    
    /* Fill up RTCP common header later */
    pRtcpCommon = (RtcpCommon_t *)pBuffer;
    
    pBuffer += sizeof(RtcpCommon_t);
    len -= sizeof(RtcpCommon_t);

    /* Set SSRC */
    *(DWORD *)pBuffer = pRtpAddr->RtpNetSState.dwSendSSRC;
    pBuffer += sizeof(DWORD);
    len -= sizeof(DWORD);

    /* Add sender info (if applicable) */
    if (bPT == RTCP_SR)
    {
        used = RtcpFillSInfo(pRtpAddr, pBuffer, len);
        pBuffer += used;
        len -= used;
    }

    /* Add report blocks */

    /* TODO when there is a large number of sender, send report blocks
     * for them in several packets (actually an open issue if I send a
     * burts of those packets, or schedule who is reported on which
     * packet) */
    used = RtcpFillReportBlocks(pRtpAddr, pBuffer, len, &lCount);
    pBuffer += used;
    len -= used;

    /* Add bandwidth estimation if available */
    used = RtcpFillPEBand(pRtpAddr, pBuffer, len);
    pBuffer += used;

    len = (DWORD) (pBuffer - (char *)pRtcpCommon);

    /* Finish initialization of first packet in the compound RTCP packet */
    RtcpFillCommon(pRtcpCommon, lCount, 0, bPT, len);

    TraceDebugAdvanced((
            0, GROUP_RTCP, S_RTCP_RRSR,
            _T("%s: pRtpAddr[0x%p] CC:%d RTCP %s packet prepared"),
            _fname, pRtpAddr, lCount, (bPT == RTCP_SR)? _T("SR") : _T("RR")
        ));
   
    return(len);
}

DWORD RtcpFillProbe(RtpAddr_t *pRtpAddr, char *pBuffer, DWORD len)
{
    DWORD          used;
    RtcpCommon_t  *pRtcpCommon;
    
    TraceFunctionName("RtcpFillProbe");

    /* Fill up RTCP common header later */
    pRtcpCommon = (RtcpCommon_t *)pBuffer;
    
    pBuffer += sizeof(RtcpCommon_t);
    len -= sizeof(RtcpCommon_t);
    
    /* Set SSRC */
    *(DWORD *)pBuffer = pRtpAddr->RtpNetSState.dwSendSSRC;
    pBuffer += sizeof(DWORD);
    len -= sizeof(DWORD);

    /* Add sender info */
    used = RtcpFillSInfo(pRtpAddr, pBuffer, len);
    pBuffer += used;

    len = (DWORD) (pBuffer - (char *)pRtcpCommon);

    /* Finish initialization of the only packet in the RTCP SR probe
     * packet */
    RtcpFillCommon(pRtcpCommon, 0, 0, RTCP_SR, len);

    TraceDebugAdvanced((
            0, GROUP_RTCP, S_RTCP_RRSR,
            _T("%s: pRtpAddr[0x%p] RTCP SR probe packet prepared"),
            _fname, pRtpAddr
        ));
   
    return(len);
}

void RtcpFillCommon(
        RtcpCommon_t *pRtcpCommon,
        long          lCount,
        DWORD         dwPad,
        BYTE          bPT,
        DWORD         dwLen
    )
{
    pRtcpCommon->count = (BYTE)lCount;
    pRtcpCommon->p = (BYTE)(dwPad & 1);
    pRtcpCommon->version = RTP_VERSION;
    pRtcpCommon->pt = bPT;
    dwLen = (dwLen >> 2) - 1;
    pRtcpCommon->length = htons((WORD)dwLen);
}

DWORD RtcpFillSInfo(RtpAddr_t *pRtpAddr, char *pBuffer, DWORD len)
{
    DWORD            used;
    RtcpSInfo_t     *pRtcpSInfo;
    RtpNetCount_t   *pRtpNetCount;
    RtpNetSState_t  *pRtpNetSState;
    double           dTime;
    double           TimeLastRtpSent;
    DWORD            dwSendTimeStamp;
    DWORD            dwSamplingFreq;

    TraceFunctionName("RtcpFillSInfo");

    pRtpNetCount  = &pRtpAddr->RtpAddrCount[SEND_IDX];
    pRtpNetSState = &pRtpAddr->RtpNetSState;
    
    used = 0;
    
    if (pRtpNetCount && len >= sizeof(RtcpSInfo_t)) {
        /* Insert Sender Info */

        pRtcpSInfo = (RtcpSInfo_t *)pBuffer;

        /* Obtain latest NTP/timestamp pair */
        if (RtpEnterCriticalSection(&pRtpAddr->NetSCritSect))
        {
            dTime = RtpGetTimeOfDay((RtpTime_t *)NULL);

            dwSendTimeStamp = pRtpNetSState->dwSendTimeStamp;
            
            TimeLastRtpSent = pRtpNetSState->dTimeLastRtpSent;
            
            dwSamplingFreq = pRtpNetSState->dwSendSamplingFreq;
            /*
             * We can now early release the critical section
             * */
            RtpLeaveCriticalSection(&pRtpAddr->NetSCritSect);

            /* pRtpNetSState->dTimeLastRtpSent and
             * pRtpNetSState->dwSendTimeStamp are updated in UpdateRtpHdr()
             * */

            /* NOTE
             *
             * The time the last RTP packet was sent may not
             * correspond to the current time, so, in order to the SR
             * to contain the current time, and the timestamp to match
             * that time, the timestamp is computed rather than taken
             * from the last RTP packet sent */

            pRtcpSInfo->ntp_sec = (DWORD)dTime;
        
            pRtcpSInfo->ntp_frac = (DWORD)
                ( (dTime - (double) pRtcpSInfo->ntp_sec) * 4294967296.0 );

            /* NOTE This assumes (as expected) that dTime >=
             * TimeLastRtpSent */
            pRtcpSInfo->rtp_ts =
                dwSendTimeStamp + (DWORD)
                (((dTime - TimeLastRtpSent) * (double)dwSamplingFreq) + 5e-9);

            TraceRetailAdvanced((
                    0, GROUP_RTCP, S_RTCP_NTP,
                    _T("%s: pRtpAddr[0x%p] NTP:%0.3f/%u ntp:%04X:%04X ")
                    _T("ts:%u (+%u) elapsed:%0.3fs"),
                    _fname, pRtpAddr, dTime, pRtcpSInfo->rtp_ts,
                    pRtcpSInfo->ntp_sec & 0xffff,
                    pRtcpSInfo->ntp_frac >> 16,
                    dwSendTimeStamp, pRtcpSInfo->rtp_ts-dwSendTimeStamp,
                    dTime - TimeLastRtpSent
                ));
            
            pRtcpSInfo->ntp_sec = htonl(pRtcpSInfo->ntp_sec);

            pRtcpSInfo->ntp_frac = htonl(pRtcpSInfo->ntp_frac);
        
            pRtcpSInfo->rtp_ts = htonl(pRtcpSInfo->rtp_ts);
            
            pRtcpSInfo->psent = htonl(pRtpNetCount->dwRTPPackets);
                                     
            pRtcpSInfo->bsent = htonl(pRtpNetCount->dwRTPBytes);

        }
        else
        {
            ZeroMemory(pBuffer, sizeof(RtcpSInfo_t));
        }

        used = sizeof(RtcpSInfo_t);
    }
    
    return(used);
}

/* Include (somehow) all the participants that have sent since the
 * last RTCP report we sent */
DWORD RtcpFillReportBlocks(
        RtpAddr_t       *pRtpAddr,
        char            *pBuffer,
        DWORD            len,
        long             *plCount
    )
{
    BOOL             bOk;
    DWORD            used;
    long             lCount;
    long             lMax;
    RtpQueue_t       ToReportQ;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpUser_t       *pRtpUser;

    TraceFunctionName("RtcpFillReportBlocks");

    used = 0;
    *plCount = 0;

    /* Determine what is the maximum number of report blocks we can
     * include */
    lMax = len / sizeof(RtcpRBlock_t);

    if (lMax > MAX_RTCP_RBLOCKS)
    {
        lMax = MAX_RTCP_RBLOCKS;
    }
    else if (!lMax)
    {
        /* We don't have room for any RB */
        return(used);
    }
    
    ZeroMemory((char *)&ToReportQ, sizeof(RtpQueue_t));
    
    bOk = RtpEnterCriticalSection(&pRtpAddr->PartCritSect);

    if (bOk)
    {
        lCount =
            GetQueueSize(&pRtpAddr->Cache1Q) +
            GetQueueSize(&pRtpAddr->Cache2Q);

        if (lCount <= lMax)
        {
            /* We can report all the senders */

            /* Add to report list participants in Cache1Q */
            lCount = GetQueueSize(&pRtpAddr->Cache1Q);
            pRtpQueueItem = pRtpAddr->Cache1Q.pFirst;
            
            for(; lCount > 0; lCount--)
            {
                pRtpUser =
                    CONTAINING_RECORD(pRtpQueueItem, RtpUser_t, UserQItem);

                enqueuel(&ToReportQ, NULL, &pRtpUser->ReportQItem);
                
                pRtpQueueItem = pRtpQueueItem->pNext;
            }
            
            /* Add to report list participants in Cache2Q */
            lCount = GetQueueSize(&pRtpAddr->Cache2Q);
            pRtpQueueItem = pRtpAddr->Cache2Q.pFirst;
            
            for(; lCount > 0; lCount--)
            {
                pRtpUser =
                    CONTAINING_RECORD(pRtpQueueItem, RtpUser_t, UserQItem);

                enqueuel(&ToReportQ, NULL, &pRtpUser->ReportQItem);
                
                pRtpQueueItem = pRtpQueueItem->pNext;
            }
        }
        else
        {
            /* We need to select a random subset of all the senders to
             * be included in the report rather than sending multiple
             * RTCP packets to report every body */

            /* TODO right now don't send any report, the mechanism
             * used to select the senders reported is independent of
             * the use of a sampling algorithm. */

            /* A possibility to guide the choice is to report only
             * those senders that are of interest to the user,
             * e.g. those that are mapped in a DShow graph */

            TraceRetail((
                    CLASS_WARNING, GROUP_RTCP, S_RTCP_RRSR,
                    _T("%s: pRtpAddr[0x%p] Too many RBlocks:%d ")
                    _T("not reporting them"),
                    _fname, pRtpAddr, lCount
                ));
        }

        RtpLeaveCriticalSection(&pRtpAddr->PartCritSect);

        /* Add the report blocks to the packet */
        lCount = GetQueueSize(&ToReportQ);

        if (!lCount)
        {
            TraceRetail((
                    CLASS_WARNING, GROUP_RTCP, S_RTCP_RRSR,
                    _T("%s: pRtpAddr[0x%p] No RBlocks added"),
                    _fname, pRtpAddr
                ));
        }
        else
        {
            while(lCount > 0)
            {
                pRtpQueueItem = dequeuef(&ToReportQ, NULL);

                pRtpUser =
                    CONTAINING_RECORD(pRtpQueueItem, RtpUser_t, ReportQItem);
            
                len = RtcpFillRBlock(pRtpAddr, pRtpUser, pBuffer);

                used += len;
                pBuffer += len;

                lCount--;
            }
        }

        *plCount = (used / sizeof(RtcpRBlock_t));
    }
        
    return(used);
}

/* Fills a single report block */
DWORD RtcpFillRBlock(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        char            *pBuffer
    )
{
    BOOL             bOk;
    DWORD            used;
    DWORD            extended_max;
    int              lost;
    DWORD            expected;
    DWORD            expected_interval;
    DWORD            received_interval;
    int              lost_interval;
    int              lost_rate;
    DWORD            red_expected_interval;
    DWORD            red_received_interval;
    int              red_lost_interval;
    int              red_lost_rate;
    DWORD            fraction;
    DWORD            dwSecs;
    double           dLSR;
    double           dDLSR;
    double           dCurrentTime;
    RtcpRBlock_t    *pRtcpRBlock;
    RtpNetRState_t  *pRtpNetRState;

    TraceFunctionName("RtcpFillRBlock");

    pRtcpRBlock = (RtcpRBlock_t *)pBuffer;
    
    pRtpNetRState = &pRtpUser->RtpNetRState;

    used = 0;
    
    bOk = RtpEnterCriticalSection(&pRtpUser->UserCritSect);

    if (bOk)
    {
        /* Check if we have received since last report sent */
        if (pRtpUser->RtpUserCount.dRTPLastTime <
            pRtpAddr->RtpAddrCount[SEND_IDX].dRTCPLastTime)
        {
            /* We haven't received RTP packets recently so don't
             * report this sender */
            RtpLeaveCriticalSection(&pRtpUser->UserCritSect);

            TraceDebugAdvanced((
                    0, GROUP_RTCP, S_RTCP_RRSR,
                    _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                    _T("Not including this RBlock, ")
                    _T("RTP(%0.3f) < RTCP(%0.3f)"),
                    _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                    pRtpUser->RtpUserCount.dRTPLastTime,
                    pRtpAddr->RtpAddrCount[SEND_IDX].dRTCPLastTime
                ));
            
            return(used);
        }

        /* SSRC kept in NETWORK order */
        pRtcpRBlock->ssrc = pRtpUser->dwSSRC;

        /*
         * Cumulative losses
         * */
        extended_max = pRtpNetRState->cycles + pRtpNetRState->max_seq;

        /* expected is always positive as extended_max keeps growing
         * but base_seq ramains the same */
        expected = extended_max - pRtpNetRState->base_seq + 1;

        /* lost can be negative if we have duplicates */
        lost = expected - pRtpNetRState->received;

        /* NOTE in draft-ietf-avt-rtp-new-05 it says "clamp at
         * 0x7fffff for positive loss or 0xffffff for negative loss"
         * which seems to imply the representaion for negative numbers
         * is not 2s complemet on which the biggest negative number
         * would be 0x800000, below I'm using the biggest negative
         * number represented on any computer (i.e. using 2s
         * complement) */

        /* clamp to a 24bits signed number */
        if (lost > 8388607)
        {
            lost = 8388607;
        }
        else if (lost < -8388608)
        {
            lost = -8388608;
        }

        /* >>>> Test lost */
        /* lost = -5717; */
        
        /*
         * Fraction lost
         * */
        /* expected_interval must always be positive as expected is,
         * also, expected is always >= expected_prior */
        expected_interval = expected - pRtpNetRState->expected_prior;
        
        pRtpNetRState->expected_prior = expected;

        /* received_interval is always positive, it can only grow,
         * i.e. received >= received_prior */
        received_interval =
            pRtpNetRState->received - pRtpNetRState->received_prior;
        
        pRtpNetRState->received_prior = pRtpNetRState->received;
        
        lost_interval = expected_interval - received_interval;
        
        if (expected_interval == 0 || lost_interval <= 0)
        {
            fraction = 0;
            lost_rate = 0;
        }
        else
        {
            fraction = (lost_interval << 8) / expected_interval;
            lost_rate =
                (lost_interval * 100 * LOSS_RATE_FACTOR) / expected_interval;
        }

        pRtpNetRState->iAvgLossRateR =
            RtpUpdateLossRate(pRtpNetRState->iAvgLossRateR, lost_rate);
        
        /* Compute the fraction lost after packet reconstruction
         * (using redundancy) */
        expected = pRtpNetRState->red_max_seq - pRtpNetRState->base_seq + 1;

        red_expected_interval = expected - pRtpNetRState->red_expected_prior;
        
        pRtpNetRState->red_expected_prior = expected;
        
        red_received_interval =
            pRtpNetRState->red_received - pRtpNetRState->red_received_prior;

        pRtpNetRState->red_received_prior = pRtpNetRState->red_received;
        
        red_lost_interval = red_expected_interval - red_received_interval;

        if (red_expected_interval == 0 || red_lost_interval <= 0)
        {
            red_lost_rate = 0;
        }
        else
        {
            red_lost_rate =
                (red_lost_interval * 100 * LOSS_RATE_FACTOR) /
                red_expected_interval;
        }

        pRtpNetRState->iRedAvgLossRateR =
            RtpUpdateLossRate(pRtpNetRState->iRedAvgLossRateR, red_lost_rate);

        TraceRetailAdvanced((
                0, GROUP_RTCP, S_RTCP_LOSSES,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                _T("reporting recv loss rate:%5.2f%%/%0.2f%% ")
                _T("avg:%5.2f%%/%0.2f%% jitter:%0.3fs"),
                _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                (double)lost_rate / LOSS_RATE_FACTOR,
                (double)red_lost_rate / LOSS_RATE_FACTOR,
                (double)pRtpNetRState->iAvgLossRateR / LOSS_RATE_FACTOR,
                (double)pRtpNetRState->iRedAvgLossRateR / LOSS_RATE_FACTOR,
                (double)pRtpNetRState->jitter/pRtpNetRState->dwRecvSamplingFreq
            ));

        /* Post loss rate as an event */
        RtpPostEvent(pRtpAddr,
                     pRtpUser,
                     RTPEVENTKIND_RTP,
                     RTPRTP_RECV_LOSSRATE,
                     pRtpUser->dwSSRC,
                     pRtpNetRState->iRedAvgLossRateR);
        
        /* >>>> Test fraction */
        /* fraction = (17 * 256) / 100; */
        
        /* Compose DWORD containing fraction lost (8) and cumulative
         * lost (24) */
        pRtcpRBlock->frac_cumlost =
            ((fraction & 0xff) << 24) | (lost & 0xffffff);

        /* Extended last sequence number received */
        pRtcpRBlock->last_seq = extended_max;

        /* Interarrival jitter */
        pRtcpRBlock->jitter = pRtpNetRState->jitter;

        /*
         * We can now early release the critical section
         */
        RtpLeaveCriticalSection(&pRtpUser->UserCritSect);

        if (RtpBitTest(pRtpUser->dwUserFlags, FGUSER_SR_RECEIVED))
        {
            /* Set values for LSR and DLSR only if we have already
             * received a SR */

            /* Time from last SR */
            pRtcpRBlock->lsr =
                (pRtpNetRState->NTP_sr_rtt.dwSecs & 0xffff) << 16;

            pRtcpRBlock->lsr |= (DWORD)
                ( ( ((double)pRtpNetRState->NTP_sr_rtt.dwUSecs / 1000000.0) *
                    65536.0 ) + 5e-9);

            dLSR = (double)pRtpNetRState->NTP_sr_rtt.dwSecs +
                (double)pRtpNetRState->NTP_sr_rtt.dwUSecs / 1000000.0;

            /* Delay since last SR was received */
            dCurrentTime = RtpGetTimeOfDay((RtpTime_t *)NULL);
        
            dDLSR =
                dCurrentTime -
                (double)pRtpNetRState->TimeLastSRRecv.dwSecs -
                (double)pRtpNetRState->TimeLastSRRecv.dwUSecs / 1000000.0;

            dwSecs = (DWORD)dDLSR;
            
            pRtcpRBlock->dlsr = (dwSecs & 0xffff) << 16;

            pRtcpRBlock->dlsr |= (DWORD)
                ( ( (dDLSR - (double)dwSecs) * 65536.0 ) + 5e-9);
        }
        else
        {
            dLSR = 0.0;
            
            dDLSR = 0.0;
            
            pRtcpRBlock->lsr = 0;
            
            pRtcpRBlock->dlsr = 0;
        }

        TraceRetailAdvanced((
                0, GROUP_RTCP, S_RTCP_RRSR,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                _T("LSR:%0.3f DLSR:%0.3f"),
                _fname, pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                dLSR, dDLSR
            ));
  
        /* Put in NETWORK order */
        pRtcpRBlock->frac_cumlost = htonl(pRtcpRBlock->frac_cumlost);

        pRtcpRBlock->last_seq = htonl(extended_max);

        pRtcpRBlock->jitter = htonl(pRtcpRBlock->jitter);
        
        pRtcpRBlock->lsr = htonl(pRtcpRBlock->lsr);
        
        pRtcpRBlock->dlsr = htonl(pRtcpRBlock->dlsr);

        used = sizeof(RtcpRBlock_t);
    }
    
    return(used);
}

DWORD RtcpFillSdesInfo(RtpAddr_t *pRtpAddr, char *pBuffer, DWORD len)
{
    DWORD            used;
    DWORD            len2;
    DWORD            dwItemsToSend;
    DWORD            dwItem;
    DWORD            pad;
    RtcpCommon_t    *pRtcpCommon;
    RtpSdes_t       *pRtpSdes;
    RtpNetCount_t   *pRtpNetCount;

    used = 0;

    pRtpSdes = pRtpAddr->pRtpSess->pRtpSdes;
    
    if (pRtpSdes)
    {
        pRtcpCommon = (RtcpCommon_t *)pBuffer;

        /* TODO find out if the len passed is enough for first SDES item
         * (CNAME), second, third */
        pBuffer += sizeof(RtcpCommon_t);
        len -= sizeof(RtcpCommon_t);

        *(DWORD *)pBuffer = pRtpAddr->RtpNetSState.dwSendSSRC;
        pBuffer += sizeof(DWORD);
        len -= sizeof(DWORD);

        /* Schedule items to send */
        dwItemsToSend = ScheduleSdes(pRtpAddr->pRtpSess);

        for(dwItem = RTCP_SDES_CNAME, len2 = 0;
            dwItem < RTCP_SDES_LAST;
            dwItem++) {

            if (RtpBitTest(dwItemsToSend, dwItem)) {

                used = RtcpFillSdesItem(pRtpSdes, pBuffer, len, dwItem);

                if (!used) {
                    /* buffer not enough big */
                    break;
                }
                
                pBuffer += used;
                len2 += used;
                len -= used;
            }
        }

        if (len2 > 0) {

            pad = (DWORD) ((DWORD_PTR)pBuffer & 0x3);
            
            /* insert 1 or more END items to pad to a 32 bits boundary
             *
             * Note that this padding is separate from that indicated
             * by the P bit in the RTCP header */
            pad = 4 - pad;

            ZeroMemory(pBuffer, pad);
            pBuffer += pad;
            
            /* total size */
            used = (DWORD) (pBuffer - (char *)pRtcpCommon);

            /* Finish initialization of SDES header */
            RtcpFillCommon(pRtcpCommon, 1, 0, RTCP_SDES, used);
 
        } else {
            used = 0;
        }
    }
    
    return(used);
}

DWORD RtcpFillSdesItem(
        RtpSdes_t       *pRtpSdes,
        char            *pBuffer,
        DWORD            len,
        DWORD            dwItem
    )
{
    DWORD            used;
    DWORD            dwItemLen;
    RtcpSdesItem_t  *pRtcpSdesItem;

    used = 0;
    dwItemLen = pRtpSdes->RtpSdesItem[dwItem].dwDataLen;
    
    if (dwItemLen > 0 && (dwItemLen + sizeof(RtcpSdesItem_t)) <= len ) {

        pRtcpSdesItem = (RtcpSdesItem_t *)pBuffer;
        pBuffer += sizeof(RtcpSdesItem_t);
        len -= sizeof(RtcpSdesItem_t);
        
        CopyMemory(pBuffer,
                   pRtpSdes->RtpSdesItem[dwItem].pBuffer,
                   pRtpSdes->RtpSdesItem[dwItem].dwDataLen);

        pBuffer += pRtpSdes->RtpSdesItem[dwItem].dwDataLen;

        pRtcpSdesItem->type = (BYTE)dwItem;
        pRtcpSdesItem->length = (BYTE)pRtpSdes->RtpSdesItem[dwItem].dwDataLen;
        
        used = (DWORD) (pBuffer - (char *)pRtcpSdesItem);
    }

    return(used);
}

/* TODO, should be able to set a user defined reason */
DWORD RtcpFillBye(RtpAddr_t *pRtpAddr, char *pBuffer, DWORD len)
{
    DWORD            pad;
    DWORD            slen;
    RtcpCommon_t    *pRtcpCommon;
    RtpSdes_t       *pRtpSdes;

    pRtcpCommon = (RtcpCommon_t *)pBuffer;

    pBuffer += sizeof(RtcpCommon_t);
    len -= sizeof(RtcpCommon_t);

    /* Set SSRC */
    *(DWORD *)pBuffer = pRtpAddr->RtpNetSState.dwSendSSRC;
    pBuffer += sizeof(DWORD);
    len -= sizeof(DWORD);

    /* Set reason (if available) */
    if (RtpBitTest(pRtpAddr->pRtpSess->dwSdesPresent, RTCP_SDES_BYE))
    {
        pRtpSdes = pRtpAddr->pRtpSess->pRtpSdes;
        
        slen = pRtpSdes->RtpSdesItem[RTCP_SDES_BYE].dwDataLen;

        if (len < (slen + 1))
        {
            /* If buffer is not enough big, truncate the bye reason */
            slen = ((len - 1)/sizeof(TCHAR_t)) * sizeof(TCHAR_t);
        }
        
        *pBuffer = (char)slen;
        pBuffer++;
        len--;

        CopyMemory(pBuffer,
                   pRtpSdes->RtpSdesItem[RTCP_SDES_BYE].pBuffer, slen);
    
        pBuffer += slen;
    }

    pad = (DWORD) ((DWORD_PTR)pBuffer & 0x3);

    /* insert 1 or more  NULL chars to pad to a 32 bits boundary
     *
     * Note that this padding is separate from that indicated
     * by the P bit in the RTCP header */
    pad = 4 - pad;

    ZeroMemory(pBuffer, pad);
    pBuffer += pad;

    /* Get total packet's length */
    len = (DWORD) (pBuffer - (char *)pRtcpCommon);

    /* Finish initialization of SDES header */
    RtcpFillCommon(pRtcpCommon, 1, 0, RTCP_BYE, len);
    
    return(len);
}

DWORD RtcpFillPEBand(RtpAddr_t *pRtpAddr, char *pBuffer, DWORD len)
{
    BOOL             bOk;
    DWORD            used;
    DWORD            dwBin;
    double           dTime;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpUser_t       *pRtpUser;
    RtpNetRState_t  *pRtpNetRState;
    RtpBandEst_t    *pRtpBandEst;
    
    used = 0;

    if (len < sizeof(RtpBandEst_t))
    {
        return(used);
    }
    
    bOk = RtpEnterCriticalSection(&pRtpAddr->PartCritSect);
    
    if (bOk)
    {
        pRtpQueueItem = pRtpAddr->Cache1Q.pFirst;

        RtpLeaveCriticalSection(&pRtpAddr->PartCritSect);

        if (pRtpQueueItem)
        {
            pRtpUser =
                CONTAINING_RECORD(pRtpQueueItem, RtpUser_t, UserQItem);

            pRtpNetRState = &pRtpUser->RtpNetRState;

            dTime = RtpGetTimeOfDay(NULL);
            
            /* Determine if we have bandwidth estimation to report */
            if ( (dTime - pRtpNetRState->dLastTimeEstimation) <
                 g_dRtcpBandEstTTL )
            {
                used = sizeof(RtpBandEst_t);

                pRtpBandEst = (RtpBandEst_t *)pBuffer;

                pRtpBandEst->type = htons((WORD)RTPPE_BANDESTIMATION);
                pRtpBandEst->len = htons((WORD)used);

                /* Already NETWORK order */
                pRtpBandEst->dwSSRC = pRtpUser->dwSSRC;

                if (!RtpBitTest(pRtpNetRState->dwNetRStateFlags2,
                                FGNETRS2_BANDESTNOTREADY))
                {
                    if (!RtpBitTest(pRtpNetRState->dwNetRStateFlags2,
                                    FGNETRS2_BANDWIDTHUNDEF))
                    {
                        dwBin = pRtpNetRState->dwBestBin;
                        
                        pRtpBandEst->dwBandwidth = (DWORD)
                            (pRtpNetRState->dBinBandwidth[dwBin] /
                             pRtpNetRState->dwBinFrequency[dwBin]);

                        pRtpBandEst->dwBandwidth =
                            htonl(pRtpBandEst->dwBandwidth);
                    }
                    else
                    {
                        /* If last estimation was undefined, i.e. the gap
                         * between the 2 consecutive packets was 0 or
                         * negative, report RTP_BANDWIDTH_UNDEFINED as the
                         * estimated bandwidth */
                        pRtpBandEst->dwBandwidth =
                            htonl(RTP_BANDWIDTH_UNDEFINED);
                    }
                }
                else
                {
                    pRtpBandEst->dwBandwidth =
                        htonl(RTP_BANDWIDTH_BANDESTNOTREADY);
                }
            }
        }
    }

    return(used);
}

/*
 * The scheduler will send a CNAME on every report, then, every L1
 * reports will send a second SDES item.
 *
 * The second SDES item will be NAME, and every L2 reports, it will be
 * OTHER SDES item.
 *
 * The OTHER SDES item will be EMAIL, and every L3 reports, it will be
 * OTHER2 SDES item.
 *
 * The OTHER2 SDES item will be different on each time it is included,
 * and will start from PHONE to PRIV to go back to PHONE
 *
 * If all the SDES items are available and enabled to be sent, and the
 * reports are sent every 5 secs, all of the SDES items will be sent
 * in: 5secs * (5 * L3 * L2 * L1) = 400 secs ~= 7 min */
DWORD ScheduleSdes(RtpSess_t *pRtpSess)
{
    RtpSdesSched_t *pRtpSdesSched;
    DWORD           dwItemsToSend;
    DWORD           dwMask;

    dwItemsToSend = 0;
    pRtpSdesSched = &pRtpSess->RtpSdesSched;
    dwMask        = pRtpSess->dwSdesPresent & pRtpSess->dwSdesMask[LOCAL_IDX];

    /* CNAME */
    if (RtpBitTest(pRtpSess->dwSdesPresent, RTCP_SDES_CNAME)) {
        
        RtpBitSet(dwItemsToSend, RTCP_SDES_CNAME);
    }

    pRtpSdesSched->L1++;

    if ( !(pRtpSdesSched->L1 % SDES_MOD_L1)) {

        pRtpSdesSched->L2++;

        if ((pRtpSdesSched->L2 % SDES_MOD_L2) &&
            RtpBitTest(dwMask, RTCP_SDES_NAME)) {

            /* NAME */
            RtpBitSet(dwItemsToSend, RTCP_SDES_NAME);
            
        } else {

            pRtpSdesSched->L3++;

            if ((pRtpSdesSched->L3 % SDES_MOD_L3) &&
                RtpBitTest(dwMask, RTCP_SDES_EMAIL)) {

                /* EMAIL */
                RtpBitSet(dwItemsToSend, RTCP_SDES_EMAIL);
                
            } else {

                /* Others */
                if (RtpBitTest(dwMask, pRtpSdesSched->L4 + RTCP_SDES_PHONE)) {
                    RtpBitSet(dwItemsToSend,
                              pRtpSdesSched->L4 + RTCP_SDES_PHONE);
                }

                pRtpSdesSched->L4++;

                if (pRtpSdesSched->L4 >= (RTCP_SDES_LAST-RTCP_SDES_PHONE-1)) {
                    pRtpSdesSched->L4 = 0;
                }
            }
        }
    }

    return(dwItemsToSend);
}

/*
 * Creates and initialize a RtcpSendIO_t structure
 * */
RtcpSendIO_t *RtcpSendIOAlloc(RtcpAddrDesc_t *pRtcpAddrDesc)
{
    RtcpSendIO_t    *pRtcpSendIO;
    
    TraceFunctionName("RtcpSendIOAlloc");

    pRtcpSendIO = RtpHeapAlloc(g_pRtcpSendIOHeap, sizeof(RtcpSendIO_t));

    if (!pRtcpSendIO)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_ALLOC,
                _T("%s: pRtcpAddrDesc[0x%p] failed to allocate memory"),
                _fname, pRtcpAddrDesc
            ));

        goto bail;
    }

    pRtcpSendIO->dwObjectID = OBJECTID_RTCPSENDIO;

    pRtcpSendIO->pRtcpAddrDesc = pRtcpAddrDesc;
    
    return(pRtcpSendIO);

 bail:
    RtcpSendIOFree(pRtcpSendIO);

    return((RtcpSendIO_t *)NULL);
}

/*
 * Deinitilize and frees a RtcpSendIO_t structure
 * */
void RtcpSendIOFree(RtcpSendIO_t *pRtcpSendIO)
{
    TraceFunctionName("RtcpSendIOFree");

    if (!pRtcpSendIO)
    {
        /* TODO may be log */
        return;
    }
    
    if (pRtcpSendIO->dwObjectID != OBJECTID_RTCPSENDIO)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_ALLOC,
                _T("%s: pRtcpSendIO[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtcpSendIO,
                pRtcpSendIO->dwObjectID, OBJECTID_RTCPSENDIO
            ));
        
        return;
    }

    /* Invalidate object */
    INVALIDATE_OBJECTID(pRtcpSendIO->dwObjectID);
    
    RtpHeapFree(g_pRtcpSendIOHeap, pRtcpSendIO);  
}

/* Update the average RTCP packet size sent and received, the packets
 * size is in bytes but the average is kept in bits */
double RtcpUpdateAvgPacketSize(RtpAddr_t *pRtpAddr, DWORD dwPacketSize)
{
    BOOL             bOk;
    
    /* Packet size for average includes the UDP/IP headers as per
     * draft-ietf-avt-rtp-new-05 */
    dwPacketSize += SIZEOF_UDP_IP_HDR;

    /* We are going to keep the average RTCP packet size in bits */
    dwPacketSize *= 8;
    
    /* Compute average RTCP packet size, the weight is according to
     * draft-ietf-avt-rtp-new-05 */
    if (pRtpAddr->RtpNetSState.avg_rtcp_size)
    {
        pRtpAddr->RtpNetSState.avg_rtcp_size =
            ( 1.0/16.0) * dwPacketSize +
            (15.0/16.0) * pRtpAddr->RtpNetSState.avg_rtcp_size;
    }
    else
    {
        pRtpAddr->RtpNetSState.avg_rtcp_size = dwPacketSize;
    }
    
    return(pRtpAddr->RtpNetSState.avg_rtcp_size);
}

void RtpSetBandEstFromRegistry(void)
{
    DWORD           *pDWORD;
    DWORD            i;
    
    if (IsDWValueSet(g_RtpReg.dwBandEstModulo) && g_RtpReg.dwBandEstModulo)
    {
        if (g_RtpReg.dwBandEstModulo & 0xff)
        {
            g_dwRtcpBandEstModNormal = g_RtpReg.dwBandEstModulo & 0xff;
        }

        if ((g_RtpReg.dwBandEstModulo >> 8) & 0xff)
        {
            g_dwRtcpBandEstModInitial = (g_RtpReg.dwBandEstModulo >> 8) & 0xff;
        }

        if ((g_RtpReg.dwBandEstModulo >> 16) & 0xff)
        {
            g_dwRtcpBandEstInitialCount =
                (g_RtpReg.dwBandEstModulo >> 16) & 0xff;
        }

        if ((g_RtpReg.dwBandEstModulo >> 24) & 0xff)
        {
            g_dwRtcpBandEstMinReports =
                (g_RtpReg.dwBandEstModulo >> 24) & 0xff;
        }
    }

    if (IsDWValueSet(g_RtpReg.dwBandEstTTL) && g_RtpReg.dwBandEstTTL)
    {
        g_dRtcpBandEstTTL = (double) g_RtpReg.dwBandEstTTL;
    }

    if (IsDWValueSet(g_RtpReg.dwBandEstWait) && g_RtpReg.dwBandEstWait)
    {
        g_dRtcpBandEstWait = (double) g_RtpReg.dwBandEstWait;
    }

    if (IsDWValueSet(g_RtpReg.dwBandEstMaxGap) && g_RtpReg.dwBandEstMaxGap)
    {
        /* Convert milliseconds to seconds */
        g_dRtcpBandEstMaxGap = (double) g_RtpReg.dwBandEstMaxGap / 1000;
    }

    pDWORD = &g_RtpReg.dwBandEstBin0;

    for(i = 0; i <= RTCP_BANDESTIMATION_MAXBINS; i++)
    {
        if (IsDWValueSet(pDWORD[i]) && pDWORD[i])
        {
            g_dRtcpBandEstBin[i] = (double)pDWORD[i];
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\rtcp\rtcpsdes.c ===
/**********************************************************************
 *
 *  Copyright (C) 1999 Microsoft Corporation
 *
 *  File name:
 *
 *    rtcpsdes.c
 *
 *  Abstract:
 *
 *    SDES support functions
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/07/13 created
 *
 **********************************************************************/

#include "rtpmisc.h"
#include "rtpglobs.h"
#include "rtpheap.h"
#include "rtpmisc.h"
#include "rtpreg.h"
#include "lookup.h"
#include "rtpevent.h"

#include "rtcpsdes.h"

#define MAX_HOST_NAME 128
#define MAX_USER_NAME 128

/* Default BYE reason to send */
const TCHAR_t   *g_sByeReason = _T("Session terminated");

RtpSdes_t        g_RtpSdesDefault;

BOOL RtpCopySdesItem(
        WCHAR           *psSdesData,
        DWORD           *pdwSdesDataLen,
        RtpSdesItem_t   *pRtpSdesItem
    );

/**********************************************************************
 * Local SDES information
 **********************************************************************

/* Initialize to zero and compute the data pointers */
void RtcpSdesInit(RtpSdes_t *pRtpSdes)
{
    DWORD            i;
    DWORD            dwOffset;
    char            *ptr;
    
    ZeroMemory(pRtpSdes, sizeof(RtpSdes_t));

    pRtpSdes->dwObjectID = OBJECTID_RTPSDES;
    
    for(i = RTCP_SDES_FIRST + 1, ptr = pRtpSdes->SDESData;
        i < RTCP_SDES_LAST;
        i++, ptr += RTCP_MAX_SDES_SIZE)
    {
        /* Set buffer size to 255 (RTP) instead of 256 (allocated) */
        pRtpSdes->RtpSdesItem[i].dwBfrLen = RTCP_MAX_SDES_SIZE - 1;
        
        pRtpSdes->RtpSdesItem[i].pBuffer = (TCHAR_t *)ptr;
    }
}

/*
 * Sets a specific SDES item, expects a NULL terminated UNICODE string
 * no bigger than 255 bytes when converted to UTF-8 (including the
 * NULL terminating character). The string is converted to UTF-8 to be
 * stored and used in RTCP reports.
 *
 * Returns the mask of the item set or 0 if none
 * */
DWORD RtcpSdesSetItem(
        RtpSdes_t       *pRtpSdes,
        DWORD            dwItem,
        WCHAR           *pData
    )
{
    DWORD            dwDataLen;
    DWORD            dwWasSet;

    dwWasSet = 0;
    
    if (dwItem > RTCP_SDES_FIRST && dwItem < RTCP_SDES_LAST)
    {
#if 1
        /* UNICODE */
        
        /*
         * NOTE WideCharToMultiByte will convert also the null
         * terminating character which will be included in the length
         * returned
         * */
        dwDataLen = WideCharToMultiByte(
                CP_UTF8, /* UINT code page */
                0,       /* DWORD performance and mapping flags */
                pData,   /* LPCWSTR address of wide-character string */
                -1,      /* int number of characters in string */
                (char *)pRtpSdes->RtpSdesItem[dwItem].pBuffer,
                /* LPSTR address of buffer for new string */
                pRtpSdes->RtpSdesItem[dwItem].dwBfrLen,
                /* int size of buffer */
                NULL,    /* LPCSTR lpDefaultChar */
                NULL     /* LPBOOL lpUsedDefaultChar */
            );

        if (dwDataLen > 0)
        {
            pRtpSdes->RtpSdesItem[dwItem].dwDataLen = dwDataLen;
                
            RtpBitSet(dwWasSet, dwItem);
        }
#else
        /* ASCII */
        
        /* Add NULL to string length */
        dwDataLen = lstrlen(pData);

        if (dwDataLen > 0)
        {
            dwDataLen++;
        }

        dwDataLen *= sizeof(TCHAR_t);
        
        if (dwDataLen > 0 &&
            dwDataLen <= pRtpSdes->RtpSdesItem[dwItem].dwBfrLen)
        {
            /* If UNICODE is not defined, string is already UTF-8
             * (ASCII is a subset of UTF-8) */
            CopyMemory((char *)pRtpSdes->RtpSdesItem[dwItem].pBuffer,
                       (char *)pData,
                       dwDataLen);
                
            pRtpSdes->RtpSdesItem[dwItem].dwDataLen = dwDataLen;
                
            RtpBitSet(dwWasSet, dwItem);
        }
#endif
    }

    return(dwWasSet);
}

/* Obtain default values for the RTCP SDES items. This function
 * assumes the structure was initialized, i.e. zeroed and the data
 * pointers properly initialized.
 *
 * Data was first read from the registry and then defaults are set for
 * some items that don't have value yet.
 *
 * Return the mask of items that were set */
DWORD RtcpSdesSetDefault(RtpSdes_t *pRtpSdes)
{
    BOOL             bOk;
    DWORD            dwDataSize;
    DWORD            dwIndex;
    DWORD            dwSdesItemsSet;
    TCHAR_t        **ppsSdesItem;
    /* MAYDO instead, may be allocate memory from global heap */
    TCHAR_t         *pBuffer;

    dwSdesItemsSet = 0;
    
    pBuffer = RtpHeapAlloc(g_pRtpGlobalHeap,
                          RTCP_MAX_SDES_SIZE * sizeof(TCHAR_t));

    if (!pBuffer)
    { 
        return(0);
    }
    
    if ( IsRegValueSet(g_RtpReg.dwSdesEnable) &&
         ((g_RtpReg.dwSdesEnable & 0x3) == 0x3) )
    {
        ppsSdesItem = &g_RtpReg.psCNAME;
        
        for(dwIndex = RTCP_SDES_FIRST + 1, ppsSdesItem = &g_RtpReg.psCNAME;
            dwIndex < RTCP_SDES_LAST;      /* BYE */
            dwIndex++, ppsSdesItem++)
        {
            if (*ppsSdesItem)
            {
                /* Disable this parameter if first char is '-',
                 * otherwise set it */
                if (**ppsSdesItem == _T('-'))
                {
                    pRtpSdes->RtpSdesItem[dwIndex].pBuffer[0] = _T('\0');
                }
                else
                {
                    dwSdesItemsSet |= RtcpSdesSetItem(pRtpSdes,
                                                      dwIndex,
                                                      *ppsSdesItem);
                }
            }
        }
    }

    /* Now assign default values for some empty items */

    /* NAME */
    pBuffer[0] = _T('\0');

    bOk = RtpGetUserName(pBuffer, RTCP_MAX_SDES_SIZE);
    
    if (!RtpBitTest(dwSdesItemsSet, RTCP_SDES_NAME)) {
            
        if (bOk)
        {
            dwSdesItemsSet |=
                RtcpSdesSetItem(pRtpSdes, RTCP_SDES_NAME, pBuffer);
        }
        else
        {
            dwSdesItemsSet |=
                RtcpSdesSetItem(pRtpSdes, RTCP_SDES_NAME, _T("Unknown user"));
        }
    }
    
    /* CNAME: always machine generated */
    dwDataSize = lstrlen(pBuffer);

    bOk = RtpGetHostName(&pBuffer[dwDataSize + 1],
                         (RTCP_MAX_SDES_SIZE - dwDataSize -1));

    if (bOk)
    {
        pBuffer[dwDataSize] = _T('@');
    }

    dwSdesItemsSet |= RtcpSdesSetItem(pRtpSdes, RTCP_SDES_CNAME, pBuffer);

    /* TOOL */
    if (!RtpBitTest(dwSdesItemsSet, RTCP_SDES_TOOL)) {
        
        bOk = RtpGetPlatform(pBuffer);
    
        if (bOk) {
            dwSdesItemsSet |=
                RtcpSdesSetItem(pRtpSdes, RTCP_SDES_TOOL, pBuffer);
        }
    }

    /* BYE reason */
    if (!RtpBitTest(dwSdesItemsSet, RTCP_SDES_BYE)) {
        
        dwSdesItemsSet |=
            RtcpSdesSetItem(pRtpSdes, RTCP_SDES_BYE, (TCHAR_t *)g_sByeReason);
    }

    RtpHeapFree(g_pRtpGlobalHeap, pBuffer);
    
    return(dwSdesItemsSet);
}

/* Creates and initializes a RtpSdes_t structure */
RtpSdes_t *RtcpSdesAlloc(void)
{
    RtpSdes_t       *pRtpSdes;

    
    pRtpSdes = (RtpSdes_t *)
        RtpHeapAlloc(g_pRtpSdesHeap, sizeof(RtpSdes_t));

    if (pRtpSdes)
    {
        /* This function will initialize the dwObjectID */
        RtcpSdesInit(pRtpSdes);
    }
    
    return(pRtpSdes);
}

/* Frees a RtpSdes_t structure */
void RtcpSdesFree(RtpSdes_t *pRtpSdes)
{
    TraceFunctionName("RtcpSdesFree");

    /* verify object ID */
    if (pRtpSdes->dwObjectID != OBJECTID_RTPSDES)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_SDES,
                _T("%s: pRtpSdes[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpSdes,
                pRtpSdes->dwObjectID, OBJECTID_RTPSDES
            ));

        return;
    }

    /* Invalidate object */
    INVALIDATE_OBJECTID(pRtpSdes->dwObjectID);
    
    RtpHeapFree(g_pRtpSdesHeap, pRtpSdes);
}

/* Set the local SDES info for item dwSdesItem (e.g RTPSDES_CNAME,
 * RTPSDES_EMAIL), psSdesData contains the NUL terminated UNICODE
 * string to be assigned to the item */
HRESULT RtpSetSdesInfo(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwSdesItem,
        WCHAR           *psSdesData
    )
{
    HRESULT          hr;
    DWORD            dwWasSet;
    RtpSess_t       *pRtpSess;

    TraceFunctionName("RtpSetSdesInfo");

    pRtpSess = (RtpSess_t *)NULL;
    
    if (!pRtpAddr)
    {
        /* Having this as a NULL pointer means Init hasn't been
         * called, return this error instead of RTPERR_POINTER to be
         * consistent */
        hr = RTPERR_INVALIDSTATE;

        goto end;
    }

    /* verify object ID */
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_SDES,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        hr = RTPERR_INVALIDRTPADDR;

        goto end;
    }

    if (dwSdesItem <= RTCP_SDES_FIRST || dwSdesItem >= RTCP_SDES_LAST)
    {
        hr = RTPERR_INVALIDARG;

        goto end;
    }

    if (!psSdesData)
    {
        hr = RTPERR_POINTER;
        
        goto end;
    }

    hr = NOERROR;
    
    pRtpSess = pRtpAddr->pRtpSess;
    
    if (pRtpSess->pRtpSdes)
    {
        dwWasSet =
            RtcpSdesSetItem(pRtpSess->pRtpSdes, dwSdesItem, psSdesData);

        if (dwWasSet)
        {
            pRtpSess->dwSdesPresent |= dwWasSet;
        }
        else
        {
            hr = RTPERR_INVALIDARG;
        }
    }
    else
    {
        hr = RTPERR_INVALIDSTATE;
    }

 end:
    if (SUCCEEDED(hr))
    {
        TraceDebug((
                CLASS_INFO, GROUP_RTCP, S_RTCP_SDES,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] Sdes:[%s:%ls]"),
                _fname, pRtpSess, pRtpAddr,
                g_psRtpSdesEvents[dwSdesItem],
                psSdesData
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_SDES,
                _T("%s: pRtpSess[0x%p] failed: %u (0x%X)"),
                _fname, pRtpSess, hr, hr
            ));
    }
    
    return(hr);
}

/* Get a local SDES item if dwSSRC=0, otherwise gets the SDES item
 * from the participant whose SSRC was specified.
 *
 * dwSdesItem is the item to get (e.g. RTPSDES_CNAME, RTPSDES_EMAIL),
 * psSdesData is the memory place where the item's value will be
 * copied, pdwSdesDataLen contains the initial size in UNICODE chars,
 * and returns the actual UNICODE chars copied (including the NULL
 * terminating char), dwSSRC specify which participant to retrieve the
 * information from. If the SDES item is not available, dwSdesDataLen
 * is set to 0 and the call doesn't fail */
HRESULT RtpGetSdesInfo(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwSdesItem,
        WCHAR           *psSdesData,
        DWORD           *pdwSdesDataLen,
        DWORD            dwSSRC
    )
{
    HRESULT          hr;
    BOOL             bOk;
    BOOL             bCreate;
    int              DoCase;
    RtpSess_t       *pRtpSess;
    RtpUser_t       *pRtpUser;
    RtpSdesItem_t   *pRtpSdesItem;

    TraceFunctionName("RtpGetSdesInfo");

    pRtpSess = (RtpSess_t *)NULL;
    
    /* Check item validity */
    if (dwSdesItem <= RTCP_SDES_FIRST || dwSdesItem >= RTCP_SDES_LAST)
    {
        hr = RTPERR_INVALIDARG;

        goto end;
    }

    /* Check data pointers */
    if (!psSdesData || !pdwSdesDataLen)
    {
        hr = RTPERR_POINTER;

        goto end;
    }

    /* Decide case */
    if (!pRtpAddr && !dwSSRC)
    {
        /* We just want default values */
        DoCase = 2;
        
        goto doit;
    }
    else if (dwSSRC)
    {
        /* Remote */
        DoCase = 0;
    }
    else
    {
        /* Local */
        DoCase = 1;
    }

    /* More tests for cases local & remote */
    if (!pRtpAddr)
    {
        /* Having this as a NULL pointer means Init hasn't been
         * called, return this error instead of RTPERR_POINTER to be
         * consistent */
        hr = RTPERR_INVALIDSTATE;

        goto end;
    }

    /* verify object ID */
    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_SDES,
                _T("%s: pRtpAddr[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpAddr,
                pRtpAddr->dwObjectID, OBJECTID_RTPADDR
            ));

        hr = RTPERR_INVALIDRTPADDR;

        goto end;
    }

    pRtpSess = pRtpAddr->pRtpSess;

 doit:
    pRtpSdesItem = (RtpSdesItem_t *)NULL;

    switch(DoCase)
    {
    case 0:
        /* Remote */
        bCreate = FALSE;
        pRtpUser = LookupSSRC(pRtpAddr, dwSSRC, &bCreate);

        if (pRtpUser)
        {
            if (!pRtpUser->pRtpSdes)
            {
                hr = RTPERR_INVALIDSTATE;
            
                goto end;
            }

            if (RtpBitTest(pRtpUser->dwSdesPresent, dwSdesItem))
            {
                pRtpSdesItem = &pRtpUser->pRtpSdes->RtpSdesItem[dwSdesItem];
            }
        }
        else
        {
            hr = RTPERR_NOTFOUND;

            goto end;
        }

        break;
        
    case 1:
        /* Local */
        if (!pRtpSess->pRtpSdes)
        {
            hr = RTPERR_INVALIDSTATE;
            
            goto end;
        }

        if (RtpBitTest(pRtpSess->dwSdesPresent, dwSdesItem))
        {
            pRtpSdesItem = &pRtpSess->pRtpSdes->RtpSdesItem[dwSdesItem];
        }

        break;

    default:
        /* Default */
        if (g_RtpSdesDefault.RtpSdesItem[dwSdesItem].dwDataLen > 0)
        {
            pRtpSdesItem = &g_RtpSdesDefault.RtpSdesItem[dwSdesItem];
        }
    } /* switch() */

    hr = NOERROR;
    
    if (pRtpSdesItem)
    {
        bOk = RtpCopySdesItem(psSdesData, pdwSdesDataLen, pRtpSdesItem);
            
        if (!bOk)
        {
            hr = RTPERR_FAIL;
        }
    }
    else
    {
        /* Make the string empty */
        *psSdesData = _T('\0');
    }

 end:

    if (SUCCEEDED(hr))
    {
        TraceDebug((
                CLASS_INFO, GROUP_RTCP, S_RTCP_SDES,
                _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                _T("SSRC:0x%X Sdes:[%s:%s]"),
                _fname, pRtpSess, pRtpAddr,
                ntohl(dwSSRC), g_psRtpSdesEvents[dwSdesItem],
                psSdesData
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_SDES,
                _T("%s: pRtpAddr[0x%p] SSRC:0x%X failed: %u (0x%X)"),
                _fname, pRtpAddr, ntohl(dwSSRC),
                hr, hr
            ));
    }
    
    return(hr);
}

BOOL RtpCopySdesItem(
        WCHAR           *psSdesData,
        DWORD           *pdwSdesDataLen,
        RtpSdesItem_t   *pRtpSdesItem
    )
{
    BOOL             bOk;
    DWORD            dwError;
    int              iStatus;

    TraceFunctionName("RtpCopySdesItem");  

    /* Covert from UTF-8 to UNICODE */
    iStatus = MultiByteToWideChar(CP_UTF8,
                                  0,
                                  (char *)pRtpSdesItem->pBuffer,
                                  pRtpSdesItem->dwDataLen,
                                  psSdesData,
                                  *pdwSdesDataLen);

    if (iStatus > 0)
    {
        bOk = TRUE;

        /* Update the number of UNICODE chars converted */
        *pdwSdesDataLen = iStatus;
    }
    else
    {
        TraceRetailGetError(dwError);
        
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_SDES,
                _T("%s: MultiByteToWideChar src[0x%p]:%u dst[0x%p]:%u ")
                _T("failed: %u (0x%X)"),
                _fname, pRtpSdesItem->pBuffer, pRtpSdesItem->dwDataLen,
                psSdesData, *pdwSdesDataLen,
                dwError, dwError
            ));
        
        bOk = FALSE;
    }
    
    return(bOk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\rtcp\rtcpthrd.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtcpthrd.c
 *
 *  Abstract:
 *
 *    RTCP thread
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/07/07 created
 *
 **********************************************************************/

#include "rtpheap.h"
#include "rtpglobs.h"
#include "rtpcrit.h"
#include "rtpchan.h"
#include "rtcprecv.h"
#include "rtcpsend.h"
#include "rtpqos.h"
#include "rtppinfo.h"
#include "rtcpint.h"
#include "rtpncnt.h"
#include "rtpevent.h"

#include <mmsystem.h> /* timeGetTime() */

#include "rtcpthrd.h"

HRESULT ConsumeRtcpCmdChannel(
        RtcpContext_t   *pRtcpContext,
        DWORD           *pdwCommand
    );

#if USE_RTCP_THREAD_POOL > 0
HRESULT ConsumeRtcpIoChannel(RtcpContext_t *pRtcpContext);
#endif /* USE_RTCP_THREAD_POOL > 0 */

HRESULT RtcpThreadAddrAdd(RtcpContext_t *pRtcpContext, RtpAddr_t *pRtpAddr);

HRESULT RtcpThreadAddrDel(RtcpContext_t *pRtcpContext, RtpAddr_t *pRtpAddr);

HRESULT RtcpThreadReserve(
        RtcpContext_t   *pRtcpContext,
        RtpAddr_t       *pRtpAddr,
        DWORD            dwCommand,
        DWORD            dwRecvSend
    );

HRESULT RtcpThreadAddrSendBye(
        RtcpContext_t   *pRtcpContext,
        RtpAddr_t       *pRtpAddr,
        BOOL             bShutDown
    );

HRESULT RtcpThreadAddrCleanup(RtcpContext_t *pRtcpContext);

double RtcpOnTimeout(RtcpContext_t *pRtcpContext);

double RtpAddrTimeout(RtcpContext_t *pRtcpContext);

double RtpUserTimeout(RtpAddr_t *pRtpAddr);

double RtcpSendReports(RtcpContext_t *pRtcpContext);

RtcpAddrDesc_t *RtcpAddrDescAlloc(
        RtpAddr_t       *pRtpAddr
    );

void RtcpAddrDescFree(RtcpAddrDesc_t *pRtcpAddrDesc);

RtcpAddrDesc_t *RtcpAddrDescGetFree(
        RtcpContext_t  *pRtcpContext,
        RtpAddr_t       *pRtpAddr
    );

RtcpAddrDesc_t *RtcpAddrDescPutFree(
        RtcpContext_t   *pRtcpContext,
        RtcpAddrDesc_t  *pRtcpAddrDesc
    );

HRESULT RtcpAddToVector(
        RtcpContext_t   *pRtcpContext,
        RtcpAddrDesc_t  *pRtcpAddrDesc
    );

HRESULT RtcpRemoveFromVector(
        RtcpContext_t   *pRtcpContext,
        RtcpAddrDesc_t  *pRtcpAddrDesc
    );

RtcpContext_t g_RtcpContext;

long g_lCountRtcpRecvThread = 0; /* Current number */
long g_lNumRtcpRecvThread = 0;   /* Cumulative number */

TCHAR *g_psRtcpThreadCommands[] =
{
    _T("invalid"),
    
    _T("ADDADDR"),
    _T("DELADDR"),
    _T("RESERVE"),
    _T("UNRESERVE"),
    _T("SENDBYE"),
    _T("EXIT"),

    _T("invalid"),
};

#define RtcpThreadCommandName(c) (g_psRtcpThreadCommands[c-RTCPTHRD_FIRST])

#if USE_RTCP_THREAD_POOL > 0
void CALLBACK RtcpRecvCallback(
        void        *pParameter,
        BOOLEAN      bTimerOrWaitFired
    )
{
    TraceFunctionName("RtcpRecvCallback");
    
    if (bTimerOrWaitFired)
    {
        return;
    }

    TraceDebugAdvanced((
            0, GROUP_RTCP, S_RTCP_CALLBACK,
            _T("%s: pRtcpAddrDesc[0x%p] enters"),
            _fname, pParameter
        ));
    
    RtpChannelSend(&g_RtcpContext.RtcpThreadIoChannel,
                   RTCPPOOL_RTCPRECV,
                   (DWORD_PTR)pParameter,
                   (DWORD_PTR)NULL,
                   0);

    TraceDebugAdvanced((
            0, GROUP_RTCP, S_RTCP_CALLBACK,
            _T("%s: pRtcpAddrDesc[0x%p] leaves"),
            _fname, pParameter
        ));
}

void CALLBACK RtcpQosCallback(
        void        *pParameter,
        BOOLEAN      bTimerOrWaitFired
    )
{
    TraceFunctionName("RtcpQosCallback");
    
    if (bTimerOrWaitFired)
    {
        return;
    }

    TraceDebugAdvanced((
            0, GROUP_RTCP, S_RTCP_CALLBACK,
            _T("%s: pRtcpAddrDesc[0x%p] enters"),
            _fname, pParameter
        ));
    
    RtpChannelSend(&g_RtcpContext.RtcpThreadIoChannel,
                   RTCPPOOL_QOSNOTIFY,
                   (DWORD_PTR)pParameter,
                   (DWORD_PTR)NULL,
                   0);

    TraceDebugAdvanced((
            0, GROUP_RTCP, S_RTCP_CALLBACK,
            _T("%s: pRtcpAddrDesc[0x%p] leaves"),
            _fname, pParameter
        ));
}
#endif /* USE_RTCP_THREAD_POOL > 0 */

/*
 * Do minimal initialization for RTCP
 * */
HRESULT RtcpInit(void)
{
    BOOL             bStatus;
    HRESULT          hr;

    TraceFunctionName("RtcpInit");

    /* Initialize RtcpContext */
    ZeroMemory(&g_RtcpContext, sizeof(g_RtcpContext));

    g_RtcpContext.dwObjectID = OBJECTID_RTCPCONTEXT;
    
    bStatus =
        RtpInitializeCriticalSection(&g_RtcpContext.RtcpContextCritSect,
                                     (void *)&g_RtcpContext,
                                     _T("RtcpContextCritSect"));

    hr = NOERROR;
    
    if (!bStatus) {

        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_INIT,
                _T("%s: pRtcpContext[0x%p] critical section ")
                _T("failed to initialize"),
                _fname, &g_RtcpContext
            ));

        hr = RTPERR_CRITSECT;
    }

    return(hr);
}

/*
 * Do last de-initialization for RTCP
 * */
HRESULT RtcpDelete(void)
{
    HRESULT          hr;

    TraceFunctionName("RtcpDelete");

    hr = NOERROR;

    /* RtcpContext de-initialization */
    RtpDeleteCriticalSection(&g_RtcpContext.RtcpContextCritSect);

    if (g_RtcpContext.lRtcpUsers > 0)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_INIT,
                _T("%s: pRtcpContext[0x%p] ")
                _T("pRtcpContext->lRtcpUsers > 0: %d"),
                _fname, &g_RtcpContext,
                g_RtcpContext.lRtcpUsers
            ));

        hr = RTPERR_INVALIDSTATE;
    }

    if (g_RtcpContext.hRtcpContextThread)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_INIT,
                _T("%s: pRtcpContext[0x%p] ")
                _T("Thread 0x%X still active"),
                _fname, &g_RtcpContext,
                g_RtcpContext.dwRtcpContextThreadID
            ));
        
        hr = RTPERR_INVALIDSTATE;
    }

    if (SUCCEEDED(hr))
    {
        INVALIDATE_OBJECTID(g_RtcpContext.dwObjectID);
    }
        
    return(hr);
}

/* RTCP worker thread */
DWORD WINAPI RtcpWorkerThreadProc(LPVOID lpParameter)
{
    DWORD            dwError;
    HRESULT          hr;
    DWORD            dwStatus;
    DWORD            dwCommand;
    DWORD            dwIndex;
    DWORD            dwDescIndex;
    DWORD            dwNumHandles;
    DWORD            dwWaitTime;
    RtcpContext_t   *pRtcpContext;
    RtpChannelCmd_t *pRtpChannelCmd;

    HANDLE           hThread;
    DWORD            dwThreadID;
    HANDLE          *pHandle;

    
#if USE_RTCP_THREAD_POOL <= 0
    RtcpAddrDesc_t  *pRtcpAddrDesc;
    RtcpAddrDesc_t **ppRtcpAddrDesc;
#endif /* USE_RTCP_THREAD_POOL <= 0 */

    TraceFunctionName("RtcpWorkerThreadProc");

    InterlockedIncrement(&g_lCountRtcpRecvThread);
    InterlockedIncrement(&g_lNumRtcpRecvThread);
    
    pRtcpContext = (RtcpContext_t *)lpParameter;

    hThread = 0;
    dwThreadID = -1;
    
    if (!pRtcpContext)
    {
        dwError = RTPERR_POINTER;
        goto exit;
    }

    if (pRtcpContext->dwObjectID != OBJECTID_RTCPCONTEXT)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_THREAD,
                _T("%s: pRtcpContext[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtcpContext,
                pRtcpContext->dwObjectID, OBJECTID_RTCPCONTEXT
            ));

        dwError = RTPERR_INVALIDRTCPCONTEXT;
        
        goto exit;
    }

    dwError = NOERROR;
    hThread = pRtcpContext->hRtcpContextThread;
    dwThreadID = pRtcpContext->dwRtcpContextThreadID;
    
    pHandle = pRtcpContext->pHandle;
    
#if USE_RTCP_THREAD_POOL <= 0
    ppRtcpAddrDesc = pRtcpContext->ppRtcpAddrDesc;
#endif /* USE_RTCP_THREAD_POOL <= 0 */
    
    pHandle[0] = pRtcpContext->RtcpThreadCmdChannel.hWaitEvent;

#if USE_RTCP_THREAD_POOL > 0
    pHandle[1] = pRtcpContext->RtcpThreadIoChannel.hWaitEvent;
#endif /* USE_RTCP_THREAD_POOL > 0 */

    dwWaitTime = 5000;
    dwCommand = 0;

    TraceRetail((
            CLASS_INFO, GROUP_RTCP, S_RTCP_THREAD,
            _T("%s: pRtcpContext[0x%p] thread:%u (0x%X) ID:%u (0x%X) ")
            _T("has started"),
            _fname, pRtcpContext,
            hThread, hThread,
            dwThreadID, dwThreadID
        ));
    
    do
    {
        dwNumHandles =
            (pRtcpContext->dwMaxDesc * RTCP_HANDLE_SIZE) + RTCP_HANDLE_OFFSET;
        
        dwStatus = WaitForMultipleObjectsEx(
                dwNumHandles, /* DWORD nCount */
                pHandle,      /* CONST HANDLE *lpHandles */
                FALSE,        /* BOOL fWaitAll */
                dwWaitTime,   /* DWORD dwMilliseconds */
                TRUE          /* BOOL bAlertable */
            );

        if (dwStatus == WAIT_OBJECT_0)
        {
            ConsumeRtcpCmdChannel(pRtcpContext, &dwCommand);
        }
#if USE_RTCP_THREAD_POOL > 0
        else if (dwStatus == (WAIT_OBJECT_0 + 1))
        {
            ConsumeRtcpIoChannel(pRtcpContext);
        }
#else /* USE_RTCP_THREAD_POOL > 0 */
        else if ( (dwStatus >= (WAIT_OBJECT_0 + RTCP_HANDLE_OFFSET)) &&
                  (dwStatus < (WAIT_OBJECT_0 + RTCP_HANDLE_OFFSET +
                               (RTCP_HANDLE_SIZE * RTCP_MAX_DESC))) )
        {
            /* Asynchronous reception events start at index
             * RTCP_HANDLE_OFFSET, but descriptors start at index 0
             * */
            dwIndex = dwStatus - WAIT_OBJECT_0 - RTCP_HANDLE_OFFSET;
            
            dwDescIndex = dwIndex / RTCP_HANDLE_SIZE;

            pRtcpAddrDesc = ppRtcpAddrDesc[dwDescIndex];

            switch(dwIndex % RTCP_HANDLE_SIZE) {
                /* Asynchronous activity is restarted inside each
                 * function */
            case 0: /* I/O completion signaled */
                ConsumeRtcpRecvFrom(pRtcpContext, pRtcpAddrDesc);
                break;
            case 1: /* QOS notification */
                ConsumeRtcpQosNotify(pRtcpContext, pRtcpAddrDesc);
                break;
            default:
                ; /* TODO log error */
            }

            /* If we just had asynchronous I/O, that means the
             * RtcpAddrDesc hasn't been removed from vector, do it now
             * if there are no more pending I/Os (structure is moved
             * to AddrDescFreeQ by RtcpRemoveFromVector()) */
            if (RtpBitTest(pRtcpAddrDesc->dwAddrDescFlags,
                           FGADDRD_SHUTDOWN2))
            {
                if ( (pRtcpAddrDesc->lRtcpPending <= 0) &&
                     (pRtcpAddrDesc->lQosPending <= 0) )
                {
                    RtcpRemoveFromVector(pRtcpContext, pRtcpAddrDesc);
                }
            }
        }
#endif /* USE_RTCP_THREAD_POOL > 0 */

        if (dwCommand != RTCPTHRD_EXIT)
        {
            dwWaitTime = (DWORD) (RtcpOnTimeout(pRtcpContext) * 1000.0);
        }
        
    } while(dwCommand != RTCPTHRD_EXIT);

 exit:
    TraceRetail((
            CLASS_INFO, GROUP_RTCP, S_RTCP_THREAD,
            _T("%s: pRtcpContext[0x%p] thread:%u (0x%X) ID:%u (0x%X) ")
            _T("exit with code: %u (0x%X)"),
            _fname, pRtcpContext,
            hThread, hThread,
            dwThreadID, dwThreadID,
            dwError, dwError
        ));
  
    InterlockedDecrement(&g_lCountRtcpRecvThread);
    
    return(dwError);
}

HRESULT ConsumeRtcpCmdChannel(
        RtcpContext_t   *pRtcpContext,
        DWORD           *pdwCommand
    )
{
    HRESULT          hr;
    RtpChannelCmd_t *pRtpChannelCmd;
    DWORD            dwCommand;

    hr = NOERROR;
    dwCommand = 0;
    
    while( (pRtpChannelCmd =
            RtpChannelGetCmd(&pRtcpContext->RtcpThreadCmdChannel)) )
    {
        dwCommand = pRtpChannelCmd->dwCommand;

        switch(dwCommand) {
        case RTCPTHRD_ADDADDR:
            hr = RtcpThreadAddrAdd(
                    pRtcpContext,
                    (RtpAddr_t *)pRtpChannelCmd->dwPar1);
            break;
        case RTCPTHRD_DELADDR:
            hr = RtcpThreadAddrDel(
                    pRtcpContext,
                    (RtpAddr_t *)pRtpChannelCmd->dwPar1);
            break;
        case RTCPTHRD_RESERVE:
        case RTCPTHRD_UNRESERVE:
            hr = RtcpThreadReserve(
                    pRtcpContext,
                    (RtpAddr_t *)pRtpChannelCmd->dwPar1,
                    dwCommand,
                    (DWORD)pRtpChannelCmd->dwPar2);
            break;
        case RTCPTHRD_SENDBYE:
            hr = RtcpThreadAddrSendBye(
                    pRtcpContext,
                    (RtpAddr_t *)pRtpChannelCmd->dwPar1,
                    (BOOL)pRtpChannelCmd->dwPar2);
            break;
        case RTCPTHRD_EXIT:
            /* Release resources (overlapped I/O if there is
             * any. That can happen if the overlapped I/O
             * takes longer to complete and the EXIT command
             * sent after last DELADDR completed also before
             * the I/O completes) */
            hr = RtcpThreadAddrCleanup(pRtcpContext);
            break;
        default:
            hr = NOERROR; /* TODO Should be an error */
        }
            
        RtpChannelAck(&pRtcpContext->RtcpThreadCmdChannel,
                      pRtpChannelCmd,
                      hr);
    }

    *pdwCommand = dwCommand;
    
    return(hr);
}

#if USE_RTCP_THREAD_POOL > 0
HRESULT ConsumeRtcpIoChannel(RtcpContext_t *pRtcpContext)
{
    HRESULT          hr;
    RtpChannelCmd_t *pRtpChannelCmd;
    RtcpAddrDesc_t  *pRtcpAddrDesc;
    DWORD            dwCommand;

    TraceFunctionName("ConsumeRtcpIoChannel");

    hr = NOERROR;
    
    while( (pRtpChannelCmd =
            RtpChannelGetCmd(&pRtcpContext->RtcpThreadIoChannel)) )
    {
        dwCommand = pRtpChannelCmd->dwCommand;

        pRtcpAddrDesc = (RtcpAddrDesc_t *)pRtpChannelCmd->dwPar1;

        if (pRtcpAddrDesc->dwObjectID != OBJECTID_RTCPADDRDESC)
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_RTCP, S_RTCP_THREAD,
                    _T("%s: pRtcpAddrDesc[0x%p] Invalid object ID ")
                    _T("0x%X != 0x%X"),
                    _fname, pRtcpAddrDesc,
                    pRtcpAddrDesc->dwObjectID, OBJECTID_RTCPADDRDESC
                ));
        }
        else
        {
            switch(dwCommand)
            {
            case RTCPPOOL_RTCPRECV:
                hr = ConsumeRtcpRecvFrom(pRtcpContext, pRtcpAddrDesc);
                break;
            case RTCPPOOL_QOSNOTIFY:
                hr = ConsumeRtcpQosNotify(pRtcpContext, pRtcpAddrDesc);
                break;
            default:
                hr = NOERROR; /* TODO This is an error */
            }
        }
        
        RtpChannelAck(&pRtcpContext->RtcpThreadIoChannel,
                      pRtpChannelCmd,
                      hr);
        
        if (pRtcpAddrDesc->dwObjectID == OBJECTID_RTCPADDRDESC)
        {
            /* If we just had asynchronous I/O, that means the
             * RtcpAddrDesc hasn't been removed from vector, do it now
             * if there are no more pending I/Os (structure is moved
             * to AddrDescFreeQ by RtcpRemoveFromVector()) */
            if (RtpBitTest(pRtcpAddrDesc->dwAddrDescFlags,
                           FGADDRD_SHUTDOWN2))
            {
                if ( (pRtcpAddrDesc->lRtcpPending <= 0) &&
                     (pRtcpAddrDesc->lQosPending <= 0) )
                {
                    RtcpRemoveFromVector(pRtcpContext, pRtcpAddrDesc);
                }
            }
        }
    }

    return(hr);
}
#endif /* USE_RTCP_THREAD_POOL > 0 */

/* Create (if not yet created) the RTCP worker thread */
HRESULT RtcpCreateThread(RtcpContext_t *pRtcpContext)
{
    HRESULT         hr;
    DWORD           dwError;
    BOOL            bOk;

    TraceFunctionName("RtcpCreateThread");

    bOk = RtpEnterCriticalSection(&pRtcpContext->RtcpContextCritSect);

    if (!bOk)
    {
        hr = RTPERR_CRITSECT;
        goto bail;
    }

    hr = NOERROR;
    
    /* If RTCP thread is not started yet, create it and start it */
    if (!pRtcpContext->hRtcpContextThread)
    {
        /* First time, initializa channel */
        hr = RtpChannelInit(&pRtcpContext->RtcpThreadCmdChannel,
                            pRtcpContext);

        if (FAILED(hr))
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_RTCP, S_RTCP_THREAD,
                    _T("%s: pRtcpContext[0x%p] ")
                    _T("Failed to initialize cmd channel: %u (0x%X)"),
                    _fname, pRtcpContext,
                    hr, hr
                ));
            
            goto bail;
        }
        
#if USE_RTCP_THREAD_POOL > 0
        hr = RtpChannelInit(&pRtcpContext->RtcpThreadIoChannel,
                            pRtcpContext);

        if (FAILED(hr))
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_RTCP, S_RTCP_THREAD,
                    _T("%s: pRtcpContext[0x%p] ")
                    _T("Failed to initialize IO channel: %u (0x%X)"),
                    _fname, pRtcpContext,
                    hr, hr
                ));
            
            goto bail;
        }
#endif /* USE_RTCP_THREAD_POOL > 0 */
        
        /* Create thread */
        pRtcpContext->hRtcpContextThread = CreateThread(
                NULL,                 /* LPSECURITY_ATTRIBUTES lpThrdAttrib */
                0,                    /* DWORD dwStackSize */
                RtcpWorkerThreadProc, /* LPTHREAD_START_ROUTINE lpStartProc */
                pRtcpContext,         /* LPVOID  lpParameter */
                0,                    /* DWORD dwCreationFlags */
                &pRtcpContext->dwRtcpContextThreadID /* LPDWORD lpThreadId */
        );

        if (!pRtcpContext->hRtcpContextThread)
        {
            TraceRetailGetError(dwError);
            
            TraceRetail((
                    CLASS_ERROR, GROUP_RTCP, S_RTCP_THREAD,
                    _T("%s: pRtcpContext[0x%p] ")
                    _T("Thread creation failed: %u (0x%X)"),
                    _fname, pRtcpContext,
                    dwError, dwError
                ));
            
            hr = RTPERR_THREAD;
            
            goto bail;
        }
        
        pRtcpContext->lRtcpUsers = 0;
        pRtcpContext->dwMaxDesc = 0;
    }
    
    pRtcpContext->lRtcpUsers++;
    
    RtpLeaveCriticalSection(&pRtcpContext->RtcpContextCritSect);
    
    return(hr);

bail:
    if (bOk)
    {
        if (IsRtpChannelInitialized(&pRtcpContext->RtcpThreadCmdChannel))
        {
            RtpChannelDelete(&pRtcpContext->RtcpThreadCmdChannel);
        }

    #if USE_RTCP_THREAD_POOL > 0
        if (IsRtpChannelInitialized(&pRtcpContext->RtcpThreadIoChannel))
        {
            RtpChannelDelete(&pRtcpContext->RtcpThreadIoChannel);
        }
    #endif /* USE_RTCP_THREAD_POOL > 0 */
    
        RtpLeaveCriticalSection(&pRtcpContext->RtcpContextCritSect);
    }

    return(hr);
}

/* Delete thread when there are no more RTCP users */
HRESULT RtcpDeleteThread(RtcpContext_t *pRtcpContext)
{
    HRESULT          hr;
    BOOL             bOk;
    
    TraceFunctionName("RtcpDeleteThread");
    
    bOk = RtpEnterCriticalSection(&pRtcpContext->RtcpContextCritSect);

    if (!bOk)
    {
        hr = RTPERR_CRITSECT;
        goto bail;
    }

    hr = NOERROR;

    /* If RTCP thread is not started yet, do nothing */
    if (pRtcpContext->hRtcpContextThread)
    {
        /* Everything fine, see if thread needs to be stoped */
        pRtcpContext->lRtcpUsers--;
            
        if (pRtcpContext->lRtcpUsers <= 0)
        {
            /* Really terminate thread */
            
            /* Direct thread to stop, synchronize ack */
            hr = RtpChannelSend(&pRtcpContext->RtcpThreadCmdChannel,
                                RTCPTHRD_EXIT,
                                0,
                                0,
                                60*60*1000); /* TODO update */
            
            if (SUCCEEDED(hr))
            {
                /* TODO I may modify to loop until object is
                 * signaled or get a timeout */
                WaitForSingleObject(pRtcpContext->hRtcpContextThread,
                                    INFINITE);
            }
            else
            {
                /* Force ungraceful thread termination */
                
                TraceRetail((
                        CLASS_ERROR, GROUP_RTCP, S_RTCP_THREAD,
                        _T("%s: Force ungraceful ")
                        _T("thread termination: %u (0x%X)"),
                        _fname, hr, hr
                    ));
                
                TerminateThread(pRtcpContext->hRtcpContextThread, -1);
            }

            CloseHandle(pRtcpContext->hRtcpContextThread);
            
            pRtcpContext->hRtcpContextThread = NULL;
            
            /* ...thread stoped, now delete channel */
            RtpChannelDelete(&pRtcpContext->RtcpThreadCmdChannel);
            
#if USE_RTCP_THREAD_POOL > 0
            RtpChannelDelete(&pRtcpContext->RtcpThreadIoChannel);
#endif /* USE_RTCP_THREAD_POOL > 0 */
        }
    }

    RtpLeaveCriticalSection(&pRtcpContext->RtcpContextCritSect);

 bail:
    
    return(hr);
}

/*
 * Start the RTCP thread
 * */
HRESULT RtcpStart(RtcpContext_t *pRtcpContext)
{
    HRESULT          hr;

    TraceFunctionName("RtcpStart");

    hr = RtcpCreateThread(pRtcpContext);

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_THREAD,
                _T("%s: pRtcpContext[0x%p] ")
                _T("thread creation failed: %u (0x%X)"),
                _fname, pRtcpContext,
                hr, hr
            ));
    }
    else
    {
        TraceDebug((
                CLASS_INFO, GROUP_RTCP, S_RTCP_THREAD,
                _T("%s: pRtcpContext[0x%p] ")
                _T("thread creation succeeded"),
                _fname, pRtcpContext
            ));
    }

    return(hr);
}

/*
 * Stop the RTCP thread
 * */
HRESULT RtcpStop(RtcpContext_t *pRtcpContext)
{
    HRESULT          hr;

    TraceFunctionName("RtcpStop");

    hr = RtcpDeleteThread(pRtcpContext);

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_THREAD,
                _T("%s: pRtcpContext[0x%p] ")
                _T("thread termination failed: %u (0x%X)"),
                _fname, pRtcpContext,
                hr, hr
            ));
    }
    else
    {
        TraceDebug((
                CLASS_INFO, GROUP_RTCP, S_RTCP_THREAD,
                _T("%s: pRtcpContext[0x%p] ")
                _T("thread deletion succeeded"),
                _fname, pRtcpContext
            ));
    }

    return (hr);
}

/**********************************************************************
 * Function called to send commands to the RTCP thread
 **********************************************************************/

/*
 * RTCPTHRD_ADDADDR: Add an address so the RTCP worker thread can
 * start receiving/sending RTCP reports on its behalf.
 *
 * RTCPTHRD_DELADDR: Remove an address so the RTCP stops
 * receiving/sending RTCP reports on its behalf.
 *
 * RTCPTHRD_RESERVE: Directs the RTCP thread to do a QOS reservation
 * (do a reservation if a receiver or start sending PATH messages if a
 * sender).
 *
 * RTCPTHRD_UNRESERVE: Directs the RTCP thread to undo a QOS
 * reservation (remove the reservation if a receiver or stop sending
 * PATH messages if a sender).
 *
 * RTCPTHRD_SENDBYE: Shutdown an address so the RTCP thread sends a
 * RTCP BYE
 * */

HRESULT RtcpThreadCmd(
        RtcpContext_t   *pRtcpContext,
        RtpAddr_t       *pRtpAddr,
        RTCPTHRD_e       eCommand,
        DWORD            dwParam,
        DWORD            dwWaitTime
    )
{
    HRESULT          hr;
    
    TraceFunctionName("RtcpThreadCmd");

    TraceDebug((
            CLASS_INFO, GROUP_RTCP, S_RTCP_CHANNEL,
            _T("%s: pRtcpContext[0x%p] pRtpAddr[0x%p] ")
            _T("Cmd:%s Par:0x%X Wait:%u"),
            _fname, pRtcpContext, pRtpAddr,
            RtcpThreadCommandName(eCommand), dwParam, dwWaitTime
        ));

    /* Send command to RTCP worker thread, synchronize */
    hr = RtpChannelSend(&pRtcpContext->RtcpThreadCmdChannel,
                        eCommand,
                        (DWORD_PTR)pRtpAddr,
                        (DWORD_PTR)dwParam,
                        dwWaitTime);
        
    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_CHANNEL,
                _T("%s: pRtcpContext[0x%p] pRtpAddr[0x%p] ")
                _T("Cmd:%s Par:0x%X Wait:%u failed: %u (0x%X)"),
                _fname, pRtcpContext, pRtpAddr,
                RtcpThreadCommandName(eCommand), dwParam, dwWaitTime,
                hr, hr
            ));
    }
    
    return(hr);

}

/**********************************************************************
 * Functions called inside the RTCP thread
 **********************************************************************/

/* Called from the RTCP worker thread whenever a RTCPTHRD_ADDADDR
 * command is received */
HRESULT RtcpThreadAddrAdd(RtcpContext_t *pRtcpContext, RtpAddr_t *pRtpAddr)
{
    HRESULT          hr;
    DWORD            s;
    RtcpAddrDesc_t  *pRtcpAddrDesc;
    double           dTime;
    double           dTimeToNextReport;

    TraceFunctionName("RtcpThreadAddrAdd");

    hr = RTPERR_RESOURCES;
    
    /* Check if we can handle another address */
    if (pRtcpContext->dwMaxDesc >= RTCP_MAX_DESC)
    {
        TraceRetail((
                CLASS_WARNING, GROUP_RTCP, S_RTCP_CMD,
                _T("%s: pRtcpContext[0x%p] pRtpAddr[0x%p] ")
                _T("failed: max entries in vector reached:%u"),
                _fname, pRtcpContext, pRtpAddr,
                pRtcpContext->dwMaxDesc
            ));
        
        return(hr);
    }
    
    /* Allocate a new RtcpAddrDesc_t structure */
    pRtcpAddrDesc = RtcpAddrDescGetFree(pRtcpContext, pRtpAddr);

    if (pRtcpAddrDesc)
    {
        pRtcpAddrDesc->pRtpAddr = pRtpAddr;

        for(s = SOCK_RECV_IDX; s <= SOCK_RTCP_IDX; s++)
        {
            /* Keep a copy of sockets to avoid access to pRtpAddr */
            pRtcpAddrDesc->Socket[s] = pRtpAddr->Socket[s]; 
        }

        pRtcpAddrDesc->AddrDescQItem.pvOther = (void *)pRtpAddr;
        
        /* Add pRtcpAddrDesc to the address queue */
        enqueuef(&pRtcpContext->AddrDescBusyQ,
                 NULL,
                 &pRtcpAddrDesc->AddrDescQItem);
        
        dTime = RtpGetTimeOfDay((RtpTime_t *)NULL);

        /* Schedule first RTCP report to be sent */
        dTimeToNextReport = dTime + RtcpNextReportInterval(pRtpAddr);

        /* Add pRtcpAddrDesc to the reports queue */
        /* Insert in ascending order using the dTimeToNextReport
         * as a Key (used to schedule sending RTCP reports) */
        enqueuedK(&pRtcpContext->SendReportQ,
                  NULL,
                  &pRtcpAddrDesc->SendQItem,
                  dTimeToNextReport);

        /* NOTE Add systematically pRtcpAddrDesc to the QOS
         * notifications queue (regardless if the session is or not
         * QOS enabled).  This will add a small overhead, but is
         * comparable to testing for the need or not to add/remove
         * from QOS queues, with the advantage that the code is
         * simpler */
        enqueuedK(&pRtcpContext->QosStartQ,
                  NULL,
                  &pRtcpAddrDesc->QosQItem,
                  dTime + 0.100); /* +100ms from now */

        /*
         * Update the events vector for asynchronous reception
         * */
        RtcpAddToVector(pRtcpContext, pRtcpAddrDesc);
        
        /* Start asynchronous RTCP reception */
        StartRtcpRecvFrom(pRtcpContext, pRtcpAddrDesc);

        /* Start asynchronous QOS notifications */
        if ( RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_QOSRECVON) ||
             RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_QOSSENDON) )
        {
            /* ... only if QOS is enabled */
            StartRtcpQosNotify(pRtcpContext, pRtcpAddrDesc);
        }

        hr = NOERROR;
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_CMD,
                _T("%s: pRtcpContext[0x%p] pRtpAddr[0x%p] ")
                _T("failed to create pRtcpAddrDesc"),
                _fname, pRtcpContext, pRtpAddr
            ));
    }

    return(hr);
}

/* Called from the RTCP worker thread whenever a RTCPTHRD_DELADDR
 * command is received */
HRESULT RtcpThreadAddrDel(RtcpContext_t *pRtcpContext, RtpAddr_t *pRtpAddr)
{
    HRESULT          hr;
    RtcpAddrDesc_t  *pRtcpAddrDesc;
    RtpQueueItem_t  *pRtpQueueItem;

    TraceFunctionName("RtcpThreadAddrDel");

    hr = RTPERR_NOTFOUND;
    
    pRtpQueueItem = findQO(&pRtcpContext->AddrDescBusyQ,
                           NULL,
                           (void *)pRtpAddr);

    if (pRtpQueueItem)
    {
        pRtcpAddrDesc =
            CONTAINING_RECORD(pRtpQueueItem, RtcpAddrDesc_t, AddrDescQItem);

        /* Remove from the reports queue */
        dequeue(&pRtcpContext->SendReportQ, NULL, &pRtcpAddrDesc->SendQItem);

        /* Reset key */
        pRtcpAddrDesc->SendQItem.dwKey = 0;

        /* This RtcpAddrDesc is shutting down */
        RtpBitSet(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_SHUTDOWN2);

        if (RtpBitTest(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_NOTIFYBUSY))
        {
            /* A QOS notification can be still in BusyQ, and yet not
             * be pending, if it completed after FGADDRD_SHUTDOWN1 was
             * set, but before having set FGADDRD_SHUTDOWN2. */

            if (pRtcpAddrDesc->lQosPending > 0)
            {
                /* Move from QosBusyQ to QosStopQ */
                move2ql(&pRtcpContext->QosStopQ, /* ToQ */
                        &pRtcpContext->QosBusyQ, /* FromQ */
                        NULL,
                        &pRtcpAddrDesc->QosQItem);

                /* When notification completes, the RtcpAddrDesc will
                 * be removed from QosStopQ */
            }
            else
            {
                /* Just remove from QosBusyQ */
                dequeue(&pRtcpContext->QosBusyQ,
                        NULL,
                        &pRtcpAddrDesc->QosQItem);
            }
            
            RtpBitReset(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_NOTIFYBUSY);
        }
        else
        {
            /* NOTE the pRtcpAddrDesc was added to the QosStartQ
             * during RtcpThreadAddrAdd regardless if QOS was enabled
             * or not, if it wasn't, it would have remained in
             * QosStartQ.  */
            
            /* If QOS notification is not in BusyQ, item must be in
             * QosStartQ, and there must not be a QOS notification
             * pending, just remove from QosStartQ */

            dequeue(&pRtcpContext->QosStartQ,
                    NULL,
                    &pRtcpAddrDesc->QosQItem);
        }

        if (pRtcpAddrDesc->lRtcpPending > 0)
        {
            /* Reception pending, move pRtcpAddrDesc from
             * AddrDescBusyQ to AddrDescStopQ */

            move2ql(&pRtcpContext->AddrDescStopQ,
                    &pRtcpContext->AddrDescBusyQ,
                    NULL,
                    &pRtcpAddrDesc->AddrDescQItem);
            
            /* When reception completes, the RtcpAddrDesc will be
             * removed from AddrDescStopQ */

            TraceDebug((
                    CLASS_INFO, GROUP_RTCP, S_RTCP_CMD,
                    _T("%s: pRtcpContext[0x%p] ")
                    _T("pRtcpAddrDesc[0x%p] pRtpAddr[0x%p] ")
                    _T("Shutting down, I/O:%d ")
                    _T("AddrDescBusyQ->AddrDescStopQ"),
                    _fname, pRtcpContext, pRtcpAddrDesc, pRtpAddr,
                    pRtcpAddrDesc->lRtcpPending
                ));
        }
        else
        {
            /* RtcpAddrDesc is in AddrDescBusyQ regardless there is
             * a pending I/O or not */
            dequeue(&pRtcpContext->AddrDescBusyQ,
                    NULL,
                    &pRtcpAddrDesc->AddrDescQItem);

            pRtcpAddrDesc->AddrDescQItem.pvOther = NULL;

            TraceDebug((
                    CLASS_INFO, GROUP_RTCP, S_RTCP_CMD,
                    _T("%s: pRtcpContext[0x%p] ")
                    _T("pRtcpAddrDesc[0x%p] pRtpAddr[0x%p] ")
                    _T("Shutting down, I/O:%d ")
                    _T("AddrDescBusyQ->"),
                    _fname, pRtcpContext, pRtcpAddrDesc, pRtpAddr,
                    pRtcpAddrDesc->lRtcpPending
                ));
        }
        
        if ( (pRtcpAddrDesc->lRtcpPending <= 0) &&
             (pRtcpAddrDesc->lQosPending <= 0) )
        {
            /* If no pending I/Os, remove from event vector and move
             * descriptor to AddrDescFreeQ */
            
            RtcpRemoveFromVector(pRtcpContext, pRtcpAddrDesc);

            /* If there is no pending I/O, the RtcpAddrDesc will not
             * be in any queue when we get to this point (removed in
             * the ConsumeRtcp* functions)
             * */
        }

        hr = NOERROR;
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_CMD,
                _T("%s: pRtcpContext[0x%p] pRtpAddr[0x%p] ")
                _T("failed: address not found in context"),
                _fname, pRtcpContext, pRtpAddr
            ));
    }

    return(hr);
}

/* Called from the RTCP thread whenever a RTCPTHRD_RESERVE command is
 * received. Does a reservation/unreservation on behalf of the
 * RtpAddr_t */
HRESULT RtcpThreadReserve(
        RtcpContext_t   *pRtcpContext,
        RtpAddr_t       *pRtpAddr,
        DWORD            dwCommand,
        DWORD            dwRecvSend
    )
{
    HRESULT          hr;
    DWORD            dwFlag;
    RtcpAddrDesc_t  *pRtcpAddrDesc;
    RtpQueueItem_t  *pRtpQueueItem;

    hr = NOERROR;

    pRtpQueueItem = findQO(&pRtcpContext->AddrDescBusyQ,
                           NULL,
                           (void *)pRtpAddr);

    dwFlag = dwRecvSend? FGADDRQ_QOSSENDON : FGADDRQ_QOSRECVON;
    
    if (dwCommand == RTCPTHRD_RESERVE)
    {
        /* Reserve */
        hr = RtpReserve(pRtpAddr, dwRecvSend);

        if (SUCCEEDED(hr))
        {
            RtpBitSet(pRtpAddr->dwAddrFlagsQ, dwFlag);

            if (dwRecvSend == SEND_IDX)
            {
                /* Ask for permission to send and update state if
                 * needed. Later in this same thread, when the
                 * RECEIVERS notification comes (that notification
                 * must not happen if we have not enabled QOS), the
                 * send state will be updated again */
                RtcpUpdateSendState(pRtpAddr, RTPQOS_NO_RECEIVERS);
            }
            
            if (pRtpQueueItem)
            {
                pRtcpAddrDesc =
                    CONTAINING_RECORD(pRtpQueueItem,
                                      RtcpAddrDesc_t,
                                      AddrDescQItem);

                /* Start asynchronous QOS notifications */
                StartRtcpQosNotify(pRtcpContext, pRtcpAddrDesc);
            }
        }
    }
    else
    {
        /* Unreserve */
        if (RtpBitTest(pRtpAddr->dwAddrFlagsQ, dwFlag))
        {
            hr = RtpUnreserve(pRtpAddr, dwRecvSend);

            RtpBitReset(pRtpAddr->dwAddrFlagsQ, dwFlag);

            if (dwRecvSend)
            {
                /* Sender only */
                RtpBitReset(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSREDSENDON);
            }
       }
    }
    
    return(hr);
}

/* Called from the RTCP worker thread whenever a RTCPTHRD_SENDBYE
 * command is received */
HRESULT RtcpThreadAddrSendBye(
        RtcpContext_t   *pRtcpContext,
        RtpAddr_t       *pRtpAddr,
        BOOL             bShutDown
    )
{
    HRESULT          hr;
    RtcpAddrDesc_t  *pRtcpAddrDesc;
    RtpQueueItem_t  *pRtpQueueItem;

    TraceFunctionName("RtcpThreadAddrSendBye");

    hr = RTPERR_NOTFOUND;
    
    pRtpQueueItem = findQO(&pRtcpContext->AddrDescBusyQ,
                           NULL,
                           (void *)pRtpAddr);

    if (pRtpQueueItem)
    {
        pRtcpAddrDesc =
            CONTAINING_RECORD(pRtpQueueItem, RtcpAddrDesc_t, AddrDescQItem);

        TraceDebug((
                CLASS_INFO, GROUP_RTCP, S_RTCP_CMD,
                _T("%s: pRtcpContext[0x%p] ")
                _T("pRtcpAddrDesc[0x%p] pRtpAddr[0x%p] ")
                _T("About to send BYE"),
                _fname, pRtcpContext, pRtcpAddrDesc, pRtpAddr
            ));

        RtcpSendBye(pRtcpAddrDesc);

        if (bShutDown)
        {
            TraceDebug((
                    CLASS_INFO, GROUP_RTCP, S_RTCP_CMD,
                    _T("%s: pRtcpContext[0x%p] ")
                    _T("pRtcpAddrDesc[0x%p] pRtpAddr[0x%p] ")
                    _T("About to shutdown"),
                    _fname, pRtcpContext, pRtcpAddrDesc, pRtpAddr
                ));
            
            /* This RtcpAddrDesc is about to shut down */
            RtpBitSet(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_SHUTDOWN1);
        }
        
        hr = NOERROR;
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_CMD,
                _T("%s: pRtcpContext[0x%p] pRtpAddr[0x%p] ")
                _T("failed: address not found in context"),
                _fname, pRtcpContext, pRtpAddr
            ));
    }

    return(hr);
}


/* Called from the RTCP worker thread whenever a RTCPTHRD_EXIT command
 * is received */
HRESULT RtcpThreadAddrCleanup(RtcpContext_t *pRtcpContext)
{
    RtcpAddrDesc_t  *pRtcpAddrDesc;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpAddr_t       *pRtpAddr;

    TraceFunctionName("RtcpThreadAddrCleanup");

    TraceDebug((
            CLASS_INFO, GROUP_RTCP, S_RTCP_CMD,
            _T("%s: pRtcpContext[0x%p]"),
            _fname, pRtcpContext
        ));

    /* NOTE dequeing from *StopQ shouldn't be needed if all the
     * pending I/Os had completed when the sockets were closed. In
     * practice, some times execution makes that the sequence of: 1)
     * delete sockets; then 2) send EXIT command to the thread,
     * happens fast enough that the I/O completions don't have a
     * chance to run before the thread exits (they must have been
     * ready to complete with error WSA_OPERATION_ABORTED after the
     * sockets are closed) */

#if USE_RTCP_THREAD_POOL > 0
    /* Consume any pending IO commands */
    ConsumeRtcpIoChannel(pRtcpContext);
#endif /* USE_RTCP_THREAD_POOL > 0 */
   
    /* Visit the AddrDescStopQ */
    do
    {
        pRtpQueueItem = dequeuef(&pRtcpContext->AddrDescStopQ, NULL);

        if (pRtpQueueItem)
        {
            pRtcpAddrDesc =
                CONTAINING_RECORD(pRtpQueueItem, RtcpAddrDesc_t, AddrDescQItem);

            pRtpAddr = pRtcpAddrDesc->pRtpAddr;

            if (pRtcpAddrDesc->lRtcpPending > 0)
            {
                TraceRetail((
                        CLASS_WARNING, GROUP_RTCP, S_RTCP_CMD,
                        _T("%s: pRtcpContext[0x%p] ")
                        _T("pRtcpAddrDesc[0x%p] pRtpAddr[0x%p] ")
                        _T("RTCP I/O:%d"),
                        _fname, pRtcpContext, pRtcpAddrDesc, pRtpAddr,
                        pRtcpAddrDesc->lRtcpPending
                    ));
                
                /* Enqueue again for the benefit of ConsumeRtcpRecvFrom */
                enqueuef(&pRtcpContext->AddrDescStopQ, NULL, pRtpQueueItem);
                
                ConsumeRtcpRecvFrom(pRtcpContext, pRtcpAddrDesc);

                if (pRtcpAddrDesc->lRtcpPending > 0)
                {
                    TraceRetail((
                            CLASS_ERROR, GROUP_RTCP, S_RTCP_CMD,
                            _T("%s: pRtcpContext[0x%p] ")
                            _T("pRtcpAddrDesc[0x%p] pRtpAddr[0x%p] ")
                            _T("still RTCP I/O:%d"),
                            _fname, pRtcpContext, pRtcpAddrDesc, pRtpAddr,
                            pRtcpAddrDesc->lRtcpPending
                        ));

                    pRtcpAddrDesc->lRtcpPending = 0;

                    pRtpQueueItem = dequeue(&pRtcpContext->AddrDescStopQ,
                                            NULL,
                                            &pRtcpAddrDesc->AddrDescQItem);
                    if (!pRtpQueueItem)
                    {
                        TraceRetail((
                                CLASS_ERROR, GROUP_RTCP, S_RTCP_CMD,
                                _T("%s: pRtcpContext[0x%p] ")
                                _T("pRtcpAddrDesc[0x%p] pRtpAddr[0x%p] ")
                                _T("item not found in AddrDescStopQ"),
                                _fname, pRtcpContext, pRtcpAddrDesc, pRtpAddr
                            ));
                    }

                    pRtcpAddrDesc->AddrDescQItem.pvOther = NULL;
                }
            }
            
            if (pRtcpAddrDesc->lQosPending <= 0)
            {
                RtcpRemoveFromVector(pRtcpContext, pRtcpAddrDesc);

                /* RtcpAddrDesc will be put in the AddrDescFreeQ */
            }
        }
    } while(pRtpQueueItem);

    /* Visit the QosStopQ */
    do
    {
        pRtpQueueItem = dequeuef(&pRtcpContext->QosStopQ, NULL);

        if (pRtpQueueItem)
        {
            pRtcpAddrDesc =
                CONTAINING_RECORD(pRtpQueueItem, RtcpAddrDesc_t, QosQItem);

            pRtpAddr = pRtcpAddrDesc->pRtpAddr;

            if (pRtcpAddrDesc->lQosPending > 0)
            {
                TraceRetail((
                        CLASS_WARNING, GROUP_RTCP, S_RTCP_CMD,
                        _T("%s: pRtcpContext[0x%p] ")
                        _T("pRtcpAddrDesc[0x%p] pRtpAddr[0x%p] ")
                        _T("QOS I/O:%d"),
                        _fname, pRtcpContext, pRtcpAddrDesc, pRtpAddr,
                        pRtcpAddrDesc->lQosPending
                    ));

                /* Enqueue again for the benefit of ConsumeRtcpQosNotify */
                enqueuef(&pRtcpContext->QosStopQ, NULL, pRtpQueueItem);
                
                ConsumeRtcpQosNotify(pRtcpContext, pRtcpAddrDesc);

                if (pRtcpAddrDesc->lQosPending > 0)
                {
                    TraceRetail((
                            CLASS_ERROR, GROUP_RTCP, S_RTCP_CMD,
                            _T("%s: pRtcpContext[0x%p] ")
                            _T("pRtcpAddrDesc[0x%p] pRtpAddr[0x%p] ")
                            _T("still QOS I/O:%d"),
                            _fname, pRtcpContext, pRtcpAddrDesc, pRtpAddr,
                            pRtcpAddrDesc->lQosPending
                        ));

                    pRtcpAddrDesc->lQosPending = 0;
                }
                
                RtcpRemoveFromVector(pRtcpContext, pRtcpAddrDesc);

                /* RtcpAddrDesc will be put in the AddrDescFreeQ */
            }
        }
    } while(pRtpQueueItem);

    /* NOTE we DO need to make sure we call once RtcpAddrDescFree for
     * every pRtcpAddrDesc left in AddrDescFreeQ after doing the
     * above, we need it because it is here where the Event handles
     * for asynchronous I/O (QOS, Recv) will be closed */
    do
    {
        pRtpQueueItem = dequeuef(&pRtcpContext->AddrDescFreeQ, NULL);

        if (pRtpQueueItem)
        {
            pRtcpAddrDesc =
                CONTAINING_RECORD(pRtpQueueItem, RtcpAddrDesc_t,AddrDescQItem);

            RtcpAddrDescFree(pRtcpAddrDesc);
        }
    } while(pRtpQueueItem);

    return(NOERROR);
}

/* Return the interval time (in seconds) to wait before next timeout
 * will expire */
double RtcpOnTimeout(RtcpContext_t *pRtcpContext)
{
    double           dNextTime;
    double           dNextTime2;
    double           dCurrentTime;
    double           dDelta;

    TraceFunctionName("RtcpOnTimeout");

    /* Check Users that need to timeout */
    dNextTime = RtpAddrTimeout(pRtcpContext);
    
    /* Send RTCP reports if necesary */
    dNextTime2 = RtcpSendReports(pRtcpContext);

    if (dNextTime2 < dNextTime)
    {
        dNextTime = dNextTime2;
    }
    
    /* MAYDO check for asyncrhronous reception that needs to be
     * started and asynchronous QOS notifications (right now,
     * asynchronous QOS notifications are started once or in every
     * Reserve, if they fail, they will no be re-started later) */

    dCurrentTime = RtpGetTimeOfDay((RtpTime_t *)NULL);

    if (dNextTime > dCurrentTime)
    {
        dDelta = dNextTime - dCurrentTime;
    }
    else
    {
        dDelta = 0.01; /* 10 ms */
    }
    
    TraceDebugAdvanced((
            0, GROUP_RTCP, S_RTCP_TIMING,
            _T("%s: Wait time: %0.3f s (Next:%0.3f, Curr:%0.3f Delta:%0.3f)"),
            _fname, dNextTime - dCurrentTime,
            dNextTime, dCurrentTime, dNextTime - dCurrentTime
        ));
   
    return(dDelta);
}

/* Timeout users in all addresses, do that periodically (e.g. every
 * second). Return the moment time (in seconds from the RTP start) at
 * which a new test is required */
double RtpAddrTimeout(RtcpContext_t *pRtcpContext)
{
    RtcpAddrDesc_t  *pRtcpAddrDesc;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpAddr_t       *pRtpAddr;
    long             lCount;
    double           dDelta;
    double           dCurrentTime;
    double           dTimeToNextTest;
    double           dTimeToNextTest2;
   
    TraceFunctionName("RtpAddrTimeout");

    lCount = GetQueueSize(&pRtcpContext->AddrDescBusyQ);

    dCurrentTime = 0;
    
    for(dTimeToNextTest = BIG_TIME; lCount > 0; lCount--)
    {
        dCurrentTime = RtpGetTimeOfDay((RtpTime_t *)NULL);
        
        /* Start with the last one */
        pRtpQueueItem = pRtcpContext->AddrDescBusyQ.pFirst->pPrev;

        pRtcpAddrDesc =
            CONTAINING_RECORD(pRtpQueueItem, RtcpAddrDesc_t, AddrDescQItem);

        pRtpAddr = pRtcpAddrDesc->pRtpAddr;

        if (!RtpBitTest(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_SHUTDOWN1))
        {
            /* Age users in this RtpAddr (only if not shutting down) */
            dTimeToNextTest2 = RtpUserTimeout(pRtpAddr);

            if (dTimeToNextTest2 < dTimeToNextTest)
            {
                dTimeToNextTest = dTimeToNextTest2;
            }
        }
        
        /* Move item to the first place and prepare to check what
         * is left at the end... */
        move2first(&pRtcpContext->AddrDescBusyQ, NULL, pRtpQueueItem);
    }

    TraceDebug((
            0, GROUP_RTCP, S_RTCP_TIMING,
            _T("%s:  Time for next addr timeout test: %0.3f (+%0.3f)"),
            _fname, dTimeToNextTest, dTimeToNextTest-dCurrentTime
        ));
   
    return(dTimeToNextTest);
}

/* These are the offsets from RtpAddr_t to the queues to visit */
const DWORD g_dwRtpQueueOffset[] = {CACHE1Q, CACHE2Q, ALIVEQ, BYEQ};

#define ITEMS (sizeof(g_dwRtpQueueOffset)/sizeof(DWORD))

#define HEADQ(_addr, _off) ((RtpQueue_t *)((char *)_addr + (_off)))

const TCHAR *g_psAddrQNames[] = {
    _T("Cache1Q"),
    _T("Cache2Q"),
    _T("AliveQ"),
    _T("ByeQ")
};

/* Return the moment in time (seconds) for the next test */
double RtpUserTimeout(RtpAddr_t *pRtpAddr)
{
    BOOL             bOk;
    RtpUser_t       *pRtpUser;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpNetCount_t   *pRtpNetCount;
    long             lCount;
    DWORD            dwCurrentState;
    double           dDelta;
    double           dCurrentTime;
    double           dLastPacket;
    double           dTimeToNextTest;
    double           dTimeToNextTest2;
    double           dTimer;
    DWORD            i;
    RtpQueue_t      *pRtpQueue;

    TraceFunctionName("RtpUserTimeout");

    dCurrentTime = RtpGetTimeOfDay((RtpTime_t *)NULL);
    dTimeToNextTest = BIG_TIME;
    
    bOk = RtpEnterCriticalSection(&pRtpAddr->PartCritSect);

    if (bOk)
    {
        for(i = 0; i < ITEMS; i++)
        {
            pRtpQueue = HEADQ(pRtpAddr, g_dwRtpQueueOffset[i]);
            
            lCount = GetQueueSize(pRtpQueue);

            if (lCount <= 0)
            {
                continue;
            }
            
            pRtpQueueItem = pRtpQueue->pFirst->pPrev;

            pRtpUser =
                CONTAINING_RECORD(pRtpQueueItem, RtpUser_t, UserQItem);

            pRtpNetCount = &pRtpUser->RtpUserCount;

            do
            {
                pRtpQueueItem = pRtpQueue->pFirst->pPrev;

                pRtpUser = CONTAINING_RECORD(pRtpQueueItem,
                                             RtpUser_t,
                                             UserQItem);

                pRtpNetCount = &pRtpUser->RtpUserCount;
                
                /* Use the right timer according to the user's state */
                dwCurrentState = pRtpUser->dwUserState;

                if (dwCurrentState == RTPPARINFO_TALKING)
                {
                    dTimer = RTPPARINFO_TIMER1;
                }
                else
                {
                    dTimer =
                        g_dwTimesRtcpInterval[dwCurrentState] *
                        pRtpAddr->RtpNetSState.dRtcpInterval;
                }

                /* Use last RTP packet for states TALKING and
                 * WAS_TALKING but use the most recent of RTP or RTCP
                 * for the other states */
                dLastPacket = pRtpNetCount->dRTPLastTime;
                
                if (!( (dwCurrentState == RTPPARINFO_TALKING) ||
                       (dwCurrentState == RTPPARINFO_WAS_TALKING) ))
                {
                    if (pRtpNetCount->dRTCPLastTime > dLastPacket)
                    {
                        dLastPacket = pRtpNetCount->dRTCPLastTime;
                    }
                }

                /* Consider a timeout if we are already 50ms close */
                dDelta = dCurrentTime - dLastPacket + 0.05;
                    
                if (dDelta >= dTimer)
                {
                    /* We have a timeout */
                    
                    TraceDebugAdvanced((
                            0, GROUP_RTCP, S_RTCP_TIMEOUT,
                            _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                            _T("%s timeout: Last[%s]:%0.3f (%0.3f) ")
                            _T("Timer[%s]:%0.3f Delta:%0.3f"),
                            _fname,
                            pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                            g_psAddrQNames[i],
                            (pRtpNetCount->dRTPLastTime == dLastPacket)?
                            _T("RTP") : _T("RTCP"),
                            dLastPacket, dLastPacket-dCurrentTime,
                            g_psRtpUserStates[dwCurrentState], dTimer,
                            dDelta-0.05
                        ));

                    /* Obtain the next state now as this event may
                     * cause the RtpUser_t structure to be deleted,
                     * next state is dependent only on the current
                     * state and the user event (states machine) */
                    dwCurrentState = RtpGetNextUserState(dwCurrentState,
                                                         USER_EVENT_TIMEOUT);
                    
                    RtpUpdateUserState(pRtpAddr, pRtpUser, USER_EVENT_TIMEOUT);

                    /* Set the timer to be the value for the timer in
                     * the (new) current state if that is not
                     * RTPPARINFO_DEL */
                    if (dwCurrentState != RTPPARINFO_DEL)
                    {
                        if (dwCurrentState == RTPPARINFO_TALKING)
                        {
                            dTimeToNextTest2 = RTPPARINFO_TIMER1;
                        }
                        else
                        {
                            dTimeToNextTest2 =
                                g_dwTimesRtcpInterval[dwCurrentState] *
                                pRtpAddr->RtpNetSState.dRtcpInterval;
                        }
                    
                        dTimeToNextTest2 += dLastPacket;
                    }
                }
                else
                {
                    /* This user hasn't timeout, as active users are
                     * always moved to the first place, inactive ones
                     * move automatically to the end as a side effect
                     * and hence finding a non timeout user, while
                     * searching from end to begining, guarantee that
                     * there are no more users that have timeout */
                    dTimeToNextTest2 = dLastPacket + dTimer;

                    TraceDebugAdvanced((
                            0, GROUP_RTCP, S_RTCP_TIMING,
                            _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                            _T("%s Timer[%s]:%0.3f ")
                            _T("Time at next timeout: %0.3f (+%0.3f)"),
                            _fname,
                            pRtpAddr, pRtpUser, ntohl(pRtpUser->dwSSRC),
                            g_psAddrQNames[i],
                            g_psRtpUserStates[dwCurrentState], dTimer,
                            dTimeToNextTest2, dTimeToNextTest2-dCurrentTime
                        ));
                }

                if (dTimeToNextTest2 < dTimeToNextTest)
                {
                    dTimeToNextTest = dTimeToNextTest2;
                }

                lCount--;
                
            } while(lCount && (dDelta >= dTimer));
        }
        
        RtpLeaveCriticalSection(&pRtpAddr->PartCritSect);
    }
    
    return(dTimeToNextTest);
}

/* Return the moment in time (seconds) for the next report */
double RtcpSendReports(RtcpContext_t *pRtcpContext)
{
    RtcpAddrDesc_t  *pRtcpAddrDesc;
    RtpQueueItem_t  *pRtcpSendQItem;
    double           dCurrentTime;
    double           dTimeToNextReport;
    double           dTimeToNextReport2;
    double           dDelta;
    BOOL             bSendReport;

    TraceFunctionName("RtcpSendReports");
    
    dTimeToNextReport = BIG_TIME;
    
    /* Check if there are RTCP reports to be sent */
    do {
        bSendReport = FALSE;
    
        dCurrentTime = RtpGetTimeOfDay((RtpTime_t *)NULL);
        
        pRtcpSendQItem = pRtcpContext->SendReportQ.pFirst;

        if (pRtcpSendQItem) {
        
            pRtcpAddrDesc =
                CONTAINING_RECORD(pRtcpSendQItem, RtcpAddrDesc_t, SendQItem);

            if (RtpBitTest(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_SHUTDOWN1))
            {
                /* If shutting down, just move to the end */
                dequeue(&pRtcpContext->SendReportQ,
                        NULL,
                        pRtcpSendQItem);

                enqueuedK(&pRtcpContext->SendReportQ,
                          NULL,
                          pRtcpSendQItem,
                          BIG_TIME);

                continue;
            }
            
            if (pRtcpAddrDesc->SendQItem.dKey <= dCurrentTime) {

                /* Send RTCP report */
                bSendReport = TRUE;
                
            } else {
                dDelta = pRtcpAddrDesc->SendQItem.dKey - dCurrentTime;

                if (dDelta < 0.1 /* 100 ms */) {
                    
                    /* Send RTCP report now before its due time */
                    bSendReport = TRUE;
                    
                } else {
                    /* Sleep until the time for next report is due */
                    bSendReport = FALSE;

                    dTimeToNextReport = dCurrentTime + dDelta;
                }
            }

            if (bSendReport) {
                /* Send RTCP report */

                dequeue(&pRtcpContext->SendReportQ,
                        NULL,
                        pRtcpSendQItem);

                /* Obtain the time to next report. Do it before
                 * actually sending the report so we know if we are a
                 * receiver or a sender (send RR or SR) */
                dTimeToNextReport2 =
                    dCurrentTime +
                    RtcpNextReportInterval(pRtcpAddrDesc->pRtpAddr);

                if (!RtpBitTest(pRtcpAddrDesc->dwAddrDescFlags,
                                FGADDRD_SHUTDOWN1))
                {
                    /* Send report only if not shutting down */
                    RtcpSendReport(pRtcpAddrDesc);
                }

                if (dTimeToNextReport2 < dTimeToNextReport)
                {
                    dTimeToNextReport = dTimeToNextReport2;
                }
                
                /* Insert in ascending order using the
                 * dTimeToNextReport2 as a Key */
                enqueuedK(&pRtcpContext->SendReportQ,
                          NULL,
                          pRtcpSendQItem,
                          dTimeToNextReport2);

                TraceDebugAdvanced((
                        0, GROUP_RTCP, S_RTCP_TIMING,
                        _T("%s: pRtpAddr[0x%p] Time to next RTCP report: ")
                        _T("%0.3f (+%0.3f)"),
                        _fname, pRtcpAddrDesc->pRtpAddr,
                        dTimeToNextReport2, dTimeToNextReport2-dCurrentTime
                    ));
            }
        }
    } while(bSendReport);

    TraceDebug((
            0, GROUP_RTCP, S_RTCP_TIMING,
            _T("%s: pRtcpContext[0x%p] Time to next RTCP report: ")
            _T("%0.3f (+%0.3f)"),
            _fname, pRtcpContext,
            dTimeToNextReport, dTimeToNextReport-dCurrentTime
        ));
    

    return(dTimeToNextReport);
}

/**********************************************************************
 * RtcpAddrDesc_t handling
 **********************************************************************/

/* Creates and initializes a ready to use RtcpAddrDesc_t structure */
RtcpAddrDesc_t *RtcpAddrDescAlloc(
        RtpAddr_t       *pRtpAddr
    )
{
    DWORD            dwError;
    RtcpAddrDesc_t  *pRtcpAddrDesc;

    TraceFunctionName("RtcpAddrDescAlloc");

    pRtcpAddrDesc =
        RtpHeapAlloc(g_pRtcpAddrDescHeap, sizeof(RtcpAddrDesc_t));

    if (!pRtcpAddrDesc)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_ADDRDESC, S_ADDRDESC_ALLOC,
                _T("%s: failed to allocate memory"),
                _fname
            ));

        goto bail;
    }

    ZeroMemory(pRtcpAddrDesc, sizeof(RtcpAddrDesc_t));
        
    pRtcpAddrDesc->dwObjectID = OBJECTID_RTCPADDRDESC;

    /* Overlapped RTCP reception */
    pRtcpAddrDesc->pRtcpRecvIO = RtcpRecvIOAlloc(pRtcpAddrDesc);

    if (!pRtcpAddrDesc->pRtcpRecvIO)
    {
        goto bail;
    }

    /* RTCP send */
    pRtcpAddrDesc->pRtcpSendIO = RtcpSendIOAlloc(pRtcpAddrDesc);
    
    if (!pRtcpAddrDesc->pRtcpSendIO)
    {
        goto bail;
    }
    
    /* Asynchronous QOS notifications */
#if USE_RTCP_THREAD_POOL > 0
    /* If using thread pool, create RtpQosNotify_t structure
     * conditionally */
    if (RtpBitTest(pRtpAddr->dwIRtpFlags, FGADDR_IRTP_QOS))
    {
        pRtcpAddrDesc->pRtpQosNotify = RtpQosNotifyAlloc(pRtcpAddrDesc);

        if (!pRtcpAddrDesc->pRtpQosNotify)
        {
            goto bail;
        }
    }
#else /* USE_RTCP_THREAD_POOL > 0 */
    /* If NOT using thread pool, ALWAYS create RtpQosNotify_t
     * structure */
    pRtcpAddrDesc->pRtpQosNotify = RtpQosNotifyAlloc(pRtcpAddrDesc);

    if (!pRtcpAddrDesc->pRtpQosNotify)
    {
        goto bail;
    }
#endif /* USE_RTCP_THREAD_POOL > 0 */
    
    return(pRtcpAddrDesc);
    
 bail:

    RtcpAddrDescFree(pRtcpAddrDesc);
    
    return((RtcpAddrDesc_t *)NULL);
}

/* Frees a RtcpAddrDesc_t structure */
void RtcpAddrDescFree(RtcpAddrDesc_t *pRtcpAddrDesc)
{
    TraceFunctionName("RtcpAddrDescFree");

    if (!pRtcpAddrDesc)
    {
        /* TODO may be log */
        return;
    }

    if (pRtcpAddrDesc->dwObjectID != OBJECTID_RTCPADDRDESC)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_ALLOC,
                _T("%s: pRtcpAddrDesc[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtcpAddrDesc,
                pRtcpAddrDesc->dwObjectID, OBJECTID_RTCPADDRDESC
            ));

        return;
    }

    /* Asynchronous reception */
    if (pRtcpAddrDesc->pRtcpRecvIO)
    {
        RtcpRecvIOFree(pRtcpAddrDesc->pRtcpRecvIO);
        
        pRtcpAddrDesc->pRtcpRecvIO = (RtcpRecvIO_t *)NULL;
    }

    /* Sender */
    if (pRtcpAddrDesc->pRtcpSendIO)
    {
        RtcpSendIOFree(pRtcpAddrDesc->pRtcpSendIO);
        
        pRtcpAddrDesc->pRtcpSendIO = (RtcpSendIO_t *)NULL;
    }

    /* Asynchronous QOS notifications */
    if (pRtcpAddrDesc->pRtpQosNotify)
    {
        RtpQosNotifyFree(pRtcpAddrDesc->pRtpQosNotify);

        pRtcpAddrDesc->pRtpQosNotify = (RtpQosNotify_t *)NULL;
    }

    /* Invalidate object */
    INVALIDATE_OBJECTID(pRtcpAddrDesc->dwObjectID);
    
    RtpHeapFree(g_pRtcpAddrDescHeap, pRtcpAddrDesc);
}

/* Get a ready to use RtcpAddrDesc_t from the AddrDescFreeQ, if empty
 * create a new one */
RtcpAddrDesc_t *RtcpAddrDescGetFree(
        RtcpContext_t   *pRtcpContext,
        RtpAddr_t       *pRtpAddr
    )
{
    RtcpAddrDesc_t  *pRtcpAddrDesc;
    RtpQueueItem_t  *pRtpQueueItem;

    RtpQosNotify_t  *pRtpQosNotify;
    RtcpRecvIO_t    *pRtcpRecvIO;
    RtcpSendIO_t    *pRtcpSendIO;
    
    pRtcpAddrDesc = (RtcpAddrDesc_t *)NULL;

    /* Don't need a critical section as this function is ONLY called
     * by the RTCP thread */
    pRtpQueueItem = dequeuef(&pRtcpContext->AddrDescFreeQ, NULL);

    if (pRtpQueueItem)
    {
        pRtcpAddrDesc =
            CONTAINING_RECORD(pRtpQueueItem, RtcpAddrDesc_t, AddrDescQItem);

        if ( (RtpBitTest(pRtpAddr->dwIRtpFlags, FGADDR_IRTP_QOS) &&
              !pRtcpAddrDesc->pRtpQosNotify) ||
             (!RtpBitTest(pRtpAddr->dwIRtpFlags, FGADDR_IRTP_QOS) &&
              pRtcpAddrDesc->pRtpQosNotify) )
        {
            /* Not the kind we need, return it to the free queue */
            enqueuel(&pRtcpContext->AddrDescFreeQ, NULL, pRtpQueueItem);

            pRtcpAddrDesc = (RtcpAddrDesc_t *)NULL;
        }
        else
        {
            /* Save some pointers */
            pRtpQosNotify = pRtcpAddrDesc->pRtpQosNotify;
            pRtcpRecvIO = pRtcpAddrDesc->pRtcpRecvIO;
            pRtcpSendIO = pRtcpAddrDesc->pRtcpSendIO;

            ZeroMemory(pRtcpAddrDesc, sizeof(RtcpAddrDesc_t));
        
            pRtcpAddrDesc->dwObjectID = OBJECTID_RTCPADDRDESC;

            /* Restore saved pointers */
            pRtcpAddrDesc->pRtpQosNotify = pRtpQosNotify;
            pRtcpAddrDesc->pRtcpRecvIO = pRtcpRecvIO;
            pRtcpAddrDesc->pRtcpSendIO = pRtcpSendIO;
        }
    }

    if (!pRtcpAddrDesc)
    {
        pRtcpAddrDesc = RtcpAddrDescAlloc(pRtpAddr);
    }

    return(pRtcpAddrDesc);
}

/* Returns an address descriptor to the FreeQ to be reused later */
RtcpAddrDesc_t *RtcpAddrDescPutFree(
        RtcpContext_t   *pRtcpContext,
        RtcpAddrDesc_t  *pRtcpAddrDesc
    )
{
    TraceFunctionName("RtcpAddrDescPutFree");  

    /* Do some sanity tests */
    if ( InQueue(&pRtcpAddrDesc->AddrDescQItem) ||
         InQueue(&pRtcpAddrDesc->QosQItem)      ||
         InQueue(&pRtcpAddrDesc->RecvQItem)     ||
         InQueue(&pRtcpAddrDesc->SendQItem) )
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_ALLOC,
                _T("%s: pRtcpContext[0x%p] pRtcpAddrDesc[0x%p] ")
                _T("still in a queue"),
                _fname, pRtcpContext, pRtcpAddrDesc
            ));
        
        pRtcpAddrDesc = (RtcpAddrDesc_t *)NULL;
    }
    else
    {
        if (IsSetDebugOption(OPTDBG_FREEMEMORY))
        {
            RtcpAddrDescFree(pRtcpAddrDesc);
        }
        else
        {
            enqueuef(&pRtcpContext->AddrDescFreeQ,
                     NULL,
                     &pRtcpAddrDesc->AddrDescQItem);
        }
    }
    
    return(pRtcpAddrDesc);
}

#if USE_RTCP_THREAD_POOL > 0
HRESULT RtcpAddToVector(
        RtcpContext_t   *pRtcpContext,
        RtcpAddrDesc_t  *pRtcpAddrDesc
    )
{
    BOOL             bOk;
    DWORD            dwError;
    
    TraceFunctionName("RtcpAddToVector");

    TraceDebug((
            CLASS_INFO, GROUP_RTCP, S_RTCP_CMD,
            _T("%s: pRtcpContext[0x%p] pRtcpAddrDesc[0x%p] "),
            _fname, pRtcpContext, pRtcpAddrDesc
        ));

    bOk = RegisterWaitForSingleObject( 
            &pRtcpAddrDesc->hRecvWaitObject,/* PHANDLE phNewWaitObject */
            pRtcpAddrDesc->pRtcpRecvIO->
            hRtcpCompletedEvent,         /* HANDLE hObject */
            RtcpRecvCallback,            /* WAITORTIMERCALLBACK Callback */
            (void *)pRtcpAddrDesc,       /* PVOID Context */
            INFINITE,                    /* ULONG dwMilliseconds */
            WT_EXECUTEINWAITTHREAD       /* ULONG dwFlags */
        );

    if (!bOk)
    {
        TraceRetailGetError(dwError);
        
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_CMD,
                _T("%s: pRtcpContext[0x%p] pRtcpAddrDesc[0x%p] ")
                _T("RegisterWaitForSingleObject(Recv:0x%X) failed: %u (0x%X)"),
                _fname, pRtcpContext, pRtcpAddrDesc,
                pRtcpAddrDesc->pRtcpRecvIO->hRtcpCompletedEvent,
                dwError, dwError
            ));
        
        goto bail;
    }

    RtpBitSet(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_INVECTORRECV);

    if (RtpBitTest(pRtcpAddrDesc->pRtpAddr->dwIRtpFlags, FGADDR_IRTP_QOS))
    {
        bOk = RegisterWaitForSingleObject( 
                &pRtcpAddrDesc->hQosWaitObject,/* PHANDLE phNewWaitObject */
                pRtcpAddrDesc->pRtpQosNotify->
                hQosNotifyEvent,             /* HANDLE hObject */
                RtcpQosCallback,             /* WAITORTIMERCALLBACK Callback */
                (void *)pRtcpAddrDesc,       /* PVOID Context */
                INFINITE,                    /* ULONG dwMilliseconds */
                WT_EXECUTEINWAITTHREAD       /* ULONG dwFlags */
            );

        if (!bOk)
        {
            TraceRetailGetError(dwError);
            
            TraceRetail((
                    CLASS_ERROR, GROUP_RTCP, S_RTCP_CMD,
                    _T("%s: pRtcpContext[0x%p] pRtcpAddrDesc[0x%p] ")
                    _T("RegisterWaitForSingleObject(Qos:0x%X) failed: %u (0x%X)"),
                    _fname, pRtcpContext,
                    pRtcpAddrDesc->pRtpQosNotify->hQosNotifyEvent,
                    pRtcpAddrDesc, dwError, dwError
                ));
        
            goto bail;
        }

        RtpBitSet(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_INVECTORQOS);
    }

    pRtcpContext->dwMaxDesc++;

    return(NOERROR);

 bail:
    RtcpRemoveFromVector(pRtcpContext, pRtcpAddrDesc);

    return(RTPERR_RESOURCES);
}

HRESULT RtcpRemoveFromVector(
        RtcpContext_t   *pRtcpContext,
        RtcpAddrDesc_t  *pRtcpAddrDesc
    )
{
    BOOL             bOk;
    DWORD            dwError;
    HANDLE           hEvent;
    DWORD            dwFlags;
    
    TraceFunctionName("RtcpRemoveFromVector");

    TraceDebug((
            CLASS_INFO, GROUP_RTCP, S_RTCP_CMD,
            _T("%s: pRtcpContext[0x%p] pRtcpAddrDesc[0x%p] "),
            _fname, pRtcpContext, pRtcpAddrDesc
        ));
    
    hEvent = NULL;
    dwFlags = 0;

    if (pRtcpAddrDesc->pRtcpRecvIO)
    {
        hEvent = pRtcpAddrDesc->pRtcpRecvIO->hRtcpCompletedEvent;
    }
            
    if (RtpBitTest(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_INVECTORRECV))
    {
        RtpBitSet(dwFlags, FGADDRD_INVECTORRECV);
        
        bOk = UnregisterWaitEx(
                pRtcpAddrDesc->hRecvWaitObject,  /* HANDLE WaitHandle */
                INVALID_HANDLE_VALUE             /* HANDLE CompletionEvent */
            );

        if (bOk)
        {
            pRtcpAddrDesc->hRecvWaitObject = NULL; 
        }
        else
        {
            TraceRetailGetError(dwError);
        
            /* Save the error */
            pRtcpAddrDesc->hRecvWaitObject = (HANDLE)UIntToPtr(dwError);

            TraceRetail((
                    CLASS_ERROR, GROUP_RTCP, S_RTCP_CMD,
                    _T("%s: pRtcpContext[0x%p] pRtcpAddrDesc[0x%p] ")
                    _T("UnregisterWaitEx(Recv:0x%X) failed: %u (0x%X)"),
                    _fname, pRtcpContext, pRtcpAddrDesc, hEvent,
                    dwError, dwError
                ));
        }

        RtpBitReset(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_INVECTORRECV);
    }
    else
    {
        TraceRetail((
                CLASS_WARNING, GROUP_RTCP, S_RTCP_CMD,
                _T("%s: pRtcpContext[0x%X] pRtcpAddrDesc[0x%p] ")
                _T("handle[0x%p] is not in vector"),
                _fname, pRtcpContext, pRtcpAddrDesc,
                hEvent
            ));
    }
    
    hEvent = NULL;
    
    if (pRtcpAddrDesc->pRtpQosNotify)
    {
        hEvent = pRtcpAddrDesc->pRtpQosNotify->hQosNotifyEvent;
    }
    
    if (RtpBitTest(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_INVECTORQOS))
    {
        RtpBitSet(dwFlags, FGADDRD_INVECTORQOS);
        
        bOk = UnregisterWaitEx(
                pRtcpAddrDesc->hQosWaitObject,   /* HANDLE WaitHandle */
                INVALID_HANDLE_VALUE             /* HANDLE CompletionEvent */
            );

        if (bOk)
        {
            pRtcpAddrDesc->hQosWaitObject = NULL;
        }
        else
        {
            TraceRetailGetError(dwError);

            /* Save the error */
            pRtcpAddrDesc->hQosWaitObject = (HANDLE)UIntToPtr(dwError);
            
            TraceRetail((
                    CLASS_ERROR, GROUP_RTCP, S_RTCP_CMD,
                    _T("%s: pRtcpContext[0x%p] pRtcpAddrDesc[0x%p] ")
                    _T("UnregisterWaitEx(Qos:0x%X) failed: %u (0x%X)"),
                    _fname, pRtcpContext, pRtcpAddrDesc, hEvent,
                    dwError, dwError
                ));
        }

        RtpBitReset(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_INVECTORQOS);
    }
    else
    {
        if (!RtpBitTest(pRtcpAddrDesc->pRtpAddr->dwIRtpFlags, FGADDR_IRTP_QOS))
        {
            /* Session was not QOS enabled */
            RtpBitSet(dwFlags, FGADDRD_INVECTORQOS);
        }
        else
        {
            TraceRetail((
                    CLASS_WARNING, GROUP_RTCP, S_RTCP_CMD,
                    _T("%s: pRtcpContext[0x%X] pRtcpAddrDesc[0x%p] ")
                    _T("handle[0x%p] is not in vector"),
                    _fname, pRtcpContext, pRtcpAddrDesc,
                    hEvent
                ));
        }
    }

    if (RtpBitTest2(dwFlags, FGADDRD_INVECTORRECV, FGADDRD_INVECTORQOS) ==
        RtpBitPar2(FGADDRD_INVECTORRECV, FGADDRD_INVECTORQOS))
    {
        /* Only do this if this is a valid removal, i.e. both wait
         * objects were successfully registered before */
        
        pRtcpContext->dwMaxDesc--;

        /* Return RtcpAddrDesc to the free pool */
        RtcpAddrDescPutFree(pRtcpContext, pRtcpAddrDesc);
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTCP, S_RTCP_CMD,
                _T("%s: pRtcpContext[0x%p] pRtcpAddrDesc[0x%p] ")
                _T("Invalid attempt to remove, flags:0x%X"),
                _fname, pRtcpContext, pRtcpAddrDesc,
                dwFlags
            ));
    }
    
    return(NOERROR);
}

#else /* USE_RTCP_THREAD_POOL > 0 */

HRESULT RtcpAddToVector(
        RtcpContext_t   *pRtcpContext,
        RtcpAddrDesc_t  *pRtcpAddrDesc
    )
{
    DWORD            dwIndex;
    
    TraceFunctionName("RtcpAddToVector");

    pRtcpAddrDesc->dwDescIndex = pRtcpContext->dwMaxDesc;

    /* Find absolute index to use in handles vector */
    dwIndex = (pRtcpContext->dwMaxDesc * RTCP_HANDLE_SIZE) +
        RTCP_HANDLE_OFFSET;

    /* Event handles... */
    pRtcpContext->pHandle[dwIndex] =
        pRtcpAddrDesc->pRtcpRecvIO->hRtcpCompletedEvent;

    pRtcpContext->pHandle[dwIndex + 1] =
        pRtcpAddrDesc->pRtpQosNotify->hQosNotifyEvent;
        
    /* ...and matching RtcpAddrDesc */
    pRtcpContext->ppRtcpAddrDesc[pRtcpContext->dwMaxDesc] = pRtcpAddrDesc;

    pRtcpContext->dwMaxDesc++;

    /* Placed in vector */
    RtpBitSet2(pRtcpAddrDesc->dwAddrDescFlags,
               FGADDRD_INVECTORRECV, FGADDRD_INVECTORQOS);
        
    TraceDebug((
            CLASS_INFO, GROUP_RTCP, S_RTCP_CMD,
            _T("%s: pRtcpContext[0x%p] ")
            _T("pRtcpAddrDesc[0x%p] pRtpAddr[0x%p]"),
            _fname, pRtcpContext, pRtcpAddrDesc, pRtcpAddrDesc->pRtpAddr
        ));

    return(NOERROR);
}

/* Remove from event vector */
HRESULT RtcpRemoveFromVector(
        RtcpContext_t   *pRtcpContext,
        RtcpAddrDesc_t  *pRtcpAddrDesc
    )
{
    DWORD     dwDescIndex; /* descriptor index */
    DWORD     dwCount; /* number of logical items to move */
    DWORD     n;
    DWORD     srcH;    /* source handle */
    DWORD     dstH;    /* destination handle */
    DWORD     srcD;    /* source descriptor */
    DWORD     dstD;    /* destination descriptor */

    TraceFunctionName("RtcpRemoveFromVector");  

    if (!RtpBitTest(pRtcpAddrDesc->dwAddrDescFlags, FGADDRD_INVECTORRECV))
    {
        TraceRetail((
                CLASS_WARNING, GROUP_RTCP, S_RTCP_CMD,
                _T("%s: pRtcpContext[0x%p] pRtcpAddrDesc[0x%p] ")
                _T("is not in vector"),
                _fname, pRtcpContext, pRtcpAddrDesc
            ));

        return(NOERROR);
    }
    
    dwDescIndex = pRtcpAddrDesc->dwDescIndex;
    dwCount = pRtcpContext->dwMaxDesc - dwDescIndex - 1;

    if (dwCount > 0) {
        
        dstD = dwDescIndex;
        srcD = dwDescIndex + 1;

        dstH = RTCP_HANDLE_OFFSET + (dwDescIndex * RTCP_HANDLE_SIZE);
        srcH = dstH + RTCP_HANDLE_SIZE;

        while(dwCount > 0) {
            
            /* shift event handle(s) in vector */
            for(n = RTCP_HANDLE_SIZE; n > 0; n--, srcH++, dstH++) {
                pRtcpContext->pHandle[dstH] = pRtcpContext->pHandle[srcH];
            }
            
            /* shift matching address descriptor in vector */
            pRtcpContext->ppRtcpAddrDesc[dstD] =
                pRtcpContext->ppRtcpAddrDesc[srcD];

            /* now update new position in vector */
            pRtcpContext->ppRtcpAddrDesc[dstD]->dwDescIndex = dstD;

            srcD++;
            dstD++;
            dwCount--;
        }
    }

    /* Removed from events vector */
    RtpBitReset2(pRtcpAddrDesc->dwAddrDescFlags,
                 FGADDRD_INVECTORRECV, FGADDRD_INVECTORQOS);
    
    pRtcpContext->dwMaxDesc--;

    /* Return RtcpAddrDesc to the free pool */
    RtcpAddrDescPutFree(pRtcpContext, pRtcpAddrDesc);

    return(NOERROR);
}
#endif /* USE_RTCP_THREAD_POOL > 0 */

/*
 * Decide if we need to drop this packet or we have a collision */
BOOL RtpDropCollision(
        RtpAddr_t       *pRtpAddr,
        SOCKADDR_IN     *pSockAddrIn,
        BOOL             bRtp
    )
{
    BOOL             bCollision;
    BOOL             bDiscard;
    DWORD            dwOldSSRC;
    WORD            *pwPort;

    bCollision = FALSE;
    bDiscard = FALSE;

    if (bRtp)
    {
        pwPort = &pRtpAddr->wRtpPort[LOCAL_IDX];
    }
    else
    {
        pwPort = &pRtpAddr->wRtcpPort[LOCAL_IDX];
    }
    
    /* Find out if this is a collision or our own packet that we need
     * to discard */
                            
    if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_LOOPBACK_WS2))
    {
        /* Loopback is enabled in Winsock, detect collision only
         * between us and participants with different source
         * address/port */
                                
        if ((pRtpAddr->dwAddr[LOCAL_IDX] == pSockAddrIn->sin_addr.s_addr) &&
            (*pwPort == pSockAddrIn->sin_port))
        {
            /* Discard this packet, is ours */
            bDiscard = TRUE;
        }
        else
        {
            /* Collision detected */
            bCollision = TRUE;
        }
    }
    else
    {
        /* Loopback is disabled in Winsock, this must be a
         * collision */
        
        /* Collision detected */
        bCollision = TRUE;
    }

    if (bCollision)
    {
        /* Send BYE and get new random variables (including new SSRC) */

        /* Send BYE, need to do it asynchronously by sending a command
         * to the RTCP thread if the caller is a reception thread, or
         * directly calling the function if in the context of the RTCP
         * thread */
        
        if (bRtp)
        {
            /* Send command to RTCP thread to do it */
            RtcpThreadCmd(&g_RtcpContext,
                          pRtpAddr,
                          RTCPTHRD_SENDBYE,
                          FALSE,
                          60*60*1000); /* TODO update */
        }
        else
        {
            /* Just do it */
            RtcpThreadAddrSendBye(&g_RtcpContext, pRtpAddr, FALSE);
        }
        
        /* Reset counters and obtain new random values */
        
        /* Reset counters */
        RtpResetNetCount(&pRtpAddr->RtpAddrCount[RECV_IDX],
                         &pRtpAddr->NetSCritSect);
        RtpResetNetCount(&pRtpAddr->RtpAddrCount[SEND_IDX],
                         &pRtpAddr->NetSCritSect);
        
        /* Reset sender's network state */
        RtpResetNetSState(&pRtpAddr->RtpNetSState,
                          &pRtpAddr->NetSCritSect);
        
        dwOldSSRC = pRtpAddr->RtpNetSState.dwSendSSRC;

        /* Need to set it to zero to bypass the Init option
         * RTPINITFG_PERSISTSSRC (if in use) */
        pRtpAddr->RtpNetSState.dwSendSSRC = 0;
        
        /* Obtain new SSRC, random sequence number and timestamp */
        RtpGetRandomInit(pRtpAddr);

        /* Post event */
        RtpPostEvent(pRtpAddr,
                     NULL,
                     RTPEVENTKIND_RTP,
                     RTPRTP_LOCAL_COLLISION,
                     pRtpAddr->RtpNetSState.dwSendSSRC /* Par1: new SSRC */,
                     dwOldSSRC);
    }
    
    return(bDiscard);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\rtp\rtpdtmf.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpdtmf.c
 *
 *  Abstract:
 *
 *    Implements functionality to partially support rfc2833
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2000/08/17 created
 *
 **********************************************************************/

#include "gtypes.h"
#include "rtphdr.h"
#include "struct.h"
#include "rtpsend.h"

#include "rtpdtmf.h"

/* Configures DTMF parameters */
DWORD RtpSetDtmfParameters(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwPT_Dtmf
    )
{
    DWORD            dwError;
    
    TraceFunctionName("RtpSetDtmfParameters");

    dwError = NOERROR;
    
    if ((dwPT_Dtmf & 0x7f) == dwPT_Dtmf)
    {
        pRtpAddr->RtpNetSState.bPT_Dtmf = (BYTE)dwPT_Dtmf;
    }
    else
    {
        dwError = RTPERR_INVALIDARG;
    }

    if (dwError == NOERROR)
    {
        TraceRetail((
                CLASS_INFO, GROUP_RTP, S_RTP_DTMF,
                _T("%s: pRtpAddr[0x%p] DTMF PT:%u"),
                _fname, pRtpAddr, dwPT_Dtmf
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTP, S_RTP_DTMF,
                _T("%s: pRtpAddr[0x%p] DTMF invalid PT:%u"),
                _fname, pRtpAddr, dwPT_Dtmf
            ));
    }

    return(dwError);
}

/* Directs an RTP render filter to send a packet formatted according
 * to rfc2833 containing the specified event, specified volume level,
 * duration in timestamp units, and some flags (including END flag) */
DWORD RtpSendDtmfEvent(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwTimeStamp,
        DWORD            dwEvent,
        DWORD            dwVolume,
        DWORD            dwDuration, /* timestamp units */
        DWORD            dwDtmfFlags
    )
{
    DWORD            dwError;
    DWORD            dwSendFlags;
    WSABUF           WSABuf[2];
    RtpDtmfEvent_t   RtpDtmfEvent;

    TraceFunctionName("RtpSendDtmfEvent");

    /* Check parameters */
    if ( (dwEvent >= RTPDTMF_LAST) ||
         ((dwVolume & 0x3f) != dwVolume) ||
         ((dwDuration & 0xffff) != dwDuration) )
    {
        dwError = RTPERR_INVALIDARG;

        goto end;
    }

    if (pRtpAddr->RtpNetSState.bPT_Dtmf == NO_PAYLOADTYPE)
    {
        /* DTMF payload type hasn't been set yet */

        dwError = RTPERR_INVALIDSTATE;

        goto end;
    }

    dwSendFlags = RtpBitPar(FGSEND_DTMF);
    
    if (RtpBitTest(dwDtmfFlags, FGDTMF_MARKER))
    {
        dwSendFlags |= RtpBitPar(FGSEND_FORCEMARKER);
    }
    
    /* Format packet */
    RtpDtmfEvent.event = (BYTE)dwEvent;
    RtpDtmfEvent.e = RtpBitTest(dwDtmfFlags, FGDTMF_END)? 1:0;
    RtpDtmfEvent.r = 0;
    RtpDtmfEvent.volume = (BYTE)dwVolume;
    RtpDtmfEvent.duration = htons((WORD)dwDuration);

    /* Fill up WSABUFs */
    WSABuf[0].len = 0;
    WSABuf[0].buf = NULL;
    WSABuf[1].len = sizeof(RtpDtmfEvent);
    WSABuf[1].buf = (char *)&RtpDtmfEvent;

    /* Send packet */
    dwError = RtpSendTo_(pRtpAddr, WSABuf, 2, dwTimeStamp, dwSendFlags);

 end:
    if (dwError == NOERROR)
    {
        TraceRetail((
                CLASS_INFO, GROUP_RTP, S_RTP_DTMF,
                _T("%s: pRtpAddr[0x%p] Event sent: ")
                _T("Event:%u Volume:%u Duration:%u, End:%u"),
                _fname, pRtpAddr,
                dwEvent, dwVolume, dwDuration,
                RtpBitTest(dwDtmfFlags, FGDTMF_END)? 1:0
            ));
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTP, S_RTP_DTMF,
                _T("%s: pRtpAddr[0x%p] ")
                _T("Event:%u Volume:%u Duration:%u, End:%u ")
                _T("failed: %s (0x%X)"),
                _fname, pRtpAddr,
                dwEvent, dwVolume, dwDuration,
                RtpBitTest(dwDtmfFlags, FGDTMF_END)? 1:0,
                RTPERR_TEXT(dwError), dwError
            ));
    }
    
    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\rtp\rtpthrd.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpthrd.c
 *
 *  Abstract:
 *
 *    Implement the RTP reception working thread
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/30 created
 *
 **********************************************************************/

#include "rtprecv.h"
#include "rtpchan.h"
#include "rtpaddr.h"

#include "rtpthrd.h"

long g_lCountRtpRecvThread = 0; /* Current number */
long g_lNumRtpRecvThread = 0;   /* Cumulative number */

/* RTP reception worker thread */
DWORD WINAPI RtpWorkerThreadProc(LPVOID lpParameter)
{
    DWORD            dwError;
    BOOL             bAlertable;
    DWORD            dwCommand;
    DWORD            dwStatus;
    DWORD            dwWaitTime;
    HANDLE           hThread;
    DWORD            dwThreadID;
    RtpAddr_t       *pRtpAddr;
    RtpChannelCmd_t *pRtpChannelCmd;
    /* 0:I/O; 1:Channel */
    HANDLE           pHandle[2];
    
    TraceFunctionName("RtpWorkerThreadProc");

    InterlockedIncrement(&g_lCountRtpRecvThread);
    InterlockedIncrement(&g_lNumRtpRecvThread);
    
    /* initialize */
    pRtpAddr = (RtpAddr_t *)lpParameter;

    hThread = (HANDLE)NULL;
    dwThreadID = 0;

    if (!pRtpAddr)
    {
        dwError = RTPERR_POINTER;
        goto exit;
    }

    if (pRtpAddr->dwObjectID != OBJECTID_RTPADDR)
    {
        dwError = RTPERR_INVALIDRTPADDR;
        goto exit;
    }

    dwError = NOERROR;
    
    hThread = pRtpAddr->hRtpRecvThread;
    dwThreadID = pRtpAddr->dwRtpRecvThreadID;
    
    dwCommand = RTPTHRD_FIRST;

    /* Listen to commands send trough the channel */
    pHandle[0] = RtpChannelGetWaitEvent(&pRtpAddr->RtpRecvThreadChan);

    /* I/O completion */
    pHandle[1] = pRtpAddr->hRecvCompletedEvent;
    
    bAlertable = FALSE;

    dwWaitTime = INFINITE;

    TraceRetail((
            CLASS_INFO, GROUP_RTP, S_RTP_THREAD,
            _T("%s: pRtpAddr[0x%p] thread:%u (0x%X) ID:%u (0x%X) has started"),
            _fname, pRtpAddr,
            hThread, hThread,
            dwThreadID, dwThreadID
        ));

    /* Set the receive buffer size to a certain value */
    RtpSetRecvBuffSize(pRtpAddr, pRtpAddr->Socket[SOCK_RECV_IDX], 1024*8);
    
    while(dwCommand != RTPTHRD_STOP)
    {
        dwStatus = WaitForMultipleObjectsEx(
                2,        /* DWORD nCount */
                pHandle,  /* CONST HANDLE *lpHandles */
                FALSE,    /* BOOL fWaitAll */
                dwWaitTime,/* DWORD dwMilliseconds */
                bAlertable/* BOOL bAlertable */
            );

        if (dwStatus == WAIT_IO_COMPLETION)
        {
            /* Do nothing */
        }
        else if (dwStatus == WAIT_OBJECT_0)
        {
            /* Received commannd from channel */
            do
            {
                pRtpChannelCmd =
                    RtpChannelGetCmd(&pRtpAddr->RtpRecvThreadChan);

                if (pRtpChannelCmd)
                {
                    dwCommand = pRtpChannelCmd->dwCommand;
                    
                    if (dwCommand == RTPTHRD_START)
                    {
                        bAlertable = TRUE;
                    }
                    else if (dwCommand == RTPTHRD_STOP)
                    {
                        /* Pending I/O will never complete, move them
                         * back to FreeQ */
                        FlushRtpRecvFrom(pRtpAddr);
                    }
                    else if (dwCommand == RTPTHRD_FLUSHUSER)
                    {
                        /* This used is being deleted, I need to
                         * remove all his pending IO in RecvIOWaitRedQ */
                        FlushRtpRecvUser(pRtpAddr,
                                         (RtpUser_t *)pRtpChannelCmd->dwPar1);
                    }
                    
                    RtpChannelAck(&pRtpAddr->RtpRecvThreadChan,
                                  pRtpChannelCmd,
                                  NOERROR);
                }
            } while(pRtpChannelCmd);
        }
        else if (dwStatus == (WAIT_OBJECT_0 + 1))
        {
            /* Completion event signaled */
            ConsumeRtpRecvFrom(pRtpAddr);
        }
        else if (dwStatus == WAIT_TIMEOUT)
        {
            /* Do nothing */;
        }
        else
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_RTP, S_RTP_THREAD,
                    _T("%s: pRtpAddr[0x%p] ThreadID: %u (0x%X) ")
                    _T("Unexpected status: %u (0x%X)"),
                    _fname, pRtpAddr, dwThreadID, dwThreadID,
                    dwStatus, dwStatus
                ));
        }

        if (dwCommand != RTPTHRD_STOP)
        {
            dwWaitTime = RtpCheckReadyToPostOnTimeout(pRtpAddr);

            /* Re-start more async reception */
            StartRtpRecvFrom(pRtpAddr);
        }
    }

 exit:
    /* Reset the receive buffer size to 0 */
    if (pRtpAddr)
    {
        RtpSetRecvBuffSize(pRtpAddr, pRtpAddr->Socket[SOCK_RECV_IDX], 0);
    }

    TraceRetail((
            CLASS_INFO, GROUP_RTP, S_RTP_THREAD,
            _T("%s: pRtpAddr[0x%p] thread:%u (0x%X) ID:%u (0x%X) ")
            _T("exit with code: %u (0x%X)"),
            _fname, pRtpAddr,
            hThread, hThread,
            dwThreadID, dwThreadID,
            dwError, dwError
        ));

    InterlockedDecrement(&g_lCountRtpRecvThread);

    return(dwError);
}

/* Create a RTP reception thread, and initialize the communication
 * channel */
HRESULT RtpCreateRecvThread(RtpAddr_t *pRtpAddr)
{
    HRESULT          hr;
    DWORD            dwError;

    TraceFunctionName("RtpCreateRecvThread");

    TraceDebug((
            CLASS_INFO, GROUP_RTP, S_RTP_THREAD,
            _T("%s"),
            _fname
        ));
    
    /* First make sure we don't have anything left */
    if (pRtpAddr->hRtpRecvThread)
    {
        hr = RTPERR_INVALIDSTATE;

        TraceRetail((
                CLASS_ERROR, GROUP_RTP, S_RTP_THREAD,
                _T("%s: thread is already initialized: %s (0x%X)"),
                _fname, RTPERR_TEXT(hr), hr
            ));
        
        goto bail;
    }

    if (IsRtpChannelInitialized(&pRtpAddr->RtpRecvThreadChan))
    {
        hr = RTPERR_INVALIDSTATE;

        TraceRetail((
                CLASS_ERROR, GROUP_RTP, S_RTP_THREAD,
                _T("%s: channel is already initialized: %s (0x%X)"),
                _fname, RTPERR_TEXT(hr), hr
            ));
        
        goto bail;
    }
   
    /* Initialize channel */
    hr = RtpChannelInit(&pRtpAddr->RtpRecvThreadChan, pRtpAddr);

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTP, S_RTP_THREAD,
                _T("%s: Channel initialization failed: %s (0x%X)"),
                _fname, RTPERR_TEXT(hr), hr
            ));

        goto bail;
    }
    
    /* Create thread */
    pRtpAddr->hRtpRecvThread = CreateThread(
            NULL,                 /* LPSECURITY_ATTRIBUTES lpThrdAttrib */
            0,                    /* DWORD dwStackSize */
            RtpWorkerThreadProc,  /* LPTHREAD_START_ROUTINE lpStartProc */
            (void *)pRtpAddr,     /* LPVOID  lpParameter */
            0,                    /* DWORD dwCreationFlags */
            &pRtpAddr->dwRtpRecvThreadID /* LPDWORD lpThreadId */
        );

    if (!pRtpAddr->hRtpRecvThread)
    {
        TraceRetailGetError(dwError);
        
        TraceRetail((
                CLASS_ERROR, GROUP_RTP, S_RTP_THREAD,
                _T("%s: failed to create thread: %u (0x%X)"),
                _fname, dwError, dwError
            ));

        hr = RTPERR_THREAD;
        
        goto bail;
    }

    /* For class audio RTP threads, raise priority */
    if (RtpGetClass(pRtpAddr->dwIRtpFlags) == RTPCLASS_AUDIO)
    {
        SetThreadPriority(pRtpAddr->hRtpRecvThread,
                          THREAD_PRIORITY_TIME_CRITICAL);
    }
    
    /* Direct thread to start, synchronize ack */
    hr = RtpChannelSend(&pRtpAddr->RtpRecvThreadChan,
                        RTPTHRD_START,
                        0,
                        0,
                        60*60*1000); /* TODO update */

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTP, S_RTP_THREAD,
                _T("%s: start command ")
                _T("sent to thread failed: %u (0x%X)"),
                _fname, hr, hr
            ));

        goto bail;
    }
    
    return(hr);
 bail:
    
    RtpDeleteRecvThread(pRtpAddr);

    return(hr);
}

/* Shut down a RTP reception thread and deletes the communication
 * channel */
HRESULT RtpDeleteRecvThread(RtpAddr_t *pRtpAddr)
{
    HRESULT          hr;

    TraceFunctionName("RtpDeleteRecvThread");

    hr = RTPERR_NOERROR;

    TraceDebug((
            CLASS_INFO, GROUP_RTP, S_RTP_THREAD,
            _T("%s"),
            _fname
        ));
    
    /* Shut down thread */
    if (pRtpAddr->hRtpRecvThread)
    {
        if (IsRtpChannelInitialized(&pRtpAddr->RtpRecvThreadChan))
        {
            /* Direct thread to stop, synchronize ack */
            hr = RtpChannelSend(&pRtpAddr->RtpRecvThreadChan,
                                RTPTHRD_STOP,
                                0,
                                0,
                                60*60*1000); /* TODO update */

        }
        else
        {
            /* If no channel, force ungraceful termination */
            hr = RTPERR_CHANNEL;
        }

        if (SUCCEEDED(hr))
        {
            /* TODO I may modify to loop until object is
             * signaled or get a timeout */
            WaitForSingleObject(pRtpAddr->hRtpRecvThread, INFINITE);
        } else {
            
            /* Do ungraceful thread termination */
            
            TraceRetail((
                    CLASS_ERROR, GROUP_RTP, S_RTP_THREAD,
                    _T("%s: Unable to send ")
                    _T("command to thread: ")
                    _T(" %u (0x%X)"),
                    _fname, hr, hr
                ));

            TerminateThread(pRtpAddr->hRtpRecvThread, -1);
        }

        CloseHandle(pRtpAddr->hRtpRecvThread);
        
        pRtpAddr->hRtpRecvThread = NULL;
    }

    /* Delete channel */
    if (IsRtpChannelInitialized(&pRtpAddr->RtpRecvThreadChan))
    {
        RtpChannelDelete(&pRtpAddr->RtpRecvThreadChan);
    }

    return(hr);
}

/* Send a command to the RTP thread to flush all the waiting IOs
 * belonging to the specified RtpUser_t */
HRESULT RtpThreadFlushUser(RtpAddr_t *pRtpAddr, RtpUser_t *pRtpUser)
{
    HRESULT          hr;
    
    hr = RtpChannelSend(&pRtpAddr->RtpRecvThreadChan,
                        RTPTHRD_FLUSHUSER,
                        (DWORD_PTR)pRtpUser,
                        0,
                        60*60*1000); /* TODO update */

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\rtp\rtpchan.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpchan.c
 *
 *  Abstract:
 *
 *    Implements a communication channel between the RTCP thread
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/07/08 created
 *
 **********************************************************************/

#include "rtpheap.h"
#include "rtpglobs.h"

#include "rtpchan.h"

RtpChannelCmd_t *RtpChannelCmdAlloc(
        RtpChannel_t    *pRtpChannel
    );

void RtpChannelCmdFree(
        RtpChannelCmd_t *pRtpChannelCmd
    );

RtpChannelCmd_t *RtpChannelCmdGetFree(
        RtpChannel_t    *pRtpChannel
    );

RtpChannelCmd_t *RtpChannelCmdPutFree(
        RtpChannel_t    *pRtpChannel,
        RtpChannelCmd_t *pRtpChannelCmd
    );


/* Initializes a channel
 *
 * WARNING: must be called before the channel can be used
 * */
HRESULT RtpChannelInit(
        RtpChannel_t    *pRtpChannel,
        void            *pvOwner
    )
{
    BOOL             bStatus;
    DWORD            dwError;
    RtpChannelCmd_t *pRtpChannelCmd;
    TCHAR            Name[128];
    
    TraceFunctionName("RtpChannelInit");

    ZeroMemory(pRtpChannel, sizeof(RtpChannel_t));

    bStatus =
        RtpInitializeCriticalSection(&pRtpChannel->ChannelCritSect,
                                     (void *)pRtpChannel,
                                     _T("ChannelCritSec"));

    if (!bStatus)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_CHANNEL, S_CHANNEL_INIT,
                _T("%s: pRtpChannel[0x%p] ")
                _T("failed to initialize critical section"),
                _fname, pRtpChannel
            ));

        return(RTPERR_CRITSECT);
    }

    /* Create wait event */
    _stprintf(Name, _T("%X:pvOwner[0x%p] pRtpChannel[0x%p]->hWaitEvent"),
              GetCurrentProcessId(), pvOwner, pRtpChannel);

    pRtpChannel->hWaitEvent = CreateEvent(
            NULL,  /* LPSECURITY_ATTRIBUTES lpEventAttributes */
            FALSE, /* BOOL bManualReset */
            FALSE, /* BOOL bInitialState */
            Name   /* LPCTSTR lpName */
        );
    
    if (!pRtpChannel->hWaitEvent)
    {
        TraceRetailGetError(dwError);
            
        TraceRetail((
                CLASS_ERROR, GROUP_CHANNEL, S_CHANNEL_INIT,
                _T("%s: pRtpChannel[0x%p] failed to create ")
                _T("wait event: %u (0x%X)"),
                _fname, pRtpChannel, dwError, dwError
            ));

        RtpDeleteCriticalSection(&pRtpChannel->ChannelCritSect);

        return(RTPERR_EVENT);
    }
    
    /* Prepare one cmd */
    pRtpChannelCmd = RtpChannelCmdAlloc(pRtpChannel);

    if (pRtpChannelCmd)
    {
        RtpChannelCmdPutFree(pRtpChannel, pRtpChannelCmd);
    }
    
    return(NOERROR);
}

/* De-initializes a channel
 *
 * WARNING: must be called when the channel is not enaymore in use
 * */
HRESULT RtpChannelDelete(
        RtpChannel_t    *pRtpChannel
    )
{
    RtpQueueItem_t  *pRtpQueueItem;
    RtpChannelCmd_t *pRtpChannelCmd;
    long             lCount;
    
    TraceFunctionName("RtpChannelDelete");

    if ( !IsQueueEmpty(&pRtpChannel->CommandQ) )
    {
        lCount = GetQueueSize(&pRtpChannel->CommandQ);
        
        while( !IsQueueEmpty(&pRtpChannel->CommandQ) )
        {
            pRtpQueueItem = dequeuef(&pRtpChannel->CommandQ, NULL);
            
            if (pRtpQueueItem)
            {
                pRtpChannelCmd =
                    CONTAINING_RECORD(pRtpQueueItem,
                                      RtpChannelCmd_t,
                                      QueueItem);
                
                TraceDebug((
                        CLASS_WARNING, GROUP_CHANNEL, S_CHANNEL_INIT,
                        _T("%s: pRtpChannel[0x%p] pRtpChannelCmd[0x%p] ")
                        _T("not consumed: cmd:%u p1:0x%p p2:0x%p flags:0x%X"),
                        _fname, pRtpChannel, pRtpChannelCmd,
                        pRtpChannelCmd->dwCommand,
                        pRtpChannelCmd->dwPar1,
                        pRtpChannelCmd->dwPar2,
                        pRtpChannelCmd->dwFlags 
                    ));
                
                RtpChannelCmdFree(pRtpChannelCmd);
            }
        }

        TraceRetail((
                CLASS_WARNING, GROUP_CHANNEL, S_CHANNEL_INIT,
                _T("%s: pRtpChannel[0x%p] CommandQ was not empty: %d"),
                _fname, pRtpChannel, lCount
            ));
    }
    
    /* Scan FreeQ and free all not used commands */
    while( !IsQueueEmpty(&pRtpChannel->FreeQ) )
    {
        pRtpQueueItem = dequeuef(&pRtpChannel->FreeQ, NULL);

        if (pRtpQueueItem)
        {
            pRtpChannelCmd =
                CONTAINING_RECORD(pRtpQueueItem, RtpChannelCmd_t, QueueItem);
            
            RtpChannelCmdFree(pRtpChannelCmd);
        }
    }

    /* Close wait event handle */
    if (pRtpChannel->hWaitEvent)
    {
        CloseHandle(pRtpChannel->hWaitEvent);

        pRtpChannel->hWaitEvent = NULL;
    }
    
    RtpDeleteCriticalSection(&pRtpChannel->ChannelCritSect);

    return(NOERROR);
}

/* Creates and initializes a ready to use RtpChannelCmd_t structure */
RtpChannelCmd_t *RtpChannelCmdAlloc(
        RtpChannel_t    *pRtpChannel
    )
{
    DWORD            dwError;
    RtpChannelCmd_t *pRtpChannelCmd;
    TCHAR            Name[128];

    TraceFunctionName("RtpChannelCmdAlloc");

    pRtpChannelCmd =
        RtpHeapAlloc(g_pRtpChannelCmdHeap, sizeof(RtpChannelCmd_t));

    if (pRtpChannelCmd)
    {
        ZeroMemory(pRtpChannelCmd, sizeof(RtpChannelCmd_t));
        
        /* Create event for the answer */
        _stprintf(Name,
                  _T("%X:pRtpChannel[0x%p] pRtpChannelCmd[0x%p]->hSyncEvent"),
                  GetCurrentProcessId(), pRtpChannel, pRtpChannelCmd);
        
        pRtpChannelCmd->hSyncEvent = CreateEvent(
                NULL,  /* LPSECURITY_ATTRIBUTES lpEventAttributes */
                FALSE, /* BOOL bManualReset */
                FALSE, /* BOOL bInitialState */
                Name   /* LPCTSTR lpName */
            );

        if (!pRtpChannelCmd->hSyncEvent)
        {
            TraceRetailGetError(dwError);
            
            TraceRetail((
                    CLASS_ERROR, GROUP_CHANNEL, S_CHANNEL_CMD,
                    _T("%s: pRtpChannel[0x%p] failed to create ")
                    _T("synchronization event: %u (0x%X)"),
                    _fname, pRtpChannel, dwError, dwError
                ));

            RtpHeapFree(g_pRtpChannelCmdHeap, pRtpChannelCmd);

            pRtpChannelCmd = (RtpChannelCmd_t *)NULL;
        }
    }
    else
    {
        TraceRetail((
                CLASS_ERROR, GROUP_CHANNEL, S_CHANNEL_CMD,
                _T("%s: pRtpChannel[0x%p] failed to allocate memory"),
                _fname, pRtpChannel
            ));
    }

    if (pRtpChannelCmd)
    {
        pRtpChannelCmd->dwObjectID = OBJECTID_RTPCHANCMD;
    }
    
    return(pRtpChannelCmd);
}

/* Frees a RtpChannelCmd_t structure */
void RtpChannelCmdFree(RtpChannelCmd_t *pRtpChannelCmd)
{
    if (pRtpChannelCmd->dwObjectID != OBJECTID_RTPCHANCMD)
    {
        /* TODO log error */
        return;
    }
    
    if (pRtpChannelCmd->hSyncEvent)
    {
        CloseHandle(pRtpChannelCmd->hSyncEvent);
        pRtpChannelCmd->hSyncEvent = NULL;
    }

    RtpHeapFree(g_pRtpChannelCmdHeap, pRtpChannelCmd);
}

/* Get a ready to use command from the FreeQ, if empty create a new
 * one */
RtpChannelCmd_t *RtpChannelCmdGetFree(
        RtpChannel_t    *pRtpChannel
    )
{
    RtpChannelCmd_t *pRtpChannelCmd;
    RtpQueueItem_t  *pRtpQueueItem;

    pRtpChannelCmd = (RtpChannelCmd_t *)NULL;
    
    pRtpQueueItem = dequeuef(&pRtpChannel->FreeQ,
                             &pRtpChannel->ChannelCritSect);

    if (pRtpQueueItem)
    {
        pRtpChannelCmd =
            CONTAINING_RECORD(pRtpQueueItem, RtpChannelCmd_t, QueueItem);
    }

    if (!pRtpChannelCmd)
    {
        pRtpChannelCmd = RtpChannelCmdAlloc(pRtpChannel);
    }

    return(pRtpChannelCmd);
}

/* Returns a command to the FreeQ to be reused later */
RtpChannelCmd_t *RtpChannelCmdPutFree(
        RtpChannel_t    *pRtpChannel,
        RtpChannelCmd_t *pRtpChannelCmd
    )
{
    if (IsSetDebugOption(OPTDBG_FREEMEMORY))
    {
        RtpChannelCmdFree(pRtpChannelCmd);
    }
    else
    {
        enqueuef(&pRtpChannel->FreeQ,
                 &pRtpChannel->ChannelCritSect,
                 &pRtpChannelCmd->QueueItem);
    }
    
    return(pRtpChannelCmd);
}
        
        
/* Send a command to the specified channel. Wait for completion if
 * requested */
HRESULT RtpChannelSend(
        RtpChannel_t    *pRtpChannel,
        DWORD            dwCommand,
        DWORD_PTR        dwPar1,
        DWORD_PTR        dwPar2,
        DWORD            dwWaitTime
    )
{
    HRESULT          hr;
    DWORD            dwStatus;
    RtpChannelCmd_t *pRtpChannelCmd;

    TraceFunctionName("RtpChannelSend");

    /* Get a cmd */
    pRtpChannelCmd = RtpChannelCmdGetFree(pRtpChannel);

    if (pRtpChannelCmd)
    {
        TraceDebugAdvanced((
                0, GROUP_CHANNEL, S_CHANNEL_CMD,
                _T("%s: pRtpChannel[0x%p] pRtpChannelCmd[0x%p] ")
                _T("Sending %s cmd:%u p1:0x%p p2:0x%p"),
                _fname, pRtpChannel, pRtpChannelCmd,
                dwWaitTime? _T("synchronous") : _T("asynchronous"), dwCommand,
                dwPar1, dwPar2
            ));
        
        /* Fill in command */
        pRtpChannelCmd->dwCommand = dwCommand;
        pRtpChannelCmd->dwPar1 = dwPar1;
        pRtpChannelCmd->dwPar2 = dwPar2;
        pRtpChannelCmd->dwFlags = 0;
        pRtpChannelCmd->hr = 0;
        
        if (dwWaitTime)
        {
            RtpBitSet(pRtpChannelCmd->dwFlags, FGCHAN_SYNC);
        }

        /* Commands are consumed FIFO, enqueue at the end */
        enqueuel(&pRtpChannel->CommandQ,
                 &pRtpChannel->ChannelCritSect,
                 &pRtpChannelCmd->QueueItem);

        /* Awaken thread */
        SetEvent(pRtpChannel->hWaitEvent);

        if (dwWaitTime)
        {
            /*
             * WARNING:
             *
             * If the thread is having I/O completions, the wait will
             * be reset, then I would require to decrease the waiting
             * time each time I enter the wait again */
            
            do
            {
                dwStatus =
                    WaitForSingleObjectEx(pRtpChannelCmd->hSyncEvent,
                                          dwWaitTime,
                                          TRUE);

            } while (dwStatus == WAIT_IO_COMPLETION);

            if (dwStatus == WAIT_OBJECT_0)
            {
                hr = pRtpChannelCmd->hr;
            }
            else if (dwStatus == WAIT_TIMEOUT)
            {
                hr = RTPERR_WAITTIMEOUT;
            }
            else
            {
                hr = RTPERR_FAIL;
            }

            if (dwStatus != WAIT_OBJECT_0)
            {
                TraceRetail((
                        CLASS_ERROR, GROUP_CHANNEL, S_CHANNEL_CMD,
                        _T("%s: pRtpChannel[0x%p] Leaving waiting for ")
                        _T("syncronization object: %s (0x%X)"),
                        _fname, pRtpChannel, RTPERR_TEXT(hr), hr
                    ));
            }
            
            /* On synchronous commands the cmd is returned to the free
             * pool here. Yet the command is always removed from the
             * CommandQ when consumed */
            RtpChannelCmdPutFree(pRtpChannel, pRtpChannelCmd);
            
        }
        else
        {
            /* On asynchronous commands, return no error */
            hr = NOERROR;

            /* On asynchronous commands the cmd is returned during the
             * Ack (by the consumer thread) */
        }
    }
    else
    {
        hr = RTPERR_RESOURCES;
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_CHANNEL, S_CHANNEL_CMD,
                _T("%s: pRtpChannel[0x%p] failed: %s (0x%X)"),
                _fname, pRtpChannel, RTPERR_TEXT(hr), hr
            ));
    }
    else
    {
        TraceDebugAdvanced((
                0, GROUP_CHANNEL, S_CHANNEL_CMD,
                _T("%s: pRtpChannel[0x%p] pRtpChannelCmd[0x%p] ")
                _T("Command sent"),
                _fname, pRtpChannel, pRtpChannelCmd
            ));
    }
    
    return(hr);
}

/* Once a waiting thread is awakened, it get the sent comman(s) with
 * this function */
RtpChannelCmd_t *RtpChannelGetCmd(
        RtpChannel_t    *pRtpChannel
    )
{
    BOOL             bOk;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpChannelCmd_t *pRtpChannelCmd;

    TraceFunctionName("RtpChannelGetCmd");

    pRtpQueueItem = (RtpQueueItem_t *)NULL;
    pRtpChannelCmd = (RtpChannelCmd_t *)NULL;

    bOk = RtpEnterCriticalSection(&pRtpChannel->ChannelCritSect);

    if (bOk)
    {
        if (GetQueueSize(&pRtpChannel->CommandQ) > 0)
        {
            pRtpQueueItem = dequeuef(&pRtpChannel->CommandQ, NULL);
        }

        RtpLeaveCriticalSection(&pRtpChannel->ChannelCritSect);

        if (pRtpQueueItem)
        {
            pRtpChannelCmd =
                CONTAINING_RECORD(pRtpQueueItem, RtpChannelCmd_t, QueueItem);

            TraceDebugAdvanced((
                    0, GROUP_CHANNEL, S_CHANNEL_CMD,
                    _T("%s: pRtpChannel[0x%p] pRtpChannelCmd[0x%p] ")
                    _T("Receiving cmd:%u p1:0x%p p2:0x%p"),
                    _fname, pRtpChannel, pRtpChannelCmd,
                    pRtpChannelCmd->dwCommand,
                    pRtpChannelCmd->dwPar1,
                    pRtpChannelCmd->dwPar2
                ));
        }
    }

    return(pRtpChannelCmd);
}

/* Used by the consumer thread to acknowledge received commands */
HRESULT RtpChannelAck(
        RtpChannel_t    *pRtpChannel,
        RtpChannelCmd_t *pRtpChannelCmd,
        HRESULT          hr
    )
{
    TraceFunctionName("RtpChannelAck");

    if (RtpBitTest(pRtpChannelCmd->dwFlags, FGCHAN_SYNC))
    {
        /* On synchronous commands, the cmd is returned to the free
         * pool after the synchronization point by the producer
         * thread */

        /* Pass back the result */
        pRtpChannelCmd->hr = hr;
        
        TraceDebugAdvanced((
                0, GROUP_CHANNEL, S_CHANNEL_CMD,
                _T("%s: pRtpChannel[0x%p] pRtpChannelCmd[0x%p] ")
                _T("Synchronous cmd:%u result:0x%X"),
                _fname, pRtpChannel, pRtpChannelCmd,
                pRtpChannelCmd->dwCommand, hr
            ));
        
        SetEvent(pRtpChannelCmd->hSyncEvent);
    }
    else
    {
        TraceDebugAdvanced((
                0, GROUP_CHANNEL, S_CHANNEL_CMD,
                _T("%s: pRtpChannel[0x%p] pRtpChannelCmd[0x%p] ")
                _T("Asynchronous cmd:%u result:0x%X"),
                _fname, pRtpChannel, pRtpChannelCmd,
                pRtpChannelCmd->dwCommand, hr
            ));
        
        /* On asynchronous commands, the cmd is returned to the free
         * pool by the consumer thread */
        RtpChannelCmdPutFree(pRtpChannel, pRtpChannelCmd);
    }
    
    return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\rtp\rtpsend.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpsend.c
 *
 *  Abstract:
 *
 *    RTP send
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/24 created
 *
 **********************************************************************/

#include "gtypes.h"
#include "rtphdr.h"
#include "struct.h"
#include "rtpglobs.h"
#include "rtpncnt.h"
#include "rtpcrypt.h"
#include "rtpevent.h"
#include "rtpmisc.h"
#include "rtpred.h"
#include "rtpqos.h"
#include "rtpsend.h"

/*
 * Updates the RTP header */
HRESULT UpdateRtpHdr(
        RtpAddr_t       *pRtpAddr,
        RtpHdr_t        *pRtpHdr,
        DWORD            dwTimeStamp,
        DWORD            dwSendFlags
    )
{
    BOOL             bOk;
    RtpNetSState_t  *pRtpNetSState;

    pRtpNetSState = &pRtpAddr->RtpNetSState;

    bOk = RtpEnterCriticalSection(&pRtpAddr->NetSCritSect);
    
    pRtpHdr->cc      = 0; /* No Contributing SSRCs */
    pRtpHdr->x       = 0; /* No extensions */
    pRtpHdr->p       = 0; /* No padding */
    pRtpHdr->version = RTP_VERSION; /* RTP version */

    pRtpHdr->m       = (pRtpNetSState->bMarker)? 1:0;

    pRtpHdr->seq     = htons(pRtpNetSState->wSeq);
    pRtpNetSState->dwSeq++;

    /* add random offset */
    dwTimeStamp     += pRtpNetSState->dwTimeStampOffset;

    pRtpHdr->ts      = htonl(dwTimeStamp);

    pRtpHdr->ssrc    = pRtpNetSState->dwSendSSRC;

    if (!RtpBitTest(dwSendFlags, FGSEND_DTMF))
    {
        pRtpHdr->pt      = pRtpNetSState->bPT;
    }
    else
    {
        pRtpHdr->pt      = pRtpNetSState->bPT_Dtmf;

        /* Do I need to force marker bit set for first DTMF packet? */
        if (RtpBitTest(dwSendFlags, FGSEND_FORCEMARKER))
        {
            pRtpHdr->m = 1; 
        }
    }

    /* Save last timestamp together with the NTP time it corresponds
     * to */
    if (pRtpNetSState->dwSendTimeStamp != dwTimeStamp)
    {
        /* In some cases (e.g. video frames), several packets are sent
         * with the same timestamp, keep the time for the last packet
         * to be the one when the first packet of the serie containing
         * the same timestamp was sent */
        pRtpNetSState->dwSendTimeStamp = dwTimeStamp;
        pRtpNetSState->dTimeLastRtpSent = RtpGetTimeOfDay((RtpTime_t *)NULL);
    }
    
    if (bOk)
    {
        RtpLeaveCriticalSection(&pRtpAddr->NetSCritSect);
    }
    
    return(NOERROR);
}

/*
 * Updates the RTP header using the existing timestamp to generate the
 * new one (i.e. the timestamp is already in a buffer passed, may be
 * because this packet is being passed thru in a bridge like app) */
HRESULT UpdateRtpHdr2(
        RtpAddr_t       *pRtpAddr,
        RtpHdr_t        *pRtpHdr
    )
{
    BOOL             bOk;
    RtpNetSState_t  *pRtpNetSState;
    DWORD            dwTimeStamp;

    pRtpNetSState = &pRtpAddr->RtpNetSState;

    bOk = RtpEnterCriticalSection(&pRtpAddr->NetSCritSect);
    
    pRtpHdr->cc      = 0; /* No Contributing SSRCs */
    pRtpHdr->x       = 0; /* No extensions */
    pRtpHdr->p       = 0; /* No padding */
    pRtpHdr->version = RTP_VERSION; /* RTP version */

    /* remember what we got from the RTP header */
    pRtpNetSState->bMarker = (BOOL)pRtpHdr->m;
    pRtpNetSState->bPT = (BYTE)pRtpHdr->pt;
    pRtpNetSState->dwSeq = (DWORD)(ntohs(pRtpHdr->seq) + 1);
    
    /* Get original timestamp */
    dwTimeStamp      = ntohl(pRtpHdr->ts);
    
    /* add random offset */
    dwTimeStamp     += pRtpNetSState->dwTimeStampOffset;

    pRtpHdr->ts      = htonl(dwTimeStamp);

    pRtpHdr->ssrc    = pRtpNetSState->dwSendSSRC;

    /* Save last timestamp together with the NTP time it corresponds
     * to */
    if (pRtpNetSState->dwSendTimeStamp != dwTimeStamp)
    {
        /* In some cases (e.g. video frames), several packets are sent
         * with the same timestamp, keep the time for the last packet
         * to be the one when the first packet of the serie containing
         * the same timestamp was sent */
        pRtpNetSState->dwSendTimeStamp = dwTimeStamp;
        pRtpNetSState->dTimeLastRtpSent = RtpGetTimeOfDay((RtpTime_t *)NULL);
    }

    if (bOk)
    {
        RtpLeaveCriticalSection(&pRtpAddr->NetSCritSect);
    }
    
    return(NOERROR);
}

/*
 * Updates the RTP header adding the redundant header and reorganizing
 * the WSABUFs to contain the redunadnt data if available */
HRESULT UpdateRtpRedHdr(
        RtpAddr_t       *pRtpAddr,
        RtpHdr_t        *pRtpHdr,
        DWORD            dwTimeStamp,
        WSABUF          *pWSABuf,
        DWORD           *pdwWSABufCount
    )
{
    BOOL             bOk;
    BOOL             bAddRedundancy;
    DWORD            dwIndex;
    DWORD            dwSamplesDistance;
    DWORD            dwCurRedDistance;
    RtpNetSState_t  *pRtpNetSState;
    RtpRedEntry_t    RtpRedEntry;
    RtpRedEntry_t   *pRtpRedEntry;
    RtpRedHdr_t     *pRtpRedHdr;

    TraceFunctionName("UpdateRtpRedHdr");  

    pRtpNetSState = &pRtpAddr->RtpNetSState;

    bOk = RtpEnterCriticalSection(&pRtpAddr->NetSCritSect);
    
    /* Initialize part of the header */
    pRtpHdr->cc      = 0; /* No Contributing SSRCs */
    pRtpHdr->x       = 0; /* No extensions */
    pRtpHdr->p       = 0; /* No padding */
    pRtpHdr->version = RTP_VERSION; /* RTP version */

    pRtpHdr->m       = (pRtpNetSState->bMarker)? 1:0;

    pRtpHdr->seq     = htons(pRtpNetSState->wSeq);
    pRtpNetSState->dwSeq++;

    /* add random offset */
    dwTimeStamp     += pRtpNetSState->dwTimeStampOffset;

    pRtpHdr->ts      = htonl(dwTimeStamp);

    pRtpHdr->ssrc    = pRtpNetSState->dwSendSSRC;

    dwCurRedDistance = pRtpNetSState->dwCurRedDistance;
    
    bAddRedundancy = TRUE;
    
    dwSamplesDistance = 0;
    
    /* Find out if we can actually add redundancy */
    
    dwIndex = (pRtpNetSState->dwRedIndex +
               RTP_RED_MAXDISTANCE -
               dwCurRedDistance) %  RTP_RED_MAXDISTANCE;

    pRtpRedEntry = &pRtpNetSState->pRtpRedEntry[dwIndex];

    if (dwCurRedDistance > 0)
    {
        if (pRtpRedEntry->bValid)
        {
            dwSamplesDistance = pRtpNetSState->dwSendSamplesPerPacket *
                dwCurRedDistance;
        
            /* We have a valid buffer, find out if it is not too old,
             * i.e. its timestamp belongs to the one either 1, 2 or 3
             * frames before */
            if ((dwTimeStamp - dwSamplesDistance) == pRtpRedEntry->dwTimeStamp)
            {
                /* Add redundancy */
                TraceDebugAdvanced((
                        0, GROUP_RTP, S_RTP_REDSENDPERPKT1,
                        _T("%s: pRtpAddr[0x%p] at seq:%u ts:%u ")
                        _T("adding Red[%u] D:%u from seq:%u ts:%u"),
                        _fname, pRtpAddr,
                        pRtpNetSState->dwSeq-1,
                        dwTimeStamp,
                        dwIndex, dwCurRedDistance,
                        pRtpRedEntry->dwSeq,
                        pRtpRedEntry->dwTimeStamp
                ));
            }
            else
            {
                bAddRedundancy = FALSE;
                
                TraceDebugAdvanced((
                        0, GROUP_RTP, S_RTP_REDSENDPERPKT2,
                        _T("%s: pRtpAddr[0x%p] at seq:%u ts:%u ")
                        _T("discarding Red[%u] D:%u from seq:%u ts:%u ")
                        _T("expected:%u"),
                        _fname, pRtpAddr,
                        pRtpNetSState->dwSeq-1,
                        dwTimeStamp,
                        dwIndex, dwCurRedDistance,
                        pRtpRedEntry->dwSeq,
                        pRtpRedEntry->dwTimeStamp,
                        dwTimeStamp - dwSamplesDistance
                    ));
            }
        }
        else
        {
            /* Generate an empty redundancy used only to let the
             * receiver know what is the maximum redundancy distance,
             * this should be done only once the current redundancy
             * has been set bigger than 0 */
            pRtpRedEntry = &RtpRedEntry;
            
            pRtpRedEntry->WSABuf.buf = pWSABuf[1].buf;
            pRtpRedEntry->WSABuf.len = 0;
            pRtpRedEntry->bRedPT = pRtpNetSState->bPT;
            
            dwSamplesDistance = pRtpNetSState->dwSendSamplesPerPacket *
                dwCurRedDistance;

            TraceDebugAdvanced((
                    0, GROUP_RTP, S_RTP_REDSENDPERPKT1,
                    _T("%s: pRtpAddr[0x%p] at seq:%u ts:%u ")
                    _T("adding empty Red[%u] D:%u from seq:%u ts:%u"),
                    _fname, pRtpAddr,
                    pRtpNetSState->dwSeq-1,
                    dwTimeStamp,
                    dwIndex, dwCurRedDistance,
                    pRtpNetSState->dwSeq-1-dwCurRedDistance,
                    dwTimeStamp-dwSamplesDistance
                ));
        }
    }
    else
    {
        bAddRedundancy = FALSE;  
    }

    if (bAddRedundancy)
    {
        /* If sending redundant data, RTP header must indicate so by
         * carrying the redundant PT (pRtpHdr is the first WSABUF) */
        pRtpHdr->pt = pRtpNetSState->bPT_RedSend;

        /* Main data will be the fourth (last) WSABUF */
        pWSABuf[3].buf = pWSABuf[1].buf;
        pWSABuf[3].len = pWSABuf[1].len;

        /* Second WSABUF is the redundant header */
        pRtpRedHdr = (RtpRedHdr_t *)(pRtpHdr + 1);
        pWSABuf[1].buf = (char *)pRtpRedHdr;
        pWSABuf[1].len = sizeof(RtpRedHdr_t) + 1;

        /* Third WSABUF is the redundant data */
        pWSABuf[2].buf = pRtpRedEntry->WSABuf.buf;
        pWSABuf[2].len = pRtpRedEntry->WSABuf.len;

        /* Initialize redundant header, redundant block */
        pRtpRedHdr->pt = pRtpRedEntry->bRedPT;
        pRtpRedHdr->F = 1;
        PutRedLen(pRtpRedHdr, pRtpRedEntry->WSABuf.len);
        PutRedTs(pRtpRedHdr, dwSamplesDistance);

        /* Now initialize redundant header, main block */
        pRtpRedHdr++;
        pRtpRedHdr->pt = pRtpNetSState->bPT;
        pRtpRedHdr->F = 0;

        /* We have now 4 WSABUFs to send */
        *pdwWSABufCount = 4;
    }
    else
    {
        /* If not adding redundancy, RTP header must have the PT of
         * the main encoding */
        pRtpHdr->pt = pRtpNetSState->bPT;
    }
    
    /* Save last timestamp together with the NTP time it corresponds
     * to */
    if (pRtpNetSState->dwSendTimeStamp != dwTimeStamp)
    {
        /* In some cases (e.g. video frames), several packets are sent
         * with the same timestamp, keep the time for the last packet
         * to be the one when the first packet of the serie containing
         * the same timestamp was sent */
        pRtpNetSState->dwSendTimeStamp = dwTimeStamp;
        pRtpNetSState->dTimeLastRtpSent = RtpGetTimeOfDay((RtpTime_t *)NULL);
    }
    
    if (bOk)
    {
        RtpLeaveCriticalSection(&pRtpAddr->NetSCritSect);
    }
    
    return(NOERROR);
}

/* Compute if there is enough tokens to send a packet */
BOOL RtpQosEnoughTokens(
        RtpAddr_t       *pRtpAddr,
        WSABUF          *pWSABuf,
        DWORD            dwWSABufCount
    )
{
    double           dTime;
    RtpQosReserve_t *pRtpQosReserve;
    DWORD            i;
    DWORD            dwLen;
    DWORD            dwTokens;
    DWORD            dwTokenRate;
    DWORD            dwMaxSduSize;
    
    pRtpQosReserve = pRtpAddr->pRtpQosReserve;

    /* Compute overall size */
    for(i = 0, dwLen = 0; i < dwWSABufCount; i++, pWSABuf++)
    {
        dwLen += pWSABuf->len;
    }

    if (pRtpAddr->pRtpCrypt[CRYPT_SEND_IDX])
    {
        /* Add the max padding size for encryption */
        /* MAYDO obtain and keep that value in the RtpCrypt_t
         * structure */
        dwLen += 8;
    }

    /* Update available tokens */
    dTime = RtpGetTimeOfDay((RtpTime_t *)NULL);
    
    dwTokenRate = pRtpQosReserve->qos.SendingFlowspec.TokenRate;

    if (dwTokenRate == QOS_NOT_SPECIFIED)
    {
        /* This shouldn't happen, but if it does, then I will use the
         * PCMU's token rate */
        dwTokenRate = 1000;
    }

    dwMaxSduSize = pRtpQosReserve->qos.SendingFlowspec.MaxSduSize;

    if (dwMaxSduSize == QOS_NOT_SPECIFIED)
    {
        /* This shouldn't happen, but if it does, then I will use this
         * packet size */
        dwMaxSduSize = dwLen * 2;
    }
    
    dwTokens = (DWORD)
        ((dTime - pRtpQosReserve->dLastAddition) *
         (double)dwTokenRate * 0.1 /* 10% */);

    /* Update last time I made an addition to the bucket */
    pRtpQosReserve->dLastAddition = dTime;
    
    pRtpQosReserve->dwTokens += dwTokens;

    if (pRtpQosReserve->dwTokens > dwMaxSduSize)
    {
        /* Bucket size is limited by the SduSize */
        pRtpQosReserve->dwTokens = dwMaxSduSize;
    }
    
    if (pRtpQosReserve->dwTokens >= dwLen)
    {
        /* Consume the tokens when we have enough for current packet */
        pRtpQosReserve->dwTokens -= dwLen;

        return(TRUE);
    }

    /* Don't have enough tokens to send this packet */
    return(FALSE);
}

/* IMPORTANT NOTE
 *
 * This function assumes that the first WSABUF is reserved for RTP
 * header and the buffer count received as a parameter includes that
 * header. Note also that the number of buffers is in fact fix
 * depending if it is audio or video, it will be further changed is it
 * is audio and redundancy is used, and/or encryption is used, having
 * an expolicit parameter doesn't imply that the caller can pass more
 * than 1 buffer woth of payload.
 *
 * WARNING
 *
 * If using encryption, the array of WSABUFs passed can be modified */
HRESULT RtpSendTo_(
        RtpAddr_t       *pRtpAddr,
        WSABUF          *pWSABuf,
        DWORD            dwWSABufCount,
        DWORD            dwTimeStamp,
        DWORD            dwSendFlags
    )
{
    BOOL             bOk;
    BOOL             bUsingRedundancy;
    DWORD            dwEvent;
    char             cHdr[RTP_PLUS_RED_HDR_SIZE];
    WSABUF           MainWSABuf;
    RtpHdr_t        *pRtpHdr;
    RtpCrypt_t      *pRtpCrypt;
    SOCKADDR_IN      saddr;
    DWORD            dwStatus;
    DWORD            dwError;
    DWORD            dwNumBytesSent;
    DWORD            dwCount;
    double           dTime;
    TCHAR_t          sAddr[16];

    TraceFunctionName("RtpSendTo_");  

    if (!RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_RUNSEND))
    {
        return(RTPERR_INVALIDSTATE);
    }

    if (!RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_RADDR) ||
        !pRtpAddr->wRtpPort[REMOTE_IDX])
    {
        /* Do not send packet if remote address is not specified or
         * remote port is zero */
        TraceRetail((
                CLASS_WARNING, GROUP_RTP, S_RTP_SEND,
                _T("%s: pRtpAddr[0x%p] WSASendTo(%s/%u) ")
                _T("failed: no destination address/port"),
                _fname, pRtpAddr,
                RtpNtoA(pRtpAddr->dwAddr[REMOTE_IDX], sAddr),
                ntohs(pRtpAddr->wRtpPort[REMOTE_IDX])
            ));
        
        return(RTPERR_INVALIDSTATE);
    }
                                                                 
    /* Test if sender is muted */
    if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_MUTERTPSEND))
    {
        return(NOERROR);
    }

    /* Getting the current time here will make me include in the send
     * time also encryption and redundancy handling (if used), as well
     * as the time spent in WSASendTo */
    dTime = RtpGetTimeOfDay((RtpTime_t *)NULL);

    if (!RtpBitTest(pRtpAddr->dwAddrFlagsS, FGADDRS_FRAMESIZE))
    {
        if (!RtpBitTest(pRtpAddr->dwAddrFlagsS, FGADDRS_FIRSTSENT))
        {
            RtpBitSet(pRtpAddr->dwAddrFlagsS, FGADDRS_FIRSTSENT);

            pRtpAddr->RtpNetSState.dwPreviousTimeStamp = dwTimeStamp;
        }
        else if (!pRtpAddr->RtpNetSState.dwSendSamplesPerPacket)
        {
            pRtpAddr->RtpNetSState.dwSendSamplesPerPacket =
                dwTimeStamp - pRtpAddr->RtpNetSState.dwPreviousTimeStamp;

            RtpBitSet(pRtpAddr->dwAddrFlagsS, FGADDRS_FRAMESIZE);

            TraceRetail((
                    CLASS_INFO, GROUP_RTP, S_RTP_SEND,
                    _T("%s: pRtpAddr[0x%p] ")
                    _T("Sending samples/packet:%u"),
                    _fname, pRtpAddr,
                    pRtpAddr->RtpNetSState.dwSendSamplesPerPacket
                ));

            if (pRtpAddr->pRtpQosReserve)
            {
                /* Update at this moment the frame size if it was
                 * unknown so the next reservation will be done with
                 * the right QOS flowspec, this might happen later
                 * when we pass from non redundancy use to redundancy
                 * use or viceversa. This is a last resource as the
                 * frame size for a sender is always known at the time
                 * the session is configured */
                if (!pRtpAddr->pRtpQosReserve->dwFrameSizeMS[SEND_IDX])
                {
                    pRtpAddr->pRtpQosReserve->dwFrameSizeMS[SEND_IDX] =
                        pRtpAddr->RtpNetSState.dwSendSamplesPerPacket /
                        pRtpAddr->RtpNetSState.dwSendSamplingFreq;
                }
            }
        }
    }

    dwError = NOERROR;
    bUsingRedundancy = FALSE;
    
    if (!RtpBitTest(pRtpAddr->pRtpSess->dwFeatureMask, RTPFEAT_PASSHEADER))
    {
        /* RTP header */

        pRtpHdr = (RtpHdr_t *)cHdr;
        pWSABuf[0].len = sizeof(*pRtpHdr);
        pWSABuf[0].buf = (char *)pRtpHdr;

        if (RtpBitTest(dwSendFlags, FGSEND_USERED) &&
            pRtpAddr->RtpNetSState.dwNxtRedDistance &&
            pRtpAddr->RtpNetSState.dwSendSamplesPerPacket)
        {
            /* Use dwNxtRedDistance instead of dwCurRedDistance for
             * the above condition because I need to enter this path
             * to eventually update dwCurRedDistance from the value in
             * dwNxtRedDistance, that's only done at the begining of a
             * talkspurt */
            
            bUsingRedundancy = TRUE;

            MainWSABuf.buf = pWSABuf[1].buf;
            MainWSABuf.len = pWSABuf[1].len;
            
            if (pRtpAddr->RtpNetSState.bMarker)
            {
                RtpClearRedundantBuffs(pRtpAddr);

                TraceRetail((
                        CLASS_INFO, GROUP_RTP, S_RTP_REDSEND,
                        _T("%s: pRtpAddr[0x%p] update (if needed) ")
                        _T("current red distance from %u to %u"),
                        _fname, pRtpAddr,
                        pRtpAddr->RtpNetSState.dwCurRedDistance,
                        pRtpAddr->RtpNetSState.dwNxtRedDistance
                    ));
                
                pRtpAddr->RtpNetSState.dwCurRedDistance =
                    pRtpAddr->RtpNetSState.dwNxtRedDistance;
            }
            
            UpdateRtpRedHdr(pRtpAddr, pRtpHdr, dwTimeStamp,
                            pWSABuf, &dwWSABufCount);
        }
        else
        {
            UpdateRtpHdr(pRtpAddr, pRtpHdr, dwTimeStamp, dwSendFlags);
        }
    }
    else
    {
        /* RTP header and payload are in pWSABuf[1], don't modify the
         * RTP header except the SSRC */

        pRtpHdr = (RtpHdr_t *)pWSABuf[1].buf;
        
        pWSABuf[0].buf = pWSABuf[1].buf;
        pWSABuf[0].len = sizeof(RtpHdr_t) + pRtpHdr->cc * sizeof(DWORD);

        pWSABuf[1].buf += pWSABuf[0].len;
        pWSABuf[1].len -= pWSABuf[0].len;

        pWSABuf[0].len = sizeof(RtpHdr_t);
        
        UpdateRtpHdr2(pRtpAddr, pRtpHdr);
    }
    
    if (!RtpBitTest2(pRtpAddr->dwAddrFlagsQ,
                     FGADDRQ_QOSUNCONDSEND, FGADDRQ_QOSSEND))
    {
        /* NOTE FGADDRQ_QOSSEND is set when QOS is NOT used, so in the
         * absence of QOS I never enter this if */
        
        if (RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSCONDSEND))
        {
            /* Cheack if we have enough tokens to send */
            if (!RtpQosEnoughTokens(pRtpAddr, pWSABuf, dwWSABufCount))
            {
                goto skipsend;
            }
        }
        else
        {
            goto skipsend;
        }
    }

    pRtpCrypt = pRtpAddr->pRtpCrypt[CRYPT_SEND_IDX];

    if ( pRtpCrypt &&
         (RtpBitTest2(pRtpCrypt->dwCryptFlags, FGCRYPT_INIT, FGCRYPT_KEY) ==
          RtpBitPar2(FGCRYPT_INIT, FGCRYPT_KEY)) )
    {
        /* We know we have to encrypt */

        /* NOTE Be aware that RtpEncrypt will merge all the WSABUFs
         * into one whose private data is left pointing not to the
         * original buffer but to pRtpAddr->CryptBuffer[RTP_IDX] */
            
        if ((pRtpAddr->dwCryptMode & 0xffff) >= RTPCRYPTMODE_RTP)
        {
            /* Encrypt whole packets */

            dwError = RtpEncrypt(
                    pRtpAddr,
                    pRtpCrypt,
                    pWSABuf,
                    dwWSABufCount,
                    pRtpAddr->CryptBuffer[RTP_IDX],
                    pRtpAddr->dwCryptBufferLen[RTP_IDX]
                );
            
            dwWSABufCount = 1;
        }
        else
        {
            /* Encrypt only payload (this might include redundant
             * header and redundant data) */
                
            dwError = RtpEncrypt(
                    pRtpAddr,
                    pRtpCrypt,
                    pWSABuf + 1,
                    dwWSABufCount - 1,
                    pRtpAddr->CryptBuffer[RTP_IDX],
                    pRtpAddr->dwCryptBufferLen[RTP_IDX]
                );

            dwWSABufCount = 2;

            if (dwError && !pRtpCrypt->CryptFlags.EncryptionError)
            {
                /* Post an event only the first time */
                pRtpCrypt->CryptFlags.EncryptionError = 1;
 
                RtpPostEvent(pRtpAddr,
                             NULL,
                             RTPEVENTKIND_RTP,
                             RTPRTP_CRYPT_SEND_ERROR,
                             RTP_IDX,
                             pRtpCrypt->dwCryptLastError);
            }
        }
    }

    if (dwError == NOERROR)
    {
        /* Initialize destination address */
        /* TODO I shouldn't need to do this for every packet */
        ZeroMemory(&saddr, sizeof(saddr));
    
        saddr.sin_family = AF_INET;
        saddr.sin_addr.s_addr = pRtpAddr->dwAddr[REMOTE_IDX];
        saddr.sin_port = pRtpAddr->wRtpPort[REMOTE_IDX];

#if USE_GEN_LOSSES > 0
        if (RtpRandomLoss(SEND_IDX))
        {
            dwStatus = 0;

            /* I'm simulating network losses, so I still want to print
             * the log as if I had sent the packet */
            for(dwCount = 0, dwNumBytesSent = 0;
                dwCount < dwWSABufCount;
                dwCount++)
            {
                dwNumBytesSent += pWSABuf[dwCount].len;
            }

            /* @ send_at seq# ts m size pt send_time_ms */
            TraceDebugAdvanced((
                    0, GROUP_RTP, S_RTP_PERPKTSTAT9,
                    _T("%s: pRtpAddr[0x%p] @ %0.3f %u %u %u %u %u %0.3f"),
                    _fname, pRtpAddr,
                    dTime, pRtpAddr->RtpNetSState.dwSeq-1,
                    ntohl(((RtpHdr_t *)pWSABuf[0].buf)->ts),
                    ((RtpHdr_t *)pWSABuf[0].buf)->m,
                    dwNumBytesSent,
                    ((RtpHdr_t *)pWSABuf[0].buf)->pt,
                    (RtpGetTimeOfDay((RtpTime_t *)NULL) - dTime)*1000.0
                ));
            
            goto lossit;
        }
#endif /* USE_GEN_LOSSES > 0 */
    
        dwStatus = WSASendTo(
                pRtpAddr->Socket[SOCK_SEND_IDX],/* SOCKET    s */
                pWSABuf,             /* LPWSABUF  lpBuffers */
                dwWSABufCount,       /* DWORD dwBufferCount */    
                &dwNumBytesSent,     /* LPDWORD lpNumberOfBytesSent */    
                0,                   /* DWORD dwFlags*/    
                (SOCKADDR *)&saddr,  /* const struct sockaddr FAR *lpTo */
                sizeof(saddr),       /* int iToLen*/
                NULL,                /* LPWSAOVERLAPPED lpOverlapped */
                NULL /* LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionROUTINE */
            );

        /* @ send_at seq# ts m size pt send_time_ms */
        TraceDebugAdvanced((
                0, GROUP_RTP, S_RTP_PERPKTSTAT9,
                _T("%s: pRtpAddr[0x%p] @ %0.3f %u %u %u %u %u %0.3f"),
                _fname, pRtpAddr,
                dTime, pRtpAddr->RtpNetSState.dwSeq-1,
                ntohl(((RtpHdr_t *)pWSABuf[0].buf)->ts),
                ((RtpHdr_t *)pWSABuf[0].buf)->m,
                dwNumBytesSent,
                ((RtpHdr_t *)pWSABuf[0].buf)->pt,
                (RtpGetTimeOfDay((RtpTime_t *)NULL) - dTime)*1000.0
            ));

#if USE_GEN_LOSSES > 0
    lossit:
#endif /* USE_GEN_LOSSES > 0 */


        /* Once the packet is sent, I need to reorganize the redundant
         * entries if needed */
        if (bUsingRedundancy)
        {
            /* NOTE that the timestamp here doesn't have yet the
             * random offset added */
            RtpAddRedundantBuff(pRtpAddr, &MainWSABuf, dwTimeStamp);
        }
        
        if (dwStatus)
        {
            TraceRetailWSAGetError(dwError);

            if (dwError == WSAEADDRNOTAVAIL)
            {
                dwEvent = RTPRTP_WS_NET_FAILURE;
            }
            else
            {
                dwEvent = RTPRTP_WS_SEND_ERROR;
            }
            
            RtpPostEvent(pRtpAddr,
                         NULL,
                         RTPEVENTKIND_RTP,
                         dwEvent,
                         RTP_IDX,
                         dwError);

            if (IsAdvancedTracingUsed())
            {
                /* Get the total buffer size */
                for(dwCount = 0, dwNumBytesSent = 0;
                    dwCount < dwWSABufCount;
                    dwCount++)
                {
                    dwNumBytesSent += pWSABuf[dwCount].len;
                }
                
                /* Using class error controlled by the
                 * UseAdvancedTracing (normally all errors go through
                 * TraceRetail without any filter other than the
                 * class) flag to prevent, in the case of lots of
                 * errors to flood the log file */
                TraceRetail((
                        CLASS_ERROR, GROUP_RTP, S_RTP_SEND,
                        _T("%s: pRtpAddr[0x%p] seq:%u size:%u ")
                        _T("failed: %u (0x%X)"),
                        _fname, pRtpAddr,
                        pRtpAddr->RtpNetSState.dwSeq-1, dwNumBytesSent,
                        dwError, dwError
                    ));
            }

            return(RTPERR_WS2SEND);
        }
        else
        {
            /* As per draft-ietf-avt-rtp-new-05, keep a count of the
             * number of bytes of payload (not including headers) sent (to
             * be used in SR's sender info) */
            RtpUpdateNetCount(&pRtpAddr->RtpAddrCount[SEND_IDX],
                              &pRtpAddr->NetSCritSect,
                              RTP_IDX,
                              dwNumBytesSent - sizeof(*pRtpHdr),
                              NO_FLAGS,
                              dTime);
        }
    }
    
 skipsend:
            
    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\tools\common.inc ===
#**********************************************************************
#*
#*  Copyright (c) 2001 Microsoft Corporation
#*
#*  File name:
#*
#*    rtp\tools\common.inc
#*
#*  Abstract:
#*
#*    Common file included in all sources files
#*
#*  Author:
#*
#*    Andres Vega-Garcia (andresvg)
#*
#*  Revision:
#*
#*    2001/01/17 created
#*
#**********************************************************************
# MSVCRT.LIB Import library for MSVCRT.DLL, retail version
USE_CRTDLL=1

# Generate map file
USE_MAPSYM=1
BROWSER_INFO=1
USE_ICECAP4=1

INCLUDES=\
    $(BASEDIR)\public\oak\inc;\
    $(BASEDIR)\public\sdk\inc;\
    $(BASEDIR)\public\sdk\inc\crt;\
    $(TOOLS)\inc;\
    .

LINKLIBS=\
    $(TARGETPATH)\*\common.lib \
    $(SDK_LIB_PATH)\libc.lib \
    $(SDK_LIB_PATH)\msvcrt.lib \
    $(SDK_LIB_PATH)\ws2_32.lib   \
    $(SDK_LIB_PATH)\winmm.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\rtp\rtprecv.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtprecv.c
 *
 *  Abstract:
 *
 *    RTP packet reception and decoding
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/17 created
 *
 **********************************************************************/

#include "gtypes.h"
#include "rtphdr.h"
#include "struct.h"
#include "rtpncnt.h"
#include "lookup.h"
#include "rtpglobs.h"
#include "rtppinfo.h"
#include "rtpdejit.h"
#include "rtpcrypt.h"
#include "rtpqos.h"
#include "rtcpthrd.h"
#include "rtpdemux.h"
#include "rtpevent.h"
#include "rtpred.h"

#include <mmsystem.h>

#include "rtprecv.h"

DWORD RtpValidatePacket(
        RtpAddr_t       *pRtpAddr,
        RtpRecvIO_t     *pRtpRecvIO
    );

DWORD RtpPreProcessPacket(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        RtpRecvIO_t     *pRtpRecvIO,
        RtpHdr_t        *pRtpHdr
    );

DWORD RtpProcessPacket(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        RtpRecvIO_t     *pRtpRecvIO,
        RtpHdr_t        *pRtpHdr
    );

DWORD RtpPostUserBuffer(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        RtpRecvIO_t     *pRtpRecvIO,
        RtpHdr_t        *pRtpHdr
    );

BOOL RtpReadyToPost(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        RtpRecvIO_t     *pRtpRecvIO
    );

DWORD RtpScheduleToPost(
        RtpAddr_t       *pRtpAddr,
        RtpRecvIO_t     *pRtpRecvIO
    );

BOOL RtpUpdateRSeq(RtpUser_t *pRtpUser, RtpHdr_t *pRtpHdr);

void RtpForceFrameSizeDetection(
        RtpUser_t        *pRtpUser,
        RtpHdr_t         *pRtpHdr
    );

void RtpInitRSeq(RtpUser_t *pRtpUser, RtpHdr_t *pRtpHdr);

RtpRecvIO_t *RtpRecvIOGetFree(
        RtpAddr_t       *pRtpAddr
    );

RtpRecvIO_t *RtpRecvIOGetFree2(
        RtpAddr_t       *pRtpAddr,
        RtpRecvIO_t     *pRtpRecvIO
    );

RtpRecvIO_t *RtpRecvIOPutFree(
        RtpAddr_t       *pRtpAddr,
        RtpRecvIO_t     *pRtpRecvIO
    );

void RtpRecvIOFreeAll(RtpAddr_t *pRtpAddr);

HRESULT RtpRecvFrom_(
        RtpAddr_t        *pRtpAddr,
        WSABUF           *pWSABuf,
        void             *pvUserInfo1,
        void             *pvUserInfo2
    )
{
    HRESULT          hr;
    RtpRecvIO_t     *pRtpRecvIO;
    RtpQueueItem_t  *pRtpQueueItem;
        
    TraceFunctionName("RtpRecvFrom_");

    /* allocate context */
    pRtpRecvIO = RtpRecvIOGetFree(pRtpAddr);
    
    if (!pRtpRecvIO)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTP, S_RTP_RECV,
                _T("%s: pRtpAddr[0x%p] ")
                _T("No more RtpRecvIO_t structures"),
                _fname, pRtpAddr
            ));
        
        return(RTPERR_RESOURCES);
    }

    pRtpRecvIO->dwObjectID    = OBJECTID_RTPRECVIO;

    pRtpRecvIO->WSABuf.len    = pWSABuf->len;
    pRtpRecvIO->WSABuf.buf    = pWSABuf->buf;

    pRtpRecvIO->pvUserInfo1   = pvUserInfo1;
    pRtpRecvIO->pvUserInfo2   = pvUserInfo2;
    
    /* put buffer in thread's queue */

    pRtpQueueItem = enqueuel(&pRtpAddr->RecvIOReadyQ,
                             &pRtpAddr->RecvQueueCritSect,
                             &pRtpRecvIO->RtpRecvIOQItem);

    if (!pRtpQueueItem)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTP, S_RTP_RECV,
                _T("%s: pRtpAddr[0x%p] ")
                _T("enqueuel failed to enqueue to RecvIOReadyQ"),
                _fname, pRtpAddr
            ));
    }
        
    return(NOERROR);
}

/* Initiates asynchronous reception for all the buffers in
 * RtpReadyQ queue */
DWORD StartRtpRecvFrom(RtpAddr_t *pRtpAddr)
{
    RtpRecvIO_t     *pRtpRecvIO;
    RtpQueueItem_t  *pRtpQueueItem;
    DWORD            dwStarted;
    DWORD            dwStatus;
    DWORD            dwError;

    TraceFunctionName("StartRtpRecvFrom");

    dwStarted = 0;
    
    while(pRtpAddr->RecvIOReadyQ.lCount > 0)
    {
        pRtpQueueItem = dequeuef(&pRtpAddr->RecvIOReadyQ,
                                 &pRtpAddr->RecvQueueCritSect);

        if (!pRtpQueueItem)
        {
            break;
        }

        pRtpRecvIO =
            CONTAINING_RECORD(pRtpQueueItem, RtpRecvIO_t, RtpRecvIOQItem);

        /* Overlapped structure */
        pRtpRecvIO->Overlapped.hEvent = pRtpAddr->hRecvCompletedEvent;

        do
        {
            pRtpRecvIO->Overlapped.Internal = 0;
            
            pRtpRecvIO->Fromlen = sizeof(pRtpRecvIO->From);

            pRtpRecvIO->dwRtpWSFlags = 0;

            pRtpRecvIO->dwRtpIOFlags = RtpBitPar(FGRECV_MAIN);
            
            dwStatus = WSARecvFrom(
                    pRtpAddr->Socket[SOCK_RECV_IDX],/* SOCKET s */
                    &pRtpRecvIO->WSABuf,    /* LPWSABUF lpBuffers */
                    1,                      /* DWORD dwBufferCount */
                    &pRtpRecvIO->dwTransfered,/*LPDWORD lpNumberOfBytesRecvd*/
                    &pRtpRecvIO->dwRtpWSFlags,/* LPDWORD lpFlags */
                    &pRtpRecvIO->From,      /* struct sockaddr FAR *lpFrom */
                    &pRtpRecvIO->Fromlen,   /* LPINT lpFromlen */
                    &pRtpRecvIO->Overlapped,/* LPWSAOVERLAPPED lpOverlapped */
                    NULL              /* LPWSAOVERLAPPED_COMPLETION_ROUTINE */
                );
            
            /* WARNING note that the len field in the WSABUF passed is
             * not updated to reflect the amount of bytes received
             * (or transfered) */
            
            if (dwStatus)
            {
                dwError = WSAGetLastError();
            }
        } while(dwStatus &&
                ( (dwError == WSAECONNRESET) ||
                  (dwError == WSAEMSGSIZE) )   );

        if (!dwStatus || (dwError == WSA_IO_PENDING))
        {
            dwStarted++;
            
            enqueuel(&pRtpAddr->RecvIOPendingQ,
                     &pRtpAddr->RecvQueueCritSect,
                     &pRtpRecvIO->RtpRecvIOQItem);
      
        }
        else
        {
            /* move back to Ready */
                
            TraceRetail((
                    CLASS_ERROR, GROUP_RTP, S_RTP_RECV,
                    _T("%s: pRtpAddr[0x%p] ")
                    _T("Overlapped reception failed: %u (0x%X)"),
                    _fname, pRtpAddr,
                    dwError, dwError
                ));

            enqueuef(&pRtpAddr->RecvIOReadyQ,
                     &pRtpAddr->RecvQueueCritSect,
                     &pRtpRecvIO->RtpRecvIOQItem);

            RtpPostEvent(pRtpAddr,
                         NULL,
                         RTPEVENTKIND_RTP,
                         RTPRTP_WS_RECV_ERROR,
                         RTP_IDX,
                         dwError);
            break;
        }
    }

    if (dwStarted == 0 &&
        !GetQueueSize(&pRtpAddr->RecvIOPendingQ) &&
        !GetQueueSize(&pRtpAddr->RecvIOWaitRedQ) &&
        RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_RUNRECV))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTP, S_RTP_RECV,
                _T("%s: pRtpAddr[0x%p] ")
                _T("Number of RTP RECV started:0"),
                _fname, pRtpAddr
            ));
    }
    
    return(dwStarted);
}

/* Consumes all the buffers that have completed I/O
 *
 * WARNING
 *
 * timestamp, and sequence number are left in host order
 * */
DWORD ConsumeRtpRecvFrom(RtpAddr_t *pRtpAddr)
{
    BOOL             bStatus;
    BOOL             bCreate;
    DWORD            dwSendSSRC;

    RtpUser_t       *pRtpUser;
    RtpRecvIO_t     *pRtpRecvIO;
    RtpHdr_t        *pRtpHdr;
    RtpQueueItem_t  *pRtpQueueItem;
    SOCKADDR_IN     *pFromIn;

    DWORD            dwConsumed;
    
    TraceFunctionName("ConsumeRtpRecvFrom");

    dwConsumed = 0;
    
    do
    {
        pRtpUser    = (RtpUser_t *)NULL;
    
        pRtpQueueItem = pRtpAddr->RecvIOPendingQ.pFirst;
        
        if (pRtpQueueItem)
        {
            pRtpRecvIO =
                CONTAINING_RECORD(pRtpQueueItem, RtpRecvIO_t, RtpRecvIOQItem);
            
            bStatus = WSAGetOverlappedResult(
                    pRtpAddr->Socket[SOCK_RECV_IDX], /* SOCKET s */
                    &pRtpRecvIO->Overlapped,   /*LPWSAOVERLAPPED lpOverlapped*/
                    &pRtpRecvIO->dwWSTransfered,/* LPDWORD lpcbTransfer */
                    FALSE,                     /* BOOL fWait */
                    &pRtpRecvIO->dwRtpWSFlags  /* LPDWORD lpdwFlags */
                );

            if (!bStatus)
            {
                pRtpRecvIO->dwWSError = WSAGetLastError();
                
                if (pRtpRecvIO->dwWSError == WSA_IO_INCOMPLETE)
                {
                    /* just quit as this means there are no more
                     * completed I/Os */
                    /* Also need to clear the error from this buffer */
                    pRtpRecvIO->dwWSError = NOERROR;
                    break;
                }
            }

            /* I/O completed */

            pRtpRecvIO->dRtpRecvTime = RtpGetTimeOfDay((RtpTime_t *)NULL);
            
            dequeue(&pRtpAddr->RecvIOPendingQ,
                    &pRtpAddr->RecvQueueCritSect,
                    pRtpQueueItem);
            
            pRtpRecvIO->pRtpUser = (RtpUser_t *)NULL;
            
            pRtpHdr = (RtpHdr_t *)pRtpRecvIO->WSABuf.buf;
            
            pRtpRecvIO->dwTransfered = pRtpRecvIO->dwWSTransfered;

            /*
             * NOTE about dwTransfered and pRtpRecvIO->dwTransfered
             *
             * dwTransfered retains the WS2 value, while
             * RtpRecvIO->dwTransfered may be modified because of
             * decryption and/or padding removal during
             * RtpValidatePacket().
             *
             * Once the final number of bytes to pass up to the app is
             * obtained (when returning from RtpValidatePacket()),
             * dwTransfered is still used to update counters, but will
             * be readjusted after that
             * */

            /* Test if reception is muted */
            if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_MUTERTPRECV))
            {
                pRtpRecvIO->dwError = RTPERR_PACKETDROPPED;
                
                RtpBitSet2(pRtpRecvIO->dwRtpIOFlags,
                           FGRECV_DROPPED, FGRECV_MUTED);
            }
#if USE_GEN_LOSSES > 0
            else if (RtpRandomLoss(RECV_IDX))
            {
                pRtpRecvIO->dwError = RTPERR_PACKETDROPPED;
                
                RtpBitSet2(pRtpRecvIO->dwRtpIOFlags,
                           FGRECV_DROPPED, FGRECV_RANDLOSS);
            }
#endif
            else
            {
                if (pRtpRecvIO->dwWSError == NOERROR)
                {
                    /* packet succeesfully received, scan header */
                    RtpValidatePacket(pRtpAddr, pRtpRecvIO);
                    /* NOTE the above function may have modified
                     * pRtpRecvIO->dwTransfered (because of
                     * decryption/padding), error code is returned in
                     * pRtpRecvIO->dwError */

                    if (pRtpRecvIO->dwError == NOERROR)
                    {
                        /* MAYDO may need to look at the contributing
                         * sources and create new participants for each
                         * contributing source, need also to send an event
                         * NEW_SOURCE for each new participant created */

                        pFromIn = (SOCKADDR_IN *)&pRtpRecvIO->From;

                        /* Filter explicitly loopback packets if needed */
                        /* Decide if we need to detect collisions */
                        if ( RtpBitTest2(pRtpAddr->dwAddrFlags,
                                         FGADDR_COLLISION, FGADDR_ISMCAST) ==
                             RtpBitPar2(FGADDR_COLLISION, FGADDR_ISMCAST) )
                        {
                            dwSendSSRC = pRtpAddr->RtpNetSState.dwSendSSRC;
                        
                            if (pRtpHdr->ssrc == dwSendSSRC)
                            {
                                if (RtpDropCollision(pRtpAddr, pFromIn, TRUE))
                                {
                                    RtpBitSet2(pRtpRecvIO->dwRtpIOFlags,
                                               FGRECV_DROPPED, FGRECV_LOOP);
                                }
                            }
                        }

                        /* If packet is not comming from the registered
                         * source address, discard it. This is enabled by
                         * flag FGADDR_IRTP_MATCHRADDR */
                        if (RtpBitTest(pRtpAddr->dwIRtpFlags,
                                       FGADDR_IRTP_MATCHRADDR))
                        {
                            if (pFromIn->sin_addr.s_addr !=
                                pRtpAddr->dwAddr[REMOTE_IDX])
                            {
                                RtpBitSet2(pRtpRecvIO->dwRtpIOFlags,
                                           FGRECV_DROPPED, FGRECV_MISMATCH);
                            }
                        }

                        if (RtpBitTest(pRtpRecvIO->dwRtpIOFlags,
                                       FGRECV_DROPPED))
                        {
                            pRtpRecvIO->dwError = RTPERR_PACKETDROPPED;
                        }
                        else
                        {
                            /*
                             * Look up SSRC, create new one if not
                             * exist yet */
                            bCreate = TRUE;
                            pRtpUser = LookupSSRC(pRtpAddr,
                                                  pRtpHdr->ssrc,
                                                  &bCreate);

                            if (pRtpUser)
                            {
                                pRtpRecvIO->pRtpUser = pRtpUser;
                                
                                if (bCreate)
                                {
                                    /* Increase the number of not yet
                                     * validated participants, the bit
                                     * FGUSER_VALIDATED is reset when the
                                     * RtpUser_t structure is just created
                                     * */
                                    InterlockedIncrement(&pRtpAddr->lInvalid);
                                
                                    TraceDebug((
                                            CLASS_INFO, GROUP_RTP, S_RTP_RECV,
                                            _T("%s: pRtpAddr[0x%p] ")
                                            _T("SSRC:0x%X new user"),
                                            _fname, pRtpAddr,
                                            ntohl(pRtpUser->dwSSRC)
                                        ));
                                }

                                /* Store RTP source address/port */
                                if (!RtpBitTest(pRtpUser->dwUserFlags,
                                                FGUSER_RTPADDR))
                                {
                                    pRtpUser->dwAddr[RTP_IDX] =
                                        (DWORD) pFromIn->sin_addr.s_addr;
                                
                                    pRtpUser->wPort[RTP_IDX] =
                                        pFromIn->sin_port;

                                    RtpBitSet(pRtpUser->dwUserFlags,
                                              FGUSER_RTPADDR);
#if 0
                                    /* This code used to test shared
                                     * explicit mode, add automatically
                                     * each user to the shared explicit
                                     * list */
                                    RtpSetQosState(pRtpAddr,
                                                   pRtpUser->dwSSRC,
                                                   TRUE);
#endif
                                }



                                /* Preprocess the packet, this is some
                                 * processig needed for every valid
                                 * packet received, regardless it
                                 * contains redundancy or not */
                                pRtpRecvIO->dwError =
                                    RtpPreProcessPacket(pRtpAddr,
                                                        pRtpUser,
                                                        pRtpRecvIO,
                                                        pRtpHdr);

                                if (pRtpRecvIO->dwError == NOERROR)
                                {
                                    /* Buffer will be posted from the
                                     * following function, so do not
                                     * post it from here */

                                    /* Process packet, it may contain
                                     * redundancy */
                                    RtpProcessPacket(pRtpAddr,
                                                     pRtpUser,
                                                     pRtpRecvIO,
                                                     pRtpHdr);
                                }
                                else
                                {
                                    /* Packet preprocess failed */
                                    RtpBitSet2(pRtpRecvIO->dwRtpIOFlags,
                                               FGRECV_DROPPED, FGRECV_PREPROC);

                                    TraceRetail((
                                            CLASS_WARNING,GROUP_RTP,S_RTP_RECV,
                                            _T("%s: pRtpAddr[0x%p] ")
                                            _T("pRtpUser[0x%p] ")
                                            _T("pRtpRecvIO[0x%p] ")
                                            _T("preprocess failed:%u (0x%X)"),
                                            _fname, pRtpAddr, pRtpUser,
                                            pRtpRecvIO, pRtpRecvIO->dwError,
                                            pRtpRecvIO->dwError
                                        ));
                                }
                            }
                            else
                            {
                                /* Either there were no resources to create
                                 * the new user structure, or it was found in
                                 * the BYE queue and thus was reported as not
                                 * found */
                                pRtpRecvIO->dwError = RTPERR_NOTFOUND;

                                RtpBitSet2(pRtpRecvIO->dwRtpIOFlags,
                                           FGRECV_DROPPED, FGRECV_NOTFOUND);
                            }
                        }
                    }
                    else
                    {
                        /* Buffer validation failed, packet is being
                         * dropped, dwError has the reason */
                        RtpBitSet2(pRtpRecvIO->dwRtpIOFlags,
                                   FGRECV_DROPPED, FGRECV_INVALID);
                    }
                }
                else
                {
                    /* WSAGetOverlappedResult reported an error */
                    RtpBitSet2(pRtpRecvIO->dwRtpIOFlags,
                               FGRECV_ERROR, FGRECV_WS2);
                    
                    pRtpRecvIO->dwError = pRtpRecvIO->dwWSError;
                }
            }

            if (pRtpRecvIO->dwError != NOERROR)
            {
                /* In case of error, post buffer to user layer
                 * (e.g. DShow).
                 *
                 * NOTE in this code path, pRtpRecvIO->dwError always
                 * reports an error */
                RtpPostUserBuffer(pRtpAddr, pRtpUser, pRtpRecvIO, pRtpHdr);
            }

            dwConsumed++;
        }
    } while (pRtpQueueItem);

    /* Now reset event */
    ResetEvent(pRtpAddr->hRecvCompletedEvent);
    
    return(dwConsumed);
}

DWORD RtpPreProcessPacket(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,   /* Always valid */
        RtpRecvIO_t     *pRtpRecvIO,
        RtpHdr_t        *pRtpHdr
    )
{
    BOOL             bOk;
    BOOL             bValid;
    DWORD            dwOldFreq;
    double           dDelta;
    RtpNetRState_t  *pRtpNetRState;
    
    TraceFunctionName("RtpPreProcessPacket");  

    pRtpNetRState = &pRtpUser->RtpNetRState;

    bOk = RtpEnterCriticalSection(&pRtpUser->UserCritSect);

    if (bOk)
    {
        if (pRtpRecvIO->lRedHdrSize > 0)
        {
            /* Packet containing redundancy, use the main PT */
            pRtpHdr->pt = pRtpRecvIO->bPT_Block;
        }
        
        if (pRtpHdr->pt != pRtpNetRState->dwPt)
        {
            /* Save the current sampling frequency as it will be
             * updated in RtpMapPt2Frequency */
            dwOldFreq = pRtpNetRState->dwRecvSamplingFreq;
            
            /* Obtain the sampling frequency to use, can not do this
             * when the user is created as it may be created in RTCP.
             *
             * MUST be before RtpOnFirstPacket as it uses the sampling
             * frequency set by this function. This function will
             * update pRtpNetRState->dwPt and
             * pRtpNetRState->dwRecvSamplingFreq */
            pRtpRecvIO->dwError =
                RtpMapPt2Frequency(pRtpAddr, pRtpUser, pRtpHdr->pt, RECV_IDX);

            if (pRtpRecvIO->dwError == NOERROR)
            {
                TraceRetail((
                        CLASS_INFO, GROUP_RTP, S_RTP_RECV,
                        _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                        _T("Receiving PT:%u Frequency:%u"),
                        _fname, pRtpAddr, pRtpUser,
                        ntohl(pRtpUser->dwSSRC),
                        pRtpNetRState->dwPt,
                        pRtpNetRState->dwRecvSamplingFreq
                    ));

                if (!RtpBitTest(pRtpUser->dwUserFlags, FGUSER_FIRST_RTP))
                {
                    /* Do some initialization required only when the
                     * first RTP packet is received */
                    RtpOnFirstPacket(pRtpUser, pRtpHdr,
                                     pRtpRecvIO->dRtpRecvTime);

                    /* Modify some variables so a marker bit will be
                     * generated regardless of the marker bit in the
                     * original packet */
                    RtpPrepareForMarker(pRtpUser, pRtpHdr,
                                        pRtpRecvIO->dRtpRecvTime);
                    
                    /* Init variables used to keep track of sequence
                     * number, lost fraction and cycles */
                    RtpInitRSeq(pRtpUser, pRtpHdr);

                    /* First packet is considered in sequence, for
                     * RtpUdateRSeq to find so, decrement max_seq */
                    pRtpNetRState->max_seq--;
                    pRtpNetRState->red_max_seq--;

                    /* Need to set this to a value on the first packet */
                    pRtpNetRState->dwLastPacketSize = pRtpRecvIO->dwTransfered;
                    
                    RtpBitSet(pRtpUser->dwUserFlags, FGUSER_FIRST_RTP);
                }
                else if (pRtpNetRState->dwRecvSamplingFreq != dwOldFreq)
                {
                    /* A sampling frequency change has just happened,
                     * need to update my reference time to compute
                     * delay, variance and jitter */
                    RtpOnFirstPacket(pRtpUser, pRtpHdr,
                                     pRtpRecvIO->dRtpRecvTime);

                    /* Frequency change implies the audio capture
                     * device might go through perturbations that will
                     * make delay to be unstable for several packets,
                     * to better converge I need to span the
                     * adjustment to cover more packets (twice as
                     * much) */
                    RtpPrepareForShortDelay(pRtpUser, SHORTDELAYCOUNT * 2);

                    /* Also need to modify the timestamp for the
                     * begining of the talkspurt as if in the whole
                     * talksput we had been using the new sampling
                     * frequency, otherwise I would get a wrong play
                     * time */
                    if (pRtpNetRState->dwRecvSamplingFreq > dwOldFreq)
                    {
                        pRtpNetRState->dwBeginTalkspurtTs -= (DWORD)
                            ( ((ntohl(pRtpHdr->ts) -
                                pRtpNetRState->dwBeginTalkspurtTs) *
                               (pRtpNetRState->dwRecvSamplingFreq - dwOldFreq))
                              /
                              dwOldFreq );
                    }
                    else
                    {
                        pRtpNetRState->dwBeginTalkspurtTs += (DWORD)
                            ( ((ntohl(pRtpHdr->ts) -
                                pRtpNetRState->dwBeginTalkspurtTs) *
                               (dwOldFreq - pRtpNetRState->dwRecvSamplingFreq))
                              /
                              dwOldFreq );
                    }

                    TraceRetail((
                            CLASS_INFO, GROUP_RTP, S_RTP_RECV,
                            _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] SSRC:0x%X ")
                            _T("frequency change: %u to %u"),
                            _fname, pRtpAddr, pRtpUser,
                            ntohl(pRtpUser->dwSSRC),
                            dwOldFreq,
                            pRtpNetRState->dwRecvSamplingFreq
                        ));
                }

                if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_QOSRECVON))
                {
                    /* Set QOS update flag as we just started receiving
                     * a new known valid PT.
                     *
                     * WARNING this scheme works well in unicast or in
                     * multicast if everybody uses the same codec,
                     * otherwise, the last one to experience a change will
                     * dictate what basic QOS flowspec is used */
                    RtpSetQosByNameOrPT(pRtpAddr,
                                        RECV_IDX,
                                        NULL,
                                        pRtpNetRState->dwPt,
                                        NO_DW_VALUESET,
                                        NO_DW_VALUESET,
                                        NO_DW_VALUESET,
                                        NO_DW_VALUESET,
                                        TRUE);

                    /* Force frame size to be computed again, this
                     * might have changed together with the new PT,
                     * QOS will be updated only after the new frame
                     * size has been computed */
                    if (RtpGetClass(pRtpAddr->dwIRtpFlags) == RTPCLASS_AUDIO)
                    {
                        RtpForceFrameSizeDetection(pRtpUser, pRtpHdr);

                        /* Set frame size as not valid */
                        pRtpAddr->pRtpQosReserve->
                            ReserveFlags.RecvFrameSizeValid = 0;

                        /* When a new frame size is detected, this
                         * flag set to 1 will indicate that QOS needs
                         * to be updated */
                        pRtpAddr->pRtpQosReserve->
                            ReserveFlags.RecvFrameSizeWaiting = 1;
                    }
                }
            }
            else
            {
                RtpBitSet2(pRtpRecvIO->dwRtpIOFlags,
                           FGRECV_DROPPED, FGRECV_BADPT);

                /* NOTE Bad PT packets will not be used to initialize
                 * the sequence number nor to validate the participant
                 * (probation) */
            }
        }

        if (pRtpRecvIO->dwError == NOERROR)
        {            
            /* Update the sequence number and some counters for this
             * user (SSRC) */
            bValid = RtpUpdateRSeq(pRtpUser, pRtpHdr);

            /* Obtain the extended sequence number for this buffer. NOTE:
             * this needs to be done after RtpUpdateRSeq as the
             * pRtpNetRState->cycles might have been updated */
            pRtpRecvIO->dwExtSeq = pRtpNetRState->cycles + pRtpRecvIO->wSeq;

            /* Check if need to make participant valid */
            if (bValid == TRUE &&
                !RtpBitTest(pRtpUser->dwUserFlags, FGUSER_VALIDATED))
            {
                /* The participant has been validated and was invalid */
                InterlockedDecrement(&pRtpAddr->lInvalid);

                RtpBitSet(pRtpUser->dwUserFlags, FGUSER_VALIDATED);
            }
        }
        
        RtpLeaveCriticalSection(&pRtpUser->UserCritSect);
    }
    else
    {
        pRtpRecvIO->dwError = RTPERR_CRITSECT;

        RtpBitSet2(pRtpRecvIO->dwRtpIOFlags, FGRECV_DROPPED, FGRECV_CRITSECT);
    }
                        
    if (pRtpRecvIO->dwError == NOERROR)
    {
        if (RtpBitTest(pRtpAddr->dwIRtpFlags, FGADDR_IRTP_USEPLAYOUT))
        {
            if (pRtpNetRState->dwLastPacketSize != pRtpRecvIO->dwTransfered)
            {
                /* WARNING: The packet size change to detect frame
                 * size change works only for constant bit rate codecs
                 * (as opposed to variable as in video), currently all
                 * our audio codecs are in that category. */
                
                /* A frame size change just happened, need to update
                 * my reference time to compute delay, variance and
                 * jitter as otherwise a false delay jump will be
                 * detected. E.g. if we change 8KHz frames at 20ms to
                 * 90ms, the timestamp is that of the first sample,
                 * and the packet is sent 20ms later in the first
                 * case, and 90ms later in the second case, as the
                 * relative delay was set while receiving 20ms frames,
                 * when I start receiving 90ms frames I will perceive
                 * an apparent delay increase of 70ms, this will cause
                 * an un-needed jitter and playout delay increase */
                RtpPrepareForShortDelay(pRtpUser, SHORTDELAYCOUNT);

                /* Store the last audio packet size so the next change
                 * will be detected to resync again relative delay
                 * computation */
                pRtpNetRState->dwLastPacketSize = pRtpRecvIO->dwTransfered;
            }
            
            /* See if the playout bounds need to be updated */
            RtpUpdatePlayoutBounds(pRtpAddr, pRtpUser, pRtpRecvIO);
        }
        
        /* Compute delay, variance and jitter for good packets */
        RtpUpdateNetRState(pRtpAddr, pRtpUser, pRtpHdr, pRtpRecvIO);

        /* Compute the time at which the frame should be played back and
         * hence need to be posted by that time */
        if (RtpBitTest(pRtpAddr->dwIRtpFlags, FGADDR_IRTP_USEPLAYOUT))
        {
            pRtpRecvIO->dPostTime =
                pRtpNetRState->dBeginTalkspurtTime +
                pRtpRecvIO->dPlayTime;

            /* Make sure that the PlayTime is not too far ahead, this
             * could happen because of bogus timestamps */
            dDelta = pRtpRecvIO->dPostTime - pRtpRecvIO->dRtpRecvTime;
            
            if (dDelta > ((double)(MAX_PLAYOUT * 2) / 1000))
            {
                TraceRetail((
                        CLASS_WARNING, GROUP_RTP, S_RTP_RECV,
                        _T("%s: pRtpAddr[0x%p] pRtpRecvIO[0x%p] ")
                        _T("post:%0.3f/%+0.3f post time too far ahead"),
                        _fname, pRtpAddr, pRtpRecvIO,
                        pRtpRecvIO->dPostTime, dDelta
                    ));
                
                pRtpRecvIO->dPostTime = pRtpRecvIO->dRtpRecvTime +
                    ((double)(MAX_PLAYOUT * 2) / 1000);
            }

            /* Check if marker bit is set (audio) and force frame size
             * detection to be done again. Frame size can change any
             * time, if it grows the reservation should still be
             * enough, but if it decreses, we may need to redo it */
            if (RtpBitTest(pRtpRecvIO->dwRtpIOFlags, FGRECV_MARKER))
            {
                RtpForceFrameSizeDetection(pRtpUser, pRtpHdr);
            }
        }
        else
        {
            pRtpRecvIO->dPostTime = pRtpRecvIO->dRtpRecvTime;
        }
    }
    
    /* Update receive counters for this user (SSRC) */
    RtpUpdateNetCount(&pRtpUser->RtpUserCount,
                      &pRtpUser->UserCritSect,
                      RTP_IDX,
                      pRtpRecvIO->dwWSTransfered,
                      pRtpRecvIO->dwRtpIOFlags,
                      pRtpRecvIO->dRtpRecvTime);
        
    /* If user was just created, move it from AliveQ to Cache1Q, if it
     * already existed, it may have been in Cache1Q, Cache2Q, or
     * AliveQ, in either case move it to the head of Cache1Q. An event
     * might be posted result of this function call */
    RtpUpdateUserState(pRtpAddr, pRtpUser, USER_EVENT_RTP_PACKET); 

    /* Update RtpAddr and RtpSess receive stats */
                
    RtpUpdateNetCount(&pRtpAddr->RtpAddrCount[RECV_IDX],
                      &pRtpAddr->NetSCritSect,
                      RTP_IDX,
                      pRtpRecvIO->dwWSTransfered,
                      pRtpRecvIO->dwRtpIOFlags,
                      pRtpRecvIO->dRtpRecvTime);

    /* TODO right now there is only 1 RtpAddr_t per RtpSess_t, so the
     * session stats are not used because they are the same as those
     * from the address, but when support for multiple addresses per
     * session be added, we will need to update the session stats
     * also, but as they can be updated by more than 1 address, the
     * update will be a critical section. In that case, DON'T USE the
     * SessCritSect to avoid the deadlock described next. The stop
     * function will try to stop the Recv thread (having locked using
     * SessCritSect), then, if the Recv thread gets a RTP packet
     * before processing the exit command, it will consume it and
     * update stats blocking in SessCritSect, none will be able to
     * continue. The code that follows deadlocks if SessCritSect is
     * used but is right if a different lock is used */
#if 0
    RtpUpdateNetCount(&pRtpAddr->pRtpSess->
                      RtpSessCount[RECV_IDX],
                      pRtpSess->SessCritSect???,
                      RTP_IDX,
                      pRtpRecvIO->dwWSTransfered,
                      pRtpRecvIO->dRtpRecvTime);
#endif

    return(pRtpRecvIO->dwError);
}

DWORD RtpProcessPacket(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        RtpRecvIO_t     *pRtpRecvIO,
        RtpHdr_t        *pRtpHdr
    )
{
    long             lPosted;
    DWORD            dwDataOffset;
    DWORD            dwBlockSize;
    DWORD            dwTimeStampOffset;
    BOOL             bPostNow;
    RtpRecvIO_t     *pRtpRecvIO2;
    RtpRedHdr_t     *pRtpRedHdr;
    RtpNetRState_t  *pRtpNetRState;
    
    TraceFunctionName("RtpProcessPacket");  

    /* Will create a separate RtpRecvIO structure for each redundant
     * block */

    /* MAYDO compute the samples per packet (based on timestamp
     * differences) and disable redundancy use until that value has
     * been obtained, the same can be done for the sender */

    pRtpNetRState = &pRtpUser->RtpNetRState;

    lPosted = 0;
    
    if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_REDRECV) &&
        (pRtpRecvIO->lRedDataSize > 0) &&
        (pRtpNetRState->iAvgLossRateR >= RED_LT_1) &&
        !RtpBitTest(pRtpRecvIO->dwRtpIOFlags, FGRECV_MARKER) &&
        pRtpNetRState->dwRecvSamplesPerPacket > 0)
    {
        /* We have redundancy -and- redundancy is enabled -and- loss
         * rate requires packet reconstruction -and- this is not a
         * begining of a talkspurt (I discard any data preceding the
         * one on which I apply the playout delay) */

        pRtpRedHdr = (RtpRedHdr_t *)
            (pRtpRecvIO->WSABuf.buf + pRtpRecvIO->lHdrSize);

        for(dwDataOffset = 0; pRtpRedHdr->F; pRtpRedHdr++)
        {
            dwTimeStampOffset = RedTs(pRtpRedHdr);

            dwBlockSize = RedLen(pRtpRedHdr);
        
            pRtpRecvIO2 = RtpRecvIOGetFree2(pRtpAddr, pRtpRecvIO);

            if (!pRtpRecvIO2)
            {
                /* Lack of resources prevent the processing of
                 * this redundancy block, try next one (next one
                 * migth be main)
                 * */
                dwDataOffset += dwBlockSize;
                
                continue;
            }

            /* It is redundancy, FGRECV_MAIN must be reset and the
             * redundancy flag set */
            pRtpRecvIO2->dwRtpIOFlags = RtpBitPar(FGRECV_ISRED);

            /* Compute just the parametes in the buffer descriptor
             * needed to determine if this redundant block needs to be
             * posted or not */
            
            pRtpRecvIO2->dwExtSeq = pRtpRecvIO->dwExtSeq -
                (dwTimeStampOffset / pRtpNetRState->dwRecvSamplesPerPacket);

            pRtpRecvIO2->dPostTime -=
                ((double)dwTimeStampOffset/pRtpNetRState->dwRecvSamplingFreq);

            if (!dwBlockSize)
            {
                /* Discard redundant blocks with size 0 */
                pRtpRecvIO2->dwError = RTPERR_PACKETDROPPED;

                RtpBitSet2(pRtpRecvIO2->dwRtpIOFlags,
                           FGRECV_DROPPED, FGRECV_OBSOLETE);

                goto dropit;
            }
                    
            /* Verify the PT carried in the redundant block is known,
             * otherwise drop it */
            pRtpRecvIO2->bPT_Block = pRtpRedHdr->pt;

            /* If this block's PT is different from the one we are
             * currently receiving, find out if it is a known one */
            if ( (pRtpRecvIO2->bPT_Block != pRtpNetRState->dwPt) &&
                 !RtpLookupPT(pRtpAddr, pRtpRecvIO2->bPT_Block) )
            {
                pRtpRecvIO2->dwError = RTPERR_NOTFOUND;

                RtpBitSet2(pRtpRecvIO2->dwRtpIOFlags,
                           FGRECV_DROPPED, FGRECV_BADPT);

                goto dropit;
            }
                
            /* If packet is in sequence, or its post time is close or
             * has passed, post it immediatly, otherwise, schedule it
             * to be posted later or drop it if it contains obsolete
             * data (dwError is set). */
            bPostNow = RtpReadyToPost(pRtpAddr, pRtpUser, pRtpRecvIO2);
    
            if (pRtpRecvIO2->dwError)
            {
                goto dropit;
            }

            /* This redundant block will need to be consumed
             * (i.e. will replace a lost main block, compute remainnig
             * fields in the buffer descriptor */
            pRtpRecvIO2->wSeq = (WORD)(pRtpRecvIO2->dwExtSeq & 0xffff);

            pRtpRecvIO2->dwTimeStamp =
                pRtpRecvIO->dwTimeStamp - dwTimeStampOffset;
            
            pRtpRecvIO2->lHdrSize +=
                pRtpRecvIO2->lRedHdrSize + dwDataOffset;

            pRtpRecvIO2->dwTransfered =
                pRtpRecvIO2->lHdrSize + dwBlockSize;

            pRtpRecvIO2->dPlayTime -=
                ((double)dwTimeStampOffset /
                 pRtpNetRState->dwRecvSamplingFreq);
            
            if (bPostNow)
            {
                /* Post buffer to user layer (e.g. DShow) */
                RtpPostUserBuffer(pRtpAddr,
                                  pRtpUser,
                                  pRtpRecvIO2,
                                  pRtpHdr);
                
                lPosted++;
            }
            else
            {
                RtpScheduleToPost(pRtpAddr, pRtpRecvIO2);
            }

            if (RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSRECVON) &&
                !RtpBitTest(pRtpAddr->dwAddrFlagsR, FGADDRR_QOSREDRECV))
            {
                /* QOS in the receiver is enabled but we haven't
                 * updated the reservation to include the redundancy,
                 * update it now. Set the following flag first as it
                 * is used to let QOS know that redundancy is used and
                 * the flowspec needs to be set accordingly */
                RtpBitSet(pRtpAddr->dwAddrFlagsR, FGADDRR_QOSREDRECV);

                RtpBitSet(pRtpAddr->dwAddrFlagsR, FGADDRR_UPDATEQOS);
            }
            
            dwDataOffset += dwBlockSize;
            
            continue;

        dropit:
            TraceDebugAdvanced((
                    0, GROUP_RTP, S_RTP_PERPKTSTAT5,
                    _T("%s:  pRtpAddr[0x%p] pRtpUser[0x%p] ")
                    _T("pRtpRecvIO[0x%p]: ")
                    _T("p %c%c PT:%u m:%u seq:%u ts:%u post:%0.3f/%+0.3f ")
                    _T("error:0x%X flags:0x%08X"),
                    _fname, pRtpAddr, pRtpRecvIO2->pRtpUser, pRtpRecvIO2,
                    _T('R'), _T('-'),
                    pRtpRecvIO2->bPT_Block, pRtpHdr->m,
                    pRtpRecvIO2->dwExtSeq,
                    pRtpRecvIO2->dwTimeStamp,
                    pRtpRecvIO2->dPostTime,
                    pRtpRecvIO2->dPostTime -
                    RtpGetTimeOfDay((RtpTime_t *)NULL),
                    pRtpRecvIO2->dwError,
                    pRtpRecvIO2->dwRtpIOFlags
                    ));
            
            /* Return structure to Free pool */
            RtpRecvIOPutFree(pRtpAddr, pRtpRecvIO2);
            
            dwDataOffset += dwBlockSize;
        }
    }

    /* Now process main data */

    /* Modify headers to reflect a bigger header plus main data */
    pRtpRecvIO->lHdrSize +=
        pRtpRecvIO->lRedHdrSize + pRtpRecvIO->lRedDataSize;

    bPostNow = RtpReadyToPost(pRtpAddr, pRtpUser, pRtpRecvIO);
    
    if (bPostNow)
    {
        /* Post buffer to user layer (e.g. DShow) */
        RtpPostUserBuffer(pRtpAddr,
                          pRtpUser,
                          pRtpRecvIO,
                          pRtpHdr);

        lPosted++;
    }
    else
    {
        RtpScheduleToPost(pRtpAddr, pRtpRecvIO);
    }

    if ((pRtpUser->lPendingPackets > 0) && (lPosted > 0))
    {
        /* We posted at least 1 buffer, if we had pending buffers
         * waiting for it, they may be postable now, check it now */
        RtpCheckReadyToPostOnRecv(pRtpAddr, pRtpUser);
    }

    /* Check if the flowspec needs to be updated */
    if (RtpBitTest(pRtpAddr->dwAddrFlagsR, FGADDRR_UPDATEQOS))
    {
        if (pRtpAddr->pRtpQosReserve->ReserveFlags.RecvFrameSizeValid)
        {
            /* Redo the reservation until we have detected the
             * samples/packet, otherwise that will have to be done
             * again a few packets later */
            RtpBitReset(pRtpAddr->dwAddrFlagsR, FGADDRR_UPDATEQOS);

            /* Adjust first the flowspec to take into account a
             * possible new frame size or redundancy */
            RtpSetQosFlowSpec(pRtpAddr, RECV_IDX);
            
            /* Either we started getting redundancy or the PT being
             * received has changed and need to redo a new reservation */
            RtcpThreadCmd(&g_RtcpContext,
                          pRtpAddr,
                          RTCPTHRD_RESERVE,
                          RECV_IDX,
                          DO_NOT_WAIT);
        }
    }

    
    return(pRtpRecvIO->dwError);
}

DWORD RtpPostUserBuffer(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        RtpRecvIO_t     *pRtpRecvIO,
        RtpHdr_t        *pRtpHdr
    )
{
    DWORD            dwError;
    DWORD            dwTransfered;
    DWORD            dwFlags;
    double           dPlayTime;
    long             lHdrSize;
    void            *pvUserInfo1;
    void            *pvUserInfo2;
    void            *pvUserInfo3;
    RtpOutput_t     *pRtpOutput;
    RtpNetRState_t  *pRtpNetRState;
    RtpRecvIO_t     *pRtpRecvIO2;
    double           dFrameSize;
    
    TraceFunctionName("RtpPostUserBuffer");  

    pvUserInfo1 = pRtpRecvIO->pvUserInfo1;
    pvUserInfo2 = pRtpRecvIO->pvUserInfo2;
    pvUserInfo3 = NULL;
    
    if (!pRtpRecvIO->dwError && pRtpUser)
    {
        pRtpNetRState = &pRtpUser->RtpNetRState;
        
        if (!RtpBitTest(pRtpUser->dwUserFlags2, FGUSER2_MUTED))
        {
            /* If this user is not muted, see if there is an output
             * assigned and if not try to assign one */
        
            pRtpOutput = pRtpUser->pRtpOutput;

            if (!pRtpOutput)
            {
                /* No output assigned yet */
                            
                pRtpOutput = RtpGetOutput(pRtpAddr, pRtpUser);
            }
                        
            if (pRtpOutput)
            {
                /* User is (or was just) mapped */
                            
                /* Parameter used later for user function */
                pvUserInfo3 = pRtpOutput->pvUserInfo;
            }
        }

        if (((pRtpNetRState->red_max_seq + 1) != pRtpRecvIO->dwExtSeq) &&
            (RtpGetClass(pRtpAddr->dwIRtpFlags) == RTPCLASS_AUDIO))
        {
            /* I will use the packet duplication technique to recover
             * a single loss only if the audio frame size is smaller
             * than a certain value. This restriction is needed
             * because big frame sizes are more noticeable and can be
             * annoying */
            dFrameSize =
                (double) pRtpNetRState->dwRecvSamplesPerPacket /
                pRtpNetRState->dwRecvSamplingFreq;

            if (!RtpBitTest2(pRtpRecvIO->dwRtpIOFlags,
                             FGRECV_MARKER, FGRECV_HOLD) &&
                (dFrameSize < RTP_MAXFRAMESIZE_PACKETDUP))
            {
                /* If this buffer is not the one expected, that means
                 * there was a gap (at least 1 packet lost), and if this
                 * is audio and this packet was not the begining of a
                 * talkspurt, nor already a recursive call, then I will
                 * post this same buffer (with some fields updated) twice
                 * to implement a receiver only technique to recover from
                 * single losses by playing twice the same frame */
            
                pRtpRecvIO2 = RtpRecvIOGetFree2(pRtpAddr, pRtpRecvIO);

                if (pRtpRecvIO2)
                {
                    /* Update this to be the previous buffer */

                    pRtpRecvIO2->dwExtSeq--;

                    pRtpRecvIO2->dwTimeStamp -=
                        pRtpNetRState->dwRecvSamplesPerPacket;

                    pRtpRecvIO2->dPlayTime -= dFrameSize;
                
                    pRtpRecvIO2->dPostTime -= dFrameSize;
                
                    RtpBitSet(pRtpRecvIO2->dwRtpIOFlags, FGRECV_HOLD);
                    
                    RtpPostUserBuffer(pRtpAddr,pRtpUser,pRtpRecvIO2,pRtpHdr);
                }
            }
        }
        
        pRtpNetRState->red_received++;

        pRtpNetRState->red_max_seq = pRtpRecvIO->dwExtSeq;
    }

    if (RtpBitTest(pRtpRecvIO->dwRtpIOFlags, FGRECV_MARKER))
    {
        pRtpHdr->m = 1;
    }
    else
    {
        pRtpHdr->m = 0;
    }

    /* This logs all the packets */
    TraceDebugAdvanced((
            0, GROUP_RTP, S_RTP_PERPKTSTAT5,
            _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] pRtpRecvIO[0x%p]: ")
            _T("p %c%c PT:%u m:%u seq:%u ts:%u post:%0.3f/%+0.3f ")
            _T("error:0x%X flags:0x%08X"),
            _fname, pRtpAddr, pRtpRecvIO->pRtpUser, pRtpRecvIO,
            RtpBitTest(pRtpRecvIO->dwRtpIOFlags, FGRECV_HOLD)?
            _T('D') /* A double packet */ :
            RtpBitTest(pRtpRecvIO->dwRtpIOFlags, FGRECV_MAIN)?
            _T('M') /* Main data */ : _T('R') /* Redundancy */,
            pRtpRecvIO->dwError ?
            _T('-') /* Not consumed */ : _T('+') /* Consumed */,
            pRtpRecvIO->bPT_Block, pRtpHdr->m,
            pRtpRecvIO->dwExtSeq,
            pRtpRecvIO->dwTimeStamp,
            pRtpRecvIO->dPostTime,
            pRtpRecvIO->dPostTime - RtpGetTimeOfDay((RtpTime_t *)NULL),
            pRtpRecvIO->dwError,
            pRtpRecvIO->dwRtpIOFlags
        ));

    pRtpHdr->pt  = pRtpRecvIO->bPT_Block;
    pRtpHdr->seq = htons(pRtpRecvIO->wSeq);
    pRtpHdr->ts  = htonl(pRtpRecvIO->dwTimeStamp);

    dwError      = pRtpRecvIO->dwError;
    dwTransfered = pRtpRecvIO->dwTransfered;
    dwFlags      = pRtpRecvIO->dwRtpIOFlags;
    lHdrSize     = pRtpRecvIO->lHdrSize;
    dPlayTime    = pRtpRecvIO->dPlayTime;


    /* Return structure to Free pool */
    RtpRecvIOPutFree(pRtpAddr, pRtpRecvIO);
    
    /* Call user function even on error, needed for the user to take
     * back its buffer (e.g. for DShow filter to Release the sample)
     * */
    pRtpAddr->pRtpRecvCompletionFunc(pvUserInfo1,
                                     pvUserInfo2,
                                     pvUserInfo3,
                                     pRtpUser,
                                     dPlayTime,
                                     dwError,
                                     lHdrSize,
                                     dwTransfered,
                                     dwFlags);

    return(NOERROR);
}

BOOL RtpPostOldest(
        RtpAddr_t       *pRtpAddr
    )
{
    BOOL             bMainPosted;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpRecvIO_t     *pRtpRecvIO;
    RtpUser_t       *pRtpUser;
    RtpNetRState_t  *pRtpNetRState;

    TraceFunctionName("RtpPostOldest");

    bMainPosted = FALSE;

    do {
        pRtpQueueItem =
            dequeuef(&pRtpAddr->RecvIOWaitRedQ, &pRtpAddr->RecvQueueCritSect);

        if (pRtpQueueItem)
        {
            pRtpRecvIO =
                CONTAINING_RECORD(pRtpQueueItem, RtpRecvIO_t, RtpRecvIOQItem);

            pRtpUser = pRtpRecvIO->pRtpUser;

            pRtpUser->lPendingPackets--;

            if (RtpBitTest(pRtpRecvIO->dwRtpIOFlags, FGRECV_MAIN) &&
                !RtpBitTest(pRtpRecvIO->dwRtpIOFlags, FGRECV_HOLD))
            {
                /* Set this boolean only if by posting it another IO
                 * will be started, i.e. it is a main block that is
                 * not being duplicated */
                bMainPosted = TRUE;
            }

            TraceDebug((
                    CLASS_WARNING, GROUP_RTP, S_RTP_RECV,
                    _T("%s: pRtpAddr[0x%p] pRtpRecvIO[0x%p] seq:%u ")
                    _T("forcefully posted, may be ahead of time"),
                    _fname, pRtpAddr, pRtpRecvIO,
                    pRtpRecvIO->dwExtSeq
                ));

            pRtpNetRState = &pRtpUser->RtpNetRState;
            
            /* Check if this is in fact a block (typically redundancy)
             * that needs to be discarded */
            if ((pRtpNetRState->red_max_seq + 1) != pRtpRecvIO->dwExtSeq)
            {
                if (pRtpRecvIO->dwExtSeq <= pRtpNetRState->red_max_seq)
                {
                    /* Old packet (typically an unused redundant
                     * block, unused because we got the main block),
                     * discard it */
                    pRtpRecvIO->dwError = RTPERR_PACKETDROPPED;

                    RtpBitSet2(pRtpRecvIO->dwRtpIOFlags,
                               FGRECV_DROPPED, FGRECV_OBSOLETE);
                }
            }
            
            /* Post buffer to user layer (e.g. DShow) */
            RtpPostUserBuffer(pRtpAddr,
                              pRtpUser,
                              pRtpRecvIO,
                              (RtpHdr_t *)pRtpRecvIO->WSABuf.buf);

            /* now check if other buffers became postable after this
             * one was forced to be posted */
            RtpCheckReadyToPostOnRecv(pRtpAddr, pRtpUser);
        }
    } while(pRtpQueueItem && !bMainPosted);

    if (!bMainPosted)
    {
        TraceRetail((
                CLASS_WARNING, GROUP_RTP, S_RTP_RECV,
                _T("%s: pRtpAddr[0x%p] couldn't post any main buffer ")
                _T("there might not be I/O for some time"),
                _fname, pRtpAddr
            ));
    }
   
    return(bMainPosted);
}
        
/* Test if a buffer is ready to post immediatly */
BOOL RtpReadyToPost(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser,
        RtpRecvIO_t     *pRtpRecvIO
    )
{
    BOOL             bPostNow;
    double           dCurTime;
    double           dDiff;
    RtpNetRState_t  *pRtpNetRState;
    
    TraceFunctionName("RtpReadyToPost");  

    bPostNow = TRUE;
            
    dCurTime = RtpGetTimeOfDay((RtpTime_t *)NULL);

    pRtpNetRState = &pRtpRecvIO->pRtpUser->RtpNetRState;

    /* Decide if this buffer is in sequence */
    if ((pRtpNetRState->red_max_seq + 1) != pRtpRecvIO->dwExtSeq)
    {
        /* Decide if this buffer is a duplicate or outdated packet, or
         * if it is and out of order packet (a packet that is ahead of
         * one or more yet to come) */
        if (pRtpRecvIO->dwExtSeq <= pRtpNetRState->red_max_seq)
        {
            /* Old packet (typically an unused redundant block, unused
             * because we got the main block), discard it */
            pRtpRecvIO->dwError = RTPERR_PACKETDROPPED;

            RtpBitSet2(pRtpRecvIO->dwRtpIOFlags,
                       FGRECV_DROPPED, FGRECV_OBSOLETE);
        }
        else
        {
            /* Out of sequence (ahead), we may need to wait for the
             * redundancy to arrive and fill the gap, -or- if not
             * using redundancy,we may need to wait to avoid letting
             * the gap be closed at the consumer (e.g. DShow audio
             * render filter) */
            dDiff = pRtpRecvIO->dPostTime - dCurTime;
            
            if (dDiff > g_dRtpRedEarlyPost)
            {
                /* The time to post this packet hasn't come yet,
                 * before deciding to schedule for later, make sure
                 * there is going to be at least 1 pending I/O so I
                 * can continue receiving packets */
                if (IsQueueEmpty(&pRtpAddr->RecvIOPendingQ) &&
                    IsQueueEmpty(&pRtpAddr->RecvIOReadyQ))
                {
                    /* Post the oldest one (the one closer to be
                     * posted) */
                    RtpPostOldest(pRtpAddr);
                }
                
                bPostNow = FALSE;
            }
            else
            {
                /* The time to post this packet has come, post
                 * right away */
            }
        }
    }
    else
    {
        /* In sequence, post right away */
    }

    return(bPostNow);
}

/* Schedule a buffer to be posted later */
DWORD RtpScheduleToPost(
        RtpAddr_t       *pRtpAddr,
        RtpRecvIO_t     *pRtpRecvIO
    )
{
    RtpQueueItem_t  *pRtpQueueItem;
    
    TraceFunctionName("RtpScheduleToPost");  

    pRtpQueueItem = enqueuedK(&pRtpAddr->RecvIOWaitRedQ,
                              &pRtpAddr->RecvQueueCritSect,
                              &pRtpRecvIO->RtpRecvIOQItem,
                              pRtpRecvIO->dPostTime);

    if (pRtpQueueItem)
    {
        /* A double frame to do receiver only packet reconstruction
         * will never be scheduled, so don't bother about that in the
         * logs */
        TraceDebugAdvanced((
                0, GROUP_RTP, S_RTP_PERPKTSTAT5,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] pRtpRecvIO[0x%p]: ")
                _T("s %c%c PT:%u m:%u seq:%u ts:%u post:%0.3f/%+0.3f"),
                _fname, pRtpAddr, pRtpRecvIO->pRtpUser, pRtpRecvIO,
                RtpBitTest(pRtpRecvIO->dwRtpIOFlags, FGRECV_MAIN)?
                _T('M'):_T('R'),
                pRtpRecvIO->dwError ? _T('-'):_T('+'),
                pRtpRecvIO->bPT_Block,
                RtpBitTest(pRtpRecvIO->dwRtpIOFlags, FGRECV_MARKER)? 1:0,
                pRtpRecvIO->dwExtSeq,
                pRtpRecvIO->dwTimeStamp,
                pRtpRecvIO->dPostTime,
                pRtpRecvIO->dPostTime - RtpGetTimeOfDay(NULL)
            ));
        
        pRtpRecvIO->pRtpUser->lPendingPackets++;
        
        return(NOERROR);
    }

    /* If failed, this buffer still needs to be posted */

    TraceRetail((
            CLASS_WARNING, GROUP_RTP, S_RTP_PERPKTSTAT5,
            _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] pRtpRecvIO[0x%p]: ")
            _T("s %c%c PT:%u m:%u seq:%u ts:%u NOT scheduled, dropped"),
            _fname, pRtpAddr, pRtpRecvIO->pRtpUser, pRtpRecvIO,
            RtpBitTest(pRtpRecvIO->dwRtpIOFlags, FGRECV_MAIN)?
            _T('M'):_T('R'),
            pRtpRecvIO->dwError ? _T('-'):_T('+'),
            pRtpRecvIO->bPT_Block,
            RtpBitTest(pRtpRecvIO->dwRtpIOFlags, FGRECV_MARKER)? 1:0,
            pRtpRecvIO->dwExtSeq,
            pRtpRecvIO->dwTimeStamp
        ));

    /* Post with error */
    pRtpRecvIO->dwError = RTPERR_QUEUE;

    RtpBitSet2(pRtpRecvIO->dwRtpIOFlags, FGRECV_ERROR, FGRECV_FAILSCHED);

    /* Post buffer to user layer (e.g. DShow) */
    RtpPostUserBuffer(pRtpAddr,
                      (RtpUser_t *)NULL,
                      pRtpRecvIO,
                      (RtpHdr_t *)pRtpRecvIO->WSABuf.buf);
     
    return(RTPERR_QUEUE);
}

/* Return the time to wait before a  */
DWORD RtpCheckReadyToPostOnTimeout(
        RtpAddr_t       *pRtpAddr
    )
{
    DWORD            dwWaitTime;
    double           dCurTime;
    double           dDiff;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpRecvIO_t     *pRtpRecvIO;

    TraceFunctionName("RtpCheckReadyToPostOnTimeout");  

    dwWaitTime = INFINITE;
    
    while( (pRtpQueueItem = pRtpAddr->RecvIOWaitRedQ.pFirst) )
    {
        dCurTime = RtpGetTimeOfDay((RtpTime_t *)NULL);
    
        dDiff = pRtpQueueItem->dKey - dCurTime;

        if (dDiff < g_dRtpRedEarlyPost)
        {
            /* At least one block for this user needs to be posted */
            pRtpRecvIO =
                CONTAINING_RECORD(pRtpQueueItem, RtpRecvIO_t, RtpRecvIOQItem);

            RtpCheckReadyToPostOnRecv(pRtpAddr, pRtpRecvIO->pRtpUser);
        }
        else
        {
            /* Stop right after finding the first buffer that is not
             * ready to post */
            break;
        }
    }

    pRtpQueueItem = pRtpAddr->RecvIOWaitRedQ.pFirst;

    if (pRtpQueueItem)
    {
        dCurTime = RtpGetTimeOfDay((RtpTime_t *)NULL);

        dDiff = pRtpQueueItem->dKey - dCurTime;

        if (dDiff < g_dRtpRedEarlyPost)
        {
            dwWaitTime = 0;

            TraceRetail((
                    CLASS_WARNING, GROUP_RTP, S_RTP_RECV,
                    _T("%s: pRtpAddr[0x%p] post time has passed:%1.0fms"),
                    _fname, pRtpAddr, dDiff * 1000
                ));
        }
        else
        {
            /* Decrease the timeout value */
            dwWaitTime = (DWORD) ((dDiff - g_dRtpRedEarlyTimeout) * 1000);

            pRtpRecvIO =
                CONTAINING_RECORD(pRtpQueueItem, RtpRecvIO_t, RtpRecvIOQItem);

            if (dwWaitTime > (MAX_PLAYOUT * RTP_RED_MAXDISTANCE))
            {
                TraceRetail((
                        CLASS_WARNING, GROUP_RTP, S_RTP_RECV,
                        _T("%s: pRtpAddr[0x%p] pRtpRecvIO[0x%p] ")
                        _T("post:%0.3f/%+0.3f wait time too big:%ums"),
                        _fname, pRtpAddr, pRtpRecvIO,
                        pRtpRecvIO->dPostTime, dDiff, dwWaitTime
                    ));

                dwWaitTime = MAX_PLAYOUT * RTP_RED_MAXDISTANCE;
            }
            else
            {
                TraceDebug((
                        CLASS_INFO, GROUP_RTP, S_RTP_RECV,
                        _T("%s: pRtpAddr[0x%p] pRtpRecvIO[0x%p] ")
                        _T("post:%0.3f/%+0.3f wait time %ums"),
                        _fname, pRtpAddr, pRtpRecvIO,
                        pRtpRecvIO->dPostTime, dDiff, dwWaitTime
                    ));
            }
        }
    }
    
    return(dwWaitTime);
}

/* NOTE that there might be in the stack a recursive call with depth 2
 * (no recursion being depth 1); RtpCheckReadyToPostOnRecv will call
 * RtpReadyToPost, which in turn may call RtpPostOldest (this
 * function), which will call again RtpCheckReadyToPostOnRecv, the
 * latter will call again RtpReadyToPost but will never call again
 * RtpPostOldest (the recursion stops there). In unicast, the
 * recursion will be for the same RtpUser_t and could be optimized,
 * but in multicast, that could be a different one. Also, the first
 * call to RtpCheckReadyToPostOnRecv will start visiting the items in
 * RecvIOWaitRedQ, and when the recursion occurs, it will not continue
 * because when RtpPostOldest is called (situation on which the
 * recursion happens) that loop will be terminated, and will be
 * completely started in the second call to RtpCheckReadyToPostOnRecv
 * */

/* Check all the pending buffers (those that were scheduled to be
 * posted later) to find out which ones, among those belonging to this
 * user, are ready to post at this moment */
DWORD RtpCheckReadyToPostOnRecv(
        RtpAddr_t       *pRtpAddr,
        RtpUser_t       *pRtpUser
    )
{
    BOOL             bPostNow;
    long             lCount;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpRecvIO_t     *pRtpRecvIO;
    
    TraceFunctionName("RtpCheckReadyToPostOnRecv");  

    for(lCount = GetQueueSize(&pRtpAddr->RecvIOWaitRedQ),
            pRtpQueueItem = pRtpAddr->RecvIOWaitRedQ.pFirst;
        lCount > 0 && pRtpQueueItem;
        lCount--)
    {
        pRtpRecvIO =
            CONTAINING_RECORD(pRtpQueueItem, RtpRecvIO_t, RtpRecvIOQItem);

        pRtpQueueItem = pRtpQueueItem->pNext;

        if (pRtpRecvIO->pRtpUser == pRtpUser)
        {
            bPostNow = RtpReadyToPost(pRtpAddr, pRtpUser, pRtpRecvIO);
    
            if (bPostNow)
            {
                dequeue(&pRtpAddr->RecvIOWaitRedQ,
                        &pRtpAddr->RecvQueueCritSect,
                        &pRtpRecvIO->RtpRecvIOQItem);

                pRtpUser->lPendingPackets--;
            
                /* Post buffer to user layer (e.g. DShow) */
                RtpPostUserBuffer(pRtpAddr,
                                  pRtpRecvIO->pRtpUser,
                                  pRtpRecvIO,
                                  (RtpHdr_t *)pRtpRecvIO->WSABuf.buf);
            }
            else
            {
                /* I'm checking only buffers pending to be posted to
                 * this user, if one is not ready, then none of those
                 * (if any) that follow it will be, so stop now
                 * */
                break;
            }
        }
    }

    return(NOERROR);
}

/* Call callback function to release all pending buffers when the
 * RTP recv thread is about to exit */
DWORD FlushRtpRecvFrom(RtpAddr_t *pRtpAddr)
{
    RtpRecvIO_t     *pRtpRecvIO;
    RtpQueue_t      *pQueue[2];
    RtpQueueItem_t  *pRtpQueueItem;
    DWORD            i;
    DWORD            dwConsumed;

    TraceFunctionName("FlushRtpRecvFrom");

    pQueue[0] = &pRtpAddr->RecvIOPendingQ;
    pQueue[1] = &pRtpAddr->RecvIOWaitRedQ;
    
    for(dwConsumed = 0, i = 0; i < 2; i++)
    {
        do
        {
            pRtpQueueItem = dequeuef(pQueue[i], &pRtpAddr->RecvQueueCritSect);
        
            if (pRtpQueueItem)
            {
                pRtpRecvIO = CONTAINING_RECORD(pRtpQueueItem,
                                               RtpRecvIO_t,
                                               RtpRecvIOQItem);
                
                pRtpRecvIO->dwError = WSA_OPERATION_ABORTED;
                pRtpRecvIO->dwTransfered = 0;
                RtpBitSet2(pRtpRecvIO->dwRtpIOFlags,
                           FGRECV_DROPPED, FGRECV_SHUTDOWN);

                if (pRtpRecvIO->pRtpUser)
                {
                    /* Only buffers in RecvIOWaitRedQ have a user
                     * associated, the pending ones (in
                     * RecvIOPendingQ) do not */
                    pRtpRecvIO->pRtpUser->lPendingPackets--;
                }
                
                /* Call user function even on error, needed for upper
                 * layer to release resources (e.g. DShow filter to
                 * Release the sample) */
                RtpPostUserBuffer(pRtpAddr,
                                  (RtpUser_t *)NULL,
                                  pRtpRecvIO,
                                  (RtpHdr_t *)pRtpRecvIO->WSABuf.buf);
                
                dwConsumed++;
            }
        } while (pRtpQueueItem);
    }

    if (dwConsumed > 0)
    {
        TraceRetail((
                CLASS_INFO, GROUP_RTP, S_RTP_RECV,
                _T("%s: pRtpAddr[0x%p] RtpRecvIO_t flushed:%u"),
                _fname, pRtpAddr, dwConsumed
            ));
    }

    return(dwConsumed);
}

/* Call the callback function to release all the waiting bufferes
 * belonging to the specific user when he is being deleted */
DWORD FlushRtpRecvUser(RtpAddr_t *pRtpAddr, RtpUser_t *pRtpUser)
{
    long             lCount;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpRecvIO_t     *pRtpRecvIO;
    DWORD            dwConsumed;
    
    TraceFunctionName("FlushRtpRecvUser");  

    dwConsumed = 0;
    
    for(lCount = GetQueueSize(&pRtpAddr->RecvIOWaitRedQ),
            pRtpQueueItem = pRtpAddr->RecvIOWaitRedQ.pFirst;
        lCount > 0 && pRtpQueueItem;
        lCount--)
    {
        pRtpRecvIO =
            CONTAINING_RECORD(pRtpQueueItem, RtpRecvIO_t, RtpRecvIOQItem);

        pRtpQueueItem = pRtpQueueItem->pNext;

        if (pRtpRecvIO->pRtpUser == pRtpUser)
        {
            dequeue(&pRtpAddr->RecvIOWaitRedQ,
                    &pRtpAddr->RecvQueueCritSect,
                    &pRtpRecvIO->RtpRecvIOQItem);

            pRtpUser->lPendingPackets--;

            pRtpRecvIO->dwError = RTPERR_PACKETDROPPED;

            pRtpRecvIO->dwTransfered = 0;

            RtpBitSet2(pRtpRecvIO->dwRtpIOFlags,
                       FGRECV_DROPPED, FGRECV_USERGONE);

            /* Post buffer to user layer (e.g. DShow) */
            RtpPostUserBuffer(pRtpAddr,
                              pRtpRecvIO->pRtpUser,
                              pRtpRecvIO,
                              (RtpHdr_t *)pRtpRecvIO->WSABuf.buf);

            dwConsumed++;
        }
    }

    if (dwConsumed > 0)
    {
        TraceRetail((
                CLASS_INFO, GROUP_RTP, S_RTP_RECV,
                _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] RtpRecvIO_t flushed:%u"),
                _fname, pRtpAddr, pRtpUser, dwConsumed
            ));
    }
    
    return(NOERROR);
}

/* Validate an RTP packet, decrypt if needed */
DWORD RtpValidatePacket(RtpAddr_t *pRtpAddr, RtpRecvIO_t *pRtpRecvIO)
{
    RtpHdr_t        *pRtpHdr;
    RtpHdrExt_t     *pRtpHdrExt;
    RtpRedHdr_t     *pRtpRedHdr;
    char            *hdr;
    RtpCrypt_t      *pRtpCrypt;
    long             lHdrSize;
    int              len;
    int              pad;
    BOOL             bDecryptPayload;
    DWORD            dwDataLen; /* used for decryption */
    DWORD            dwTimeStampOffset; /* Redundant block's ts offset */

    TraceFunctionName("RtpValidatePacket");

    /* MAYDO update bad packets in RtpAddr, right now don't have
     * counters for bad packets, I may add a flag to RtpUpdateStats()
     * so I know if it is a valid packet, a packet too short, an
     * invalid header, etc */

    /* MAYDO may be generate event to the upper layer whenever N
     * invalid packets are received */
    
   /*
     * If encyption mode is "RTP" or "ALL", apply decryption first to
     * whole packet. Use pRtpAddr->pRtpCrypt[RECV_IDX] encryption
     * descriptor.
     *
     * An alternative is to attempt decription only if the packet
     * fails the validity check */

    pRtpCrypt = pRtpAddr->pRtpCrypt[CRYPT_RECV_IDX];
    
    bDecryptPayload = FALSE;
    
    if ( pRtpCrypt &&
         (RtpBitTest2(pRtpCrypt->dwCryptFlags, FGCRYPT_INIT, FGCRYPT_KEY) ==
          RtpBitPar2(FGCRYPT_INIT, FGCRYPT_KEY)) )
    {
        if ((pRtpAddr->dwCryptMode & 0xffff) >= RTPCRYPTMODE_RTP)
        {
            /* Decrypt whole RTP packet */

            dwDataLen = pRtpRecvIO->dwTransfered;
            
            pRtpRecvIO->dwError = RtpDecrypt(
                    pRtpAddr,
                    pRtpCrypt,
                    pRtpRecvIO->WSABuf.buf,
                    &dwDataLen
                );

            if (pRtpRecvIO->dwError != NOERROR)
            {
                if (!pRtpCrypt->CryptFlags.DecryptionError)
                {
                    /* Post an event only the first time */
                    pRtpCrypt->CryptFlags.DecryptionError = 1;
                
                    RtpPostEvent(pRtpAddr,
                                 NULL,
                                 RTPEVENTKIND_RTP,
                                 RTPRTP_CRYPT_RECV_ERROR,
                                 RTP_IDX,
                                 pRtpCrypt->dwCryptLastError);
                }

                goto bail;
            }

            /* Update dwTransfered to reflect the size after
             * decryption */
            pRtpRecvIO->dwTransfered = dwDataLen;
        }
        else
        {
            /* Decrypt only payload */
            bDecryptPayload = TRUE;
        }
    }

    lHdrSize = sizeof(RtpHdr_t);

    len = (int)pRtpRecvIO->dwTransfered;

    /*
     * Check minimal size
     * */
    if (len < lHdrSize)
    {
        /* packet too short */

        pRtpRecvIO->dwError = RTPERR_MSGSIZE;

        goto bail;
    }

     
    hdr = pRtpRecvIO->WSABuf.buf;
    pRtpHdr = (RtpHdr_t *)hdr;

    /*
     * Check version
     * */
    if (pRtpHdr->version != RTP_VERSION)
    {
        /* invalid version */

        pRtpRecvIO->dwError = RTPERR_INVALIDVERSION;
        
        goto bail;
    }

    /* Test payload type is not SR nor RR */
    if (pRtpHdr->pt >= RTCP_SR)
    {
        pRtpRecvIO->dwError = RTPERR_INVALIDPT;

        goto bail;
    }

    /*
     * Handle the contributing sources
     * */
    if (pRtpHdr->cc > 0)
    {
        /* Add to header size the CSRCs size */
        lHdrSize += (pRtpHdr->cc * sizeof(DWORD));

        /* Check minimal size again */
        if (len < lHdrSize)
        {
            /* packet too short */

            pRtpRecvIO->dwError = RTPERR_MSGSIZE;

            goto bail;
        }
    }
    
    /*
     * Handle extension bit
     * */
    if (pRtpHdr->x)
    {
        /* Extension present */

        /* Get variable header size */
        pRtpHdrExt = (RtpHdrExt_t *)(hdr + lHdrSize);

        /* Add to header size the extension size and extension header */
        lHdrSize += ((ntohs(pRtpHdrExt->length) + 1) * sizeof(DWORD));

        /* Check minimal size again */
        if (len < lHdrSize)
        {
            /* packet too short */

            pRtpRecvIO->dwError = RTPERR_MSGSIZE;

            goto bail;
        }
    }

    /* If decrypting payload only, do it now */
    if (bDecryptPayload)
    {
        dwDataLen = pRtpRecvIO->dwTransfered - (DWORD)lHdrSize;
        
        pRtpRecvIO->dwError = RtpDecrypt(
                pRtpAddr,
                pRtpCrypt,
                pRtpRecvIO->WSABuf.buf + lHdrSize,
                &dwDataLen
            );

        if (pRtpRecvIO->dwError != NOERROR)
        {
            goto bail;
        }

        /* Update dwTransfered to reflect the size after decryption */
        pRtpRecvIO->dwTransfered = dwDataLen + lHdrSize;

        len = (int)pRtpRecvIO->dwTransfered;
    }
    
    /*
     * Test padding looking at last byte of WSABUF.buf
     * */
    if (pRtpHdr->p)
    {
        pad = (int) ((DWORD) pRtpRecvIO->WSABuf.buf[len - 1]);

        if (pad > (len - lHdrSize))
        {
            pRtpRecvIO->dwError = RTPERR_INVALIDPAD;

            goto bail;
        }

        /* Remove pad */
        pRtpRecvIO->dwTransfered -= pad;
    }

    /* Save in the buffer descriptor this packet's timestamp and
     * payload type */
    pRtpRecvIO->bPT_Block   = (BYTE)pRtpHdr->pt;
    pRtpRecvIO->wSeq        = ntohs(pRtpHdr->seq);
    pRtpRecvIO->dwTimeStamp = ntohl(pRtpHdr->ts);
    if (pRtpHdr->m)
    {
        RtpBitSet(pRtpRecvIO->dwRtpIOFlags, FGRECV_MARKER);
    }

    pRtpRecvIO->lRedHdrSize = 0;
    pRtpRecvIO->lRedDataSize= 0;
    pRtpRecvIO->dwMaxTimeStampOffset = 0;
    
    /* If the packet contains redundant encoding, validate it */
    if (pRtpHdr->pt == pRtpAddr->bPT_RedRecv)
    {
        len = pRtpRecvIO->dwTransfered - lHdrSize;

        for(pRtpRedHdr = (RtpRedHdr_t *) ((char *)pRtpHdr + lHdrSize);
            pRtpRedHdr->F && len > 0;
            pRtpRedHdr++)
        {
            len -= sizeof(RtpRedHdr_t); /* Red hdr */

            len -= (int)RedLen(pRtpRedHdr);  /* Red data */

            pRtpRecvIO->lRedDataSize += (int)RedLen(pRtpRedHdr);
            pRtpRecvIO->lRedHdrSize += sizeof(RtpRedHdr_t);

            dwTimeStampOffset = RedTs(pRtpRedHdr);

            if (dwTimeStampOffset > pRtpRecvIO->dwMaxTimeStampOffset)
            {
                pRtpRecvIO->dwMaxTimeStampOffset = dwTimeStampOffset;
            }
        }
        
        /* 1 byte main hdr */
        pRtpRecvIO->lRedHdrSize++;
        len--;

        if (len < 0)
        {
            pRtpRecvIO->dwError = RTPERR_INVALIDRED;

            goto bail;
        }

        /* Update the real PT for this buffer, i.e. that of the main
         * buffer */
        pRtpRecvIO->bPT_Block = pRtpRedHdr->pt;

        /* Keep information about this main buffer also containing
         * redundancy */
        RtpBitSet(pRtpRecvIO->dwRtpIOFlags, FGRECV_HASRED);
    }
    
    pRtpRecvIO->lHdrSize = lHdrSize;

    pRtpRecvIO->dwError = NOERROR;

 bail:
    if (pRtpRecvIO->dwError != NOERROR)
    {
        TraceRetail((
                CLASS_WARNING, GROUP_RTP, S_RTP_RECV,
                _T("%s: pRtpAddr[0x%p] pRtpRecvIO[0x%p] ")
                _T("Invalid packet: %u (0x%X)"),
                _fname, pRtpAddr, pRtpRecvIO,
                pRtpRecvIO->dwError, pRtpRecvIO->dwError
            ));
    }
    
    return(pRtpRecvIO->dwError);
}

void RtpInitRSeq(RtpUser_t *pRtpUser, RtpHdr_t *pRtpHdr)
{
    WORD             seq;
    RtpNetRState_t  *pRtpNetRState;

    seq = ntohs(pRtpHdr->seq);
    pRtpNetRState = &pRtpUser->RtpNetRState;
    
    pRtpNetRState->base_seq = seq;

    pRtpNetRState->max_seq = seq;

    pRtpNetRState->bad_seq = RTP_SEQ_MOD + 1;

    pRtpNetRState->cycles = 0;

    pRtpNetRState->received = 0;

    pRtpNetRState->received_prior = 0;

    pRtpNetRState->expected_prior = 0;

    RtpForceFrameSizeDetection(pRtpUser, pRtpHdr);
    
    pRtpNetRState->red_max_seq = seq;

    pRtpNetRState->red_received = 0;

    pRtpNetRState->red_received_prior = 0;

    pRtpNetRState->red_expected_prior = 0;
}

void RtpForceFrameSizeDetection(
        RtpUser_t       *pRtpUser,
        RtpHdr_t        *pRtpHdr
    )
{
    RtpNetRState_t  *pRtpNetRState;
    
    pRtpNetRState = &pRtpUser->RtpNetRState;

    pRtpNetRState->probation = MIN_SEQUENTIAL;

    pRtpNetRState->dwRecvSamplesPerPacket = 0;

    pRtpNetRState->dwRecvMinSamplesPerPacket = 16000;

    pRtpNetRState->dwPreviousTimeStamp =
        ntohl(pRtpHdr->ts) - 16000;
}

/* Return 1 if validated, 0 otherwise
 *
 * See draft-ietf-avt-rtp-new-05.txt */
BOOL RtpUpdateRSeq(RtpUser_t *pRtpUser, RtpHdr_t *pRtpHdr)
{
    BOOL             bRet;
    BOOL             bOk;
    WORD             seq;
    WORD             udelta;
    DWORD            dwTimeStamp;
    DWORD            dwTimeStampGap;
    DWORD            dwNewFrameSize;
    RtpNetRState_t  *pRtpNetRState;
    RtpAddr_t       *pRtpAddr;
    RtpQosReserve_t *pRtpQosReserve;
    
    TraceFunctionName("RtpUpdateRSeq");

    pRtpNetRState = &pRtpUser->RtpNetRState;
    
    seq = ntohs(pRtpHdr->seq);

    udelta = seq - pRtpNetRState->max_seq;

    bRet = FALSE;
    
    bOk = RtpEnterCriticalSection(&pRtpUser->UserCritSect);
    /* If can not get the critical section, just continue, the only
     * bad effect is the posibility of the introduction of a packet
     * lost in the RTCP report if it is being generated right now for
     * this user. This would happen due to the RTCP using values from
     * max_seq and received that might not be in sync.
     * */

    /*
     * Source is not valid until MIN_SEQUENTIAL packets with
     * sequential sequence numbers have been received.
     */
    if (pRtpNetRState->probation)
    {
        /* packet is in sequence */
        if (seq == pRtpNetRState->max_seq + 1)
        {
            pRtpNetRState->max_seq = seq;
            
            dwTimeStamp = ntohl(pRtpHdr->ts);
            
            dwTimeStampGap = dwTimeStamp - pRtpNetRState->dwPreviousTimeStamp;

            pRtpNetRState->dwPreviousTimeStamp = dwTimeStamp;

            if (dwTimeStampGap < pRtpNetRState->dwRecvMinSamplesPerPacket)
            {
                pRtpNetRState->dwRecvMinSamplesPerPacket = dwTimeStampGap;
            }
                
            pRtpNetRState->probation--;
            
            if (pRtpNetRState->probation == 0)
            {
                pRtpNetRState->received += MIN_SEQUENTIAL;

                /* The number of samples per packet is considered to
                 * be minimum seen during the probation phase */
                pRtpNetRState->dwRecvSamplesPerPacket =
                    pRtpNetRState->dwRecvMinSamplesPerPacket;
                
                TraceRetail((
                        CLASS_INFO, GROUP_RTP, S_RTP_RECV,
                        _T("%s: pRtpAddr[0x%p] pRtpUser[0x%p] ")
                        _T("Receiving samples/packet:%u at %u Hz"),
                        _fname, pRtpUser->pRtpAddr, pRtpUser,
                        pRtpNetRState->dwRecvSamplesPerPacket,
                        pRtpNetRState->dwRecvSamplingFreq
                    ));

                pRtpAddr = pRtpUser->pRtpAddr;

                pRtpQosReserve = pRtpAddr->pRtpQosReserve;
                
                if (pRtpQosReserve)
                {
                    /* Update at this moment the frame size if it was
                     * unknown so the next reservation will be done
                     * with the right QOS flowspec, this might happen
                     * later when we start receiving redundancy and we
                     * pass from non redundancy use to redundancy
                     * use. Note that there is a drawback. If
                     * different participants use a different frame
                     * size, the last size will prevail and will be
                     * used for future reservations */
                    dwNewFrameSize =
                        (pRtpNetRState->dwRecvSamplesPerPacket * 1000) /
                        pRtpNetRState->dwRecvSamplingFreq;

                    /* Set the QOS update flag if the frame size has
                     * changed or we are waiting for a fresh computed
                     * frame size */
                    if ( (pRtpQosReserve->dwFrameSizeMS[RECV_IDX] !=
                          dwNewFrameSize)  ||
                         pRtpQosReserve->ReserveFlags.RecvFrameSizeWaiting )
                    {
                        /* Need to redo the reservation if QOS is ON
                         * (i.e. a flow spec has been defined) */
                        if (RtpBitTest(pRtpAddr->dwAddrFlags,
                                       FGADDR_QOSRECVON))
                        {
                            RtpBitSet(pRtpAddr->dwAddrFlagsR,
                                      FGADDRR_UPDATEQOS);
                        }

                        pRtpQosReserve->dwFrameSizeMS[RECV_IDX] =
                            dwNewFrameSize;
                        
                        pRtpQosReserve->ReserveFlags.RecvFrameSizeWaiting = 0;
                    }

                    /* Set frame size as valid */
                    pRtpQosReserve->ReserveFlags.RecvFrameSizeValid = 1;
                }

                bRet = TRUE;
                goto end;
            }
        }
        else
        {
            pRtpNetRState->probation = MIN_SEQUENTIAL - 1;
            
            pRtpNetRState->max_seq = seq;
        }
        
        goto end;
    }
    else if (udelta < MAX_DROPOUT)
    {
        /* in order, with permissible gap */
        if (seq < pRtpNetRState->max_seq)
        {
            /*
             * Sequence number wrapped - count another 64K cycle.
             */
            pRtpNetRState->cycles += RTP_SEQ_MOD;
        }
        
        pRtpNetRState->max_seq = seq;

        /* Valid */
    }
    else if (udelta <= RTP_SEQ_MOD - MAX_MISORDER)
    {
        /* the sequence number made a very large jump */
        if (seq == pRtpNetRState->bad_seq)
        {
            /*
             * Two sequential packets -- assume that the other side
             * restarted without telling us so just re-sync
             * (i.e., pretend this was the first packet).
             */
            RtpInitRSeq(pRtpUser, pRtpHdr);
        }
        else
        {
            pRtpNetRState->bad_seq = (seq + 1) & (RTP_SEQ_MOD-1);

            goto end;
        }
    }
    else
    {
        /* duplicate or reordered packet */
    }

    pRtpNetRState->received++;

    bRet = TRUE;
    
 end:
    if (bOk)
    {
        RtpLeaveCriticalSection(&pRtpUser->UserCritSect);
    }
    
    return(bRet);
}

RtpRecvIO_t *RtpRecvIOGetFree(
        RtpAddr_t       *pRtpAddr
    )
{
    RtpQueueItem_t  *pRtpQueueItem;
    RtpRecvIO_t     *pRtpRecvIO;

    pRtpRecvIO = (RtpRecvIO_t *)NULL;
    
    pRtpQueueItem = dequeuef(&pRtpAddr->RecvIOFreeQ,
                             &pRtpAddr->RecvQueueCritSect);

    if (pRtpQueueItem)
    {
        pRtpRecvIO =
            CONTAINING_RECORD(pRtpQueueItem, RtpRecvIO_t, RtpRecvIOQItem);
    }
    else
    {
        pRtpRecvIO = (RtpRecvIO_t *)
            RtpHeapAlloc(g_pRtpRecvIOHeap, sizeof(RtpRecvIO_t));
    }

    if (pRtpRecvIO)
    {
        ZeroMemory(pRtpRecvIO, sizeof(RtpRecvIO_t));
    }

    return(pRtpRecvIO);
}

RtpRecvIO_t *RtpRecvIOGetFree2(
        RtpAddr_t       *pRtpAddr,
        RtpRecvIO_t     *pRtpRecvIO
    )
{
    RtpQueueItem_t  *pRtpQueueItem;
    RtpRecvIO_t     *pRtpRecvIO2;

    pRtpRecvIO2 = (RtpRecvIO_t *)NULL;
    
    pRtpQueueItem = dequeuef(&pRtpAddr->RecvIOFreeQ,
                             &pRtpAddr->RecvQueueCritSect);

    if (pRtpQueueItem)
    {
        pRtpRecvIO2 =
            CONTAINING_RECORD(pRtpQueueItem, RtpRecvIO_t, RtpRecvIOQItem);
    }
    else
    {
        pRtpRecvIO2 = (RtpRecvIO_t *)
            RtpHeapAlloc(g_pRtpRecvIOHeap, sizeof(RtpRecvIO_t));
    }

    if (pRtpRecvIO2)
    {
        CopyMemory(pRtpRecvIO2,
                   pRtpRecvIO,
                   sizeof(RtpRecvIO_t) - sizeof(pRtpRecvIO->Overlapped));

        ZeroMemory(&pRtpRecvIO2->Overlapped, sizeof(pRtpRecvIO2->Overlapped));
    }

    return(pRtpRecvIO2);
}

RtpRecvIO_t *RtpRecvIOPutFree(
        RtpAddr_t       *pRtpAddr,
        RtpRecvIO_t     *pRtpRecvIO
    )
{
    INVALIDATE_OBJECTID(pRtpRecvIO->dwObjectID);

#if 0
    if (IsSetDebugOption(OPTDBG_FREEMEMORY))
    {
        if (RtpHeapFree(g_pRtpRecvIOHeap, pRtpRecvIO))
        {
            return(pRtpRecvIO);
        }
    }
    else
#endif
    {
        if (enqueuef(&pRtpAddr->RecvIOFreeQ,
                     &pRtpAddr->RecvQueueCritSect,
                     &pRtpRecvIO->RtpRecvIOQItem))
        {
            return(pRtpRecvIO);
        }
    }

    return((RtpRecvIO_t *)NULL);
}

void RtpRecvIOFreeAll(RtpAddr_t *pRtpAddr)
{
    RtpQueueItem_t  *pRtpQueueItem;
    RtpRecvIO_t     *pRtpRecvIO;
    
    do
    {
        pRtpQueueItem = dequeuef(&pRtpAddr->RecvIOFreeQ,
                                 &pRtpAddr->RecvQueueCritSect);

        if (pRtpQueueItem)
        {
            pRtpRecvIO =
                CONTAINING_RECORD(pRtpQueueItem, RtpRecvIO_t, RtpRecvIOQItem);

            /* Invalidate object */
            INVALIDATE_OBJECTID(pRtpRecvIO->dwObjectID);
            
            RtpHeapFree(g_pRtpRecvIOHeap, pRtpRecvIO);
        }
    } while(pRtpQueueItem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\msrtp\rtp\rtpstart.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    rtpstart.c
 *
 *  Abstract:
 *
 *    Start/Stop RTP session (and allits addresses)
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    1999/06/24 created
 *
 **********************************************************************/

#include "struct.h"

#include "rtpthrd.h"
#include "rtcpthrd.h"

#include <ws2tcpip.h>

#include "rtpaddr.h"
#include "rtpqos.h"
#include "rtpuser.h"
#include "rtpncnt.h"
#include "rtpcrypt.h"
#include "rtpreg.h"
#include "rtpmisc.h"
#include "rtpglobs.h"
#include "rtpdemux.h"
#include "rtcpband.h"

#include "rtpstart.h"
HRESULT RtpRealStart(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwFlags
    );

HRESULT RtpRealStop(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwFlags
    );

void RtpSetFromRegistry(RtpAddr_t *pRtpAddr, DWORD dwFlags);


HRESULT RtpStart_(
        RtpSess_t       *pRtpSess,
        DWORD            dwFlags
    )
{
    HRESULT          hr;
    BOOL             bOk;
    BOOL             bDoStart;
    DWORD            dwRecvSend;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpAddr_t       *pRtpAddr;

    TraceFunctionName("RtpStart_");

    dwRecvSend = RtpBitTest(dwFlags, FGADDR_ISRECV)? RECV_IDX : SEND_IDX;
    
    bOk = FALSE;
    
    TraceRetail((
            CLASS_INFO, GROUP_RTP, S_RTP_TRACE,
            _T("%s: pRtpSess[0x%p] %s Flags:0x%X +++++++++++++++++"),
            _fname, pRtpSess,
            RTPRECVSENDSTR(dwRecvSend), dwFlags
        ));

    if (!pRtpSess)
    {
        hr = RTPERR_INVALIDSTATE;

        TraceRetail((
                CLASS_ERROR, GROUP_RTP, S_RTP_START,
                _T("%s: pRtpSess[0x%p]: failed invalid state"),
                _fname, pRtpSess
            ));
        
        goto end;
    }

    /* verify object ID in RtpSess_t */
    if (pRtpSess->dwObjectID != OBJECTID_RTPSESS)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTP, S_RTP_START,
                _T("%s: pRtpSess[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpSess,
                pRtpSess->dwObjectID, OBJECTID_RTPSESS
            ));

        hr = RTPERR_INVALIDRTPSESS;

        goto end;
    }
   
    /* Serialize Start/Stop for this session */
    bOk = RtpEnterCriticalSection(&pRtpSess->SessCritSect);

    if (!bOk)
    {
        hr = RTPERR_CRITSECT;
        
        TraceRetail((
                CLASS_ERROR, GROUP_RTP, S_RTP_START,
                _T("%s: pRtpSess[0x%p]: failed to enter critical section"),
                _fname, pRtpSess
            ));

        goto end;
    }
    
    /* TODO go through all the address and start all of them */
    pRtpQueueItem = pRtpSess->RtpAddrQ.pFirst;

    /* Initialize SDES scheduler */
    ZeroMemory(&pRtpSess->RtpSdesSched, sizeof(RtpSdesSched_t));

    if (pRtpQueueItem)
    {
        pRtpAddr = CONTAINING_RECORD(pRtpQueueItem, RtpAddr_t, AddrQItem);

        if (RtpBitTest(pRtpAddr->dwIRtpFlags, FGADDR_IRTP_PERSISTSOCKETS))
        {
            /* Using persistent sockets, i.e. sockets and the RTP
             * session remain active after Stop, they are not really
             * stopped. Ports are guaranteed to remain valid */

            /* On the first time really do start */
            bDoStart = FALSE;
            
            if (RtpBitTest(dwFlags, FGADDR_ISRECV) &&
                !RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_RUNRECV))
            {
                bDoStart = TRUE;
            }
            if (RtpBitTest(dwFlags, FGADDR_ISSEND) &&
                !RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_RUNSEND))
            {
                bDoStart = TRUE;
            }

            if (bDoStart)
            {
                /* Need to do a real start */
                hr = RtpRealStart(pRtpAddr, dwFlags);
            }
            else
            {
                /* Already started, just unmute session, re-enable
                 * events, and re-do QOS reservation */
                hr = RtpNetUnmute(pRtpAddr, dwFlags);
            }
        }
        else
        {
            /* Using non persistent sockets, i.e. sockets are closed on
             * Stop. Ports may become used by another application and
             * binding to the same ports again after Stop, then Start,
             * could lead to a failure in unicast, and to unexpected
             * behavior in multicast */
            hr = RtpRealStart(pRtpAddr, dwFlags);
        }
    }

 end:
    if (bOk)
    {
        RtpLeaveCriticalSection(&pRtpSess->SessCritSect);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTP, S_RTP_START,
                _T("%s: pRtpSess[0x%p]: failed %s (0x%X)"),
                _fname, pRtpSess, RTPERR_TEXT(hr), hr
            ));
    }
    
    TraceRetail((
            CLASS_INFO, GROUP_RTP, S_RTP_TRACE,
            _T("%s: pRtpSess[0x%p] %s Flags:0x%X -----------------"),
            _fname, pRtpSess,
            RTPRECVSENDSTR(dwRecvSend), dwFlags
        ));

    return(hr);
}

HRESULT RtpStop_(
        RtpSess_t       *pRtpSess,
        DWORD            dwFlags
    )
{
    HRESULT          hr;
    BOOL             bOk;
    BOOL             bDoStop;
    DWORD            dwRecvSend;
    RtpQueueItem_t  *pRtpQueueItem;
    RtpAddr_t       *pRtpAddr;

    TraceFunctionName("RtpStop_");

    dwRecvSend = RtpBitTest(dwFlags, FGADDR_ISRECV)? RECV_IDX : SEND_IDX;

    bOk = FALSE;
    
    TraceRetail((
            CLASS_INFO, GROUP_RTP, S_RTP_TRACE,
            _T("%s: pRtpSess[0x%p] %s Flags:0x%X +++++++"),
            _fname, pRtpSess,
            RTPRECVSENDSTR(dwRecvSend), dwFlags
        ));

    if (!pRtpSess)
    {
        hr = RTPERR_INVALIDSTATE;

        TraceRetail((
                CLASS_ERROR, GROUP_RTP, S_RTP_START,
                _T("%s: pRtpSess[0x%p]: failed invalid state"),
                _fname, pRtpSess
            ));
        
        goto end;
    }

    /* verify object ID in RtpSess_t */
    if (pRtpSess->dwObjectID != OBJECTID_RTPSESS)
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTP, S_RTP_START,
                _T("%s: pRtpSess[0x%p] Invalid object ID 0x%X != 0x%X"),
                _fname, pRtpSess,
                pRtpSess->dwObjectID, OBJECTID_RTPSESS
            ));

        hr = RTPERR_INVALIDRTPSESS;

        goto end;
    }
    
    /* Serialize Start/Stop for this session */
    bOk = RtpEnterCriticalSection(&pRtpSess->SessCritSect);

    if (!bOk)
    { 
        hr = RTPERR_CRITSECT;
        
        TraceRetail((
                CLASS_ERROR, GROUP_RTP, S_RTP_START,
                _T("%s: pRtpSess[0x%p]: failed to enter critical section"),
                _fname, pRtpSess
            ));
        
        goto end;
    }

    /* TODO go trough all the address and start all of them */
    pRtpQueueItem = pRtpSess->RtpAddrQ.pFirst;

    if (pRtpQueueItem)
    {
        pRtpAddr = CONTAINING_RECORD(pRtpQueueItem, RtpAddr_t, AddrQItem);

        if (RtpBitTest(pRtpAddr->dwIRtpFlags, FGADDR_IRTP_PERSISTSOCKETS) &&
            !RtpBitTest(dwFlags, FGADDR_FORCESTOP))
        {
            /* Using persistent sockets, i.e. sockets and the RTP
             * session remain active after Stop, they are not really
             * stopped. Ports are guaranteed to remain valid */

            /* Mute the session, disable events, and unreserve */
            hr = RtpNetMute(pRtpAddr, dwFlags);
        }
        else
        {
            /* Using non persistent sockets, i.e. sockets are closed on
             * Stop. Ports may become used by another application and
             * binding to the same ports again after Stop, then Start,
             * could lead to a failure in unicast, and to unexpected
             * behavior in multicast */
            hr = RtpRealStop(pRtpAddr, dwFlags);
        }
    }

 end:
    if (bOk)
    {
        RtpLeaveCriticalSection(&pRtpSess->SessCritSect);
    }

    if (FAILED(hr))
    {
        TraceRetail((
                CLASS_ERROR, GROUP_RTP, S_RTP_START,
                _T("%s: pRtpSess[0x%p]: failed %S (0x%X)"),
                _fname, pRtpSess, RTPERR_TEXT(hr), hr
            ));
    }

    TraceRetail((
            CLASS_INFO, GROUP_RTP, S_RTP_TRACE,
            _T("%s: pRtpSess[0x%p] %s Flags:0x%X -------"),
            _fname, pRtpSess,
            RTPRECVSENDSTR(dwRecvSend), dwFlags
        ));

    return(hr);
}

HRESULT RtpRealStart(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwFlags
    )
{
    HRESULT          hr;
    HRESULT          hr2;
    WORD             wRtcpPort;
    DWORD            dwRecvSend;
    DWORD            dwClass;
    RtpSess_t       *pRtpSess;
    RtpCrypt_t      *pRtpCrypt;

    TraceFunctionName("RtpRealStart");

    dwRecvSend = RtpBitTest(dwFlags, FGADDR_ISRECV)? RECV_IDX : SEND_IDX;

    dwClass = RtpGetClass(pRtpAddr->dwIRtpFlags);
    
    hr = NOERROR;

    pRtpSess = pRtpAddr->pRtpSess;
    
    TraceRetail((
            CLASS_INFO, GROUP_RTP, S_RTP_TRACE,
            _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
            _T("%s/%s Flags:0x%X *****************"),
            _fname, pRtpSess, pRtpAddr,
            RTPRECVSENDSTR(dwRecvSend), RTPSTREAMCLASS(dwClass),
            dwFlags
        ));

    /* Set some defaults from registry (if needed) */
    if (RtpBitTest(dwFlags, FGADDR_ISRECV) &&
        !RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_REGUSEDRECV))
    {
        RtpSetFromRegistry(pRtpAddr, RtpBitPar(FGADDR_ISRECV));

        RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_REGUSEDRECV);
    }

    if (RtpBitTest(dwFlags, FGADDR_ISSEND) &&
        !RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_REGUSEDSEND))
    {
        RtpSetFromRegistry(pRtpAddr, RtpBitPar(FGADDR_ISSEND));

        RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_REGUSEDSEND);
    }
    
    /* Create sockets if they are not yet created */
    if (!RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_SOCKET))
    {
        /* This function will set FGADDR_SOCKET */
        hr = RtpGetSockets(pRtpAddr);

        if (FAILED(hr))
        {
            TraceRetail((
                    CLASS_ERROR, GROUP_RTP, S_RTP_START,
                    _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                    _T("failed to create sockets: %u (0x%X)"),
                    _fname, pRtpSess, pRtpAddr, hr, hr
                ));
            
            goto bail;
        }
    }

    if (!RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_RUNRECV) &&
        !RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_RUNSEND) )
    {
        /* Reset counters */
        RtpResetNetCount(&pRtpAddr->RtpAddrCount[RECV_IDX],
                         &pRtpAddr->NetSCritSect);
        RtpResetNetCount(&pRtpAddr->RtpAddrCount[SEND_IDX],
                         &pRtpAddr->NetSCritSect);

        /* Reset sender's network state */
        RtpResetNetSState(&pRtpAddr->RtpNetSState,
                          &pRtpAddr->NetSCritSect);
    }
        
    /* Set TTL and if multicast set multicast loopback and join group */
    if (!RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_SOCKOPT))
    {
        /* This function will set FGADDR_SOCKOPT */
        RtpSetSockOptions(pRtpAddr);
    }
        
    /* Obtain our own SSRC, random sequence number and timestamp */
    if (!RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_RANDOMINIT))
    {
        RtpGetRandomInit(pRtpAddr);

        RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_RANDOMINIT);
    }

    TraceDebug((
            CLASS_INFO, GROUP_RTP, S_RTP_START,
            _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] local SSRC:0x%X"),
            _fname, pRtpSess, pRtpAddr,
            ntohl(pRtpAddr->RtpNetSState.dwSendSSRC)
        ));

    /* Start RTCP thread for this address */
    if (!RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_RTCPTHREAD))
    {
        RtpBitReset2(pRtpAddr->RtpNetSState.dwNetSFlags,
                     FGNETS_1STBANDPOSTED, FGNETS_NOBANDPOSTED);

        RtpBitReset(pRtpAddr->RtpNetSState.dwNetSFlags, FGNETS_DONOTSENDPROBE);
        
        hr = RtcpStart(&g_RtcpContext);

        if (SUCCEEDED(hr))
        {
            RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_RTCPTHREAD);
        }
        else
        {
            goto bail;
        }
    }
        
    /* Initialize receiver */
    if (RtpBitTest(dwFlags, FGADDR_ISRECV))
    {
        if (!RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_RUNRECV))
        {
            /* Receiver's cryptographic initialization */
            pRtpCrypt = pRtpAddr->pRtpCrypt[CRYPT_RECV_IDX];
            
            if (pRtpCrypt)
            {
                hr = RtpCryptInit(pRtpAddr, pRtpCrypt);
                
                if (FAILED(hr))
                {
                    goto bail;
                }

                RtpBitSet(pRtpAddr->dwAddrFlagsC, FGADDRC_CRYPTRECVON);
            }

            RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_ISRECV);
            
            if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_QOSRECV) &&
                RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_RECVFSPEC_DEFINED)&&
                !RtpBitTest2(pRtpAddr->dwAddrFlagsQ,
                             FGADDRQ_REGQOSDISABLE, FGADDRQ_QOSNOTALLOWED))
            {
                /* NOTE: the test above is also done in RtpNetUnmute */

                /* Make a QOS reservation */
                hr2 = RtcpThreadCmd(&g_RtcpContext,
                                    pRtpAddr,
                                    RTCPTHRD_RESERVE,
                                    RECV_IDX,
                                    DO_NOT_WAIT);

                if (SUCCEEDED(hr2))
                {
                    RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_QOSRECVON);
                }
            }

            /* Enable events (provided the mask has some events
             * enabled) */
            RtpBitSet(pRtpSess->dwSessFlags, FGSESS_EVENTRECV);

            /* Set state FGADDR_RUNRECV, it i simportant to do
             * this before starting the RTP thread to allow it to
             * repost packets received */
            RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_RUNRECV);

            /* Create reception thread and start reception */
            hr = RtpCreateRecvThread(pRtpAddr);

            if (FAILED(hr))
            {
                TraceRetail((
                        CLASS_ERROR, GROUP_RTP, S_RTP_START,
                        _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
                        _T("RTP thread creation failed: %u (0x%X)"),
                        _fname, pRtpSess, pRtpAddr, hr, hr
                    ));
                
                goto bail;
            }

            RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_RTPTHREAD);

            InterlockedIncrement(&g_RtpContext.lNumRecvRunning);
        }
    }

    /* Initialize sender */
    if (RtpBitTest(dwFlags, FGADDR_ISSEND))
    {
        if (!RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_RUNSEND))
        {
            /* Sender's cryptographic initialization */
            pRtpCrypt = pRtpAddr->pRtpCrypt[CRYPT_SEND_IDX];
            
            if (pRtpCrypt)
            {
                hr = RtpCryptInit(pRtpAddr, pRtpCrypt);

                if (FAILED(hr))
                {
                    goto bail;
                }

                RtpBitSet(pRtpAddr->dwAddrFlagsC, FGADDRC_CRYPTSENDON);
            }

            RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_ISSEND);
            
            /* Enable sending at full rate, QOS may not be used or
             * permission granted, in the mean time, send */
            RtpBitSet(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSSEND);

            if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_QOSSEND) &&
                RtpBitTest(pRtpAddr->dwAddrFlagsQ, FGADDRQ_SENDFSPEC_DEFINED)&&
                !RtpBitTest2(pRtpAddr->dwAddrFlagsQ,
                             FGADDRQ_REGQOSDISABLE, FGADDRQ_QOSNOTALLOWED))
            {
                /* NOTE: the test above is also done in RtpNetUnmute */
                
                /* Start sending PATH messages */
                hr2 = RtcpThreadCmd(&g_RtcpContext,
                                    pRtpAddr,
                                    RTCPTHRD_RESERVE,
                                    SEND_IDX,
                                    DO_NOT_WAIT);
                
                if (SUCCEEDED(hr2))
                {
                    RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_QOSSENDON);
                }
            }

            /* Start with this redundancy distance */
            pRtpAddr->RtpNetSState.dwNxtRedDistance =
                pRtpAddr->RtpNetSState.dwInitialRedDistance;

            /* Bandwidth estimation, set initial module every time we
             * start, also reset the counter */
            pRtpAddr->RtpNetSState.dwBandEstMod = g_dwRtcpBandEstModInitial;
            pRtpAddr->RtpNetSState.dwBandEstCount = 0;
            
            /* Enable events (provided the mask has some events
             * enabled) */
            RtpBitSet(pRtpSess->dwSessFlags, FGSESS_EVENTSEND);

            RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_RUNSEND);

            InterlockedIncrement(&g_RtpContext.lNumSendRunning);
        }
    }

    /* Start RTCP activity (send/receive reports) for this
     * address */
    if (!RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_ADDED))
    {
        /* RTCP's cryptographic initialization */
        pRtpCrypt = pRtpAddr->pRtpCrypt[CRYPT_RTCP_IDX];
            
        if (pRtpCrypt)
        {
            hr = RtpCryptInit(pRtpAddr, pRtpCrypt);
            
            if (FAILED(hr))
            {
                goto bail;
            }

            RtpBitSet(pRtpAddr->dwAddrFlagsC, FGADDRC_CRYPTRTCPON);
        }
            
        hr = RtcpThreadCmd(&g_RtcpContext,
                           pRtpAddr,
                           RTCPTHRD_ADDADDR,
                           0,
                           60*60*1000); /* TODO update */
        
        if (SUCCEEDED(hr))
        {
            RtpBitSet(pRtpAddr->dwAddrFlags, FGADDR_ADDED);
        }
        else
        {
            goto bail;
        }
    }

    TraceRetail((
            CLASS_INFO, GROUP_RTP, S_RTP_TRACE,
            _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
            _T("%s/%s Flags:0x%X ================="),
            _fname, pRtpSess, pRtpAddr,
            RTPRECVSENDSTR(dwRecvSend), RTPSTREAMCLASS(dwClass),
            dwFlags
        ));
    
    return(hr);

 bail:

    RtpRealStop(pRtpAddr, dwFlags);
    
    TraceRetail((
            CLASS_ERROR, GROUP_RTP, S_RTP_START,
            _T("%s: pRtpAddr[0x%p] failed: %s (0x%X)"),
            _fname, pRtpAddr, RTPERR_TEXT(hr), hr
        ));
    
    return(hr);
}

HRESULT RtpRealStop(
        RtpAddr_t       *pRtpAddr,
        DWORD            dwFlags
    )
{
    HRESULT          hr;
    DWORD            dwRecvSend;
    DWORD            dwClass;
    RtpSess_t       *pRtpSess;
    RtpCrypt_t      *pRtpCrypt;

    TraceFunctionName("RtpRealStop");

    dwRecvSend = RtpBitTest(dwFlags, FGADDR_ISRECV)? RECV_IDX : SEND_IDX;

    dwClass = RtpGetClass(pRtpAddr->dwIRtpFlags);

    hr = NOERROR;

    pRtpSess = pRtpAddr->pRtpSess;
    
    TraceRetail((
            CLASS_INFO, GROUP_RTP, S_RTP_TRACE,
            _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
            _T("%s/%s Flags:0x%X *******"),
            _fname, pRtpSess, pRtpAddr,
            RTPRECVSENDSTR(dwRecvSend), RTPSTREAMCLASS(dwClass),
            dwFlags
        ));
    
    if (RtpBitTest(dwFlags, FGADDR_ISRECV))
    {
        if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_ISRECV))
        {
            /* De-initialize as receiver */

            /* Don't want more events */
            RtpBitReset(pRtpSess->dwSessFlags, FGSESS_EVENTRECV);

            if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_QOSRECVON))
            {
                RtcpThreadCmd(&g_RtcpContext,
                              pRtpAddr,
                              RTCPTHRD_UNRESERVE,
                              RECV_IDX,
                              DO_NOT_WAIT);

                RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_QOSRECVON);
            }

            /* Reset state FGADDR_RUNRECV, it is important to do
             * this before calling RtpDeleteRecvThread to prevent
             * trying to repost again the completed async I/Os
             * */
            RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_RUNRECV);
                
            if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_RTPTHREAD))
            {
                RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_RTPTHREAD);
            
                /* Stop reception thread */
                RtpDeleteRecvThread(pRtpAddr);

                /* Receiver's cryptographic de-initialization */
                pRtpCrypt = pRtpAddr->pRtpCrypt[CRYPT_RECV_IDX];
            
                if (pRtpCrypt)
                {
                    if (RtpBitTest(pRtpAddr->dwAddrFlagsC,
                                   FGADDRC_CRYPTRECVON))
                    {
                        RtpCryptDel(pRtpAddr, pRtpCrypt);

                        RtpBitReset(pRtpAddr->dwAddrFlagsC,
                                    FGADDRC_CRYPTRECVON);
                    }
                }

                InterlockedDecrement(&g_RtpContext.lNumRecvRunning);  
            }

            /* Unmap all the RTP outputs */
            RtpUnmapAllOuts(pRtpSess);

            /* Reset reception in all participants */
            ResetAllRtpUser(pRtpAddr, RtpBitPar(RECV_IDX));
            
            /* NOTE I could move here disabling the events so
             * unmapping the outputs will still have a chance to post
             * events */

            /* If the same receiver session is real started again,
             * start in the unmuted state */
            RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_MUTERTPRECV);
            
            RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_ISRECV);

            RtpBitReset(pRtpAddr->dwAddrFlagsR, FGADDRR_QOSREDRECV);
            RtpBitReset(pRtpAddr->dwAddrFlagsR, FGADDRR_UPDATEQOS);
        }
    }
        
    if (RtpBitTest(dwFlags, FGADDR_ISSEND))
    {
        if (RtpBitTest2(pRtpAddr->dwAddrFlags,
                        FGADDR_ISSEND, FGADDR_RUNSEND) ==
            RtpBitPar2(FGADDR_ISSEND, FGADDR_RUNSEND))
        {
            /* De-initialize as sender */
                
            /* Don't want more events */
            RtpBitReset(pRtpSess->dwSessFlags, FGSESS_EVENTSEND);
                
            RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_RUNSEND);
                
            if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_QOSSENDON))
            {
                RtcpThreadCmd(&g_RtcpContext,
                              pRtpAddr,
                              RTCPTHRD_UNRESERVE,
                              SEND_IDX,
                              DO_NOT_WAIT);

                RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_QOSSENDON);
            }
  
            /* Sender's cryptographic de-initialization */
            pRtpCrypt = pRtpAddr->pRtpCrypt[CRYPT_SEND_IDX];

            if (pRtpCrypt)
            {
                if (RtpBitTest(pRtpAddr->dwAddrFlagsC,
                               FGADDRC_CRYPTSENDON))
                {
                    RtpCryptDel(pRtpAddr, pRtpCrypt);

                    RtpBitReset(pRtpAddr->dwAddrFlagsC,
                                FGADDRC_CRYPTSENDON);
                }
            }

            /* If the same sender session is real started again, start
             * in the unmuted state */
            RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_MUTERTPSEND);
            
            RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_ISSEND);

            InterlockedDecrement(&g_RtpContext.lNumSendRunning);  
        }
    }

    if ( !RtpBitTest2(pRtpAddr->dwAddrFlags,
                      FGADDR_RUNRECV, FGADDR_RUNSEND) )
    {
        if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_ADDED))
        {
            /* Send RTCP BYE and shutdown this address */
            RtcpThreadCmd(&g_RtcpContext,
                          pRtpAddr,
                          RTCPTHRD_SENDBYE,
                          TRUE,
                          60*60*1000); /* TODO update */
        
            /* destroy sockets */
            RtpDelSockets(pRtpAddr);
            
            /* Remove this address from RTCP thread */
            hr = RtcpThreadCmd(&g_RtcpContext,
                               pRtpAddr,
                               RTCPTHRD_DELADDR,
                               0,
                               60*60*1000); /* TODO update */
            RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_ADDED);
        }
        else
        {
            /* Shouldn't need to delete sockets here, if the address
             * was not added, it would not need to be removed (in
             * other words, if the address was not started, it doesn't
             * need to be stopped). Yet the sockets still need to be
             * deleted even when the address was never
             * started/stopped, as they might have been created
             * because the application queried for the local ports,
             * but that deletion is delegated to DelRtpAddr() */
        }

        /* RTCP's cryptographic de-initialization */
        pRtpCrypt = pRtpAddr->pRtpCrypt[CRYPT_RTCP_IDX];

        if (pRtpCrypt)
        {
            if (RtpBitTest(pRtpAddr->dwAddrFlagsC, FGADDRC_CRYPTRTCPON))
            {
                RtpCryptDel(pRtpAddr, pRtpCrypt);

                RtpBitReset(pRtpAddr->dwAddrFlagsC, FGADDRC_CRYPTRTCPON);
            }
        }
            
        /* Stop the RTCP thread */
        if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_RTCPTHREAD))
        {
            RtcpStop(&g_RtcpContext);

            RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_RTCPTHREAD);
        }

        /* If later I'm started again, I want to obtain new random
         * values */
        if (RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_RANDOMINIT))
        {
            RtpBitReset(pRtpAddr->dwAddrFlags, FGADDR_RANDOMINIT);
            
            /* Delete all participants */
            DelAllRtpUser(pRtpAddr);
        }

        RtpBitReset(pRtpAddr->dwAddrFlagsQ, FGADDRQ_QOSEVENTPOSTED);
    }

    TraceDebug((
            CLASS_INFO, GROUP_RTP, S_RTP_TRACE,
            _T("%s: Recv(Free:%u, Ready:%u, Pending:%u)"),
            _fname,
            GetQueueSize(&pRtpAddr->RecvIOFreeQ),
            GetQueueSize(&pRtpAddr->RecvIOReadyQ),
            GetQueueSize(&pRtpAddr->RecvIOPendingQ)
        ));

    TraceRetail((
            CLASS_INFO, GROUP_RTP, S_RTP_TRACE,
            _T("%s: pRtpSess[0x%p] pRtpAddr[0x%p] ")
            _T("%s/%s Flags:0x%X ======="),
            _fname, pRtpSess, pRtpAddr,
            RTPRECVSENDSTR(dwRecvSend), RTPSTREAMCLASS(dwClass),
            dwFlags
        ));

    return(hr);
}

/* Helper function for RtpSetFromRegistry() */
void RtpModifyBit(
        DWORD           *pdwEventMask,
        DWORD            dwMask,
        DWORD            dwFlag,
        BOOL             bEnable)
{
    DWORD            i;
    
    if (dwMask != -1)
    {
        for(i = RECV_IDX; i <= SEND_IDX; i++)
        {
            if (RtpBitTest(dwFlag, i))
            {
                if (bEnable)
                {
                    pdwEventMask[i] |= dwMask;
                }
                else
                {
                    pdwEventMask[i] &= ~dwMask;
                }
            }
        }
    }
}

/*
 * Very important WARNING and TODO
 *
 * Some *disabling* flags here might be dangerous, i.e. to disable
 * encryption. I need either to add a compilation option to remove
 * them in the final product, or provide a mechanism to inform the
 * user about things being disabled */
void RtpSetFromRegistry(RtpAddr_t *pRtpAddr, DWORD dwFlags)
{
    WORD             wPort;
    DWORD            i;
    DWORD            dwFlag;
    DWORD            dwRecvSend;
    DWORD            dwCryptMode;
    DWORD            dwPar1;
    DWORD            dwPar2;
    DWORD            dwPar3;
    RtpSess_t       *pRtpSess;

    TraceFunctionName("RtpSetFromRegistry");

    pRtpSess = pRtpAddr->pRtpSess;
    
    /*
     * Address/port
     */
    if (RtpBitTest(pRtpAddr->dwIRtpFlags, FGADDR_IRTP_AUTO))
    {
        if (!RtpBitTest(pRtpAddr->dwAddrFlags, FGADDR_RADDR))
        {
            pRtpAddr->dwAddr[REMOTE_IDX]    = 0x0a0505e0;/* 224.5.5.10/10000 */
            pRtpAddr->wRtpPort[LOCAL_IDX]   = htons(10000);
            pRtpAddr->wRtpPort[REMOTE_IDX]  = htons(10000);
            pRtpAddr->wRtcpPort[LOCAL_IDX]  = htons(10001);
            pRtpAddr->wRtcpPort[REMOTE_IDX] = htons(10001);
            
            if (g_RtpReg.psDefaultIPAddress)
            {
                pRtpAddr->dwAddr[REMOTE_IDX] =
                    RtpAtoN(g_RtpReg.psDefaultIPAddress);
            }

            if (g_RtpReg.dwDefaultLocalPort <= 0xffff)
            {
                wPort = (WORD)g_RtpReg.dwDefaultLocalPort;
                pRtpAddr->wRtpPort[LOCAL_IDX]  = htons(wPort);
                wPort++;
                pRtpAddr->wRtcpPort[LOCAL_IDX] = htons(wPort);
            }

            if (g_RtpReg.dwDefaultRemotePort <= 0xffff)
            {
                wPort = (WORD)g_RtpReg.dwDefaultRemotePort;
                pRtpAddr->wRtpPort[REMOTE_IDX]  = htons(wPort);
                wPort++;
                pRtpAddr->wRtcpPort[REMOTE_IDX] = htons(wPort);
            }

            /* Needed to set local address */
            RtpSetAddress(pRtpAddr, 0, pRtpAddr->dwAddr[REMOTE_IDX]);
        }
    }

    if (g_RtpReg.dwMcastLoopbackMode < RTPMCAST_LOOPBACKMODE_LAST)
    {
        TraceRetail((
                CLASS_WARNING, GROUP_RTP, S_RTP_REG,
                _T("%s: pRtpAddr[0x%p] multicast mode being forced to:%u"),
                _fname, pRtpAddr, g_RtpReg.dwMcastLoopbackMode
            ));

        RtpSetMcastLoopback(pRtpAddr, g_RtpReg.dwMcastLoopbackMode, 0);
    }
    
    /*
     * QOS
     */
    if (RtpBitTest(pRtpAddr->dwIRtpFlags, FGADDR_IRTP_QOS) &&
        IsRegValueSet(g_RtpReg.dwQosEnable))
    {
        dwRecvSend = RtpBitTest(dwFlags, FGADDR_ISRECV)? RECV_IDX : SEND_IDX;

        if ((g_RtpReg.dwQosEnable & 0x3) == 3)
        {
            dwPar1 = RTPQOS_STYLE_DEFAULT;
            
            if (IsRegValueSet(g_RtpReg.dwQosRsvpStyle) &&
                g_RtpReg.dwQosRsvpStyle < RTPQOS_STYLE_LAST)
            {
                dwPar1 = g_RtpReg.dwQosRsvpStyle;
            }

            dwPar2 = 1;

            if (IsRegValueSet(g_RtpReg.dwQosMaxParticipants) &&
                g_RtpReg.dwQosMaxParticipants < 0x1024)
            {
                dwPar2 = g_RtpReg.dwQosMaxParticipants;
            }

            dwPar3 = RTPQOSSENDMODE_ASK_BUT_SEND;
            
            if (IsRegValueSet(g_RtpReg.dwQosSendMode) &&
                g_RtpReg.dwQosSendMode < RTPQOSSENDMODE_LAST)
            {
                dwPar3 = g_RtpReg.dwQosSendMode;
            }

            TraceRetail((
                    CLASS_WARNING, GROUP_RTP, S_RTP_REG,
                    _T("%s: pRtpAddr[0x%p] QOS being forced enabled"),
                    _fname, pRtpAddr
                ));
            
            if (g_RtpReg.psQosPayloadType)
            {
                RtpSetQosByNameOrPT(pRtpAddr,
                                    dwRecvSend,
                                    g_RtpReg.psQosPayloadType,
                                    NO_DW_VALUESET,
                                    dwPar1,
                                    dwPar2,
                                    dwPar3,
                                    NO_DW_VALUESET,
                                    TRUE);
            }
            else
            {
                RtpSetQosByNameOrPT(pRtpAddr,
                                    dwRecvSend,
                                    _T("H263CIF"),
                                    NO_DW_VALUESET,
                                    dwPar1,
                                    dwPar2,
                                    dwPar3,
                                    NO_DW_VALUESET,
                                    TRUE);
            }

            if (g_RtpReg.psQosAppName ||
                g_RtpReg.psQosAppGUID ||
                g_RtpReg.psQosPolicyLocator)
            {
                RtpSetQosAppId(pRtpAddr,
                               g_RtpReg.psQosAppName,
                               g_RtpReg.psQosAppGUID,
                               g_RtpReg.psQosPolicyLocator);
            }

            RtpBitReset(pRtpAddr->dwAddrFlagsQ, FGADDRQ_REGQOSDISABLE);
        }
        else if ((g_RtpReg.dwQosEnable & 0x3) == 2)
        {
            TraceRetail((
                    CLASS_WARNING, GROUP_RTP, S_RTP_REG,
                    _T("%s: pRtpAddr[0x%p] QOS being forced disabled"),
                    _fname, pRtpAddr
                ));
            
            /* disable QOS */
            RtpBitSet(pRtpAddr->dwAddrFlagsQ, FGADDRQ_REGQOSDISABLE);
        }
    }

    /*
     * Cryptography
     */
    if (!pRtpAddr->pRtpCrypt[CRYPT_RECV_IDX])
    {
        /* Cryptography was not initialized */
        
        if ( IsRegValueSet(g_RtpReg.dwCryptEnable) &&
             ((g_RtpReg.dwCryptEnable & 0x3) == 0x3) )
        {
            dwCryptMode = g_RtpReg.dwCryptMode;
            
            if ((dwCryptMode & 0xffff) >= RTPCRYPTMODE_LAST)
            {
                dwCryptMode = 0;
            }
            
            RtpSetEncryptionMode(pRtpAddr,
                                 dwCryptMode & 0x0000ffff,
                                 dwCryptMode & 0xffff0000);

            if (g_RtpReg.psCryptPassPhrase)
            {
                for(i = CRYPT_RECV_IDX; i <= CRYPT_RTCP_IDX; i++)
                {
                    if (pRtpAddr->pRtpCrypt[i] &&
                        !RtpBitTest(pRtpAddr->pRtpCrypt[i]->dwCryptFlags,
                                    FGCRYPT_KEY))
                    {
                        RtpSetEncryptionKey(pRtpAddr,
                                            g_RtpReg.psCryptPassPhrase,
                                            g_RtpReg.psCryptHashAlg,
                                            g_RtpReg.psCryptDataAlg,
                                            i);
                    }
                }
            }
        }
        else
        {
            /* TODO disable cryptography under conditional compilation */
        }
    }

    /*
     * Events
     */

    /* WARNING If the events are explicitly enabled or disabled in the
     * registry, the masks will be used untested as ALL the values in
     * the DWORD mask are valid, so if they were not set in the
     * registry, its value will be assumed 0xffffffff and will be used
     * */
    
    /* Enable */
    dwFlag = 0;
    if (IsRegValueSet(g_RtpReg.dwEventsReceiver) &&
        (g_RtpReg.dwEventsReceiver & 0x3) == 0x3)
    {
        dwFlag |= RtpBitPar(RECV_IDX);
    }
    if (IsRegValueSet(g_RtpReg.dwEventsSender) &&
        (g_RtpReg.dwEventsSender & 0x3) == 0x3)
    {
        dwFlag |= RtpBitPar(SEND_IDX);
    }
    if (dwFlag)
    {
        RtpModifyBit(pRtpSess->dwEventMask, g_RtpReg.dwEventsRtp,
                     dwFlag, 1);
        RtpModifyBit(pRtpSess->dwPartEventMask, g_RtpReg.dwEventsPInfo,
                     dwFlag, 1);
        RtpModifyBit(pRtpSess->dwQosEventMask, g_RtpReg.dwEventsQos,
                     dwFlag, 1);
        RtpModifyBit(pRtpSess->dwSdesEventMask, g_RtpReg.dwEventsSdes,
                     dwFlag, 1);
    }
    /* Disable */
    dwFlag = 0;
    if (IsRegValueSet(g_RtpReg.dwEventsReceiver) &&
        (g_RtpReg.dwEventsReceiver & 0x3) == 0x2)
    {
        dwFlag |= RtpBitPar(RECV_IDX);
    }
    if (IsRegValueSet(g_RtpReg.dwEventsSender) &&
        (g_RtpReg.dwEventsSender & 0x3) == 0x2)
    {
        dwFlag |= RtpBitPar(SEND_IDX);
    }
    if (dwFlag)
    {
        RtpModifyBit(pRtpSess->dwEventMask, g_RtpReg.dwEventsRtp,
                     dwFlag, 0);
        RtpModifyBit(pRtpSess->dwPartEventMask, g_RtpReg.dwEventsPInfo,
                     dwFlag, 0);
        RtpModifyBit(pRtpSess->dwQosEventMask, g_RtpReg.dwEventsQos,
                     dwFlag, 0);
        RtpModifyBit(pRtpSess->dwSdesEventMask, g_RtpReg.dwEventsSdes,
                     dwFlag, 0);
    }

    /* Bandwidth estimation */
    if (IsRegValueSet(g_RtpReg.dwBandEstEnable))
    {
        if ((g_RtpReg.dwBandEstEnable & 0x3) == 0x3)
        {
            if (!RtpBitTest(pRtpSess->dwFeatureMask, RTPFEAT_BANDESTIMATION))
            {
                TraceRetail((
                        CLASS_WARNING, GROUP_RTP, S_RTP_REG,
                        _T("%s: pRtpAddr[0x%p] badwidth estimation ")
                        _T("being forced anabled"),
                        _fname, pRtpAddr
                    ));
            }
            
            RtpBitSet(pRtpSess->dwFeatureMask, RTPFEAT_BANDESTIMATION);
        }
        else if ((g_RtpReg.dwBandEstEnable & 0x3) == 0x2)
        {
            if (RtpBitTest(pRtpSess->dwFeatureMask, RTPFEAT_BANDESTIMATION))
            {
                TraceRetail((
                        CLASS_WARNING, GROUP_RTP, S_RTP_REG,
                        _T("%s: pRtpAddr[0x%p] badwidth estimation ")
                        _T("being forced disabled"),
                        _fname, pRtpAddr
                    ));
            }

            RtpBitReset(pRtpSess->dwFeatureMask, RTPFEAT_BANDESTIMATION);
        }
    }

    /* Network quality */
    if (IsDWValueSet(g_RtpReg.dwNetQualityEnable))
    {
        if ((g_RtpReg.dwNetQualityEnable & 0x3) == 0x2)
        {
            /* Disable */
            RtpBitSet(pRtpAddr->dwAddrRegFlags, FGADDRREG_NETQFORCED);
            RtpBitReset(pRtpAddr->dwAddrRegFlags, FGADDRREG_NETQFORCEDVALUE);
        }
        else if ((g_RtpReg.dwNetQualityEnable & 0x3) == 0x3)
        {
            /* Enable */
            RtpBitSet(pRtpAddr->dwAddrRegFlags, FGADDRREG_NETQFORCED);
            RtpBitSet(pRtpAddr->dwAddrRegFlags, FGADDRREG_NETQFORCEDVALUE);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\tools\inc\udpecho.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 2001
 *
 *  File name:
 *
 *    udpecho.h
 *
 *  Abstract:
 *
 *    udpecho structures
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2001/05/18 created
 *
 **********************************************************************/
#ifndef _udpecho_h_
#define _udpecho_h_

typedef struct _EchoStream_t {

    DWORD            dwAddrCount;
    NetAddr_t        NetAddr[2];

    WSABUF           WSABuf;
    char             buffer[MAX_BUFFER_SIZE];
} EchoStream_t;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\tools\inc\udpsend.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 2001
 *
 *  File name:
 *
 *    udpsend.h
 *
 *  Abstract:
 *
 *    udpsend structures
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2001/01/18 created
 *
 **********************************************************************/
#ifndef _udpsend_h_
#define _udpsend_h_

typedef struct _SendStream_t {
    DWORD            dwBlocks;
    DWORD            dwPackets;
    DWORD            dwBlockGap;   /* millisecs */
    DWORD            dwPacketGap;  /* millisecs */
    DWORD            dwBlockCount;
    DWORD            dwPacketCount;
    DWORD            dwPacketSize;

    DWORD            dwAdvanceTimeout;
    
    DWORD            dwBytesSent;
    DWORD            dwPacketsSent;
    
    DWORD            dwOptions;
    double           dNextPacket;

    NetAddr_t        NetAddr;

    /* Used to receive */
    struct timeval   timeval;
    fd_set           fdReceivers;

    FILE            *output;
    char             FileName[128];

    WSABUF           WSABuf;
    char             buffer[MAX_BUFFER_SIZE];
} SendStream_t;

enum {
    OP_FIRST,

    OP_RANDOMDATA,

    OP_SENDANDRECEIVE,
    
    OP_DISCARD,    /* Discard received data, i.e. don't print it */

    OP_LAST
};

#define DEFAULT_BLOCKS       1
#define DEFAULT_PACKETS      (1000*10/30) /* 10 secs of 30ms packets */
#define DEFAULT_BLOCKGAP     (3*1000)
#define DEFAULT_PACKETGAP    30
#define DEFAULT_PACKETSIZE   (240+12)

/* Do not sleep but do an active wait if target time is this close */
#define DEFAULT_TIMEOUT      5  /* millisecs */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\tools\inc\common.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 2001
 *
 *  File name:
 *
 *    common.h
 *
 *  Abstract:
 *
 *    This file implements some common functions used by the
 *    udpsend/udpecho/udprecv tool for sending/receiving bursts of UDP
 *    packets with specific network characteristics.
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2001/01/17 created
 *
 **********************************************************************/
#ifndef _common_h_
#define _common_h_

/* Packets are send in blocks separated by gaps, each block containing
   N packets also separated by an specific gap, i.e:

        block 1          block gap    block 2           block gap ...
   |--------------------|---------|--------------------|--------- ...
    -- -- -- -- -- -- --
      v
    \-|-------v--------/ \------v/
      |       |                 |
      |       Packets per block |
      |                         Inter block gap
      Inter packet gap
*/

#include <winsock2.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <mmsystem.h>  /* timeGetTime() */
#include <sys/timeb.h> /* void _ftime( struct _timeb *timeptr ); */
#include <ws2tcpip.h>

#define APP_VERSION      2.0

typedef struct _PcktHdr_t {
    DWORD            dwSeq;
    
    DWORD            SendNTP_sec;
    DWORD            SendNTP_frac;
    
    DWORD            EchoNTP_sec;
    DWORD            EchoNTP_frac;
} PcktHdr_t;

typedef struct _NetAddr_t {
    SOCKET           Socket;

    union {
        SOCKADDR_IN      FromInAddr;
        SOCKADDR         From;
    };

    union {
        SOCKADDR_IN      ToInAddr;
        SOCKADDR         To;
    };

    DWORD            dwRxTransfered;
    DWORD            dwTxTransfered;

    /* NETWORK ORDER */
    DWORD            dwAddr[2]; /* Local, Remote */

    /* NETWORK ORDER */
    union {
        WORD             wPort[2];  /* Local, Remote */
        DWORD            dwPorts;
    };
    
    DWORD            dwTTL;
} NetAddr_t;

#define DEFAULT_PORT         5008
#define DEFAULT_ADDR         0x0a0505e0  /* 224.5.5.10 */
#define DEFAULT_LOC_ADDR     0           /* INADDR_ANY */

#define DEFAULT_UCAST_TTL    127
#define DEFAULT_MCAST_TTL    8

#define RECV_IDX             0
#define SEND_IDX             1

#define LOCAL_IDX            0
#define REMOTE_IDX           1

#define MAX_BYE_PACKETS      4
#define BYE_PACKET_SIZE      4

#define MAX_BUFFER_SIZE  2048

/* A DWORD value is not set */
#define NO_DW_VALUESET    ((DWORD)~0)
#define IsDWValueSet(dw)  ((dw) != NO_DW_VALUESET)

/* builds a mask of bit b */
#define BitPar(b)            (1 << (b))
#define BitPar2(b1, b2)      ((1 << (b1)) | (1 << (b2)))

/* test bit b in f */
#define BitTest(f, b)        (f & (1 << (b)))
#define BitTest2(f, b1, b2)  (f & BitPar2(b1, b2))

/* set bit b in f */
#define BitSet(f, b)         (f |= (1 << (b)))
#define BitSet2(f, b1, b2)   (f |= BitPar2(b1, b2))

/* reset bit b in f */
#define BitReset(f, b)       (f &= ~(1 << (b)))
#define BitReset2(f, b1, b2) (f &= ~BitPar2(b1, b2))

#define IS_MULTICAST(addr) (((long)(addr) & 0x000000f0) == 0x000000e0)
#define IS_UNICAST(addr)   (((long)(addr) & 0x000000f0) != 0x000000e0)

void print_error(char *pFormat, ...);

char *IPNtoA(DWORD dwAddr, char *sAddr);
DWORD IPAtoN(char *sAddr);

void InitReferenceTime(void);
double GetTimeOfDay(void);

DWORD InitWinSock(void);
void DeinitWinSock(void);

DWORD InitNetwork(NetAddr_t *pNetAddr, DWORD dwDirection);
void DeinitNetwork(NetAddr_t *pNetAddr);

DWORD GetNetworkAddress(NetAddr_t *pNetAddr, char *addr);
SOCKET GetSocket(DWORD *pdwAddr, WORD *pwPort, DWORD dwRecvSend);
DWORD SetTTL(SOCKET Socket, DWORD dwTTL, BOOL bMcast);

DWORD JoinLeaf(SOCKET Socket, DWORD dwAddr, WORD wPort, DWORD dwRecvSend);
DWORD SetMcastSendIF(SOCKET Socket, DWORD dwAddr);
DWORD SetWinSockLoopback(SOCKET Socket, BOOL bEnabled);

DWORD ReceivePacket(
        NetAddr_t       *pNetAddr,
        WSABUF          *pWSABuf,
        DWORD            dwBufferCount,
        double          *pAi
    );

DWORD SendPacket(
        NetAddr_t       *pNetAddr,
        WSABUF          *pWSABuf,
        DWORD            dwBufferCount
    );

void PrintPacket(
        FILE            *output,
        PcktHdr_t       *pPcktHdr,
        DWORD            dwTransfered,
        double           Ai
    );

#endif _common_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\tools\inc\udprecv.h ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 2001
 *
 *  File name:
 *
 *    udprecv.h
 *
 *  Abstract:
 *
 *    udprecv structures
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2001/01/18 created
 *
 **********************************************************************/
#ifndef _udprecv_h_
#define _udprecv_h_

enum {
    OP_FIRST,

    OP_DISCARD,    /* Discard received data, i.e. don't print it */
    
    OP_LAST
};

typedef struct _RecvStream_t {
    DWORD            dwBytesRecv;
    DWORD            dwPacketsRecv;

    DWORD            dwOptions;
    
    FILE            *output;
    char             FileName[128];
    NetAddr_t        NetAddr;

    double           Ai;
    WSABUF           WSABuf;
    char             buffer[MAX_BUFFER_SIZE];
   
} RecvStream_t;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\tools\common\common.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 2001
 *
 *  File name:
 *
 *    common.c
 *
 *  Abstract:
 *
 *    This file implements some common functions used by the
 *    udpsend/udpecho/udprecv tool for sending/receiving bursts of UDP
 *    packets with specific network characteristics.
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2001/01/17 created
 *
 **********************************************************************/

#include "common.h"

DWORD            g_dwRefTime;
double           g_dRefTime;

LONGLONG         g_lPerfFrequency = 0;
LONGLONG         g_lRefTime;


void print_error(char *pFormat, ...)
{
    va_list          arglist;

    va_start(arglist, pFormat);

    vfprintf(stderr, pFormat, arglist);
    
    va_end(arglist);
}

char *IPNtoA(DWORD dwAddr, char *sAddr)
{
    sprintf(sAddr, "%u.%u.%u.%u",
            (dwAddr & 0xff),
            (dwAddr >> 8) & 0xff,
            (dwAddr >> 16) & 0xff,
            (dwAddr >> 24) & 0xff);
    
    return(sAddr);
}

DWORD IPAtoN(char *sAddr)
{
    DWORD            b3, b2, b1, b0;
    DWORD            dwAddr;
    
    if (sscanf(sAddr,"%u.%u.%u.%u", &b3, &b2, &b1, &b0) != 4)
    {
        dwAddr = 0;
    }
    else
    {
        dwAddr =
            ((b0 & 0xff) << 24) | ((b1 & 0xff) << 16) |
            ((b2 & 0xff) <<  8) | (b3 & 0xff);
    }
    
    return(dwAddr);
}

void InitReferenceTime(void)
{
    struct _timeb    timeb;
    
    _ftime(&timeb);
    
    g_dRefTime = timeb.time + (double)timeb.millitm/1000.0;

    QueryPerformanceFrequency((LARGE_INTEGER *)&g_lPerfFrequency);
    
    if (g_lPerfFrequency)
    {
        QueryPerformanceCounter((LARGE_INTEGER *)&g_lRefTime);
    }
    else
    {
        g_dwRefTime = timeGetTime();
    }
}

double GetTimeOfDay(void)
{
    double           dTime;
    LONGLONG         lTime;
    
    if (g_lPerfFrequency)
    {
        QueryPerformanceCounter((LARGE_INTEGER *)&lTime);

        dTime = g_dRefTime + (double)(lTime - g_lRefTime)/g_lPerfFrequency;
    }
    else
    {
        dTime = g_dRefTime + (double)(timeGetTime() - g_dwRefTime)/1000.0;
    }

    return(dTime);
}

DWORD InitWinSock(void)
{
    DWORD            dwError;
    WSADATA          WSAData;
    WORD             VersionRequested;

    VersionRequested = MAKEWORD(2,0);

    dwError = WSAStartup(VersionRequested, &WSAData);

    if (dwError)
    {
        dwError = WSAGetLastError();
    }

    return(dwError);
}

void DeinitWinSock(void)
{
    WSACleanup();
}

DWORD InitNetwork(NetAddr_t *pNetAddr, DWORD dwDirection)
{
    DWORD            dwError;
    
    dwError = NOERROR;
    
    pNetAddr->Socket = GetSocket(pNetAddr->dwAddr,
                                 pNetAddr->wPort,
                                 dwDirection);

    if (pNetAddr->Socket != INVALID_SOCKET)
    {
        if (IS_MULTICAST(pNetAddr->dwAddr[REMOTE_IDX]))
        {
            dwError = JoinLeaf(pNetAddr->Socket,
                               pNetAddr->dwAddr[REMOTE_IDX],
                               pNetAddr->wPort[REMOTE_IDX],
                               dwDirection);
        }

        if (BitTest(dwDirection, RECV_IDX))
        {
            /* Receiver */
        }

        if (BitTest(dwDirection, SEND_IDX))
        {
            /* Sender */
            if (!pNetAddr->dwTTL)
            {
                if (IS_MULTICAST(pNetAddr->dwAddr[REMOTE_IDX]))
                {
                    pNetAddr->dwTTL = DEFAULT_MCAST_TTL;
                }
                else
                {
                    pNetAddr->dwTTL = DEFAULT_UCAST_TTL;
                }
                
                SetTTL(pNetAddr->Socket,
                       pNetAddr->dwTTL,
                       IS_MULTICAST(pNetAddr->dwAddr[REMOTE_IDX]));
            }

            /* Set destination address */
            ZeroMemory(&pNetAddr->ToInAddr, sizeof(pNetAddr->ToInAddr));
    
            pNetAddr->ToInAddr.sin_family = AF_INET;
            pNetAddr->ToInAddr.sin_addr.s_addr = pNetAddr->dwAddr[REMOTE_IDX];
            pNetAddr->ToInAddr.sin_port = pNetAddr->wPort[REMOTE_IDX];
        }
    }
    else
    {
        dwError = 1;
    }
    
    return(dwError);
}

void DeinitNetwork(NetAddr_t *pNetAddr)
{
    if (pNetAddr->Socket != INVALID_SOCKET)
    {
        closesocket(pNetAddr->Socket);
    }
}

/* Parse a network address of the form address/port/ttl */
DWORD GetNetworkAddress(NetAddr_t *pNetAddr, char *addr)
{
    char            *str;
    char            *port;
    char            *ttl;
    BOOL             bResolve;
    struct hostent  *he;

    port = ttl = NULL;
    
    /* Split address/port */
    port = strchr(addr, '/');

    if (port)
    {
        *port = 0; /* Null end the address */
        port++;    /* Point to port */

        ttl = strchr(port, '/');

        if (ttl)
        {
            *ttl = 0;
            ttl++;

            str =  strchr(ttl, '/');

            if (str)
            {
                *str = 0;
            }
        }
    }

    if (port)
    {
        pNetAddr->wPort[REMOTE_IDX] = htons((short)atoi(port));
        pNetAddr->wPort[LOCAL_IDX] = pNetAddr->wPort[REMOTE_IDX];
    }

    if (ttl)
    {
        pNetAddr->dwTTL = atoi(ttl);
    }

    bResolve = FALSE;
    
    for(str = addr; *str; str++)
    {
        if (!(isdigit((int)*str) || *str=='.'))
        {
            /* Resolve address */
            bResolve = TRUE;
            break;
        }
    }

    if (bResolve)
    {
        he = gethostbyname(addr);

        if (!he)
        {
            print_error("gethostbyname: failed for host:%s, error=%u\n",
                        addr, WSAGetLastError());
            
            goto fail;
        }

        pNetAddr->dwAddr[REMOTE_IDX] = *((DWORD *)he->h_addr_list[0]);
    }
    else
    {
        /* Address in dot form */
        pNetAddr->dwAddr[REMOTE_IDX] = IPAtoN(addr);

        if (!pNetAddr->dwAddr[REMOTE_IDX])
        {
            print_error("Invalid dot address: %s\n", addr);

            goto fail;;
        }

    }
    
    return(NOERROR);

 fail:
    pNetAddr->dwPorts = 0;
    return(1);
}

SOCKET GetSocket(DWORD *pdwAddr, WORD *pwPort, DWORD dwDirection)
{
    SOCKET           Socket;
    int              iSockFlags;
    DWORD            dwPar;
    DWORD            dwError;
    
    SOCKADDR_IN      LocalAddr;
    int              LocalAddrLen;
    char             sLocalAddr[16];
    
    iSockFlags = 0;

    if (IS_MULTICAST(pdwAddr[REMOTE_IDX]))
    {
        iSockFlags |=
            (WSA_FLAG_MULTIPOINT_C_LEAF |
             WSA_FLAG_MULTIPOINT_D_LEAF);
    }

    Socket = WSASocket(
            AF_INET,    /* int af */
            SOCK_DGRAM, /* int type */
            IPPROTO_IP, /* int protocol */
            NULL,       /* LPWSAPROTOCOL_INFO lpProtocolInfo */
            0,          /* GROUP g */
            iSockFlags  /* DWORD dwFlags */
        );
        
    if (Socket == INVALID_SOCKET)
    {
        dwError = WSAGetLastError();

        print_error("WSAGetSocket failed:%u\n", dwError);

        return(Socket);
    }

    /* Need to do this before binding, otherwise it may fail if the
     * address is already in use.
     *
     * WARNING Note that option SO_REUSEADDR is used regardless of the
     * destination address (multicast or unicast). Who receives data
     * in a unicast session is unpredicted when multiple (more than 1)
     * sockets are bound to the same address and port
     * */
            
    dwPar = 1; /* Reuse */

    /* Reuse address/port */
    dwError = setsockopt(
            Socket,
            SOL_SOCKET,
            SO_REUSEADDR,
            (PCHAR)&dwPar,
            sizeof(dwPar)
        );
        
    if (dwError == SOCKET_ERROR)
    {
        dwError = WSAGetLastError();

        print_error("setsockoption(SO_REUSEADDR) failed: %u (0x%X)\n",
                    dwError, dwError);
    }

    /* bind socket */
    ZeroMemory(&LocalAddr, sizeof(LocalAddr));

    LocalAddr.sin_family = AF_INET;
    LocalAddr.sin_addr = *(struct in_addr *) &pdwAddr[LOCAL_IDX];
    if (BitTest(dwDirection, RECV_IDX))
    {
        LocalAddr.sin_port = pwPort[LOCAL_IDX];
    }
    else
    {
        LocalAddr.sin_port = 0; 
    }
            
    /* bind rtp socket to the local address specified */
    dwError = bind(Socket, (SOCKADDR *)&LocalAddr, sizeof(LocalAddr));

    if (dwError == 0)
    {
        /* Get the port */
        LocalAddrLen = sizeof(LocalAddr);
        dwError =
            getsockname(Socket, (struct sockaddr *)&LocalAddr, &LocalAddrLen);

        if (dwError)
        {
            dwError = WSAGetLastError();
            
            print_error("getsockname failed: %u (0x%X)\n",
                        dwError, dwError);

            closesocket(Socket);

            return(INVALID_SOCKET);
        }
        else
        {
            pwPort[LOCAL_IDX] = LocalAddr.sin_port;
        }
    }
    else
    {
        dwError = WSAGetLastError();

        print_error("bind socket:%u to port:%u failed: %u (0x%X)\n",
                    Socket, ntohs(LocalAddr.sin_port), dwError, dwError);
        closesocket(Socket);

        return(INVALID_SOCKET);
    }

    if (IS_MULTICAST(pdwAddr[REMOTE_IDX]))
    {
        if (pdwAddr[LOCAL_IDX])
        {
            SetMcastSendIF(Socket, pdwAddr[LOCAL_IDX]);
        }

        /* Disable multicast loopback */
        SetWinSockLoopback(Socket, FALSE);
    }

    return(Socket);
}

DWORD SetTTL(SOCKET Socket, DWORD dwTTL, BOOL bMcast)
{
    DWORD            dwError;

    dwError = setsockopt( 
            Socket,
            IPPROTO_IP, 
            bMcast? IP_MULTICAST_TTL : IP_TTL,
            (PCHAR)&dwTTL,
            sizeof(dwTTL)
        );

    if (dwError == SOCKET_ERROR)
    {
        dwError = WSAGetLastError();
            
        print_error("Socket:%u TTL:%d failed: %u (0x%X)\n",
                    Socket, dwTTL, dwError, dwError);
    }

    return(dwError);
}

DWORD JoinLeaf(SOCKET Socket, DWORD dwAddr, WORD wPort, DWORD dwDirection)
{
    DWORD            dwError;
    DWORD            dwFlags;
    SOCKADDR_IN      JoinAddr;
    SOCKET           TmpSocket;
    char             sAddr[16];
                    
    ZeroMemory(&JoinAddr, sizeof(JoinAddr));
        
    JoinAddr.sin_family = AF_INET;
    JoinAddr.sin_addr = *(struct in_addr *) &dwAddr;
    JoinAddr.sin_port = wPort;

    dwFlags = 0;

    /* Join in one direction */

    if (BitTest(dwDirection, RECV_IDX))
    {
        dwFlags |= JL_RECEIVER_ONLY;
    }

    if (BitTest(dwDirection, SEND_IDX))
    {
        dwFlags |= JL_SENDER_ONLY;
    }

    
    TmpSocket = WSAJoinLeaf(Socket,
                            (const struct sockaddr *)&JoinAddr,
                            sizeof(JoinAddr),
                            NULL, NULL, NULL, NULL,
                            dwFlags);

    if (TmpSocket == INVALID_SOCKET)
    {
        dwError = WSAGetLastError();

        print_error("WSAJoinLeaf failed: %u:%s/%u %u (0x%X)\n",
                    Socket, IPNtoA(dwAddr, sAddr), ntohs(wPort),
                    dwError, dwError);
    }
    else
    {
        dwError = NOERROR;
    }

    return(dwError);
}

DWORD SetMcastSendIF(SOCKET Socket, DWORD dwAddr)
{
    DWORD            dwError;
    char             sAddr[16];

    dwError = setsockopt( 
            Socket,
            IPPROTO_IP, 
            IP_MULTICAST_IF,
            (char *)&dwAddr,
            sizeof(dwAddr)
        );

    if (dwError == SOCKET_ERROR)
    {
        dwError = WSAGetLastError();
            
        print_error("Socket:%u IP_MULTICAST_IF(%s) failed: %u (0x%X)\n",
                    Socket, IPNtoA(dwAddr, sAddr), dwError, dwError);
    }
    
    return(dwError);
}

DWORD SetWinSockLoopback(SOCKET Socket, BOOL bEnabled)
{
    DWORD            dwStatus;
    DWORD            dwPar;

    dwPar = bEnabled? 1:0;
    
    /* Allow own packets to come back or not */
    dwStatus = setsockopt(
            Socket,
            IPPROTO_IP,
            IP_MULTICAST_LOOP,
            (PCHAR)&dwPar,
            sizeof(dwPar)
        );
        
    if (dwStatus == SOCKET_ERROR)
    {
        dwStatus = WSAGetLastError();
        
        print_error("Socket:%u Loopback:%d failed: %u (0x%X)",
                    Socket, dwPar, dwStatus, dwStatus);
    }
    else
    {
        dwStatus = NOERROR;
    }
    
    return(dwStatus);
}

DWORD ReceivePacket(
        NetAddr_t       *pNetAddr,
        WSABUF          *pWSABuf,
        DWORD            dwBufferCount,
        double          *pAi
    )
{
    DWORD            dwStatus;
    DWORD            dwFlags;
    DWORD            dwFromLen;

    dwFlags = 0;
    
    dwFromLen = sizeof(pNetAddr->From);
    
    pNetAddr->dwRxTransfered = 0;
    
    dwStatus = WSARecvFrom(
            pNetAddr->Socket,       /* SOCKET s */
            pWSABuf,                /* LPWSABUF lpBuffers */
            dwBufferCount,          /* DWORD dwBufferCount */
            &pNetAddr->dwRxTransfered,/* LPDWORD lpNumberOfBytesRecvd */
            &dwFlags,               /* LPDWORD lpFlags */
            &pNetAddr->From,        /* struct sockaddr FAR *lpFrom */
            &dwFromLen,             /* LPINT lpFromlen */
            NULL,                   /* LPWSAOVERLAPPED lpOverlapped */
            NULL                    /* LPWSAOVERLAPPED_COMPLETION_ROUTINE */
        );

    if (pAi)
    {
        *pAi = GetTimeOfDay();
    }
    
    if (dwStatus)
    {
        dwStatus = WSAGetLastError();
        
        if (dwStatus != WSAECONNRESET)
        {
            print_error("WSARecvFrom failed: %u (0x%X)\n", dwStatus, dwStatus);
        }
        
        pNetAddr->dwRxTransfered = 0;
    }
    
    
    return(pNetAddr->dwRxTransfered);
}

DWORD SendPacket(
        NetAddr_t       *pNetAddr,
        WSABUF          *pWSABuf,
        DWORD            dwBufferCount
    )
{
    DWORD            dwStatus;
    DWORD            dwBytesTransfered;

    dwBytesTransfered = 0;
    
    dwStatus = WSASendTo(
            pNetAddr->Socket,    /* SOCKET    s */
            pWSABuf,             /* LPWSABUF  lpBuffers */
            dwBufferCount,       /* DWORD dwBufferCount */    
            &pNetAddr->dwTxTransfered,/* LPDWORD lpNumberOfBytesSent */    
            0,                   /* DWORD dwFlags*/    
            &pNetAddr->To,       /* const struct sockaddr *lpTo */
            sizeof(pNetAddr->To),/* int iToLen*/
            NULL,                /* LPWSAOVERLAPPED lpOverlapped */
            NULL /* LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionROUTINE */
        );

    if (dwStatus)
    {
        dwStatus = WSAGetLastError();
        
        print_error("WSASendTo failed: %u (0x%X)\n", dwStatus, dwStatus);

        pNetAddr->dwTxTransfered = 0;
    }

    return(pNetAddr->dwTxTransfered);
}

void PrintPacket(
        FILE            *output,
        PcktHdr_t       *pPcktHdr,
        DWORD            dwTransfered,
        double           Ai
    )
{
    NetAddr_t       *pNetAddr;
    double           SendTime;
    double           EchoTime;

    if (dwTransfered >= sizeof(PcktHdr_t))
    {
        SendTime = (double)ntohl(pPcktHdr->SendNTP_sec);
        SendTime += ((double)ntohl(pPcktHdr->SendNTP_frac) / 4294967296.0);

        EchoTime = (double)ntohl(pPcktHdr->EchoNTP_sec);
        EchoTime += ((double)ntohl(pPcktHdr->EchoNTP_frac) / 4294967296.0);
        
        fprintf(output,
                "%u %0.6f %0.6f %0.6f %u\n",
                ntohl(pPcktHdr->dwSeq),
                SendTime,
                EchoTime,
                Ai,
                dwTransfered);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\tools\udpecho\udpecho.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 2001
 *
 *  File name:
 *
 *    udpecho.c
 *
 *  Abstract:
 *
 *    This file implements a tool for echoing UDP packets
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2001/05/18 created
 *
 **********************************************************************/

#include "common.h"
#include <signal.h>

#include "udpecho.h"

/* Packets are send in blocks separated by gaps, each block containing
   N packets also separated by an specific gap, i.e:

        block 1          block gap    block 2           block gap ...
   |--------------------|---------|--------------------|--------- ...
    -- -- -- -- -- -- --
      v
    \-|-------v--------/ \------v/
      |       |                 |
      |  Packets per block      |
      |                         Inter block gap
      Inter packet gap
*/

/*
  TODO list

  1. Add support for QOS in unicast/multicast
  
*/

void print_help(char *prog)
{
    char             sLocal[16];
    char             sAddr[16];

    fprintf(stderr,
            "Windows Real-Time Communications %s v%2.1f\n"
            "echo packets from/to a unicast or multicast address\n"
            "to/from another unicast or multicast address\n"
            "usage: %s "
            "[-i addr] address[/port[/ttl]] "
            "[[-i addr] address[/port[/ttl]]]\n"
            "options are:\n"
            "    -h, -?           : this help\n"
            "    -i addr          : select local interface "
            "(must preceed address)\n"
            "    address/port/ttl : address, port and ttl\n",
            prog, APP_VERSION, prog
        );
}

void InitEchoStream(EchoStream_t *pEchoStream)
{
    NetAddr_t       *pNetAddr;
    int              i;
    
    ZeroMemory(pEchoStream, sizeof(*pEchoStream));

    for(i = 0; i < 2; i++)
    {
        pEchoStream->NetAddr[i].Socket = INVALID_SOCKET;
        
        pEchoStream->NetAddr[i].wPort[REMOTE_IDX] = htons(DEFAULT_PORT);
        pEchoStream->NetAddr[i].wPort[LOCAL_IDX] = htons(DEFAULT_PORT);
    }
}

DWORD ProcessParameters(EchoStream_t *pEchoStream, int argc, char **argv)
{
    int              p;
    DWORD            dwError;
    NetAddr_t       *pNetAddr;

    dwError = NOERROR;

    for(p = 1; p < argc && dwError == NOERROR; p++)
    {
        if (*argv[p] == '-' || *argv[p] == '/')
        {
            switch(argv[p][1])
            {
            case 'h':
            case 'H':
            case '?':
                print_help(argv[0]);
                dwError = 1;
                break;
            case 'i':
                p++;
                pNetAddr = &pEchoStream->NetAddr[pEchoStream->dwAddrCount % 2];
                pNetAddr->dwAddr[LOCAL_IDX] = IPAtoN(argv[p]);
                break;
            default:
                print_error("unknown option:>>> %s <<<\n", argv[p]);
                dwError = 1;
            }
        }
        else
        {
            /* Must be an address/port/ttl */
            
            dwError = GetNetworkAddress(
                    &pEchoStream->NetAddr[pEchoStream->dwAddrCount % 2],
                    argv[p]);

            if (dwError == NOERROR)
            {
                pEchoStream->dwAddrCount++;
            }
        }
    }

    if (pEchoStream->dwAddrCount < 1)
    {
        dwError = 1;
    }

    return(dwError);
}


void ProcessPacket(EchoStream_t *pEchoStream, int Entry)
{
    DWORD            dwError;
    double           Ai;
    PcktHdr_t       *pHdr;
    NetAddr_t       *pNetAddr;
    
    pEchoStream->WSABuf.len = MAX_BUFFER_SIZE;
    pEchoStream->WSABuf.buf = pEchoStream->buffer;

    pNetAddr = &pEchoStream->NetAddr[Entry];
    
    ReceivePacket(pNetAddr,
                  &pEchoStream->WSABuf,
                  1,
                  &Ai);

    if (pNetAddr->dwRxTransfered > 0)
    {
        pHdr = (PcktHdr_t *)pEchoStream->buffer;

        /* Set the echo time */
        pHdr->EchoNTP_sec = (DWORD) Ai;

        pHdr->EchoNTP_frac = (DWORD)
            ( (Ai - (double) pHdr->EchoNTP_sec) * 4294967296.0 );

        pHdr->EchoNTP_sec = htonl(pHdr->EchoNTP_sec);

        pHdr->EchoNTP_frac = htonl(pHdr->EchoNTP_frac);

        /* Send packet back */

        pEchoStream->WSABuf.len = pNetAddr->dwRxTransfered;
        
        pNetAddr = &pEchoStream->NetAddr[1 - Entry];
        
        SendPacket(pNetAddr,
                   &pEchoStream->WSABuf,
                   1);
    }
}

BOOL             g_bExit = FALSE;

void __cdecl Signal_Ctrl_C(int sig)
{
    g_bExit = TRUE;
}

void __cdecl main(int argc, char **argv)
{
    DWORD            dwError;
    int              iStatus;
    EchoStream_t     EchoStream;
    struct timeval   timeval;
    fd_set           fdReceivers;
    
    DWORD            i;

    /* Initialize stream's structure */
    InitEchoStream(&EchoStream);
    
    InitReferenceTime();
    
    /* initialize winsock */
    dwError = InitWinSock();

    if (dwError)
    {
        print_error("WSAStartup failed to initialize:%u\n", dwError);

        return;
    }
    
    /* Read parameters */
    if (argc > 1)
    {
        dwError = ProcessParameters(&EchoStream, argc, argv);

        if (dwError != NOERROR)
        {
            goto end;
        }
    }
    else
    {
        print_help(argv[0]);

        goto end;
    }

    /* Init Network */
    for(i = 0; i < EchoStream.dwAddrCount; i++)
    {
        dwError = InitNetwork(&EchoStream.NetAddr[i],
                              BitPar2(RECV_IDX, SEND_IDX));

        if (dwError != NOERROR)
        {
            goto end;
        }
    }

    /* If only 1 address was given, use it to receive and echo */
    if (EchoStream.dwAddrCount == 1)
    {
        /* Echo to the same */
        EchoStream.NetAddr[1] = EchoStream.NetAddr[0];
    }
    
    /* Prepare for asynchronous IO */
    FD_ZERO(&fdReceivers);

    timeval.tv_sec = 0;
    timeval.tv_usec = 250000;

    /* Handle Ctrl-C */
    signal(SIGINT, Signal_Ctrl_C);

    /* Start listening */
    do {
        /* Prepare for asynchronous IO */
        for(i = 0; i < EchoStream.dwAddrCount; i++)
        {
            FD_SET(EchoStream.NetAddr[i].Socket, &fdReceivers);
        }

        iStatus = select(0, &fdReceivers, NULL, NULL, &timeval);

        switch(iStatus)
        {
        case SOCKET_ERROR:
            dwError = WSAGetLastError();
           
            print_error("select: %u (0x%X)", dwError, dwError);

            break;
        case 0:
            /* Timer expired */
            break;
        default:
            /* We received a packet */
            for(i = 0; i < EchoStream.dwAddrCount; i++)
            {
                if (FD_ISSET(EchoStream.NetAddr[i].Socket, &fdReceivers))
                {
                    ProcessPacket(&EchoStream, i);
                }
            }
         }
    } while(!g_bExit);

    dwError = NOERROR;      

 end:
    for(i = 0; i < EchoStream.dwAddrCount; i++)
    {
        DeinitNetwork(&EchoStream.NetAddr[i]);
    }
    
    DeinitWinSock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\tools\udprecv\udprecv.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 2001
 *
 *  File name:
 *
 *    udpsend.c
 *
 *  Abstract:
 *
 *    This file implements a tool for receiving UDP packets with
 *    specific network characteristics.
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2001/01/18 created
 *
 **********************************************************************/

#include "common.h"
#include "udprecv.h"

void print_help(char *prog)
{
    char             sLocal[16];
    char             sAddr[16];
    
    fprintf(stderr,
            "Windows Real-Time Communications %s v%2.1f\n"
            "receive packets in unicast or from a multicast address\n"
            "usage: %s [<options>] [address[/port]]\n"
            "options are:\n"
            "    -h, -?           : this help\n"
            "    -i addr          : select local interface [%s]\n"
            "    -o file          : send output to file [stdout]\n"
            "                     : if file equal null, don't output\n"
            "    address/port     : address/port [%s/%u]\n",
            prog, APP_VERSION, prog,
            IPNtoA(DEFAULT_LOC_ADDR, sLocal),
            IPNtoA(DEFAULT_ADDR, sAddr),
            DEFAULT_PORT
        );
}

void InitPacketStream(RecvStream_t *pRecvStream)
{
    NetAddr_t       *pNetAddr;
    
    ZeroMemory(pRecvStream, sizeof(*pRecvStream));

    pNetAddr = &pRecvStream->NetAddr;

    pRecvStream->output = stdout;
    
    pNetAddr->wPort[LOCAL_IDX] = htons(DEFAULT_PORT);
    pNetAddr->wPort[REMOTE_IDX] = htons(DEFAULT_PORT);
    pNetAddr->dwAddr[REMOTE_IDX] = DEFAULT_ADDR;
}

DWORD UdpReceivePacket(RecvStream_t *pRecvStream)
{
    DWORD            dwStatus;
    DWORD            dwError;
    DWORD            dwFlags;
    DWORD            dwFromLen;
    NetAddr_t       *pNetAddr;

    pNetAddr = &pRecvStream->NetAddr;

    dwFlags = 0;

    pRecvStream->WSABuf.buf = pRecvStream->buffer;

    pRecvStream->WSABuf.len = MAX_BUFFER_SIZE;

    dwFromLen = sizeof(pNetAddr->From);

    ReceivePacket(pNetAddr,
                  &pRecvStream->WSABuf,
                  1,
                  &pRecvStream->Ai);
    
    return(pNetAddr->dwRxTransfered);
}

void UdpPrintPacket(RecvStream_t *pRecvStream)
{
    NetAddr_t       *pNetAddr;
    PcktHdr_t       *pPcktHdr;

    pNetAddr = &pRecvStream->NetAddr;
    
    PrintPacket(pRecvStream->output,
                (PcktHdr_t *)pRecvStream->buffer,
                pNetAddr->dwRxTransfered,
                pRecvStream->Ai);
    
    pRecvStream->dwBytesRecv += pNetAddr->dwRxTransfered;
    pRecvStream->dwPacketsRecv++;
}

DWORD ProcessParameters(RecvStream_t *pRecvStream, int argc, char **argv)
{
    int              p;
    DWORD            dwError;
    NetAddr_t       *pNetAddr;

    dwError = NOERROR;
    pNetAddr = &pRecvStream->NetAddr;

    for(p = 1; p < argc && dwError == NOERROR; p++)
    {
        if (*argv[p] == '-' || *argv[p] == '/')
        {
            switch(argv[p][1])
            {
            case 'h':
            case 'H':
            case '?':
                print_help(argv[0]);
                dwError = 1;
                break;
            case 'i':
                p++;
                pNetAddr->dwAddr[LOCAL_IDX] = IPAtoN(argv[p]);
                break;
            case 'o':
                p++;
                strcpy(pRecvStream->FileName, argv[p]);
                if (!_stricmp(pRecvStream->FileName, "null"))
                {
                    BitSet(pRecvStream->dwOptions, OP_DISCARD);
                }
                break;
            default:
                print_error("unknown option:>>> %s <<<\n", argv[p]);
                dwError = 1;
            }
        }
        else
        {
            /* Must be a and address/port */
            dwError = GetNetworkAddress(pNetAddr, argv[p]);
        }
    }

    return(dwError);
}

void __cdecl main(int argc, char **argv)
{
    DWORD            dwError;
    DWORD            dwSize;
    RecvStream_t     RecvStream;
    
    /* Initialize stream's structure */
    InitPacketStream(&RecvStream);

    InitReferenceTime();
    
    /* initialize winsock */
    dwError = InitWinSock();

    if (dwError)
    {
        print_error("WSAStartup failed to initialize:%u\n", dwError);

        return;
    }
    
    /* Read parameters */
    if (argc > 1)
    {
        dwError = ProcessParameters(&RecvStream, argc, argv);

        if (dwError != NOERROR)
        {
            goto end;
        }
    }

    /* Init Network */
    dwError = InitNetwork(&RecvStream.NetAddr, BitPar(RECV_IDX));

    if (dwError != NOERROR)
    {
        goto end;
    }

    /* Open output file if needed */
    if (strlen(RecvStream.FileName) > 0 &&
        !BitTest(RecvStream.dwOptions, OP_DISCARD))
    {
        RecvStream.output = fopen(RecvStream.FileName, "w");

        if (!RecvStream.output)
        {
            print_error("fopen failed to create file: %s\n",
                        RecvStream.FileName);

            dwError = 1;
            
            goto end;
        }
    }
    
    /* Receive packets */
    do {
        dwSize = UdpReceivePacket(&RecvStream);

        if (!BitTest(RecvStream.dwOptions, OP_DISCARD))
        {
            UdpPrintPacket(&RecvStream);
        }
    } while (dwSize > BYE_PACKET_SIZE);

    /* Close output file if needed */
    if (RecvStream.output && RecvStream.output != stdout)
    {
        fclose(RecvStream.output);
    }
    
 end:
    DeinitNetwork(&RecvStream.NetAddr);

    DeinitWinSock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\rtp\tools\udpsend\udpsend.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 2001
 *
 *  File name:
 *
 *    udpsend.c
 *
 *  Abstract:
 *
 *    This file implements a tool for sending UDP packets with
 *    specific network characteristics.
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2001/01/16 created
 *
 **********************************************************************/

#include "common.h"
#include "udpsend.h"

/* Packets are send in blocks separated by gaps, each block containing
   N packets also separated by an specific gap, i.e:

        block 1          block gap    block 2           block gap ...
   |--------------------|---------|--------------------|--------- ...
    -- -- -- -- -- -- --
      v
    \-|-------v--------/ \------v/
      |       |                 |
      |  Packets per block      |
      |                         Inter block gap
      Inter packet gap
*/

/*
  TODO list

  1. Add support for QOS in unicast/multicast
  
*/

void print_help(char *prog)
{
    char             sLocal[16];
    char             sAddr[16];

    fprintf(stderr,
            "Windows Real-Time Communications %s v%2.1f\n"
            "send packets to a unicast or multicast address\n"
            "usage: %s [<options>] [address[/port[/ttl]]]\n"
            "options are:\n"
            "    -h, -?           : this help\n"
            "    -p packets       : number of packets [%u]\n"
            "    -b blocks        : number of blocks [%u]\n"
            "    -g gap           : inter packet gap (ms) [%u]\n"
            "    -G gap           : inter block gap (ms) [%u]\n"
            "    -s size          : packet size (bytes) [%u]\n"
            "    -i addr          : select local interface [%s]\n"
            "    -t timeout       : time to do active wait (ms) [%u]\n"
            "    -o file          : send output to file (implies -R) [stdout]\n"
            "    -R               : send and receive (used with udpecho)\n"
            "    -dr              : fill with random data (minimize compression)\n"
            "    address/port/ttl : address/port [%s/%u/u:%u|m:%u]\n",
            prog, APP_VERSION, prog,
            DEFAULT_PACKETS,
            DEFAULT_BLOCKS,
            DEFAULT_PACKETGAP,
            DEFAULT_BLOCKGAP,
            DEFAULT_PACKETSIZE,
            IPNtoA(DEFAULT_LOC_ADDR, sLocal),
            DEFAULT_TIMEOUT,
            IPNtoA(DEFAULT_ADDR, sAddr),
            DEFAULT_PORT,
            DEFAULT_UCAST_TTL, DEFAULT_MCAST_TTL
        );
}

void InitPacketStream(SendStream_t *pSendStream)
{
    NetAddr_t       *pNetAddr;
    
    ZeroMemory(pSendStream, sizeof(*pSendStream));

    pSendStream->output = stdout;

    /* Prepare for asynchronous IO */
    FD_ZERO(&pSendStream->fdReceivers);
   
    pNetAddr = &pSendStream->NetAddr;
    
    pSendStream->dwBlocks = DEFAULT_BLOCKS;
    pSendStream->dwPackets = DEFAULT_PACKETS;
    pSendStream->dwBlockGap = DEFAULT_BLOCKGAP;
    pSendStream->dwPacketGap= DEFAULT_PACKETGAP;
    pSendStream->dwPacketSize = DEFAULT_PACKETSIZE;
    pSendStream->dwAdvanceTimeout = DEFAULT_TIMEOUT;
    
    pNetAddr->Socket = INVALID_SOCKET;
    pNetAddr->wPort[REMOTE_IDX] = htons(DEFAULT_PORT);
    pNetAddr->wPort[LOCAL_IDX] = htons(DEFAULT_PORT);
    pNetAddr->dwAddr[REMOTE_IDX] = DEFAULT_ADDR;
}

void FillBuffer(SendStream_t *pSendStream)
{
    double           dTime;
    DWORD            dwSecs;
    PcktHdr_t       *pHdr;
    DWORD            i;

    dTime = GetTimeOfDay();

    pHdr = (PcktHdr_t *)pSendStream->buffer;
    ZeroMemory(pHdr, sizeof(PcktHdr_t));
    
    pHdr->dwSeq = htonl(pSendStream->dwPacketsSent);

    pHdr->SendNTP_sec = (DWORD) dTime;

    pHdr->SendNTP_frac = (DWORD)
        ( (dTime - (double) pHdr->SendNTP_sec) * 4294967296.0 );

    pHdr->SendNTP_sec = htonl(pHdr->SendNTP_sec);

    pHdr->SendNTP_frac = htonl(pHdr->SendNTP_frac);

    /* Optionally may fill remaining buffer with something */
    if (BitTest(pSendStream->dwOptions, OP_RANDOMDATA))
    {
        for(i = sizeof(PcktHdr_t); i < pSendStream->dwPacketSize; i++)
        {
            pSendStream->buffer[i] = rand() ^ rand();
        }
    }
}

void UdpSendPacket(SendStream_t *pSendStream)
{
    /* Optionally fill buffer with something */
    FillBuffer(pSendStream);

    SendPacket(&pSendStream->NetAddr, &pSendStream->WSABuf, 1);
            
    if (pSendStream->NetAddr.dwTxTransfered >= sizeof(PcktHdr_t))
    {
        /* Count normal (valid) packets but not the shorter bye
         * packets */
        pSendStream->dwBytesSent += pSendStream->NetAddr.dwTxTransfered;
        pSendStream->dwPacketsSent++;
    }
}

/* Send packets with size shorter than valid to signal the receiver
 * the end of the sequence */
void SendBye(SendStream_t *pSendStream)
{
    DWORD            i;
    DWORD            OldLen;

    OldLen = pSendStream->WSABuf.len;
    pSendStream->WSABuf.len = BYE_PACKET_SIZE;
    
    for(i = 0; i < MAX_BYE_PACKETS; i++)
    {
        UdpSendPacket(pSendStream);
    }

    pSendStream->WSABuf.len = OldLen;
}

DWORD ProcessParameters(SendStream_t *pSendStream, int argc, char **argv)
{
    int              p;
    DWORD            dwError;
    NetAddr_t       *pNetAddr;

    dwError = NOERROR;
    pNetAddr = &pSendStream->NetAddr;

    for(p = 1; p < argc && dwError == NOERROR; p++)
    {
        if (*argv[p] == '-' || *argv[p] == '/')
        {
            switch(argv[p][1])
            {
            case 'h':
            case 'H':
            case '?':
                print_help(argv[0]);
                dwError = 1;
                break;
            case 'p':
                p++;
                pSendStream->dwPackets = atoi(argv[p]);
                break;
            case 'b':
                p++;
                pSendStream->dwBlocks = atoi(argv[p]);
                break;
            case 'g':
                p++;
                pSendStream->dwPacketGap = atoi(argv[p]);
                break;
            case 'G':
                p++;
                pSendStream->dwBlockGap = atoi(argv[p]);
                break;
            case 'i':
                p++;
                pNetAddr->dwAddr[LOCAL_IDX] = IPAtoN(argv[p]);
                break;
            case 's':
                p++;
                pSendStream->dwPacketSize = atoi(argv[p]);
                if (pSendStream->dwPacketSize > MAX_BUFFER_SIZE)
                {
                    pSendStream->dwPacketSize = MAX_BUFFER_SIZE;
                }
                else if (pSendStream->dwPacketSize < sizeof(PcktHdr_t))
                {
                    pSendStream->dwPacketSize = sizeof(PcktHdr_t);
                }
                break;
            case 't':
                p++;
                pSendStream->dwAdvanceTimeout = atoi(argv[p]);
                break;
            case 'o':
                p++;
                strcpy(pSendStream->FileName, argv[p]);
                if (!_stricmp(pSendStream->FileName, "null"))
                {
                    BitSet(pSendStream->dwOptions, OP_DISCARD);
                }
            case 'R':
                BitSet(pSendStream->dwOptions, OP_SENDANDRECEIVE);
                break;
            case 'd':
                switch(argv[p][2])
                {
                case 'r':
                    BitSet(pSendStream->dwOptions, OP_RANDOMDATA);
                    break;
                }
                break;
            default:
                print_error("unknown option:>>> %s <<<\n", argv[p]);
                dwError = 1;
            }
        }
        else
        {
            /* Must be an address/port/ttl */
            dwError = GetNetworkAddress(pNetAddr, argv[p]);
        }
    }

    return(dwError);
}

void ProcessPacket(SendStream_t *pSendStream)
{
    DWORD            dwError;
    WSABUF           WSABuf;
    double           Ai;
    PcktHdr_t       *pHdr;
    NetAddr_t       *pNetAddr;
    
    WSABuf.len = MAX_BUFFER_SIZE;
    WSABuf.buf = pSendStream->buffer;

    pNetAddr = &pSendStream->NetAddr;
    
    ReceivePacket(pNetAddr,
                  &WSABuf,
                  1,
                  &Ai);

    if ((pNetAddr->dwRxTransfered > 0) &&
        !BitTest(pSendStream->dwOptions, OP_DISCARD))
    {
        PrintPacket(pSendStream->output,
                    (PcktHdr_t *)pSendStream->buffer,
                    pNetAddr->dwRxTransfered,
                    Ai);
    }
}

void WaitForNextTime(SendStream_t *pSendStream, double dNextPacket)
{
    int              iStatus;
    DWORD            dwError;
    double           dCurrTime;
    double           dDelta;
    DWORD            dwMillisecs;

    dCurrTime = GetTimeOfDay();

    dDelta = dNextPacket - dCurrTime;

    while(dDelta > 0)
    {
        pSendStream->timeval.tv_sec = (DWORD)dDelta;

        pSendStream->timeval.tv_usec = (DWORD)
            ((dDelta - pSendStream->timeval.tv_sec) * 1e6);

        if (BitTest(pSendStream->dwOptions, OP_SENDANDRECEIVE))
        {
            FD_SET(pSendStream->NetAddr.Socket, &pSendStream->fdReceivers);
        
            iStatus = select(0,
                             &pSendStream->fdReceivers,
                             NULL, NULL,
                             &pSendStream->timeval);
            
            switch(iStatus)
            {
            case SOCKET_ERROR:
                dwError = WSAGetLastError();
            
                print_error("select: %u (0x%X)", dwError, dwError);
                
                break;
            case 0:
                /* Timer expired */
                break;
            default:
                /* We received a packet */
                if (FD_ISSET(pSendStream->NetAddr.Socket,
                             &pSendStream->fdReceivers))
                {
                    ProcessPacket(pSendStream);
                }
            }
        }
        else
        {
            SleepEx((DWORD)(dDelta * 1000), FALSE);
        }

        dCurrTime = GetTimeOfDay();

        dDelta = dNextPacket - dCurrTime;
    }
}


void __cdecl main(int argc, char **argv)
{
    DWORD            dwError;
    DWORD            dwDirection;
    SendStream_t     SendStream;
    
    DWORD            dwNBlocks;
    DWORD            dwPacketsPerBlock;
    DWORD            dwInterBlockGap;   /* millisecs */
    DWORD            dwInterpacketGap;  /* millisecs */
    
    /* Initialize stream's structure */
    InitPacketStream(&SendStream);

    InitReferenceTime();
    
    /* initialize winsock */
    dwError = InitWinSock();

    if (dwError)
    {
        print_error("WSAStartup failed to initialize:%u\n", dwError);

        return;
    }
    
    /* Read parameters */
    if (argc > 1)
    {
        dwError = ProcessParameters(&SendStream, argc, argv);

        if (dwError != NOERROR)
        {
            goto end;
        }
    }

    /* Open output file if needed */
    if (strlen(SendStream.FileName) > 0 &&
        !BitTest(SendStream.dwOptions, OP_DISCARD))
    {
        SendStream.output = fopen(SendStream.FileName, "w");

        if (!SendStream.output)
        {
            print_error("fopen failed to create file: %s\n",
                        SendStream.FileName);

            dwError = 1;
            
            goto end;
        }
    }

    /* Init Network */
    dwDirection = BitPar(SEND_IDX);

    if (BitTest(SendStream.dwOptions, OP_SENDANDRECEIVE))
    {
        dwDirection |= BitPar(RECV_IDX); 
    }
    
    dwError = InitNetwork(&SendStream.NetAddr, dwDirection);

    if (dwError != NOERROR)
    {
        goto end;
    }

    /* Initialize sender's data buffer */
    SendStream.WSABuf.buf = SendStream.buffer;
    SendStream.WSABuf.len = SendStream.dwPacketSize;
    
    /* Send packets */
    SendStream.dNextPacket = GetTimeOfDay();

    for(SendStream.dwBlockCount = SendStream.dwBlocks;
        SendStream.dwBlockCount > 0;
        SendStream.dwBlockCount--)
    {
        for(SendStream.dwPacketCount = SendStream.dwPackets;
            SendStream.dwPacketCount > 0;
            SendStream.dwPacketCount--)
        {
            UdpSendPacket(&SendStream);

            if (SendStream.dwPacketCount > 1)
            {
                SendStream.dNextPacket +=
                    (double)SendStream.dwPacketGap/1000.0;

                /* Set time to wait until next packet is due to be
                 * send, listen for packets in the mean time */
                WaitForNextTime(&SendStream, SendStream.dNextPacket);
            }
        }

        if (SendStream.dwBlockCount > 1)
        {
            SendStream.dNextPacket +=
                (double)SendStream.dwBlockGap/1000.0;
            
            /* Wait until the time to send next block comes */
            WaitForNextTime(&SendStream, SendStream.dNextPacket);
        }
    }

    if (BitTest(SendStream.dwOptions, OP_SENDANDRECEIVE))
    {
        /* Wait until the time to send next block comes */
        WaitForNextTime(&SendStream, GetTimeOfDay() + 1.0);
    }

    /* Send bye packets */
    SendBye(&SendStream);
    
#if 0
    fprintf(stdout, "Packets sent: %u\nBytes Sent: %u\n",
            SendStream.dwPacketsSent,
            SendStream.dwBytesSent);
#endif       
 end:
    DeinitNetwork(&SendStream.NetAddr);
    
    DeinitWinSock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\sources.inc ===
!IF 0

Copyright (c) 1996  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    Common makefile for ActiveMovie filters.

Revision History:

    06-Nov-1996 DonRyan
        Created.

!ENDIF

###############################################################################
#                                                                             #
#  Private Definitions                                                        #
#                                                                             #
###############################################################################

TARGETEXT=dll

###############################################################################
#                                                                             #
#  Debug Support                                                              #
#                                                                             #
###############################################################################

!if !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) -DDEBUG
!endif


###############################################################################
#                                                                             #
#  Profile Support                                                            #
#                                                                             #
###############################################################################

!IF "$(NTPROFILE)" == ""
STRM_PROFILE_FLAG=
STRM_PROFILE_LIB=
!ELSE
!    IF "($NTPROFILE)" == "cap"
STRM_PROFILE_FLAG=-Gp
STRM_PROFILE_LIB=$(SDK_LIB_PATH)\cap.lib
!    ELSE
!        IF "$(NTPROFILE)" == "wst"
STRM_PROFILE_FLAG=-Gp
STRM_PROFILE_LIB=$(SDK_LIB_PATH)\wst.lib
!        ELSE
!            error NTPROFILE macro can be either "", "cap", or "wst"
!        ENDIF
!    ENDIF
!ENDIF

###############################################################################
#                                                                             #
#  Global Definitions                                                         #
#                                                                             #
###############################################################################

DLLENTRY=DllEntryPoint
MSC_WARNING_LEVEL=/W3 /WX
NOT_LEAN_AND_MEAN=1
USE_CRTDLL=1
386_FLAGS=$(STRM_PROFILE_FLAG)

#Compatibility with Memphis
SUBSYSTEM_VERSION=4.00

!IF defined (USE_DYNGRAPH)
C_DEFINES=$(C_DEFINES) -DDYNGRAPH
!endif

###############################################################################
#                                                                             #
#  Includes                                                                   #
#                                                                             #
###############################################################################

INCLUDES=\
    $(BASEDIR)\public\sdk\amovie\inc; \
    ..\inc; \
    ..\..\inc; \
    ..\..\..\inc; \
    ..\..\..\..\inc; \

###############################################################################
#                                                                             #
#  Link Libraries                                                             #
#                                                                             #
###############################################################################

!if defined (USE_DYNGRAPH)
LINKLIBS=\
    $(BASEDIR)\public\sdk\amovie\lib\*\strmbase.lib
!else

!if $(FREEBUILD)
LINKLIBS=\
    $(SDK_LIB_PATH)\strmbase.lib
!else
C_DEFINES=$(C_DEFINES) -DDEBUG
LINKLIBS=\
    $(SDK_LIB_PATH)\strmbasd.lib
!endif

!endif

###############################################################################
#                                                                             #
#  Target Libraries                                                           #
#                                                                             #
###############################################################################

TARGETLIBS=\
    $(SDK_LIB_PATH)\vfw32.lib    \
    $(SDK_LIB_PATH)\comctl32.lib \
    $(SDK_LIB_PATH)\winmm.lib    \
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SDK_LIB_PATH)\user32.lib   \
    $(SDK_LIB_PATH)\version.lib  \
    $(SDK_LIB_PATH)\gdi32.lib    \
    $(SDK_LIB_PATH)\ole32.lib    \
    $(SDK_LIB_PATH)\oleaut32.lib \
    $(SDK_LIB_PATH)\uuid.lib     \
    $(STRM_PROFILE_LIB)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\utils\tptrace.cpp ===
/*++

    Copyright (c) 1997 Microsoft Corporation

Module Name:

    tptrace.cpp

Abstract:

    This file contains the function that implements a basic tracing for
    all the filters.

Author:

    Mu Han (muhan) April-17-2000

--*/
#include <windows.h>
#include <mmsystem.h>
#include <tptrace.h>

#if DBG

const char * TraceLevels[] = 
{
    "ERROR", 
    "WARNING", 
    "INFO", 
    "TRACE", 
    "ELSE",
    "INVALID TRACE LEVEL"
};

void DBGPrint(DWORD dwTraceID, DWORD dwDbgLevel, LPCSTR lpszFormat, IN ...)
/*++

Routine Description:

    Formats the incoming debug message & calls TraceVprintfEx to print it.

Arguments:

    dwDbgLevel   - The type of the message.

    lpszFormat - printf-style format string, followed by appropriate
                 list of arguments

Return Value:

--*/
{
    #define MAXDEBUGSTRINGLENGTH 512
    char  szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];
    
    DWORD dwIndex;
    double dTime;
    DWORD  dwSecs;

    switch(dwDbgLevel)
    {
    case FAIL: dwIndex = 0; break;
    case WARN: dwIndex = 1; break;
    case INFO: dwIndex = 2; break;
    case TRCE: dwIndex = 3; break;
    case ELSE: dwIndex = 4; break;
    default:   dwIndex = 5; break;
    }

    dTime = RtpGetTimeOfDay(NULL);
    dwSecs = (DWORD)dTime;
    
    wsprintfA(szTraceBuf, "%u.%03u[%s] %s",
              dwSecs, (DWORD)((dTime - dwSecs) * 1000),
              TraceLevels[dwIndex], lpszFormat);

    va_list arglist;
    va_start(arglist, lpszFormat);
    TraceVprintfExA(dwTraceID, dwDbgLevel, szTraceBuf, arglist);
    va_end(arglist);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\utils\tpdbg.c ===
/**********************************************************************
 *
 *  Copyright (C) Microsoft Corporation, 1999
 *
 *  File name:
 *
 *    tpdbg.c
 *
 *  Abstract:
 *
 *    Some debuging support for TAPI filters
 *
 *  Author:
 *
 *    Andres Vega-Garcia (andresvg)
 *
 *  Revision:
 *
 *    2000/08/31 created
 *
 **********************************************************************/

#include <windows.h>
#include <tpdbg.h>

AudCritSect_t     g_AudCritSect;
Queue_t           g_AudObjectsQ;
const TCHAR      *g_psAudIds[] = {
    TEXT("unknown"),
    
    TEXT("AUDENCHANDLER"),
    TEXT("AUDCAPINPIN"),
    TEXT("AUDCAPOUTPIN"),
    TEXT("AUDCAPFILTER"),
    TEXT("AUDDECINPIN"),
    TEXT("AUDDECOUTPIN"),
    TEXT("AUDDECFILTER"),
    TEXT("AUDENCINPIN"),
    TEXT("AUDENCOUTPIN"),
    TEXT("AUDENCFILTER"),
    TEXT("AUDMIXINPIN"),
    TEXT("AUDMIXOUTPIN"),
    TEXT("AUDMIXFILTER"),
    TEXT("AUDRENINPIN"),
    TEXT("AUDRENFILTER"),
    NULL
};

QueueItem_t *AudEnqueue(
        Queue_t         *pHead,
        CRITICAL_SECTION *pCritSect,
        QueueItem_t     *pItem
    );

QueueItem_t *AudDequeue(
        Queue_t         *pHead,
        CRITICAL_SECTION *pCritSect,
        QueueItem_t     *pItem
    );

void AudInit()
{
    DWORD            SpinCount;

    ZeroMemory(&g_AudObjectsQ, sizeof(g_AudObjectsQ));
    
    g_AudCritSect.bInitOk = FALSE;
    
    /* Set bit 31 to 1 to preallocate the event object, and set
     * the spin count that is used in multiprocessor environments
     * */
    SpinCount = 0x80000000 | 1000;
    
    if (InitializeCriticalSectionAndSpinCount(&g_AudCritSect.CritSect,
                                              SpinCount))
    {
        g_AudCritSect.bInitOk = TRUE;
    }
}

void AudDeinit()
{
    if (g_AudCritSect.bInitOk)
    {
        DeleteCriticalSection(&g_AudCritSect.CritSect);

        g_AudCritSect.bInitOk = FALSE;
    }
}

void AudObjEnqueue(QueueItem_t *pQueueItem, DWORD dwObjectID)
{
    if (g_AudCritSect.bInitOk)
    {
        AudEnqueue(&g_AudObjectsQ, &g_AudCritSect.CritSect, pQueueItem);

        pQueueItem->dwKey =  dwObjectID;
    }
}

void AudObjDequeue(QueueItem_t *pQueueItem)
{
    if (g_AudCritSect.bInitOk)
    {
        AudDequeue(&g_AudObjectsQ, &g_AudCritSect.CritSect, pQueueItem);
    }
}

/* enqueue at the end */
QueueItem_t *AudEnqueue(
        Queue_t         *pHead,
        CRITICAL_SECTION  *pCritSect,
        QueueItem_t     *pItem
    )
{
    BOOL             bOk;
    DWORD            dwError;
    QueueItem_t     *pQueueItem;
    Queue_t         *pItempHead;

    pQueueItem = (QueueItem_t *)NULL;
    
    EnterCriticalSection(pCritSect);
    
    if (pItem->pHead)
    {
        goto error;
    }
    
    if (pHead->pFirst)
    {
        /* not empty */
        pItem->pNext = pHead->pFirst;
        pItem->pPrev = pHead->pFirst->pPrev;
        pItem->pPrev->pNext = pItem;
        pItem->pNext->pPrev = pItem;
        pHead->lCount++;
    }
    else
    {
        /* empty */
        pHead->lCount = 1;
        pHead->pFirst = pItem;
        pItem->pNext  = pItem;
        pItem->pPrev  = pItem;
    }

    pItem->pHead = pHead;
    
    LeaveCriticalSection(pCritSect);

    pQueueItem = pItem;
    
    return(pQueueItem);

 error:
    LeaveCriticalSection(pCritSect);

    return(pQueueItem);
}

/* dequeue item pItem */
QueueItem_t *AudDequeue(
        Queue_t         *pHead,
        CRITICAL_SECTION *pCritSect,
        QueueItem_t     *pItem
    )
{
    BOOL             bOk;
    DWORD            dwError;
    QueueItem_t     *pQueueItem;
    Queue_t         *pItempHead;

    pQueueItem = (QueueItem_t *)NULL;
    
    EnterCriticalSection(pCritSect);
    
    if (pItem->pHead != pHead)
    {
        goto error;
    }

    if (pHead->lCount > 1)
    {
        /* 2 or more items */
        if (pHead->pFirst == pItem)
        {
            pHead->pFirst = pItem->pNext;
        }
        pItem->pPrev->pNext = pItem->pNext;
        pItem->pNext->pPrev = pItem->pPrev;
        pHead->lCount--;
    }
    else
    {
        /* just 1 item */
        pHead->pFirst = (QueueItem_t *)NULL;
        pHead->lCount = 0;
    }

    LeaveCriticalSection(pCritSect);
    
    pItem->pNext = (QueueItem_t *)NULL;
    pItem->pPrev = (QueueItem_t *)NULL;
    pItem->pHead = NULL;

    pQueueItem = pItem;
    
    return(pQueueItem);

 error:
    LeaveCriticalSection(pCritSect);

    return(pQueueItem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\inc\h245vid.h ===
/****************************************************************************
 *  @doc INTERNAL H245VID
 *
 *  @module h245vid.h | Header file for the <c CTAPIVCap> class and
 *  <c CTAPIVDec> methods used to implement the <i IH245Capability>
 *  TAPI inteface.
 *
 *  @comm For now, use the NM heuristics.
 ***************************************************************************/
#ifndef _h245vid_h_
#define _h245vid_h_

// Define four classes of CPU
#define SLOW_CPU_MHZ 110
#define FAST_CPU_MHZ 200
#define VERYFAST_CPU_MHZ 400

// Define maximum receive frame rates for CPUs < 110MHZ
#define CIF_RATE_VERYSLOW 3L
#define SQCIF_RATE_VERYSLOW 7L
#define QCIF_RATE_VERYSLOW 7L

// Define maximum receive frame rates for 110MHz < CPUs < 200MhZ
#define CIF_RATE_SLOW 7L
#define SQCIF_RATE_SLOW 15L
#define QCIF_RATE_SLOW 15L

// Define maximum receive frame rates for 200MHz < CPUs < 400MhZ
#define CIF_RATE_FAST 15L
#define SQCIF_RATE_FAST 30L
#define QCIF_RATE_FAST 30L

// Define maximum receive frame rates for CPUs > 400MHz
#define CIF_RATE_VERYFAST 30L
#define SQCIF_RATE_VERYFAST 30L
#define QCIF_RATE_VERYFAST 30L

// Define max CPU usage for decoding
#define MAX_CPU_USAGE 50UL

/*****************************************************************************
 *  @doc INTERNAL H245VIDCSTRUCTENUM
 *
 *  @struct VideoResourceBounds | The <t VideoResourceBounds> structure is used
 *    to specify the estimated maximum continuous resource requirements of the
 *    TAPI MSP Video Capture filter at a specific frame rate.
 *
 *  @field LONG | lPicturesPerSecond | Specifies an INTEGER value that
 *    indicates the video frame rate, in frames per second, for which the
 *    resource bounds are being specified. Frame rates of less than 1 frame
 *    per second are indicated by a negative value in units of seconds per
 *    frame.
 *
 *  @field DWORD | dwBitsPerPicture | Specifies a DWORD value that indicates
 *    the approximate average number of bits per video frame at an average
 *    frame rate of iPicturesPerSecond.
 ***************************************************************************/
typedef struct tag_VideoResourceBounds
{
    LONG  lPicturesPerSecond;
    DWORD dwBitsPerPicture;
} VideoResourceBounds;

#endif /* _h245vid_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\basepin.cpp ===
/****************************************************************************
 *  @doc INTERNAL BASEPIN
 *
 *  @module BasePin.cpp | Source file for the <c CTAPIBasePin> class methods
 *    used to implement the TAPI base output pin.
 ***************************************************************************/

#include "Precomp.h"

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | CTAPIBasePin | This method is the
 *  constructorfor the <c CTAPIBasePin> object
 *
 *  @rdesc Nada.
 ***************************************************************************/
CTAPIBasePin::CTAPIBasePin(IN TCHAR *pObjectName, IN CTAPIVCap *pCaptureFilter, IN HRESULT *pHr, IN LPCWSTR pName) : CBaseOutputPin(pObjectName, pCaptureFilter, &pCaptureFilter->m_lock, pHr, pName)
{
        FX_ENTRY("CTAPIBasePin::CTAPIBasePin")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Initialize stuff
        m_pCaptureFilter = pCaptureFilter;
        ZeroMemory(&m_parms, sizeof(m_parms));

#ifdef USE_CPU_CONTROL
        // CPU control
        m_MaxProcessingTime = 0;
        m_CurrentProcessingTime = 0;
        m_dwMaxCPULoad = 0;
        m_dwCurrentCPULoad = 0;
#endif

        // Frame rate control
        // Those default values will be fixed up later when we have
        // set a format on a capture device... unless it's a VfW
        // device since we have no programmatic way to get those values
        // from VfW drivers.
        m_lMaxAvgTimePerFrame = 333333L;
        m_lCurrentAvgTimePerFrame       = 333333L;
        m_lAvgTimePerFrameRangeMin = 333333L;
        m_lAvgTimePerFrameRangeMax = 10000000L;
        m_lAvgTimePerFrameRangeSteppingDelta = 333333L;
        m_lAvgTimePerFrameRangeDefault = 333333L;

        // Bitrate control
        m_lTargetBitrate = 0L;
        m_lCurrentBitrate = 0L;
        m_lBitrateRangeMin = 0L;
        m_lBitrateRangeMax = 0L;
        m_lBitrateRangeSteppingDelta = 0L;
        m_lBitrateRangeDefault = 0L;

        // Video mode control
        // @todo This may be fine for VfW devices but not with WDM devices.
        // WDM devices may support this in hardware. You need to query
        // the device to know if it supports this feature. If it doesn't
        // you can still provide a software only implementation for it.
        m_fFlipHorizontal = FALSE;
        m_fFlipVertical = FALSE;

        // Formats
        m_aFormats              = NULL;
        m_aCapabilities = NULL;
        m_dwNumFormats  = 0;
        m_iCurrFormat   = -1L;
        m_fFormatChanged = TRUE;

        // Fast updates - Start with an I-frame
        m_fFastUpdatePicture = TRUE;

        // Format conversion
        m_pConverter = NULL;

        // Blackbanding and cropping vs stretching
        m_fNoImageStretch = FALSE;
        m_dwBlackEntry = 0L;

#ifdef USE_SOFTWARE_CAMERA_CONTROL
        // Software-only camera control
        m_pbyCamCtrl = NULL;
        m_fSoftCamCtrl = FALSE;
        m_pbiSCCOut = NULL;
        m_pbiSCCIn = NULL;
#endif

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc void | CTAPIBasePin | ~CTAPIBasePin | This method is the destructor
 *    for the <c CTAPIBasePin> object.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CTAPIBasePin::~CTAPIBasePin()
{
        FX_ENTRY("CTAPIBasePin::~CTAPIBasePin")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | NonDelegatingQueryInterface | This
 *    method is the nondelegating interface query function. It returns a
 *    pointer to the specified interface if supported. The only interfaces
 *    explicitly supported being <i IAMStreamConfig>, <i IAMStreamControl>,
 *    <i ICPUControl>, <i IFrameRateControl> and <i IBitrateControl>.
 *
 *  @parm REFIID | riid | Specifies the identifier of the interface to return.
 *
 *  @parm PVOID* | ppv | Specifies the place in which to put the interface
 *    pointer.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::NonDelegatingQueryInterface(IN REFIID riid, OUT void **ppv)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIBasePin::NonDelegatingQueryInterface")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(ppv);
        if (!ppv)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Retrieve interface pointer
        if (riid == __uuidof(IAMStreamConfig))
        {
                if (FAILED(Hr = GetInterface(static_cast<IAMStreamConfig*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: NDQI for IAMStreamConfig failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: IAMStreamConfig*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
#ifdef USE_CPU_CONTROL
        else if (riid == __uuidof(ICPUControl))
        {
                if (FAILED(Hr = GetInterface(static_cast<ICPUControl*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: NDQI for ICPUControl failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: ICPUControl*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
#endif
        else if (riid == __uuidof(IFrameRateControl))
        {
                if (FAILED(Hr = GetInterface(static_cast<IFrameRateControl*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: NDQI for IFrameRateControl failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: IFrameRateControl*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
        else if (riid == __uuidof(IBitrateControl))
        {
                if (FAILED(Hr = GetInterface(static_cast<IBitrateControl*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: NDQI for IBitrateControl failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: IBitrateControl*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
        else if (riid == __uuidof(IVideoControl))
        {
                if (FAILED(Hr = GetInterface(static_cast<IVideoControl*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: NDQI for IVideoControl failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: IVideoControl*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }

        if (FAILED(Hr = CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, WARN, "%s:   WARNING: NDQI for {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX} failed Hr=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], Hr));
        }
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX}*=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], *ppv));
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | DecideBufferSize | This method is
 *    used to retrieve the number and size of buffers required for transfer.
 *
 *  @parm IMemAllocator* | pAlloc | Specifies a pointer to the allocator
 *    assigned to the transfer.
 *
 *  @parm ALLOCATOR_PROPERTIES* | ppropInputRequest | Specifies a pointer to an
 *    <t ALLOCATOR_PROPERTIES> structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIBasePin::DecideBufferSize(IN IMemAllocator *pAlloc, OUT ALLOCATOR_PROPERTIES *ppropInputRequest)
{
        HRESULT Hr = NOERROR;
        ALLOCATOR_PROPERTIES Actual;

        FX_ENTRY("CPreviewPin::DecideBufferSize")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pAlloc);
        ASSERT(ppropInputRequest);
        if (!pAlloc || !ppropInputRequest)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid input parameter!", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // @todo We shouldn't need that many compressed buffers and you probably need a different number
        // of buffers if you are capturing in streaming mode of frame grabbing mode
        // You also need to decouple this number from the number of video capture buffers: only
        // if you need to ship the video capture buffer downstream (possible on the preview pin)
        // should you make those number equal.
        ppropInputRequest->cBuffers = MAX_VIDEO_BUFFERS;
        ppropInputRequest->cbPrefix = 0;
        ppropInputRequest->cbAlign  = 1;
        ppropInputRequest->cbBuffer = HEADER(m_mt.pbFormat)->biSizeImage;
        ppropInputRequest->cbBuffer = (long)ALIGNUP(ppropInputRequest->cbBuffer + ppropInputRequest->cbPrefix, ppropInputRequest->cbAlign) - ppropInputRequest->cbPrefix;

        ASSERT(ppropInputRequest->cbBuffer);
        if (!ppropInputRequest->cbBuffer)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Buffer size is 0!", _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Using %d buffers, prefix %d size %d align %d", _fx_, ppropInputRequest->cBuffers, ppropInputRequest->cbPrefix, ppropInputRequest->cbBuffer, ppropInputRequest->cbAlign));

        Hr = pAlloc->SetProperties(ppropInputRequest,&Actual);

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | DecideAllocator | This method is
 *    used to negotiate the allocator to use.
 *
 *  @parm IMemInputPin* | pPin | Specifies a pointer to the IPin interface
 *    of the connecting pin.
 *
 *  @parm IMemAllocator** | ppAlloc | Specifies a pointer to the negotiated
 *    IMemAllocator interface.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIBasePin::DecideAllocator(IN IMemInputPin *pPin, OUT IMemAllocator **ppAlloc)
{
        HRESULT Hr = NOERROR;
        ALLOCATOR_PROPERTIES prop;

        FX_ENTRY("CTAPIBasePin::DecideAllocator")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pPin);
        ASSERT(ppAlloc);
        if (!pPin || !ppAlloc)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid input parameter!", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        if (FAILED(GetInterface(static_cast<IMemAllocator*>(this), (void **)ppAlloc)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: GetInterface failed!", _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

        // Get downstream allocator property requirement
        ZeroMemory(&prop, sizeof(prop));

        if (SUCCEEDED(Hr = DecideBufferSize(*ppAlloc, &prop)))
        {
                // Our buffers are not read only
                if (SUCCEEDED(Hr = pPin->NotifyAllocator(*ppAlloc, FALSE)))
                        goto MyExit;
        }

        (*ppAlloc)->Release();
        *ppAlloc = NULL;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | Active | This method is called by the
 *    <c CBaseFilter> implementation when the state changes from stopped to
 *    either paused or running.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIBasePin::Active()
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIBasePin::Active")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Do nothing if not connected -- but don't fail
        if (!IsConnected())
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   WARNING: Capture pin isn't connected yet", _fx_));
                goto MyExit;
        }

        // Let the base class know we're going from STOP->PAUSE
        if (FAILED(Hr = CBaseOutputPin::Active()))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: CBaseOutputPin::Active failed!", _fx_));
                goto MyExit;
        }

        // Check if we're already running
        if (m_pCaptureFilter->ThdExists())
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   WARNING: We're already running", _fx_));
                goto MyExit;
        }

        // Create the capture thread
        if (!m_pCaptureFilter->CreateThd())
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Coutdn't create the capture thread!", _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

        // Wait until the worker thread is done with initialization and has entered the paused state
        if (!m_pCaptureFilter->PauseThd())
        {
                // Something went wrong. Destroy thread before we get confused
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Capture thread failed to enter Paused state!", _fx_));
                Hr = E_FAIL;
                m_pCaptureFilter->StopThd();            
                m_pCaptureFilter->DestroyThd();
                goto MyExit;
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: We're going from STOP->PAUSE", _fx_));

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | Inactive | This method is called by the
 *    <c CBaseFilter> implementation when the state changes from either
 *    paused or running to stopped.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIBasePin::Inactive()
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIBasePin::Inactive")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Do nothing if not connected -- but don't fail
        if (!IsConnected())
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   WARNING: Capture pin isn't connected yet", _fx_));
                goto MyExit;
        }

        // Tell the worker thread to stop and begin cleaning up
        m_pCaptureFilter->StopThd();

        // Need to do this before trying to stop the thread, because
        // we may be stuck waiting for our own allocator!!
        // Call this first to Decommit the allocator
        if (FAILED(Hr = CBaseOutputPin::Inactive()))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: CBaseOutputPin::Inactive failed!", _fx_));
                goto MyExit;
        }

        // Wait for the worker thread to die
        m_pCaptureFilter->DestroyThd();

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: We're going from PAUSE->STOP", _fx_));

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | ActiveRun | This method is called by the
 *    <c CBaseFilter> implementation when the state changes from paused to
 *    running mode.
 *
 *  @parm REFERENCE_TIME | tStart | Who cares.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIBasePin::ActiveRun(IN REFERENCE_TIME tStart)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIBasePin::ActiveRun")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Make sure we're connected and our capture thread is up
        ASSERT(IsConnected());
        ASSERT(m_pCaptureFilter->ThdExists());
        if (!IsConnected() || !m_pCaptureFilter->ThdExists())
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Pin isn't connected or capture thread hasn't been created!", _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

        // Let the fun begin
        if (!m_pCaptureFilter->RunThd() || m_pCaptureFilter->m_state != TS_Run)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Couldn't run the capture thread!", _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: We're going from PAUSE->RUN", _fx_));

        // Fast updates - Start with an I-frame
        m_fFastUpdatePicture = TRUE;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | ActivePause | This method is called by the
 *    <c CBaseFilter> implementation when the state changes from running to
 *    paused mode.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIBasePin::ActivePause()
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIBasePin::ActivePause")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Make sure we're connected and our worker thread is up
        ASSERT(IsConnected());
        ASSERT(m_pCaptureFilter->ThdExists());
        if (!IsConnected() || !m_pCaptureFilter->ThdExists())
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Pin isn't connected or capture thread hasn't been created!", _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

        // Pause the fun
        if (!m_pCaptureFilter->PauseThd() || m_pCaptureFilter->m_state != TS_Pause)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Couldn't pause the capture thread!", _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: We're going from RUN->PAUSE", _fx_));

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | SetProperties | This method is used to
 *    specify the size, number, and alignment of blocks.
 *
 *  @parm ALLOCATOR_PROPERTIES* | pRequest | Specifies a pointer to the
 *    requested allocator properties.
 *
 *  @parm ALLOCATOR_PROPERTIES* | pActual | Specifies a pointer to the
 *    allocator properties actually set.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::SetProperties(IN ALLOCATOR_PROPERTIES *pRequest, OUT ALLOCATOR_PROPERTIES *pActual)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIBasePin::SetProperties")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pRequest);
        ASSERT(pActual);
        if (!pRequest || !pActual)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument!", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // If we have already allocated headers & buffers ignore the
        // requested and return the actual numbers. Otherwise, make a
        // note of the requested so that we can honour it later.
        if (!Committed())
        {
                m_parms.cBuffers  = pRequest->cBuffers;
                m_parms.cbBuffer  = pRequest->cbBuffer;
                m_parms.cbAlign   = pRequest->cbAlign;
                m_parms.cbPrefix  = pRequest->cbPrefix;
        }

        pActual->cBuffers   = (long)m_parms.cBuffers;
        pActual->cbBuffer   = (long)m_parms.cbBuffer;
        pActual->cbAlign    = (long)m_parms.cbAlign;
        pActual->cbPrefix   = (long)m_parms.cbPrefix;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | GetProperties | This method is used to
 *    retrieve the properties being used on this allocator.
 *
 *  @parm ALLOCATOR_PROPERTIES* | pProps | Specifies a pointer to the
 *    requested allocator properties.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::GetProperties(ALLOCATOR_PROPERTIES *pProps)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIBasePin::GetProperties")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pProps);
        if (!pProps)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument!", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        pProps->cBuffers = (long)m_parms.cBuffers;
        pProps->cbBuffer = (long)m_parms.cbBuffer;
        pProps->cbAlign  = (long)m_parms.cbAlign;
        pProps->cbPrefix = (long)m_parms.cbPrefix;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | Commit | This method is used to
 *    commit the memory for the specified buffers.
 *
 *  @rdesc This method returns S_OK.
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::Commit()
{
        FX_ENTRY("CTAPIBasePin::Commit")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

        return S_OK;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | Decommit | This method is used to
 *    release the memory for the specified buffers.
 *
 *  @rdesc This method returns S_OK.
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::Decommit()
{
        FX_ENTRY("CTAPIBasePin::Decommit")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

        return S_OK;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | GetBuffer | This method is used to
 *    retrieve a container for a sample.
 *
 *  @rdesc This method returns E_FAIL.
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::GetBuffer(IMediaSample **ppBuffer, REFERENCE_TIME *pStartTime, REFERENCE_TIME *pEndTime, DWORD dwFlags)
{
        FX_ENTRY("CTAPIBasePin::GetBuffer")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

        return E_FAIL;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | ReleaseBuffer | This method is used to
 *    release the <c CMediaSample> object. The final call to Release() on
 *    <i IMediaSample> will call this method.
 *
 *  @parm IMediaSample* | pSample | Specifies a pointer to the buffer to
 *    release.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag S_OK | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::ReleaseBuffer(IMediaSample *pSample)
{
        HRESULT Hr = S_OK;
        LPTHKVIDEOHDR ptvh;

        FX_ENTRY("CTAPIBasePin::ReleaseBuffer")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pSample);
        if (!pSample)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument!", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        if (ptvh = ((CFrameSample *)pSample)->GetFrameHeader())
                Hr = m_pCaptureFilter->ReleaseFrame(ptvh);

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc DWORD | CTAPIBasePin | Flush | Called when stopping. Flush any
 *    buffers that may be still downstream.
 *
 *  @rdesc Returns NOERROR
 ***************************************************************************/
HRESULT CTAPIBasePin::Flush()
{
        FX_ENTRY("CTAPIBasePin::Flush")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        BeginFlush();
        EndFlush();

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | SendFrame | This method is used to
 *    send a a media sample downstream.
 *
 *  @parm CFrameSample | pSample | Specifies a pointer to the media sample
 *    to send downstream.
 *
 *  @parm LPTHKVIDEOHDR | ptvh | Specifies a pointer to the video header
 *    of the video capture buffer associated to this sample.
 *
 *  @parm PDWORD | pdwBytesUsed | Specifies a pointer to a DWORD to receive
 *    the size of the frame that has been delivered downstream.
 *
 *  @parm BOOL | bDiscon | Set to TRUE if this is the first frame we ever
 *    sent downstream.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag S_OK | No error
 *  @flag S_FALSE | If the pin is off (IAMStreamControl)
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIBasePin::SendFrame(IN CFrameSample *pSample, IN PBYTE pbyInBuff, IN DWORD dwInBytes, OUT PDWORD pdwBytesUsed, OUT PDWORD pdwBytesExtent, IN BOOL bDiscon)
{
        HRESULT Hr = NOERROR;
        DWORD dwBytesUsed;
    LPBYTE lp;

        FX_ENTRY("CTAPIBasePin::SendFrame")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pSample);
        ASSERT(pbyInBuff);
        ASSERT(pdwBytesUsed);
        if (!pSample || !pbyInBuff || !pdwBytesUsed)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument!", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Process the video capture buffer before sending it downstream, if necessary
        if (m_pConverter)
        {
                dwBytesUsed = 0;

                if (SUCCEEDED(Hr = pSample->GetPointer(&lp)))
                {
                        Hr = m_pConverter->ConvertFrame(pbyInBuff, dwInBytes, lp, &dwBytesUsed, pdwBytesExtent, NULL, NULL, m_fFastUpdatePicture);
                        m_fFastUpdatePicture = FALSE;

            if (FAILED(Hr))
            {
                                goto MyExit;
                        }
                }
        }
        else
        {
                dwBytesUsed = dwInBytes;

#ifdef USE_SOFTWARE_CAMERA_CONTROL
                // Do we need to apply any software-only camera control operations?
                if (IsSoftCamCtrlNeeded())
                {
                        // If the software-only camera controller isn't opened yet, open it
                        if (!IsSoftCamCtrlOpen())
                        {
                                // OpenConverter(HEADER(m_user.pvi), HEADER(m_pPreviewPin->m_mt.pbFormat)));
                                OpenSoftCamCtrl(HEADER(m_pCaptureFilter->m_user.pvi), HEADER(m_mt.pbFormat));
                        }
                        
                        if (IsSoftCamCtrlOpen())
                        {
                                // In this case, the input is RGB24 and the output is RGB24. The sample
                                // pointer has already been initialized to the video capture buffer.
                                // We need to apply the transform to the capture buffer and copy
                                // back the result on this buffer.
                                ApplySoftCamCtrl(pbyInBuff, dwInBytes, m_pbyCamCtrl, &dwBytesUsed, pdwBytesExtent);

                                // Remember the current data pointer
                                pSample->GetPointer(&lp);

                                // Set a new pointer
                                pSample->SetPointer(m_pbyCamCtrl, dwBytesUsed);
                        }
                }
                else
                {
                        // If we had a software-only camera controller but we don't
                        // need it anymore, just close it
                        if (IsSoftCamCtrlOpen())
                                CloseSoftCamCtrl();
                }
#endif
        }

        if (dwBytesUsed)
        {
                // It isn't necessarily a keyframe, but who cares?
                pSample->SetSyncPoint(TRUE);
                pSample->SetActualDataLength(dwBytesUsed);
                pSample->SetDiscontinuity(bDiscon);
                pSample->SetPreroll(FALSE);

                // Let the downstream pin know about the format change
                if (m_fFormatChanged)
                {
                        pSample->SetMediaType(&m_mt);
                        m_fFormatChanged = FALSE;
                }

                // Use the clock's graph to mark the times for the samples.  The video
                // capture card's clock is going to drift from the graph clock, so you'll
                // think we're dropping frames or sending too many frames if you look at
                // the time stamps, so we have an agreement to mark the MediaTime with the
                // frame number so you can tell if any frames are dropped.
                // Use the time we got in Run() to determine the stream time.  Also add
                // a latency (HACK!) to prevent preview renderers from thinking we're
                // late.
                // If we are RUN, PAUSED, RUN, we won't send stuff smoothly where we
                // left off because of the async nature of pause.
                CRefTime rtSample;
                CRefTime rtEnd;
                if (m_pCaptureFilter->m_pClock)
                {
                        rtSample = m_pCaptureFilter->m_cs.rtThisFrameTime - m_pCaptureFilter->m_tStart;
                        rtEnd = rtSample + m_lMaxAvgTimePerFrame;
                        pSample->SetTime((REFERENCE_TIME *)&rtSample, (REFERENCE_TIME *)&rtEnd);
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Stream time is %d", _fx_, (LONG)rtSample.Millisecs()));
                }
                else
                {
                        // No clock, use our driver time stamps
                        rtSample = m_pCaptureFilter->m_cs.rtThisFrameTime - m_pCaptureFilter->m_tStart;
                        rtEnd    = rtSample + m_pCaptureFilter->m_user.pvi->AvgTimePerFrame;
                        pSample->SetTime((REFERENCE_TIME *)&rtSample, (REFERENCE_TIME *)&rtEnd);
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   No graph clock! Stream time is %d (based on driver time)", _fx_, (LONG)rtSample.Millisecs()));
                }

                // Don't deliver it if the stream is off for now
                int iStreamState = CheckStreamState(pSample);
                if (iStreamState == STREAM_FLOWING)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Sending frame: Stamps(%u): Time(%d,%d)", _fx_, m_pCaptureFilter->m_pBufferQueue[m_pCaptureFilter->m_uiQueueTail], (LONG)rtSample.Millisecs(), (LONG)rtEnd.Millisecs()));
                        if ((Hr = Deliver (pSample)) == S_FALSE)
                                Hr = E_FAIL;    // stop delivering anymore, this is serious
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Discarding frame", _fx_));
                        Hr = S_FALSE;           // discarding
                }

#ifdef USE_SOFTWARE_CAMERA_CONTROL
                // Restore the sample pointers if necessary
                if (IsSoftCamCtrlOpen())
                {
                        pSample->SetPointer(lp, dwInBytes);
                }
#endif
        }
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: BUFFER (%08lX %ld %lu) returned EMPTY!", _fx_, pSample));
        }

        *pdwBytesUsed = dwBytesUsed;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCONVERTMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | OpenConverter | This method opens a format
 *    converter.
 *
 *  @parm PBITMAPINFOHEADER | pbiIn | Pointer to the input format.
 *
 *  @parm PBITMAPINFOHEADER | pbiOut | Pointer to the output format.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIBasePin::OpenConverter(IN PBITMAPINFOHEADER pbiIn, IN PBITMAPINFOHEADER pbiOut)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIBasePin::OpenConverter")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        ASSERT(!m_pConverter);

        // Create converter
        if ((pbiOut->biCompression == FOURCC_M263) || (pbiOut->biCompression == FOURCC_M261))
                Hr = CH26XEncoder::CreateH26XEncoder(this, pbiIn, pbiOut, &m_pConverter);
        else
                Hr = CICMConverter::CreateICMConverter(this, pbiIn, pbiOut, &m_pConverter);
        if (FAILED(Hr))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Format converter object couldn't be created", _fx_));
                m_pConverter = NULL;
                goto MyExit;
        }

        // Open converter
        if (FAILED(Hr = m_pConverter->OpenConverter()))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Format converter object couldn't be opened", _fx_));
                delete m_pConverter, m_pConverter = NULL;
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCONVERTMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | CloseConverter | This method closes a
 *    format converter.

 *  @rdesc This method returns NOERROR.
 ***************************************************************************/
HRESULT CTAPIBasePin::CloseConverter()
{
        FX_ENTRY("CTAPIBasePin::CloseConverter")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Destroy converter
        if (m_pConverter)
        {
                m_pConverter->CloseConverter();
                delete m_pConverter, m_pConverter = NULL;
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

        return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\bitrate.cpp ===
/****************************************************************************
 *  @doc INTERNAL BITRATE
 *
 *  @module Bitrate.cpp | Source file for the <c CTAPIBasePin> class methods
 *    used to implement the output pin bitrate control.
 ***************************************************************************/

#include "Precomp.h"

/****************************************************************************
 *  @doc INTERNAL CBITRATECMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | Set | This method is used to set the
 *    the value of the maximum output bitrate.
 *
 *  @parm BitrateControlProperty | Property | Used to specifiy the property
 *    to set the value of.
 *
 *  @parm long | lValue | Used to specify the value to set on the property.
 *
 *  @parm TAPIControlFlags | lFlags | Used to specify the flags to set on
 *    the property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::Set(IN BitrateControlProperty Property, IN long lValue, IN TAPIControlFlags lFlags, IN DWORD dwLayerId)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIBasePin::Set (BitrateControlProperty)")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(lValue >= m_lBitrateRangeMin);
        ASSERT(lValue <= m_lBitrateRangeMax);
        ASSERT(dwLayerId == 0);
        if (dwLayerId)
        {
                // We don't implement multi-layered encoding in this filter
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }

        ASSERT(Property >= BitrateControl_Maximum && Property <= BitrateControl_Current);

        // Set relevant values
        if (Property == BitrateControl_Maximum)
        {
                if (lValue < m_lBitrateRangeMin || lValue > m_lBitrateRangeMax)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                        Hr = E_INVALIDARG;
                        goto MyExit;
                }
                m_lTargetBitrate = lValue;
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   New target bitrate: %ld", _fx_, m_lTargetBitrate));
        }
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                Hr = E_PROP_ID_UNSUPPORTED;
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CBITRATECMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | Get | This method is used to retrieve
 *    the current or maximum limit in bandwidth transmission advertized.
 *
 *  @parm BitrateControlProperty | Property | Used to specifiy the property
 *    to retrieve the value of.
 *
 *  @parm long* | plValue | Used to receive the value of the property, in bps.
 *
 *  @parm TAPIControlFlags* | plFlags | Used to receive the value of the flag
 *    associated to the property.
 *
 *  @parm DWORD | dwLayerId | Specifies the ID of the encoding layer the
 *    call applies to. For standard audio and video encoders, this field is
 *    always set to 0. In the case of multi-layered encoders, this field
 *    shall be set to 0 for the base layer, 1 for the first enhancement
 *    layer, 2 for the next enhancement layer, etc
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::Get(IN BitrateControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags, IN DWORD dwLayerId)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIBasePin::Get (BitrateControlProperty)")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(plValue);
        ASSERT(plFlags);
        if (!plValue || !plFlags)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }
        ASSERT(dwLayerId == 0);
        if (dwLayerId)
        {
                // We don't support multi-layered decoding in this filter
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }
        ASSERT(Property >= BitrateControl_Maximum && Property <= BitrateControl_Current);

        // Return relevant values
        *plFlags = TAPIControl_Flags_None;
        if (Property == BitrateControl_Maximum)
                *plValue = m_lTargetBitrate;
        else if (Property == BitrateControl_Current)
                *plValue = m_lCurrentBitrate;
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid Property argument", _fx_));
                Hr = E_PROP_ID_UNSUPPORTED;
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CBITRATECMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | GetRange | This
 *    method is used to retrieve support, minimum, maximum, and default
 *    values for the upper limit in bandwidth transmission the an output pin
 *    may be setup for.
 *
 *  @parm long* | plMin | Used to retrieve the minimum value of the
 *    property, in bps.
 *
 *  @parm long* | plMax | Used to retrieve the maximum value of the
 *    property, in bps.
 *
 *  @parm long* | plSteppingDelta | Used to retrieve the stepping delta
 *    of the property, in bps.
 *
 *  @parm long* | plDefault | Used to retrieve the default value of the
 *    property, in bps.
 *
 *  @parm TAPIControlFlags* | plCapsFlags | Used to receive the flags
 *    suppported by the property.
 *
 *  @parm DWORD | dwLayerId | Specifies the ID of the encoding layer the
 *    call applies to. For standard audio and video encoders, this field is
 *    always set to 0. In the case of multi-layered encoders, this field
 *    shall be set to 0 for the base layer, 1 for the first enhancement
 *    layer, 2 for the next enhancement layer, etc
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::GetRange(IN BitrateControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags, IN DWORD dwLayerId)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIBasePin::GetRange (BitrateControlProperty)")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(plMin);
        ASSERT(plMax);
        ASSERT(plSteppingDelta);
        ASSERT(plDefault);
        ASSERT(plCapsFlags);
        if (!plMin || !plMax || !plSteppingDelta || !plDefault || !plCapsFlags)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }
        ASSERT(dwLayerId == 0);
        if (dwLayerId)
        {
                // We don't implement multi-layered encoding in this filter
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }
        ASSERT(Property >= BitrateControl_Maximum && Property <= BitrateControl_Current);
        if (Property != BitrateControl_Maximum && Property != BitrateControl_Current)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid Property argument", _fx_));
                Hr = E_PROP_ID_UNSUPPORTED;
                goto MyExit;
        }

        // Return relevant values
        *plCapsFlags = TAPIControl_Flags_None;
        *plMin = m_lBitrateRangeMin;
        *plMax = m_lBitrateRangeMax;
        *plSteppingDelta = m_lBitrateRangeSteppingDelta;
        *plDefault = m_lBitrateRangeDefault;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\basepin.h ===
/****************************************************************************
 *  @doc INTERNAL BASEPIN
 *
 *  @module BasePin.h | Header file for the <c CTAPIBasePin> class methods
 *    used to implement the TAPI base output pin.
 ***************************************************************************/

#ifndef _BASEPIN_H_
#define _BASEPIN_H_

/*****************************************************************************
 * @doc EXTERNAL CONSTANTS
 *
 * @const 0x00000000 | CONVERSIONTYPE_NONE | No conversion operation necessary.
 *
 * @const 0x00000001 | CONVERSIONTYPE_ENCODE | Specifies an encoding operation.
 *
 * @const 0x00000002 | CONVERSIONTYPE_DECODE | Specifies a decoding operation.
 *
 * @const 0x00000004 | CONVERSIONTYPE_SCALER | Specifies an image size change.
 *
 * @const 0x00000008 | CONVERSIONTYPE_PRESCALER | Specifies an image size change will occur before a format change.
 ****************************************************************************/
#define CONVERSIONTYPE_NONE                                     0x00000000
#define CONVERSIONTYPE_ENCODE                           0x00000001
#define CONVERSIONTYPE_DECODE                           0x00000002
#define CONVERSIONTYPE_SCALER                           0x00000004
#define CONVERSIONTYPE_PRESCALER                        0x00000008

/****************************************************************************
 *  @doc INTERNAL CBASEPINCLASS
 *
 *  @class CTAPIBasePin | This class implements the TAPI base output pin.
 *
 *  @mdata CTAPIVCap* | CTAPIBasePin | m_pCaptureFilter | Pointer to the
 *    filter that owns us.
 *
 *  @mdata ALLOCATOR_PROPERTIES | CTAPIBasePin | m_parms | Out allocator
 *    properties.
 *
 *  @mdata REFERENCE_TIME | CTAPIBasePin | m_MaxProcessingTime | Maximum
 *    processing time.
 *
 *  @mdata REFERENCE_TIME | CTAPIBasePin | m_CurrentProcessingTime | Current
 *    processing time.
 *
 *  @mdata DWORD | CTAPIBasePin | m_dwMaxCPULoad | Maximum CPU load.
 *
 *  @mdata DWORD | CTAPIBasePin | m_dwCurrentCPULoad | Current CPU load.
 *
 *  @mdata REFERENCE_TIME | CTAPIBasePin | m_AvgTimePerFrameRangeMin | Minimum
 *    target frame rate.
 *
 *  @mdata REFERENCE_TIME | CTAPIBasePin | m_AvgTimePerFrameRangeMax | Maximum
 *    target frame rate.
 *
 *  @mdata REFERENCE_TIME | CTAPIBasePin | m_AvgTimePerFrameRangeSteppingDelta | Target
 *    frame rate stepping delta.
 *
 *  @mdata REFERENCE_TIME | CTAPIBasePin | m_AvgTimePerFrameRangeDefault | Target
 *    frame rate default.
 *
 *  @mdata REFERENCE_TIME | CTAPIBasePin | m_MaxAvgTimePerFrame | Target
 *    frame rate.
 *
 *  @mdata REFERENCE_TIME | CTAPIBasePin | m_CurrentAvgTimePerFrame | Current
 *    frame rate.
 *
 *  @mdata DWORD | CTAPIBasePin | m_dwBitrateRangeMin | Minimum target bitrate.
 *
 *  @mdata DWORD | CTAPIBasePin | m_dwBitrateRangeMax | Maximum target bitrate.
 *
 *  @mdata DWORD | CTAPIBasePin | m_dwBitrateRangeSteppingDelta | Target
 *    bitrate stepping delta.
 *
 *  @mdata DWORD | CTAPIBasePin | m_dwBitrateRangeDefault | Default target bitrate.
 *
 *  @mdata DWORD | CTAPIBasePin | m_dwMaxBitrate | Target bitrate.
 *
 *  @mdata DWORD | CTAPIBasePin | m_dwCurrentBitrate | Current bitrate.
 *
 *  @mdata BOOL | CTAPIBasePin | m_fFlipHorizontal | Set to TRUE if image is
 *    to be flipped horizontally.
 *
 *  @mdata BOOL | CTAPIBasePin | m_fFlipVertical | Set to TRUE if image is
 *    to be flipped vertically.
 *
 *  @mdata BOOL | CTAPIBasePin | m_fFlipVertical | Affects the quality of
 *    en encoded video stream.
 *
 *  @mdata DWORD  | CTAPIBasePin | m_dwConversionType | Specifies the format
 *    conversion operation necessary to go from the format of the captured
 *    video frames to the format of the data actually generated by the pin.
 *    It can be any combination of the following constants:
 *
 *  @flag CONVERSIONTYPE_NONE | No conversion operation necessary
 *  @flag CONVERSIONTYPE_ENCODE | Specifies an encoding operation
 *  @flag CONVERSIONTYPE_DECODE | Specifies a decoding operation
 *  @flag CONVERSIONTYPE_SCALER | Specifies an image size change
 *
 *  @mdata PBYTE | CTAPIBasePin | m_pbyOut | Pointer to the output buffer
 *    used in a conversion operation.
 *
 *  @mdata DWORD | CTAPIBasePin | m_dwLastTimestamp | Timestamps of the last
 *    frame generated, normalized to 29.97Hz.
 *
 *  @mdata DWORD | CTAPIBasePin | m_dwLastIFrameTime | Remembers the last
 *    time we sent an I-frame downstream.
 *
 *  @mdata DWORD | CTAPIBasePin | m_dwFrame | Current frame number.
 *
 *  @mdata HIC | CTAPIBasePin | m_hIC | Handle to the ICM image converter.
 *
 *  @mdata BOOL | CTAPIBasePin | m_fPeriodicIFrames | Set to TRUE to generate
 *    I-frame periodically.
 *
 *  @mdata PBITMAPINFOHEADER | CTAPIBasePin | m_pbiOut | Pointer to the output
 *    format.
 *
 *  @mdata PBITMAPINFOHEADER | CTAPIBasePin | m_pbiIn | Pointer to the input
 *    format.
 *
 *  @mdata PBITMAPINFOHEADER | CTAPIBasePin | m_pbiInt | Pointer to the intermediate
 *    format.
 *
 *  @mdata BOOL | CTAPIBasePin | m_fConvert | Set to TRUE after an ICM converter
 *    has been open successfully.
 *
 *  @mdata PBITMAPINFOHEADER | CTAPIBasePin | m_pbiSCCOut | Pointer to the output
 *    format of a software-only camera controlled operation.
 *
 *  @mdata PBITMAPINFOHEADER | CTAPIBasePin | m_pbiSCCIn | Pointer to the input
 *    format of a software-only camera controlled operation.
 *
 *  @mdata PBYTE | CTAPIBasePin | m_pbyCamCtrl | Intermediate buffer used in
 *    a software-only camera controlled operation.
 *
 *  @mdata BOOL | CTAPIBasePin | m_fSoftCamCtrl | Set to TRUE after a
 *    software-only camera controller has been opened.
 ***************************************************************************/
class CTAPIBasePin : public CBaseOutputPin, public CBaseStreamControl, public IAMStreamConfig, public IFrameRateControl, public IVideoControl, public IBitrateControl, public IMemAllocator
#ifdef USE_CPU_CONTROL
, public ICPUControl
#endif
{
        public:
        DECLARE_IUNKNOWN
        STDMETHODIMP NonDelegatingQueryInterface(IN REFIID riid, OUT PVOID *ppv);
        CTAPIBasePin(IN TCHAR *pObjectName, IN CTAPIVCap *pCaptureFilter, IN HRESULT *pHr, IN LPCWSTR pName);
        virtual ~CTAPIBasePin();

        // Override CBasePin base class methods
        virtual HRESULT GetMediaType(IN int iPosition, OUT CMediaType *pMediaType);
        virtual HRESULT CheckMediaType(IN const CMediaType *pMediaType);
        virtual HRESULT SetMediaType(IN CMediaType *pMediaType);

        // Implement IAMStreamConfig
        STDMETHODIMP SetFormat(IN AM_MEDIA_TYPE *pmt);
        STDMETHODIMP GetFormat(OUT AM_MEDIA_TYPE **ppmt);
        STDMETHODIMP GetNumberOfCapabilities(OUT int *piCount, OUT int *piSize);
        STDMETHODIMP GetStreamCaps(IN int iIndex, OUT AM_MEDIA_TYPE **ppmt, OUT LPBYTE pSCC);

#ifdef USE_CPU_CONTROL
        // Implement ICPUControl
        STDMETHODIMP SetMaxProcessingTime(IN REFERENCE_TIME MaxProcessingTime);
        STDMETHODIMP GetMaxProcessingTime(OUT REFERENCE_TIME *pMaxProcessingTime, IN DWORD dwMaxCPULoad);
        STDMETHODIMP GetCurrentProcessingTime(OUT REFERENCE_TIME *pCurrentProcessingTime);
        STDMETHODIMP GetMaxProcessingTimeRange(OUT REFERENCE_TIME *pMin, OUT REFERENCE_TIME *pMax, OUT REFERENCE_TIME *pSteppingDelta, OUT REFERENCE_TIME *pDefault, IN DWORD dwMaxCPULoad);
        STDMETHODIMP SetMaxCPULoad(IN DWORD dwMaxCPULoad);
        STDMETHODIMP GetMaxCPULoad(OUT DWORD *pdwMaxCPULoad, IN REFERENCE_TIME MaxProcessingTime);
        STDMETHODIMP GetCurrentCPULoad(OUT DWORD *pdwCurrentCPULoad);
        STDMETHODIMP GetMaxCPULoadRange(OUT DWORD *pMin, OUT DWORD *pMax, OUT DWORD *pSteppingDelta, OUT DWORD *pDefault, IN REFERENCE_TIME MaxProcessingTime);
#endif

        // Implement IFrameRateControl
        STDMETHODIMP GetRange(IN FrameRateControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags);
        STDMETHODIMP Set(IN FrameRateControlProperty Property, IN long lValue, IN TAPIControlFlags lFlags);
        STDMETHODIMP Get(IN FrameRateControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags);

        // Implement IBitrateControl
        STDMETHODIMP GetRange(IN BitrateControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags, IN DWORD dwLayerId);
        STDMETHODIMP Set(IN BitrateControlProperty Property, IN long lValue, IN TAPIControlFlags lFlags, IN DWORD dwLayerId);
        STDMETHODIMP Get(IN BitrateControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags, IN DWORD dwLayerId);

        // Implement IVideoControl
        STDMETHODIMP GetCaps(OUT LONG *pCapsFlags);
        STDMETHODIMP SetMode(IN LONG Mode);
        STDMETHODIMP GetMode(OUT LONG *Mode);
        STDMETHODIMP GetCurrentActualFrameRate(OUT LONGLONG *ActualFrameRate);
        STDMETHODIMP GetMaxAvailableFrameRate(IN LONG iIndex, IN SIZE Dimensions, OUT LONGLONG *MaxAvailableFrameRate);
        STDMETHODIMP GetFrameRateList(IN LONG iIndex, IN SIZE Dimensions, IN LONG *ListSize, OUT LONGLONG **FrameRates);

        // Implement IMemAllocator
        STDMETHODIMP SetProperties(IN ALLOCATOR_PROPERTIES *pRequest, OUT ALLOCATOR_PROPERTIES *pActual);
        STDMETHODIMP GetProperties(OUT ALLOCATOR_PROPERTIES *pProps);
        STDMETHODIMP Commit();
        STDMETHODIMP Decommit();
        STDMETHODIMP GetBuffer(OUT IMediaSample **ppBuffer, IN REFERENCE_TIME *pStartTime, IN REFERENCE_TIME *pEndTime, IN DWORD dwFlags);
        STDMETHODIMP ReleaseBuffer(IN IMediaSample *pBuffer);

        // Override CBaseOutputPin base class methods
        HRESULT DecideBufferSize(IN IMemAllocator *pAlloc, OUT ALLOCATOR_PROPERTIES *ppropInputRequest);
        HRESULT DecideAllocator(IN IMemInputPin *pPin, OUT IMemAllocator **ppAlloc);

        // Override IQualityControl interface method to receive Notification messages
        STDMETHODIMP Notify(IN IBaseFilter *pSelf, IN Quality q) {return E_NOTIMPL;};

        HRESULT Active();
        HRESULT Inactive();
        HRESULT ActiveRun(IN REFERENCE_TIME tStart);
        HRESULT ActivePause();
    HRESULT ChangeFormatHelper();
    HRESULT NotifyDeviceFormatChange(IN CMediaType *pMediaType);
        HRESULT Reconnect();

        protected:

        friend class CVfWCapDev;
        friend class CWDMCapDev;
        friend class CICMConverter;
        friend class CH26XEncoder;
        friend class CRtpPdPin;
        friend class CConverter;

        CTAPIVCap               *m_pCaptureFilter;

        // Allocator properties
        ALLOCATOR_PROPERTIES m_parms;

#ifdef USE_CPU_CONTROL
        // CPU control
        REFERENCE_TIME  m_MaxProcessingTime;
        REFERENCE_TIME  m_CurrentProcessingTime;
        DWORD                   m_dwMaxCPULoad;
        DWORD                   m_dwCurrentCPULoad;
#endif

        // Frame rate control
        LONG m_lAvgTimePerFrameRangeMin;
        LONG m_lAvgTimePerFrameRangeMax;
        LONG m_lAvgTimePerFrameRangeSteppingDelta;
        LONG m_lAvgTimePerFrameRangeDefault;
        LONG m_lMaxAvgTimePerFrame;
        LONG m_lCurrentAvgTimePerFrame;

        // Bitrate control
        LONG m_lBitrateRangeMin;
        LONG m_lBitrateRangeMax;
        LONG m_lBitrateRangeSteppingDelta;
        LONG m_lBitrateRangeDefault;
        LONG m_lTargetBitrate;
        LONG m_lCurrentBitrate;

        // Video mode control
        BOOL m_fFlipHorizontal;
        BOOL m_fFlipVertical;

        // Formats
        AM_MEDIA_TYPE*                                  *m_aFormats;
        DWORD                                                   m_dwNumFormats;
        const VIDEO_STREAM_CONFIG_CAPS* const *m_aCapabilities;
        int                                                             m_iCurrFormat;
        BOOL                                                    m_fFormatChanged;

        // Fast updates, this really only belongs to the capture pin, but it is
    // not worth while to override SendFrame just to read this flag.
        BOOL                            m_fFastUpdatePicture;

        // Format conversion
        CConverter *m_pConverter;
        HRESULT OpenConverter(IN PBITMAPINFOHEADER pbiIn, IN PBITMAPINFOHEADER pbiOut);
        HRESULT CloseConverter();

        // Blackbanding and cropping vs stretching
        BOOL m_fNoImageStretch;

        // ScaleDIB8 helpers
        DWORD m_dwBlackEntry;

#ifdef USE_SOFTWARE_CAMERA_CONTROL
        // Software-only camera control
        PBITMAPINFOHEADER m_pbiSCCOut;
        PBITMAPINFOHEADER m_pbiSCCIn;
        PBYTE m_pbyCamCtrl;
        BOOL m_fSoftCamCtrl;
        HRESULT CloseSoftCamCtrl();
        BOOL    IsSoftCamCtrlNeeded();
        BOOL    IsSoftCamCtrlOpen();
        HRESULT ApplySoftCamCtrl(PBYTE pbyInput, DWORD dwInBytes, PBYTE pbyOutput, PDWORD pdwBytesUsed, PDWORD pdwBytesExtent);
        HRESULT OpenSoftCamCtrl(IN PBITMAPINFOHEADER pbiIn, IN PBITMAPINFOHEADER pbiOut);
#endif

        // Video capture buffer queue management
    BOOL        Committed() {return m_pCaptureFilter->m_cs.paHdr != NULL;};
    HRESULT     Flush();
    HRESULT     ReleaseFrame(IN LPTHKVIDEOHDR ptvh);
    HRESULT     SendFrame(IN CFrameSample *pSample, IN PBYTE pbyInBuff, IN DWORD dwInBytes, OUT PDWORD pdwBytesUsed, OUT PDWORD pdwBytesExtent, IN BOOL bDiscon);
};

#endif // _BASEPIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\cameracp.h ===
/****************************************************************************
 *  @doc INTERNAL CAMERACP
 *
 *  @module CameraCP.h | Header file for the <c CCameraControlProperty>
 *    class used to implement a property page to test the TAPI interface
 *    <i ICameraControl>.
 *
 *  @comm This code tests the TAPI Video Decoder Filter <i ICameraControl>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
 ***************************************************************************/

#ifndef _CAMERACP_H_
#define _CAMERACP_H_

#ifdef USE_PROPERTY_PAGES

#ifdef USE_SOFTWARE_CAMERA_CONTROL

#define NUM_CAMERA_CONTROLS 9

/****************************************************************************
 *  @doc INTERNAL CCAMERACPCLASS
 *
 *  @class CCameraControlProperty | This class implements handling of a
 *    single camera control property in a property page.
 *
 *  @mdata int | CCameraControlProperty | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata ICameraControl * | CCameraControlProperty | m_pInterface | Pointer
 *    to the <i ICameraControl> interface.
 *
 *  @comm This code tests the TAPI Video Decoder Filter <i ICameraControl>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
***************************************************************************/
class CCameraControlProperty : public CPropertyEditor 
{
	public:
	CCameraControlProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, ICameraControl *pInterface);
	~CCameraControlProperty ();

	// CPropertyEditor base class pure virtual overrides
	HRESULT GetValue();
	HRESULT SetValue();
	HRESULT GetRange();
	BOOL CanAutoControl(void);
	BOOL GetAuto(void);
	BOOL SetAuto(BOOL fAuto);

	private:
	ICameraControl *m_pInterface;
};

/****************************************************************************
 *  @doc INTERNAL CCAMERACPCLASS
 *
 *  @class CCameraControlProperties | This class runs a property page to test
 *    the TAPI Capture Filter <i ICameraControl> implementation.
 *
 *  @mdata int | CCameraControlProperties | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata ICameraControl * | CCameraControlProperties | m_pICameraControl | Pointer
 *    to the <i ICameraControl> interface.
 *
 *  @mdata CCameraControlProperty * | CCameraControlProperties | m_Controls[NUM_CAMERA_CONTROLS] | Array
 *    of camera control properties.
 *
 *  @comm This code tests the TAPI Capture Filter <i ICameraControl>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
***************************************************************************/
class CCameraControlProperties : public CBasePropertyPage
{
	public:
	CCameraControlProperties(LPUNKNOWN pUnk, HRESULT *pHr);
	~CCameraControlProperties();

	HRESULT OnConnect(IUnknown *pUnk);
	HRESULT OnDisconnect();
	HRESULT OnActivate();
	HRESULT OnDeactivate();
	HRESULT OnApplyChanges();
	BOOL    OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

	private:
	void SetDirty();

	int m_NumProperties;
	ICameraControl *m_pICameraControl;
	BOOL m_fActivated;
	CCameraControlProperty *m_Controls[NUM_CAMERA_CONTROLS];
};

#endif // USE_SOFTWARE_CAMERA_CONTROL

#endif // USE_PROPERTY_PAGES

#endif // _CAMERACP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\camerac.cpp ===
/****************************************************************************
 *  @doc INTERNAL CAMERAC
 *
 *  @module CameraC.cpp | Source file for the <c CCapDev> and <c CWDMCapDev>
 *    class methods used to implement the <i ICameraControl> interface.
 *
 *  @todo The <c CCapDev> class does everything in software. When the same
 *    kind of services are supported by a WDM capture device, we use those
 *    instead.
 ***************************************************************************/

#include "Precomp.h"

#define PAN_TILT_MIN -180
#define PAN_TILT_MAX 180
#define PAN_TILT_DELTA 1
#define PAN_TILT_DEFAULT 0
#define ZOOM_MIN 10
#define ZOOM_MAX 600
#define ZOOM_DELTA 10
#define ZOOM_DEFAULT 10

/****************************************************************************
 *  @doc INTERNAL CCAMERACMETHOD
 *
 *  @mfunc HRESULT | CCapDev | Set | This method is used to set the value
 *    of a camera control setting.
 *
 *  @parm TAPICameraControlProperty | Property | Used to specify the camera
 *    control setting to set the value of. Use a member of the
 *    <t TAPICameraControlProperty> enumerated type.
 *
 *  @parm long | lValue | Used to specify the new value of the camera control
 *    setting.
 *
 *  @parm long | Flags | A member of the <t TAPIControlFlags> enumerated
 *    type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CCapDev::Set(IN TAPICameraControlProperty Property, IN long lValue, IN TAPIControlFlags lFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCapDev::Set (CameraControl)")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT((Property >= TAPICameraControl_Pan && Property <= TAPICameraControl_Focus) || Property == TAPICameraControl_FlipVertical || Property == TAPICameraControl_FlipHorizontal);

	// Update the property and flags
	switch (Property)
	{
		case TAPICameraControl_Pan:
			ASSERT(lValue >= PAN_TILT_MIN && lValue <= PAN_TILT_MAX);
			if (lValue >= PAN_TILT_MIN && lValue <= PAN_TILT_MAX)
				m_lCCPan = lValue;
			else
				Hr = E_INVALIDARG;
			break;
		case TAPICameraControl_Tilt:
			ASSERT(lValue >= PAN_TILT_MIN && lValue <= PAN_TILT_MAX);
			if (lValue >= PAN_TILT_MIN && lValue <= PAN_TILT_MAX)
				m_lCCTilt = lValue;
			else
				Hr = E_INVALIDARG;
			break;
		case TAPICameraControl_Zoom:
			ASSERT(lValue >= ZOOM_MIN && lValue <= ZOOM_MAX);
			if (lValue >= ZOOM_MIN && lValue <= ZOOM_MAX)
				m_lCCZoom = lValue;
			else
				Hr = E_INVALIDARG;
			break;
		case TAPICameraControl_FlipVertical:
			m_pCaptureFilter->m_pPreviewPin->m_fFlipVertical = lValue;
			break;
		case TAPICameraControl_FlipHorizontal:
			m_pCaptureFilter->m_pPreviewPin->m_fFlipHorizontal = lValue;
			break;
		default:
			Hr = E_PROP_ID_UNSUPPORTED;
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACMETHOD
 *
 *  @mfunc HRESULT | CCapDev | Get | This method is used to retrieve the
 *    value of a camera control setting.
 *
 *  @parm TAPICameraControlProperty | Property | Used to specify the camera
 *    control setting to get the value of. Use a member of the
 *    <t TAPICameraControlProperty> enumerated type.
 *
 *  @parm long* | plValue | Used to retrieve the current value of the
 *    camera control setting.
 *
 *  @parm long* | plFlags | Pointer to a member of the <t TAPIControlFlags>
 *    enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CCapDev::Get(IN TAPICameraControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCapDev::Get (CameraControl)")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(plValue);
	ASSERT(plFlags);
	if (!plValue || !plFlags)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT((Property >= TAPICameraControl_Pan && Property <= TAPICameraControl_Focus) || Property == TAPICameraControl_FlipVertical || Property == TAPICameraControl_FlipHorizontal);

	// Update the property and flags
	*plFlags = TAPIControl_Flags_Manual;
	switch (Property)
	{
		case TAPICameraControl_Pan:
			*plValue = m_lCCPan;
			break;
		case TAPICameraControl_Tilt:
			*plValue = m_lCCTilt;
			break;
		case TAPICameraControl_Zoom:
			*plValue = m_lCCZoom;
			break;
		case TAPICameraControl_FlipVertical:
			*plValue = m_pCaptureFilter->m_pPreviewPin->m_fFlipVertical;
			break;
		case TAPICameraControl_FlipHorizontal:
			*plValue = m_pCaptureFilter->m_pPreviewPin->m_fFlipHorizontal;
			break;
		default:
			Hr = E_PROP_ID_UNSUPPORTED;
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACMETHOD
 *
 *  @mfunc HRESULT | CCapDev | GetRange | This method is used to retrieve
 *    the minimum, maximum, and default values for specific camera control
 *    settings.
 *
 *  @parm CameraControlProperty | Property | Used to specify the camera
 *    control setting to determine the range of. Use a member of the
 *    <t CameraControlProperty> enumerated type.
 *
 *  @parm long* | plMin | Used to retrieve the minimum value of the camera
 *    control setting range.
 *
 *  @parm long* | plMax | Used to retrieve the maximum value of the camera
 *    control setting range.
 *
 *  @parm long* | plSteppingDelta | Used to retrieve the stepping delta of
 *    the camera control setting range.
 *
 *  @parm long* | plDefault | Used to retrieve the default value of the
 *    camera control setting range.
 *
 *  @parm long* | plCapsFlags | Used to retrieve the capabilities of the
 *    camera control setting. Pointer to a member of the
 *    <t TAPIControlFlags> enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CCapDev::GetRange(IN TAPICameraControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCapDev::GetRange (CameraControl)")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(plMin);
	ASSERT(plMax);
	ASSERT(plSteppingDelta);
	ASSERT(plDefault);
	ASSERT(plCapsFlags);
	if (!plMin || !plMax || !plSteppingDelta || !plDefault || !plCapsFlags)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT((Property >= TAPICameraControl_Pan && Property <= TAPICameraControl_Focus) || Property == TAPICameraControl_FlipVertical || Property == TAPICameraControl_FlipHorizontal);

	// Update the property and flags
	*plCapsFlags = TAPIControl_Flags_Manual;
	switch (Property)
	{
		case TAPICameraControl_Pan:
		case TAPICameraControl_Tilt:
			*plMin = PAN_TILT_MIN;
			*plMax = PAN_TILT_MAX;
			*plSteppingDelta = PAN_TILT_DELTA;
			*plDefault = PAN_TILT_DEFAULT;
			break;
		case TAPICameraControl_Zoom:
			*plMin = ZOOM_MIN;
			*plMax = ZOOM_MAX;
			*plSteppingDelta = ZOOM_DELTA;
			*plDefault = ZOOM_DEFAULT;
			break;
		case TAPICameraControl_FlipVertical:
		case TAPICameraControl_FlipHorizontal:
			*plMin = 0;
			*plMax = 1;
			*plSteppingDelta = 1;
			*plDefault = 0;
			break;
		default:
			Hr = E_PROP_ID_UNSUPPORTED;
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

#ifndef USE_SOFTWARE_CAMERA_CONTROL
/****************************************************************************
 *  @doc INTERNAL CCAMERACMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | Set | This method is used to set the value
 *    of a camera control setting.
 *
 *  @parm TAPICameraControlProperty | Property | Used to specify the camera
 *    control setting to set the value of. Use a member of the
 *    <t TAPICameraControlProperty> enumerated type.
 *
 *  @parm long | lValue | Used to specify the new value of the camera control
 *    setting.
 *
 *  @parm long | Flags | A member of the <t TAPIControlFlags> enumerated
 *    type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 *
 *  @todo Check the range of <p lValue> before remembering it - return
 *    E_INVALIDARG on error in this case
 ***************************************************************************/
STDMETHODIMP CWDMCapDev::Set(IN TAPICameraControlProperty Property, IN long lValue, IN TAPIControlFlags lFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CWDMCapDev::Set (CameraControl)")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT((Property >= TAPICameraControl_Pan && Property <= TAPICameraControl_Focus) || Property == TAPICameraControl_FlipVertical || Property == TAPICameraControl_FlipHorizontal);
	if (!((Property >= TAPICameraControl_Pan && Property <= TAPICameraControl_Focus) || Property == TAPICameraControl_FlipVertical || Property == TAPICameraControl_FlipHorizontal))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid property argument", _fx_));
		Hr = E_PROP_ID_UNSUPPORTED;
		goto MyExit;
	}
	ASSERT(lFlags == TAPIControl_Flags_Manual || lFlags == TAPIControl_Flags_Auto);
	if (lFlags != TAPIControl_Flags_Manual && lFlags != TAPIControl_Flags_Auto)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid flag argument", _fx_));
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	// Set the property on the driver
	if (Property >= TAPICameraControl_Pan && Property <= TAPICameraControl_Focus)
	{
		if (FAILED(Hr = SetPropertyValue(PROPSETID_VIDCAP_CAMERACONTROL, (ULONG)Property, lValue, (ULONG)lFlags, (ULONG)lFlags)))
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: SetPropertyValue failed", _fx_));
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: SetPropertyValue succeeded", _fx_));
		}
	}
	else
	{
		// @todo Put some code here for the flip vertical/horizontal property
		Hr = E_PROP_ID_UNSUPPORTED;
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | Get | This method is used to retrieve the
 *    value of a camera control setting.
 *
 *  @parm TAPICameraControlProperty | Property | Used to specify the camera
 *    control setting to set the value of. Use a member of the
 *    <t TAPICameraControlProperty> enumerated type.
 *
 *  @parm long* | plValue | Used to retrieve the current value of the
 *    camera control setting.
 *
 *  @parm long* | plFlags | Pointer to a member of the <t TAPIControlFlags>
 *    enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CWDMCapDev::Get(IN TAPICameraControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags)
{
	HRESULT Hr = NOERROR;
	ULONG ulCapabilities;

	FX_ENTRY("CWDMCapDev::Get (CameraControl)")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(plValue);
	ASSERT(plFlags);
	if (!plValue || !plFlags)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT((Property >= TAPICameraControl_Pan && Property <= TAPICameraControl_Focus) || Property == TAPICameraControl_FlipVertical || Property == TAPICameraControl_FlipHorizontal);

	// Get the property from the driver
	if (Property >= TAPICameraControl_Pan && Property <= TAPICameraControl_Focus)
	{
		if (FAILED(Hr = GetPropertyValue(PROPSETID_VIDCAP_CAMERACONTROL, (ULONG)Property, plValue, (PULONG)plFlags, &ulCapabilities)))
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: GetPropertyValue failed", _fx_));
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: GetPropertyValue succeeded", _fx_));
		}
	}
	else
	{
		// @todo Put some code here for the flip vertical/horizontal property
		Hr = E_PROP_ID_UNSUPPORTED;
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | GetRange | This method is used to retrieve
 *    the minimum, maximum, and default values for specific camera control
 *    settings.
 *
 *  @parm TAPICameraControlProperty | Property | Used to specify the camera
 *    control setting to set the value of. Use a member of the
 *    <t TAPICameraControlProperty> enumerated type.
 *
 *  @parm long* | plMin | Used to retrieve the minimum value of the camera
 *    control setting range.
 *
 *  @parm long* | plMax | Used to retrieve the maximum value of the camera
 *    control setting range.
 *
 *  @parm long* | plSteppingDelta | Used to retrieve the stepping delta of
 *    the camera control setting range.
 *
 *  @parm long* | plDefault | Used to retrieve the default value of the
 *    camera control setting range.
 *
 *  @parm long* | plCapsFlags | Used to retrieve the capabilities of the
 *    camera control setting. Pointer to a member of the
 *    <t TAPIControlFlags> enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CWDMCapDev::GetRange(IN TAPICameraControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags)
{
	HRESULT Hr = NOERROR;
	LONG  lCurrentValue;
	ULONG ulCurrentFlags;

	FX_ENTRY("CWDMCapDev::GetRange (CameraControl)")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(plMin);
	ASSERT(plMax);
	ASSERT(plSteppingDelta);
	ASSERT(plDefault);
	ASSERT(plCapsFlags);
	if (!plMin || !plMax || !plSteppingDelta || !plDefault || !plCapsFlags)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT((Property >= TAPICameraControl_Pan && Property <= TAPICameraControl_Focus) || Property == TAPICameraControl_FlipVertical || Property == TAPICameraControl_FlipHorizontal);

	// Get the range values from the driver
	if (Property >= TAPICameraControl_Pan && Property <= TAPICameraControl_Focus)
	{
		if (FAILED(Hr = GetRangeValues(PROPSETID_VIDCAP_CAMERACONTROL, (ULONG)Property, plMin, plMax, plSteppingDelta)))
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: GetRangeValues failed", _fx_));
			goto MyExit;
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: GetRangeValues succeeded", _fx_));
		}

		// Get the capability flags from the driver
		if (FAILED(Hr = GetPropertyValue(PROPSETID_VIDCAP_VIDEOPROCAMP, (ULONG)Property, &lCurrentValue, &ulCurrentFlags, (PULONG)plCapsFlags)))
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: GetRangeValues failed", _fx_));
			goto MyExit;
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: GetRangeValues succeeded", _fx_));
		}

		// Get the default value from the driver
		if (FAILED(Hr = GetDefaultValue(PROPSETID_VIDCAP_CAMERACONTROL, (ULONG)Property, plDefault)))
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: GetDefaultValue failed", _fx_));
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: GetDefaultValue succeeded", _fx_));
		}
	}
	else
	{
		// @todo Put some code here for the flip vertical/horizontal property
		Hr = E_PROP_ID_UNSUPPORTED;
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

#endif // USE_SOFTWARE_CAMERA_CONTROL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\capture.h ===
/****************************************************************************
 *  @doc INTERNAL CAPTURE
 *
 *  @module Capture.h | Header file for the <c CCapturePin> class methods
 *    used to implement the video capture output pin.
 ***************************************************************************/

#ifndef _CAPTURE_H_
#define _CAPTURE_H_

#define MAX_VIDEO_BUFFERS 6
#define MIN_VIDEO_BUFFERS 2

#define ALIGNUP(dw,align) ((LONG_PTR)(((LONG_PTR)(dw)+(align)-1) / (align)) * (align))

class CFrameSample : public CMediaSample
{
	public:
	CFrameSample(IMemAllocator *pAllocator, HRESULT *phr, LPTHKVIDEOHDR ptvh, LPBYTE pBuffer, LONG length) : m_ptvh(ptvh), CMediaSample(NAME("Video Frame"), (CBaseAllocator *)pAllocator, phr, pBuffer, length){};
	LPTHKVIDEOHDR GetFrameHeader() {return m_ptvh;};

	private:
	const LPTHKVIDEOHDR m_ptvh;
};

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPINCLASS
 *
 *  @class CCapturePin | This class implements the video capture output pin.
 *
 *  @mdata CTAPIVCap* | CCapturePin | m_pCaptureFilter | Reference to the
 *    parent capture filter.
 *
 *  @comm Supports IPin. Never created by COM, so no CreateInstance or entry
 *    in global FactoryTemplate table. Only ever created by a <c CTAPIVCap>
 *    object and returned via the EnumPins interface
 ***************************************************************************/
class CCapturePin : public CTAPIBasePin, public IStreamConfig, public IH245Capability, public IH245EncoderCommand
#ifdef USE_NETWORK_STATISTICS
, public INetworkStats
#endif
#ifdef USE_PROGRESSIVE_REFINEMENT
, public IProgressiveRefinement
#endif
#ifdef USE_PROPERTY_PAGES
, public ISpecifyPropertyPages
#endif
{
	public:
	DECLARE_IUNKNOWN
	CCapturePin(IN TCHAR *pObjectName, IN CTAPIVCap *pCaptureFilter, IN HRESULT *pHr, IN LPCWSTR pName);
	~CCapturePin();
	STDMETHODIMP NonDelegatingQueryInterface(IN REFIID riid, OUT PVOID *ppv);
	static HRESULT CALLBACK CreateCapturePin(CTAPIVCap *pCaptureFilter, CCapturePin **ppCapturePin);

	// Override CBasePin base class methods
	HRESULT SetMediaType(IN CMediaType *pMediaType);

	// Implement IStreamConfig
	STDMETHODIMP SetFormat(IN DWORD dwRTPPayLoadType, IN AM_MEDIA_TYPE *pMediaType);
	STDMETHODIMP GetFormat(OUT DWORD *pdwRTPPayLoadType, OUT AM_MEDIA_TYPE **ppMediaType);
	STDMETHODIMP GetNumberOfCapabilities(OUT DWORD *pdwCount);
	STDMETHODIMP GetStreamCaps(IN DWORD dwIndex, OUT AM_MEDIA_TYPE **ppMediaType, OUT TAPI_STREAM_CONFIG_CAPS *pTSCC, OUT DWORD *pdwRTPPayLoadType);
#ifdef TEST_ISTREAMCONFIG
	STDMETHODIMP TestIStreamConfig();
#endif

#ifdef USE_PROPERTY_PAGES
	// ISpecifyPropertyPages methods
	STDMETHODIMP GetPages(OUT CAUUID *pPages);
#endif

#ifdef USE_NETWORK_STATISTICS
	// Implement INetworkStats
	STDMETHODIMP SetChannelErrors(IN CHANNELERRORS_S *pChannelErrors, IN DWORD dwLayerId);
	STDMETHODIMP GetChannelErrors(OUT CHANNELERRORS_S *pChannelErrors, IN WORD dwLayerId);
	STDMETHODIMP GetChannelErrorsRange(OUT CHANNELERRORS_S *pMin, OUT CHANNELERRORS_S *pMax, OUT CHANNELERRORS_S *pSteppingDelta, OUT CHANNELERRORS_S *pDefault, IN DWORD dwLayerId);
	STDMETHODIMP SetPacketLossRate(IN DWORD dwPacketLossRate, IN DWORD dwLayerId);
	STDMETHODIMP GetPacketLossRate(OUT LPDWORD pdwPacketLossRate, IN DWORD dwLayerId);
	STDMETHODIMP GetPacketLossRateRange(OUT LPDWORD pdwMin, OUT LPDWORD pdwMax, OUT LPDWORD pdwSteppingDelta, OUT LPDWORD pdwDefault, IN DWORD dwLayerId);
#endif

	// Implement IH245Capability
	STDMETHODIMP GetH245VersionID(OUT DWORD *pdwVersionID);
	STDMETHODIMP GetFormatTable(OUT H245MediaCapabilityTable *pTable);
	STDMETHODIMP ReleaseFormatTable(IN H245MediaCapabilityTable *pTable);
	STDMETHODIMP IntersectFormats(
        IN DWORD dwUniqueID, 
        IN const H245MediaCapability *pLocalCapability, 
        IN const H245MediaCapability *pRemoteCapability, 
        OUT H245MediaCapability **ppIntersectedCapability,
        OUT  DWORD *pdwPayloadType
        );
	STDMETHODIMP Refine(IN OUT H245MediaCapability *pLocalCapability, IN DWORD dwUniqueID, IN DWORD dwResourceBoundIndex);
	STDMETHODIMP GetLocalFormat(IN DWORD dwUniqueID, IN const H245MediaCapability *pIntersectedCapability, OUT AM_MEDIA_TYPE **ppAMMediaType);
	STDMETHODIMP ReleaseNegotiatedCapability(IN H245MediaCapability *pIntersectedCapability);
	STDMETHODIMP FindIDByRange(IN const AM_MEDIA_TYPE *pAMMediaType, OUT DWORD *pdwID);
#ifdef TEST_H245_VID_CAPS
	STDMETHODIMP TestH245VidC();
#endif

	// Implement H245EncoderCommand
	STDMETHODIMP videoFastUpdatePicture();
	STDMETHODIMP videoFastUpdateGOB(IN DWORD dwFirstGOB, IN DWORD dwNumberOfGOBs);
	STDMETHODIMP videoFastUpdateMB(IN DWORD dwFirstGOB, IN DWORD dwFirstMB, IN DWORD dwNumberOfMBs);
	STDMETHODIMP videoSendSyncEveryGOB(IN BOOL fEnable);
	STDMETHODIMP videoNotDecodedMBs(IN DWORD dwFirstMB, IN DWORD dwNumberOfMBs, IN DWORD dwTemporalReference);

#ifdef USE_PROGRESSIVE_REFINEMENT
	// Implement IProgressiveRefinement
	STDMETHODIMP doOneProgression();
	STDMETHODIMP doContinuousProgressions();
	STDMETHODIMP doOneIndependentProgression();
	STDMETHODIMP doContinuousIndependentProgressions();
	STDMETHODIMP progressiveRefinementAbortOne();
	STDMETHODIMP progressiveRefinementAbortContinuous();
#endif

	private:

	friend class CTAPIVCap;
	// friend class CPreviewPin;
	friend class CRtpPdPin;
	friend class CAlloc;
	friend class CCapDev;

#ifdef USE_NETWORK_STATISTICS
	// Network statistics
	CHANNELERRORS_S m_ChannelErrors;
	CHANNELERRORS_S m_ChannelErrorsMin;
	CHANNELERRORS_S m_ChannelErrorsMax;
	CHANNELERRORS_S m_ChannelErrorsSteppingDelta;
	CHANNELERRORS_S m_ChannelErrorsDefault;
	DWORD m_dwPacketLossRate;
	DWORD m_dwPacketLossRateMin;
	DWORD m_dwPacketLossRateMax;
	DWORD m_dwPacketLossRateSteppingDelta;
	DWORD m_dwPacketLossRateDefault;
#endif

	// H.245 Video Capabilities
	H245MediaCapabilityMap	*m_pH245MediaCapabilityMap;
	VideoResourceBounds		*m_pVideoResourceBounds;
	FormatResourceBounds	*m_pFormatResourceBounds;

	// Payload type
	DWORD m_dwRTPPayloadType;

	// Format helper
	STDMETHODIMP GetStringFromStringTable(IN UINT uStringID, OUT WCHAR* pwchDescription);

	// Delivery method
    HRESULT	SendFrames(IN CFrameSample *pCapSample, IN CFrameSample *pPrevSample, IN PBYTE pbyInBuff, IN DWORD dwInBytes, OUT PDWORD pdwBytesUsed, OUT PDWORD pdwBytesExtent, IN BOOL bDiscon);
};

#endif // _CAPTURE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\cameracs.cpp ===
/****************************************************************************
 *  @doc INTERNAL CAMERACS
 *
 *  @module CameraCS.cpp | Source file for the <c CTAPIBasePin> class methods
 *    used to implement the software-only camera control functions.
 ***************************************************************************/

#include "Precomp.h"

#ifdef USE_SOFTWARE_CAMERA_CONTROL

/****************************************************************************
 *  @doc INTERNAL CCONVERTMETHOD
 *
 *  @mfunc void | CConverter | InsertSoftCamCtrl | This method inserts a
 *    software-only camera controller.
 *
 *  @todo Verify error management
 ***************************************************************************/
HRESULT CConverter::InsertSoftCamCtrl() 
{
	HRESULT	Hr;
	DWORD	dwBmiSize;

	FX_ENTRY("CConverter::InsertSoftCamCtrl")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	if (m_dwConversionType == CONVERSIONTYPE_NONE)
	{
		// We already have an input and output buffer (e.g. 160x120 RGB24 -> Processed RGB24)
		// This doesn't require any temporary buffer
		m_dwConversionType |= CONVERSIONTYPE_SCALER;
	}
	else if (!(m_dwConversionType & CONVERSIONTYPE_SCALER))
	{
		// Backup input format bitmap info header
		dwBmiSize = m_pbiIn->biSize;

		// Copy the palette if necessary
		if (m_pbiIn->biCompression == BI_RGB)
		{
			if (m_pbiIn->biBitCount == 8)
			{
				dwBmiSize += (DWORD)(m_pbiIn->biClrImportant ? m_pbiIn->biClrImportant * sizeof(RGBQUAD) : 256 * sizeof(RGBQUAD));
			}
			else if (m_pbiIn->biBitCount == 4)
			{
				dwBmiSize += (DWORD)(m_pbiIn->biClrImportant ? m_pbiIn->biClrImportant * sizeof(RGBQUAD) : 16 * sizeof(RGBQUAD));
			}
		}

		// We already have an input, output, AND intermediary buffer  (e.g. 160x120 RGB24 -> 176x144 Processed RGB24 -> 176x144 Processed H.26X or 160x120 YVU9 -> 160x120 Processed RGB24 -> 176x144 H.26X)
		// Use this intermediary buffer to apply the camera control operations
		m_dwConversionType |= CONVERSIONTYPE_SCALER;

		if (m_pbiIn->biCompression == BI_RGB || m_pbiIn->biCompression == VIDEO_FORMAT_YVU9 || m_pbiIn->biCompression == VIDEO_FORMAT_YUY2 || m_pbiIn->biCompression == VIDEO_FORMAT_UYVY || m_pbiIn->biCompression == VIDEO_FORMAT_I420 || m_pbiIn->biCompression == VIDEO_FORMAT_IYUV)
		{
			// The camera control operations will occur before the format conversion
			m_dwConversionType |= CONVERSIONTYPE_PRESCALER;

			// The input and intermediary buffers are both RGB (e.g. 160x120 RGB24 -> 176x144 Processed RGB24 -> 176x144 H.26X)
			if (!(m_pbiInt = (PBITMAPINFOHEADER)(new BYTE[(m_pbiIn->biBitCount == 4) ? m_pbiIn->biSize + 256 * sizeof(RGBQUAD) : dwBmiSize])))
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
				Hr = E_OUTOFMEMORY;
				goto MyError;
			}

			CopyMemory(m_pbiInt, m_pbiIn, dwBmiSize);

			// If the input is 4bpp, we'll use a RGB8 intermediate format
			if (m_pbiIn->biBitCount == 4)
			{
				m_pbiInt->biBitCount = 8;
				m_pbiInt->biClrImportant = 256;
			}
			m_pbiInt->biWidth = m_pbiOut->biWidth;
			m_pbiInt->biHeight = m_pbiOut->biHeight;
			m_pbiInt->biSizeImage = DIBSIZE(*m_pbiInt);

			// Allocate intermediary buffer
			if (!(m_pbyOut = (PBYTE)(new BYTE[m_pbiInt->biSizeImage])))
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
				Hr = E_OUTOFMEMORY;
				goto MyError;
			}
		}
		else
		{
			// We will need to decompress to an intermediary format if a camera control operation is necessary (e.g. 160x120 MJPEG -> 160x120 RGB24 -> 176x144 Processed RGB24)
			if (!(m_pbiInt = (PBITMAPINFOHEADER)(new BYTE[m_pbiOut->biSize])))
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
				Hr = E_OUTOFMEMORY;
				goto MyError;
			}
			CopyMemory(m_pbiInt, m_pbiOut, m_pbiOut->biSize);
			m_pbiInt->biWidth = m_pbiIn->biWidth;
			m_pbiInt->biHeight = m_pbiIn->biHeight;
			m_pbiInt->biSizeImage = DIBSIZE(*m_pbiInt);

			// Allocate intermediary buffer
			if (!(m_pbyOut = (PBYTE)(new BYTE[m_pbiInt->biSizeImage])))
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
				Hr = E_OUTOFMEMORY;
				goto MyError;
			}
		}
	}

	// Mark success
	m_fSoftCamCtrl = TRUE;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: Software-only camera controller insterted", _fx_));

	Hr = NOERROR;

	goto MyExit;

MyError:
	if (m_pbiInt)
		delete m_pbiInt, m_pbiInt = NULL;
MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}


/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | OpenSoftCamCtrl | This method opens a
 *    software-only camera controller.
 *
 *  @todo Verify error management
 ***************************************************************************/
HRESULT CTAPIBasePin::OpenSoftCamCtrl(PBITMAPINFOHEADER pbiIn, PBITMAPINFOHEADER pbiOut)
{
	HRESULT	Hr = NOERROR;
	DWORD dwBmiSize, dwOutBmiSize;

	FX_ENTRY("CTAPIBasePin::OpenSoftCamCtrl")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Default to failure
	m_fSoftCamCtrl = FALSE;

	// Validate input parameters
	ASSERT(pbiIn);
	ASSERT(pbiOut);
	if (!pbiIn || !pbiOut)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	ASSERT(!m_pbiSCCIn);
	ASSERT(!m_pbiSCCOut);
	if (m_pbiSCCIn || m_pbiSCCOut)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid state", _fx_));
		Hr = E_UNEXPECTED;
		goto MyExit;
	}

	// Backup input format bitmap info header
	dwBmiSize = pbiIn->biSize;

	// Copy the palette if necessary
	if (pbiIn->biCompression == BI_RGB)
	{
		if (pbiIn->biBitCount == 8)
		{
			dwBmiSize += (DWORD)(pbiIn->biClrImportant ? pbiIn->biClrImportant * sizeof(RGBQUAD) : 256 * sizeof(RGBQUAD));
		}
		else if (pbiIn->biBitCount == 4)
		{
			dwBmiSize += (DWORD)(pbiIn->biClrImportant ? pbiIn->biClrImportant * sizeof(RGBQUAD) : 16 * sizeof(RGBQUAD));
		}
	}

	if (!(m_pbiSCCIn = (PBITMAPINFOHEADER)(new BYTE[dwBmiSize])))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
		Hr = E_OUTOFMEMORY;
		goto MyExit;
	}

	// @todo Why are we making a copy exactly?
	CopyMemory(m_pbiSCCIn, pbiIn, dwBmiSize);

	// Backup output format bitmap info header
	// @todo Why do we make copy of this instead of keeping a reference to the bitmap infoheader?
	dwOutBmiSize = pbiOut->biSize;

	// Copy the palette if necessary
	if (pbiOut->biCompression == BI_RGB)
	{
		if (pbiOut->biBitCount == 8)
		{
			dwOutBmiSize += (DWORD)(pbiOut->biClrImportant ? pbiOut->biClrImportant * sizeof(RGBQUAD) : 256 * sizeof(RGBQUAD));
		}
		else if (pbiOut->biBitCount == 4)
		{
			dwOutBmiSize += (DWORD)(pbiOut->biClrImportant ? pbiOut->biClrImportant * sizeof(RGBQUAD) : 16 * sizeof(RGBQUAD));
		}
	}

	if (!(m_pbiSCCOut = (PBITMAPINFOHEADER)(new BYTE[dwOutBmiSize])))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
		Hr = E_OUTOFMEMORY;
		goto MyError0;
	}
	CopyMemory(m_pbiSCCOut, pbiOut, dwOutBmiSize);

	// We only need to allocate one intermediary buffer that will contain
	// the result of the operation. This buffer will then be compressed to H.26X
	// or copied to the output buffer for preview.
	// @todo Find a way to go around this extra memory copy in the preview case
	if (!(m_pbyCamCtrl = (PBYTE)(new BYTE[m_pbiSCCIn->biSizeImage])))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
		Hr = E_OUTOFMEMORY;
		goto MyError1;
	}

	// Mark success
	m_fSoftCamCtrl = TRUE;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: Software-only camera controller ready", _fx_));

	goto MyExit;

MyError1:
	if (m_pbiSCCOut)
		delete m_pbiSCCOut, m_pbiSCCOut = NULL;
MyError0:
	if (m_pbiSCCIn)
		delete m_pbiSCCIn, m_pbiSCCIn = NULL;
MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc BOOL | CTAPIBasePin | IsSoftCamCtrlOpen | This method checks if
 *    a software-only camera controller has already been opened.
 *
 *  @rdesc Returns TRUE if a software-only camera controller has already been opened
 ***************************************************************************/
BOOL CTAPIBasePin::IsSoftCamCtrlOpen()
{
	FX_ENTRY("CTAPIBasePin::IsSoftCamCtrlOpen")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

	return m_fSoftCamCtrl;
}

/****************************************************************************
 *  @doc INTERNAL CCONVERTMETHOD
 *
 *  @mfunc BOOL | CConverter | IsSoftCamCtrlInserted | This method checks if
 *    a software-only camera controller has already been inserted.
 *
 *  @rdesc Returns TRUE if a software-only camera controller has already
 *    been inserted
 ***************************************************************************/
BOOL CConverter::IsSoftCamCtrlInserted()
{
	FX_ENTRY("CConverter::IsSoftCamCtrlInserted")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

	return m_fSoftCamCtrl;
}

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPINMETHOD
 *
 *  @mfunc HRESULT | CPreviewPin | IsSoftCamCtrlNeeded | This method verifies
 *    if a software-only camera controller is needed.
 *
 *  @todo You'll need a function like this one for RGB16 and RGB8
 *    too. In RGB8, make sure you use the Indeo palette, like NM.
 ***************************************************************************/
BOOL CTAPIBasePin::IsSoftCamCtrlNeeded()
{
	BOOL fRes;

	FX_ENTRY("CTAPIBasePin::IsSoftCamCtrlNeeded")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	fRes = m_pCaptureFilter && (m_fFlipHorizontal || m_fFlipVertical || (m_pCaptureFilter->m_pCapDev->m_lCCZoom > 10 && m_pCaptureFilter->m_pCapDev->m_lCCZoom <= 600) || m_pCaptureFilter->m_pCapDev->m_lCCPan != 0 || m_pCaptureFilter->m_pCapDev->m_lCCTilt != 0);

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

	return fRes;
}

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPINMETHOD
 *
 *  @mfunc HRESULT | CConverter | IsSoftCamCtrlNeeded | This method verifies
 *    if a software-only camera controller is needed.
 *
 *  @rdesc Returns TRUE if a software-only camera controller is needed
 ***************************************************************************/
BOOL CConverter::IsSoftCamCtrlNeeded()
{
	BOOL fRes;

	FX_ENTRY("CConverter::IsSoftCamCtrlNeeded")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	fRes = m_pBasePin->m_pCaptureFilter && (m_pBasePin->m_fFlipHorizontal || m_pBasePin->m_fFlipVertical || (m_pBasePin->m_pCaptureFilter->m_pCapDev->m_lCCZoom > 10 && m_pBasePin->m_pCaptureFilter->m_pCapDev->m_lCCZoom <= 600) || m_pBasePin->m_pCaptureFilter->m_pCapDev->m_lCCPan != 0 || m_pBasePin->m_pCaptureFilter->m_pCapDev->m_lCCTilt != 0);

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

	return fRes;
}

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPINMETHOD
 *
 *  @mfunc HRESULT | CPreviewPin | ApplySoftCamCtrl | This method applies
 *    software-only camera control operators.
 *
 *  @todo You'll need a function like this one for RGB16 and RGB8
 *    too. In RGB8, make sure you use the Indeo palette, like NM.
 ***************************************************************************/
HRESULT CTAPIBasePin::ApplySoftCamCtrl(PBYTE pbyInput, DWORD dwInBytes, PBYTE pbyOutput, PDWORD pdwBytesUsed, PDWORD pdwBytesExtent)
{
	HRESULT Hr = NOERROR;
	RECT	rcRect;

	FX_ENTRY("CTAPIBasePin::ApplySoftCamCtrl")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(m_pbiSCCIn);
	ASSERT(m_pbiSCCOut);
	ASSERT(pbyInput);
	ASSERT(pbyOutput);
	if (!m_pbiSCCIn || !m_pbiSCCOut || !pbyInput || !pbyOutput)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Get the input rectangle
	ComputeRectangle(m_pbiSCCIn, m_pbiSCCOut, m_pCaptureFilter->m_pCapDev->m_lCCZoom, m_pCaptureFilter->m_pCapDev->m_lCCPan, m_pCaptureFilter->m_pCapDev->m_lCCTilt, &rcRect, m_fFlipHorizontal, m_fFlipVertical);

	// Scale DIB
	ScaleDIB(m_pbiSCCIn, pbyInput, m_pbiSCCOut, pbyOutput, &rcRect, m_fFlipHorizontal, m_fFlipVertical, m_fNoImageStretch, m_dwBlackEntry);

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | CloseSoftCamCtrl | This method closes a
 *    software-only camera controller.
 ***************************************************************************/
HRESULT CTAPIBasePin::CloseSoftCamCtrl()
{
	FX_ENTRY("CTAPIBasePin::CloseSoftCamCtrl")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Free memory
	if (m_pbyCamCtrl)
		delete m_pbyCamCtrl, m_pbyCamCtrl = NULL;

	if (m_pbiSCCOut)
		delete m_pbiSCCOut, m_pbiSCCOut = NULL;

	if (m_pbiSCCIn)
		delete m_pbiSCCIn, m_pbiSCCIn = NULL;

	m_fSoftCamCtrl = FALSE;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CCONVERTMETHOD
 *
 *  @mfunc BOOL | CConverter | RemoveSoftCamCtrl | This method disables
 *    a software-only camera controller that has already been inserted.
 *
 *  @rdesc Returns NOERROR
 ***************************************************************************/
HRESULT CConverter::RemoveSoftCamCtrl()
{
	FX_ENTRY("CConverter::RemoveSoftCamCtrl")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Restore flags and release memory if necessary
	m_dwConversionType = m_dwConversionType & ~(CONVERSIONTYPE_SCALER | CONVERSIONTYPE_PRESCALER);

	if ((m_pbiIn->biWidth == m_pbiOut->biWidth && m_pbiIn->biHeight == m_pbiOut->biHeight))
	{
		if (m_pbyOut)
			delete m_pbyOut, m_pbyOut = NULL;
		if (m_pbiInt)
			delete m_pbiInt, m_pbiInt = NULL;
	}
	else
	{
		// We need a size change
		m_dwConversionType |= CONVERSIONTYPE_SCALER;

		if (m_pbiIn->biCompression == BI_RGB || m_pbiIn->biCompression == VIDEO_FORMAT_YVU9 || m_pbiIn->biCompression == VIDEO_FORMAT_YUY2 || m_pbiIn->biCompression == VIDEO_FORMAT_UYVY || m_pbiIn->biCompression == VIDEO_FORMAT_I420 || m_pbiIn->biCompression == VIDEO_FORMAT_IYUV)
		{
			// The scaling will occur before the format conversion
			m_dwConversionType |= CONVERSIONTYPE_PRESCALER;
		}
	}

	m_fSoftCamCtrl = FALSE;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

	return NOERROR;
}

#endif // USE_SOFTWARE_CAMERA_CONTROL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\cameracp.cpp ===
/****************************************************************************
 *  @doc INTERNAL CAMERACP
 *
 *  @module CameraCP.cpp | Source file for the <c CCameraControlProperty>
 *    class used to implement a property page to test the TAPI interface
 *    <i ICameraControl>.
 *
 *  @comm This code tests the TAPI Video Capture filter <i ICameraControl>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
 ***************************************************************************/

#include "Precomp.h"

#ifdef USE_PROPERTY_PAGES

#ifdef USE_SOFTWARE_CAMERA_CONTROL

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc void | CCameraControlProperty | CCameraControlProperty | This
 *    method is the constructor for camera control property objects. It
 *    calls the base class constructor, calls InitCommonControlsEx, and saves
 *    a pointer to the <i ICameraControl> interface.
 *
 *  @parm HWND | hDlg | Specifies a handle to the parent property page.
 *
 *  @parm ULONG | IDLabel | Specifies a label ID for the property.
 *
 *  @parm ULONG | IDMinControl | Specifies a label ID for the associated
 *    property edit control where the Minimum value of the property appears.
 *
 *  @parm ULONG | IDMaxControl | Specifies a label ID for the associated
 *    property edit control where the Maximum value of the property appears.
 *
 *  @parm ULONG | IDDefaultControl | Specifies a label ID for the associated
 *    property edit control where the Default value of the property appears.
 *
 *  @parm ULONG | IDStepControl | Specifies a label ID for the associated
 *    property edit control where the Stepping Delta value of the property appears.
 *
 *  @parm ULONG | IDEditControl | Specifies a label ID for the associated
 *    property edit control where the value of the property appears.
 *
 *  @parm ULONG | IDTrackbarControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProgressControl | Specifies a label ID for the associated
 *    property progress bar.
 *
 *  @parm ULONG | IDProperty | Specifies the ID of the Ks property.
 *
 *  @parm ICameraControl* | pInterface | Specifies a pointer to the
 *    <i ICameraControl> interface.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCameraControlProperty::CCameraControlProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, ICameraControl *pInterface)
: CPropertyEditor(hDlg, IDLabel, IDMinControl, IDMaxControl, IDDefaultControl, IDStepControl, IDEditControl, IDTrackbarControl, IDProgressControl, IDProperty, IDAutoControl)
{
	INITCOMMONCONTROLSEX cc;

	FX_ENTRY("CCameraControlProperty::CCameraControlProperty")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	cc.dwSize = sizeof (INITCOMMONCONTROLSEX);
	cc.dwICC  = ICC_UPDOWN_CLASS | ICC_BAR_CLASSES;

	InitCommonControlsEx(&cc);

	// It's fine if the interface pointer is NULL, we'll grey the
	// associated items in the property page
	m_pInterface = pInterface;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc void | CCameraControlProperty | ~CCameraControlProperty | This
 *    method is the destructor for camera control property objects. It
 *    simply calls the base class destructor.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCameraControlProperty::~CCameraControlProperty()
{
	FX_ENTRY("CCameraControlProperty::~CCameraControlProperty")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperty | GetValue | This method queries for
 *    the value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperty::GetValue()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCameraControlProperty::GetValue")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	if (!m_pInterface)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_FAIL;
		goto MyExit;
	}

	if (SUCCEEDED (Hr = m_pInterface->Get((TAPICameraControlProperty)m_IDProperty, &m_CurrentValue, (TAPIControlFlags *)&m_CurrentFlags)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_CurrentValue=%ld, m_CurrentFlags=%ld", _fx_, m_CurrentValue, m_CurrentFlags));
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: m_pICameraControl->Get failed Hr=0x%08lX", _fx_, Hr));
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperty | SetValue | This method sets the
 *    value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperty::SetValue()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCameraControlProperty::SetValue")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	if (!m_pInterface)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_FAIL;
		goto MyExit;
	}

	if (SUCCEEDED (Hr = m_pInterface->Set((TAPICameraControlProperty)m_IDProperty, m_CurrentValue, (TAPIControlFlags)m_CurrentFlags)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_CurrentValue=%ld, m_CurrentFlags=%ld", _fx_, m_CurrentValue, m_CurrentFlags));
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: m_pICameraControl->Set failed Hr=0x%08lX", _fx_, Hr));
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperty | GetRange | This method retrieves
 *    the range information of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperty::GetRange()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCameraControlProperty::GetRange")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	if (!m_pInterface)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_FAIL;
		goto MyExit;
	}

	if (SUCCEEDED (Hr = m_pInterface->GetRange((TAPICameraControlProperty)m_IDProperty, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, (TAPIControlFlags *)&m_CapsFlags)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Min=%ld, m_Max=%ld, m_SteppingDelta=%ld, m_DefaultValue=%ld, m_CapsFlags=%ld", _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue, m_CapsFlags));
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: m_pICameraControl->GetRange failed Hr=0x%08lX", _fx_, Hr));
	}
	m_DefaultFlags = m_CapsFlags;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc CUnknown* | CCameraControlProperties | CreateInstance | This
 *    method is called by DShow to create an instance of a
 *    Property Page. It is referred to in the global structure <t g_Templates>.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Returns a pointer to the nondelegating CUnknown portion of the
 *    object, or NULL otherwise.
 ***************************************************************************/
CUnknown* CALLBACK CCameraControlPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr) 
{
	CUnknown *pUnknown = (CUnknown *)NULL;

	FX_ENTRY("CCameraControlPropertiesCreateInstance")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pHr);
	if (!pHr)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		goto MyExit;
	}

	if (!(pUnknown = new CCameraControlProperties(pUnkOuter, pHr)))
	{
		*pHr = E_OUTOFMEMORY;
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: new CCameraControlProperties failed", _fx_));
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: new CCameraControlProperties created", _fx_));
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return pUnknown;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc void | CCameraControlProperties | CCameraControlProperties | This
 *    method is the constructor for the property page object. It simply
 *    calls the constructor of the property page base class.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCameraControlProperties::CCameraControlProperties(LPUNKNOWN pUnk, HRESULT *pHr) : CBasePropertyPage(NAME("Camera Control Property Page"), pUnk, IDD_CameraControlProperties, IDS_CAMERACONTROLPROPNAME)
{
	FX_ENTRY("CCameraControlProperties::CCameraControlProperties")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	m_pICameraControl = NULL;
	m_NumProperties = NUM_CAMERA_CONTROLS;
	m_fActivated = FALSE;

	for (int i = 0; i < m_NumProperties; i++)
		m_Controls[i] = NULL;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc void | CCameraControlProperties | ~CCameraControlProperties | This
 *    method is the destructor for camera control property page. It
 *    simply calls the base class destructor after deleting all the controls.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCameraControlProperties::~CCameraControlProperties()
{
	int		j;

	FX_ENTRY("CCameraControlProperties::~CCameraControlProperties")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX", _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: control already freed", _fx_));
		}
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperties | OnConnect | This
 *    method is called when the property page is connected to the filter.
 *
 *  @parm LPUNKNOWN | pUnknown | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperties::OnConnect(IUnknown *pUnk)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCameraControlProperties::OnConnect")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pUnk);
	if (!pUnk)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Get the camera control interface
	if (SUCCEEDED (Hr = pUnk->QueryInterface(__uuidof(ICameraControl),(void **)&m_pICameraControl)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_pICameraControl=0x%08lX", _fx_, m_pICameraControl));
	}
	else
	{
		m_pICameraControl = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: IOCTL failed Hr=0x%08lX", _fx_, Hr));
	}

	// It's Ok if we couldn't get interface pointers. We'll just grey the controls in the property page
	// to make it clear to the user that they can't control those properties on the device
	Hr = NOERROR;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperties | OnDisconnect | This
 *    method is called when the property page is disconnected from the owning
 *    filter.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperties::OnDisconnect()
{
	FX_ENTRY("CCameraControlProperties::OnDisconnect")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters: we seem to get called several times here
	// Make sure the interface pointer is still valid
	if (!m_pICameraControl)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: already disconnected!", _fx_));
	}
	else
	{
		// Release the interface
		m_pICameraControl->Release();
		m_pICameraControl = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: releasing m_pICameraControl", _fx_));
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperties | OnActivate | This
 *    method is called when the property page is activated.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperties::OnActivate()
{
	HRESULT	Hr = E_OUTOFMEMORY;
	int		j;

	FX_ENTRY("CCameraControlProperties::OnActivate")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Create the controls for the properties
	if (!(m_Controls[0] = new CCameraControlProperty(m_hwnd, IDC_Pan_Label, IDC_Pan_Minimum, IDC_Pan_Maximum, IDC_Pan_Default, IDC_Pan_Stepping, IDC_Pan_Edit, IDC_Pan_Slider, 0, TAPICameraControl_Pan, IDC_Pan_Auto, m_pICameraControl)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: mew m_Controls[TAPICameraControl_Pan] failed - Out of memory", _fx_));
		goto MyExit;
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[TAPICameraControl_Pan]=0x%08lX", _fx_, m_Controls[0]));
	}

	if (!(m_Controls[1] = new CCameraControlProperty(m_hwnd, IDC_Tilt_Label, IDC_Tilt_Minimum, IDC_Tilt_Maximum, IDC_Tilt_Default, IDC_Tilt_Stepping, IDC_Tilt_Edit, IDC_Tilt_Slider, 0, TAPICameraControl_Tilt, IDC_Tilt_Auto, m_pICameraControl)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: mew m_Controls[TAPICameraControl_Tilt] failed - Out of memory", _fx_));
		goto MyError0;
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[TAPICameraControl_Tilt]=0x%08lX", _fx_, m_Controls[1]));
	}

	if (!(m_Controls[2] = new CCameraControlProperty(m_hwnd, IDC_Roll_Label, IDC_Roll_Minimum, IDC_Roll_Maximum, IDC_Roll_Default, IDC_Roll_Stepping, IDC_Roll_Edit, IDC_Roll_Slider, 0, TAPICameraControl_Roll, IDC_Roll_Auto, m_pICameraControl)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: mew m_Controls[TAPICameraControl_Roll] failed - Out of memory", _fx_));
		goto MyError1;
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[TAPICameraControl_Roll]=0x%08lX", _fx_, m_Controls[2]));
	}

	if (!(m_Controls[3] = new CCameraControlProperty(m_hwnd, IDC_Zoom_Label, IDC_Zoom_Minimum, IDC_Zoom_Maximum, IDC_Zoom_Default, IDC_Zoom_Stepping, IDC_Zoom_Edit, IDC_Zoom_Slider, 0, TAPICameraControl_Zoom, IDC_Zoom_Auto, m_pICameraControl)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: mew m_Controls[TAPICameraControl_Zoom] failed - Out of memory", _fx_));
		goto MyError2;
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[TAPICameraControl_Zoom]=0x%08lX", _fx_, m_Controls[3]));
	}

	if (!(m_Controls[4] = new CCameraControlProperty(m_hwnd, IDC_Exposure_Label, IDC_Exposure_Minimum, IDC_Exposure_Maximum, IDC_Exposure_Default, IDC_Exposure_Stepping, IDC_Exposure_Edit, IDC_Exposure_Slider, 0, TAPICameraControl_Exposure, IDC_Exposure_Auto, m_pICameraControl)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: mew m_Controls[TAPICameraControl_Exposure] failed - Out of memory", _fx_));
		goto MyError3;
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[TAPICameraControl_Exposure]=0x%08lX", _fx_, m_Controls[4]));
	}

	if (!(m_Controls[5] = new CCameraControlProperty(m_hwnd, IDC_Iris_Label, IDC_Iris_Minimum, IDC_Iris_Maximum, IDC_Iris_Default, IDC_Iris_Stepping, IDC_Iris_Edit, IDC_Iris_Slider, 0, TAPICameraControl_Iris, IDC_Iris_Auto, m_pICameraControl)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: mew m_Controls[TAPICameraControl_Iris] failed - Out of memory", _fx_));
		goto MyError4;
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[TAPICameraControl_Iris]=0x%08lX", _fx_, m_Controls[5]));
	}

	if (!(m_Controls[6] = new CCameraControlProperty(m_hwnd, IDC_Focus_Label, IDC_Focus_Minimum, IDC_Focus_Maximum, IDC_Focus_Default, IDC_Focus_Stepping, IDC_Focus_Edit, IDC_Focus_Slider, 0, TAPICameraControl_Focus, 0, m_pICameraControl)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: mew m_Controls[TAPICameraControl_Focus] failed - Out of memory", _fx_));
		goto MyError5;
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[TAPICameraControl_Focus]=0x%08lX", _fx_, m_Controls[6]));
	}

	if (!(m_Controls[7] = new CCameraControlProperty(m_hwnd, 0, 0, 0, 0, 0, IDC_FlipVertical_Edit, 0, 0, TAPICameraControl_FlipVertical, 0, m_pICameraControl)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: mew m_Controls[TAPICameraControl_FlipVertical] failed - Out of memory", _fx_));
		goto MyError6;
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[TAPICameraControl_FlipVertical]=0x%08lX", _fx_, m_Controls[7]));
	}

	if (!(m_Controls[8] = new CCameraControlProperty(m_hwnd, 0, 0, 0, 0, 0, IDC_FlipHorizontal_Edit, 0, 0, TAPICameraControl_FlipHorizontal, 0, m_pICameraControl)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: mew m_Controls[TAPICameraControl_FlipHorizontal] failed - Out of memory", _fx_));
		goto MyError7;
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[TAPICameraControl_FlipHorizontal]=0x%08lX", _fx_, m_Controls[8]));
	}


	// Initialize all the controls. If the initialization fails, it's Ok. It just means
	// that the TAPI control interface isn't implemented by the device. The dialog item
	// in the property page will be greyed, showing this to the user.
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j]->Init())
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[%ld]->Init()", _fx_, j));
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: m_Controls[%ld]->Init() failed", _fx_, j));
		}
	}

	Hr = NOERROR;
	goto MyExit;

MyError7:
	if (m_Controls[7])
		delete m_Controls[7], m_Controls[7] = NULL;
MyError6:
	if (m_Controls[6])
		delete m_Controls[6], m_Controls[6] = NULL;
MyError5:
	if (m_Controls[5])
		delete m_Controls[5], m_Controls[5] = NULL;
MyError4:
	if (m_Controls[4])
		delete m_Controls[4], m_Controls[4] = NULL;
MyError3:
	if (m_Controls[3])
		delete m_Controls[3], m_Controls[3] = NULL;
MyError2:
	if (m_Controls[2])
		delete m_Controls[2], m_Controls[2] = NULL;
MyError1:
	if (m_Controls[1])
		delete m_Controls[1], m_Controls[1] = NULL;
MyError0:
	if (m_Controls[0])
		delete m_Controls[0], m_Controls[0] = NULL;
MyExit:
	m_fActivated = TRUE;
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperties | OnDeactivate | This
 *    method is called when the property page is dismissed.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperties::OnDeactivate()
{
	int		j;

	FX_ENTRY("CCameraControlProperties::OnDeactivate")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX", _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: control already freed", _fx_));
		}
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	m_fActivated = FALSE;
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc HRESULT | CCameraControlProperties | OnApplyChanges | This
 *    method is called when the user applies changes to the property page.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCameraControlProperties::OnApplyChanges()
{
	HRESULT	Hr = NOERROR;

	FX_ENTRY("CCameraControlProperties::OnApplyChanges")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	for (int j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			if (m_Controls[j]->HasChanged())
			{
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: calling m_Controls[%ld]=0x%08lX->OnApply", _fx_, j, m_Controls[j]));
				m_Controls[j]->OnApply();
			}
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: can't call m_Controls[%ld]=NULL->OnApply", _fx_, j));
			Hr = E_UNEXPECTED;
			break;
		}
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc BOOL | CCameraControlProperties | OnReceiveMessage | This
 *    method is called when a message is sent to the property page dialog box.
 *
 *  @rdesc By default, returns the value returned by the Win32 DefWindowProc function.
 ***************************************************************************/
BOOL CCameraControlProperties::OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
	int iNotify = HIWORD (wParam);
	int j;

	switch (uMsg)
	{
		case WM_INITDIALOG:
			return TRUE; // Don't call setfocus

		case WM_HSCROLL:
		case WM_VSCROLL:
			if (m_fActivated)
			{
				// Process all of the Trackbar messages
				for (j = 0; j < m_NumProperties; j++)
				{
					ASSERT(m_Controls[j]);
					if (m_Controls[j]->GetTrackbarHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnScroll(uMsg, wParam, lParam);
						SetDirty();
					}
				}
				OnApplyChanges();
			}
			break;

		case WM_COMMAND:

			// This message gets sent even before OnActivate() has been
			// called(!). We need to test and make sure the controls have
			// beeen initialized before we can use them.

			if (m_fActivated)
			{
				// Process all of the auto checkbox messages
				for (j = 0; j < m_NumProperties; j++)
				{
					if (m_Controls[j] && m_Controls[j]->GetAutoHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnAuto(uMsg, wParam, lParam);
						SetDirty();
						break;
					}
				}

				// Process all of the edit box messages
				for (j = 0; j < m_NumProperties; j++)
				{
					if (m_Controls[j] && m_Controls[j]->GetEditHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnEdit(uMsg, wParam, lParam);
						SetDirty();
						break;
					}
				}

				switch (LOWORD(wParam))
				{
					case IDC_CONTROL_DEFAULT:
						for (j = 0; j < m_NumProperties; j++)
						{
							if (m_Controls[j])
								m_Controls[j]->OnDefault();
						}
						break;

					default:
						break;
				}

			OnApplyChanges();
			}
			break;

		default:
			return FALSE;
	}

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CCAMERACPMETHOD
 *
 *  @mfunc BOOL | CCameraControlProperties | SetDirty | This
 *    method notifies the property page site of changes.
 *
 *  @rdesc Nada.
 ***************************************************************************/
void CCameraControlProperties::SetDirty()
{
	m_bDirty = TRUE;
	if (m_pPageSite)
		m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}

#endif // USE_SOFTWARE_CAMERA_CONTROL

#endif // USE_PROPERTY_PAGES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\capture.cpp ===
/****************************************************************************
 *  @doc INTERNAL CAPTURE
 *
 *  @module Capture.cpp | Source file for the <c CCapturePin> class methods
 *    used to implement the video capture output pin.
 ***************************************************************************/

#include "Precomp.h"

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPINMETHOD
 *
 *  @mfunc CCapturePin* | CCapturePin | CreateCapturePin | This helper
 *    function creates a video output pin for capture.
 *
 *  @parm CTAPIVCap* | pCaptureFilter | Specifies a pointer to the owner
 *    filter.
 *
 *  @parm CCapturePin** | ppCapturePin | Specifies that address of a pointer
 *    to a <c CCapturePin> object to receive the a pointer to the newly
 *    created pin.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CALLBACK CCapturePin::CreateCapturePin(CTAPIVCap *pCaptureFilter, CCapturePin **ppCapturePin)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CCapturePin::CreateCapturePin")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pCaptureFilter);
        ASSERT(ppCapturePin);
        if (!pCaptureFilter || !ppCapturePin)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        if (!(*ppCapturePin = (CCapturePin *) new CCapturePin(NAME("Video Capture Stream"), pCaptureFilter, &Hr, PNAME_CAPTURE)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                Hr = E_OUTOFMEMORY;
                goto MyExit;
        }

        // If initialization failed, delete the stream array and return the error
        if (FAILED(Hr) && *ppCapturePin)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Initialization failed", _fx_));
                Hr = E_FAIL;
                delete *ppCapturePin, *ppCapturePin = NULL;
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPINMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | CCapturePin | This method is the
 *  constructorfor the <c CCapturePin> object
 *
 *  @rdesc Nada.
 ***************************************************************************/
#pragma warning(disable:4355)
CCapturePin::CCapturePin(IN TCHAR *pObjectName, IN CTAPIVCap *pCaptureFilter, IN HRESULT *pHr, IN LPCWSTR pName) : CTAPIBasePin(pObjectName, pCaptureFilter, pHr, pName)
{
        FX_ENTRY("CCapturePin::CCapturePin")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pHr);
        ASSERT(pCaptureFilter);
        if (!pCaptureFilter || !pHr)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                if (pHr)
                        *pHr = E_POINTER;
        }

        if (pHr && FAILED(*pHr))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Base class error or invalid input parameter", _fx_));
                goto MyExit;
        }

#ifdef USE_NETWORK_STATISTICS
        // Networks stats
        m_dwPacketLossRate = m_dwPacketLossRateMin = m_dwPacketLossRateMax = m_dwPacketLossRateSteppingDelta = m_dwPacketLossRateDefault = 0UL;
        m_ChannelErrors.dwRandomBitErrorRate = 0; m_ChannelErrors.dwBurstErrorDuration = 0; m_ChannelErrors.dwBurstErrorMaxFrequency = 0;
        m_ChannelErrorsMin.dwRandomBitErrorRate = 0; m_ChannelErrorsMin.dwBurstErrorDuration = 0; m_ChannelErrorsMin.dwBurstErrorMaxFrequency = 0;
        m_ChannelErrorsMax.dwRandomBitErrorRate = 0; m_ChannelErrorsMax.dwBurstErrorDuration = 0; m_ChannelErrorsMax.dwBurstErrorMaxFrequency = 0;
        m_ChannelErrorsSteppingDelta.dwRandomBitErrorRate = 0; m_ChannelErrorsSteppingDelta.dwBurstErrorDuration = 0; m_ChannelErrorsSteppingDelta.dwBurstErrorMaxFrequency = 0;
        m_ChannelErrorsDefault.dwRandomBitErrorRate = 0; m_ChannelErrorsDefault.dwBurstErrorDuration = 0; m_ChannelErrorsDefault.dwBurstErrorMaxFrequency = 0;
#endif

        // Initialize to default format: H.263 176x144 at 30 fps
        m_mt = *CaptureFormats[0];
        m_aFormats = (AM_MEDIA_TYPE**)CaptureFormats;
        m_aCapabilities = CaptureCaps;
        m_dwNumFormats = NUM_CAPTURE_FORMATS;
        m_dwRTPPayloadType = RTPPayloadTypes[0];

        // Update bitrate controls
        // MaxBitsPerSecond value too big; use the 10th part of it for the m_lTargetBitrate
        m_lTargetBitrate = CaptureCaps[0]->MaxBitsPerSecond / 10; // theoretically should be   max(CaptureCaps[0]->MinBitsPerSecond, CaptureCaps[0]->MaxBitsPerSecond / 10);
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: m_lTargetBitrate set to %ld", _fx_, m_lTargetBitrate));
        m_lCurrentBitrate = 0;
        m_lBitrateRangeMin = CaptureCaps[0]->MinBitsPerSecond;
        m_lBitrateRangeMax = CaptureCaps[0]->MaxBitsPerSecond;
        m_lBitrateRangeSteppingDelta = 100;
        m_lBitrateRangeDefault = CaptureCaps[0]->MaxBitsPerSecond / 10;

        // Update frame rate controls
        // @todo With WDM, these numbers need to come from the device
        m_lMaxAvgTimePerFrame = (LONG)CaptureCaps[0]->MinFrameInterval;
        // We need to do the following because our bitrate control assumes
        // that m_lCurrentAvgTimePerFrame is valid to compute the size of
        // each target output frame. If we start at 0, it's doing a poor
        // job until this field is updated (1s later). So, instead, let's
        // assume that the current average time per frame IS close to the
        // target average time per frame.
        m_lCurrentAvgTimePerFrame = m_lMaxAvgTimePerFrame;
        m_lAvgTimePerFrameRangeMin = (LONG)CaptureCaps[0]->MinFrameInterval;
        m_lAvgTimePerFrameRangeMax = (LONG)CaptureCaps[0]->MaxFrameInterval;
        m_lAvgTimePerFrameRangeSteppingDelta = (LONG)(CaptureCaps[0]->MaxFrameInterval - CaptureCaps[0]->MinFrameInterval) / 100;
        m_lAvgTimePerFrameRangeDefault = (LONG)CaptureCaps[0]->MinFrameInterval;

        // H.245 video capabilities
        m_pH245MediaCapabilityMap = NULL;
        m_pVideoResourceBounds = NULL;
        m_pFormatResourceBounds = NULL;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPINMETHOD
 *
 *  @mfunc void | CCapturePin | ~CCapturePin | This method is the destructor
 *    for the <c CCapturePin> object.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCapturePin::~CCapturePin()
{
        FX_ENTRY("CCapturePin::~CCapturePin")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPINMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | NonDelegatingQueryInterface | This
 *    method is the nondelegating interface query function. It returns a pointer
 *    to the specified interface if supported. The only interfaces explicitly
 *    supported being <i IAMStreamConfig>,
 *    <i IAMStreamControl>, <i ICPUControl>, <i IFrameRateControl>,
 *    <i IBitrateControl>, <i INetworkStats>, <i IH245EncoderCommand>
 *    and <i IProgressiveRefinement>.
 *
 *  @parm REFIID | riid | Specifies the identifier of the interface to return.
 *
 *  @parm PVOID* | ppv | Specifies the place in which to put the interface
 *    pointer.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CCapturePin::NonDelegatingQueryInterface(IN REFIID riid, OUT void **ppv)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CCapturePin::NonDelegatingQueryInterface")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(ppv);
        if (!ppv)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        if (riid == __uuidof(IAMStreamControl))
        {
                if (FAILED(Hr = GetInterface(static_cast<IAMStreamControl*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: NDQI for IAMStreamControl failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: IAMStreamControl*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
        else if (riid == __uuidof(IStreamConfig))
        {
                if (FAILED(Hr = GetInterface(static_cast<IStreamConfig*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: NDQI for IStreamConfig failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: IStreamConfig*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
#ifdef USE_PROPERTY_PAGES
        else if (riid == IID_ISpecifyPropertyPages)
        {
                if (FAILED(Hr = GetInterface(static_cast<ISpecifyPropertyPages*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: NDQI for ISpecifyPropertyPages failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: ISpecifyPropertyPages*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
#endif
#ifdef USE_NETWORK_STATISTICS
        else if (riid == __uuidof(INetworkStats))
        {
                if (FAILED(Hr = GetInterface(static_cast<INetworkStats*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: NDQI for INetworkStats failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: INetworkStats*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
#endif
        else if (riid == __uuidof(IH245Capability))
        {
                if (FAILED(Hr = GetInterface(static_cast<IH245Capability*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: NDQI for IH245Capability failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: IH245Capability*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
        else if (riid == __uuidof(IH245EncoderCommand))
        {
                if (FAILED(Hr = GetInterface(static_cast<IH245EncoderCommand*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: NDQI for IH245EncoderCommand failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: IH245EncoderCommand*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
#ifdef USE_PROGRESSIVE_REFINEMENT
        else if (riid == __uuidof(IProgressiveRefinement))
        {
                if (FAILED(Hr = GetInterface(static_cast<IProgressiveRefinement*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: NDQI for IProgressiveRefinement failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: IProgressiveRefinement*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
#endif

        if (FAILED(Hr = CTAPIBasePin::NonDelegatingQueryInterface(riid, ppv)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, WARN, "%s:   WARNING: NDQI for {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX} failed Hr=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], Hr));
        }
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX}*=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], *ppv));
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

#ifdef USE_PROPERTY_PAGES
/****************************************************************************
 *  @doc INTERNAL CCAPTUREPINMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | GetPages | This method Fills a counted
 *    array of GUID values where each GUID specifies the CLSID of each
 *    property page that can be displayed in the property sheet for this
 *    object.
 *
 *  @parm CAUUID* | pPages | Specifies a pointer to a caller-allocated CAUUID
 *    structure that must be initialized and filled before returning. The
 *    pElems field in the CAUUID structure is allocated by the callee with
 *    CoTaskMemAlloc and freed by the caller with CoTaskMemFree.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_OUTOFMEMORY | Allocation failed
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CCapturePin::GetPages(OUT CAUUID *pPages)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CCapturePin::GetPages")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pPages);
        if (!pPages)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

#ifdef USE_CPU_CONTROL
#ifdef USE_PROGRESSIVE_REFINEMENT
#ifdef USE_NETWORK_STATISTICS
        pPages->cElems = 4;
#else
        pPages->cElems = 3;
#endif
#else
#ifdef USE_NETWORK_STATISTICS
        pPages->cElems = 3;
#else
        pPages->cElems = 2;
#endif
#endif
#else
#ifdef USE_PROGRESSIVE_REFINEMENT
#ifdef USE_NETWORK_STATISTICS
        pPages->cElems = 3;
#else
        pPages->cElems = 2;
#endif
#else
#ifdef USE_NETWORK_STATISTICS
        pPages->cElems = 2;
#else
        pPages->cElems = 1;
#endif
#endif
#endif

        // Alloc memory for the page stuff
        if (!(pPages->pElems = (GUID *) QzTaskMemAlloc(sizeof(GUID) * pPages->cElems)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                Hr = E_OUTOFMEMORY;
        }
        else
        {
                pPages->pElems[0] = _uuidof(CapturePropertyPage);
#ifdef USE_CPU_CONTROL
                pPages->pElems[1] = _uuidof(CPUCPropertyPage);
#ifdef USE_NETWORK_STATISTICS
                pPages->pElems[2] = _uuidof(NetworkStatsPropertyPage);
#ifdef USE_PROGRESSIVE_REFINEMENT
                pPages->pElems[3] = _uuidof(ProgRefPropertyPage);
#endif
#else
#ifdef USE_PROGRESSIVE_REFINEMENT
                pPages->pElems[2] = _uuidof(ProgRefPropertyPage);
#endif
#endif
#else
#ifdef USE_NETWORK_STATISTICS
                pPages->pElems[1] = _uuidof(NetworkStatsPropertyPage);
#ifdef USE_PROGRESSIVE_REFINEMENT
                pPages->pElems[2] = _uuidof(ProgRefPropertyPage);
#endif
#else
#ifdef USE_PROGRESSIVE_REFINEMENT
                pPages->pElems[1] = _uuidof(ProgRefPropertyPage);
#endif
#endif
#endif
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}
#endif

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPINMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | SendFrames | This method is used to
 *    send a a media sample downstream.
 *
 *  @parm CFrameSample | pCapSample | Specifies a pointer to the capture
 *    video sample to send downstream.
 *
 *  @parm CFrameSample | pPrevSample | Specifies a pointer to the preview
 *    video sample to send downstream.
 *
 *  @parm LPTHKVIDEOHDR | ptvh | Specifies a pointer to the video header
 *    of the video capture buffer associated to this sample.
 *
 *  @parm PDWORD | pdwBytesUsed | Specifies a pointer to a DWORD to receive
 *    the size of the frame that has been delivered downstream.
 *
 *  @parm BOOL | bDiscon | Set to TRUE if this is the first frame we ever
 *    sent downstream.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag S_OK | No error
 *  @flag S_FALSE | If the pin is off (IAMStreamControl)
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCapturePin::SendFrames(IN CFrameSample *pCapSample, IN CFrameSample *pPrevSample, IN PBYTE pbyInBuff, IN DWORD dwInBytes, OUT PDWORD pdwBytesUsed, OUT PDWORD pdwBytesExtent, IN BOOL bDiscon)
{
        HRESULT Hr = NOERROR;
        DWORD   dwBytesUsed;
        int             iStreamState;
    LPBYTE      lpbyCap;
    LPBYTE      lpbyPrev;
        DWORD   dwBytesPrev;

        FX_ENTRY("CCapturePin::SendFrames")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pCapSample);
        ASSERT(pPrevSample);
        ASSERT(pbyInBuff);
        ASSERT(pdwBytesUsed);
        ASSERT(m_pConverter);
        if (!pCapSample || !pPrevSample || !pbyInBuff || !pdwBytesUsed || !m_pConverter)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument!", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Get a pointer to the preview buffer
        if (FAILED(Hr = pPrevSample->GetPointer(&lpbyPrev)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Couldn't get preview buffer", _fx_));
                goto MyExit;
        }

        // Process the video capture buffer before sending it downstream, if necessary
        dwBytesUsed = 0UL;
        dwBytesPrev = 0UL;

        if (SUCCEEDED(Hr = pCapSample->GetPointer(&lpbyCap)))
        {
                Hr = m_pConverter->ConvertFrame(pbyInBuff, dwInBytes, lpbyCap, &dwBytesUsed, pdwBytesExtent, lpbyPrev, &dwBytesPrev, m_fFastUpdatePicture);
        m_fFastUpdatePicture = FALSE;

        if (FAILED(Hr))
        {
                        goto MyExit;
                }
        }

        if (dwBytesUsed && dwBytesPrev)
        {
                // It isn't necessarily a keyframe, but who cares?
                pCapSample->SetSyncPoint(TRUE);
                pCapSample->SetActualDataLength(dwBytesUsed);
                pCapSample->SetDiscontinuity(bDiscon);
                pCapSample->SetPreroll(FALSE);

                pPrevSample->SetSyncPoint(TRUE);
                pPrevSample->SetActualDataLength(dwBytesUsed);
                pPrevSample->SetDiscontinuity(bDiscon);
                pPrevSample->SetPreroll(FALSE);

                // Let the downstream pin know about the format change: [Cristi: see also inside CTAPIBasePin::SendFrame (7 Dec 2000 16:37:06)]
                if (m_fFormatChanged)
                {
                        pCapSample->SetMediaType(&m_mt);
                        //pPrevSample->SetMediaType(&m_mt); //no need to do for this one...
                        m_fFormatChanged = FALSE;
                }
                // Use the clock's graph to mark the times for the samples.  The video
                // capture card's clock is going to drift from the graph clock, so you'll
                // think we're dropping frames or sending too many frames if you look at
                // the time stamps, so we have an agreement to mark the MediaTime with the
                // frame number so you can tell if any frames are dropped.
                // Use the time we got in Run() to determine the stream time.  Also add
                // a latency (HACK!) to prevent preview renderers from thinking we're
                // late.
                // If we are RUN, PAUSED, RUN, we won't send stuff smoothly where we
                // left off because of the async nature of pause.
                CRefTime rtSample;
                CRefTime rtEnd;
                if (m_pCaptureFilter->m_pClock)
                {
                        rtSample = m_pCaptureFilter->m_cs.rtThisFrameTime - m_pCaptureFilter->m_tStart;
                        rtEnd = rtSample + m_lMaxAvgTimePerFrame;
                        pCapSample->SetTime((REFERENCE_TIME *)&rtSample, (REFERENCE_TIME *)&rtEnd);
                        pPrevSample->SetTime(NULL, NULL);
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Stream time is %d", _fx_, (LONG)rtSample.Millisecs()));
                }
                else
                {
                        // No clock, use our driver time stamps
                        rtSample = m_pCaptureFilter->m_cs.rtThisFrameTime - m_pCaptureFilter->m_tStart;
                        rtEnd    = rtSample + m_pCaptureFilter->m_user.pvi->AvgTimePerFrame;
                        pCapSample->SetTime((REFERENCE_TIME *)&rtSample, (REFERENCE_TIME *)&rtEnd);
                        pPrevSample->SetTime(NULL, NULL);
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   No graph clock! Stream time is %d (based on driver time)", _fx_, (LONG)rtSample.Millisecs()));
                }

                // Don't deliver capture sample if the capture stream is off for now
                iStreamState = CheckStreamState(pCapSample);
                if (iStreamState == STREAM_FLOWING)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Sending frame: Stamps(%u): Time(%d,%d)", _fx_, m_pCaptureFilter->m_pBufferQueue[m_pCaptureFilter->m_uiQueueTail], (LONG)rtSample.Millisecs(), (LONG)rtEnd.Millisecs()));
                        if ((Hr = Deliver (pCapSample)) == S_FALSE)
                                Hr = E_FAIL;    // stop delivering anymore, this is serious
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Discarding frame", _fx_));
                        Hr = S_FALSE;           // discarding
                }

                // Don't deliver preview sample if the preview stream is off for now
                iStreamState = m_pCaptureFilter->m_pPreviewPin->CheckStreamState(pPrevSample);
                if (iStreamState == STREAM_FLOWING)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Sending frame: Stamps(%u): Time(%d,%d)", _fx_, m_pCaptureFilter->m_pBufferQueue[m_pCaptureFilter->m_uiQueueTail], (LONG)rtSample.Millisecs(), (LONG)rtEnd.Millisecs()));
                        if ((Hr = m_pCaptureFilter->m_pPreviewPin->Deliver (pPrevSample)) == S_FALSE)
                                Hr = E_FAIL;    // stop delivering anymore, this is serious
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Discarding frame", _fx_));
                        Hr = S_FALSE;           // discarding
                }
        }
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: BUFFER (%08lX %ld %lu) returned EMPTY!", _fx_, pCapSample));
        }

        *pdwBytesUsed = dwBytesUsed;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\cpuc.cpp ===
/****************************************************************************
 *  @doc INTERNAL CPUC
 *
 *  @module CPUC.cpp | Source file for the <c CTAPIBasePin> class methods
 *    used to implement CPU control.
 ***************************************************************************/

#include "Precomp.h"

#ifdef USE_CPU_CONTROL

/****************************************************************************
 *  @doc INTERNAL CCPUCMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | SetMaxProcessingTime | This
 *    method is used to specify to the compressed video output pin the
 *    maximum encoding time per frame, in 100-nanosecond units.
 *
 *  @parm REFERENCE_TIME | MaxProcessingTime | Used to specify the maximum
 *    encoding time per frame, in 100-nanosecond units.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::SetMaxProcessingTime(IN REFERENCE_TIME MaxProcessingTime)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIBasePin::SetMaxProcessingTime")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters - we can't take more than the picture interval
	// if we still want to be working in real time
	ASSERT(MaxProcessingTime < m_MaxAvgTimePerFrame);
	if (!(MaxProcessingTime < m_MaxAvgTimePerFrame))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid argument - would break real-time!", _fx_));
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	// Remember value passed in 
	m_MaxProcessingTime = MaxProcessingTime;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCPUCMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | GetMaxProcessingTime | This
 *    method is used to retrieve the maximum encoding time per frame the
 *    compressed video output pin is currently setup for, in 100-nanosecond
 *    units.
 *
 *  @parm REFERENCE_TIME* | pMaxProcessingTime | Used to receive the maximum
 *    encoding time per frame the compressed video output pin is currently
 *    setup for, in 100-nanosecond units.
 *
 *  @parm DWORD | dwMaxCPULoad | Specifies an hypothetical CPU load, in
 *    percentage units. If this parameter is set to -1UL, this method shall
 *    use the value of the CPU load  the compressed video output pin is
 *    currently setup for.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::GetMaxProcessingTime(OUT REFERENCE_TIME *pMaxProcessingTime, IN DWORD dwMaxCPULoad)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIBasePin::GetMaxProcessingTime")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pMaxProcessingTime);
	if (!pMaxProcessingTime)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT(dwMaxCPULoad == (DWORD)-1L || dwMaxCPULoad <= 100);
	if (dwMaxCPULoad != (DWORD)-1L && dwMaxCPULoad > 100)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid argument - 0<dwMaxCPULoad<100 or -1 only", _fx_));
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	// Ignore the CPU load information 
	if (m_MaxProcessingTime != -1)
		*pMaxProcessingTime = m_MaxProcessingTime;
	else
		*pMaxProcessingTime = m_MaxAvgTimePerFrame;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCPUCMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | GetCurrentProcessingTime | This
 *    method is used to retrieve the current encoding time per frame, in
 *    100-nanosecond units.
 *
 *  @parm REFERENCE_TIME* | pCurrentProcessingTime | Used to receive the maximum
 *    encoding time per frame the compressed video output pin is currently
 *    setup for, in 100-nanosecond units.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::GetCurrentProcessingTime(OUT REFERENCE_TIME *pCurrentProcessingTime)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIBasePin::GetMaxProcessingTime")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pCurrentProcessingTime);
	if (!pCurrentProcessingTime)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Return the current processing time 
	*pCurrentProcessingTime = m_CurrentProcessingTime;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCPUCMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | GetMaxProcessingTimeRange | This
 *    method is used to retrieve support, minimum, maximum, and default
 *    values for the maximum encoding time per frame the compressed video
 *    output pin may be setup for, in 100-nanosecond units.
 *
 *  @parm REFERENCE_TIME* | pMin | Used to retrieve the minimum value of
 *    encoding time per frame the compressed video output pin may be setup
 *    for, in 100-nanosecond units.
 *
 *  @parm REFERENCE_TIME* | pMax | Used to retrieve the maximum value of
 *    encoding time per frame the compressed video output pin may be setup
 *    for, in 100-nanosecond units.
 *
 *  @parm REFERENCE_TIME* | pSteppingDelta | Used to retrieve the stepping
 *    delta of encoding time per frame the compressed video output pin may
 *    be setup for, in 100-nanosecond units.
 *
 *  @parm REFERENCE_TIME* | pDefault | Used to retrieve the default value
 *    of encoding time per frame the compressed video output pin is setup
 *    for, in 100-nanosecond units.
 *
 *  @parm DWORD | dwMaxCPULoad | Specifies an hypothetical CPU load, in
 *    percentage units. If this parameter is set to -1UL, this method shall
 *    use the value of the CPU load  the compressed video output pin is
 *    currently setup for.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::GetMaxProcessingTimeRange(OUT REFERENCE_TIME *pMin, OUT REFERENCE_TIME *pMax, OUT REFERENCE_TIME *pSteppingDelta, OUT REFERENCE_TIME *pDefault, IN DWORD dwMaxCPULoad)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIBasePin::GetMaxProcessingTimeRange")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pMin && pMax && pSteppingDelta && pDefault);
	if (!pMin || !pMax || !pSteppingDelta || !pDefault)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT(dwMaxCPULoad == (DWORD)-1L || dwMaxCPULoad <= 100);
	if (dwMaxCPULoad != (DWORD)-1L && dwMaxCPULoad > 100)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid argument - 0<dwMaxCPULoad<100 or -1 only", _fx_));
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	// Return range information - ignore CPU load 
	*pMin = 0;
	*pMax = m_MaxAvgTimePerFrame;
	*pSteppingDelta = 1;
	*pDefault = 0;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCPUCMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | SetMaxCPULoad | This method is used to
 *    specify to the compressed video output pin the maximum encoding
 *    algorithm CPU load.
 *
 *  @parm DWORD | dwMaxCPULoad | Used to specify the maximum encoding
 *    algorithm CPU load, in percentage units.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::SetMaxCPULoad(IN DWORD dwMaxCPULoad)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIBasePin::SetMaxCPULoad")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(dwMaxCPULoad >= 0 && dwMaxCPULoad <= 100);
	if (!(dwMaxCPULoad >= 0 && dwMaxCPULoad <= 100))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid argument - 0<dwMaxCPULoad<100 or -1 only", _fx_));
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	// Remember value passed in
	m_dwMaxCPULoad = dwMaxCPULoad;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCPUCMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | GetMaxCPULoad | This
 *    method is used to retrieve the maximum encoding algorithm CPU load the
 *    compressed video output pin is currently setup for.
 *
 *  @parm DWORD* | pdwMaxCPULoad | Used to retrieve the maximum encoding
 *    algorithm CPU load the compressed video output pin is currently setup
 *    for, in percentage units.
 *
 *  @parm REFERENCE_TIME | MaxProcessingTime | Specifies an hypothetical
 *    maximum encoding time per frame, in 100-nanosecond units. If this
 *    parameter is set to -1, this method shall use the value of the maximum
 *    encoding time per frame the compressed video output pin is currently
 *    setup for.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::GetMaxCPULoad(OUT DWORD *pdwMaxCPULoad, IN REFERENCE_TIME MaxProcessingTime)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIBasePin::GetMaxCPULoad")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pdwMaxCPULoad);
	if (!pdwMaxCPULoad)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Return current value - ignore MaxProcessingTime parameter 
	*pdwMaxCPULoad = m_dwMaxCPULoad;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCPUCMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | GetCurrentCPULoad | This
 *    method is used to retrieve the current encoding algorithm CPU load.
 *
 *  @parm DWORD* | pdwCurrentCPULoad | Used to retrieve the current encoding
 *    algorithm CPU load, in percentage units.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::GetCurrentCPULoad(OUT DWORD *pdwCurrentCPULoad)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIBasePin::GetCurrentCPULoad")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pdwCurrentCPULoad);
	if (!pdwCurrentCPULoad)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Return current value
	*pdwCurrentCPULoad = m_dwCurrentCPULoad;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCPUCMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | GetMaxCPULoadRange | This
 *    method is used to retrieve support, minimum, maximum, and default
 *    values for the maximum CPU load the compressed video output pin may be
 *    setup for, in percentage.
 *
 *  @parm DWORD* | pdwMin | Used to retrieve the minimum value of encoding
 *    algorithm CPU load the compressed video output pin may be setup for,
 *    in percentage units.
 *
 *  @parm DWORD* | pdwMax | Used to retrieve the maximum value of encoding
 *    algorithm CPU load the compressed video output pin may be setup for, in
 *    percentage units.
 *
 *  @parm DWORD* | pdwSteppingDelta | Used to retrieve the stepping delta of
 *    encoding algorithm CPU load the compressed video output pin may be
 *    setup for, in percentage units.
 *
 *  @parm DWORD* | pdwDefault | Used to retrieve the default value of encoding
 *    algorithm CPU load the compressed video output pin is setup for, in
 *    percentage units.
 *
 *  @parm REFERENCE_TIME | MaxProcessingTime | Specifies an hypothetical
 *    maximum encoding time per frame, in 100-nanosecond units. If this
 *    parameter is set to -1, this method shall use the value of the maximum
 *    encoding time per frame the compressed video output pin is currently
 *    setup for.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::GetMaxCPULoadRange(OUT DWORD *pdwMin, OUT DWORD *pdwMax, OUT DWORD *pdwSteppingDelta, OUT DWORD *pdwDefault, IN REFERENCE_TIME MaxProcessingTime)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIBasePin::GetMaxCPULoadRange")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pdwMin && pdwMax && pdwSteppingDelta && pdwDefault);
	if (!pdwMin || !pdwMax || !pdwSteppingDelta || !pdwDefault)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Return range values - ignore MaxProcessingTime parameter 
	*pdwMin = 0;
	*pdwMax = 100;
	*pdwSteppingDelta = 1;
	*pdwDefault = 0;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\capturep.h ===
/****************************************************************************
 *  @doc INTERNAL CAPTUREP
 *
 *  @module CaptureP.h | Header file for the <c CCaptureProperty>
 *    class used to implement a property page to test the new TAPI internal
 *    interfaces <i IBitrateControl>, <i IFrameRateControl>, and dynamic
 *    format changes.
 *
 *  @comm This code tests the TAPI Capture Pin <i IBitrateControl>,
 *    <i IFrameRateControl>, and dynamic format change implementation. This
 *    code is only compiled if USE_PROPERTY_PAGES is defined.
 ***************************************************************************/

#ifndef _CAPTUREP_H_
#define _CAPTUREP_H_

#ifdef USE_PROPERTY_PAGES

#define NUM_CAPTURE_CONTROLS			6
#define IDC_Capture_Bitrate				0
#define IDC_Capture_CurrentBitrate		1
#define IDC_Capture_FrameRate			2
#define IDC_Capture_CurrentFrameRate	3
#define IDC_Capture_FlipVertical		4
#define IDC_Capture_FlipHorizontal		5

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPCLASS
 *
 *  @class CCaptureProperty | This class implements handling of a
 *    single capture property in a property page.
 *
 *  @mdata int | CCaptureProperty | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata IBitrateControl* | CCaptureProperty | m_pIBitrateControl | Pointer
 *    to the <i IBitrateControl> interface.
 *
 *  @mdata IFrameRateControl* | CCaptureProperty | m_pIFrameRateControl | Pointer
 *    to the <i IFrameRateControl> interface.
 *
 *  @comm This code tests the TAPI Capture Pin <i IBitrateControl>,
 *    <i IFrameRateControl>, and dynamic format change implementation. This
 *    code is only compiled if USE_PROPERTY_PAGES is defined.
***************************************************************************/
class CCaptureProperty : public CPropertyEditor 
{
	public:
	CCaptureProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, IBitrateControl *pIBitrateControl, IFrameRateControl *pIFrameRateControl, IVideoControl *pIVideoControl);
	~CCaptureProperty ();

	// CPropertyEditor base class pure virtual overrides
	HRESULT GetValue();
	HRESULT SetValue();
	HRESULT GetRange();
	BOOL CanAutoControl(void);
	BOOL GetAuto(void);
	BOOL SetAuto(BOOL fAuto);

	private:
	IBitrateControl *m_pIBitrateControl;
	IFrameRateControl *m_pIFrameRateControl;
	IVideoControl *m_pIVideoControl;
};

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPCLASS
 *
 *  @class CCaptureProperties | This class implements a property page
 *    to test the new TAPI internal interfaces <i IBitrateControl> and
 *    <i IFrameRateControl>.
 *
 *  @mdata int | CCaptureProperties | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata IBitrateControl* | CCaptureProperties | m_pInterface | Pointer
 *    to the <i IBitrateControl> interface.
 *
 *  @mdata IFrameRateControl* | CCaptureProperties | m_pInterface | Pointer
 *    to the <i IFrameRateControl> interface.
 *
 *  @mdata CCaptureProperty* | CCaptureProperties | m_Controls[NUM_CAPTURE_CONTROLS] | Array
 *    of capture properties.
 *
 *  @comm This code tests the TAPI Capture Pin <i IBitrateControl>,
 *    <i IFrameRateControl>, and dynamic format change implementation. This
 *    code is only compiled if USE_PROPERTY_PAGES is defined.
***************************************************************************/
class CCaptureProperties : public CBasePropertyPage
{
	public:
	CCaptureProperties(LPUNKNOWN pUnk, HRESULT *pHr);
	~CCaptureProperties();


	// Implement CBasePropertyPage virtual methods
	HRESULT OnConnect(IUnknown *pUnk);
	HRESULT OnDisconnect();
	HRESULT OnActivate();
	HRESULT OnDeactivate();
	HRESULT OnApplyChanges();
	BOOL    OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

	private:
	void SetDirty();

	// Format manipulation methods
	HRESULT InitialRangeScan();
	HRESULT OnFormatChanged();
	HRESULT GetCurrentMediaType(void);

	HWND						m_hWnd;
	int							m_NumProperties;
	IBitrateControl				*m_pIBitrateControl;
	IFrameRateControl			*m_pIFrameRateControl;
	IAMStreamConfig				*m_pIAMStreamConfig;
	IVideoControl				*m_pIVideoControl;
	int							m_RangeCount;
	VIDEO_STREAM_CONFIG_CAPS	m_RangeCaps;
	GUID						*m_SubTypeList;
	SIZE						*m_FrameSizeList;
	GUID						m_SubTypeCurrent;
	SIZE						m_FrameSizeCurrent;
	AM_MEDIA_TYPE				*m_CurrentMediaType;
	HWND						m_hWndFormat;
	BOOL						m_fActivated;
	int							m_CurrentFormat;
	int							m_OriginalFormat;

	CCaptureProperty *m_Controls[NUM_CAPTURE_CONTROLS];
};

#endif

#endif // _CAPTUREP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\convert.h ===
/****************************************************************************
 *  @doc INTERNAL CONVERT
 *
 *  @module Convert.cpp | Source file for the <c CConverter> class methods
 *    used to implement the video capture and preview pin format conversion
 *    routines.
 *
 *  @todo Merge the two ScaleDIB methods + fix method comments + by the end
 *    of the H.362 work, you should never have to open an ICM encoder for
 *    encoding, only decode or scaling -> clean code at that point
 ***************************************************************************/

#ifndef _CONVERT_H_
#define _CONVERT_H_

/****************************************************************************
 *  @doc INTERNAL CCONVERTCLASS
 *
 *  @class CConverter | This base class implements a video encoder or decoder.
 ***************************************************************************/
class CConverter : public CUnknown
{
        public:

        DECLARE_IUNKNOWN
        STDMETHODIMP NonDelegatingQueryInterface(IN REFIID riid, OUT PVOID *ppv);
        CConverter(IN TCHAR *pObjectName, IN CTAPIBasePin *pBasePin, IN PBITMAPINFOHEADER pbiIn, IN PBITMAPINFOHEADER pbiOut, IN HRESULT *pHr);
        virtual ~CConverter();

        // Scaling routines
        void InitBlack8(IN PBITMAPINFOHEADER pbiSrc);
#ifdef USE_SOFTWARE_CAMERA_CONTROL
        HRESULT InsertSoftCamCtrl();
        HRESULT RemoveSoftCamCtrl();
        BOOL IsSoftCamCtrlInserted();
        BOOL IsSoftCamCtrlNeeded();
#endif

        // Format conversion routines
        virtual HRESULT ConvertFrame(IN PBYTE pbyInput, IN DWORD dwInputSize, IN PBYTE pbyOutput, OUT PDWORD pdwOutputSize, OUT PDWORD pdwBytesExtent, IN PBYTE pbyPreview, OUT PDWORD pdwPreviewSize, IN BOOL fSendKeyFrame) PURE;
        virtual HRESULT OpenConverter() PURE;
        virtual HRESULT CloseConverter();

        // Format conversion
        DWORD m_dwConversionType;
        PBYTE m_pbyOut;

        protected:

        CTAPIBasePin *m_pBasePin;

        // Quality control
        // @todo Do we really need this?
        DWORD m_dwImageQuality;

        // Format conversion
        DWORD m_dwLastTimestamp;
        DWORD m_dwLastIFrameTime;
        DWORD m_dwFrame;
        BOOL m_fPeriodicIFrames;
        PBITMAPINFOHEADER m_pbiOut;
        PBITMAPINFOHEADER m_pbiIn;
        PBITMAPINFOHEADER m_pbiInt;
        BOOL m_fConvert;

#ifdef USE_SOFTWARE_CAMERA_CONTROL
        // Soft Cam Control
        BOOL m_fSoftCamCtrl;
#endif
};

/****************************************************************************
 *  @doc INTERNAL CCONVERTCLASS
 *
 *  @class CConverter | This base class implements a converter using ICM.
 ***************************************************************************/
class CICMConverter : public CConverter
{
        public:

        DECLARE_IUNKNOWN
        CICMConverter(IN TCHAR *pObjectName, IN CTAPIBasePin *pBasePin, IN PBITMAPINFOHEADER pbiIn, IN PBITMAPINFOHEADER pbiOut, IN HRESULT *pHr);
        ~CICMConverter();
        static HRESULT CALLBACK CreateICMConverter(IN CTAPIBasePin *pBasePin, IN PBITMAPINFOHEADER pbiIn, IN PBITMAPINFOHEADER pbiOut, OUT CConverter **ppConverter);

        // Format conversion routines
        HRESULT ConvertFrame(IN PBYTE pbyInput, IN DWORD dwInputSize, IN PBYTE pbyOutput, OUT PDWORD pdwOutputSize, OUT PDWORD pdwBytesExtent, IN PBYTE pbyPreview, IN OUT PDWORD pdwPreviewSize, IN BOOL fSendKeyFrame);
        HRESULT OpenConverter();
        HRESULT CloseConverter();

        private:

        HIC m_hIC;
};

HRESULT ScaleDIB(PBITMAPINFOHEADER pbiSrc, PBYTE pbySrc, PBITMAPINFOHEADER pbiDst, PBYTE pbyDst, PRECT prcRect, BOOL fFlipHorizontal, BOOL fFlipVertical, BOOL fNoImageStretch, DWORD dwBlackEntry);
HRESULT ScaleDIB24(IN PBITMAPINFOHEADER pbiSrc, IN PBYTE pbySrc, IN PBITMAPINFOHEADER pbiDst, IN PBYTE pbyDst, IN PRECT prcRect, IN BOOL fFlipHorizontal, IN BOOL fFlipVertical, BOOL fNoImageStretch);
HRESULT ScaleDIB16(IN PBITMAPINFOHEADER pbiSrc, IN PBYTE pbySrc, IN PBITMAPINFOHEADER pbiDst, IN PBYTE pbyDst, IN PRECT prcRect, IN BOOL fFlipHorizontal, IN BOOL fFlipVertical, BOOL fNoImageStretch);
void InitDst8(IN OUT PBITMAPINFOHEADER pbiDst);
void ScalePackedPlane(IN PBYTE pbySrc, IN PBYTE pbyDst, IN int dxDst, IN int dyDst, IN long WidthBytesSrc, IN long WidthBytesDst, IN LPRECT prcRect, IN BOOL fFlipHorizontal, IN BOOL fFlipVertical, IN DWORD dwDelta);
void ScalePlane(IN PBYTE pbySrc, IN PBYTE pbyDst, IN int WidthBytesSrc, IN int dxDst, IN int dyDst, IN long WidthBytesDst, IN LPRECT prcRect, IN BOOL fFlipHorizontal, IN BOOL fFlipVertical);
HRESULT ScaleDIB8(IN PBITMAPINFOHEADER pbiSrc, IN PBYTE pbySrc, IN PBITMAPINFOHEADER pbiDst, IN PBYTE pbyDst, IN PRECT prcRect, IN BOOL fFlipHorizontal, IN BOOL fFlipVertical, BOOL fNoImageStretch, DWORD dwBlackEntry);
HRESULT ScaleDIB4(IN PBITMAPINFOHEADER pbiSrc, IN PBYTE pbySrc, IN PBITMAPINFOHEADER pbiDst, IN PBYTE pbyDst, IN PRECT prcRect, IN BOOL fFlipHorizontal, IN BOOL fFlipVertical, BOOL fNoImageStretch, DWORD dwBlackEntry);
HRESULT ScaleDIBYUVPlanar(PBITMAPINFOHEADER pbiSrc, PBYTE pbySrc, PBITMAPINFOHEADER pbiDst, PBYTE pbyDst, DWORD dwUVDownSampling, IN PRECT prcRect, IN BOOL fFlipHorizontal, IN BOOL fFlipVertical, BOOL fNoImageStretch);
HRESULT ScaleDIBYUVPacked(PBITMAPINFOHEADER pbiSrc, PBYTE pbySrc, PBITMAPINFOHEADER pbiDst, PBYTE pbyDst, DWORD dwZeroingDWORD, IN PRECT prcRect, IN BOOL fFlipHorizontal, IN BOOL fFlipVertical, BOOL fNoImageStretch, int []);
HRESULT ComputeRectangle(PBITMAPINFOHEADER pbiSrc, PBITMAPINFOHEADER pbiDst, LONG lZoom, LONG lPan, LONG lTilt, PRECT prcRect, BOOL fFlipHorizontal, BOOL fFlipVertical);

#endif // _CONVERT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\capturep.cpp ===
/****************************************************************************
 *  @doc INTERNAL CAPTUREP
 *
 *  @module CaptureP.cpp | Source ile for the <c CCaptureProperty>
 *    class used to implement a property page to test the new TAPI internal
 *    interfaces <i IBitrateControl>, <i IFrameRateControl>, and dynamic
 *    format changes.
 *
 *  @comm This code tests the TAPI Capture Pin <i IBitrateControl>,
 *    <i IFrameRateControl>, and dynamic format change implementation. This
 *    code is only compiled if USE_PROPERTY_PAGES is defined.
 ***************************************************************************/

#include "Precomp.h"

#ifdef USE_PROPERTY_PAGES

#if 0 // remove later.
// Video subtypes
EXTERN_C const GUID MEDIASUBTYPE_H263_V1 = {0x3336324DL, 0x0000, 0x0010, {0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71}};
EXTERN_C const GUID MEDIASUBTYPE_H261 = {0x3136324DL, 0x0000, 0x0010, {0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71}};
EXTERN_C const GUID MEDIASUBTYPE_H263_V2 = {0x3336324EL, 0x0000, 0x0010, {0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71}};
#endif

EXTERN_C const GUID MEDIASUBTYPE_I420 = {0x30323449L, 0x0000, 0x0010, {0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71}};
EXTERN_C const GUID MEDIASUBTYPE_IYUV = {0x56555949L, 0x0000, 0x0010, {0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71}};

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc void | CCaptureProperty | CCaptureProperty | This
 *    method is the constructor for bitrate and frame rate property objects. It
 *    calls the base class constructor, calls InitCommonControlsEx, and saves
 *    pointers to the <i IBitrateControl> and <i IFrameRateControl> interfaces.
 *
 *  @parm HWND | hDlg | Specifies a handle to the parent property page.
 *
 *  @parm ULONG | IDLabel | Specifies a label ID for the property.
 *
 *  @parm ULONG | IDMinControl | Specifies a label ID for the associated
 *    property edit control where the Minimum value of the property appears.
 *
 *  @parm ULONG | IDMaxControl | Specifies a label ID for the associated
 *    property edit control where the Maximum value of the property appears.
 *
 *  @parm ULONG | IDDefaultControl | Specifies a label ID for the associated
 *    property edit control where the Default value of the property appears.
 *
 *  @parm ULONG | IDStepControl | Specifies a label ID for the associated
 *    property edit control where the Stepping Delta value of the property appears.
 *
 *  @parm ULONG | IDEditControl | Specifies a label ID for the associated
 *    property edit control where the value of the property appears.
 *
 *  @parm ULONG | IDTrackbarControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProgressControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProperty | Specifies the ID of the Ks property.
 *
 *  @parm IBitrateControl* | pIBitrateControl | Specifies a pointer to the
 *    <i IBitrateControl> interface.
 *
 *  @parm IFrameRateControl* | pIFrameRateControl | Specifies a pointer to the
 *    <i IFrameRateControl> interface.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCaptureProperty::CCaptureProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, IBitrateControl *pIBitrateControl, IFrameRateControl *pIFrameRateControl, IVideoControl *pIVideoControl)
: CPropertyEditor(hDlg, IDLabel, IDMinControl, IDMaxControl, IDDefaultControl, IDStepControl, IDEditControl, IDTrackbarControl, IDProgressControl, IDProperty, 0)
{
	INITCOMMONCONTROLSEX cc;

	FX_ENTRY("CCaptureProperty::CCaptureProperty")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	cc.dwSize = sizeof (INITCOMMONCONTROLSEX);
	cc.dwICC  = ICC_UPDOWN_CLASS | ICC_BAR_CLASSES;

	InitCommonControlsEx(&cc);

	// It's fine if the interface pointers are NULL, we'll grey the
	// associated items in the property page
	m_pIBitrateControl = pIBitrateControl;
	m_pIFrameRateControl = pIFrameRateControl;
	m_pIVideoControl = pIVideoControl;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc void | CCaptureProperty | ~CCaptureProperty | This
 *    method is the destructor for capture property objects. It
 *    simply calls the base class destructor.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCaptureProperty::~CCaptureProperty()
{
	FX_ENTRY("CCaptureProperty::~CCaptureProperty")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc HRESULT | CCaptureProperty | GetValue | This method queries for
 *    the value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCaptureProperty::GetValue()
{
	HRESULT Hr = E_NOTIMPL;
	LONG CurrentValue;
	LONG Mode;

	FX_ENTRY("CCaptureProperty::GetValue")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	switch (m_IDProperty)
	{									
		case IDC_Capture_FrameRate:
			if (m_pIFrameRateControl && SUCCEEDED (Hr = m_pIFrameRateControl->Get(FrameRateControl_Maximum, &CurrentValue, (TAPIControlFlags *)&m_CurrentFlags)))
			{
				if (CurrentValue)
					m_CurrentValue = (LONG)(10000000 / CurrentValue);
				else
					m_CurrentValue = 0;
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: *pAvgTimePerFrame=%ld", _fx_, CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_Capture_CurrentFrameRate:
			if (m_pIFrameRateControl && SUCCEEDED (Hr = m_pIFrameRateControl->Get(FrameRateControl_Current, &CurrentValue, (TAPIControlFlags *)&m_CurrentFlags)))
			{
				if (CurrentValue)
					m_CurrentValue = (LONG)(10000000 / CurrentValue);
				else
					m_CurrentValue = 0;
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: *pAvgTimePerFrame=%ld", _fx_, CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_Capture_Bitrate:
			if (m_pIBitrateControl && SUCCEEDED (Hr = m_pIBitrateControl->Get(BitrateControl_Maximum, &m_CurrentValue, (TAPIControlFlags *)&m_CurrentFlags, 0UL)))
			{
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: *pdwMaxBitrate=%ld, dwLayerId=0", _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_Capture_CurrentBitrate:
			if (m_pIBitrateControl && SUCCEEDED (Hr = m_pIBitrateControl->Get(BitrateControl_Current, &m_CurrentValue, (TAPIControlFlags *)&m_CurrentFlags, 0UL)))
			{
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: *pdwCurrentBitrate=%ld, dwLayerId=0", _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_Capture_FlipVertical:
			if (m_pIVideoControl && SUCCEEDED (Hr = m_pIVideoControl->GetMode(&Mode)))
			{
				// We have to be between 0 and 1
				m_CurrentValue = Mode & VideoControlFlag_FlipVertical ? TRUE : FALSE;
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: Vertical flip is %s"), _fx_, m_CurrentValue ? "ON" : "OFF");
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_Capture_FlipHorizontal:
			if (m_pIVideoControl && SUCCEEDED (Hr = m_pIVideoControl->GetMode(&Mode)))
			{
				// We have to be between 0 and 1
				m_CurrentValue = Mode & VideoControlFlag_FlipHorizontal ? TRUE : FALSE;
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: Horizontal flip is %s"), _fx_, m_CurrentValue ? "ON" : "OFF");
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		default:
			Hr = E_UNEXPECTED;
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Unknown capture property", _fx_));
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc HRESULT | CCaptureProperty | SetValue | This method sets the
 *    value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCaptureProperty::SetValue()
{
	HRESULT Hr = E_NOTIMPL;
	LONG CurrentValue;
	long Mode;

	FX_ENTRY("CCaptureProperty::SetValue")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	switch (m_IDProperty)
	{
		case IDC_Capture_FrameRate:
			if (m_CurrentValue)
				CurrentValue = 10000000L / m_CurrentValue;
			if (m_pIFrameRateControl && SUCCEEDED (Hr = m_pIFrameRateControl->Set(FrameRateControl_Maximum, CurrentValue, (TAPIControlFlags)m_CurrentFlags)))
			{
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: AvgTimePerFrame=%ld", _fx_, CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_Capture_Bitrate:
			if (m_pIBitrateControl && SUCCEEDED (Hr = m_pIBitrateControl->Set(BitrateControl_Maximum, m_CurrentValue, (TAPIControlFlags)m_CurrentFlags, 0UL)))
			{
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: dwMaxBitrate=%ld, dwLayerId=0", _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_Capture_FlipVertical:
			if (m_pIVideoControl && SUCCEEDED (Hr = m_pIVideoControl->GetMode(&Mode)))
			{
				if (m_CurrentValue)
					Mode |= VideoControlFlag_FlipVertical;
				else
					Mode &= !VideoControlFlag_FlipVertical;
				if (SUCCEEDED (Hr = m_pIVideoControl->SetMode(Mode)))
				{
					DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: Vertical flip is %s"), _fx_, m_CurrentValue ? "ON" : "OFF");
				}
				else
				{
					DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
				}
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_Capture_FlipHorizontal:
			if (m_pIVideoControl && SUCCEEDED (Hr = m_pIVideoControl->GetMode(&Mode)))
			{
				if (m_CurrentValue)
					Mode |= VideoControlFlag_FlipHorizontal;
				else
					Mode &= !VideoControlFlag_FlipHorizontal;
				if (SUCCEEDED (Hr = m_pIVideoControl->SetMode(Mode)))
				{
					DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: Horizontal flip is %s"), _fx_, m_CurrentValue ? "ON" : "OFF");
				}
				else
				{
					DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
				}
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_Capture_CurrentBitrate:
		case IDC_Capture_CurrentFrameRate:
			// This is a read-only property. Don't do anything.
			Hr = NOERROR;
			break;
		default:
			Hr = E_UNEXPECTED;
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Unknown capture property", _fx_));
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc HRESULT | CCaptureProperty | GetRange | This method retrieves
 *    the range information of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCaptureProperty::GetRange()
{
	HRESULT Hr = E_NOTIMPL;
	LONG Min;
	LONG Max;
	LONG SteppingDelta;
	LONG Default;

	FX_ENTRY("CCaptureProperty::GetRange")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	switch (m_IDProperty)
	{
		case IDC_Capture_FrameRate:
			if (m_pIFrameRateControl && SUCCEEDED (Hr = m_pIFrameRateControl->GetRange(FrameRateControl_Maximum, &Min, &Max, &SteppingDelta, &Default, (TAPIControlFlags *)&m_CapsFlags)))
			{
				if (Min)
					m_Max = (LONG)(10000000 / Min);
				else
					m_Max = 0;
				if (Max)
					m_Min = (LONG)(10000000 / Max);
				else
					m_Min = 0;
				if (SteppingDelta)
					m_SteppingDelta = (m_Max - m_Min) / (LONG)((Max - Min) / SteppingDelta);
				else
					m_SteppingDelta = 0;
				if (Default)
					m_DefaultValue = (LONG)(10000000 / Default);
				else
					m_DefaultValue = 0;
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: *pMin=%ld, *pMax=%ld, *pSteppingDelta=%ld, *pDefault=%ld", _fx_, Min, Max, SteppingDelta, Default));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_Capture_CurrentFrameRate:
			if (m_pIFrameRateControl && SUCCEEDED (Hr = m_pIFrameRateControl->GetRange(FrameRateControl_Current, &Min, &Max, &SteppingDelta, &Default, (TAPIControlFlags *)&m_CapsFlags)))
			{
				if (Min)
					m_Max = (LONG)(10000000 / Min);
				else
					m_Max = 0;
				if (Max)
					m_Min = (LONG)(10000000 / Max);
				else
					m_Min = 0;
				if (SteppingDelta)
					m_SteppingDelta = (LONG)(10000000 / SteppingDelta);
				else
					m_SteppingDelta = 0;
				if (Default)
					m_DefaultValue = (LONG)(10000000 / Default);
				else
					m_DefaultValue = 0;
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: *pMin=%ld, *pMax=%ld, *pSteppingDelta=%ld, *pDefault=%ld", _fx_, Min, Max, SteppingDelta, Default));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_Capture_Bitrate:
			if (m_pIBitrateControl && SUCCEEDED (Hr = m_pIBitrateControl->GetRange(BitrateControl_Maximum, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, (TAPIControlFlags *)&m_CapsFlags, 0UL)))
			{
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: *pdwMin=%ld, *pdwMax=%ld, *pdwSteppingDelta=%ld, *pdwDefault=%ld, dwLayerId=0", _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_Capture_CurrentBitrate:
			if (m_pIBitrateControl && SUCCEEDED (Hr = m_pIBitrateControl->GetRange(BitrateControl_Current, &m_Min, &m_Max, &m_SteppingDelta, &m_DefaultValue, (TAPIControlFlags *)&m_CapsFlags, 0UL)))
			{
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: *pdwMin=%ld, *pdwMax=%ld, *pdwSteppingDelta=%ld, *pdwDefault=%ld, dwLayerId=0", _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_Capture_FlipVertical:
		case IDC_Capture_FlipHorizontal:
			m_DefaultValue = m_CurrentValue;
			m_Min = 0;
			m_Max = 1;
			m_SteppingDelta = 1;
			Hr = NOERROR;
			break;
		default:
			Hr = E_UNEXPECTED;
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Unknown capture property", _fx_));
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc CUnknown* | CCaptureProperties | CreateInstance | This
 *    method is called by DShow to create an instance of a TAPI Capture Pin
 *    Property Page. It is referred to in the global structure <t g_Templates>.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Returns a pointer to the nondelegating CUnknown portion of the
 *    object, or NULL otherwise.
 ***************************************************************************/
CUnknown* CALLBACK CCapturePropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr) 
{
	CUnknown *pUnknown = (CUnknown *)NULL;

	FX_ENTRY("CCapturePropertiesCreateInstance")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pHr);
	if (!pHr)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		goto MyExit;
	}

	if (!(pUnknown = new CCaptureProperties(pUnkOuter, pHr)))
	{
		*pHr = E_OUTOFMEMORY;
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: new CCaptureProperties failed", _fx_));
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: new CCaptureProperties created", _fx_));
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return pUnknown;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc void | CCaptureProperties | CCaptureProperties | This
 *    method is the constructor for the property page object. It simply
 *    calls the constructor of the property page base class.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCaptureProperties::CCaptureProperties(LPUNKNOWN pUnk, HRESULT *pHr) : CBasePropertyPage(NAME("TAPI Capture Pin Property Page"), pUnk, IDD_CaptureFormatProperties, IDS_CAPTUREFORMATSPROPNAME)
{
	FX_ENTRY("CCaptureProperties::CCaptureProperties")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	m_pIBitrateControl = NULL;
	m_pIFrameRateControl = NULL;
	m_pIAMStreamConfig = NULL;
	m_pIVideoControl = NULL;
	m_NumProperties = NUM_CAPTURE_CONTROLS;
	m_fActivated = FALSE;
	m_hWndFormat = m_hWnd = NULL;
	m_RangeCount = 0;
	m_SubTypeList = NULL;
	m_FrameSizeList = NULL;
	m_CurrentMediaType = NULL;
	m_CurrentFormat = 0;
	m_OriginalFormat = 0;

	for (int i = 0; i < m_NumProperties; i++)
		m_Controls[i] = NULL;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc void | CCaptureProperties | ~CCaptureProperties | This
 *    method is the destructor for the capture pin property page. It
 *    simply calls the base class destructor after deleting all the controls.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCaptureProperties::~CCaptureProperties()
{
	int		j;

	FX_ENTRY("CCaptureProperties::~CCaptureProperties")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX", _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: control already freed", _fx_));
		}
	}

	if (m_SubTypeList)
		delete[] m_SubTypeList, m_SubTypeList = NULL;

	if (m_FrameSizeList)
		delete[] m_FrameSizeList, m_FrameSizeList = NULL;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc HRESULT | CCaptureProperties | OnConnect | This
 *    method is called when the property page is connected to the filter.
 *
 *  @parm LPUNKNOWN | pUnknown | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCaptureProperties::OnConnect(IUnknown *pUnk)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCaptureProperties::OnConnect")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pUnk);
	if (!pUnk)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Get the bitrate control interface
	if (SUCCEEDED (Hr = pUnk->QueryInterface(__uuidof(IBitrateControl), (void **)&m_pIBitrateControl)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_pIBitrateControl=0x%08lX", _fx_, m_pIBitrateControl));
	}
	else
	{
		m_pIBitrateControl = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
	}

	// Get the frame rate control interface
	if (SUCCEEDED (Hr = pUnk->QueryInterface(__uuidof(IFrameRateControl), (void **)&m_pIFrameRateControl)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_pIFrameRateControl=0x%08lX", _fx_, m_pIFrameRateControl));
	}
	else
	{
		m_pIFrameRateControl = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
	}

	// Get the format control interface
	if (SUCCEEDED (Hr = pUnk->QueryInterface(IID_IAMStreamConfig, (void **)&m_pIAMStreamConfig)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_pIAMStreamConfig=0x%08lX", _fx_, m_pIAMStreamConfig));
	}
	else
	{
		m_pIAMStreamConfig = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
	}

	// Get the video control interface
	if (SUCCEEDED (Hr = pUnk->QueryInterface(__uuidof(IVideoControl), (void **)&m_pIVideoControl)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_pIVideoControl=0x%08lX", _fx_, m_pIVideoControl));
	}
	else
	{
		m_pIVideoControl = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
	}

	// It's Ok if we couldn't get interface pointers
	// We'll just grey the controls in the property page
	// to make it clear to the user that they can't
	// control those properties on the capture device
	Hr = NOERROR;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc HRESULT | CCaptureProperties | OnDisconnect | This
 *    method is called when the property page is disconnected from the owning
 *    filter.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCaptureProperties::OnDisconnect()
{
	FX_ENTRY("CCaptureProperties::OnDisconnect")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters: we seem to get called several times here
	// Make sure the interface pointer is still valid
	if (!m_pIBitrateControl)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: already disconnected!", _fx_));
	}
	else
	{
		// Release the interface
		m_pIBitrateControl->Release();
		m_pIBitrateControl = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: releasing m_pIBitrateControl", _fx_));
	}

	if (!m_pIFrameRateControl)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: already disconnected!", _fx_));
	}
	else
	{
		// Release the interface
		m_pIFrameRateControl->Release();
		m_pIFrameRateControl = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: releasing m_pIFrameRateControl", _fx_));
	}

	if (!m_pIAMStreamConfig)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: already disconnected!", _fx_));
	}
	else
	{
		// Release the interface
		m_pIAMStreamConfig->Release();
		m_pIAMStreamConfig = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: releasing m_pIAMStreamConfig", _fx_));
	}

	if (!m_pIVideoControl)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: already disconnected!", _fx_));
	}
	else
	{
		// Release the interface
		m_pIVideoControl->Release();
		m_pIVideoControl = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: releasing m_pIVideoControl", _fx_));
	}

	// Release format memory
	if (m_CurrentMediaType)
	{
		DeleteMediaType(m_CurrentMediaType);
		m_CurrentMediaType = NULL;
	}

	if (m_SubTypeList)
		delete[] m_SubTypeList, m_SubTypeList = NULL;

	if (m_FrameSizeList)
		delete[] m_FrameSizeList, m_FrameSizeList = NULL;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc HRESULT | CCaptureProperties | OnActivate | This
 *    method is called when the property page is activated.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCaptureProperties::OnActivate()
{
	HRESULT	Hr = NOERROR;
	int		j;
	TCHAR	buf[32];

	FX_ENTRY("CCaptureProperties::OnActivate")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Initialize format control structures
	m_hWndFormat = GetDlgItem(m_hWnd, IDC_FORMAT_Compression);

	// Disable everything if we didn't initialize correctly
	if (!m_pIAMStreamConfig || (FAILED (Hr = InitialRangeScan())))
	{
		EnableWindow(m_hWndFormat, FALSE);
	}
	else
	{
		// Update the content of the format combo box
		ComboBox_ResetContent(m_hWndFormat);
		for (j = 0; j < m_RangeCount; j++)
		{
			if (IsEqualGUID(m_SubTypeList[j], MEDIASUBTYPE_H263_V1))
				wsprintf (buf, "%s %ldx%ld", "H.263", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_H263_V2))
				wsprintf (buf, "%s %ldx%ld", "H.263+", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_H261))
				wsprintf (buf, "%s %ldx%ld", "H.261", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_YVU9))
				wsprintf (buf, "%s %ldx%ld", "YVU9", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_YUY2))
				wsprintf (buf, "%s %ldx%ld", "YUY2", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_YVYU))
				wsprintf (buf, "%s %ldx%ld", "YVYU", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_UYVY))
				wsprintf (buf, "%s %ldx%ld", "UYVY", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_YV12))
				wsprintf (buf, "%s %ldx%ld", "YV12", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_I420))
				wsprintf (buf, "%s %ldx%ld", "I420", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_IYUV))
				wsprintf (buf, "%s %ldx%ld", "IYUV", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_YV12))
				wsprintf (buf, "%s %ldx%ld", "YV12", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_RGB4))
				wsprintf (buf, "%s %ldx%ld", "RGB4", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_RGB8))
				wsprintf (buf, "%s %ldx%ld", "RGB8", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_RGB555))
				wsprintf (buf, "%s %ldx%ld", "RGB16", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_RGB565))
				wsprintf (buf, "%s %ldx%ld", "RGB16", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_RGB24))
				wsprintf (buf, "%s %ldx%ld", "RGB24", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else if (IsEqualGUID (m_SubTypeList[j], MEDIASUBTYPE_UYVY))
				wsprintf (buf, "%s %ldx%ld", "UYVY", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);
			else
				wsprintf (buf, "%s %ldx%ld", "Unknown", m_FrameSizeList[j].cx, m_FrameSizeList[j].cy);

			ComboBox_AddString(m_hWndFormat, buf);

			if (m_CurrentMediaType->subtype == m_SubTypeList[j] && HEADER(m_CurrentMediaType->pbFormat)->biWidth == m_FrameSizeList[j].cx  && HEADER(m_CurrentMediaType->pbFormat)->biHeight == m_FrameSizeList[j].cy)
			{
				ComboBox_SetCurSel(m_hWndFormat, j);
				m_SubTypeCurrent = m_SubTypeList[j];
				m_FrameSizeCurrent = m_FrameSizeList[j];
			}
		}

		// Update current format
		OnFormatChanged();

		// Remember the original format
		m_OriginalFormat = m_CurrentFormat;
	}

	// Create the controls for the properties
	if (m_Controls[0] = new CCaptureProperty(m_hwnd, IDC_BitrateControl_Label, IDC_BitrateControl_Minimum, IDC_BitrateControl_Maximum, IDC_BitrateControl_Default, IDC_BitrateControl_Stepping, IDC_BitrateControl_Edit, IDC_BitrateControl_Slider, 0, IDC_Capture_Bitrate, m_pIBitrateControl, m_pIFrameRateControl, m_pIVideoControl))
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[0]=0x%08lX", _fx_, m_Controls[0]));

		if (m_Controls[1] = new CCaptureProperty(m_hwnd, IDC_FrameRateControl_Label, IDC_FrameRateControl_Minimum, IDC_FrameRateControl_Maximum, IDC_FrameRateControl_Default, IDC_FrameRateControl_Stepping, IDC_FrameRateControl_Edit, IDC_FrameRateControl_Slider, 0, IDC_Capture_FrameRate, m_pIBitrateControl, m_pIFrameRateControl, m_pIVideoControl))
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[1]=0x%08lX", _fx_, m_Controls[1]));

			if (m_Controls[2] = new CCaptureProperty(m_hwnd, 0, 0, 0, 0, 0, IDC_FORMAT_FlipVertical, 0, 0, IDC_Capture_FlipVertical, m_pIBitrateControl, m_pIFrameRateControl, m_pIVideoControl))
			{
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[2]=0x%08lX", _fx_, m_Controls[2]));

				if (m_Controls[3] = new CCaptureProperty(m_hwnd, 0, 0, 0, 0, 0, IDC_FORMAT_FlipHorizontal, 0, 0, IDC_Capture_FlipHorizontal, m_pIBitrateControl, m_pIFrameRateControl, m_pIVideoControl))
				{
					DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[3]=0x%08lX", _fx_, m_Controls[3]));

					if (m_Controls[4] = new CCaptureProperty(m_hwnd, 0, 0, 0, 0, 0, IDC_FrameRateControl_Actual, 0, IDC_FrameRateControl_Meter, IDC_Capture_CurrentFrameRate, m_pIBitrateControl, m_pIFrameRateControl, m_pIVideoControl))
					{
						DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[4]=0x%08lX", _fx_, m_Controls[4]));

						if (m_Controls[5] = new CCaptureProperty(m_hwnd, 0, 0, 0, 0, 0, IDC_BitrateControl_Actual, 0, IDC_BitrateControl_Meter, IDC_Capture_CurrentBitrate, m_pIBitrateControl, m_pIFrameRateControl, m_pIVideoControl))
						{
							DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[5]=0x%08lX", _fx_, m_Controls[5]));
						}
						else
						{
							DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
							delete m_Controls[0], m_Controls[0] = NULL;
							delete m_Controls[1], m_Controls[1] = NULL;
							delete m_Controls[2], m_Controls[2] = NULL;
							delete m_Controls[3], m_Controls[3] = NULL;
							delete m_Controls[4], m_Controls[4] = NULL;
							Hr = E_OUTOFMEMORY;
							goto MyExit;
						}
					}
					else
					{
						DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
						delete m_Controls[0], m_Controls[0] = NULL;
						delete m_Controls[1], m_Controls[1] = NULL;
						delete m_Controls[2], m_Controls[2] = NULL;
						delete m_Controls[3], m_Controls[3] = NULL;
						Hr = E_OUTOFMEMORY;
						goto MyExit;
					}
				}
				else
				{
					DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
					delete m_Controls[0], m_Controls[0] = NULL;
					delete m_Controls[1], m_Controls[1] = NULL;
					delete m_Controls[2], m_Controls[2] = NULL;
					Hr = E_OUTOFMEMORY;
					goto MyExit;
				}
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
				delete m_Controls[0], m_Controls[0] = NULL;
				delete m_Controls[1], m_Controls[1] = NULL;
				Hr = E_OUTOFMEMORY;
				goto MyExit;
			}
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
			delete m_Controls[0], m_Controls[0] = NULL;
			Hr = E_OUTOFMEMORY;
			goto MyExit;
		}
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
		Hr = E_OUTOFMEMORY;
		goto MyExit;
	}

	// Initialize all the controls. If the initialization fails, it's Ok. It just means
	// that the TAPI control interface isn't implemented by the device. The dialog item
	// in the property page will be greyed, showing this to the user.
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j]->Init())
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[%ld]->Init()", _fx_, j));
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: m_Controls[%ld]->Init() failed", _fx_, j));
		}
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	m_fActivated = TRUE;
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc HRESULT | CCaptureProperties | OnDeactivate | This
 *    method is called when the property page is dismissed.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCaptureProperties::OnDeactivate()
{
	int	j;

	FX_ENTRY("CCaptureProperties::OnDeactivate")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX", _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: control already freed", _fx_));
		}
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc HRESULT | CCaptureProperties | GetCurrentMediaType | This
 *    method is used to retrieve the current media format used by the pin.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCaptureProperties::GetCurrentMediaType(void)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCaptureProperties::GetCurrentMediaType")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	if (m_CurrentMediaType)
	{
		DeleteMediaType (m_CurrentMediaType);
		m_CurrentMediaType = NULL;
	}

	if (FAILED (Hr = m_pIAMStreamConfig->GetFormat((AM_MEDIA_TYPE **)&m_CurrentMediaType)))
	{
		// Otherwise, just get the first enumerated media type
		VIDEO_STREAM_CONFIG_CAPS RangeCaps;

		if (FAILED (Hr = m_pIAMStreamConfig->GetStreamCaps(0, (AM_MEDIA_TYPE **)&m_CurrentMediaType, (BYTE *)&RangeCaps)))
		{
			m_CurrentMediaType = NULL;
		}
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc HRESULT | CCaptureProperties | OnFormatChanged | This
 *    method is used to retrieve the format selected by the user.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCaptureProperties::OnFormatChanged()
{
	HRESULT	Hr = E_UNEXPECTED;
	int		j;

	FX_ENTRY("CCaptureProperties::OnFormatChanged")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	if (!m_pIAMStreamConfig)
	{
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	// Associate the current compression index with the right range index
	m_CurrentFormat = ComboBox_GetCurSel(m_hWndFormat);
	ASSERT (m_CurrentFormat >= 0 && m_CurrentFormat < m_RangeCount);
	if (m_CurrentFormat >= 0 && m_CurrentFormat < m_RangeCount)
	{
		m_SubTypeCurrent = m_SubTypeList[m_CurrentFormat];
		m_FrameSizeCurrent = m_FrameSizeList[m_CurrentFormat];

		for (j = 0; j < m_RangeCount; j++)
		{
			if (m_SubTypeList[j] == m_SubTypeCurrent)
			{
				CMediaType *pmt = NULL;

				Hr = m_pIAMStreamConfig->GetStreamCaps(j, (AM_MEDIA_TYPE **)&pmt, (BYTE *)&m_RangeCaps);

				DeleteMediaType (pmt);
			}
		}
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc HRESULT | CCaptureProperties | InitialRangeScan | This
 *    method is used to retrieve the list of supported formats on the pin.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCaptureProperties::InitialRangeScan()
{
	HRESULT			Hr = NOERROR;
	int				lSize;
	int				j;
	AM_MEDIA_TYPE	*pmt = NULL;

	FX_ENTRY("CCaptureProperties::InitialRangeScan")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	if (!m_pIAMStreamConfig)
	{
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	Hr = m_pIAMStreamConfig->GetNumberOfCapabilities(&m_RangeCount, &lSize);
	ASSERT (lSize >= sizeof (VIDEO_STREAM_CONFIG_CAPS) && SUCCEEDED (Hr));
	if (lSize < sizeof (VIDEO_STREAM_CONFIG_CAPS) || !SUCCEEDED(Hr))
	{
		Hr = E_FAIL;
		goto MyExit;
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   NumberOfRanges=%d", _fx_, m_RangeCount));

	if (!(m_SubTypeList = new GUID [m_RangeCount]))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: ERROR: new failed", _fx_));
		Hr = E_OUTOFMEMORY;
		goto MyExit;
	}

	if (!(m_FrameSizeList = new SIZE [m_RangeCount]))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: ERROR: new failed", _fx_));
		Hr = E_OUTOFMEMORY;
		goto MyExit;
	}

	for (j = 0; j < m_RangeCount; j++)
	{
		pmt = NULL;

		Hr = m_pIAMStreamConfig->GetStreamCaps(j, (AM_MEDIA_TYPE **)&pmt, (BYTE *)&m_RangeCaps);

		ASSERT(SUCCEEDED (Hr));
		ASSERT(pmt);
		ASSERT(pmt->majortype == MEDIATYPE_Video);
		ASSERT(pmt->formattype == FORMAT_VideoInfo);

		m_SubTypeList[j] = pmt->subtype;
		m_FrameSizeList[j].cx = HEADER(pmt->pbFormat)->biWidth;
		m_FrameSizeList[j].cy = HEADER(pmt->pbFormat)->biHeight;

		DeleteMediaType(pmt);
	}

	// Get default format
	Hr = GetCurrentMediaType();

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc HRESULT | CCaptureProperties | OnApplyChanges | This
 *    method is called when the user applies changes to the property page.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCaptureProperties::OnApplyChanges()
{
	HRESULT	Hr = NOERROR;
	int		j;
	CMediaType *pmt = NULL;

	FX_ENTRY("CCaptureProperties::OnApplyChanges")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Apply format changes on video stream
	m_CurrentFormat = ComboBox_GetCurSel(m_hWndFormat);
	
	// Only apply change if the format is different
	if (m_CurrentFormat != m_OriginalFormat)
	{
		if (SUCCEEDED (Hr = m_pIAMStreamConfig->GetStreamCaps(m_CurrentFormat, (AM_MEDIA_TYPE **) &pmt, (BYTE *)&m_RangeCaps)))
		{
			ASSERT(pmt && *pmt->FormatType() == FORMAT_VideoInfo);

			if (pmt && *pmt->FormatType() == FORMAT_VideoInfo)
			{
				if (FAILED(Hr = m_pIAMStreamConfig->SetFormat(pmt)))
				{
					TCHAR TitleBuf[80];
					TCHAR TextBuf[80];

					LoadString(g_hInst, IDS_ERROR_CONNECTING_TITLE, TitleBuf, sizeof (TitleBuf));
					LoadString(g_hInst, IDS_ERROR_CONNECTING, TextBuf, sizeof (TextBuf));
					MessageBox (NULL, TextBuf, TitleBuf, MB_OK);
				}
			}

			// Free some memory that was allocated by GetStreamCaps
			if (pmt)
				DeleteMediaType(pmt);

			// Update our copy of the current format
			GetCurrentMediaType();
		}
	}

	// Apply target bitrate and target frame rate changes on video stream
	for (j = 0; j < m_NumProperties; j++)
	{
		ASSERT(m_Controls[j]);
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: calling m_Controls[%ld]=0x%08lX->OnApply", _fx_, j, m_Controls[j]));
			if (m_Controls[j]->HasChanged())
				m_Controls[j]->OnApply();
			Hr = NOERROR;
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: can't calling m_Controls[%ld]=NULL->OnApply", _fx_, j));
			Hr = E_UNEXPECTED;
		}
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc BOOL | CCaptureProperties | OnReceiveMessage | This
 *    method is called when a message is sent to the property page dialog box.
 *
 *  @rdesc By default, returns the value returned by the Win32 DefWindowProc function.
 ***************************************************************************/
BOOL CCaptureProperties::OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
	int iNotify = HIWORD (wParam);
	int j;

	switch (uMsg)
	{
		case WM_INITDIALOG:
			// This is called before Activate...
			m_hWnd = hWnd;
			return TRUE; // Don't call setfocus

		case WM_TIMER:
			if (m_fActivated)
			{
				// Update the Vu-Meters
				for (j = 0; j < m_NumProperties; j++)
				{
					ASSERT(m_Controls[j]);
					if (m_Controls[j]->GetProgressHWnd())
					{
						m_Controls[j]->UpdateProgress();
						SetDirty();
					}
				}
			}
			break;

		case WM_HSCROLL:
		case WM_VSCROLL:
			if (m_fActivated)
			{
				// Process all of the Trackbar messages
				for (j = 0; j < m_NumProperties; j++)
				{
					ASSERT(m_Controls[j]);
					if (m_Controls[j]->GetTrackbarHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnScroll(uMsg, wParam, lParam);
						SetDirty();
					}
				}
			}
			break;

		case WM_COMMAND:

			// This message gets sent even before OnActivate() has been
			// called(!). We need to test and make sure the controls have
			// beeen initialized before we can use them.
			if (m_fActivated)
			{
				// Process all of the edit box messages
				for (j = 0; j < m_NumProperties; j++)
				{
					if (m_Controls[j] && m_Controls[j]->GetEditHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnEdit(uMsg, wParam, lParam);
						SetDirty();
						break;
					}
				}

				switch (LOWORD(wParam))
				{
					case IDC_CONTROL_DEFAULT:
						for (j = 0; j < m_NumProperties; j++)
						{
							if (m_Controls[j])
								m_Controls[j]->OnDefault();
						}
						break;

					case IDC_FORMAT_Compression:
						if (HIWORD(wParam) == CBN_SELCHANGE)
						{
							OnFormatChanged();
						}
						break;

					default:
						break;
				}
			}
			break;

		default:
			return FALSE;
	}

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPMETHOD
 *
 *  @mfunc BOOL | CCaptureProperties | SetDirty | This
 *    method notifies the property page site of changes.
 *
 *  @rdesc Nada.
 ***************************************************************************/
void CCaptureProperties::SetDirty()
{
	m_bDirty = TRUE;
	if (m_pPageSite)
		m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\convert.cpp ===
/****************************************************************************
 *  @doc INTERNAL CONVERT
 *
 *  @module Convert.cpp | Source file for the <c CConverter> class methods
 *    used to implement the video capture and preview pin format conversion
 *    routines.
 *
 *  @todo Merge the two ScaleDIB methods + fix method comments + by the end
 *    of the H.263 work, you should never have to open an ICM encoder for
 *    encoding, only decode or scaling -> clean code at that point
 ***************************************************************************/

#include "Precomp.h"

#ifdef DEBUG
#define DBGUTIL_ENABLE
#endif
#define CONVERT_DEBUG
//--//#include "dbgutil.h" // this defines the __DBGUTIL_H__ below
#if defined(DBGUTIL_ENABLE) && defined(__DBGUTIL_H__)

  #ifdef CONVERT_DEBUG
    DEFINE_DBG_VARS(Convert, (NTSD_OUT | LOG_OUT), 0x0);
  #else
    DEFINE_DBG_VARS(Convert, 0, 0);
  #endif
  #define D(f) if(g_dbg_Convert & (f))

#else
  #undef CONVERT_DEBUG

  #define D(f) ; / ## /
  #define dprintf ; / ## /
  #define dout ; / ## /
#endif


#define MIN_IFRAME_REQUEST_INTERVAL 15000

BYTE g_rmap[256];
BYTE g_gmap[256];
BYTE g_bmap[256];

enum yuvstartpos_e { Y_POS=0, U_POS, V_POS };
int UYVYplanestart[3]={ 1, 0, 2};
int YUY2planestart[3]={ 0, 1, 3};

/****************************************************************************
 *  @doc INTERNAL CCONVERTMETHOD
 *
 *  @mfunc void | CConverter | CConverter | This method is the constructor
 *    for the <c CConverter> object.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CConverter::CConverter(IN TCHAR *pObjectName, IN CTAPIBasePin *pBasePin, IN PBITMAPINFOHEADER pbiIn, IN PBITMAPINFOHEADER pbiOut, IN HRESULT *pHr) : CUnknown(pObjectName, NULL, pHr)
{
        DWORD dwBmiSize, dwOutBmiSize;

        FX_ENTRY("CConverter::CConverter")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pHr);
        ASSERT(pBasePin);
        ASSERT(pbiIn);
        ASSERT(pbiOut);
        if (!pBasePin || !pbiIn || !pbiOut || !pHr)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                if (pHr)
                        *pHr = E_POINTER;
                goto MyExit;
        }

        // Default inits
        m_pBasePin      = pBasePin;
        m_fConvert      = FALSE;
        m_pbiInt        = NULL;
        m_pbyOut        = NULL;

        // Quality control
        m_dwImageQuality = 0UL; // Highest quality

        // Backup input format bitmap info header
        dwBmiSize = pbiIn->biSize;

        // Copy the palette if necessary
        if (pbiIn->biCompression == BI_RGB)
        {
                if (pbiIn->biBitCount == 8)
                {
                        dwBmiSize += (DWORD)(pbiIn->biClrImportant ? pbiIn->biClrImportant * sizeof(RGBQUAD) : 256 * sizeof(RGBQUAD));
                }
                else if (pbiIn->biBitCount == 4)
                {
                        dwBmiSize += (DWORD)(pbiIn->biClrImportant ? pbiIn->biClrImportant * sizeof(RGBQUAD) : 16 * sizeof(RGBQUAD));
                }
        }

        if (!(m_pbiIn = (PBITMAPINFOHEADER)(new BYTE[dwBmiSize])))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                *pHr = E_OUTOFMEMORY;
                goto MyExit;
        }

        // @todo Why are we making a copy exactly?
        CopyMemory(m_pbiIn, pbiIn, dwBmiSize);

        // Backup output format bitmap info header
        // @todo Why do we make copy of this instead of keeping a reference to the bitmap infoheader?
        dwOutBmiSize = pbiOut->biSize;

        // Copy the palette if necessary
        if (pbiOut->biCompression == BI_RGB)
        {
                if (pbiOut->biBitCount == 8)
                {
                        dwOutBmiSize += (DWORD)(pbiOut->biClrImportant ? pbiOut->biClrImportant * sizeof(RGBQUAD) : 256 * sizeof(RGBQUAD));
                }
                else if (pbiOut->biBitCount == 4)
                {
                        dwOutBmiSize += (DWORD)(pbiOut->biClrImportant ? pbiOut->biClrImportant * sizeof(RGBQUAD) : 16 * sizeof(RGBQUAD));
                }
        }

        if (!(m_pbiOut = (PBITMAPINFOHEADER)(new BYTE[dwOutBmiSize])))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                *pHr = E_OUTOFMEMORY;
                goto MyError1;
        }
        CopyMemory(m_pbiOut, pbiOut, dwOutBmiSize);

        // Figure out the type of conversion needed
        m_dwConversionType = CONVERSIONTYPE_NONE;
        if (m_pbiIn->biCompression == BI_RGB)
        {
                // This can only be an encoding and maybe size change
                if (m_pbiOut->biCompression != BI_RGB)
                {
                        // This can only be an encoding and maybe a size change (e.g. 176x144 RGB24 -> 176x144 H.26X)
                        m_dwConversionType |= CONVERSIONTYPE_ENCODE;
                }
        }
        else
        {
                // This can still be an encoding or decoding operation
                if (m_pbiOut->biCompression != BI_RGB)
                {
                        // This can only be an encoding and maybe a size change (e.g. 176x144 YVU9 -> 176x144 H.26X)
                        m_dwConversionType |= CONVERSIONTYPE_ENCODE;
                }
                else
                {
                        // This can only be an encoding and maybe a size change (e.g. 176x144 YVU9 -> 176x144 RGB24)
                        m_dwConversionType |= CONVERSIONTYPE_DECODE;
                }
        }

        // Do we also need a size change? or a V or H flip ?
        if (m_pbiIn->biWidth != m_pbiOut->biWidth || m_pbiIn->biHeight != m_pbiOut->biHeight || pBasePin->m_fFlipVertical || pBasePin->m_fFlipHorizontal)
        {
                if (m_dwConversionType == CONVERSIONTYPE_NONE)
                {
                        // We only need a size change  (e.g. 160x120 RGB24 -> 176x144 RGB24)
                        // This doesn't require any temporary buffer
                        m_dwConversionType |= CONVERSIONTYPE_SCALER;
                }
                else
                {
                        // We also need a size change  (e.g. 160x120 RGB24 -> 176x144 RGB24 -> 176x144 H.26X or 160x120 YVU9 -> 160x120 RGB24 -> 176x144 H.26X)
                        m_dwConversionType |= CONVERSIONTYPE_SCALER;

                        if (m_pbiIn->biCompression == BI_RGB || m_pbiIn->biCompression == VIDEO_FORMAT_YVU9 || m_pbiIn->biCompression == VIDEO_FORMAT_YUY2 || m_pbiIn->biCompression == VIDEO_FORMAT_UYVY || m_pbiIn->biCompression == VIDEO_FORMAT_I420 || m_pbiIn->biCompression == VIDEO_FORMAT_IYUV)
                        {
                                // The scaling will occur before the format conversion
                                m_dwConversionType |= CONVERSIONTYPE_PRESCALER;

                                // The input and intermediary buffers are both RGB (e.g. 160x120 RGB24 -> 176x144 RGB24 -> 176x144 H.26X)
                                if (!(m_pbiInt = (PBITMAPINFOHEADER)(new BYTE[(pbiIn->biBitCount == 4) ? pbiIn->biSize + 256 * sizeof(RGBQUAD) : dwBmiSize])))
                                {
                                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                                        *pHr = E_OUTOFMEMORY;
                                        goto MyError2;
                                }

                                CopyMemory(m_pbiInt, pbiIn, dwBmiSize);

                                // If the input is 4bpp, we'll use a RGB8 intermediate format
                                if (pbiIn->biBitCount == 4)
                                {
                                        m_pbiInt->biBitCount = 8;
                                        m_pbiInt->biClrImportant = 256;
                                }
                                m_pbiInt->biWidth = m_pbiOut->biWidth;
                                m_pbiInt->biHeight = m_pbiOut->biHeight;
                                m_pbiInt->biSizeImage = DIBSIZE(*m_pbiInt);

                                // Allocate intermediary buffer
                                if (!(m_pbyOut = (PBYTE)(new BYTE[m_pbiInt->biSizeImage])))
                                {
                                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                                        *pHr = E_OUTOFMEMORY;
                                        goto MyError3;
                                }
                        }
                        else
                        {
                                // We will need to decompress to an intermediary format if a size change is necessary (e.g. 160x120 MJPEG -> 160x120 RGB24 -> 176x144 RGB24)
                                if (!(m_pbiInt = (PBITMAPINFOHEADER)(new BYTE[pbiOut->biSize])))
                                {
                                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                                        *pHr = E_OUTOFMEMORY;
                                        goto MyError2;
                                }
                                CopyMemory(m_pbiInt, pbiOut, pbiOut->biSize);
                                m_pbiInt->biWidth = m_pbiIn->biWidth;
                                m_pbiInt->biHeight = m_pbiIn->biHeight;
                                m_pbiInt->biSizeImage = DIBSIZE(*m_pbiInt);

                                // Allocate intermediary buffer
                                if (!(m_pbyOut = (PBYTE)(new BYTE[m_pbiInt->biSizeImage])))
                                {
                                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                                        *pHr = E_OUTOFMEMORY;
                                        goto MyError3;
                                }
                        }
                }
        }

#ifdef USE_SOFTWARE_CAMERA_CONTROL
        // Soft Cam Control
        m_fSoftCamCtrl = FALSE;
#endif

        *pHr = NOERROR;

        goto MyExit;

MyError3:
        if (m_pbiInt)
                delete m_pbiInt, m_pbiInt = NULL;
MyError2:
        if (m_pbiOut)
                delete m_pbiOut, m_pbiOut = NULL;
MyError1:
        if (m_pbiIn)
                delete m_pbiIn, m_pbiIn = NULL;
MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCONVERTMETHOD
 *
 *  @mfunc void | CConverter | ~CConverter | This method is the destructor
 *    for the <c CConverter> object.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CConverter::~CConverter()
{
        FX_ENTRY("CConverter::~CConverter")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        if (m_pbiIn)
                delete m_pbiIn, m_pbiIn = NULL;

        if (m_pbiOut)
                delete m_pbiOut, m_pbiOut = NULL;

        if (m_pbiInt)
                delete m_pbiInt, m_pbiInt = NULL;

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCONVERTMETHOD
 *
 *  @mfunc HRESULT | CConverter | NonDelegatingQueryInterface | This
 *    method is the nondelegating interface query function.
 *
 *  @parm REFIID | riid | Specifies the identifier of the interface to return.
 *
 *  @parm PVOID* | ppv | Specifies the place in which to put the interface
 *    pointer.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CConverter::NonDelegatingQueryInterface(IN REFIID riid, OUT void **ppv)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CConverter::NonDelegatingQueryInterface")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(ppv);
        if (!ppv)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Retrieve interface pointer
        if (FAILED(Hr = CUnknown::NonDelegatingQueryInterface(riid, ppv)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, WARN, "%s:   WARNING: NDQI for {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX} failed Hr=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], Hr));
        }
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX}*=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], *ppv));
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCONVERTMETHOD
 *
 *  @mfunc HRESULT | CICMConverter | OpenConverter | This method opens an ICM
 *    converter.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 *
 *  @todo Verify error management
 ***************************************************************************/
HRESULT CICMConverter::OpenConverter()
{
        HRESULT                         Hr = NOERROR;
        ICINFO                          icInfo;
        DWORD                           dwStateSize;
        PVOID                           pvState = NULL;
        ICCOMPRESSFRAMES        iccf = {0};
        PMSH26XCOMPINSTINFO     pciMSH26XInfo;
#ifdef USE_MPEG4_SCRUNCH
        PMPEG4COMPINSTINFO      pciMPEG4Info;
#endif
        PBITMAPINFOHEADER       pbiIn, pbiOut;

        FX_ENTRY("CICMConverter::OpenConverter")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(m_pbiIn);
        ASSERT(m_pbiOut);
        ASSERT(!m_hIC);
        if (!m_pbiIn || !m_pbiOut || m_hIC)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Previous converter needs to be closed first", _fx_));
                Hr = E_UNEXPECTED;
                goto MyExit;
        }

        // Use a decompressor if necessary
        if (m_dwConversionType & CONVERSIONTYPE_DECODE)
        {
                // Do we need to scale the input first?
                if (m_dwConversionType & CONVERSIONTYPE_SCALER)
                {
                        // This is different if the scaling occurs before or after
                        if (m_dwConversionType & CONVERSIONTYPE_PRESCALER)
                        {
                                pbiIn = m_pbiInt;
                                pbiOut = m_pbiOut;
                        }
                        else
                        {
                                pbiIn = m_pbiIn;
                                pbiOut = m_pbiInt;
                        }
                }
                else
                {
                        pbiIn = m_pbiIn;
                        pbiOut = m_pbiOut;
                }

                // Locate a decompressor
                if ((m_hIC = ICLocate(ICTYPE_VIDEO, 0L, pbiIn, pbiOut, ICMODE_DECOMPRESS)) == NULL)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed to locate a decompressor", _fx_));
                        Hr = E_FAIL;
                        goto MyError3;
                }

                // Make sure the found compressor can decompress this format at all
                if (ICDecompressQuery(m_hIC, pbiIn, pbiOut) != ICERR_OK)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Bogus decompressor", _fx_));
                        Hr = E_FAIL;
                        goto MyError4;
                }

                // Get ready for decompression
                if (ICDecompressBegin(m_hIC, pbiIn, pbiOut) != ICERR_OK)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Bogus decompressor", _fx_));
                        Hr = E_FAIL;
                        goto MyError4;
                }

                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: Decompressor ready", _fx_));
        }
        else if (m_dwConversionType & CONVERSIONTYPE_ENCODE)
        {
                // Locate a compressor
                if ((m_pbiOut->biCompression == FOURCC_M263) || (m_pbiOut->biCompression == FOURCC_M261))
                {
                        #define CUSTOM_ENABLE_CODEC     (ICM_RESERVED_HIGH+201)
                        #define MAGICWORD1                      0xf7329ace
                        #define MAGICWORD2                      0xacdeaea2
                        if (m_hIC = ICOpen(ICTYPE_VIDEO, m_pbiOut->biCompression, ICMODE_COMPRESS))
                                ICSendMessage(m_hIC, CUSTOM_ENABLE_CODEC, MAGICWORD1, MAGICWORD2);
                }
                else
                        m_hIC = ICLocate(ICTYPE_VIDEO, m_pbiOut->biCompression, m_pbiIn, m_pbiOut, ICMODE_COMPRESS);

                if (!m_hIC)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed to locate a compressor", _fx_));
                        Hr = E_FAIL;
                        goto MyError3;
                }

                // Get info about this compressor
                ICGetInfo(m_hIC, &icInfo, sizeof(ICINFO));
                m_dwFrame = 0L;
                // For now, issue a key frame every 15 seconds
                m_dwLastIFrameTime = GetTickCount();
                m_fPeriodicIFrames = TRUE;
                m_dwLastTimestamp = 0xFFFFFFFF;

                // Get the state of the compressor
                if (dwStateSize = ICGetStateSize(m_hIC))
                {
                        if (!(pvState = (PVOID) new BYTE[dwStateSize]))
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory!", _fx_));
                                Hr = E_OUTOFMEMORY;
                                goto MyError4;
                        }
                        if (((DWORD) ICGetState(m_hIC, pvState, dwStateSize)) != dwStateSize)
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: ICGetState failed!", _fx_));
                                Hr = E_FAIL;
                                goto MyError5;
                        }
                }

                // Do any of the stuff that is MS H.263 or MS H.261 specific right here
                if ((m_pbiOut->biCompression == FOURCC_M263) || (m_pbiOut->biCompression == FOURCC_M261))
                {
                        pciMSH26XInfo = (PMSH26XCOMPINSTINFO)pvState;

                        // Really configure the codec for compression
                        pciMSH26XInfo->Configuration.bRTPHeader = TRUE;
                        if (m_pBasePin->m_pCaptureFilter->m_pRtpPdPin)
                                pciMSH26XInfo->Configuration.unPacketSize = m_pBasePin->m_pCaptureFilter->m_pRtpPdPin->m_dwMaxRTPPacketSize;
                        else
                                pciMSH26XInfo->Configuration.unPacketSize = DEFAULT_RTP_PACKET_SIZE;
                        pciMSH26XInfo->Configuration.bEncoderResiliency = FALSE;
                        pciMSH26XInfo->Configuration.unPacketLoss = 0;
                        pciMSH26XInfo->Configuration.bBitRateState = TRUE;
                        pciMSH26XInfo->Configuration.unBytesPerSecond = 1664;
                        if (((DWORD) ICSetState(m_hIC, (PVOID)pciMSH26XInfo, dwStateSize)) != dwStateSize)
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: ICSetState failed!", _fx_));
                                Hr = E_FAIL;
                                goto MyError5;
                        }

                        // Get rid of the state structure
                        delete [] pvState;
                }
#ifdef USE_MPEG4_SCRUNCH
                else if ((m_pbiOut->biCompression == VIDEO_FORMAT_MPEG4_SCRUNCH))
                {
                        pciMPEG4Info = (PMPEG4COMPINSTINFO)pvState;

                        // Configure the codec for compression
                        pciMPEG4Info->lMagic = MPG4_STATE_MAGIC;
                        pciMPEG4Info->dDataRate = 20;
                        pciMPEG4Info->lCrisp = CRISP_DEF;
                        pciMPEG4Info->lKeydist = 30;
                        pciMPEG4Info->lPScale = MPG4_PSEUDO_SCALE;
                        pciMPEG4Info->lTotalWindowMs = MPG4_TOTAL_WINDOW_DEFAULT;
                        pciMPEG4Info->lVideoWindowMs = MPG4_VIDEO_WINDOW_DEFAULT;
                        pciMPEG4Info->lFramesInfoValid = FALSE;
                        pciMPEG4Info->lBFrameOn = MPG4_B_FRAME_ON;
                        pciMPEG4Info->lLiveEncode = MPG4_LIVE_ENCODE;
                        if (((DWORD) ICSetState(m_hIC, (PVOID)pciMPEG4Info, dwStateSize)) != dwStateSize)
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: ICSetState failed!", _fx_));
                                Hr = E_FAIL;
                                goto MyError5;
                        }

                        // Get rid of the state structure
                        delete [] pvState;
                }
#endif

                // Initialize ICCOMPRESSFRAMES structure
                iccf.dwFlags = icInfo.dwFlags;
                iccf.lQuality = 10000UL - (m_dwImageQuality * 322UL);
                iccf.lDataRate = m_dwImageQuality;
                iccf.lKeyRate = 0xFFFFFFFF;
                iccf.dwRate = 1000UL;
#ifdef USE_MPEG4_SCRUNCH
                iccf.dwScale = 142857;
#else
                iccf.dwScale = (LONG)m_pBasePin->m_lMaxAvgTimePerFrame / 1000UL;
#endif

                // Send this guy to the compressor
                if ((ICSendMessage(m_hIC, ICM_COMPRESS_FRAMES_INFO, (DWORD)(LPVOID)&iccf, sizeof(iccf)) != ICERR_OK))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Codec failed to handle ICM_COMPRESS_FRAMES_INFO message correctly!", _fx_));
                        Hr = E_FAIL;
                        goto MyError4;
                }

                // Start the compressor/decompressor with the right format
                if ((ICCompressGetFormatSize(m_hIC, m_pbiIn) < sizeof(BITMAPINFOHEADER)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: ICCompressGetFormatSize failed!", _fx_));
                        Hr = E_FAIL;
                        goto MyError4;
                }

                // @todo Basd on the result of the previous call, re-allocate if necessary
                if ((ICCompressGetFormat(m_hIC, m_pbiIn, m_pbiOut)) != ICERR_OK)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: ICCompressGetFormat failed!", _fx_));
                        Hr = E_FAIL;
                        goto MyError4;
                }

                if ((ICCompressBegin(m_hIC, m_pbiIn, m_pbiOut)) != MMSYSERR_NOERROR)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: ICCompressBegin failed!", _fx_));
                        Hr = E_FAIL;
                        goto MyError4;
                }

                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: Compressor ready", _fx_));
        }
        else if (m_dwConversionType & CONVERSIONTYPE_SCALER)
        {
                // Do we need to prepare some stuff for the scaler to work?
                if (m_pbiOut->biCompression == BI_RGB && m_pbiOut->biBitCount == 8)
                {
                        if (!m_pBasePin->m_fNoImageStretch)
                        {
                                // Create a temporary palette
                                InitDst8(m_pbiOut);
                        }
                        else
                        {
                                // Look for the palette entry closest to black
                                InitBlack8(m_pbiIn);
                        }
                }
        }

        m_fConvert = TRUE;

        goto MyExit;

MyError5:
        if (pvState)
                delete [] pvState, pvState = NULL;
MyError4:
        if (m_hIC)
                ICClose(m_hIC), m_hIC = NULL;
MyError3:
        if (m_pbiInt)
                delete m_pbiInt, m_pbiInt = NULL;
        if (m_pbiOut)
                delete m_pbiOut, m_pbiOut = NULL;
        if (m_pbiIn)
                delete m_pbiIn, m_pbiIn = NULL;
MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCONVERTMETHOD
 *
 *  @mfunc HRESULT | CICMConverter | ConvertFrame | This method converts
 *    a bitmap from one format to another, or scale a bitmap.
 *
 *  @parm PBYTE | pbyInput | Pointer to the input buffer.
 *
 *  @parm DWORD | dwInputSize | Size of the input buffer.
 *
 *  @parm PBYTE | pbyOutput | Pointer to the output buffer.
 *
 *  @parm PDWORD | pdwOutputSize | Pointer to a DWORD to receive the size
 *    of the converted data.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 *
 *  @todo Verify error management
 ***************************************************************************/
HRESULT CICMConverter::ConvertFrame(IN PBYTE pbyInput, IN DWORD dwInputSize, IN PBYTE pbyOutput, OUT PDWORD pdwOutputSize, OUT PDWORD pdwBytesExtent, IN PBYTE pbyPreview, IN OUT PDWORD pdwPreviewSize, IN BOOL fSendKeyFrame)
{
        HRESULT Hr = NOERROR;
        BOOL    fKeyFrame;
    DWORD       dwMaxSizeThisFrame = 0xffffff;
        DWORD   ckid = 0UL;
        DWORD   dwFlags;
        DWORD   dwTimestamp;
        RECT    rcRect;

        FX_ENTRY("CICMConverter::ConvertFrame")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pbyInput);
        ASSERT(pbyOutput);
        ASSERT(pdwOutputSize);
        ASSERT(m_pbiIn);
        ASSERT(m_pbiOut);
        ASSERT(m_fConvert);
        if (!pbyInput || !pbyOutput || !pdwOutputSize)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }
        if (!m_pbiIn || !m_pbiOut || !m_fConvert)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Converter needs to be opened first", _fx_));
                Hr = E_UNEXPECTED;
                goto MyExit;
        }

        D(1) dprintf("%s : in m_pBasePin @ %p -> m_fFlipHorizontal = %d , m_fFlipVertical = %d\n", _fx_, m_pBasePin, m_pBasePin->m_fFlipHorizontal, m_pBasePin->m_fFlipVertical);

        if (m_dwConversionType & CONVERSIONTYPE_DECODE)
        {
                ASSERT(m_hIC);

#ifdef USE_SOFTWARE_CAMERA_CONTROL
                if (IsSoftCamCtrlNeeded())
                {
                        if (!IsSoftCamCtrlInserted())
                                InsertSoftCamCtrl();
                }
                else
                {
                        if (IsSoftCamCtrlInserted())
                                RemoveSoftCamCtrl();
                }
#endif
                if (m_dwConversionType & CONVERSIONTYPE_SCALER)
                {
                        // Do we need to scale the input first?
                        if (m_dwConversionType & CONVERSIONTYPE_PRESCALER)
                        {
                                // Get the input rectangle
                                ComputeRectangle(m_pbiIn, m_pbiInt, m_pBasePin->m_pCaptureFilter->m_pCapDev->m_lCCZoom, m_pBasePin->m_pCaptureFilter->m_pCapDev->m_lCCPan, m_pBasePin->m_pCaptureFilter->m_pCapDev->m_lCCTilt, &rcRect, m_pBasePin->m_fFlipHorizontal, m_pBasePin->m_fFlipVertical);

                                // Scale DIB
                                ScaleDIB(m_pbiIn, pbyInput, m_pbiInt, m_pbyOut, &rcRect, m_pBasePin->m_fFlipHorizontal, m_pBasePin->m_fFlipVertical, m_pBasePin->m_fNoImageStretch, m_pBasePin->m_dwBlackEntry);

                                // Decompress the scaled bits to destination buffer
                                if (!m_hIC || (ICDecompress(m_hIC, 0, m_pbiInt, m_pbyOut, m_pbiOut, pbyOutput) != ICERR_OK))
                                {
                                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Decompression failed!", _fx_));
                                        Hr = E_FAIL;
                                        goto MyExit;
                                }

                                // Update output size
                                *pdwOutputSize = m_pbiOut->biSizeImage;
                        }
                        else
                        {
                                // Decompress the compressed bits to temporary buffer before scaling them
                                if (!m_hIC || (ICDecompress(m_hIC, 0, m_pbiIn, pbyInput, m_pbiInt, m_pbyOut) != ICERR_OK))
                                {
                                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Decompression failed!", _fx_));
                                        Hr = E_FAIL;
                                        goto MyExit;
                                }

                                // Get the input rectangle
                                ComputeRectangle(m_pbiInt, m_pbiOut, m_pBasePin->m_pCaptureFilter->m_pCapDev->m_lCCZoom, m_pBasePin->m_pCaptureFilter->m_pCapDev->m_lCCPan, m_pBasePin->m_pCaptureFilter->m_pCapDev->m_lCCTilt, &rcRect, m_pBasePin->m_fFlipHorizontal, m_pBasePin->m_fFlipVertical);

                                // Scale DIB
                                ScaleDIB(m_pbiInt, m_pbyOut, m_pbiOut, pbyOutput, &rcRect, m_pBasePin->m_fFlipHorizontal, m_pBasePin->m_fFlipVertical, m_pBasePin->m_fNoImageStretch, m_pBasePin->m_dwBlackEntry);

                                // Update output size
                                *pdwOutputSize = m_pbiOut->biSizeImage;
                        }
                }
                else
                {
                        // Decompress the compressed bits to destination buffer
                        if (!m_hIC || (ICDecompress(m_hIC, 0, m_pbiIn, pbyInput, m_pbiOut, pbyOutput) != ICERR_OK))
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Decompression failed!", _fx_));
                                Hr = E_FAIL;
                                goto MyExit;
                        }

                        // Update output size
                        *pdwOutputSize = m_pbiOut->biSizeImage;
                }
        }
        else if (m_dwConversionType & CONVERSIONTYPE_ENCODE)
        {
                ASSERT(m_hIC);

                // Save the current time
                dwTimestamp = GetTickCount();

                // Compress
                fKeyFrame = fSendKeyFrame || (m_fPeriodicIFrames && (((dwTimestamp > m_dwLastIFrameTime) && ((dwTimestamp - m_dwLastIFrameTime) > MIN_IFRAME_REQUEST_INTERVAL)))) || (m_dwFrame == 0);
                dwFlags = fKeyFrame ? AVIIF_KEYFRAME : 0;
                dwMaxSizeThisFrame = (DWORD)((LONGLONG)m_pBasePin->m_lCurrentAvgTimePerFrame * (LONGLONG)m_pBasePin->m_lTargetBitrate / 80000000);

                // We need to modify the frame number so that the codec can generate
                // a valid TR. TRs use MPIs as their units. So we need to generate a
                // frame number assuming a 29.97Hz capture rate, even though we will be
                // capturing at some other rate.
                if (m_dwLastTimestamp == 0xFFFFFFFF)
                {
                        // This is the first frame
                        m_dwFrame = 0UL;

                        // Save the current time
                        m_dwLastTimestamp = dwTimestamp;
                }
                else
                {
                        // Compare the current timestamp to the last one we saved. The difference
                        // will let us normalize the frame count to 29.97Hz.
                        if (fKeyFrame)
                        {
                                m_dwFrame = 0UL;
                                m_dwLastTimestamp = dwTimestamp;
                        }
                        else
                                m_dwFrame = (dwTimestamp - m_dwLastTimestamp) * 2997 / 100000UL;
                }

                if (fKeyFrame)
                {
                        m_dwLastIFrameTime = dwTimestamp;
                }

                if (!m_hIC || (ICCompress(m_hIC, fKeyFrame ? ICCOMPRESS_KEYFRAME : 0, m_pbiOut, pbyOutput, m_pbiIn, pbyInput, &ckid, &dwFlags, m_dwFrame++, dwMaxSizeThisFrame, 10000UL - (m_dwImageQuality * 322UL), NULL, NULL) != ICERR_OK))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Compression failed!", _fx_));
                        Hr = E_FAIL;
                        goto MyExit;
                }

                // Update output size
                if (m_pbiOut->biCompression == FOURCC_M263 || m_pbiOut->biCompression == FOURCC_M261)
                {
                        PH26X_RTP_BSINFO_TRAILER pbsiT;

                        // Look for the bitstream info trailer
                        pbsiT = (PH26X_RTP_BSINFO_TRAILER)(pbyOutput + m_pbiOut->biSizeImage - sizeof(H26X_RTP_BSINFO_TRAILER));

                        // Update output size
                        *pdwOutputSize = pbsiT->dwCompressedSize;
                }
                else
                {
                        *pdwOutputSize = m_pbiOut->biSizeImage;
                }
        }
        else if (m_dwConversionType & CONVERSIONTYPE_SCALER)
        {
#ifdef USE_SOFTWARE_CAMERA_CONTROL
                if (IsSoftCamCtrlNeeded())
                {
                        if (!IsSoftCamCtrlInserted())
                                InsertSoftCamCtrl();
                }
                else
                {
                        if (IsSoftCamCtrlInserted())
                                RemoveSoftCamCtrl();
                }
#endif

                // Get the input rectangle
                ComputeRectangle(m_pbiIn, m_pbiOut, m_pBasePin->m_pCaptureFilter->m_pCapDev->m_lCCZoom, m_pBasePin->m_pCaptureFilter->m_pCapDev->m_lCCPan, m_pBasePin->m_pCaptureFilter->m_pCapDev->m_lCCTilt, &rcRect, m_pBasePin->m_fFlipHorizontal, m_pBasePin->m_fFlipVertical);

                // Scale DIB
                ScaleDIB(m_pbiIn, pbyInput, m_pbiOut, pbyOutput, &rcRect, m_pBasePin->m_fFlipHorizontal, m_pBasePin->m_fFlipVertical, m_pBasePin->m_fNoImageStretch, m_pBasePin->m_dwBlackEntry);

                // Update output size
                *pdwOutputSize = m_pbiOut->biSizeImage;
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCONVERTMETHOD
 *
 *  @mfunc HRESULT | CConverter | CloseConverter | This method closes a
 *    format converter.

 *  @rdesc This method returns NOERROR.
 ***************************************************************************/
HRESULT CConverter::CloseConverter()
{
        FX_ENTRY("CConverter::CloseConverter")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        ASSERT(m_fConvert);

        // Free buffers
        if (m_pbyOut)
                delete m_pbyOut, m_pbyOut = NULL;
        if (m_pbiIn)
                delete m_pbiIn, m_pbiIn = NULL;
        if (m_pbiOut)
                delete m_pbiOut, m_pbiOut = NULL;
        if (m_pbiInt)
                delete m_pbiInt, m_pbiInt = NULL;

        m_fConvert = FALSE;

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

        return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CCONVERTMETHOD
 *
 *  @mfunc HRESULT | CICMConverter | CloseConverter | This method closes a
 *    format converter.

 *  @rdesc This method returns NOERROR.
 ***************************************************************************/
HRESULT CICMConverter::CloseConverter()
{
        FX_ENTRY("CICMConverter::CloseConverter")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        ASSERT(m_fConvert);

        // Validate input parameters
        if (m_hIC)
        {
                // Terminate conversion process and close convertor
                if (m_dwConversionType == CONVERSIONTYPE_ENCODE)
                        ICCompressEnd(m_hIC);
                else
                        ICDecompressEnd(m_hIC);
                ICClose(m_hIC);
                m_hIC = NULL;
        }

        CConverter::CloseConverter();

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

        return NOERROR;
}

#define FX1     65536           // 1.0 in fixed point

#define Pel24(p,x)  (*(DWORD UNALIGNED *)((BYTE *)(p) + (x) * 3))
#define Pel16(p,x)  (((WORD *)(p))[(x)])
#define Pel8(p,x)   (BYTE)(((BYTE *)(p))[(x)])
#define Pel4(p,x)   (BYTE)(((x) & 1) ? (((BYTE *)(p))[(x) / 2]) & 0x0F : ((((BYTE *)(p))[(x) / 2]) & 0xF0) >> 4)
#define RGBX(rgb)   RGB(GetBValue(rgb), GetGValue(rgb), GetRValue(rgb))
#define RGBQ(r,g,b) RGB(b,g,r)
#define RGBW(r,g,b) ((WORD)((b) | ((g) << 5) | ((r) << 11)))
#define RGBQR(rgb)  ((BYTE)((rgb)>>16))
#define RGBQG(rgb)  ((BYTE)(((WORD)(rgb)) >> 8))
#define RGBQB(rgb)  ((BYTE)(rgb))
#define RGBWR(rgb)  ((BYTE)(((rgb) >> 11) & 31))
#define RGBWG(rgb)  ((BYTE)(((rgb) >> 5) & 31))
#define RGBWB(rgb)  ((BYTE)((rgb) & 31))

/****************************************************************************
 *  @doc INTERNAL CCONVERTMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | ScaleDIB | This method scales/flips
 *    an RGB bitmap.
 *
 *  @parm PBITMAPINFOHEADER | pbiSrc | Pointer to the input bitmap format.
 *
 *  @parm PBYTE | pbySrc | Pointer to the input bitmap.
 *
 *  @parm PBITMAPINFOHEADER | pbiSrc | Pointer to the output bitmap format.
 *
 *  @parm PBYTE | pbyDst | Pointer to the output bitmap.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT ScaleDIB(PBITMAPINFOHEADER pbiSrc, PBYTE pbySrc, PBITMAPINFOHEADER pbiDst, PBYTE pbyDst, PRECT     prcRect, BOOL fFlipHorizontal, BOOL fFlipVertical, BOOL fNoImageStretch, DWORD dwBlackEntry)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("ScaleDIB")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pbiSrc);
        ASSERT(pbySrc);
        ASSERT(pbiDst);
        ASSERT(pbyDst);
        if (!pbiSrc || !pbySrc || !pbiDst || !pbyDst)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }
        ASSERT(pbiSrc->biCompression == pbiDst->biCompression);
        ASSERT(pbiSrc->biCompression == BI_RGB || pbiSrc->biCompression == VIDEO_FORMAT_YVU9 || pbiSrc->biCompression == VIDEO_FORMAT_YUY2 || pbiSrc->biCompression == VIDEO_FORMAT_UYVY || pbiSrc->biCompression == VIDEO_FORMAT_I420 || pbiSrc->biCompression == VIDEO_FORMAT_IYUV);

        // Chose scaler based on format type
        switch (pbiSrc->biCompression)
        {
                case BI_RGB:
                {
                        // Use one of the RGB scalers
                        switch (pbiSrc->biBitCount)
                        {
                                case 24:
                                        ScaleDIB24(pbiSrc, pbySrc, pbiDst, pbyDst, prcRect, fFlipHorizontal, fFlipVertical, fNoImageStretch);
                                        break;
                                case 16:
                                        ScaleDIB16(pbiSrc, pbySrc, pbiDst, pbyDst, prcRect, fFlipHorizontal, fFlipVertical, fNoImageStretch);
                                        break;
                                case 8:
                                        ScaleDIB8(pbiSrc, pbySrc, pbiDst, pbyDst, prcRect, fFlipHorizontal, fFlipVertical, fNoImageStretch, dwBlackEntry);
                                        break;
                                case 4:
                                        ScaleDIB4(pbiSrc, pbySrc, pbiDst, pbyDst, prcRect, fFlipHorizontal, fFlipVertical, fNoImageStretch, dwBlackEntry);
                                        break;
                        }
                        break;
                }
                case VIDEO_FORMAT_YVU9:
                {
                        // Use the YUV planar scaler
                        ScaleDIBYUVPlanar(pbiSrc, pbySrc, pbiDst, pbyDst, 4, prcRect, fFlipHorizontal, fFlipVertical, fNoImageStretch);
                        break;
                }
                case VIDEO_FORMAT_YUY2:
                {
                        // Use the YUV packed scaler
                        ScaleDIBYUVPacked(pbiSrc, pbySrc, pbiDst, pbyDst, 0x80108010, prcRect, fFlipHorizontal, fFlipVertical, fNoImageStretch, YUY2planestart);
                        break;
                }
                case VIDEO_FORMAT_UYVY:
                {
                        // Use the YUV packed scaler
                        ScaleDIBYUVPacked(pbiSrc, pbySrc, pbiDst, pbyDst, 0x10801080, prcRect, fFlipHorizontal, fFlipVertical, fNoImageStretch, UYVYplanestart);
                        break;
                }
                case VIDEO_FORMAT_I420:
                case VIDEO_FORMAT_IYUV:
                {
                        // Use the YUV packed scaler
                        ScaleDIBYUVPlanar(pbiSrc, pbySrc, pbiDst, pbyDst, 2, prcRect, fFlipHorizontal, fFlipVertical, fNoImageStretch);
                        break;
                }
                default:
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Only support RGB, YUV packed or planar bitmaps", _fx_));
                        Hr = E_INVALIDARG;
                }
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

void InitDst8(IN OUT PBITMAPINFOHEADER pbiDst)
{
    int r,g,b;
    DWORD *pdw;

    pdw = (DWORD *)(pbiDst+1);
    pbiDst->biClrUsed = 256;
    pbiDst->biClrImportant = 256;

#define NOCOLLAPSEPALETTERGBQ(r,g,b)   (0x04000000 | RGB(b,g,r))

        // This is the palette we use when we do stretching
        for (r=0; r<10; r++)
                *pdw++ = 0UL;
    for (r=0; r<6; r++)
        for (g=0; g<6; g++)
            for (b=0; b<6; b++)
                                *pdw++ = NOCOLLAPSEPALETTERGBQ(r*255/5,g*255/5,b*255/5);
                //*pdw++ = RGBQ(r*255/5,g*255/5,b*255/5);
        for (r=0; r<30; r++)
                *pdw++ = 0UL;

    for (b=0; b<256; b++)
    {
        g_bmap[b] = b*5/255;
        g_gmap[b] = 6  * g_bmap[b];
        g_rmap[b] = 36 * g_bmap[b];
    }
}

void CConverter::InitBlack8(IN PBITMAPINFOHEADER pbiSrc)
{
        DWORD dwDistance;
        DWORD dwMinDistance = 255 + 255 + 255;
        DWORD dwNumEntries;
        DWORD *pal;

        // Look for the palette entry closest to black
        dwNumEntries = pbiSrc->biClrImportant ? pbiSrc->biClrImportant : pbiSrc->biBitCount == 8 ? 256 : 16;
        m_pBasePin->m_dwBlackEntry = 0UL;
        pal = (DWORD *)(m_pbiIn+1);
        for (DWORD dw = 0; dw < dwNumEntries; dw ++)
        {
                dwDistance = (DWORD)((RGBQUAD *)(pal+dw))->rgbBlue + (DWORD)((RGBQUAD *)(pal+dw))->rgbGreen + (DWORD)((RGBQUAD *)(pal+dw))->rgbRed;
                if (dwDistance < dwMinDistance)
                {
                        m_pBasePin->m_dwBlackEntry = dw;
                        dwMinDistance = dwDistance;
                }
        }
}

#ifndef DEBUG
#pragma optimize( "gty", on )
#endif

//int gx0y0 = 0;
//int gx0yn0 = 0;
//int gxn0y0 = 0;
//int gxfx1yfx2 = 0;
//int gall = 0;
COLORREF PASCAL MixRGB(DWORD r0, DWORD r1, DWORD r2, DWORD r3, int x, int y)
{
    int r, g, b;

    if (x == 0 && y == 0)
    {
                //gx0y0++;
        r = RGBQR(r0);
        g = RGBQG(r0);
        b = RGBQB(r0);
    }
    else if (x == 0)
    {
                //gx0yn0++;
        r = ((FX1-y) * RGBQR(r0) + y * RGBQR(r2))/FX1;
        g = ((FX1-y) * RGBQG(r0) + y * RGBQG(r2))/FX1;
        b = ((FX1-y) * RGBQB(r0) + y * RGBQB(r2))/FX1;
    }
    else if (y == 0)
    {
                //gxn0y0++;
        r = ((FX1-x) * RGBQR(r0) + x * RGBQR(r1))/FX1;
        g = ((FX1-x) * RGBQG(r0) + x * RGBQG(r1))/FX1;
        b = ((FX1-x) * RGBQB(r0) + x * RGBQB(r1))/FX1;
    }
    else if (x == FX1/2 && y == FX1/2)
    {
                //gxfx1yfx2++;
        r = (RGBQR(r0) + RGBQR(r1) + RGBQR(r2) + RGBQR(r3))/4;
        g = (RGBQG(r0) + RGBQG(r1) + RGBQG(r2) + RGBQG(r3))/4;
        b = (RGBQB(r0) + RGBQB(r1) + RGBQB(r2) + RGBQB(r3))/4;
    }
    else
    {
                //gall++;
        r =((ULONG)RGBQR(r0) * (FX1-x) / FX1 * (FX1-y) + (ULONG)RGBQR(r1) * x / FX1 * (FX1-y) +
            (ULONG)RGBQR(r2) * (FX1-x) / FX1 * y       + (ULONG)RGBQR(r3) * x / FX1 * y       )/FX1;

        g =((ULONG)RGBQG(r0) * (FX1-x) / FX1 * (FX1-y) + (ULONG)RGBQG(r1) * x / FX1 * (FX1-y) +
            (ULONG)RGBQG(r2) * (FX1-x) / FX1 * y       + (ULONG)RGBQG(r3) * x / FX1 * y       )/FX1;

        b =((ULONG)RGBQB(r0) * (FX1-x) / FX1 * (FX1-y) + (ULONG)RGBQB(r1) * x / FX1 * (FX1-y) +
            (ULONG)RGBQB(r2) * (FX1-x) / FX1 * y       + (ULONG)RGBQB(r3) * x / FX1 * y       )/FX1;
    }

    return RGB(r, g, b);
}

/****************************************************************************
 *  @doc INTERNAL CCONVERTMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | ScaleDIB24 | This method scales/flips
 *    a bitmap. For now, RGB24 only.
 *
 *  @parm PBITMAPINFOHEADER | pbiSrc | Pointer to the input bitmap format.
 *
 *  @parm PBYTE | pbySrc | Pointer to the input bitmap.
 *
 *  @parm PBITMAPINFOHEADER | pbiSrc | Pointer to the output bitmap format.
 *
 *  @parm PBYTE | pbyDst | Pointer to the output bitmap.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 *
 *  @comm On a Pentium II, 400 MHz machine, scaling a 320x240 RGB24 image
 *    to 352x288 takes 20ms. Black banding only takes 3ms.
 *
 *    Parameter validation is done in ScaleDIB.
 ***************************************************************************/
HRESULT ScaleDIB24(PBITMAPINFOHEADER pbiSrc, PBYTE pbySrc, PBITMAPINFOHEADER pbiDst, PBYTE pbyDst, PRECT prcRect, BOOL fFlipHorizontal, BOOL fFlipVertical, BOOL fNoImageStretch)
{
        HRESULT         Hr = NOERROR;
        PBYTE           pbSrc;
        PBYTE           pbDst;
        int                     dxSrc, dySrc;
        int                     dxDst, dyDst;
        int                     x0, y0, sdx, sdy;
        long            WidthBytesSrc;
        long            WidthBytesDst;
        long            lOffset;
        long            destDelta;      // it'll be +3 for normal image, -3 for FlipHorizontal (going backwards)
        DWORD           bgr0, bgr1, bgr2, bgr3;
        PBYTE           pb;
        PBYTE           pd;
        int                     x, y;
        UINT            sx, sy;
        int                     xmodfx1, ymodfx1;
        int                     FX1_xmodfx1, FX1_ymodfx1;
    long                extra;
    long                prelines, postlines, prebytes, postbytes, bytes;

        FX_ENTRY("ScaleDIB24")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        dxDst = (int)pbiDst->biWidth;
        dyDst = (int)pbiDst->biHeight;

        WidthBytesDst = DIBWIDTHBYTES(*pbiDst);
        WidthBytesSrc = DIBWIDTHBYTES(*pbiSrc);

        pbiDst->biSizeImage = WidthBytesDst * dyDst;

        if (!fNoImageStretch)
        {
                dxSrc = (int)prcRect->right - prcRect->left;
                dySrc = (int)prcRect->bottom - prcRect->top;

                pbSrc = (BYTE *)pbySrc + prcRect->left * pbiSrc->biBitCount / 8 + prcRect->top * WidthBytesSrc;

                if (fFlipHorizontal)
                {
                        destDelta = -3;
                        if (fFlipVertical)
                        {
                                lOffset = dxDst * 3 - WidthBytesDst ;
                                pbDst = (BYTE *)pbyDst + (dyDst-1) * WidthBytesDst + (dxDst-1) * 3 ;
                        }
                        else
                        {
                                lOffset = WidthBytesDst + dxDst * 3;
                                pbDst = (BYTE *)pbyDst + (dxDst-1) * 3 ;
                        }
                }
                else
                {
                        destDelta = 3;
                        if (fFlipVertical)
                        {
                                lOffset = -WidthBytesDst - dxDst * 3;
                                pbDst = (BYTE *)pbyDst + (dyDst-1) * WidthBytesDst;
                        }
                        else
                        {
                                lOffset = WidthBytesDst - dxDst * 3;
                                pbDst = (BYTE *)pbyDst;
                        }
                }

                sdx = (dxSrc-1) * FX1 / (dxDst-1);
                sdy = (dySrc-1) * FX1 / (dyDst-1);
                y0  = 0;
                x0  = 0;
                //formerly two separate branches, one for fFlipHorizontal... code merged, depending only on the values set in the 3 ifs above ...
                {
                    sy=y0,y=0;
                    pb = pbSrc + WidthBytesSrc * (sy/FX1);
                    sx=x0,x=0;
                    bgr0 = Pel24(pb,sx/FX1);
                    //bgr1 = Pel24(pb,sx/FX1+1);
                    //bgr2 = Pel24(pb+WidthBytesSrc,sx/FX1);
                    //bgr3 = Pel24(pb+WidthBytesSrc,sx/FX1+1);
                    pd = pbDst;
                    *pd++ = RGBQB(bgr0);
                    *pd++ = RGBQG(bgr0);
                    *pd++ = RGBQR(bgr0);
                    pbDst+=destDelta;
                    x++, sx+=sdx;
                    for (; x<dxDst; x++, sx+=sdx)
                    {
                        bgr0 = Pel24(pb,sx/FX1);
                        bgr1 = Pel24(pb,sx/FX1-1);      //1
                        //bgr2 = Pel24(pb+WidthBytesSrc,sx/FX1);
                        //bgr3 = Pel24(pb+WidthBytesSrc,sx/FX1+1);
                        xmodfx1 = sx%FX1;
                        pd = pbDst;
                        *pd++ = ((xmodfx1) * RGBQB(bgr0) + (FX1-xmodfx1) * RGBQB(bgr1))/FX1;
                        *pd++ = ((xmodfx1) * RGBQG(bgr0) + (FX1-xmodfx1) * RGBQG(bgr1))/FX1;
                        *pd++ = ((xmodfx1) * RGBQR(bgr0) + (FX1-xmodfx1) * RGBQR(bgr1))/FX1;
                        pbDst+=destDelta;
                        //*pbDst++ = ((FX1-xmodfx1) * RGBQB(bgr0) + xmodfx1 * RGBQB(bgr1))/FX1;
                        //*pbDst++ = ((FX1-xmodfx1) * RGBQG(bgr0) + xmodfx1 * RGBQG(bgr1))/FX1;
                        //*pbDst++ = ((FX1-xmodfx1) * RGBQR(bgr0) + xmodfx1 * RGBQR(bgr1))/FX1;
                    }
                    pbDst += lOffset; //(WidthBytesDst-dxDst*3);
                    y++,sy+=sdy;
                    for (; y<dyDst; y++,sy+=sdy)
                    {
                        pb = pbSrc + WidthBytesSrc * (sy/FX1);
                        sx=x0,x=0;
                        bgr0 = Pel24(pb,sx/FX1);
                        //bgr1 = Pel24(pb,sx/FX1-1); //1
                        bgr2 = Pel24(pb-WidthBytesSrc,sx/FX1);          //WidthBytesSrc
                        //bgr3 = Pel24(pb-WidthBytesSrc,sx/FX1-1);      //WidthBytesSrc    +1
                        ymodfx1 = sy%FX1;
                        pd = pbDst;
                        *pd++ = ((ymodfx1) * RGBQB(bgr0) + (FX1-ymodfx1) * RGBQB(bgr2))/FX1;
                        *pd++ = ((ymodfx1) * RGBQG(bgr0) + (FX1-ymodfx1) * RGBQG(bgr2))/FX1;
                        *pd++ = ((ymodfx1) * RGBQR(bgr0) + (FX1-ymodfx1) * RGBQR(bgr2))/FX1;
                        pbDst+=destDelta;
                        //*pbDst++ = ((FX1-ymodfx1) * RGBQB(bgr0) + ymodfx1 * RGBQB(bgr2))/FX1;
                        //*pbDst++ = ((FX1-ymodfx1) * RGBQG(bgr0) + ymodfx1 * RGBQG(bgr2))/FX1;
                        //*pbDst++ = ((FX1-ymodfx1) * RGBQR(bgr0) + ymodfx1 * RGBQR(bgr2))/FX1;
                        x++, sx+=sdx;
                        for (; x<dxDst; x++, sx+=sdx)
                        {
                            bgr0 = Pel24(pb,sx/FX1);
                            bgr1 = Pel24(pb,sx/FX1-1);                     //1
                            bgr2 = Pel24(pb-WidthBytesSrc,sx/FX1);         //WidthBytesSrc
                            bgr3 = Pel24(pb-WidthBytesSrc,sx/FX1-1);       //WidthBytesSrc    +1
                            xmodfx1 = sx%FX1;
                            ymodfx1 = sy%FX1;
                            FX1_xmodfx1 = FX1-xmodfx1;
                            FX1_ymodfx1 = FX1-ymodfx1;
                            pd = pbDst;
                            *pd++ =   (BYTE)(((ULONG)RGBQB(bgr0) * xmodfx1     / FX1 * ymodfx1     +
                                              (ULONG)RGBQB(bgr1) * FX1_xmodfx1 / FX1 * ymodfx1     +
                                              (ULONG)RGBQB(bgr2) * xmodfx1     / FX1 * FX1_ymodfx1 +
                                              (ULONG)RGBQB(bgr3) * FX1_xmodfx1 / FX1 * FX1_ymodfx1     )/FX1);
                            //*pbDst++ =(BYTE)(((ULONG)RGBQB(bgr0) * FX1_xmodfx1 / FX1 * FX1_ymodfx1 +
                            //                  (ULONG)RGBQB(bgr1) * xmodfx1     / FX1 * FX1_ymodfx1 +
                            //                  (ULONG)RGBQB(bgr2) * FX1_xmodfx1 / FX1 * ymodfx1     +
                            //                  (ULONG)RGBQB(bgr3) * xmodfx1     / FX1 * ymodfx1         )/FX1);

                            *pd++ =   (BYTE)(((ULONG)RGBQG(bgr0) * xmodfx1     / FX1 * ymodfx1     +
                                              (ULONG)RGBQG(bgr1) * FX1_xmodfx1 / FX1 * ymodfx1     +
                                              (ULONG)RGBQG(bgr2) * xmodfx1     / FX1 * FX1_ymodfx1 +
                                              (ULONG)RGBQG(bgr3) * FX1_xmodfx1 / FX1 * FX1_ymodfx1     )/FX1);
                            //*pbDst++ =(BYTE)(((ULONG)RGBQG(bgr0) * FX1_xmodfx1 / FX1 * FX1_ymodfx1 +
                            //                  (ULONG)RGBQG(bgr1) * xmodfx1     / FX1 * FX1_ymodfx1 +
                            //                  (ULONG)RGBQG(bgr2) * FX1_xmodfx1 / FX1 * ymodfx1     +
                            //                  (ULONG)RGBQG(bgr3) * xmodfx1     / FX1 * ymodfx1         )/FX1);
                            *pd++ =   (BYTE)(((ULONG)RGBQR(bgr0) * xmodfx1     / FX1 * ymodfx1     +
                                              (ULONG)RGBQR(bgr1) * FX1_xmodfx1 / FX1 * ymodfx1     +
                                              (ULONG)RGBQR(bgr2) * xmodfx1     / FX1 * FX1_ymodfx1 +
                                              (ULONG)RGBQR(bgr3) * FX1_xmodfx1 / FX1 * FX1_ymodfx1     )/FX1);
                            //*pbDst++ =(BYTE)(((ULONG)RGBQR(bgr0) * FX1_xmodfx1 / FX1 * FX1_ymodfx1 +
                            //                  (ULONG)RGBQR(bgr1) * xmodfx1     / FX1 * FX1_ymodfx1 +
                            //                  (ULONG)RGBQR(bgr2) * FX1_xmodfx1 / FX1 * ymodfx1     +
                            //                  (ULONG)RGBQR(bgr3) * xmodfx1     / FX1 * ymodfx1         )/FX1);
                            pbDst+=destDelta;
                        }
                    pbDst += lOffset; //(WidthBytesDst-dxDst*3);
                    }
                }
        }
        else
        {
                dxSrc = (int)pbiSrc->biWidth;
                dySrc = (int)pbiSrc->biHeight;

                pbSrc = (BYTE *)pbySrc;
                pbDst = (BYTE *)pbyDst;

        if ((dxSrc >= dxDst) && (dySrc >= dyDst))
                {
                    // starts by skipping half of the height change
                    pbSrc = pbSrc + (dySrc - dyDst) / 2 * WidthBytesSrc;

                    // extra = # of source bytes per scan line that are to be cropped
                    extra = (dxSrc - dxDst) * 3;

                    // advance pIn by half of extra to crop left most pixels
                    pbSrc += extra / 2;

                    // adjust ipitch so we can add it at the end of each scan to get to start of next scan
                    WidthBytesSrc = WidthBytesSrc - (dxSrc * 3) + extra;
                    WidthBytesDst -= dxDst * 3;      // bytes at end of each row

                    for (y = 0; y < dyDst; y++) {
                        for (x = 0; x < dxDst; x++) {
                                    *pbDst++ = *pbSrc++;   // blue
                                    *pbDst++ = *pbSrc++;   // green
                                    *pbDst++ = *pbSrc++;   // red
                        }
                        pbSrc += WidthBytesSrc;          // get to start of next row
                        pbDst += WidthBytesDst;         // get to start of next row
                    }
                }
                else
                {
                    prelines = (dyDst - dySrc) / 2;
                    postlines = dyDst - dySrc - prelines;

                    prebytes = (dxDst - dxSrc) / 2;
                    postbytes = (dxDst - dxSrc - prebytes) * 3;
                    prebytes *= 3;

                    WidthBytesSrc -= dxSrc * 3;        // bytes at end of each src row
                    bytes = dxDst * 3;
                    extra = WidthBytesDst - bytes + postbytes;                    // bytes at end of each dst row

                    // do blank lines at front of destination
                    for (y = 0; y < prelines; y++)
                        {
                        ZeroMemory (pbDst, bytes);
                        pbDst += WidthBytesDst;
                    }

                    // copy source lines with blank space at front and rear
                    for (y = 0; y < dySrc; y++)
                        {
                        ZeroMemory (pbDst, prebytes);
                        pbDst += prebytes;

                        for (x = 0; x < dxSrc; x++)
                                {
                                    *pbDst++ = *pbSrc++;   // blue
                                    *pbDst++ = *pbSrc++;   // green
                                    *pbDst++ = *pbSrc++;   // red
                        }

                        ZeroMemory (pbDst, postbytes);
                        pbSrc += WidthBytesSrc;
                        pbDst += extra;
                    }

                    // do blank lines at end of destination
                    for (y = 0; y < postlines; y++)
                        {
                        ZeroMemory (pbDst, bytes);
                        pbDst += WidthBytesDst;
                    }
                }
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCONVERTMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | ScaleDIB16 | This method scales/flips
 *    a bitmap. For now, RGB16 only.
 *
 *  @parm PBITMAPINFOHEADER | pbiSrc | Pointer to the input bitmap format.
 *
 *  @parm PBYTE | pbySrc | Pointer to the input bitmap.
 *
 *  @parm PBITMAPINFOHEADER | pbiSrc | Pointer to the output bitmap format.
 *
 *  @parm PBYTE | pbyDst | Pointer to the output bitmap.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 *
 *  @comm Parameter validation is done in ScaleDIB.
 ***************************************************************************/
HRESULT ScaleDIB16(PBITMAPINFOHEADER pbiSrc, PBYTE pbySrc, PBITMAPINFOHEADER pbiDst, PBYTE pbyDst, PRECT prcRect, BOOL fFlipHorizontal, BOOL fFlipVertical, BOOL fNoImageStretch)
{
        HRESULT         Hr = NOERROR;
        PBYTE           pbSrc;
        PWORD           pbDst;
        int                     dxSrc, dySrc;
        int                     dxDst, dyDst;
        int                     x0, y0, sdx, sdy;
        long            WidthBytesSrc;
        long            WidthBytesDst;
        long            lOffset;
        WORD            bgr0, bgr1, bgr2, bgr3;
        PBYTE           pb;
        int                     x, y;
        UINT            sx, sy;
        int                     xmodfx1, ymodfx1;
        int                     FX1_xmodfx1, FX1_ymodfx1;
    long                extra;
    long                prelines, postlines, prebytes, postbytes, bytes;

        FX_ENTRY("ScaleDIB16")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        dxDst = (int)pbiDst->biWidth;
        dyDst = (int)pbiDst->biHeight;

        WidthBytesDst = DIBWIDTHBYTES(*pbiDst);
        WidthBytesSrc = DIBWIDTHBYTES(*pbiSrc);

        pbiDst->biSizeImage = WidthBytesDst * dyDst;

        if (!fNoImageStretch)
        {
                BYTE b, g, r;

                dxSrc = (int)prcRect->right - prcRect->left;
                dySrc = (int)prcRect->bottom - prcRect->top;

                pbSrc = (BYTE *)pbySrc + prcRect->left * pbiSrc->biBitCount / 8 + prcRect->top * WidthBytesSrc;

                if (fFlipHorizontal)
                {
                        if (fFlipVertical)
                        {
                                lOffset = (dxDst * 2 - WidthBytesDst) / 2;
                                pbDst = (PWORD)(pbyDst + (dyDst-1) * WidthBytesDst + dxDst * 2 - 2);
                        }
                        else
                        {
                                lOffset = (WidthBytesDst + dxDst * 2) / 2;
                                pbDst = (PWORD)(pbyDst + dxDst * 2 - 2);
                        }
                }
                else
                {
                        if (fFlipVertical)
                        {
                                lOffset = (-WidthBytesDst - dxDst * 2) / 2;
                                pbDst = (PWORD)(pbyDst + (dyDst-1) * WidthBytesDst);
                        }
                        else
                        {
                                lOffset = (WidthBytesDst - dxDst * 2) / 2;
                                pbDst = (PWORD)pbyDst;
                        }
                }

                // TESTED (both zoom in and out)

                sdx = (dxSrc-1) * FX1 / (dxDst-1);
                sdy = (dySrc-1) * FX1 / (dyDst-1);
                y0  = 0;
                x0  = 0;

                if (fFlipHorizontal)
                {
                        sy=y0,y=0;
                    pb = pbSrc + WidthBytesSrc * (sy/FX1);
                        sx=x0,x=0;
                    bgr0 = Pel16(pb,sx/FX1);
                        r = RGBWR(bgr0);
                        g = RGBWG(bgr0);
                        b = RGBWB(bgr0);
                        *pbDst-- = RGBW(RGBWR(bgr0), RGBWG(bgr0), RGBWB(bgr0));
                        x++, sx+=sdx;
                    for (; x<dxDst; x++, sx+=sdx)
                    {
                        bgr0 = Pel16(pb,sx/FX1);
                        bgr1 = Pel16(pb,sx/FX1+1);
                                xmodfx1 = sx%FX1;
                                *pbDst-- = RGBW(((FX1-xmodfx1) * RGBWR(bgr0) + xmodfx1 * RGBWR(bgr1))/FX1, ((FX1-xmodfx1) * RGBWG(bgr0) + xmodfx1 * RGBWG(bgr1))/FX1, ((FX1-xmodfx1) * RGBWB(bgr0) + xmodfx1 * RGBWB(bgr1))/FX1);
                    }
                        pbDst += lOffset;
                        y++,sy+=sdy;
                        for (; y<dyDst; y++,sy+=sdy)
                    {
                        pb = pbSrc + WidthBytesSrc * (sy/FX1);
                                sx=x0,x=0;
                        bgr0 = Pel16(pb,sx/FX1);
                        bgr2 = Pel16(pb+WidthBytesSrc,sx/FX1);
                                ymodfx1 = sy%FX1;
                                *pbDst-- = RGBW(((FX1-ymodfx1) * RGBWR(bgr0) + ymodfx1 * RGBWR(bgr2))/FX1, ((FX1-ymodfx1) * RGBWG(bgr0) + ymodfx1 * RGBWG(bgr2))/FX1, ((FX1-ymodfx1) * RGBWB(bgr0) + ymodfx1 * RGBWB(bgr2))/FX1);
                                x++, sx+=sdx;
                        for (; x<dxDst; x++, sx+=sdx)
                        {
                            bgr0 = Pel16(pb,sx/FX1);
                            bgr1 = Pel16(pb,sx/FX1+1);
                            bgr2 = Pel16(pb+WidthBytesSrc,sx/FX1);
                            bgr3 = Pel16(pb+WidthBytesSrc,sx/FX1+1);
                                        xmodfx1 = sx%FX1;
                                        ymodfx1 = sy%FX1;
                                        FX1_xmodfx1 = FX1-xmodfx1;
                                        FX1_ymodfx1 = FX1-ymodfx1;
                                        *pbDst-- = RGBW((BYTE)(((ULONG)RGBWR(bgr0) * FX1_xmodfx1 / FX1 * FX1_ymodfx1 + (ULONG)RGBWR(bgr1) * xmodfx1 / FX1 * FX1_ymodfx1 + (ULONG)RGBWR(bgr2) * FX1_xmodfx1 / FX1 * ymodfx1       + (ULONG)RGBWR(bgr3) * xmodfx1 / FX1 * ymodfx1       )/FX1), (BYTE)(((ULONG)RGBWG(bgr0) * FX1_xmodfx1 / FX1 * FX1_ymodfx1 + (ULONG)RGBWG(bgr1) * xmodfx1 / FX1 * FX1_ymodfx1 + (ULONG)RGBWG(bgr2) * FX1_xmodfx1 / FX1 * ymodfx1       + (ULONG)RGBWG(bgr3) * xmodfx1 / FX1 * ymodfx1       )/FX1), (BYTE)(((ULONG)RGBWB(bgr0) * FX1_xmodfx1 / FX1 * FX1_ymodfx1 + (ULONG)RGBWB(bgr1) * xmodfx1 / FX1 * FX1_ymodfx1 + (ULONG)RGBWB(bgr2) * FX1_xmodfx1 / FX1 * ymodfx1       + (ULONG)RGBWB(bgr3) * xmodfx1 / FX1 * ymodfx1       )/FX1));
                        }
                                pbDst += lOffset;
                        }
                }
                else
                {
                        sy=y0,y=0;
                    pb = pbSrc + WidthBytesSrc * (sy/FX1);
                        sx=x0,x=0;
                    bgr0 = Pel16(pb,sx/FX1);
                        r = RGBWR(bgr0);
                        g = RGBWG(bgr0);
                        b = RGBWB(bgr0);
                        *pbDst++ = RGBW(RGBWR(bgr0), RGBWG(bgr0), RGBWB(bgr0));
                        x++, sx+=sdx;
                    for (; x<dxDst; x++, sx+=sdx)
                    {
                        bgr0 = Pel16(pb,sx/FX1);
                        bgr1 = Pel16(pb,sx/FX1+1);
                                xmodfx1 = sx%FX1;
                                *pbDst++ = RGBW(((FX1-xmodfx1) * RGBWR(bgr0) + xmodfx1 * RGBWR(bgr1))/FX1, ((FX1-xmodfx1) * RGBWG(bgr0) + xmodfx1 * RGBWG(bgr1))/FX1, ((FX1-xmodfx1) * RGBWB(bgr0) + xmodfx1 * RGBWB(bgr1))/FX1);
                    }
                        pbDst += lOffset;
                        y++,sy+=sdy;
                        for (; y<dyDst; y++,sy+=sdy)
                    {
                        pb = pbSrc + WidthBytesSrc * (sy/FX1);
                                sx=x0,x=0;
                        bgr0 = Pel16(pb,sx/FX1);
                        bgr2 = Pel16(pb+WidthBytesSrc,sx/FX1);
                                ymodfx1 = sy%FX1;
                                *pbDst++ = RGBW(((FX1-ymodfx1) * RGBWR(bgr0) + ymodfx1 * RGBWR(bgr2))/FX1, ((FX1-ymodfx1) * RGBWG(bgr0) + ymodfx1 * RGBWG(bgr2))/FX1, ((FX1-ymodfx1) * RGBWB(bgr0) + ymodfx1 * RGBWB(bgr2))/FX1);
                                x++, sx+=sdx;
                        for (; x<dxDst; x++, sx+=sdx)
                        {
                            bgr0 = Pel16(pb,sx/FX1);
                            bgr1 = Pel16(pb,sx/FX1+1);
                            bgr2 = Pel16(pb+WidthBytesSrc,sx/FX1);
                            bgr3 = Pel16(pb+WidthBytesSrc,sx/FX1+1);
                                        xmodfx1 = sx%FX1;
                                        ymodfx1 = sy%FX1;
                                        FX1_xmodfx1 = FX1-xmodfx1;
                                        FX1_ymodfx1 = FX1-ymodfx1;
                                        *pbDst++ = RGBW((BYTE)(((ULONG)RGBWR(bgr0) * FX1_xmodfx1 / FX1 * FX1_ymodfx1 + (ULONG)RGBWR(bgr1) * xmodfx1 / FX1 * FX1_ymodfx1 + (ULONG)RGBWR(bgr2) * FX1_xmodfx1 / FX1 * ymodfx1       + (ULONG)RGBWR(bgr3) * xmodfx1 / FX1 * ymodfx1       )/FX1), (BYTE)(((ULONG)RGBWG(bgr0) * FX1_xmodfx1 / FX1 * FX1_ymodfx1 + (ULONG)RGBWG(bgr1) * xmodfx1 / FX1 * FX1_ymodfx1 + (ULONG)RGBWG(bgr2) * FX1_xmodfx1 / FX1 * ymodfx1       + (ULONG)RGBWG(bgr3) * xmodfx1 / FX1 * ymodfx1       )/FX1), (BYTE)(((ULONG)RGBWB(bgr0) * FX1_xmodfx1 / FX1 * FX1_ymodfx1 + (ULONG)RGBWB(bgr1) * xmodfx1 / FX1 * FX1_ymodfx1 + (ULONG)RGBWB(bgr2) * FX1_xmodfx1 / FX1 * ymodfx1       + (ULONG)RGBWB(bgr3) * xmodfx1 / FX1 * ymodfx1       )/FX1));
                        }
                                pbDst += lOffset;
                        }
                }
        }
        else
        {
                dxSrc = (int)pbiSrc->biWidth;
                dySrc = (int)pbiSrc->biHeight;

                pbSrc = (BYTE *)pbySrc;
                pbDst = (WORD *)pbyDst;

        if ((dxSrc >= dxDst) && (dySrc >= dyDst))
                {
                        // TESTED (zoom out)

                    // starts by skipping half of the height change
                    pbSrc = pbSrc + (dySrc - dyDst) / 2 * WidthBytesSrc;

                    // extra = # of source bytes per scan line that are to be cropped
                    extra = (dxSrc - dxDst) * 2;

                    // advance pIn by half of extra to crop left most pixels
                    pbSrc += extra / 2;

                    // adjust ipitch so we can add it at the end of each scan to get to start of next scan
                    WidthBytesSrc = WidthBytesSrc - (dxSrc * 2) + extra;
                    WidthBytesDst -= dxDst * 2;      // bytes at end of each row

                    for (y = 0; y < dyDst; y++) {
                        for (x = 0; x < dxDst; x++) {
                                    *pbDst++ = *pbSrc++;   // blue - green
                                    *pbDst++ = *pbSrc++;   // green     - red
                        }
                        pbSrc += WidthBytesSrc;          // get to start of next row
                        pbDst += WidthBytesDst;         // get to start of next row
                    }
                }
                else
                {
                        // TESTED (zoom in)

                    prelines = (dyDst - dySrc) / 2;
                    postlines = dyDst - dySrc - prelines;

                    prebytes = (dxDst - dxSrc) / 2;
                    postbytes = (dxDst - dxSrc - prebytes) * 2;
                    prebytes *= 2;

                    WidthBytesSrc -= dxSrc * 2;        // bytes at end of each src row
                    bytes = dxDst * 2;
                    extra = WidthBytesDst - bytes + postbytes;                    // bytes at end of each dst row

                    // do blank lines at front of destination
                    for (y = 0; y < prelines; y++)
                        {
                        ZeroMemory (pbDst, bytes);
                        pbDst += WidthBytesDst;
                    }

                    // copy source lines with blank space at front and rear
                    for (y = 0; y < dySrc; y++)
                        {
                        ZeroMemory (pbDst, prebytes);
                        pbDst += prebytes;

                        for (x = 0; x < dxSrc; x++)
                                {
                                    *pbDst++ = *pbSrc++;   // blue - green
                                    *pbDst++ = *pbSrc++;   // green     - red
                        }

                        ZeroMemory (pbDst, postbytes);
                        pbSrc += WidthBytesSrc;
                        pbDst += extra;
                    }

                    // do blank lines at end of destination
                    for (y = 0; y < postlines; y++)
                        {
                        ZeroMemory (pbDst, bytes);
                        pbDst += WidthBytesDst;
                    }
                }
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCONVERTMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | ScaleDIB8 | This method scales/flips
 *    a bitmap. For now, RGB8 only.
 *
 *  @parm PBITMAPINFOHEADER | pbiSrc | Pointer to the input bitmap format.
 *
 *  @parm PBYTE | pbySrc | Pointer to the input bitmap.
 *
 *  @parm PBITMAPINFOHEADER | pbiSrc | Pointer to the output bitmap format.
 *
 *  @parm PBYTE | pbyDst | Pointer to the output bitmap.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 *
 *  @comm Parameter validation is done in ScaleDIB.
 ***************************************************************************/
HRESULT ScaleDIB8(PBITMAPINFOHEADER pbiSrc, PBYTE pbySrc, PBITMAPINFOHEADER pbiDst, PBYTE pbyDst, PRECT prcRect, BOOL fFlipHorizontal, BOOL fFlipVertical, BOOL fNoImageStretch, DWORD dwBlackEntry)
{
        HRESULT         Hr = NOERROR;
        PBYTE           pbSrc;
        PBYTE           pbDst;
    DWORD               *pal;
        COLORREF        rgb;
        int                     dxSrc, dySrc;
        int                     dxDst, dyDst;
        int                     x0, y0, sdx, sdy;
        long            WidthBytesSrc;
        long            WidthBytesDst;
        BYTE            b0, b1, b2, b3;
        PBYTE           pb;
        int                     x, y;
        UINT            sx, sy;
        int                     xmodfx1, ymodfx1;
    long                extra;
    long                prelines, postlines, prebytes, postbytes, bytes;

        FX_ENTRY("ScaleDIB8")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        dxSrc = (int)pbiSrc->biWidth;
        dySrc = (int)pbiSrc->biHeight;

        dxDst = (int)pbiDst->biWidth;
        dyDst = (int)pbiDst->biHeight;

        WidthBytesDst = DIBWIDTHBYTES(*pbiDst);
        WidthBytesSrc = DIBWIDTHBYTES(*pbiSrc);

        pbiDst->biSizeImage = WidthBytesDst * dyDst;

        pbSrc = (BYTE *)pbySrc;
        pbDst = (BYTE *)pbyDst;

    pal = (DWORD *)(pbiSrc+1);

        if (!fNoImageStretch)
        {
                // TESTED (both zoom in and out)

            if (dxSrc == dxDst*2 && dySrc == dyDst*2)
            {
                sdx = FX1*2;
                sdy = FX1*2;
                y0  = FX1/2;
                x0  = FX1/2;
            }
            else
            {
                sdx = (dxSrc-1) * FX1 / (dxDst-1);
                sdy = (dySrc-1) * FX1 / (dyDst-1);
                y0  = 0;
                x0  = 0;
            }

            for (sy=y0,y=0; y<dyDst; y++,sy+=sdy)
            {
                pb = pbSrc + WidthBytesSrc * (sy/FX1);
                for (sx=x0, x=0; x<dxDst; x++, sx+=sdx)
                {
                    b0 = Pel8(pb, sx/FX1);
                    b1 = Pel8(pb, sx/FX1+1);
                    b2 = Pel8(pb+WidthBytesSrc, sx/FX1);
                    b3 = Pel8(pb+WidthBytesSrc, sx/FX1+1);

                                xmodfx1 = sx%FX1;
                                ymodfx1 = sy%FX1;

                            if ((b0==b1 && b1==b2 && b2==b3) || (xmodfx1==0 && ymodfx1==0))
                                rgb = RGBX(pal[b0]);
                            else
                                rgb = MixRGB(pal[b0], pal[b1], pal[b2], pal[b3], xmodfx1, ymodfx1);

                                pbDst[x] = (BYTE)(g_rmap[GetRValue(rgb)] + g_gmap[GetGValue(rgb)] + g_bmap[GetBValue(rgb)] + 10);
                                //pbDst[x] = (BYTE)(rmap[GetRValue(rgb)] + gmap[GetGValue(rgb)] + bmap[GetBValue(rgb)]);
                }
                pbDst += WidthBytesDst;
            }
        }
        else
        {
        if ((dxSrc >= dxDst) && (dySrc >= dyDst))
                {
                        // TESTED (zoom out)

                    // starts by skipping half of the height change
                    pbSrc = pbSrc + (dySrc - dyDst) / 2 * WidthBytesSrc;

                    // extra = # of source bytes per scan line that are to be cropped
                    extra = dxSrc - dxDst;

                    // advance pIn by half of extra to crop left most pixels
                    pbSrc += extra / 2;

                    // adjust ipitch so we can add it at the end of each scan to get to start of next scan
                    WidthBytesSrc = WidthBytesSrc - dxSrc + extra;
                    WidthBytesDst -= dxDst;      // bytes at end of each row

                    for (y = 0; y < dyDst; y++) {
                        for (x = 0; x < dxDst; x++) {
                                    *pbDst++ = *pbSrc++;
                        }
                        pbSrc += WidthBytesSrc;          // get to start of next row
                        pbDst += WidthBytesDst;         // get to start of next row
                    }
                }
                else
                {
                        // TESTED (zoom in)

                    prelines = (dyDst - dySrc) / 2;
                    postlines = dyDst - dySrc - prelines;

                    prebytes = (dxDst - dxSrc) / 2;
                    postbytes = dxDst - dxSrc - prebytes;

                    WidthBytesSrc -= dxSrc;        // bytes at end of each src row
                    bytes = dxDst;
                    extra = WidthBytesDst - bytes + postbytes;                    // bytes at end of each dst row

                    // do blank lines at front of destination
                    for (y = 0; y < prelines; y++)
                        {
                        FillMemory (pbDst, bytes, (BYTE)dwBlackEntry);
                        pbDst += WidthBytesDst;
                    }

                    // copy source lines with blank space at front and rear
                    for (y = 0; y < dySrc; y++)
                        {
                        FillMemory (pbDst, prebytes, (BYTE)dwBlackEntry);
                        pbDst += prebytes;

                        for (x = 0; x < dxSrc; x++)
                                {
                                    *pbDst++ = *pbSrc++;
                        }

                        FillMemory (pbDst, postbytes, (BYTE)dwBlackEntry);
                        pbSrc += WidthBytesSrc;
                        pbDst += extra;
                    }

                    // do blank lines at end of destination
                    for (y = 0; y < postlines; y++)
                        {
                        FillMemory (pbDst, bytes, (BYTE)dwBlackEntry);
                        pbDst += WidthBytesDst;
                    }
                }
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCONVERTMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | ScaleDIB4 | This method scales/flips
 *    a bitmap. For now, RGB4 only.
 *
 *  @parm PBITMAPINFOHEADER | pbiSrc | Pointer to the input bitmap format.
 *
 *  @parm PBYTE | pbySrc | Pointer to the input bitmap.
 *
 *  @parm PBITMAPINFOHEADER | pbiSrc | Pointer to the output bitmap format.
 *
 *  @parm PBYTE | pbyDst | Pointer to the output bitmap.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 *
 *  @comm Parameter validation is done in ScaleDIB.
 ***************************************************************************/
HRESULT ScaleDIB4(PBITMAPINFOHEADER pbiSrc, PBYTE pbySrc, PBITMAPINFOHEADER pbiDst, PBYTE pbyDst, PRECT prcRect, BOOL fFlipHorizontal, BOOL fFlipVertical, BOOL fNoImageStretch, DWORD dwBlackEntry)
{
        HRESULT         Hr = NOERROR;
        PBYTE           pbSrc;
        PBYTE           pbDst;
    DWORD               *pal;
        COLORREF        rgb;
        int                     dxSrc, dySrc;
        int                     dxDst, dyDst;
        int                     x0, y0, sdx, sdy;
        long            WidthBytesSrc;
        long            WidthBytesDst;
        long            lOffset;
        BYTE            b0, b1, b2, b3;
        PBYTE           pb;
        int                     x, y;
        UINT            sx, sy;
        int                     xmodfx1, ymodfx1;
    long                extra;
    long                prelines, postlines, prebytes, postbytes, bytes;

        FX_ENTRY("ScaleDIB4")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        dxDst = (int)pbiDst->biWidth;
        dyDst = (int)pbiDst->biHeight;

        WidthBytesDst = DIBWIDTHBYTES(*pbiDst);
        WidthBytesSrc = DIBWIDTHBYTES(*pbiSrc);

        pbiDst->biSizeImage = WidthBytesDst * dyDst;

    pal = (DWORD *)(pbiSrc+1);

        if (!fNoImageStretch)
        {
                dxSrc = (int)prcRect->right - prcRect->left;
                dySrc = (int)prcRect->bottom - prcRect->top;

                pbSrc = (BYTE *)pbySrc + prcRect->left * pbiSrc->biBitCount / 8 + prcRect->top * WidthBytesSrc;

                if (fFlipHorizontal)
                {
                        if (fFlipVertical)
                        {
                                lOffset = dxDst - WidthBytesDst ;
                                pbDst = (BYTE *)pbyDst + (dyDst-1) * WidthBytesDst + dxDst - 1;
                        }
                        else
                        {
                                lOffset = WidthBytesDst + dxDst;
                                pbDst = (BYTE *)pbyDst + dxDst - 1;
                        }
                }
                else
                {
                        if (fFlipVertical)
                        {
                                lOffset = -WidthBytesDst - dxDst;
                                pbDst = (BYTE *)pbyDst + (dyDst-1) * WidthBytesDst;
                        }
                        else
                        {
                                lOffset = WidthBytesDst - dxDst;
                                pbDst = (BYTE *)pbyDst;
                        }
                }

                // TESTED (both zoom in and out)

            if (dxSrc == dxDst*2 && dySrc == dyDst*2)
            {
                sdx = FX1*2;
                sdy = FX1*2;
                y0  = FX1/2;
                x0  = FX1/2;
            }
            else
            {
                sdx = (dxSrc-1) * FX1 / (dxDst-1);
                sdy = (dySrc-1) * FX1 / (dyDst-1);
                y0  = 0;
                x0  = 0;
            }

                if (fFlipHorizontal)
                {
                    for (sy=y0,y=0; y<dyDst; y++,sy+=sdy)
                    {
                        pb = pbSrc + WidthBytesSrc * (sy/FX1);
                        for (sx=x0, x=0; x<dxDst; x++, sx+=sdx)
                        {
                            b0 = Pel4(pb, sx/FX1);
                            b1 = Pel4(pb, sx/FX1+1);
                            b2 = Pel4(pb+WidthBytesSrc, sx/FX1);
                            b3 = Pel4(pb+WidthBytesSrc, sx/FX1+1);

                                        xmodfx1 = sx%FX1;
                                        ymodfx1 = sy%FX1;

                                    if ((b0==b1 && b1==b2 && b2==b3) || (xmodfx1==0 && ymodfx1==0))
                                        rgb = RGBX(pal[b0]);
                                    else
                                        rgb = MixRGB(pal[b0], pal[b1], pal[b2], pal[b3], xmodfx1, ymodfx1);

                                        *pbDst-- = (BYTE)(g_rmap[GetRValue(rgb)] + g_gmap[GetGValue(rgb)] + g_bmap[GetBValue(rgb)] + 10);
                        }
                        pbDst += lOffset;
                    }
                }
                else
                {
                    for (sy=y0,y=0; y<dyDst; y++,sy+=sdy)
                    {
                        pb = pbSrc + WidthBytesSrc * (sy/FX1);
                        for (sx=x0, x=0; x<dxDst; x++, sx+=sdx)
                        {
                            b0 = Pel4(pb, sx/FX1);
                            b1 = Pel4(pb, sx/FX1+1);
                            b2 = Pel4(pb+WidthBytesSrc, sx/FX1);
                            b3 = Pel4(pb+WidthBytesSrc, sx/FX1+1);

                                        xmodfx1 = sx%FX1;
                                        ymodfx1 = sy%FX1;

                                    if ((b0==b1 && b1==b2 && b2==b3) || (xmodfx1==0 && ymodfx1==0))
                                        rgb = RGBX(pal[b0]);
                                    else
                                        rgb = MixRGB(pal[b0], pal[b1], pal[b2], pal[b3], xmodfx1, ymodfx1);

                                        *pbDst++ = (BYTE)(g_rmap[GetRValue(rgb)] + g_gmap[GetGValue(rgb)] + g_bmap[GetBValue(rgb)] + 10);
                        }
                        pbDst += lOffset;
                    }
                }
        }
        else
        {
                dxSrc = (int)pbiSrc->biWidth;
                dySrc = (int)pbiSrc->biHeight;

                pbSrc = (BYTE *)pbySrc;
                pbDst = (BYTE *)pbyDst;

        if ((dxSrc >= dxDst) && (dySrc >= dyDst))
                {
                        // TESTED (zoom out)

                    // starts by skipping half of the height change
                    pbSrc = pbSrc + (dySrc - dyDst) / 2 * WidthBytesSrc;

                    // extra = # of source bytes per scan line that are to be cropped
                    extra = (dxSrc - dxDst) / 2;

                    // advance pIn by half of extra to crop left most pixels
                    pbSrc += extra / 2 ;

                    // adjust ipitch so we can add it at the end of each scan to get to start of next scan
                    WidthBytesSrc = WidthBytesSrc - dxSrc / 2 + extra;
                    WidthBytesDst -= dxDst;      // bytes at end of each row

                    for (y = 0; y < dyDst; y++) {
                        for (x = 0; x < dxDst / 2; x++) {
                                    *pbDst++ = (*pbSrc & 0xF0) >> 4;
                                    *pbDst++ = *pbSrc & 0x0F;
                                        pbSrc++;
                        }
                        pbSrc += WidthBytesSrc;          // get to start of next row
                        pbDst += WidthBytesDst;         // get to start of next row
                    }
                }
                else
                {
                        // TESTED (zoom in)

                    prelines = (dyDst - dySrc) / 2;
                    postlines = dyDst - dySrc - prelines;

                    prebytes = (dxDst - dxSrc) / 2;
                    postbytes = dxDst - dxSrc - prebytes;

                    WidthBytesSrc -= dxSrc / 2;        // bytes at end of each src row
                    bytes = dxDst;
                    extra = WidthBytesDst - bytes + postbytes;                    // bytes at end of each dst row

                    // do blank lines at front of destination
                    for (y = 0; y < prelines; y++)
                        {
                        FillMemory (pbDst, bytes, (BYTE)dwBlackEntry);
                        pbDst += WidthBytesDst;
                    }

                    // copy source lines with blank space at front and rear
                    for (y = 0; y < dySrc; y++)
                        {
                        FillMemory (pbDst, prebytes, (BYTE)dwBlackEntry);
                        pbDst += prebytes;

                        for (x = 0; x < dxSrc / 2; x++)
                                {
                                    *pbDst++ = (*pbSrc & 0xF0) >> 4;
                                    *pbDst++ = *pbSrc & 0x0F;
                                        pbSrc++;
                        }

                        FillMemory (pbDst, postbytes, (BYTE)dwBlackEntry);
                        pbSrc += WidthBytesSrc;
                        pbDst += extra;
                    }

                    // do blank lines at end of destination
                    for (y = 0; y < postlines; y++)
                        {
                        FillMemory (pbDst, bytes, (BYTE)dwBlackEntry);
                        pbDst += WidthBytesDst;
                    }
                }
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

void ScalePlane(IN PBYTE pbySrc, IN PBYTE pbyDst, IN int WidthBytesSrc, IN int dxDst, IN int dyDst, IN long WidthBytesDst, IN LPRECT prcRect, IN BOOL fFlipHorizontal, IN BOOL fFlipVertical)
{
        PBYTE           pbSrc;
        PBYTE           pbDst;
        int                     dxSrc, dySrc;
        int                     x0, y0, sdx, sdy;
        long            lOffset;
        BYTE            by0, by1, by2, by3;
        int                     xmodfx1, ymodfx1;
        int                     FX1_xmodfx1, FX1_ymodfx1;
        PBYTE           pb;
        int                     x, y;
        UINT            sx, sy;

        FX_ENTRY("ScalePlane")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        dxSrc = (int)prcRect->right - prcRect->left;
        dySrc = (int)prcRect->bottom - prcRect->top;

        pbSrc = (BYTE *)pbySrc + prcRect->left + prcRect->top * WidthBytesSrc;

        if (fFlipHorizontal)
        {
                if (fFlipVertical)
                {
                        lOffset = dxDst - WidthBytesDst;
                        pbDst = (BYTE *)pbyDst + (dyDst-1) * WidthBytesDst + dxDst - 1;
                }
                else
                {
                        lOffset = WidthBytesDst + dxDst;
                        pbDst = (BYTE *)pbyDst + dxDst - 1;
                }
        }
        else
        {
                if (fFlipVertical)
                {
                        lOffset = -WidthBytesDst - dxDst;
                        pbDst = (BYTE *)pbyDst + (dyDst-1) * WidthBytesDst;
                }
                else
                {
                        lOffset = WidthBytesDst - dxDst;
                        pbDst = (BYTE *)pbyDst;
                }
        }

        if (dxSrc == dxDst*2 && dySrc == dyDst*2)
        {
                sdx = FX1*2;
                sdy = FX1*2;
                y0  = FX1/2;
                x0  = FX1/2;
        }
        else
        {
                sdx = (dxSrc-1) * FX1 / (dxDst-1);
                sdy = (dySrc-1) * FX1 / (dyDst-1);
                y0  = 0;
                x0  = 0;
        }

        if (fFlipHorizontal)
        {
                sy=y0,y=0;
            pb = pbSrc + WidthBytesSrc * (sy/FX1);
                sx=x0,x=0;
                *pbDst-- = *(pb + sx/FX1);
                x++, sx+=sdx;
            for (; x<dxDst; x++, sx+=sdx)
            {
                        by0 = *(pb + sx/FX1);
                        by1 = *(pb + sx/FX1 + 1);
                        xmodfx1 = sx%FX1;
                        *pbDst-- = (BYTE)(((FX1-xmodfx1) * (ULONG)by0 + xmodfx1 * (ULONG)by1)/FX1);
            }
                pbDst += lOffset;
                y++,sy+=sdy;
                for (; y<dyDst; y++,sy+=sdy)
            {
                pb = pbSrc + WidthBytesSrc * (sy/FX1);
                        sx=x0,x=0;
                        by0 = *(pb + sx/FX1);
                        by2 = *(pb + WidthBytesSrc + sx/FX1);
                        ymodfx1 = sy%FX1;
                    *pbDst-- = (BYTE)(((FX1-ymodfx1) * (ULONG)by0 + ymodfx1 * (ULONG)by2)/FX1);
                        x++, sx+=sdx;
                for (; x<dxDst; x++, sx+=sdx)
                {
                                by0 = *(pb + sx/FX1);
                                by1 = *(pb + sx/FX1 + 1);
                                by2 = *(pb + WidthBytesSrc + sx/FX1);
                                by3 = *(pb + WidthBytesSrc + sx/FX1 + 1);
                                xmodfx1 = sx%FX1;
                                ymodfx1 = sy%FX1;
                                FX1_xmodfx1 = FX1-xmodfx1;
                                FX1_ymodfx1 = FX1-ymodfx1;
                                *pbDst-- =(BYTE)(((ULONG)by0 * FX1_xmodfx1 / FX1 * FX1_ymodfx1 + (ULONG)by1 * xmodfx1 / FX1 * FX1_ymodfx1 +
                            (ULONG)by2 * FX1_xmodfx1 / FX1 * ymodfx1       + (ULONG)by3 * xmodfx1 / FX1 * ymodfx1       )/FX1);
                }
                        pbDst += lOffset;
                }
        }
        else
        {
                sy=y0,y=0;
            pb = pbSrc + WidthBytesSrc * (sy/FX1);
                sx=x0,x=0;
                *pbDst++ = *(pb + sx/FX1);
                x++, sx+=sdx;
            for (; x<dxDst; x++, sx+=sdx)
            {
                        by0 = *(pb + sx/FX1);
                        by1 = *(pb + sx/FX1 + 1);
                        xmodfx1 = sx%FX1;
                        *pbDst++ = (BYTE)(((FX1-xmodfx1) * (ULONG)by0 + xmodfx1 * (ULONG)by1)/FX1);
            }
                pbDst += lOffset;
                y++,sy+=sdy;
                for (; y<dyDst; y++,sy+=sdy)
            {
                pb = pbSrc + WidthBytesSrc * (sy/FX1);
                        sx=x0,x=0;
                        by0 = *(pb + sx/FX1);
                        by2 = *(pb + WidthBytesSrc + sx/FX1);
                        ymodfx1 = sy%FX1;
                    *pbDst++ = (BYTE)(((FX1-ymodfx1) * (ULONG)by0 + ymodfx1 * (ULONG)by2)/FX1);
                        x++, sx+=sdx;
                for (; x<dxDst; x++, sx+=sdx)
                {
                                by0 = *(pb + sx/FX1);
                                by1 = *(pb + sx/FX1 + 1);
                                by2 = *(pb + WidthBytesSrc + sx/FX1);
                                by3 = *(pb + WidthBytesSrc + sx/FX1 + 1);
                                xmodfx1 = sx%FX1;
                                ymodfx1 = sy%FX1;
                                FX1_xmodfx1 = FX1-xmodfx1;
                                FX1_ymodfx1 = FX1-ymodfx1;
                                *pbDst++ =(BYTE)(((ULONG)by0 * FX1_xmodfx1 / FX1 * FX1_ymodfx1 + (ULONG)by1 * xmodfx1 / FX1 * FX1_ymodfx1 +
                            (ULONG)by2 * FX1_xmodfx1 / FX1 * ymodfx1       + (ULONG)by3 * xmodfx1 / FX1 * ymodfx1       )/FX1);
                }
                        pbDst += lOffset;
                }
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}
void ScalePackedPlane(IN PBYTE pbySrc, IN PBYTE pbyDst, IN int dxDst, IN int dyDst, IN long WidthBytesSrc, IN long WidthBytesDst, IN LPRECT prcRect, IN BOOL fFlipHorizontal, IN BOOL fFlipVertical, IN DWORD dwDelta)
{
        PBYTE           pbSrc;
        PBYTE           pbDst;
        int                     dxSrc, dySrc;
        int                     x0, y0, sdx, sdy;
        long            lOffset;
        BYTE            by0, by1, by2, by3;
        int                     xmodfx1, ymodfx1;
        int                     FX1_xmodfx1, FX1_ymodfx1;
        PBYTE           pb;
        int                     x, y;
        UINT            sx, sy;
        long            lDestDelta;    // destination delta; could be negative if H Flipping is requested


        FX_ENTRY("ScalePackedPlane")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        dxSrc = (int)prcRect->right - prcRect->left;
        dySrc = (int)prcRect->bottom - prcRect->top;

        pbSrc = (BYTE *)pbySrc + prcRect->left * dwDelta + prcRect->top * WidthBytesSrc * dwDelta;

        if (fFlipHorizontal)
        {
                lDestDelta = -(long)dwDelta;
                if (fFlipVertical)
                {
                        lOffset = (dxDst - WidthBytesDst) * dwDelta;
                        pbDst = (BYTE *)pbyDst + (dyDst-1) * WidthBytesDst * dwDelta + (dxDst - 1) * dwDelta;
                }
                else
                {
                        lOffset = (WidthBytesDst + dxDst) * dwDelta;
                        pbDst = (BYTE *)pbyDst + (dxDst - 1) * dwDelta;
                }
        }
        else
        {
                lDestDelta = (long)dwDelta ;
                if (fFlipVertical)
                {
                        lOffset = (-WidthBytesDst - dxDst) * dwDelta;
                        pbDst = (BYTE *)pbyDst + (dyDst-1) * WidthBytesDst * dwDelta;
                }
                else
                {
                        lOffset = (WidthBytesDst - dxDst) * dwDelta;
                        pbDst = (BYTE *)pbyDst;
                }
        }

        if (dxSrc == dxDst*2 && dySrc == dyDst*2)
        {
                sdx = FX1*2;
                sdy = FX1*2;
                y0  = FX1/2;
                x0  = FX1/2;
        }
        else
        {
                sdx = (dxSrc-1) * FX1 / (dxDst-1);
                sdy = (dySrc-1) * FX1 / (dyDst-1);
                y0  = 0;
                x0  = 0;
        }

        // start scaling and/or flipping ...
        D(1) dprintf("WidthBytesSrc, WidthBytesDst %d,%d\n",WidthBytesSrc, WidthBytesDst);
        D(1) dprintf("line step: %d coln step: %d\n", sdy, sdx);

        for ( sy=y0,y=0; sy<FX1 && y<dyDst; y++,sy+=sdy )       // double test condition but for a limited number of lines
        {

            D(1) dprintf("    line : %d\n", sy/FX1);
            pb = pbSrc + WidthBytesSrc * (sy/FX1) * dwDelta;

            for ( sx=x0,x=0; sx<FX1 && x<dxDst; x++, sx+=sdx )       // double test condition but for a limited number of pixels
            {
                D(1) dprintf("    coln : %d\n", sx/FX1);
                D(1) dprintf(" .......    by* %5d\n", sx/FX1);
                *pbDst = *(pb + sx/FX1 * dwDelta);
                pbDst += lDestDelta;
            }
            for (          ;           x<dxDst; x++, sx+=sdx )
            {
                D(1) dprintf("    coln : %d\n", sx/FX1);
                D(1) dprintf("by1 %5d   by0 %5d\n", (sx/FX1 - 1), sx/FX1);
                ASSERT(pb + (sx/FX1 - 1) * dwDelta >= pbSrc);
                by0 = *(pb + sx/FX1 * dwDelta);
                by1 = *(pb + (sx/FX1 - 1) * dwDelta); //1
                xmodfx1 = sx%FX1;
                *pbDst = (BYTE)((xmodfx1 * (ULONG)by0 + (FX1-xmodfx1) * (ULONG)by1)/FX1);
                pbDst += lDestDelta;
            }
            pbDst += lOffset;
        }


        for (; y<dyDst; y++,sy+=sdy)
        {
                D(1) dprintf("sy : %5d line ===> %5d [ %d ]\n", sy, sy/FX1, WidthBytesSrc);
                pb = pbSrc + WidthBytesSrc * (sy/FX1) * dwDelta;
                for ( sx=x0,x=0; sx<FX1 && x<dxDst; x++, sx+=sdx )      // double test condition -- limited number of pixels
                {
                    D(1) dprintf("by2 %5d\n", (sx/FX1 - 1));
                    D(1) dprintf("by0 %5d\n", sx/FX1);
                    D(8) ASSERT(pb + (-WidthBytesSrc + sx/FX1) * dwDelta >= pbSrc);
                    by0 = *(pb + sx/FX1 * dwDelta);
                    by2 = *(pb + (-WidthBytesSrc + sx/FX1) * dwDelta); //+WidthBytesSrc
                    ymodfx1 = sy%FX1;
                    *pbDst = (BYTE)((ymodfx1 * (ULONG)by0 + (FX1-ymodfx1) * (ULONG)by2)/FX1);
                    pbDst += lDestDelta;
                }
                for (               ; x<dxDst; x++, sx+=sdx)
                {
                        D(1) dprintf("sx : %5d coln ---| %5d [ %d ]\n", sx, sx/FX1, WidthBytesSrc);
                        D(1) dprintf("by3 %5d   by2 %5d\n", (-WidthBytesSrc + sx/FX1-1),(-WidthBytesSrc + sx/FX1));
                        D(1) dprintf("by1 %5d   by0 %5d\n", (sx/FX1 - 1), sx/FX1);
                        by0 = *(pb + sx/FX1 * dwDelta);
                        D(8) ASSERT(pb + (sx/FX1 - 1) * dwDelta >= pbSrc);
                        by1 =     *(pb + (sx/FX1 - 1) * dwDelta);                   //1
                        D(8) ASSERT(pb + (-WidthBytesSrc + sx/FX1) * dwDelta >= pbSrc);
                        by2 =     *(pb + (-WidthBytesSrc + sx/FX1) * dwDelta);      //+WidthBytesSrc
                        D(8) ASSERT(pb + (-WidthBytesSrc + sx/FX1 - 1) * dwDelta >= pbSrc);
                        by3 =     *(pb + (-WidthBytesSrc + sx/FX1 - 1) * dwDelta);  //+WidthBytesSrc    +1
                        xmodfx1 = sx%FX1;
                        ymodfx1 = sy%FX1;
                        FX1_xmodfx1 = FX1-xmodfx1;
                        FX1_ymodfx1 = FX1-ymodfx1;
                        *pbDst =(BYTE)(((ULONG)by0 * xmodfx1     / FX1 * ymodfx1     +
                                        (ULONG)by1 * FX1_xmodfx1 / FX1 * ymodfx1     +
                                        (ULONG)by2 * xmodfx1     / FX1 * FX1_ymodfx1 +
                                        (ULONG)by3 * FX1_xmodfx1 / FX1 * FX1_ymodfx1     )/FX1);
                        //*pbDst =(BYTE)(((ULONG)by0 * FX1_xmodfx1 / FX1 * FX1_ymodfx1 +
                        //                (ULONG)by1 * xmodfx1     / FX1 * FX1_ymodfx1 +
                        //                (ULONG)by2 * FX1_xmodfx1 / FX1 * ymodfx1     +
                        //                (ULONG)by3 * xmodfx1     / FX1 * ymodfx1         )/FX1);
                        D(1) dprintf("    xmodfx1 ,     ymodfx1 = %d, %d\n",     xmodfx1 ,     ymodfx1);
                        D(1) dprintf("FX1_xmodfx1 , FX1_ymodfx1 = %d, %d\n", FX1_xmodfx1 , FX1_ymodfx1);
                        pbDst += lDestDelta;
                }
                pbDst += lOffset;
                D(2) DebugBreak();
        }
        D(4) DebugBreak();

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCONVERTMETHOD
 *
 *  @mfunc HRESULT | CConverter | ScaleDIBYUVPlanar | This method scales/flips
 *    a YUV planar bitmap.
 *
 *  @parm PBITMAPINFOHEADER | pbiSrc | Pointer to the input bitmap format.
 *
 *  @parm PBYTE | pbySrc | Pointer to the input bitmap.
 *
 *  @parm PBITMAPINFOHEADER | pbiSrc | Pointer to the output bitmap format.
 *
 *  @parm PBYTE | pbyDst | Pointer to the output bitmap.
 *
 *  @parm DWORD | dwUVDownSampling | Specifies the U and V plane downsampling.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 *
 *  @comm Parameter validation is done in ScaleDIB.
 ***************************************************************************/
HRESULT ScaleDIBYUVPlanar(PBITMAPINFOHEADER pbiSrc, PBYTE pbySrc, PBITMAPINFOHEADER pbiDst, PBYTE pbyDst, DWORD dwUVDownSampling, PRECT prcRect, BOOL fFlipHorizontal, BOOL fFlipVertical, BOOL fNoImageStretch)
{
        HRESULT         Hr = NOERROR;
        PBYTE           pbSrc;
        PBYTE           pbDst;
        int                     dxSrc, dySrc;
        int                     dxDst, dyDst;
        int                     x0, y0, sdx, sdy;
        int                     y;
    long                extra, pitch, prelinebytes, postlinebytes;
    long                prelines, postlines, prebytes, postbytes, bytes;

        FX_ENTRY("ScaleDIBYUVPlanar")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        dxSrc = (int)pbiSrc->biWidth;
        dySrc = (int)pbiSrc->biHeight;

        dxDst = (int)pbiDst->biWidth;
        dyDst = (int)pbiDst->biHeight;

        pbiDst->biSizeImage = dxDst * dyDst + dxDst / dwUVDownSampling * dyDst / dwUVDownSampling + dxDst / dwUVDownSampling * dyDst / dwUVDownSampling;

        pbSrc = (BYTE *)pbySrc;
        pbDst = (BYTE *)pbyDst;

        sdx = (dxSrc-1) * FX1 / (dxDst-1);
        sdy = (dySrc-1) * FX1 / (dyDst-1);
        y0  = 0;
        x0  = 0;

        if (!fNoImageStretch)
        {
                RECT rcRect;

                // TESTED (zoom out & zoom in)

                // Do Y plane first
                rcRect.left = prcRect->left;
                rcRect.top = prcRect->top;
                rcRect.right = prcRect->right;
                rcRect.bottom = prcRect->bottom;
                ScalePlane(pbSrc, pbDst, dxSrc, dxDst, dyDst, dxDst, &rcRect, fFlipHorizontal, fFlipVertical);

                // Do U plane next
                rcRect.left = prcRect->left / dwUVDownSampling;
                rcRect.top = prcRect->top / dwUVDownSampling;
                rcRect.right = prcRect->right / dwUVDownSampling;
                rcRect.bottom = prcRect->bottom / dwUVDownSampling;
                ScalePlane(pbSrc + dxSrc * dySrc, pbDst + dxDst * dyDst, dxSrc / dwUVDownSampling, dxDst / dwUVDownSampling, dyDst / dwUVDownSampling, dxDst / dwUVDownSampling, &rcRect, fFlipHorizontal, fFlipVertical);

                // Do V plane last
                ScalePlane(pbSrc + dxSrc * dySrc + dxSrc * dySrc / (dwUVDownSampling * dwUVDownSampling), pbDst + dxDst * dyDst + dxDst * dyDst / (dwUVDownSampling * dwUVDownSampling), dxSrc / dwUVDownSampling, dxDst / dwUVDownSampling, dyDst / dwUVDownSampling, dxDst / dwUVDownSampling, &rcRect, fFlipHorizontal, fFlipVertical);
        }
        else
        {
        if ((dxSrc >= dxDst) && (dySrc >= dyDst))
                {
                        // TESTED (zoom out)

                        prelines = (dySrc - dyDst) / 2;
                        pbSrc = pbySrc + prelines * dxSrc;

                        // extra = # of source bytes per scan line that are to be cropped
                        extra = dxSrc - dxDst;
                        prebytes = extra / 2;

                        // advance pIn by half of extra to crop left most pixels
                        pbSrc += prebytes;

                        // Do the Y component first
                        pitch = extra + dxDst;
                    for (y = 0; y < dyDst; y++)
                        {
                                CopyMemory (pbDst, pbSrc, dxDst);
                        pbSrc += pitch;          // get to start of next row
                        pbDst += dxDst;         // get to start of next row
                    }

                        // Do the first color component next
                        prelines /= dwUVDownSampling;
                        prebytes /= dwUVDownSampling;
                        pbSrc = pbySrc + (dxSrc * dySrc) +    // skip Y section
                                prelines * dxSrc / dwUVDownSampling +  // skip half of the crop lines
                                prebytes;                                           // skip half of the crop pixels

                        pitch /= dwUVDownSampling;
                        bytes = dxDst / dwUVDownSampling;
                        for (y=0; y < dyDst / (long)dwUVDownSampling; y++)
                        {
                                CopyMemory (pbDst, pbSrc, bytes);
                                pbSrc += pitch;
                                pbDst += bytes;
                        }

                        // Do the second color component next
                        pbSrc = pbySrc + (dxSrc * dySrc) +    // skip Y section
                                (dxSrc * dySrc) / (dwUVDownSampling * dwUVDownSampling) +     // skip first color component section
                                prelines * dxSrc / dwUVDownSampling +                  // skip half of the crop lines
                                prebytes;                                           // skip half of the crop pixels
                        for (y=0; y < dyDst / (long)dwUVDownSampling; y++)
                        {
                                CopyMemory (pbDst, pbSrc, bytes);
                                pbSrc += pitch;
                                pbDst += bytes;
                        }
                }
                else
                {
                        // TESTED (zoom in)

                        // Do the Y component first
                    prelines = (dyDst - dySrc) / 2;
                    postlines = dyDst - dySrc - prelines;

                    prebytes = (dxDst - dxSrc) / 2;
                    postbytes = (dxDst - dxSrc - prebytes);

                    bytes = prelines * dxDst + prebytes;
                    FillMemory (pbDst, bytes, 0x10);
                    pbDst += bytes;

                        bytes = dxSrc;
                    prebytes += postbytes;
                        for (y=0; y < dySrc; y++)
                        {
                        CopyMemory (pbDst, pbSrc, bytes);
                        pbSrc += bytes;
                        pbDst += bytes;
                        FillMemory (pbDst, prebytes, 0x10);
                        pbDst += prebytes;
                        }

                        // already filled the prebytes of the first postline in loop above
                        prebytes -= postbytes;
                        bytes = postlines * dxDst - prebytes;
                        FillMemory (pbDst, bytes, (BYTE)0x10);
                        pbDst += bytes;

                        // Do the first color component next
                    prelines /= dwUVDownSampling;
                    postlines = dyDst / dwUVDownSampling - dySrc / dwUVDownSampling - prelines;

                    prebytes = prebytes / dwUVDownSampling;
                    postbytes = dxDst / dwUVDownSampling - dxSrc / dwUVDownSampling - prebytes;

                    prelinebytes = prelines * dxDst / dwUVDownSampling + prebytes;
                    FillMemory (pbDst, prelinebytes, 0x80);
                    pbDst += prelinebytes;

                        bytes = dxSrc / dwUVDownSampling;
                    prebytes += postbytes;
                        for (y=0; y < dySrc / (long)dwUVDownSampling; y++)
                        {
                        CopyMemory (pbDst, pbSrc, bytes);
                        pbSrc += bytes;
                        pbDst += bytes;
                        FillMemory (pbDst, prebytes, 0x80);
                        pbDst += prebytes;
                        }

                        // already filled the prebytes of the first postline in loop above
                        postlinebytes = postlines * dxDst / dwUVDownSampling - (prebytes - postbytes);
                        FillMemory (pbDst, postlinebytes, 0x80);
                        pbDst += postlinebytes;

                        // Do the second color component next
                    FillMemory (pbDst, prelinebytes, 0x80);
                    pbDst += prelinebytes;
                        for (y=0; y < dySrc / (long)dwUVDownSampling; y++)
                        {
                        MoveMemory (pbDst, pbSrc, bytes);
                        pbSrc += bytes;
                        pbDst += bytes;
                        FillMemory (pbDst, prebytes, 0x80);
                        pbDst += prebytes;
                        }
                        FillMemory (pbDst, postlinebytes, 0x80);
                }
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}
/****************************************************************************
 *  @doc INTERNAL CCONVERTMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | ScaleDIBYUVPacked | This method scales/flips
 *    a YUV packed bitmap.
 *
 *  @parm PBITMAPINFOHEADER | pbiSrc | Pointer to the input bitmap format.
 *
 *  @parm PBYTE | pbySrc | Pointer to the input bitmap.
 *
 *  @parm PBITMAPINFOHEADER | pbiSrc | Pointer to the output bitmap format.
 *
 *  @parm PBYTE | pbyDst | Pointer to the output bitmap.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 *
 *  @comm Parameter validation is done in ScaleDIB.
 ***************************************************************************/
HRESULT ScaleDIBYUVPacked(PBITMAPINFOHEADER pbiSrc, PBYTE pbySrc, PBITMAPINFOHEADER pbiDst, PBYTE pbyDst, DWORD dwZeroingDWORD, PRECT prcRect, BOOL fFlipHorizontal, BOOL fFlipVertical, BOOL fNoImageStretch, int yuvstartpos[])
{
        HRESULT         Hr = NOERROR;
        PBYTE           pbSrc;
        PBYTE           pbDst;
        int                     dxSrc, dySrc;
        int                     dxDst, dyDst;
        long            WidthBytesSrc;
        long            WidthBytesDst;
        int                     x, y;
    long                extra;
    long                prelines, postlines, prebytes, postbytes;

        FX_ENTRY("ScaleDIBYUVPacked")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        dxSrc = (int)pbiSrc->biWidth;
        dySrc = (int)pbiSrc->biHeight;

        dxDst = (int)pbiDst->biWidth;
        dyDst = (int)pbiDst->biHeight;

        WidthBytesDst = DIBWIDTHBYTES(*pbiDst);
        WidthBytesSrc = dxSrc * 2;

        pbiDst->biSizeImage = WidthBytesDst * dyDst;

        pbSrc = (BYTE *)pbySrc;
        pbDst = (BYTE *)pbyDst;

        if (!fNoImageStretch)
        {
                // TESTED (zoom in & out + all combinations of flipped horizontal & flipped vertical)

                RECT rcRect;

                // Do Y plane first
                rcRect.left = prcRect->left;
                rcRect.top = prcRect->top;
                rcRect.right = prcRect->right;
                rcRect.bottom = prcRect->bottom;
                ScalePackedPlane(pbSrc + yuvstartpos[Y_POS], pbDst + yuvstartpos[Y_POS], dxDst, dyDst, dxSrc, dxDst, &rcRect, fFlipHorizontal, fFlipVertical, 2);

                // Do U plane next
                rcRect.left = prcRect->left / 2;
                rcRect.top = prcRect->top;
                rcRect.right = prcRect->right / 2;
                rcRect.bottom = prcRect->bottom;
                ScalePackedPlane(pbSrc + yuvstartpos[U_POS], pbDst + yuvstartpos[U_POS], dxDst / 2, dyDst, dxSrc / 2, dxDst / 2, &rcRect, fFlipHorizontal, fFlipVertical, 4);

                // Do V plane last
                ScalePackedPlane(pbSrc + yuvstartpos[V_POS], pbDst + yuvstartpos[V_POS], dxDst / 2, dyDst, dxSrc / 2, dxDst / 2, &rcRect, fFlipHorizontal, fFlipVertical, 4);
        }
        else
        {
        if ((dxSrc >= dxDst) && (dySrc >= dyDst))
                {

                        // TESTED (zoom out)

                    // starts by skipping half of the height change
                    pbSrc = pbSrc + (dySrc - dyDst) / 2 * dxSrc * 2;

                    // extra = # of source bytes per scan line that are to be cropped
                    extra = (dxSrc - dxDst) * 2;

                    // advance pIn by half of extra to crop left most pixels
                    pbSrc += extra / 2;

                    // adjust ipitch so we can add it at the end of each scan to get to start of next scan
                    WidthBytesSrc = dxSrc * 2;
                    WidthBytesDst = dxDst * 2;      // bytes at end of each row

                    for (y = 0; y < dyDst; y++) {
                                CopyMemory(pbDst, pbSrc, WidthBytesDst);
                        pbSrc += WidthBytesSrc;          // get to start of next row
                        pbDst += WidthBytesDst;         // get to start of next row
                    }
                }
                else
                {
                        // TESTED (zoom in)

                    prelines = (dyDst - dySrc) / 2;
                    postlines = dyDst - dySrc - prelines;

                    prebytes = (dxDst - dxSrc) / 2;
                    postbytes = (dxDst - dxSrc - prebytes) / 2;
                    prebytes /= 2;

                    WidthBytesSrc = dxSrc * 2;        // bytes at end of each src row
                    WidthBytesDst = dxDst / 2;                    // bytes at end of each dst row

                    // do blank lines at front of destination
                    for (y = 0; y < prelines; y++)
                        {
                            for (x = 0; x < WidthBytesDst; x++)
                                {
                                        *(DWORD *)pbDst = dwZeroingDWORD;
                                        pbDst += sizeof(DWORD);
                                }
                    }

                    // copy source lines with blank space at front and rear
                    for (y = 0; y < dySrc; y++)
                        {
                                for (x = 0; x < prebytes; x++)
                                {
                                        *(DWORD *)pbDst = dwZeroingDWORD;
                                        pbDst += sizeof(DWORD);
                                }

                        CopyMemory(pbDst, pbSrc, WidthBytesSrc);
                                pbDst += WidthBytesSrc;
                                pbSrc += WidthBytesSrc;

                                for (x = 0; x < postbytes; x++)
                                {
                                        *(DWORD *)pbDst = dwZeroingDWORD;
                                        pbDst += sizeof(DWORD);
                                }
                    }

                    // do blank lines at end of destination
                    for (y = 0; y < postlines; y++)
                        {
                                for (x = 0; x < WidthBytesDst; x++)
                                {
                                        *(DWORD *)pbDst = dwZeroingDWORD;
                                        pbDst += sizeof(DWORD);
                                }
                    }
                }
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

HRESULT ComputeRectangle(PBITMAPINFOHEADER pbiSrc, PBITMAPINFOHEADER pbiDst, LONG lZoom, LONG lPan, LONG lTilt, PRECT prcRect, BOOL fFlipHorizontal, BOOL fFlipVertical)
{
        HRESULT Hr = NOERROR;
        LONG    lWidth = 0;
        LONG    lHeight = 0;
        LONG    lLeftPos = 0;
        LONG    lTopPos = 0;
        LONG    lCCPan = 0;
        LONG    lCCTilt = 0;

        FX_ENTRY("ComputeRectangle")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pbiSrc);
        ASSERT(pbiDst);
        if (!pbiSrc || !pbiDst)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }
        ASSERT(pbiSrc->biCompression == pbiDst->biCompression);
        ASSERT(pbiSrc->biCompression == BI_RGB || pbiSrc->biCompression == VIDEO_FORMAT_YVU9 || pbiSrc->biCompression == VIDEO_FORMAT_YUY2 || pbiSrc->biCompression == VIDEO_FORMAT_UYVY || pbiSrc->biCompression == VIDEO_FORMAT_I420 || pbiSrc->biCompression == VIDEO_FORMAT_IYUV);

        // Compute the source rectangle coordinates - we only care about pan, tilt and zoom
        lWidth = pbiSrc->biWidth;
        lHeight = pbiSrc->biHeight;

        D(1) dprintf("%s : fFlipHorizontal = %d , fFlipVertical = %d\n", _fx_, fFlipHorizontal, fFlipVertical);

        // Compute the size of the rectangle
        if ((lZoom > 10) && (lZoom <= 600))
        {
                lWidth = (8192 + (600 - lZoom) * 42) * lWidth / 32768;
                lHeight = (8192 + (600 - lZoom) * 42) * lHeight / 32768;
                if (lWidth > pbiSrc->biWidth)
                        lWidth = pbiSrc->biWidth;
                if (lHeight > pbiSrc->biHeight)
                        lHeight = pbiSrc->biHeight;
        }
        // Compute x-location of the rectangle
        if ((lPan >= -180)  && (lPan <= 180))
        {
                lCCPan = (LONG)(fFlipHorizontal ? -lPan : lPan);
                lLeftPos = (lCCPan + 180) * (pbiSrc->biWidth - lWidth) / 360;
                if (lLeftPos + lWidth > pbiSrc->biWidth)
                        if (lLeftPos)
                                lLeftPos = lLeftPos - (pbiSrc->biWidth - lWidth - lLeftPos);
        }
        // Compute y-location of the rectangle
        if ((lTilt >= -180)  && (lTilt <= 180))
        {
                lCCTilt = (LONG)(fFlipVertical ? -lTilt : lTilt);
                lTopPos = (lCCTilt + 180) * (pbiSrc->biHeight - lHeight) / 360;
                if (lTopPos + lHeight > pbiSrc->biHeight)
                        if (lTopPos)
                                lTopPos = lTopPos - (pbiSrc->biHeight - lHeight - lTopPos);
        }

        // Do a last check
        if ((lLeftPos + lWidth > pbiSrc->biWidth) || (lTopPos + lHeight > pbiSrc->biHeight))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }

        // Set up source rectangle
        prcRect->left = lLeftPos;
        prcRect->top = lTopPos;
        prcRect->right = lLeftPos + lWidth;
        prcRect->bottom = lTopPos + lHeight;

        D(1) dprintf("prcRect @ %p: l,t,r,b = %d , %d , %d , %d\n",prcRect, prcRect->left, prcRect->top, prcRect->right, prcRect->bottom);

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

#ifndef DEBUG
#pragma optimize( "", off )
#endif

/****************************************************************************
 *  @doc INTERNAL CCONVERTMETHOD
 *
 *  @mfunc void | CICMConverter | CICMConverter | This method is the constructor
 *    for the <c CICMConverter> object.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CICMConverter::CICMConverter(IN TCHAR *pObjectName, IN CTAPIBasePin *pBasePin, IN PBITMAPINFOHEADER pbiIn, IN PBITMAPINFOHEADER pbiOut, IN HRESULT *pHr) : CConverter(pObjectName, pBasePin, pbiIn, pbiOut, pHr)
{
        FX_ENTRY("CICMConverter::CICMConverter")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        if (!pHr || FAILED(*pHr))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Base class error or invalid input parameter", _fx_));
                goto MyExit;
        }

        // Default inits
        m_hIC = NULL;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCONVERTMETHOD
 *
 *  @mfunc void | CICMConverter | ~CICMConverter | This method is the destructor
 *    for the <c CICMConverter> object.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CICMConverter::~CICMConverter()
{
        FX_ENTRY("CICMConverter::~CICMConverter")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCONVERTMETHOD
 *
 *  @mfunc CICMConverter* | CICMConverter | CreateVfWCapDev | This
 *    helper function creates an object to interact with the VfW capture
 *    device.
 *
 *  @parm CTAPIVCap* | pCaptureFilter | Specifies a pointer to the owner
 *    filter.
 *
 *  @parm CCapDev** | ppCapDev | Specifies the address of a pointer to the
 *    newly created <c CVfWCapDev> object.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_OUTOFMEMORY | Out of memory
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CALLBACK CICMConverter::CreateICMConverter(IN CTAPIBasePin *pBasePin, IN PBITMAPINFOHEADER pbiIn, IN PBITMAPINFOHEADER pbiOut, OUT CConverter **ppConverter)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CICMConverter::CreateICMConverter")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pBasePin);
        ASSERT(ppConverter);
        if (!pBasePin || !ppConverter)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        if (!(*ppConverter = (CConverter *) new CICMConverter(NAME("ICM Converter"), pBasePin, pbiIn, pbiOut, &Hr)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                Hr = E_OUTOFMEMORY;
                goto MyExit;
        }

        // If initialization failed, delete the stream array and return the error
        if (FAILED(Hr) && *ppConverter)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Initialization failed", _fx_));
                Hr = E_FAIL;
                delete *ppConverter, *ppConverter = NULL;
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\critsec.h ===
#ifndef _CRITSEC_H_
#define _CRITSEC_H_

EXTERN_C CRITICAL_SECTION g_CritSec;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\cpucp.h ===
/****************************************************************************
 *  @doc INTERNAL CPUCP
 *
 *  @module CPUCP.h | Header file for the <c CCPUCProperty>
 *    class used to implement a property page to test the new TAPI internal
 *    interfaces <i ICPUControl>.
 *
 *  @comm This code tests the TAPI VfW Output Pins <i ICPUControl>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
 ***************************************************************************/

#ifndef _CPUCP_H_
#define _CPUCP_H_

#ifdef USE_PROPERTY_PAGES

#ifdef USE_CPU_CONTROL

#define NUM_CPUC_CONTROLS				4
#define IDC_CPUC_MaxCPULoad				0
#define IDC_CPUC_MaxProcessingTime		1
#define IDC_CPUC_CurrentCPULoad			2
#define IDC_CPUC_CurrentProcessingTime	3

/****************************************************************************
 *  @doc INTERNAL CCPUCPCLASS
 *
 *  @class CCPUCProperty | This class implements handling of a
 *    single CPU control property in a property page.
 *
 *  @mdata int | CCPUCProperty | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata ICPUControl* | CCPUCProperty | m_pICPUControl | Pointer
 *    to the <i ICPUControl> interface.
 *
 *  @comm This code tests the TAPI VfW Output Pins <i ICPUControl>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
***************************************************************************/
class CCPUCProperty : public CKSPropertyEditor 
{
	public:
	CCPUCProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ICPUControl *pICPUControl);
	~CCPUCProperty ();

	// CKSPropertyEditor base class pure virtual overrides
	HRESULT GetValue();
	HRESULT SetValue();
	HRESULT GetRange();
	BOOL CanAutoControl(void);
	BOOL GetAuto(void);
	BOOL SetAuto(BOOL fAuto);

	private:
	ICPUControl *m_pICPUControl;
};

/****************************************************************************
 *  @doc INTERNAL CCPUCPCLASS
 *
 *  @class CCPUCProperties | This class implements a property page
 *    to test the new TAPI internal interfaces <i ICPUControl>.
 *
 *  @mdata int | CCPUCProperties | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata ICPUControl* | CCPUCProperties | m_pInterface | Pointer
 *    to the <i ICPUControl> interface.
 *
 *  @mdata CCPUCProperty* | CCPUCProperties | m_Controls[NUM_CPUC_CONTROLS] | Array
 *    of CPU control properties.
 *
 *  @comm This code tests the TAPI VfW Output Pins <i ICPUControl>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
***************************************************************************/
class CCPUCProperties : public CBasePropertyPage
{
	public:
	CCPUCProperties(LPUNKNOWN pUnk, HRESULT *pHr);
	~CCPUCProperties();

	// Implement CBasePropertyPage virtual methods
	HRESULT OnConnect(IUnknown *pUnk);
	HRESULT OnDisconnect();
	HRESULT OnActivate();
	HRESULT OnDeactivate();
	HRESULT OnApplyChanges();
	BOOL    OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

	private:

	void SetDirty();

	HWND			m_hWnd;
	int				m_NumProperties;
	BOOL			m_fActivated;
	ICPUControl		*m_pICPUControl;
	CCPUCProperty	*m_Controls[NUM_CPUC_CONTROLS];
};

#endif // USE_CPU_CONTROL

#endif // USE_PROPERTY_PAGES

#endif // _CPUCP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\cpucp.cpp ===
/****************************************************************************
 *  @doc INTERNAL CPUCP
 *
 *  @module CPUCP.cpp | Source ile for the <c CCPUCProperty>
 *    class used to implement a property page to test the new TAPI internal
 *    interface <i ICPUControl>.
 *
 *  @comm This code tests the TAPI VfW Output Pins <i ICPUControl>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
 ***************************************************************************/

#include "Precomp.h"

#ifdef USE_PROPERTY_PAGES

#ifdef USE_CPU_CONTROL

/****************************************************************************
 *  @doc INTERNAL CCPUCPMETHOD
 *
 *  @mfunc void | CCPUCProperty | CCPUCProperty | This
 *    method is the constructor for bitrate and frame rate property objects. It
 *    calls the base class constructor, calls InitCommonControlsEx, and saves
 *    pointers to the <i ICPUControl> and <i IFrameRateControl> interfaces.
 *
 *  @parm HWND | hDlg | Specifies a handle to the parent property page.
 *
 *  @parm ULONG | IDLabel | Specifies a label ID for the property.
 *
 *  @parm ULONG | IDMinControl | Specifies a label ID for the associated
 *    property edit control where the Minimum value of the property appears.
 *
 *  @parm ULONG | IDMaxControl | Specifies a label ID for the associated
 *    property edit control where the Maximum value of the property appears.
 *
 *  @parm ULONG | IDDefaultControl | Specifies a label ID for the associated
 *    property edit control where the Default value of the property appears.
 *
 *  @parm ULONG | IDStepControl | Specifies a label ID for the associated
 *    property edit control where the Stepping Delta value of the property appears.
 *
 *  @parm ULONG | IDEditControl | Specifies a label ID for the associated
 *    property edit control where the value of the property appears.
 *
 *  @parm ULONG | IDTrackbarControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProgressControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProperty | Specifies the ID of the Ks property.
 *
 *  @parm ICPUControl* | pICPUControl | Specifies a pointer to the
 *    <i ICPUControl> interface.
 *
 *  @parm IFrameRateControl* | pIFrameRateControl | Specifies a pointer to the
 *    <i IFrameRateControl> interface.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCPUCProperty::CCPUCProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ICPUControl *pICPUControl)
: CKSPropertyEditor(hDlg, IDLabel, IDMinControl, IDMaxControl, IDDefaultControl, IDStepControl, IDEditControl, IDTrackbarControl, IDProgressControl, IDProperty, 0)
{
	INITCOMMONCONTROLSEX cc;

	FX_ENTRY("CCPUCProperty::CCPUCProperty")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	cc.dwSize = sizeof (INITCOMMONCONTROLSEX);
	cc.dwICC  = ICC_UPDOWN_CLASS | ICC_BAR_CLASSES;

	InitCommonControlsEx(&cc);

	// It's fine if the interface pointer is NULL, we'll grey the
	// associated items in the property page
	m_pICPUControl = pICPUControl;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCPUCPMETHOD
 *
 *  @mfunc void | CCPUCProperty | ~CCPUCProperty | This
 *    method is the destructor for CPU control property objects. It
 *    simply calls the base class destructor.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCPUCProperty::~CCPUCProperty()
{
	FX_ENTRY("CCPUCProperty::~CCPUCProperty")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCPUCPMETHOD
 *
 *  @mfunc HRESULT | CCPUCProperty | GetValue | This method queries for
 *    the value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCPUCProperty::GetValue()
{
	HRESULT Hr = E_NOTIMPL;
	REFERENCE_TIME CurrentValue;

	FX_ENTRY("CCPUCProperty::GetValue")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	switch (m_IDProperty)
	{									
		case IDC_CPUC_MaxCPULoad:
			if (m_pICPUControl && SUCCEEDED (Hr = m_pICPUControl->GetMaxCPULoad((LPDWORD)&m_CurrentValue, 0)))
			{
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: *pdwMaxCPULoad=%ld", _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_CPUC_MaxProcessingTime:
			if (m_pICPUControl && SUCCEEDED (Hr = m_pICPUControl->GetMaxProcessingTime(&CurrentValue, 0)))
			{
				m_CurrentValue = (LONG)CurrentValue;
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: *pMaxProcessingTime=%ld", _fx_, CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_CPUC_CurrentCPULoad:
			if (m_pICPUControl && SUCCEEDED (Hr = m_pICPUControl->GetCurrentCPULoad((LPDWORD)&m_CurrentValue)))
			{
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: *pdwCurrentCPULoad=%ld", _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_CPUC_CurrentProcessingTime:
			if (m_pICPUControl && SUCCEEDED (Hr = m_pICPUControl->GetCurrentProcessingTime(&CurrentValue)))
			{
				m_CurrentValue = (LONG)CurrentValue;
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: *pCurrentProcessingTime=%ld", _fx_, CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		default:
			Hr = E_UNEXPECTED;
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Unknown CPU control property", _fx_));
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCPUCPMETHOD
 *
 *  @mfunc HRESULT | CCPUCProperty | SetValue | This method sets the
 *    value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCPUCProperty::SetValue()
{
	HRESULT Hr = E_NOTIMPL;

	FX_ENTRY("CCPUCProperty::SetValue")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	switch (m_IDProperty)
	{
		case IDC_CPUC_MaxCPULoad:
			if (m_pICPUControl && SUCCEEDED (Hr = m_pICPUControl->SetMaxCPULoad((DWORD)m_CurrentValue)))
			{
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: dwMaxCPULoad=%ld", _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_CPUC_MaxProcessingTime:
			if (m_pICPUControl && SUCCEEDED (Hr = m_pICPUControl->SetMaxProcessingTime((REFERENCE_TIME)m_CurrentValue)))
			{
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: MaxProcessingTime=%ld", _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_CPUC_CurrentCPULoad:
		case IDC_CPUC_CurrentProcessingTime:
			// This is a read-only property. Don't do anything.
			Hr = NOERROR;
			break;
		default:
			Hr = E_UNEXPECTED;
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Unknown CPU control property", _fx_));
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCPUCPMETHOD
 *
 *  @mfunc HRESULT | CCPUCProperty | GetRange | This method retrieves
 *    the range information of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCPUCProperty::GetRange()
{
	HRESULT Hr = E_NOTIMPL;
	REFERENCE_TIME Min;
	REFERENCE_TIME Max;
	REFERENCE_TIME SteppingDelta;
	REFERENCE_TIME Default;

	FX_ENTRY("CCPUCProperty::GetRange")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	switch (m_IDProperty)
	{
		case IDC_CPUC_CurrentCPULoad:
		case IDC_CPUC_MaxCPULoad:
			if (m_pICPUControl && SUCCEEDED (Hr = m_pICPUControl->GetMaxCPULoadRange((LPDWORD)&m_Min, (LPDWORD)&m_Max, (LPDWORD)&m_SteppingDelta, (LPDWORD)&m_DefaultValue, 0UL)))
			{
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: *pdwMin=%ld, *pdwMax=%ld, *pdwSteppingDelta=%ld, *pdwDefault=%ld", _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_CPUC_CurrentProcessingTime:
		case IDC_CPUC_MaxProcessingTime:
			if (m_pICPUControl && SUCCEEDED (Hr = m_pICPUControl->GetMaxProcessingTimeRange(&Min, &Max, &SteppingDelta, &Default, 0UL)))
			{
				m_Min = (LONG)Min;
				m_Max = (LONG)Max;
				m_SteppingDelta = (LONG)SteppingDelta;
				m_DefaultValue = (LONG)Default;
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: *pMin=%ld, *pMax=%ld, *pSteppingDelta=%ld, *pDefault=%ld", _fx_, Min, Max, SteppingDelta, Default));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		default:
			Hr = E_UNEXPECTED;
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Unknown CPU control property", _fx_));
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCPUCPMETHOD
 *
 *  @mfunc HRESULT | CCPUCProperty | CanAutoControl | This method
 *    retrieves the automatic control capabilities for a property.
 *
 *  @rdesc This method returns TRUE if automatic control is supported, FALSE
 *    otherwise.
 ***************************************************************************/
BOOL CCPUCProperty::CanAutoControl(void)
{
	FX_ENTRY("CCPUCProperty::CanAutoControl")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

	return FALSE;
}

/****************************************************************************
 *  @doc INTERNAL CCPUCPMETHOD
 *
 *  @mfunc HRESULT | CCPUCProperty | GetAuto | This method
 *    retrieves the current automatic control mode of a property.
 *
 *  @rdesc This method returns TRUE if automatic control is supported, FALSE
 *    otherwise.
 ***************************************************************************/
BOOL CCPUCProperty::GetAuto(void)
{
	FX_ENTRY("CCPUCProperty::GetAuto")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

	return FALSE; 
}

/****************************************************************************
 *  @doc INTERNAL CCPUCPMETHOD
 *
 *  @mfunc HRESULT | CCPUCProperty | SetAuto | This method
 *    sets the automatic control mode of a property.
 *
 *  @parm BOOL | fAuto | Specifies the automatic control mode.
 *
 *  @rdesc This method returns TRUE.
 ***************************************************************************/
BOOL CCPUCProperty::SetAuto(BOOL fAuto)
{
	FX_ENTRY("CCPUCProperty::SetAuto")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

	return TRUE; 
}

/****************************************************************************
 *  @doc INTERNAL CCPUCPMETHOD
 *
 *  @mfunc CUnknown* | CCPUCProperties | CreateInstance | This
 *    method is called by DShow to create an instance of a TAPI CPU Control
 *    Property Page. It is referred to in the global structure <t g_Templates>.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Returns a pointer to the nondelegating CUnknown portion of the
 *    object, or NULL otherwise.
 ***************************************************************************/
CUnknown* CALLBACK CCPUCPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr) 
{
	CUnknown *pUnknown = (CUnknown *)NULL;

	FX_ENTRY("CCPUCPropertiesCreateInstance")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pHr);
	if (!pHr)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		goto MyExit;
	}

	if (!(pUnknown = new CCPUCProperties(pUnkOuter, pHr)))
	{
		*pHr = E_OUTOFMEMORY;
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: new CCPUCProperties failed", _fx_));
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: new CCPUCProperties created", _fx_));
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return pUnknown;
}

/****************************************************************************
 *  @doc INTERNAL CCPUCPMETHOD
 *
 *  @mfunc void | CCPUCProperties | CCPUCProperties | This
 *    method is the constructor for the property page object. It simply
 *    calls the constructor of the property page base class.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCPUCProperties::CCPUCProperties(LPUNKNOWN pUnk, HRESULT *pHr) : CBasePropertyPage(NAME("TAPI CPU Control Property Page"), pUnk, IDD_CPUControlProperties, IDS_CPUCPROPNAME)
{
	FX_ENTRY("CCPUCProperties::CCPUCProperties")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	m_pICPUControl = NULL;
	m_NumProperties = NUM_CPUC_CONTROLS;

	for (int i = 0; i < m_NumProperties; i++)
		m_Controls[i] = NULL;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCPUCPMETHOD
 *
 *  @mfunc void | CCPUCProperties | ~CCPUCProperties | This
 *    method is the destructor for the capture pin property page. It
 *    simply calls the base class destructor after deleting all the controls.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCPUCProperties::~CCPUCProperties()
{
	int		j;

	FX_ENTRY("CCPUCProperties::~CCPUCProperties")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX", _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: control already freed", _fx_));
		}
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCPUCPMETHOD
 *
 *  @mfunc HRESULT | CCPUCProperties | OnConnect | This
 *    method is called when the property page is connected to the filter.
 *
 *  @parm LPUNKNOWN | pUnknown | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCPUCProperties::OnConnect(IUnknown *pUnk)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCPUCProperties::OnConnect")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pUnk);
	if (!pUnk)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Get the CPU control interface
	if (SUCCEEDED (Hr = pUnk->QueryInterface(__uuidof(ICPUControl), (void **)&m_pICPUControl)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_pICPUControl=0x%08lX", _fx_, m_pICPUControl));
	}
	else
	{
		m_pICPUControl = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
	}

	// It's Ok if we couldn't get interface pointers
	// We'll just grey the controls in the property page
	// to make it clear to the user that they can't
	// control those properties on the capture device
	Hr = NOERROR;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCPUCPMETHOD
 *
 *  @mfunc HRESULT | CCPUCProperties | OnDisconnect | This
 *    method is called when the property page is disconnected from the owning
 *    filter.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCPUCProperties::OnDisconnect()
{
	FX_ENTRY("CCPUCProperties::OnDisconnect")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters: we seem to get called several times here
	// Make sure the interface pointer is still valid
	if (!m_pICPUControl)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: already disconnected!", _fx_));
	}
	else
	{
		// Release the interface
		m_pICPUControl->Release();
		m_pICPUControl = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: releasing m_pICPUControl", _fx_));
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CCPUCPMETHOD
 *
 *  @mfunc HRESULT | CCPUCProperties | OnActivate | This
 *    method is called when the property page is activated.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCPUCProperties::OnActivate()
{
	HRESULT	Hr = NOERROR;
	int		j;

	FX_ENTRY("CCPUCProperties::OnActivate")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Create the controls for the properties
	if (m_Controls[0] = new CCPUCProperty(m_hwnd, IDC_MaxProcessingTime_Label, IDC_MaxProcessingTime_Minimum, IDC_MaxProcessingTime_Maximum, IDC_MaxProcessingTime_Default, IDC_MaxProcessingTime_Stepping, IDC_MaxProcessingTime_Edit, IDC_MaxProcessingTime_Slider, 0, IDC_CPUC_MaxProcessingTime, m_pICPUControl))
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[0]=0x%08lX", _fx_, m_Controls[0]));

		if (m_Controls[1] = new CCPUCProperty(m_hwnd, IDC_CPULoad_Label, IDC_CPULoad_Minimum, IDC_CPULoad_Maximum, IDC_CPULoad_Default, IDC_CPULoad_Stepping, IDC_CPULoad_Edit, IDC_CPULoad_Slider, 0, IDC_CPUC_MaxCPULoad, m_pICPUControl))
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[1]=0x%08lX", _fx_, m_Controls[1]));

			if (m_Controls[2] = new CCPUCProperty(m_hwnd, 0, 0, 0, 0, 0, IDC_FORMAT_FlipVertical, 0, 0, IDC_CPUC_CurrentCPULoad, m_pICPUControl))
			{
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[2]=0x%08lX", _fx_, m_Controls[2]));

				if (m_Controls[3] = new CCPUCProperty(m_hwnd, 0, 0, 0, 0, 0, IDC_FORMAT_FlipHorizontal, 0, 0, IDC_CPUC_CurrentProcessingTime, m_pICPUControl))
				{
					DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[3]=0x%08lX", _fx_, m_Controls[3]));
				}
				else
				{
					DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
					delete m_Controls[0], m_Controls[0] = NULL;
					delete m_Controls[1], m_Controls[1] = NULL;
					delete m_Controls[2], m_Controls[2] = NULL;
					Hr = E_OUTOFMEMORY;
					goto MyExit;
				}
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
				delete m_Controls[0], m_Controls[0] = NULL;
				delete m_Controls[1], m_Controls[1] = NULL;
				Hr = E_OUTOFMEMORY;
				goto MyExit;
			}
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
			delete m_Controls[0], m_Controls[0] = NULL;
			Hr = E_OUTOFMEMORY;
			goto MyExit;
		}
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
		Hr = E_OUTOFMEMORY;
		goto MyExit;
	}

	// Initialize all the controls. If the initialization fails, it's Ok. It just means
	// that the TAPI control interface isn't implemented by the device. The dialog item
	// in the property page will be greyed, showing this to the user.
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j]->Init())
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[%ld]->Init()", _fx_, j));
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: m_Controls[%ld]->Init() failed", _fx_, j));
		}
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	m_fActivated = TRUE;
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCPUCPMETHOD
 *
 *  @mfunc HRESULT | CCPUCProperties | OnDeactivate | This
 *    method is called when the property page is dismissed.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCPUCProperties::OnDeactivate()
{
	int	j;

	FX_ENTRY("CCPUCProperties::OnDeactivate")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX", _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: control already freed", _fx_));
		}
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CCPUCPMETHOD
 *
 *  @mfunc HRESULT | CCPUCProperties | OnApplyChanges | This
 *    method is called when the user applies changes to the property page.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCPUCProperties::OnApplyChanges()
{
	HRESULT	Hr = NOERROR;
	int		j;
	CMediaType *pmt = NULL;

	FX_ENTRY("CCPUCProperties::OnApplyChanges")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Apply new targets on video stream
	for (j = 0; j < m_NumProperties; j++)
	{
		ASSERT(m_Controls[j]);
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: calling m_Controls[%ld]=0x%08lX->OnApply", _fx_, j, m_Controls[j]));
			if (m_Controls[j]->HasChanged())
				m_Controls[j]->OnApply();
			Hr = NOERROR;
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: can't calling m_Controls[%ld]=NULL->OnApply", _fx_, j));
			Hr = E_UNEXPECTED;
		}
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCPUCPMETHOD
 *
 *  @mfunc BOOL | CCPUCProperties | OnReceiveMessage | This
 *    method is called when a message is sent to the property page dialog box.
 *
 *  @rdesc By default, returns the value returned by the Win32 DefWindowProc function.
 ***************************************************************************/
BOOL CCPUCProperties::OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
	int iNotify = HIWORD (wParam);
	int j;

	switch (uMsg)
	{
		case WM_INITDIALOG:
			// This is called before Activate...
			m_hWnd = hWnd;
			return TRUE; // Don't call setfocus

		case WM_TIMER:
			if (m_fActivated)
			{
				// Update the Vu-Meters
				for (j = 0; j < m_NumProperties; j++)
				{
					ASSERT(m_Controls[j]);
					if (m_Controls[j]->GetProgressHWnd())
					{
						m_Controls[j]->UpdateProgress();
						SetDirty();
					}
				}
			}
			break;

		case WM_HSCROLL:
		case WM_VSCROLL:
			if (m_fActivated)
			{
				// Process all of the Trackbar messages
				for (j = 0; j < m_NumProperties; j++)
				{
					ASSERT(m_Controls[j]);
					if (m_Controls[j]->GetTrackbarHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnScroll(uMsg, wParam, lParam);
						SetDirty();
					}
				}
			}
			break;

		case WM_COMMAND:

			// This message gets sent even before OnActivate() has been
			// called(!). We need to test and make sure the controls have
			// beeen initialized before we can use them.
			if (m_fActivated)
			{
				// Process all of the edit box messages
				for (j = 0; j < m_NumProperties; j++)
				{
					if (m_Controls[j] && m_Controls[j]->GetEditHWnd() == (HWND)lParam)
					{
						m_Controls[j]->OnEdit(uMsg, wParam, lParam);
						SetDirty();
						break;
					}
				}

				switch (LOWORD(wParam))
				{
					case IDC_CONTROL_DEFAULT:
						for (j = 0; j < m_NumProperties; j++)
						{
							if (m_Controls[j])
								m_Controls[j]->OnDefault();
						}
						break;
					default:
						break;
				}
			}
			break;

		default:
			return FALSE;
	}

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CCPUCPMETHOD
 *
 *  @mfunc BOOL | CCPUCProperties | SetDirty | This
 *    method notifies the property page site of changes.
 *
 *  @rdesc Nada.
 ***************************************************************************/
void CCPUCProperties::SetDirty()
{
	m_bDirty = TRUE;
	if (m_pPageSite)
		m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\dbgxtra.h ===
//#define XTRA_TRACE -- moved in ...\skywalker\filters\filters.inc

#ifdef XTRA_TRACE

    #define XDBGONLY
    #define XDBG

    #define INIT_TICKS      LARGE_INTEGER liTicks;  \
                            LARGE_INTEGER liTicks1
    #define BEGIN_TICK QueryPerformanceCounter(&liTicks)
    #define END_TICK   QueryPerformanceCounter(&liTicks1)
    #define LOG_TICK(msg)   Log(TEXT(msg), ClockDiff(liTicks1, liTicks),0,0)
    #define END_LOG_TICK(msg)       QueryPerformanceCounter(&liTicks1);     \
                                                            Log(TEXT(msg), ClockDiff(liTicks1, liTicks),0,0)
    #define MARK_LOG_TICK(msg)              QueryPerformanceCounter(&liTicks1);                             \
                                                                    Log(TEXT(msg), ClockDiff(liTicks1, liTicks),0,0);   \
                                                                    QueryPerformanceCounter(&liTicks)
    #define HEAPCHK(msg)            SimpleHeapCheck(msg)
    #define LOG_MSG_VAL(msg,val,p,s)    Log(msg,(val),(p),(s))                                  


#undef ACLASS
#ifdef __WRKRTHD__
#define ACLASS
#else
#define ACLASS extern
#endif

extern "C" {

    ACLASS int MyDbgPrint(LPCSTR lpszFormat, IN ...);
    ACLASS int MyDbgPuts(LPCSTR lpszMsg);

    ACLASS inline int ClockDiff(
        LARGE_INTEGER &liNewTick, 
        LARGE_INTEGER &liOldTick
        );

    ACLASS void Log(
        TCHAR * pszMessage,
        DWORD dw,
        DWORD p,
        DWORD s
    );

    ACLASS void DumpLog();
    ACLASS void SimpleHeapCheck(char *pszMsg);
    ACLASS int FillPattern(char *Area, DWORD size, DWORD FillPow2, LPCSTR lpszFormat, IN ...);

}       // extern "C"


#else
    #define SLSH(a)    a##/
    #define XDBGONLY SLSH(/)
    #define XDBG SLSH(/)

    #define INIT_TICKS
    #define BEGIN_TICK
    #define END_TICK
    #define LOG_TICK(msg)
    #define END_LOG_TICK(msg)
    #define MARK_LOG_TICK(msg)      

    #define HEAPCHK(msg)
    #define LOG_MSG_VAL(msg,val,p,s)
#endif  //XTRA_TRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\devenum.h ===
/****************************************************************************
 *  @doc INTERNAL DEVENUM
 *
 *  @module DevEnum.h | Our Devenum exports.
 ***************************************************************************/

#ifndef _DEVENUM_H_
#define _DEVENUM_H_

#define VIDEOAPI EXTERN_C __declspec (dllexport) HRESULT WINAPI

VIDEOAPI GetVideoCapDeviceInfo(IN DWORD dwDeviceIndex, OUT PDEVICEINFO pDeviceInfo);
VIDEOAPI GetNumVideoCapDevices(OUT PDWORD pdwNumDevices);
EXTERN_C HRESULT WINAPI GetNumVideoCapDevicesInternal(OUT PDWORD pdwNumDevices, IN bool bRecount);
#endif // _DEVENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\dbgxtra.c ===
#ifdef XTRA_TRACE

#include <windows.h>

#include <stdio.h>          //this is only for the _vsnprintf ....
#include <rtutils.h>    //this is for the TraceVprintf ....
#include <process.h>    //for the _getpid

#include "dbgxtra.h"


//==============================================================================================
DWORD MyTraceId;

int MyDbgPrint(LPCSTR lpszFormat, IN ...)
{       int ret;

    va_list arglist;
    va_start(arglist, lpszFormat);

    ret=TraceVprintf(MyTraceId, lpszFormat, arglist);
    va_end(arglist);
    return(ret);
}

int MyDbgPuts(LPCSTR lpszMsg)
{       //this should be even faster than the xxxprintf above...
    return(TracePuts(MyTraceId, lpszMsg));
}


//------------------------
HANDLE h_mut1=NULL;
//------------------------

LARGE_INTEGER g_liFreq;
LARGE_INTEGER g_liTicks;

inline int ClockDiff(
    LARGE_INTEGER &liNewTick, 
    LARGE_INTEGER &liOldTick
    )
{
    return (DWORD)((liNewTick.QuadPart - liOldTick.QuadPart) 
        * 1e6 / g_liFreq.QuadPart);
}

typedef struct LOGITEM
{
    TCHAR * pszMessage;
    DWORD   dw;
    DWORD   p;
    DWORD   s;

} LOGITEM;

const DWORD LOG_BUFFER_MASK = 0x3ff;
const DWORD LOG_BUFFER_SIZE = LOG_BUFFER_MASK + 1;

LOGITEM g_LogBuffer[LOG_BUFFER_SIZE];
DWORD g_dwCurrentLogItem = LOG_BUFFER_SIZE; //this will be decr. before use
                                            //start from top and go down
DWORD g_dwTotalItems = 0;

void Log(
    TCHAR * pszMessage,
    DWORD dw,
    DWORD p,
    DWORD s
)
{       DWORD ret;

        //5 min. timeout, just in case
        if((h_mut1==NULL) || (ret=WaitForSingleObject(h_mut1, 300000))==WAIT_TIMEOUT || ret==WAIT_FAILED) {
        MyDbgPrint("Log:   ERROR: Wait on Log mutex: h_mut1=0x%x, ret=0x%x", h_mut1, ret);
        return;
                }

    // Access the shared resource.
    if (g_dwTotalItems < LOG_BUFFER_SIZE) 
        g_dwTotalItems ++;

    g_dwCurrentLogItem = ((g_dwCurrentLogItem - 1) & LOG_BUFFER_MASK);

    g_LogBuffer[g_dwCurrentLogItem].pszMessage = pszMessage;
    g_LogBuffer[g_dwCurrentLogItem].dw = dw;
    g_LogBuffer[g_dwCurrentLogItem].p  = p;
    g_LogBuffer[g_dwCurrentLogItem].s  = s;

        MyDbgPrint("%d,%p,%x:%s\n",dw,p,s,pszMessage);

        ReleaseMutex(h_mut1);

}

void DumpLog()
{
        DWORD ret;


        //5 min. timeout, just in case
        if((h_mut1==NULL) || (ret=WaitForSingleObject(h_mut1, 300000))==WAIT_TIMEOUT || ret==WAIT_FAILED) {
        MyDbgPrint("Log:   ERROR: Wait on Log mutex: h_mut1=0x%x, ret=0x%x", h_mut1, ret);
        return;
                }
    // Access the shared resource.

    for (DWORD i = g_dwCurrentLogItem; i < g_dwTotalItems; i ++)
    {
        MyDbgPrint("%40ws%14d %p %x\n", 
            g_LogBuffer[i].pszMessage,
            g_LogBuffer[i].dw,
            g_LogBuffer[i].p,
            g_LogBuffer[i].s
            );
    }

    for (i = 0; i < g_dwCurrentLogItem; i ++)
    {
        MyDbgPrint("%40ws%14d %p %x\n", 
            g_LogBuffer[i].pszMessage,
            g_LogBuffer[i].dw,
            g_LogBuffer[i].p,
            g_LogBuffer[i].s
            );
    }

        ReleaseMutex(h_mut1);
}

void SimpleHeapCheck(char *pszMsg)
{       char *p, *res="Ok";
        int sz;

    //FX_ENTRY("SimpleHeapCheck");
    sz=128+(rand()%10)*1024;
        if((p=new char[sz])==NULL)
        {
        MyDbgPrint("SimpleHeapCheck:   ERROR: Memory full\n");
        res="Er";
        }
        else {
                memset(p, '#', sz);
                delete[] p;
        }
        if(pszMsg==NULL) {
                pszMsg="";
                }
        MyDbgPrint("%s: %s",res,pszMsg);
        Log("HeapCheck",(DWORD)pszMsg,(DWORD)p,sz);
}

//int _vsnprintf( char *buffer, size_t count, const char *format, va_list argptr );
#define MAXFILLPATL      (1<<6)
#define DEFFILLPOW2     6
//#define FILLPATL      (1<<FILLPOW2)
//#define FILLMASK      FILLPATL-1

int FillPattern(char *Area, DWORD size, DWORD FillPow2, LPCSTR lpszFormat, IN ...)
{       DWORD ret, rem=0,quot,i;
        char *p;
        char buf[MAXFILLPATL];
        int patl;
        int fillmask;

    va_list arglist;
    va_start(arglist, lpszFormat);

        if(FillPow2>6 || FillPow2==0) FillPow2=DEFFILLPOW2;     //default
        else
        if(FillPow2<4) FillPow2=4;

        patl=(1<<FillPow2);
        fillmask=patl-1;
        
        memset(buf,'.',patl);
        _vsnprintf(buf,patl,lpszFormat,arglist);
        rem = size >>FillPow2;  //rem= size/patl;
        quot= size & fillmask;  //quot = size%patl;

    //-- just in case, guard the filling operation against concurency ...
        //5 min. timeout, just in case
        if((h_mut1==NULL) || (ret=WaitForSingleObject(h_mut1, 300000))==WAIT_TIMEOUT || ret==WAIT_FAILED) {
        MyDbgPrint("Log:   ERROR: Wait on Log mutex: h_mut1=0x%x, ret=0x%x", h_mut1, ret);
        return(0);
                }
    // Access the shared resource.

        for(p=Area, i=0;i<rem;p+=patl, i++)
                memcpy(p,buf,patl);
        memcpy(p,buf,quot);

        ReleaseMutex(h_mut1);

        return(rem);
}


//CRC32 table (polynomial 04c11db7)
unsigned long crc32_table[256]={
0x00000000,0x77073096,0xee0e612c,0x990951ba,0x076dc419,0x706af48f,0xe963a535,0x9e6495a3,
0x0edb8832,0x79dcb8a4,0xe0d5e91e,0x97d2d988,0x09b64c2b,0x7eb17cbd,0xe7b82d07,0x90bf1d91,
0x1db71064,0x6ab020f2,0xf3b97148,0x84be41de,0x1adad47d,0x6ddde4eb,0xf4d4b551,0x83d385c7,
0x136c9856,0x646ba8c0,0xfd62f97a,0x8a65c9ec,0x14015c4f,0x63066cd9,0xfa0f3d63,0x8d080df5,
0x3b6e20c8,0x4c69105e,0xd56041e4,0xa2677172,0x3c03e4d1,0x4b04d447,0xd20d85fd,0xa50ab56b,
0x35b5a8fa,0x42b2986c,0xdbbbc9d6,0xacbcf940,0x32d86ce3,0x45df5c75,0xdcd60dcf,0xabd13d59,
0x26d930ac,0x51de003a,0xc8d75180,0xbfd06116,0x21b4f4b5,0x56b3c423,0xcfba9599,0xb8bda50f,
0x2802b89e,0x5f058808,0xc60cd9b2,0xb10be924,0x2f6f7c87,0x58684c11,0xc1611dab,0xb6662d3d,
0x76dc4190,0x01db7106,0x98d220bc,0xefd5102a,0x71b18589,0x06b6b51f,0x9fbfe4a5,0xe8b8d433,
0x7807c9a2,0x0f00f934,0x9609a88e,0xe10e9818,0x7f6a0dbb,0x086d3d2d,0x91646c97,0xe6635c01,
0x6b6b51f4,0x1c6c6162,0x856530d8,0xf262004e,0x6c0695ed,0x1b01a57b,0x8208f4c1,0xf50fc457,
0x65b0d9c6,0x12b7e950,0x8bbeb8ea,0xfcb9887c,0x62dd1ddf,0x15da2d49,0x8cd37cf3,0xfbd44c65,
0x4db26158,0x3ab551ce,0xa3bc0074,0xd4bb30e2,0x4adfa541,0x3dd895d7,0xa4d1c46d,0xd3d6f4fb,
0x4369e96a,0x346ed9fc,0xad678846,0xda60b8d0,0x44042d73,0x33031de5,0xaa0a4c5f,0xdd0d7cc9,
0x5005713c,0x270241aa,0xbe0b1010,0xc90c2086,0x5768b525,0x206f85b3,0xb966d409,0xce61e49f,
0x5edef90e,0x29d9c998,0xb0d09822,0xc7d7a8b4,0x59b33d17,0x2eb40d81,0xb7bd5c3b,0xc0ba6cad,
0xedb88320,0x9abfb3b6,0x03b6e20c,0x74b1d29a,0xead54739,0x9dd277af,0x04db2615,0x73dc1683,
0xe3630b12,0x94643b84,0x0d6d6a3e,0x7a6a5aa8,0xe40ecf0b,0x9309ff9d,0x0a00ae27,0x7d079eb1,
0xf00f9344,0x8708a3d2,0x1e01f268,0x6906c2fe,0xf762575d,0x806567cb,0x196c3671,0x6e6b06e7,
0xfed41b76,0x89d32be0,0x10da7a5a,0x67dd4acc,0xf9b9df6f,0x8ebeeff9,0x17b7be43,0x60b08ed5,
0xd6d6a3e8,0xa1d1937e,0x38d8c2c4,0x4fdff252,0xd1bb67f1,0xa6bc5767,0x3fb506dd,0x48b2364b,
0xd80d2bda,0xaf0a1b4c,0x36034af6,0x41047a60,0xdf60efc3,0xa867df55,0x316e8eef,0x4669be79,
0xcb61b38c,0xbc66831a,0x256fd2a0,0x5268e236,0xcc0c7795,0xbb0b4703,0x220216b9,0x5505262f,
0xc5ba3bbe,0xb2bd0b28,0x2bb45a92,0x5cb36a04,0xc2d7ffa7,0xb5d0cf31,0x2cd99e8b,0x5bdeae1d,
0x9b64c2b0,0xec63f226,0x756aa39c,0x026d930a,0x9c0906a9,0xeb0e363f,0x72076785,0x05005713,
0x95bf4a82,0xe2b87a14,0x7bb12bae,0x0cb61b38,0x92d28e9b,0xe5d5be0d,0x7cdcefb7,0x0bdbdf21,
0x86d3d2d4,0xf1d4e242,0x68ddb3f8,0x1fda836e,0x81be16cd,0xf6b9265b,0x6fb077e1,0x18b74777,
0x88085ae6,0xff0f6a70,0x66063bca,0x11010b5c,0x8f659eff,0xf862ae69,0x616bffd3,0x166ccf45,
0xa00ae278,0xd70dd2ee,0x4e048354,0x3903b3c2,0xa7672661,0xd06016f7,0x4969474d,0x3e6e77db,
0xaed16a4a,0xd9d65adc,0x40df0b66,0x37d83bf0,0xa9bcae53,0xdebb9ec5,0x47b2cf7f,0x30b5ffe9,
0xbdbdf21c,0xcabac28a,0x53b39330,0x24b4a3a6,0xbad03605,0xcdd70693,0x54de5729,0x23d967bf,
0xb3667a2e,0xc4614ab8,0x5d681b02,0x2a6f2b94,0xb40bbe37,0xc30c8ea1,0x5a05df1b,0x2d02ef8d,
};

// This function uses the above crc32_table lookup table
// to generate a CRC for a buffer
DWORD Buf_CRC32(unsigned char *buffer, DWORD dwSize)
{
        unsigned long crc=0xffffffff;

        while(dwSize--)
                crc = (crc >> 8) ^ crc32_table[(crc & 0xFF) ^ *buffer++];
        return crc^0xffffffff;
}



#endif  //XTRA_TRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\devenum.cpp ===
/****************************************************************************
 *  @doc INTERNAL DEVENUM
 *
 *  @module DevEnum.cpp | Source file for the <c CTAPIVCap> class methods
 *    used to implement the <i IVideoDeviceControl> interface.
 ***************************************************************************/

#include "Precomp.h"
#include "CritSec.h"
#include <atlbase.h>
#include <streams.h>
#include "..\..\audio\tpaudcap\crossbar.h"
#include <initguid.h>

#ifdef DEBUG
  #include <stdio.h>
  #include <stdarg.h>

  static int dprintf( char * format, ... )
  {
      char out[1024];
      int r;
      va_list marker;
      va_start(marker, format);
      r=_vsnprintf(out, 1022, format, marker);
      va_end(marker);
      OutputDebugString( out );
      return r;
  }

  static int dout( int console, DWORD id, DWORD code, char * format, ... )
  {
      char out[1024];
      int r;
      va_list marker;
      va_start(marker, format);
      r=_vsnprintf(out, 1022, format, marker);
      va_end(marker);
      if(console) {
        OutputDebugString( out );
        OutputDebugString("\n");
      }
      DBGOUT((id, code, "%s", out));
      return r;
  }


#else
  #define dprintf ; / ## /
  #define dout ; / ## /
#endif


static const char g_szVfWToWDMMapperDescription[] = "VfW MM 16bit Driver for WDM V. Cap. Devices";
static const char g_szVfWToWDMMapperDescription2[] = "Microsoft WDM Image Capture";
static const char g_szVfWToWDMMapperDescription3[] = "Microsoft WDM Image Capture (Win32)";
static const char g_szVfWToWDMMapperDescription4[] = "WDM Video For Windows Capture Driver (Win32)";
static const char g_szVfWToWDMMapperDescription5[] = "VfWWDM32.dll";
static const char g_szMSOfficeCamcorderDescription[] = "Screen Capture Device Driver for AVI";
static const char g_szHauppaugeDll[] = "o100vc.dll";

// documented name for DV cameras. won't be changed/localized
static const char g_szDVCameraFriendlyName[] = "Microsoft DV Camera and VCR";

static const TCHAR sznSVideo[] = TEXT("nSVideo");
static const TCHAR sznComposite[] = TEXT("nComposite");

/****************************************************************************
 *  @doc INTERNAL CDEVENUMFUNCTION
 *
 *  @func HRESULT | GetNumCapDevices | This method is used to
 *    compute the number of installed capture devices. This is
 * just a wrapper around the GetNumCapDevicesInternal version,
 * calling it with bRecount TRUE to force a device recount
 *****************************************************************************/
VIDEOAPI GetNumVideoCapDevices(OUT PDWORD pdwNumDevices)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("GetNumVideoCapDevices")
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        Hr = GetNumVideoCapDevicesInternal(pdwNumDevices,  TRUE);

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}


// !!! this function is duplicated in audio code
//
HRESULT FindAPin(IBaseFilter *pf, PIN_DIRECTION dir, int iIndex, IPin **ppPin)
{
    IPin *pP, *pTo = NULL;
    DWORD dw;
    IEnumPins *pins = NULL;
    PIN_DIRECTION pindir;
    BOOL fFound = FALSE;
    HRESULT hr = pf->EnumPins(&pins);

    while (hr == NOERROR) {
        hr = pins->Next(1, &pP, &dw);
        if (hr == S_OK && dw == 1) {
            hr = pP->QueryDirection(&pindir);
            if (hr == S_OK && pindir == dir && (iIndex-- == 0)) {
                fFound = TRUE;
                break;
            } else  {
                pP->Release();
            }
        } else {
            break;
        }
    }
    if (pins)
        pins->Release();

    if (fFound) {
        *ppPin = pP;
        return NOERROR;
    } else {
        return E_FAIL;
    }
}

DEFINE_GUID(IID_IAMFilterData, 0x97f7c4d4, 0x547b, 0x4a5f, 0x83, 0x32, 0x53, 0x64, 0x30, 0xad, 0x2e, 0x4d);

MIDL_INTERFACE("97f7c4d4-547b-4a5f-8332-536430ad2e4d")
IAMFilterData : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE ParseFilterData(
        /* [size_is][in] */ BYTE __RPC_FAR *rgbFilterData,
        /* [in] */ ULONG cb,
        /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbRegFilter2) = 0;

    virtual HRESULT STDMETHODCALLTYPE CreateFilterData(
        /* [in] */ REGFILTER2 __RPC_FAR *prf2,
        /* [out] */ BYTE __RPC_FAR *__RPC_FAR *prgbFilterData,
        /* [out] */ ULONG __RPC_FAR *pcb) = 0;

};

// the next 4 functions create/open the camera reg key and return the handle;
// make sure the handle is RegClose'ed when not needed anymore
HKEY MakeRegKeyAndReturnHandle(char *szDeviceDescription, char *szDeviceVersion, HKEY root_key, char *base_key)
{

    HKEY    hDeviceKey = NULL;
    HKEY    hKey = NULL;
    DWORD   dwSize;
    char    szKey[MAX_PATH + MAX_VERSION + 2];
    DWORD   dwDisposition;

    FX_ENTRY("MakeRegKeyAndReturnHandle")

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    // Open the main capture devices key, or create it if it doesn't exist
    if (RegCreateKeyEx(root_key, base_key, 0, 0, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hDeviceKey, &dwDisposition) == ERROR_SUCCESS)
    {
        // If we have version info use that to build the key name
        // @todo VCMSTRM.cpp does some weird things with the name - probably due to bogus device
        // Repro this code
        ASSERT(lstrlen(szDeviceDescription)+1<MAX_CAPDEV_DESCRIPTION); // actually #define MAX_CAPDEV_DESCRIPTION MAX_PATH
        ASSERT(lstrlen(szDeviceVersion)+1<MAX_VERSION);
        // in the only case where this function is used, it is called with the 2 strings above that are limited at retrieval time
        // (see GetNumVideoCapDevicesInternal), but just in case, since this could be called with any strings
        if (szDeviceVersion && *szDeviceVersion != '\0')
            wsprintf(szKey, "%s, %s", szDeviceDescription, szDeviceVersion);
        else
            wsprintf(szKey, "%s", szDeviceDescription);

        // Check if there is already a key for the current device
        // Open the key for the current device, or create the key if it doesn't exist
        if (RegCreateKeyEx(hDeviceKey, szKey, 0, 0, REG_OPTION_NON_VOLATILE, KEY_READ|KEY_WRITE, NULL, &hKey, &dwDisposition) != ERROR_SUCCESS)
        {
            DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Can't create registry key!", _fx_));
        }

    }

    if (hDeviceKey)
        RegCloseKey(hDeviceKey);

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end (returning %lx)", _fx_, (DWORD)hKey));
    //if something failed, hKey would be still NULL at this point
    return hKey;
}

HKEY MakeRegKeyAndReturnHandleByIndex(DWORD dwDeviceIndex, HKEY root_key, char *base_key)
{
    return MakeRegKeyAndReturnHandle(g_aDeviceInfo[dwDeviceIndex].szDeviceDescription,g_aDeviceInfo[dwDeviceIndex].szDeviceVersion,root_key,base_key);
}


HKEY GetRegKeyHandle(char *szDeviceDescription, char *szDeviceVersion, HKEY root_key, char *base_key)
{
    char    szKey[MAX_PATH + MAX_VERSION + 2];
    HKEY    hRTCDeviceKey  = NULL;
    HKEY    hKey = NULL;


    FX_ENTRY("GetRegKeyHandle")

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    // Check if the RTC  key is there
    if (RegOpenKey(root_key, base_key, &hRTCDeviceKey) == ERROR_SUCCESS)
    {

        ASSERT(lstrlen(szDeviceDescription)+1<MAX_CAPDEV_DESCRIPTION); // actually #define MAX_CAPDEV_DESCRIPTION MAX_PATH
        ASSERT(lstrlen(szDeviceVersion)+1<MAX_VERSION);
        // in the only case where this function is used, it is called with the 2 strings above that are limited at retrieval time
        // (see GetNumVideoCapDevicesInternal), but just in case, since this could be called with any strings
        if (szDeviceVersion && *szDeviceVersion != '\0')
            wsprintf(szKey, "%s, %s", szDeviceDescription, szDeviceVersion);
        else
            wsprintf(szKey, "%s", szDeviceDescription);

        // Check if there is already an RTC key for our device
        if (RegOpenKey(hRTCDeviceKey, szKey, &hKey) != ERROR_SUCCESS)
        {
            // Try again without the version information
            if (szDeviceVersion && *szDeviceVersion != '\0')
            {
                wsprintf(szKey, "%s", szDeviceDescription);
                RegOpenKey(hRTCDeviceKey, szKey, &hKey);
            }
        }
    }


    if (hRTCDeviceKey)
        RegCloseKey(hRTCDeviceKey);

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end (returning %lx)", _fx_, (DWORD)hKey));

    //if something failed, hKey would be still NULL at this point
    return hKey;

}


HKEY GetRegKeyHandleByIndex(DWORD dwDeviceIndex, HKEY root_key, char *base_key)
{
    return GetRegKeyHandle(g_aDeviceInfo[dwDeviceIndex].szDeviceDescription,g_aDeviceInfo[dwDeviceIndex].szDeviceVersion,root_key,base_key);
}


// should this device be handled by the new DShow video capture object?  DV and devices with crossbars do not work with
// the old handlers.
//
// returns 1 for TV device
// returns 2 for DV device
// returns 0 for neither
//
BOOL IsDShowDevice(IMoniker *pM, IPropertyBag *pPropBag, DWORD dwDeviceIndex)
{
    HRESULT hr;
    VARIANT var;
    CComPtr<IBaseFilter> pFilter;
    CComPtr<IPin> pPin;
    CComPtr<IBindCtx> pBC;
    ULONG ul;
    var.vt = VT_BSTR;

    HKEY hKey=NULL;
    DWORD dwSize = sizeof(DWORD);
    DWORD  dwDoNotUseDShow=0;

    FX_ENTRY("IsDShowDevice")

    // easy way to tell if it's a DV device

    if(lstrcmp(g_aDeviceInfo[dwDeviceIndex].szDeviceDescription, g_szDVCameraFriendlyName) == 0)
    {
      // Description string (e.g., Panasonic DV Device) preferred if available (WinXP)
        if ((hr = pPropBag->Read(L"Description", &var, 0)) == S_OK)
        {
            WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1, g_aDeviceInfo[dwDeviceIndex].szDeviceDescription, MAX_PATH, 0, 0);
            SysFreeString(var.bstrVal);
        }

        return 2;
    }

    // WinSE #28804, regarding Sony MPEG2 R-Engine devices
    // the code below looks for the SOFTWARE\Microsoft\RTC\VideoCapture\Sony MPEG2 R-Engine\DoNotUseDShow key
    // (the 'Sony MPEG2 R-Engine' component of the name path above could have version numbers appended)

    //hard-coded name: SONY_MOTIONEYE_CAM_NAME
    dprintf("%s: Comparing %s : %s ...\n", _fx_,g_aDeviceInfo[dwDeviceIndex].szDeviceDescription,SONY_MOTIONEYE_CAM_NAME);
    if(lstrcmp(g_aDeviceInfo[dwDeviceIndex].szDeviceDescription,SONY_MOTIONEYE_CAM_NAME)==0)    // for a SONY Motion Eye camera ...
    {

        if((hKey = MakeRegKeyAndReturnHandleByIndex(dwDeviceIndex, RTCKEYROOT, szRegRTCKey)) != NULL)     // after creating camera key ...
        {                                                                                                 // ... (or if already existed)
              LONG err;
              if((err=RegQueryValueEx(hKey, (LPTSTR)szRegdwDoNotUseDShow, NULL, NULL, (LPBYTE)&dwDoNotUseDShow, &dwSize)) != ERROR_SUCCESS)
              {                                                                                           // if the value does not exist ...
                  dprintf("%s: RegQueryValueEx err = %#08x\n", _fx_,err);
                  dwSize = sizeof(DWORD);
                  dwDoNotUseDShow=1;                                                                      // set it on 1
                  RegSetValueEx(hKey, (LPTSTR)szRegdwDoNotUseDShow, (DWORD)NULL, REG_DWORD, (LPBYTE)&dwDoNotUseDShow, dwSize);
                  //don't care if it fails; in that case the default will be used (1 if we got to this point anyway...)
                  dprintf("%s: MOTION EYE CAM detected: REG Key %s set to %d ...\n", _fx_,szRegdwDoNotUseDShow,dwDoNotUseDShow);
              }
              RegCloseKey(hKey); hKey = NULL;
        }
    }
    else
    // now, independently of the code above, for any other cameras, check the DoNotUseDShow value, if any
    // (so the value path is: SOFTWARE\Microsoft\RTC\VideoCapture\<camera_name>\DoNotUseDShow)
    {

        if((hKey = GetRegKeyHandleByIndex(dwDeviceIndex, RTCKEYROOT, szRegRTCKey)) != NULL)
        {
              dwSize = sizeof(DWORD);
              RegQueryValueEx(hKey, (LPTSTR)szRegdwDoNotUseDShow, NULL, NULL, (LPBYTE)&dwDoNotUseDShow, &dwSize);
              //don't care if it fails; in that case the default will be used (1 if is a SONY Mot.Eye, 0 otherwise)
              RegCloseKey(hKey); hKey = NULL;
        }
    }
    // if the above code managed to set something non-zero for this, do not use DShow -- simply return 0
    if(dwDoNotUseDShow!=0)
        return 0;

    // END FIX WinSE #28804

    // See if it has an input pin.  That is only true for TV/DV devices.
    // Anything else will use the old code path for safety.


    IAMFilterData *pfd;
    hr = CoCreateInstance(CLSID_FilterMapper, NULL, CLSCTX_INPROC_SERVER,
                        IID_IAMFilterData, (void **)&pfd);
    if (FAILED(hr))
        return FALSE;   // OOM

    BOOL fDShow = FALSE;
    VARIANT varFilData;
    varFilData.vt = VT_UI1 | VT_ARRAY;
    varFilData.parray = 0; // docs say zero this
    BYTE *pbFilterData = NULL;
    DWORD dwcbFilterData = 0;

    hr = pPropBag->Read(L"FilterData", &varFilData, 0);
    if(SUCCEEDED(hr))
    {
        ASSERT(varFilData.vt == (VT_UI1 | VT_ARRAY));
        dwcbFilterData = varFilData.parray->rgsabound[0].cElements;

        hr = SafeArrayAccessData(varFilData.parray, (void **)&pbFilterData);
        ASSERT(hr == S_OK);
        ASSERT(pbFilterData);

        if(SUCCEEDED(hr))
        {
            BYTE *pb;
            hr = pfd->ParseFilterData(pbFilterData, dwcbFilterData, &pb);
            if(SUCCEEDED(hr))
            {
                REGFILTER2 *pFil = ((REGFILTER2 **)pb)[0];
                if (pFil->dwVersion == 2) {
                    for (ULONG zz=0; zz<pFil->cPins2; zz++) {
                        const REGFILTERPINS2 *pPin = pFil->rgPins2 + zz;

                        // a capture filter with an input pin that isn't
                        // rendered has extra goo, like crossbars or tv tuners
                        // so we need to talk to it with the DShow class
                        if (!(pPin->dwFlags & REG_PINFLAG_B_OUTPUT) &&
                            !(pPin->dwFlags & REG_PINFLAG_B_RENDERER)) {
                            fDShow = TRUE;
                            break;
                        }
                    }
                }
            }
        }

        if(pbFilterData)
        {
            hr = SafeArrayUnaccessData(varFilData.parray);
            ASSERT(hr == S_OK);
        }
        hr = VariantClear(&varFilData);
        ASSERT(hr == S_OK);
    }

    pfd->Release();
    return fDShow;
}



// for a TV tuner device, return how many SVideo and Composite inputs there are
//
HRESULT GetInputTypes(IMoniker *pM, DWORD dwIndex, DWORD *pnSVideo, DWORD *pnComposite)
{
    CheckPointer(pnSVideo, E_POINTER);
    CheckPointer(pnComposite, E_POINTER);
    *pnSVideo = *pnComposite = 0;

    HKEY    hDeviceKey  = NULL;
    HKEY    hKey = NULL;
    char    szKey[MAX_PATH + MAX_VERSION + 2];
    BOOL fNotFound = TRUE;
    DWORD dwSize;

    // If we have version info use that to build the key name
    if (g_aDeviceInfo[dwIndex].szDeviceVersion &&
            g_aDeviceInfo[dwIndex].szDeviceVersion[0] != '\0') {
        wsprintf(szKey, "%s, %s",
                g_aDeviceInfo[dwIndex].szDeviceDescription,
                g_aDeviceInfo[dwIndex].szDeviceVersion);
    } else {
        wsprintf(szKey, "%s", g_aDeviceInfo[dwIndex].szDeviceDescription);
    }

    // Open the RTC key
    DWORD dwDisp;
    RegOpenKey(RTCKEYROOT, szRegRTCKey, &hDeviceKey);

    // Check if there already is an RTC key for the current device
    if (hDeviceKey) {
        if (RegOpenKey(hDeviceKey, szKey, &hKey) != ERROR_SUCCESS) {

            // Try again without the version information
            wsprintf(szKey, "%s", g_aDeviceInfo[dwIndex].szDeviceDescription);
            RegOpenKey(hDeviceKey, szKey, &hKey);
        }
    }

    if (hKey) {
        dwSize = sizeof(DWORD);
        LONG l = RegQueryValueEx(hKey, sznSVideo, NULL, NULL, (LPBYTE)pnSVideo, &dwSize);
        if (l == 0) {
            l = RegQueryValueEx(hKey, sznComposite, NULL, NULL, (LPBYTE)pnComposite, &dwSize);
        }
        if (l == 0) {
            fNotFound = FALSE;  // found it in the registry
        }
    }

    // This info is not in the registry.  Take the time to figure it out and
    // put it in the registry.  There may not be a place yet to put it in
    // the registry.  If not, don't make a place for it, you'll mess up
    // other code that reads the registry and assumes the key existing means
    // it's filled with other useful info
    if (fNotFound) {
        CComPtr<IBindCtx> pBC;
        CComPtr<IBaseFilter> pFilter;
        CComPtr<IPin> pPin;
        CComPtr<ICaptureGraphBuilder2> pCGB;
        CComPtr<IAMStreamConfig> pSC;
        CComPtr<IGraphBuilder> pGB;
        if (SUCCEEDED(CreateBindCtx(0, &pBC))) {
            if (SUCCEEDED(pM->BindToObject(pBC, NULL, IID_IBaseFilter,
                                                    (void **)&pFilter))) {
                CoCreateInstance(CLSID_CaptureGraphBuilder2, NULL, CLSCTX_INPROC_SERVER,
                              IID_ICaptureGraphBuilder2, (void **)&pCGB);
                CoCreateInstance(CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER,
                              IID_IGraphBuilder, (void **)&pGB);
                if (pGB && pCGB && SUCCEEDED(pCGB->FindPin(pFilter, PINDIR_INPUT,
                            &PIN_CATEGORY_ANALOGVIDEOIN, NULL, FALSE, 0, &pPin))) {

                    // force building the upstream graph for crossbar to work
                    pGB->AddFilter(pFilter, DBGNAME("capture"));
                    pCGB->SetFiltergraph(pGB);
                    pCGB->FindInterface(&PIN_CATEGORY_CAPTURE, NULL, pFilter,
                                        IID_IAMStreamConfig, (void **)&pSC);

                    LONG cInputs = 0;
                    CCrossbar *pCrossbar = new CCrossbar(pPin);
                    if (pCrossbar) {
                        pCrossbar->GetInputCount(&cInputs);
                        LONG  PhysicalType;
                        for (LONG j = 0; j < cInputs; j++) {
                            EXECUTE_ASSERT(S_OK == pCrossbar->GetInputType(j, &PhysicalType));

                            if (PhysicalType == PhysConn_Video_Composite) {
                                (*pnComposite)++;
                            } else if (PhysicalType == PhysConn_Video_SVideo) {
                                (*pnSVideo)++;
                            }
                        }
                        delete pCrossbar;
                    }
                }
            }
        }

        // If there are NO inputs, this is hopefully a device that the old code could handle.
        // Return S_FALSE to not use the DShow handler.  For the Sony EyeCam it had worse
        // perf anyway for some mysterious reason
        if (*pnSVideo + *pnComposite == 0) {
            if (hKey) {
                RegCloseKey(hKey);
            }
            if (hDeviceKey) {
                RegCloseKey(hDeviceKey);
            }
            return S_FALSE;
        }

        if (hKey) {
            dwSize = sizeof(DWORD);
            RegSetValueEx(hKey, sznSVideo, (DWORD)NULL, REG_DWORD,
                                    (LPBYTE)pnSVideo, dwSize);
            RegSetValueEx(hKey, sznComposite, (DWORD)NULL, REG_DWORD,
                                    (LPBYTE)pnComposite, dwSize);
        }
    }

    if (hKey) {
        RegCloseKey(hKey);
    }
    if (hDeviceKey) {
        RegCloseKey(hDeviceKey);
    }

    return S_OK;
}


// duplicate this capture device entry several times, once for each input it has
// (eg 2 SVideo inputs and 3 Comp inputs)
HRESULT CloneDevice(DWORD dwIndex, DWORD nSVideo, DWORD nComposite)
{
    char c[4];

    // !!! run out of array space in g_aDeviceInfo?

    // if there's only 1 input on this card, we don't need to clone it
    if (nSVideo + nComposite <= 1)
        return S_OK;

    // start by modifying the suffix on the entry that already exists
    DWORD dw = dwIndex;
    int len = lstrlenA(g_aDeviceInfo[dw].szDeviceDescription);
    for (DWORD j = 0; j < nSVideo + nComposite; j++) {
        if (dw != dwIndex) {
            g_aDeviceInfo[dw].nDeviceType = g_aDeviceInfo[dwIndex].nDeviceType;
            g_aDeviceInfo[dw].nCaptureMode = g_aDeviceInfo[dwIndex].nCaptureMode;
            g_aDeviceInfo[dw].dwVfWIndex = g_aDeviceInfo[dwIndex].dwVfWIndex;
            g_aDeviceInfo[dw].fHasOverlay = g_aDeviceInfo[dwIndex].fHasOverlay;
            g_aDeviceInfo[dw].fInUse = g_aDeviceInfo[dwIndex].fInUse;
            lstrcpyA(g_aDeviceInfo[dw].szDeviceVersion,
                        g_aDeviceInfo[dwIndex].szDeviceVersion);
            lstrcpyA(g_aDeviceInfo[dw].szDevicePath,
                        g_aDeviceInfo[dwIndex].szDevicePath);
            lstrcpynA(g_aDeviceInfo[dw].szDeviceDescription,
                    g_aDeviceInfo[dwIndex].szDeviceDescription, len + 1);
            dwIndex++;
        }
        if (j < nSVideo) {
            lstrcatA(g_aDeviceInfo[dw].szDeviceDescription, g_szSVideo);
            if (nSVideo > 1) {
                wsprintf(c, "%u", j+1);
                lstrcatA(g_aDeviceInfo[dw].szDeviceDescription, c);
            }
        } else {
            lstrcatA(g_aDeviceInfo[dw].szDeviceDescription, g_szComposite);
            if (nComposite > 1) {
                wsprintf(c, "%u", j-nSVideo+1);
                lstrcatA(g_aDeviceInfo[dw].szDeviceDescription, c);
            }
        }
        dw = dwIndex + 1;
    }

    return S_OK;
}


/****************************************************************************
 *  @doc INTERNAL CDEVENUMFUNCTION
 *
 *  @func HRESULT | GetNumCapDevicesInternal | This method is used to
 *    determine the number of installed capture devices. This number includes
 *    only enabled devices.
 *
 *  @parm PDWORD | pdwNumDevices | Specifies a pointer to a DWORD to receive
 *    the number of installed capture devices.
 *
 *  @parm bool | bRecount | Specifies if a device recount is needed
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 *
 *      @devnote MSDN references:
 *    DirectX 5, DirectX Media, DirectShow, Application Developer's Guide
 *    "Enumerate and Access Hardware Devices in DirectShow Applications"
 ***************************************************************************/
EXTERN_C HRESULT WINAPI GetNumVideoCapDevicesInternal(OUT PDWORD pdwNumDevices,  bool bRecount)
{
    HRESULT Hr = NOERROR;
    DWORD dwDeviceIndex;
    DWORD dwVfWIndex;
    ICreateDevEnum *pCreateDevEnum;
    IEnumMoniker *pEm;
    ULONG cFetched;
    DWORD dwNumVfWDevices;
    IMoniker *pM;
    IPropertyBag *pPropBag = NULL;
    VARIANT var;

    FX_ENTRY("GetNumVideoCapDevicesInternal")

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    EnterCriticalSection (&g_CritSec);

    // Validate input parameters
    ASSERT(pdwNumDevices);
    if (!pdwNumDevices)
    {
            DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
            Hr = E_POINTER;
            goto MyExit;
    }

    // If a recount has been requested by setting bRecount TRUE (as after a PNP change, see bug 95766),
    // force a recount in the next if

    // Count the number of VfW capture devices
    if (g_dwNumDevices == (DWORD)-1 || bRecount)
    {

        if (videoGetNumDevs(FALSE))     // FALSE means don't free the list after counting ...
        {
            dprintf("%s: MAX_CAPTURE_DEVICES = %d\n", _fx_,MAX_CAPTURE_DEVICES);
            // Remove bogus Camcorder capture device from list of devices shown to the user
            // The Camcorder driver is a fake capture device used by the MS Office Camcorder
            // to capture screen activity to an AVI file. This not a legit capture device driver
            // and is extremely buggy. We also remove the VfW to WDM mapper.
            for (dwDeviceIndex = 0, dwVfWIndex = 0; dwVfWIndex < MAX_CAPTURE_DEVICES; dwVfWIndex++)
            {
                TCHAR   szDllName[MAX_PATH+2];

                dprintf("%s: dwVfWIndex = %d\n", _fx_, dwVfWIndex);
                g_aDeviceInfo[dwDeviceIndex].nDeviceType = DeviceType_VfW;
                g_aDeviceInfo[dwDeviceIndex].nCaptureMode = CaptureMode_FrameGrabbing;
                g_aDeviceInfo[dwDeviceIndex].dwVfWIndex = dwVfWIndex;
                g_aDeviceInfo[dwDeviceIndex].fHasOverlay = FALSE;
                g_aDeviceInfo[dwDeviceIndex].fInUse = FALSE;
                if (videoCapDriverDescAndVer(dwVfWIndex, g_aDeviceInfo[dwDeviceIndex].szDeviceDescription, MAX_CAPDEV_DESCRIPTION, g_aDeviceInfo[dwDeviceIndex].szDeviceVersion, MAX_CAPDEV_VERSION, szDllName, MAX_PATH))
                {
                    dout(3,g_dwVideoCaptureTraceID, TRCE, "%s:   WARNING: videoCapDriverDescAndVer(dwVfWIndex=%lu) failed", _fx_,dwVfWIndex);
                        // We shouldn't use this device if we can't get any info from it
                        continue;
                }
                if (!lstrcmp(g_aDeviceInfo[dwDeviceIndex].szDeviceDescription, g_szMSOfficeCamcorderDescription) ||
                        !lstrcmpi(szDllName,TEXT("vfwwdm32.dll")) ||      // ignore VfWWDM in enumeration
                        !lstrcmp(g_aDeviceInfo[dwDeviceIndex].szDeviceDescription, g_szVfWToWDMMapperDescription) ||
                        !lstrcmp(g_aDeviceInfo[dwDeviceIndex].szDeviceDescription, g_szVfWToWDMMapperDescription2) ||
                        !lstrcmp(g_aDeviceInfo[dwDeviceIndex].szDeviceDescription, g_szVfWToWDMMapperDescription3) ||
                        !lstrcmp(g_aDeviceInfo[dwDeviceIndex].szDeviceDescription, g_szVfWToWDMMapperDescription4) ||
                            !lstrcmp(g_aDeviceInfo[dwDeviceIndex].szDeviceDescription, g_szVfWToWDMMapperDescription5)
                          //!lstrcmpi(g_aDeviceInfo[dwDeviceIndex].szDeviceDescription, g_szHauppaugeDll)
                            )
                {
                        dout(3,g_dwVideoCaptureTraceID, TRCE, "%s:   WARNING: Removed VfW to WDM mapper or MS Office Bogus capture driver!", _fx_);
                        continue;
                }
                dprintf("GetNumVideoCapDevicesInternal: VfW %d %s\n",dwDeviceIndex, g_aDeviceInfo[dwDeviceIndex].szDeviceDescription);
                dwDeviceIndex++;
            }

            g_dwNumDevices = dwDeviceIndex;

            videoFreeDriverList ();
        }
        else
        {
            g_dwNumDevices = 0UL;
        }

        // First, create a system hardware enumerator
        // This call loads the following DLLs - total 1047 KBytes!!!:
        //   'C:\WINDOWS\SYSTEM\DEVENUM.DLL' = 60 KBytes
        //   'C:\WINDOWS\SYSTEM\RPCRT4.DLL' = 316 KBytes
        //   'C:\WINDOWS\SYSTEM\CFGMGR32.DLL' = 44 KBytes
        //   'C:\WINDOWS\SYSTEM\WINSPOOL.DRV' = 23 KBytes
        //   'C:\WINDOWS\SYSTEM\COMDLG32.DLL' = 180 KBytes
        //   'C:\WINDOWS\SYSTEM\LZ32.DLL' = 24 KBytes
        //   'C:\WINDOWS\SYSTEM\SETUPAPI.DLL' = 400 KBytes
        // According to LonnyM, there's no way to go around SETUPAPI.DLL
        // when dealing with PnP device interfaces....
        if (FAILED(Hr = CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER, IID_ICreateDevEnum, (void**)&pCreateDevEnum)))
        {
            DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Couldn't create DShow enumerator!", _fx_));
            goto MyError;
        }

        // Second, create an enumerator for a specific type of hardware device: video capture cards only
        //the call below was previously using CDEF_BYPASS_CLASS_MANAGER ... (387796)
        if (FAILED(Hr = pCreateDevEnum->CreateClassEnumerator(CLSID_VideoInputDeviceCategory, &pEm, CDEF_DEVMON_PNP_DEVICE)) || !pEm)
        {
            // try again
            if (FAILED(Hr = pCreateDevEnum->CreateClassEnumerator(CLSID_VideoInputDeviceCategory, &pEm, CDEF_CLASS_DEFAULT)) || !pEm)
            {
                            DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Couldn't create DShow enumerator!", _fx_));
                            goto MyError;
            }
        }

        // Not needed any more
        pCreateDevEnum->Release();
        pCreateDevEnum = NULL;

        // Third, enumerate the list of WDM capture devices itself
        if (FAILED(Hr = pEm->Reset()))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Couldn't reset enumerator!", _fx_));
                goto MyError;
        }

        // The new index starts at the end of the VfW capture device indices
        dwDeviceIndex = dwNumVfWDevices = g_dwNumDevices;

        while(Hr = pEm->Next(1, &pM, &cFetched), Hr==S_OK)
        {
            pM->BindToStorage(0, 0, IID_IPropertyBag, (void **)&pPropBag);

            if (pPropBag)
            {

                // Not enough room for this device in our array
                ASSERT(dwDeviceIndex < MAX_CAPTURE_DEVICES);
                if (dwDeviceIndex < MAX_CAPTURE_DEVICES)
                {
                    g_aDeviceInfo[dwDeviceIndex].nDeviceType = DeviceType_WDM;
                    g_aDeviceInfo[dwDeviceIndex].nCaptureMode = CaptureMode_FrameGrabbing;
                    g_aDeviceInfo[dwDeviceIndex].dwVfWIndex = (DWORD)-1;
                    g_aDeviceInfo[dwDeviceIndex].fHasOverlay = FALSE;
                    g_aDeviceInfo[dwDeviceIndex].fInUse = FALSE;

                    // Get friendly name of the device
                    var.vt = VT_BSTR;
                    if ((Hr = pPropBag->Read(L"FriendlyName", &var, 0)) == S_OK)
                    {
                        WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1, g_aDeviceInfo[dwDeviceIndex].szDeviceDescription, MAX_PATH, 0, 0);
                                SysFreeString(var.bstrVal);
                    }
                    else
                    {
                        // No string...
                        g_aDeviceInfo[dwDeviceIndex].szDeviceDescription[0] = '\0';
                    }

                    // 1 = TV, 2 = DV, 0 = neither
                    int fDShow = IsDShowDevice(pM, pPropBag, dwDeviceIndex);
                    if (fDShow) {
                        // either kind
                        g_aDeviceInfo[dwDeviceIndex].nDeviceType = DeviceType_DShow;
                    }

                    // Make sure this isn't one of the VfW capture devices we've already found
                    for (DWORD dwIndex = 0; dwIndex < dwNumVfWDevices; dwIndex++)
                    {
                        if (!lstrcmp(g_aDeviceInfo[dwDeviceIndex].szDeviceDescription, g_aDeviceInfo[dwIndex].szDeviceDescription))
                        {
                                // We already know about this device
                                    break;
                        }
                    }
                    dprintf("GetNumVideoCapDevicesInternal: WDM %d %s\n",dwDeviceIndex, g_aDeviceInfo[dwDeviceIndex].szDeviceDescription);
                    if (dwIndex == dwNumVfWDevices)
                    {

                        // There's no reg key for version information for WDM devices
                        // @todo Could there be another bag property we could use to get version info for WDM devices?
                        g_aDeviceInfo[dwDeviceIndex].szDeviceVersion[0] = '\0';

                        // Get DevicePath of the device
                        if ((Hr = pPropBag->Read(L"DevicePath", &var, 0)) == S_OK)
                        {
                            WideCharToMultiByte(CP_ACP, 0, var.bstrVal, -1, g_aDeviceInfo[dwDeviceIndex].szDevicePath, MAX_PATH, 0, 0);
                            SysFreeString(var.bstrVal);
                        }
                        else
                        {
                            // No string...
                            g_aDeviceInfo[dwDeviceIndex].szDevicePath[0] = '\0';
                        }

                        // TV devices will look like multiple devices for our sake, one
                        // for each input the card has (eg: composite and SVideo) otherwise
                        // how can the user select which input the camera is plugged into?
                        if (fDShow == 1) {
                            DWORD nSVideo, nComposite;
                            HRESULT hrX = GetInputTypes(pM, dwDeviceIndex, &nSVideo, &nComposite);
                            if (hrX == S_OK) {

                                CloneDevice(dwDeviceIndex, nSVideo, nComposite);
                                dwDeviceIndex += nSVideo + nComposite;
                                g_dwNumDevices += nSVideo + nComposite;
                            } else if (hrX == S_FALSE) {
                                // we're being told not use the DShow handler for this device
                                g_aDeviceInfo[dwDeviceIndex].nDeviceType = DeviceType_WDM;
                                dwDeviceIndex++;;
                                g_dwNumDevices++;
                            }
                        } else {
                            dwDeviceIndex++;
                            g_dwNumDevices++;
                        }
                    }
                }
            }

        pPropBag->Release();
        pM->Release();
        }

        pEm->Release();

        // DV users should re-enumerate.
        extern void ResetDVEnumeration();
        ResetDVEnumeration();
    }
#ifdef DEBUG
    else dprintf("g_dwNumDevices = %lu\n",g_dwNumDevices);
#endif

    // Return the number of capture devices
    *pdwNumDevices = g_dwNumDevices;

    // now add (2) at the end of duplicates ... or (3) or (4) if more than 2 ... ! :)
    { unsigned int i,j,k,same_device[MAX_CAPTURE_DEVICES]; char countbuf[32];
        for(i=0; i<g_dwNumDevices; i++)             //initialize
            same_device[i]=1;
        for(i=0,k=1; i<g_dwNumDevices; i++) {
            if(same_device[i]>1)                    // if it was already counted ...
                continue;                       // ...skip it
            for(j=i+1; j<g_dwNumDevices; j++) {     // for the remaining names up, starting with the next one ...
                if(!lstrcmp(g_aDeviceInfo[i].szDeviceDescription, g_aDeviceInfo[j].szDeviceDescription))
                        same_device[j]= ++k;    // increment the count for a duplicate/triplicate/etc. ...
            }                                       // ... and set its rank in that aux. vector
        }
        for(i=0; i<g_dwNumDevices; i++) {           // the final loop for adding the ' (n)' string at the end of each name
            if(same_device[i]>1) {                  // ...this happening only if that n > 1
                wsprintf(countbuf," (%d)",same_device[i]);
                if(lstrlen(g_aDeviceInfo[i].szDeviceDescription) + lstrlen(countbuf) < MAX_CAPDEV_DESCRIPTION-1)
                    lstrcat(g_aDeviceInfo[i].szDeviceDescription,countbuf);
#ifdef DEBUG
                else    dprintf("Buffer overflow for %s + %s ...\n",g_aDeviceInfo[i].szDeviceDescription,countbuf);
#endif
            }
        }
    }

    if (g_dwNumDevices)
    {
        Hr = S_OK;
    }

#ifdef DEBUG
    dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: %ld device(s) found", _fx_, *pdwNumDevices);
    if (*pdwNumDevices)
    {
        for (DWORD dwIndex = 0; dwIndex < *pdwNumDevices; dwIndex++)
        {
            dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS:   Device %ld (%s): %s", _fx_, dwIndex,((g_aDeviceInfo[dwIndex].nDeviceType == DeviceType_WDM)?"WDM":"VfW"),g_aDeviceInfo[dwIndex].szDeviceDescription);
        }
    }
#endif

    goto MyExit;

MyError:
    if (pCreateDevEnum)
        pCreateDevEnum->Release();
MyExit:
    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

    LeaveCriticalSection (&g_CritSec);
    return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CDEVENUMFUNCTION
 *
 *  @func HRESULT | GetCapDeviceInfo | This method is used to
 *    retrieve information about a capture device.
 *
 *  @parm DWORD | dwDeviceIndex | Specifies the device index of the capture
 *    device to return information about.
 *
 *  @parm PDEVICEINFO | pDeviceInfo | Specifies a pointer to a <t VIDEOCAPTUREDEVICEINFO>
 *    structure to receive information about a capture device.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag VFW_E_NO_CAPTURE_HARDWARE | No Capture hardware is available
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
VIDEOAPI GetVideoCapDeviceInfo(IN DWORD dwDeviceIndex, OUT PDEVICEINFO pDeviceInfo)
{
        HRESULT Hr = NOERROR;
        DWORD dwNumDevices = 0;

        FX_ENTRY("GetVideoCapDeviceInfo")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    EnterCriticalSection (&g_CritSec);

        // Validate input parameters
        ASSERT(pDeviceInfo);
        if (!pDeviceInfo || !pDeviceInfo->szDeviceDescription || !pDeviceInfo->szDeviceVersion)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Get the number of installed and enabled capture devices
        if (FAILED(Hr = GetNumVideoCapDevicesInternal(&dwNumDevices,FALSE)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Couldn't get number of installed devices!", _fx_));
                Hr = VFW_E_NO_CAPTURE_HARDWARE;
                goto MyExit;
        }

        // Validate index passed in
        ASSERT(dwDeviceIndex < dwNumDevices);
        if (!(dwDeviceIndex < dwNumDevices))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }

        // Grab the description and version info
        CopyMemory(pDeviceInfo, &g_aDeviceInfo[dwDeviceIndex], sizeof(VIDEOCAPTUREDEVICEINFO));

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: Desc: %s - Ver: %s", _fx_, pDeviceInfo->szDeviceDescription, pDeviceInfo->szDeviceVersion[0] != '\0' ? pDeviceInfo->szDeviceVersion : "Unknown"));

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

    LeaveCriticalSection (&g_CritSec);
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CDEVENUMMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | GetNumDevices | This method is used to
 *    determine the number of installed capture devices. This number includes
 *    only enabled devices.
 *
 *  @parm PDWORD | pdwNumDevices | Specifies a pointer to a DWORD to receive
 *    the number of installed capture devices.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIVCap::GetNumDevices(OUT PDWORD pdwNumDevices)
{
        return GetNumVideoCapDevicesInternal(pdwNumDevices,FALSE);
}

/****************************************************************************
 *  @doc INTERNAL CDEVENUMMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | GetDeviceInfo | This method is used to
 *    retrieve information about a capture device.
 *
 *  @parm DWORD | dwDeviceIndex | Specifies the device index of the capture
 *    device to return information about.
 *
 *  @parm PDEVICEINFO | pDeviceInfo | Specifies a pointer to a <t VIDEOCAPTUREDEVICEINFO>
 *    structure to receive information about a capture device.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIVCap::GetDeviceInfo(IN DWORD dwDeviceIndex, OUT PDEVICEINFO pDeviceInfo)
{
        return GetVideoCapDeviceInfo(dwDeviceIndex, pDeviceInfo);
}

/****************************************************************************
 *  @doc INTERNAL CDEVENUMMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | GetCurrentDevice | This method is used to
 *    determine the index of the capture device currently used.
 *
 *  @parm PDWORD | pdwDeviceIndex | Specifies a pointer to a DWORD to receive
 *    the index of the capture device currently used.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag VFW_E_NO_CAPTURE_HARDWARE | No Capture hardware is available
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIVCap::GetCurrentDevice(OUT DWORD *pdwDeviceIndex)
{
        HRESULT Hr = NOERROR;
        DWORD dwNumDevices;

        FX_ENTRY("CTAPIVCap::GetCurrentDevice")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pdwDeviceIndex);
        if (!pdwDeviceIndex)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Is there already a current capture device?
        if ((g_dwNumDevices == (DWORD)-1) || (m_dwDeviceIndex == -1))
        {
                // Use default capture devices - make sure we have at least one device first!
                if (FAILED(Hr = GetNumDevices(&dwNumDevices)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Couldn't get number of installed devices", _fx_));
                        Hr = VFW_E_NO_CAPTURE_HARDWARE;
                        goto MyExit;
                }

                // If we have some devices then return the first device enumerated
                if (dwNumDevices)
                        *pdwDeviceIndex = m_dwDeviceIndex = 0;
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: No device installed", _fx_));
                        Hr = E_FAIL;
                }
        }
        else
        {
                // Return the current capture device
                *pdwDeviceIndex = m_dwDeviceIndex;
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CDEVENUMMETHOD
 *
 *  @mfunc HRESULT | CTAPIVCap | SetCurrentDevice | This method is used to
 *    specify the index of the capture device to use.
 *
 *  @parm DWORD | dwDeviceIndex | Specifies the index of the capture device
 *    to use.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag VFW_E_NOT_STOPPED | Need to stop this filter first
 *  @flag VFW_E_NO_CAPTURE_HARDWARE | No Capture hardware is available
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIVCap::SetCurrentDevice(IN DWORD dwDeviceIndex)
{
        HRESULT Hr = NOERROR;
        DWORD dwNumDevices;

        FX_ENTRY("CTAPIVCap::SetCurrentDevice")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Setting m_dwDeviceIndex to %d", _fx_, dwDeviceIndex));
        // Validate input parameters
        if (FAILED(Hr = GetNumDevices(&dwNumDevices)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Couldn't get number of installed devices", _fx_));
                Hr = VFW_E_NO_CAPTURE_HARDWARE;
                goto MyExit;
        }
        dprintf("dwDeviceIndex = %lu, dwNumDevices = %lu, g_dwNumDevices = %lu\n",dwDeviceIndex , dwNumDevices ,g_dwNumDevices);
        ASSERT(dwDeviceIndex < dwNumDevices);
        if (!(dwDeviceIndex < dwNumDevices))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }
        ASSERT(m_State == State_Stopped);
        if (m_State != State_Stopped)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Need to stop this filter first", _fx_));
                Hr = VFW_E_NOT_STOPPED;
                goto MyExit;
        }

        // Set the current device
        m_dwDeviceIndex = dwDeviceIndex;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\device.cpp ===
/****************************************************************************
 *  @doc INTERNAL DEVICE
 *
 *  @module Device.cpp | Source file for the <c CCapDev>
 *    base class used to communicate with the capture device.
 ***************************************************************************/

#include "Precomp.h"

#define DEVICE_DEBUG
#if defined(DEBUG) && defined(DEVICE_DEBUG)

  #include <stdio.h>
  #include <stdarg.h>

  static int dprintf( char * format, ... )
  {
      char out[1024];
      int r;
      va_list marker;
      va_start(marker, format);
      r=_vsnprintf(out, 1022, format, marker);
      va_end(marker);
      OutputDebugString( out );
      return r;
  }

#else
  #undef DEVICE_DEBUG

  #define dprintf ; / ## /
#endif



const WORD aiBitDepth[NUM_BITDEPTH_ENTRIES] = {0, 0, 9, 12, 12, 16, 16, 16, 24, 4, 8};
const DWORD aiFormat[NUM_BITDEPTH_ENTRIES] = {  VIDEO_FORMAT_NUM_COLORS_MSH263,
                                                VIDEO_FORMAT_NUM_COLORS_MSH261,
                                                VIDEO_FORMAT_NUM_COLORS_YVU9,
                                                VIDEO_FORMAT_NUM_COLORS_I420,
                                                VIDEO_FORMAT_NUM_COLORS_IYUV,
                                                VIDEO_FORMAT_NUM_COLORS_YUY2,
                                                VIDEO_FORMAT_NUM_COLORS_UYVY,
                                                VIDEO_FORMAT_NUM_COLORS_65536,
                                                VIDEO_FORMAT_NUM_COLORS_16777216,
                                                VIDEO_FORMAT_NUM_COLORS_16,
                                                VIDEO_FORMAT_NUM_COLORS_256};
const DWORD aiFourCCCode[NUM_BITDEPTH_ENTRIES] = {
                                                VIDEO_FORMAT_MSH263,
                                                VIDEO_FORMAT_MSH261,
                                                VIDEO_FORMAT_YVU9,
                                                VIDEO_FORMAT_I420,
                                                VIDEO_FORMAT_IYUV,
                                                VIDEO_FORMAT_YUY2,
                                                VIDEO_FORMAT_UYVY,
                                                VIDEO_FORMAT_BI_RGB,
                                                VIDEO_FORMAT_BI_RGB,
                                                VIDEO_FORMAT_BI_RGB,
                                                VIDEO_FORMAT_BI_RGB};
const DWORD aiClrUsed[NUM_BITDEPTH_ENTRIES] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 256};

const MYFRAMESIZE awResolutions[VIDEO_FORMAT_NUM_RESOLUTIONS] =
{
        { VIDEO_FORMAT_IMAGE_SIZE_176_144, 176, 144 },
        { VIDEO_FORMAT_IMAGE_SIZE_128_96, 128, 96 },
        { VIDEO_FORMAT_IMAGE_SIZE_352_288, 352, 288 },
        { VIDEO_FORMAT_IMAGE_SIZE_160_120, 160, 120 },
        { VIDEO_FORMAT_IMAGE_SIZE_320_240, 320, 240 },
        { VIDEO_FORMAT_IMAGE_SIZE_240_180, 240, 180 }
};

/****************************************************************************
 *  @doc INTERNAL CCAPDEVMETHOD
 *
 *  @mfunc void | CCapDev | CCapDev | This method is the constructor
 *    for the <c CCapDev> object.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCapDev::CCapDev(IN TCHAR *pObjectName, IN CTAPIVCap *pCaptureFilter, IN LPUNKNOWN pUnkOuter, IN DWORD dwDeviceIndex, IN HRESULT *pHr) : CUnknown(pObjectName, pUnkOuter, pHr)
{
        FX_ENTRY("CCapDev::CCapDev")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pHr);
        ASSERT(pCaptureFilter);
        if (!pCaptureFilter || !pHr)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                if (pHr)
                        *pHr = E_POINTER;
                goto MyExit;
        }

        // Capture device caps
        m_dwDialogs = m_dwImageSize = m_dwFormat = 0UL;
        m_dwStreamingMode = FRAME_GRAB_LARGE_SIZE;
        m_pCaptureFilter = pCaptureFilter;

        // Configuration dialogs
        m_fDialogUp = FALSE;

        // Save device index
        m_dwDeviceIndex = dwDeviceIndex;
        ZeroMemory(&m_vcdi, sizeof(m_vcdi));
        m_bCached_vcdi = FALSE;
        // Camera control - for sotware-only implementation
        m_lCCPan = 0;
        m_lCCTilt = 0;
        m_lCCZoom = 10;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCAPDEVMETHOD
 *
 *  @mfunc void | CCapDev | ~CCapDev | This method is the destructor
 *    for the <c CCapDev> object.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CCapDev::~CCapDev()
{
        FX_ENTRY("CCapDev::~CCapDev")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CCapDev | NonDelegatingQueryInterface | This
 *    method is the nondelegating interface query function. It returns a pointer
 *    to the specified interface if supported. The only interfaces explicitly
 *    supported being <i IAMVfWCaptureDialogs>.
 *
 *  @parm REFIID | riid | Specifies the identifier of the interface to return.
 *
 *  @parm PVOID* | ppv | Specifies the place in which to put the interface
 *    pointer.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CCapDev::NonDelegatingQueryInterface(IN REFIID riid, OUT void **ppv)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CCapDev::NonDelegatingQueryInterface")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(ppv);
        if (!ppv)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Retrieve interface pointer
        if (riid == __uuidof(IAMVfwCaptureDialogs))
        {
            *ppv = static_cast<IAMVfwCaptureDialogs*>(this);
            GetOwner()->AddRef();
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: IAMVfwCaptureDialogs*=0x%08lX", _fx_, *ppv));
                goto MyExit;
        }
        else if (riid == __uuidof(IVideoProcAmp))
        {
            *ppv = static_cast<IVideoProcAmp*>(this);
            GetOwner()->AddRef();
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: IVideoProcAmp*=0x%08lX", _fx_, *ppv));
                goto MyExit;
        }
        else if (riid == __uuidof(ICameraControl))
        {
            *ppv = static_cast<ICameraControl*>(this);
            GetOwner()->AddRef();
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: ICameraControl*=0x%08lX", _fx_, *ppv));
                goto MyExit;
        }
        else if (FAILED(Hr = CUnknown::NonDelegatingQueryInterface(riid, ppv)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, WARN, "%s:   WARNING: NDQI for {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX} failed Hr=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], Hr));
        }
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX}*=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], *ppv));
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/*****************************************************************************
 *  @doc INTERNAL CCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CCapDev | GetFormatsFromRegistry | This method is
 *    used to retrieve from the registry the list of formats supported by the
 *    capture device.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_UNEXPECTED | Unrecoverable error
 *  @flag NOERROR | No error
 ****************************************************************************/
HRESULT CCapDev::GetFormatsFromRegistry()
{
        HRESULT Hr = NOERROR;
        HKEY    hMainDeviceKey = NULL;  // this is the szRegDeviceKey having the database that NM setup creates
        HKEY    hPrivDeviceKey = NULL;  // this is the szRegCaptureDefaultKey that NM uses to store some profile results (the default mode)
        HKEY    hRTCDeviceKey  = NULL;  // this is the newly added szRegRTCKey used by RTCClient to store its profile results
        HKEY    hKey = NULL;
        DWORD   dwSize, dwType;
        char    szKey[MAX_PATH + MAX_VERSION + 2];

        bool bIsKeyUnderPriv = FALSE;

        FX_ENTRY("CCapDev::GetFormatsFromRegistry")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Set default values
        m_dwImageSize = m_dwFormat = (DWORD)NULL;
        m_dwStreamingMode = FRAME_GRAB_LARGE_SIZE;
        m_dwDialogs = FORMAT_DLG_OFF | SOURCE_DLG_ON;
        m_dwFormat = 0;

        // Based on the name and version number of the driver, get capabilities.
        // We first try to look them up from the registry. If this is a very popular
        // board/camera, chances are that we have set the key at install time already.
        // If we can't find the key, we'll profile the hardware and save the results
        // to the registry.

    // If we have version info use that to build the key name
    if (g_aDeviceInfo[m_dwDeviceIndex].szDeviceVersion && g_aDeviceInfo[m_dwDeviceIndex].szDeviceVersion[0] != '\0')
    {
        wsprintf(szKey, "%s, %s", g_aDeviceInfo[m_dwDeviceIndex].szDeviceDescription, g_aDeviceInfo[m_dwDeviceIndex].szDeviceVersion);
    }
    else
    {
        wsprintf(szKey, "%s", g_aDeviceInfo[m_dwDeviceIndex].szDeviceDescription);
    }
    dprintf("%s: camera key: %s\n", _fx_,szKey);

    // *** PRIVATE KEY ***
    dprintf("%s: Trying under the Private key %s\n", _fx_,szRegCaptureDefaultKey);

    // Check if the priv key is there
    if (RegOpenKey(HKEY_LOCAL_MACHINE, szRegCaptureDefaultKey, &hPrivDeviceKey) != ERROR_SUCCESS)
    {
            DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Can't find private key!", _fx_));
    }
    else
    {
        // Check if there is already is an NM profile key for the current device
        if (RegOpenKey(hPrivDeviceKey, szKey, &hKey) != ERROR_SUCCESS)
        {
            // Try again without the version information
            if (g_aDeviceInfo[m_dwDeviceIndex].szDeviceVersion && g_aDeviceInfo[m_dwDeviceIndex].szDeviceVersion[0] != '\0')
                {
                        wsprintf(szKey, "%s", g_aDeviceInfo[m_dwDeviceIndex].szDeviceDescription);
                        if (RegOpenKey(hPrivDeviceKey, szKey, &hKey) != ERROR_SUCCESS)
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Can't find priv device reg key!", _fx_));
                        }
                        else
                        {
                                RegCloseKey(hKey),  hKey = NULL;
                                bIsKeyUnderPriv=TRUE;
                        }
                }
        }
        else
        {
            RegCloseKey(hKey),  hKey = NULL;
            bIsKeyUnderPriv=TRUE;
        }
        RegCloseKey(hPrivDeviceKey),  hPrivDeviceKey = NULL;
    }


    if(!bIsKeyUnderPriv)
    {

        // *** MAIN KEY ***
        dprintf("%s: Trying under the Main key %s\n", _fx_,szRegDeviceKey);

        if (g_aDeviceInfo[m_dwDeviceIndex].szDeviceVersion && g_aDeviceInfo[m_dwDeviceIndex].szDeviceVersion[0] != '\0')
        {
            wsprintf(szKey, "%s, %s", g_aDeviceInfo[m_dwDeviceIndex].szDeviceDescription, g_aDeviceInfo[m_dwDeviceIndex].szDeviceVersion);
        }
        else
        {
            wsprintf(szKey, "%s", g_aDeviceInfo[m_dwDeviceIndex].szDeviceDescription);
        }

        // Check if the main capture devices key is there
        if (RegOpenKey(HKEY_LOCAL_MACHINE, szRegDeviceKey, &hMainDeviceKey) != ERROR_SUCCESS)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Can't find main reg key - trying RTC key!", _fx_));
                goto TryRTCKey;
        }

        // Check if there is already is an official key for the current device
        if (RegOpenKey(hMainDeviceKey, szKey, &hKey) != ERROR_SUCCESS)
        {
            // Try again without the version information
            if (g_aDeviceInfo[m_dwDeviceIndex].szDeviceVersion && g_aDeviceInfo[m_dwDeviceIndex].szDeviceVersion[0] != '\0')
                {
                        wsprintf(szKey, "%s", g_aDeviceInfo[m_dwDeviceIndex].szDeviceDescription);
                        if (RegOpenKey(hMainDeviceKey, szKey, &hKey) != ERROR_SUCCESS)
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Can't find main device reg key - trying RTC key!", _fx_));
                                RegCloseKey(hMainDeviceKey), hMainDeviceKey = NULL;
                                goto TryRTCKey;
                        }
                }
                else
                {
                        RegCloseKey(hMainDeviceKey), hMainDeviceKey = NULL;
                        goto TryRTCKey;
                }
        }

        goto GetValuesFromKeys;
    }

TryRTCKey:
    // *** RTC KEY ***
    dprintf("%s: Trying under the RTC key %s\n", _fx_,szRegRTCKey);

    if (g_aDeviceInfo[m_dwDeviceIndex].szDeviceVersion && g_aDeviceInfo[m_dwDeviceIndex].szDeviceVersion[0] != '\0')
    {
        wsprintf(szKey, "%s, %s", g_aDeviceInfo[m_dwDeviceIndex].szDeviceDescription, g_aDeviceInfo[m_dwDeviceIndex].szDeviceVersion);
    }
    else
    {
        wsprintf(szKey, "%s", g_aDeviceInfo[m_dwDeviceIndex].szDeviceDescription);
    }

    // Check if the RTC  key is there
    if (RegOpenKey(RTCKEYROOT, szRegRTCKey, &hRTCDeviceKey) != ERROR_SUCCESS)
    {
            DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Can't find RTC key!", _fx_));
            Hr = E_FAIL;
            goto MyExit;
    }

    // Check if there already is an RTC key for the current device
    if (RegOpenKey(hRTCDeviceKey, szKey, &hKey) != ERROR_SUCCESS)
    {
        // Try again without the version information
        if (g_aDeviceInfo[m_dwDeviceIndex].szDeviceVersion && g_aDeviceInfo[m_dwDeviceIndex].szDeviceVersion[0] != '\0')
            {
            wsprintf(szKey, "%s", g_aDeviceInfo[m_dwDeviceIndex].szDeviceDescription);
                    if (RegOpenKey(hRTCDeviceKey, szKey, &hKey) != ERROR_SUCCESS)
                    {
                            DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Can't find RTC device reg key!", _fx_));
                            Hr = E_FAIL;
                            goto MyError0;
                    }
            }
            else
            {
                    Hr = E_FAIL;
                    goto MyError0;
            }
    }

GetValuesFromKeys:

        // Get values from the Main key if the Private key is not there; otherwise try the RTC key
        // Get the values stored in the key choosen above: should be one of Main or RTC
        // if the values below are not found (testing the existence of the 1st would be enough), that means the key has
        // been created, but without the profiled values
        // [ so far this could happen in only one case: the camera is a Sony Motion Eye camera, and the key already stores
        // the DoNotUseDShow value set in DevEnum.cpp = IsDShowDevice function, but nothing else ; see that function for more
        // comments/explanations related to WinSE #28804 ]
        dwSize = sizeof(DWORD);
        if(RegQueryValueEx(hKey, (LPTSTR)szRegdwImageSizeKey, NULL, &dwType, (LPBYTE)&m_dwImageSize, &dwSize) != ERROR_SUCCESS)
        {
                Hr = E_FAIL;
                goto NotFullyProfiledYet;

        }
        dwSize = sizeof(DWORD);
        RegQueryValueEx(hKey, (LPTSTR)szRegdwNumColorsKey, NULL, &dwType, (LPBYTE)&m_dwFormat, &dwSize);
        dwSize = sizeof(DWORD);
        m_dwStreamingMode = FRAME_GRAB_LARGE_SIZE;
        RegQueryValueEx(hKey, (LPTSTR)szRegdwStreamingModeKey, NULL, &dwType, (LPBYTE)&m_dwStreamingMode, &dwSize);
        dwSize = sizeof(DWORD);
        m_dwDialogs = FORMAT_DLG_OFF | SOURCE_DLG_ON;
        RegQueryValueEx(hKey, (LPTSTR)szRegdwDialogsKey, NULL, &dwType, (LPBYTE)&m_dwDialogs, &dwSize);

        // Check dwNumColors to figure out if we need to read the palettes too
        if (m_dwFormat & VIDEO_FORMAT_NUM_COLORS_16)
        {
                // @todo If this is a QuickCam device you may have to use a hardcoded
                // palette instead of the one provided by the device
        }

NotFullyProfiledYet:
        // Close the registry keys
        if (hKey)
                RegCloseKey(hKey);

MyError0:
        if (hRTCDeviceKey)
                RegCloseKey(hRTCDeviceKey);
        if (hMainDeviceKey)
                RegCloseKey(hMainDeviceKey);
MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CCapDev | ProfileCaptureDevice | This method is used to
 *    determine the list of formats supported by the capture device.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_UNEXPECTED | Unrecoverable error
 *  @flag NOERROR | No error
 *
 *  @comm If there is no entry for the VfW capture device in the list
 *    maintained by the TAPI MSP Video Capture filter, the TAPI MSP Video
 *    Capture filter will first query the capture device for its current
 *    video capture format, and save this information in case the following
 *    steps result in a crash.
 *
 *    Then, the TAPI MSP Video Capture filter applies a set of preferred
 *    formats on the capture device using SendDriverMessage with the
 *    DVM_FORMAT message. For each applied format, the TAPI MSP Video
 *    Capture filter will not only verify the return code of the
 *    SendDriverMessage, but also query back the current format to make
 *    sure the set format operation really succeeded. If the capture device
 *    fails one of the two previous steps, the TAPI MSP Video Capture
 *    filter will assume that the format is not supported. Once the TAPI
 *    MSP Video Capture filter is done with the entire list of preferred
 *    formats and no crash occurred, the list of video formats supported by
 *    the capture device is added to the list maintained by the TAPI MSP
 *    Video Capture filter.
 *
 *    As soon as the enumeration process succeeds for one "small" (128x96
 *    or 160x120), one "medium" (176x144 or 160x120), one "large" (352x288
 *    or 320x240) and one "very large" size (704x576 or 640x480), the TAPI
 *    MSP Video Capture filter stops the enumeration process and adds the
 *    resulting list of formats to its database. The TAPI MSP Video Capture
 *    filter will test the previous sizes for I420, IYUV, YUY2, UYVY, YVU9,
 *    RGB16, RGB24, RGB8, and RGB4 formats, in this described order.
 *
 *    The device will also be marked as a frame-grabbing device in the TAPI
 *    MSP Video Capture filter device database.
 *
 *    If there is an entry for the VfW capture device in the list maintained
 *    by the TAPI MSP Video Capture filter, the TAPI MSP Video Capture
 *    filter first verifies if the information contained is a complete list
 *    of supported formats, or only a default format. The entry will only
 *    contain a default format if the capture device did not support any of
 *    the preferred formats, or a crash occurred during the enumeration process.
 *
 *    If there is only a default format stored for the VfW capture device,
 *    the TAPI MSP Video Capture filter will build a list of media types that
 *    can be built from the default format using black-banding and/or cropping.
 *    If the default format is in a compressed format, the TAPI MSP Video
 *    Capture filter will try and locate and ICM driver that can do the
 *    decompression from the compressed format to RGB.
 *
 *    If the device supports a list of formats from the preferred list of
 *    formats, the TAPI MSP Video Capture filter will use this list to
 *    advertise the capabilities of the capture device.
 *
 *    In all cases (VfW and WDM capture devices, Videoconferencing
 *    Accelerators), the TAPI MSP Video Capture filter won't query the
 *    device for capabilities but always use the list of formats stored in
 *    its database for this capture device.
 ***************************************************************************/
HRESULT CCapDev::ProfileCaptureDevice()
{
        HRESULT Hr = NOERROR;
        HKEY    hDeviceKey = NULL;
        HKEY    hKey = NULL;
        DWORD   dwSize;
        char    szKey[MAX_PATH + MAX_VERSION + 2];
        VIDEOINFOHEADER         *pvi = NULL;
        DWORD   dwDisposition;
        int i, j, nFirstValidFormat;

        FX_ENTRY("CCapDev::ProfileCaptureDevice")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Provide defaults
    m_dwImageSize = VIDEO_FORMAT_IMAGE_SIZE_USE_DEFAULT;
    m_dwFormat = 0;

    // Since we don't know anything about this adapter, we just use its default format
    // Get the device's default format
        if (FAILED(GetFormatFromDriver(&pvi)) || !pvi)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Can't get format from device!", _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

        // Open the main capture devices key, or create it if it doesn't exist
        if (RegCreateKeyEx(RTCKEYROOT, szRegRTCKey, 0, 0, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hDeviceKey, &dwDisposition) != ERROR_SUCCESS)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Can't create registry key!", _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

        // If we have version info use that to build the key name
        // @todo VCMSTRM.cpp does some weird things with the name - probably due to bogus device
        // Repro this code
        if (g_aDeviceInfo[m_dwDeviceIndex].szDeviceVersion && g_aDeviceInfo[m_dwDeviceIndex].szDeviceVersion[0] != '\0')
        {
            wsprintf(szKey, "%s, %s", g_aDeviceInfo[m_dwDeviceIndex].szDeviceDescription, g_aDeviceInfo[m_dwDeviceIndex].szDeviceVersion);
        }
        else
        {
            wsprintf(szKey, "%s", g_aDeviceInfo[m_dwDeviceIndex].szDeviceDescription);
        }

        // Check if there already is a key for the current device
        // Open the key for the current device, or create the key if it doesn't exist
        if (RegCreateKeyEx(hDeviceKey, szKey, 0, 0, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dwDisposition) != ERROR_SUCCESS)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Can't create registry key!", _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

        switch(HEADER(pvi)->biCompression)
        {
                case VIDEO_FORMAT_BI_RGB:
                        switch(HEADER(pvi)->biBitCount)
                        {
                                case 24:
                            m_dwFormat = VIDEO_FORMAT_NUM_COLORS_16777216;
                                        break;
                                case 16:
                            m_dwFormat = VIDEO_FORMAT_NUM_COLORS_65536;
                                        break;
                                case 8:
                            m_dwFormat = VIDEO_FORMAT_NUM_COLORS_256;
                                        break;
                                case 4:
                            m_dwFormat = VIDEO_FORMAT_NUM_COLORS_16;
                                        break;
                        }
                        break;
                case VIDEO_FORMAT_MSH263:
            m_dwFormat = VIDEO_FORMAT_NUM_COLORS_MSH263;
                        break;
                case VIDEO_FORMAT_MSH261:
            m_dwFormat = VIDEO_FORMAT_NUM_COLORS_MSH261;
                        break;
                case VIDEO_FORMAT_YVU9:
            m_dwFormat = VIDEO_FORMAT_NUM_COLORS_YVU9;
                        break;
                case VIDEO_FORMAT_YUY2:
            m_dwFormat = VIDEO_FORMAT_NUM_COLORS_YUY2;
                        break;
                case VIDEO_FORMAT_UYVY:
            m_dwFormat = VIDEO_FORMAT_NUM_COLORS_UYVY;
                        break;
                case VIDEO_FORMAT_I420:
            m_dwFormat = VIDEO_FORMAT_NUM_COLORS_I420;
                        break;
                case VIDEO_FORMAT_IYUV:
            m_dwFormat = VIDEO_FORMAT_NUM_COLORS_IYUV;
                        break;
                default:
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Unsupported format! value = 0x%08lx '%.4s'", _fx_,(HEADER(pvi)->biCompression),&(HEADER(pvi)->biCompression)));
                        //**Hr = E_FAIL; if NO formats are found, ONLY then return E_FAIL (see if(nFirstValidFormat==0) below...)
                        //**goto MyExit; do not jump out; we continue instead, trying the other formats ... (332920)
                        break;
        }

    // Find the size
        for (j = 0;  j < VIDEO_FORMAT_NUM_RESOLUTIONS; j++)
        {
        if ((HEADER(pvi)->biWidth == (LONG)awResolutions[j].framesize.cx) &&
             (HEADER(pvi)->biHeight == (LONG)awResolutions[j].framesize.cy))
                {
                    m_dwImageSize |= awResolutions[j].dwRes;
                    break;
                }
        }

        // Set the values in the key
        dwSize = sizeof(DWORD);
        RegSetValueEx(hKey, (LPTSTR)szRegdwImageSizeKey, (DWORD)NULL, REG_DWORD, (LPBYTE)&m_dwImageSize, dwSize);
        dwSize = sizeof(DWORD);
        RegSetValueEx(hKey, (LPTSTR)szRegdwNumColorsKey, (DWORD)NULL, REG_DWORD, (LPBYTE)&m_dwFormat, dwSize);
        dwSize = sizeof(DWORD);
        RegSetValueEx(hKey, (LPTSTR)szRegdwStreamingModeKey, (DWORD)NULL, REG_DWORD, (LPBYTE)&m_dwStreamingMode, dwSize);
        dwSize = sizeof(DWORD);
        RegSetValueEx(hKey, (LPTSTR)szRegdwDialogsKey, (DWORD)NULL, REG_DWORD, (LPBYTE)&m_dwDialogs, dwSize);

        // Close the keys
        RegCloseKey(hKey);
        RegCloseKey(hDeviceKey);
        hDeviceKey = NULL;
        hKey = NULL;

        // We're safe. We've backed up the default format of the capture device.
        // Now we can try and apply formats on it to see what else it supports
        // This operation MAY crash - but next time we'll execute this code, we
        // won't try this code again since we'll find out that we have already
        // stored the default format for the capture device in the registry.

        // Let's try 176x144, 128x96 and 352x288 for sure
        // If we don't have both 176x144 and 128x96, try 160x120
        // If we don't have 352x288, try 320x240
        // If we don't have 320x240, try 240x180
        nFirstValidFormat = 0;
    m_dwImageSize = 0;
    m_dwFormat = 0;
        for (i = 0; i < VIDEO_FORMAT_NUM_RESOLUTIONS; i++)
        {
                if (i == 3 && (m_dwImageSize & VIDEO_FORMAT_IMAGE_SIZE_176_144) && (m_dwImageSize & VIDEO_FORMAT_IMAGE_SIZE_128_96))
                        continue;

                if (i == 4 && (m_dwImageSize & VIDEO_FORMAT_IMAGE_SIZE_352_288))
                        continue;

                if (i == 5 && ((m_dwImageSize & VIDEO_FORMAT_IMAGE_SIZE_352_288) || (m_dwImageSize & VIDEO_FORMAT_IMAGE_SIZE_320_240)))
                        continue;

                HEADER(pvi)->biSize = sizeof(BITMAPINFOHEADER);
                HEADER(pvi)->biWidth = awResolutions[i].framesize.cx;
                HEADER(pvi)->biHeight = awResolutions[i].framesize.cy;
                HEADER(pvi)->biPlanes = 1;
                HEADER(pvi)->biXPelsPerMeter = HEADER(pvi)->biYPelsPerMeter = 0;

                // Try MSH263, MSH261, I420, IYUV, YVU9, YUY2, UYVY, RGB16, RGB24, RGB4, RGB8 format.
                for (j = nFirstValidFormat; j < NUM_BITDEPTH_ENTRIES; j++)
                {
                        HEADER(pvi)->biBitCount = aiBitDepth[j];
                        HEADER(pvi)->biCompression = aiFourCCCode[j];
                        HEADER(pvi)->biClrImportant = HEADER(pvi)->biClrUsed = aiClrUsed[j];
                        HEADER(pvi)->biSizeImage = DIBSIZE(*HEADER(pvi));

                        // Ask the device to validate this format
                        if (SUCCEEDED(SendFormatToDriver(HEADER(pvi)->biWidth, HEADER(pvi)->biHeight, HEADER(pvi)->biCompression, HEADER(pvi)->biBitCount, NULL, TRUE)))
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Adding %s %ldx%ld to capabilities", _fx_, HEADER(pvi)->biCompression == VIDEO_FORMAT_MSH263 ? "H.263" : HEADER(pvi)->biCompression == VIDEO_FORMAT_MSH261 ? "H.261" : HEADER(pvi)->biCompression == VIDEO_FORMAT_YVU9 ? "YVU9" : HEADER(pvi)->biCompression == VIDEO_FORMAT_I420 ? "I420" : HEADER(pvi)->biCompression == VIDEO_FORMAT_IYUV ? "IYUV" : HEADER(pvi)->biCompression == VIDEO_FORMAT_YUY2 ? "YUY2" : HEADER(pvi)->biCompression == VIDEO_FORMAT_UYVY ? "UYVY" : "RGB", HEADER(pvi)->biWidth, HEADER(pvi)->biHeight));
                                m_dwImageSize |= awResolutions[i].dwRes;
                                m_dwFormat |= aiFormat[j];
                                if (!nFirstValidFormat)
                                        nFirstValidFormat = j;
                                // Assumption: A size supported in one format, is also supported with any other
                                // format supported by the capture device.
                                // @todo For now, get all the formats supported
                                // break;
                        }
                }
        }

        if(nFirstValidFormat==0) { // none supported ...
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: No format supported !", _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

        // If we survived the previous set format tests, reopen the keys and save
        // the new result to the registry
        if (RegCreateKeyEx(RTCKEYROOT, szRegRTCKey, 0, 0, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hDeviceKey, &dwDisposition) != ERROR_SUCCESS)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Can't reopen registry key!", _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }
        if (RegCreateKeyEx(hDeviceKey, szKey, 0, 0, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKey, &dwDisposition) != ERROR_SUCCESS)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Can't reopen registry key!", _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

    m_dwImageSize ^= VIDEO_FORMAT_IMAGE_SIZE_USE_DEFAULT;

        // Update the values in the key
        dwSize = sizeof(DWORD);
        RegSetValueEx(hKey, (LPTSTR)szRegdwImageSizeKey, (DWORD)NULL, REG_DWORD, (LPBYTE)&m_dwImageSize, dwSize);
        dwSize = sizeof(DWORD);
        RegSetValueEx(hKey, (LPTSTR)szRegdwNumColorsKey, (DWORD)NULL, REG_DWORD, (LPBYTE)&m_dwFormat, dwSize);

MyExit:
        // Close the keys
        if (hKey)
                RegCloseKey(hKey);
        if (hDeviceKey)
                RegCloseKey(hDeviceKey);
        // Free BMIH + palette space
        if (pvi)
                delete pvi, pvi = NULL;
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\device.h ===
/****************************************************************************
 *  @doc INTERNAL DEVICE
 *
 *  @module Device.h | Header file for the <c CDeviceProperties>
 *    class used to implement a property page to test the <i IAMVfwCaptureDialogs>
 *    and <i IVideoDeviceControl> interfaces.
 ***************************************************************************/

#ifndef _DEVICE_H_
#define _DEVICE_H_

#include "precomp.h"
#include "dbgxtra.h"
#include <qedit.h>
#include <atlbase.h>

#include "../../audio/tpaudcap/dsgraph.h"

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPCLASS
 *
 *  @class CTAPIVCap | This class implements the TAPI Video Capture Source
 *    filter.
 *
 *  @mdata CCritSec | CTAPIVCap | m_lock | Critical section used for
 *    locking by the <c CBaseFilter> base class.
 *
 *  @mdata CCapturePin | CTAPIVCap | m_pCapturePin | Pointer to the capture pin
 *    object
 *
 *  @mdata COverlayPin | CTAPIVCap | m_pOverlayPin | Pointer to the overlay
 *    pin object
 *
 *  @mdata CPreviewPin | CTAPIVCap | m_pPreviewPin | Pointer to the preview
 *    pin object
 *
 *  @mdata BOOL | CTAPIVCap | m_fDialogUp | Set to TRUE if a VfW driver
 *    dialog box is up
 *
 *  @todo Put some valid comments here!
 ***************************************************************************/
class CCapDev : public CUnknown, public IAMVfwCaptureDialogs, public IVideoProcAmp, public ICameraControl
{
        public:

        DECLARE_IUNKNOWN
        STDMETHODIMP NonDelegatingQueryInterface(IN REFIID riid, OUT PVOID *ppv);
        CCapDev(IN TCHAR *pObjectName, IN CTAPIVCap *pCaptureFilter, IN LPUNKNOWN pUnkOuter, IN DWORD dwDeviceIndex, IN HRESULT *pHr);
        virtual ~CCapDev();

        // Implement IAMVfwCaptureDialogs
        virtual STDMETHODIMP HasDialog(IN int iDialog) PURE;
        virtual STDMETHODIMP ShowDialog(IN int iDialog, IN HWND hwnd) PURE;
        virtual STDMETHODIMP SendDriverMessage(IN int iDialog, IN int uMsg, IN long dw1, IN long dw2) PURE;

        // Implement IAMVideoProcAmp
        virtual STDMETHODIMP Set(IN VideoProcAmpProperty Property, IN long lValue, IN TAPIControlFlags Flags) {return E_NOTIMPL;};
        virtual STDMETHODIMP Get(IN VideoProcAmpProperty Property, OUT long *lValue, OUT TAPIControlFlags *Flags) {return E_NOTIMPL;};
        virtual STDMETHODIMP GetRange(IN VideoProcAmpProperty Property, OUT long *pMin, OUT long *pMax, OUT long *pSteppingDelta, OUT long *pDefault, OUT TAPIControlFlags *pCapsFlags) {return E_NOTIMPL;};

        // Implement ICameraControl
        virtual STDMETHODIMP Set(IN TAPICameraControlProperty Property, IN long lValue, IN TAPIControlFlags Flags);
        virtual STDMETHODIMP Get(IN TAPICameraControlProperty Property, OUT long *lValue, OUT TAPIControlFlags *Flags);
        virtual STDMETHODIMP GetRange(IN TAPICameraControlProperty Property, OUT long *pMin, OUT long *pMax, OUT long *pSteppingDelta, OUT long *pDefault, OUT TAPIControlFlags *pCapsFlags);

        // Device control
        HRESULT GetFormatsFromRegistry();
        virtual HRESULT ProfileCaptureDevice();
        virtual HRESULT ConnectToDriver() PURE;
        virtual HRESULT DisconnectFromDriver() PURE;
        virtual HRESULT SendFormatToDriver(IN LONG biWidth, IN LONG biHeight, IN DWORD biCompression, IN WORD biBitCount, IN REFERENCE_TIME AvgTimePerFrame, BOOL fUseExactFormat) PURE;
        virtual HRESULT GetFormatFromDriver(OUT VIDEOINFOHEADER **ppvi) PURE;

        // Streaming and frame grabbing control
        virtual HRESULT InitializeStreaming(DWORD usPerFrame, DWORD_PTR hEvtBufferDone) PURE;
        virtual HRESULT StartStreaming() PURE;
        virtual HRESULT StopStreaming() PURE;
        virtual HRESULT TerminateStreaming() PURE;
        virtual HRESULT GrabFrame(PVIDEOHDR pVHdr) PURE;
        virtual HRESULT AllocateBuffer(LPTHKVIDEOHDR *pptvh, DWORD dwIndex, DWORD cbBuffer) PURE;
        virtual HRESULT AddBuffer(PVIDEOHDR pVHdr, DWORD cbVHdr) PURE;
        virtual HRESULT FreeBuffer(LPTHKVIDEOHDR pVHdr) PURE; //previously PVIDEOHDR pVHdr
        virtual HRESULT AllocateHeaders(DWORD dwNumHdrs, DWORD cbHdr, LPVOID *ppaHdr) PURE;
        virtual BOOL    IsBufferDone(PVIDEOHDR pVHdr) PURE;

        protected:

        friend class CTAPIVCap;
        friend class CTAPIBasePin;
        friend class CPreviewPin;
        friend class CWDMStreamer;
        friend class CConverter;
        friend class CICMConverter;
        friend class CH26XEncoder;

        // Owner filter
        CTAPIVCap *m_pCaptureFilter;

        // Capture device index
        DWORD m_dwDeviceIndex;

        // cap dev info
        VIDEOCAPTUREDEVICEINFO m_vcdi;
        BOOL m_bCached_vcdi;

        // Capture device caps
        DWORD m_dwDialogs;
        DWORD m_dwImageSize;
        DWORD m_dwFormat;
        DWORD m_dwStreamingMode;

        // Configuration dialogs
        BOOL  m_fDialogUp;

        // Camera control
        LONG m_lCCPan;
        LONG m_lCCTilt;
        LONG m_lCCZoom;
};

/****************************************************************************
 *  @doc INTERNAL CTAPIVCAPCLASS
 *
 *  @class CTAPIVCap | This class implements the TAPI Capture Source
 *    filter.
 *
 *  @mdata CCritSec | CTAPIVCap | m_lock | Critical section used for
 *    locking by the <c CBaseFilter> base class.
 *
 *  @mdata CCapturePin | CTAPIVCap | m_pCapturePin | Pointer to the capture pin
 *    object
 *
 *  @mdata COverlayPin | CTAPIVCap | m_pOverlayPin | Pointer to the overlay
 *    pin object
 *
 *  @mdata CPreviewPin | CTAPIVCap | m_pPreviewPin | Pointer to the preview
 *    pin object
 *
 *  @mdata BOOL | CTAPIVCap | m_fDialogUp | Set to TRUE if a VfW driver
 *    dialog box is up
 ***************************************************************************/
class CVfWCapDev : public CCapDev
{
        public:

        DECLARE_IUNKNOWN
        STDMETHODIMP NonDelegatingQueryInterface(IN REFIID riid, OUT PVOID *ppv);
        CVfWCapDev(IN TCHAR *pObjectName, IN CTAPIVCap *pCaptureFilter, IN LPUNKNOWN pUnkOuter, IN DWORD dwDeviceIndex, IN HRESULT *pHr);
        ~CVfWCapDev();
        static HRESULT CALLBACK CreateVfWCapDev(IN CTAPIVCap *pCaptureFilter, IN DWORD dwDeviceIndex, OUT CCapDev **ppCapDev);

        // Implement IAMVfwCaptureDialogs
        STDMETHODIMP HasDialog(IN int iDialog);
        STDMETHODIMP ShowDialog(IN int iDialog, IN HWND hwnd);
        STDMETHODIMP SendDriverMessage(IN int iDialog, IN int uMsg, IN long dw1, IN long dw2);

        // Device control
        HRESULT ProfileCaptureDevice();
        HRESULT ConnectToDriver();
        HRESULT DisconnectFromDriver();
        HRESULT SendFormatToDriver(IN LONG biWidth, IN LONG biHeight, IN DWORD biCompression, IN WORD biBitCount, IN REFERENCE_TIME AvgTimePerFrame, BOOL fUseExactFormat);
        HRESULT GetFormatFromDriver(OUT VIDEOINFOHEADER **ppvi);

        // Streaming and frame grabbing control
        HRESULT InitializeStreaming(DWORD usPerFrame, DWORD_PTR hEvtBufferDone);
        HRESULT StartStreaming();
        HRESULT StopStreaming();
        HRESULT TerminateStreaming();
        HRESULT GrabFrame(PVIDEOHDR pVHdr);
        HRESULT AllocateBuffer(LPTHKVIDEOHDR *pptvh, DWORD dwIndex, DWORD cbBuffer);
        HRESULT AddBuffer(PVIDEOHDR pVHdr, DWORD cbVHdr);
        HRESULT FreeBuffer(LPTHKVIDEOHDR pVHdr); //previously  PVIDEOHDR pVHdr
        HRESULT AllocateHeaders(DWORD dwNumHdrs, DWORD cbHdr, LPVOID *ppaHdr);
        BOOL    IsBufferDone(PVIDEOHDR pVHdr);

        private:

        UINT    m_dwDeviceID;   // id of VfW video driver to open
        HVIDEO  m_hVideoIn;             // video input
        HVIDEO  m_hVideoExtIn;  // external in (source control)
        HVIDEO  m_hVideoExtOut; // external out (overlay; not required)
        BOOL    m_bHasOverlay;  // TRUE if ExtOut has overlay support
};

// Used to query and set video data ranges of a device
typedef struct _tagVideoDataRanges {
    ULONG   Size;
    ULONG   Count;
    KS_DATARANGE_VIDEO Data;
} VIDEO_DATA_RANGES, * PVIDEO_DATA_RANGES;

/*****************************************************************************
 * @doc INTERNAL VIDEOSTRUCTENUM
 *
 * @struct DATAPINCONNECT | The <t DATAPINCONNECT> structure is used to
 *   connect to a streaming video pin.
 *
 * @field KSPIN_CONNECT | Connect | Describes how the connection is to be
 *   done.
 *
 * @field KS_DATAFORMAT_VIDEOINFOHEADER | Data | Describes the video format
 *   of the video data streaming from a video pin.
 ***************************************************************************/
// Structure used to connect to a streaming video pin
typedef struct _tagStreamConnect
{
        KSPIN_CONNECT                                   Connect;
        KS_DATAFORMAT_VIDEOINFO_PALETTE Data;
} DATAPINCONNECT, *PDATAPINCONNECT;

#define INVALID_PIN_ID (DWORD)-1L

/*****************************************************************************
 * @doc INTERNAL VIDEOSTRUCTENUM
 *
 * @struct KS_HEADER_AND_INFO | The <t KS_HEADER_AND_INFO> structure is used
 *   stream data from a video pin.
 *
 * @field KSSTREAM_HEADER | StreamHeader | Describes how the streaming is to be
 *   done.
 *
 * @field KS_FRAME_INFO | FrameInfo | Describes the video format
 *   of the video data streaming from a video pin.
 ***************************************************************************/
// Video streaming data structure
typedef struct tagKS_HEADER_AND_INFO
{
        KSSTREAM_HEADER StreamHeader;
        KS_FRAME_INFO   FrameInfo;
} KS_HEADER_AND_INFO;

/*****************************************************************************
 * @doc INTERNAL VIDEOSTRUCTENUM
 *
 * @struct BUFSTRUCT | The <t BUFSTRUCT> structure holds the status of each
 *   video streaming buffer.
 *
 * @field LPVIDEOHDR | lpVHdr | Specifies a pointer to the video header of a
 *   video streaming buffer.
 *
 * @field BOOL | fReady | Set to TRUE if the video buffer is available for
 *   video streaming, FALSE if is locked by the application or queued for
 *   an asynchronous read.
 ***************************************************************************/
// Holds status of each video streaming buffer
typedef struct _BUFSTRUCT {
        LPVIDEOHDR lpVHdr;      // Pointer to the video header of the buffer
        BOOL fReady;            // Set to TRUE if the buffer is available for streaming, FALSE otherwise
} BUFSTRUCT, * PBUFSTRUCT;

/*****************************************************************************
 * @doc INTERNAL VIDEOSTRUCTENUM
 *
 * @struct WDMVIDEOBUFF | The <t WDMVIDEOBUFF> structure is used to queue
 *   asynchronous read on a video streaming pin.
 *
 * @field OVERLAPPED | Overlap | Structure used for overlapping IOs.
 *
 * @field BOOL | fBlocking | Set to TRUE if read is going to block.
 *
 * @field KS_HEADER_AND_INFO | SHGetImage | Video streaming structure used
 *   on the video pin to get video data.
 *
 * @field LPVIDEOHDR | pVideoHdr | Pointer to the video header for this WDM
 *   video buffer.
 ***************************************************************************/
// Read buffer structure
typedef struct tagWDMVIDEOBUFF {
        OVERLAPPED                      Overlap;                // Structure used for overlapping IOs
        BOOL                            fBlocking;              // Set to TRUE if the read operation will execute asynchronously
        KS_HEADER_AND_INFO      SHGetImage;             // Video streaming structure used on the video pin
        LPVIDEOHDR                      pVideoHdr;              // Pointer to the video header for this WDM buffer
} WDMVIDEOBUFF, *PWDMVIDEOBUFF;

// For GetProcAddresss on KsCreatePin
typedef DWORD (WINAPI *LPFNKSCREATEPIN)(IN HANDLE FilterHandle, IN PKSPIN_CONNECT Connect, IN ACCESS_MASK DesiredAccess, OUT PHANDLE ConnectionHandle);

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVCLASS
 *
 *  @class CWDMCapDev | This class provides access to the streaming class
 *    driver, through which we acess the video capture mini-driver properties
 *    using IOCtls.
 *
 *  @mdata DWORD | CWDMCapDev | m_dwDeviceID | Capture device ID.
 *
 *  @mdata HANDLE | CWDMCapDev | m_hDriver | This member holds the driver
 *    file handle.
 *
 *  @mdata PVIDEO_DATA_RANGES | CWDMCapDev | m_pVideoDataRanges | This member
 *    points to the video data range structure.
 ***************************************************************************/
class CWDMCapDev : public CCapDev
{
        public:

        DECLARE_IUNKNOWN
        STDMETHODIMP NonDelegatingQueryInterface(IN REFIID riid, OUT PVOID *ppv);
        CWDMCapDev(IN TCHAR *pObjectName, IN CTAPIVCap *pCaptureFilter, IN LPUNKNOWN pUnkOuter, IN DWORD dwDeviceIndex, IN HRESULT *pHr);
        ~CWDMCapDev();
        static HRESULT CALLBACK CreateWDMCapDev(IN CTAPIVCap *pCaptureFilter, IN DWORD dwDeviceIndex, OUT CCapDev **ppCapDev);

        // Implement IAMVfwCaptureDialogs
        STDMETHODIMP HasDialog(IN int iDialog);
        STDMETHODIMP ShowDialog(IN int iDialog, IN HWND hwnd);
        STDMETHODIMP SendDriverMessage(IN int iDialog, IN int uMsg, IN long dw1, IN long dw2) {return E_NOTIMPL;};

        // Implement IAMVideoProcAmp
        STDMETHODIMP Set(IN VideoProcAmpProperty Property, IN long lValue, IN TAPIControlFlags Flags);
        STDMETHODIMP Get(IN VideoProcAmpProperty Property, OUT long *lValue, OUT TAPIControlFlags *Flags);
        STDMETHODIMP GetRange(IN VideoProcAmpProperty Property, OUT long *pMin, OUT long *pMax, OUT long *pSteppingDelta, OUT long *pDefault, OUT TAPIControlFlags *pCapsFlags);

#ifndef USE_SOFTWARE_CAMERA_CONTROL
        // Implement ICameraControl
        STDMETHODIMP Set(IN TAPICameraControlProperty Property, IN long lValue, IN TAPIControlFlags Flags);
        STDMETHODIMP Get(IN TAPICameraControlProperty Property, OUT long *lValue, OUT TAPIControlFlags *Flags);
        STDMETHODIMP GetRange(IN TAPICameraControlProperty Property, OUT long *pMin, OUT long *pMax, OUT long *pSteppingDelta, OUT long *pDefault, OUT TAPIControlFlags *pCapsFlags);
#endif

        // Device control
        HRESULT ProfileCaptureDevice();
        HRESULT ConnectToDriver();
        HRESULT DisconnectFromDriver();
        HRESULT SendFormatToDriver(IN LONG biWidth, IN LONG biHeight, IN DWORD biCompression, IN WORD biBitCount, IN REFERENCE_TIME AvgTimePerFrame, BOOL fUseExactFormat);
        HRESULT GetFormatFromDriver(OUT VIDEOINFOHEADER **ppvi);

        // Streaming and frame grabbing control
        HRESULT InitializeStreaming(DWORD usPerFrame, DWORD_PTR hEvtBufferDone);
        HRESULT StartStreaming();
        HRESULT StopStreaming();
        HRESULT TerminateStreaming();
        HRESULT GrabFrame(PVIDEOHDR pVHdr);
        HRESULT AllocateBuffer(LPTHKVIDEOHDR *pptvh, DWORD dwIndex, DWORD cbBuffer);
        HRESULT AddBuffer(PVIDEOHDR pVHdr, DWORD cbVHdr);
        HRESULT FreeBuffer(LPTHKVIDEOHDR pVHdr); // previously PVIDEOHDR pVHdr
        HRESULT AllocateHeaders(DWORD dwNumHdrs, DWORD cbHdr, LPVOID *ppaHdr);
        BOOL    IsBufferDone(PVIDEOHDR pVHdr);

        // Device IO function
    BOOL DeviceIoControl(HANDLE h, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, BOOL bOverlapped=TRUE);

    // Property functions
    HRESULT GetPropertyValue(GUID guidPropertySet, ULONG ulPropertyId, PLONG plValue, PULONG pulFlags, PULONG pulCapabilities);
    HRESULT GetDefaultValue(GUID guidPropertySet, ULONG ulPropertyId, PLONG plDefValue);
    HRESULT GetRangeValues(GUID guidPropertySet, ULONG ulPropertyId, PLONG plMin, PLONG plMax, PLONG plStep);
    HRESULT SetPropertyValue(GUID guidPropertySet, ULONG ulPropertyId, LONG lValue, ULONG ulFlags, ULONG ulCapabilities);

        private:

        friend class CWDMStreamer;

        XDBGONLY DWORD               m_tag;              //magic sequence (e.g. 'LOLA' , 0x414C4F4C ...)
        HANDLE                          m_hDriver;                              // Driver file handle
        PVIDEO_DATA_RANGES      m_pVideoDataRanges;             // Pin video data ranges
        DWORD                           m_dwPreviewPinId;               // Preview pin Id
        DWORD                           m_dwCapturePinId;               // Capture pin Id
        HANDLE                          m_hKSPin;                               // Handle to the kernel streaming pin
        HINSTANCE                       m_hKsUserDLL;                   // DLL Handle to KsUser.dll
        LPFNKSCREATEPIN         m_pKsCreatePin;                 // KsCreatePin() function pointer
        BOOL                            m_fStarted;                             // Streaming state of the kernel streaming video pin

    // Data range functions
        ULONG   CreateDriverSupportedDataRanges();
        HRESULT FindMatchDataRangeVideo(PBITMAPINFOHEADER pbiHdr, DWORD dwAvgTimePerFrame, BOOL *pfValidMatch, PKS_DATARANGE_VIDEO *ppSelDRVideo);
    HRESULT     GetDriverSupportedDataRanges(PVIDEO_DATA_RANGES *ppDataRanges);

        // Kernel streaming pin control functions
        BOOL Stop();
        BOOL Start();
        BOOL SetState(KSSTATE ksState);

        // Streaming control
        ULONG                   m_cntNumVidBuf;
        LPVIDEOHDR              m_lpVHdrFirst;
        LPVIDEOHDR              m_lpVHdrLast;
        BOOL                    m_fVideoOpen;
        WDMVIDEOBUFF    *m_pWDMVideoBuff;

        // Video streaming buffer management functions
        void BufferDone(LPVIDEOHDR lpVHdr);
        LPVIDEOHDR DeQueueHeader();
        void QueueHeader(LPVIDEOHDR lpVHdr);
        BOOL QueueRead(DWORD dwIndex);

        // Dumps the properties of the adapter
#if defined(DUMP_DRIVER_CHARACTERISTICS) && defined(DEBUG)
        void GetDriverDetails();
#endif
};

class CDShowCapDev : public CCapDev
{
        public:

        DECLARE_IUNKNOWN
        STDMETHODIMP NonDelegatingQueryInterface(IN REFIID riid, OUT PVOID *ppv);
        CDShowCapDev(IN TCHAR *pObjectName, IN CTAPIVCap *pCaptureFilter, IN LPUNKNOWN pUnkOuter, IN DWORD dwDeviceIndex, IN HRESULT *pHr);
        ~CDShowCapDev();
        static HRESULT CALLBACK CreateDShowCapDev(IN CTAPIVCap *pCaptureFilter, IN DWORD dwDeviceIndex, OUT CCapDev **ppCapDev);

        // Implement IAMVfwCaptureDialogs
        STDMETHODIMP HasDialog(IN int iDialog) { return E_NOTIMPL; }
        STDMETHODIMP ShowDialog(IN int iDialog, IN HWND hwnd) { return E_NOTIMPL; }
        STDMETHODIMP SendDriverMessage(IN int iDialog, IN int uMsg, IN long dw1, IN long dw2) {return E_NOTIMPL;};

        // Implement IAMVideoProcAmp
        STDMETHODIMP Set(IN VideoProcAmpProperty Property, IN long lValue, IN TAPIControlFlags Flags) { return E_NOTIMPL; }
        STDMETHODIMP Get(IN VideoProcAmpProperty Property, OUT long *lValue, OUT TAPIControlFlags *Flags) { return E_NOTIMPL; }
        STDMETHODIMP GetRange(IN VideoProcAmpProperty Property, OUT long *pMin, OUT long *pMax, OUT long *pSteppingDelta, OUT long *pDefault, OUT TAPIControlFlags *pCapsFlags) { return E_NOTIMPL; }

#ifndef USE_SOFTWARE_CAMERA_CONTROL
        // Implement ICameraControl
        STDMETHODIMP Set(IN TAPICameraControlProperty Property, IN long lValue, IN TAPIControlFlags Flags) { return E_NOTIMPL; }
        STDMETHODIMP Get(IN TAPICameraControlProperty Property, OUT long *lValue, OUT TAPIControlFlags *Flags) { return E_NOTIMPL; }
        STDMETHODIMP GetRange(IN TAPICameraControlProperty Property, OUT long *pMin, OUT long *pMax, OUT long *pSteppingDelta, OUT long *pDefault, OUT TAPIControlFlags *pCapsFlags) { return E_NOTIMPL; }
#endif

        // Device control
        HRESULT ProfileCaptureDevice();
        HRESULT ConnectToDriver();
        HRESULT DisconnectFromDriver();
        HRESULT SendFormatToDriver(IN LONG biWidth, IN LONG biHeight, IN DWORD biCompression, IN WORD biBitCount, IN REFERENCE_TIME AvgTimePerFrame, BOOL fUseExactFormat);
        HRESULT GetFormatFromDriver(OUT VIDEOINFOHEADER **ppvi);

        // Streaming and frame grabbing control
        HRESULT InitializeStreaming(DWORD usPerFrame, DWORD_PTR hEvtBufferDone);
        HRESULT StartStreaming();
        HRESULT StopStreaming();
        HRESULT TerminateStreaming();
        HRESULT GrabFrame(PVIDEOHDR pVHdr);
        HRESULT AllocateBuffer(LPTHKVIDEOHDR *pptvh, DWORD dwIndex, DWORD cbBuffer);
        HRESULT AddBuffer(PVIDEOHDR pVHdr, DWORD cbVHdr);
        HRESULT FreeBuffer(LPTHKVIDEOHDR pVHdr);
        HRESULT AllocateHeaders(DWORD dwNumHdrs, DWORD cbHdr, LPVOID *ppaHdr);
        BOOL    IsBufferDone(PVIDEOHDR pVHdr);

	DWORD m_dwDeviceIndex;
	CComPtr<IGraphBuilder> m_pGraph;
	CComPtr<ICaptureGraphBuilder2> m_pCGB;
	CComPtr<ISampleGrabber> m_pGrab;
	CComPtr<IBaseFilter> m_pCap;
        CComPtr<CSharedGraph> m_psg;

	AM_MEDIA_TYPE m_mt;	    // our current capture format
        HANDLE m_hEvent;	    // signal the app when a frame is captured
        DWORD m_usPerFrame;
	
	// the latest buffer captured by the sample grabber
	int m_cbBuffer;
	BYTE *m_pBuffer;
	int m_cbBufferValid;
	CCritSec m_csBuffer;// don't read and write into it at the same time
	CCritSec m_csStack; // don't muck with variables we're looking at
	BOOL m_fEventMode;   // event fire mode or frame grabbing mode?
	int m_cBuffers;	    // how many buffers we're capturing with

#define MAX_BSTACK 100

	int m_aStack[MAX_BSTACK];	    // the order we're to fill the buffers
	int m_nTop;	    // top of the stack (push)
	int m_nBottom;	    // bottom of the stack (pull)

        HRESULT BuildGraph(AM_MEDIA_TYPE&);
        static void VideoCallback(void *pContext, IMediaSample *pSample);
	static HRESULT MakeMediaType(AM_MEDIA_TYPE *, VIDEOINFOHEADER *);
	HRESULT FixDVSize(DWORD, DWORD, REFERENCE_TIME);
};

#endif // _DEVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\devicep.cpp ===
/****************************************************************************
 *  @doc INTERNAL DEVICEP
 *
 *  @module DeviceP.cpp | Source file for the <c CDeviceProperties>
 *    class used to implement a property page to test the <i IAMVfwCaptureDialogs>
 *    and <i IVideoDeviceControl> interfaces.
 *
 *  @comm This code tests the TAPI Capture Filter <i IVideoDeviceControl>
 *    and <i IAMVfwCaptureDialogs> implementations. This code is only compiled
 *    if USE_PROPERTY_PAGES is defined.
 ***************************************************************************/

#include "Precomp.h"

#ifdef USE_PROPERTY_PAGES

/****************************************************************************
 *  @doc INTERNAL CDEVICEPMETHOD
 *
 *  @mfunc CUnknown* | CDeviceProperties | CreateInstance | This
 *    method is called by DShow to create an instance of a Capture Device
 *    Property Page. It is referred to in the global structure <t g_Templates>.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Returns a pointer to the nondelegating CUnknown portion of the
 *    object, or NULL otherwise.
 ***************************************************************************/
CUnknown* CALLBACK CDevicePropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr) 
{
	CUnknown *pUnknown = (CUnknown *)NULL;

	FX_ENTRY("CDevicePropertiesCreateInstance")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pHr);
	if (!pHr)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		goto MyExit;
	}

	if (!(pUnknown = new CDeviceProperties(pUnkOuter, pHr)))
	{
		*pHr = E_OUTOFMEMORY;
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: new CDeviceProperties failed", _fx_));
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: new CDeviceProperties created", _fx_));
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return pUnknown;
}

/****************************************************************************
 *  @doc INTERNAL CDEVICEPMETHOD
 *
 *  @mfunc void | CDeviceProperties | CDeviceProperties | This
 *    method is the constructor for the property page object. It simply
 *    calls the constructor of the property page base class.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CDeviceProperties::CDeviceProperties(LPUNKNOWN pUnk, HRESULT *pHr) : CBasePropertyPage(NAME("Capture Device Property Page"), pUnk, IDD_CaptureDeviceProperties, IDS_DEVICEPROPNAME)
{
	FX_ENTRY("CDeviceProperties::CDeviceProperties")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	m_pIVideoDeviceControl = NULL;
	m_pIAMVfwCaptureDialogs = NULL;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CDEVICEPMETHOD
 *
 *  @mfunc void | CDeviceProperties | ~CDeviceProperties | This
 *    method is the destructor for capture device property page. It
 *    simply calls the base class destructor.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CDeviceProperties::~CDeviceProperties()
{
	FX_ENTRY("CDeviceProperties::~CDeviceProperties")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	if (!m_pIVideoDeviceControl)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: already released!", _fx_));
	}
	else
	{
		// Release the interface
		m_pIVideoDeviceControl->Release();
		m_pIVideoDeviceControl = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: releasing m_pIVideoDeviceControl", _fx_));
	}

	if (!m_pIAMVfwCaptureDialogs)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: already released!", _fx_));
	}
	else
	{
		// Release the interface
		m_pIAMVfwCaptureDialogs->Release();
		m_pIAMVfwCaptureDialogs = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: releasing m_pIAMVfwCaptureDialogs", _fx_));
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CDEVICEPMETHOD
 *
 *  @mfunc HRESULT | CDeviceProperties | OnConnect | This
 *    method is called when the property page is connected to the filter.
 *
 *  @parm LPUNKNOWN | pUnknown | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CDeviceProperties::OnConnect(IUnknown *pUnk)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CDeviceProperties::OnConnect")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pUnk);
	if (!pUnk)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Get the capture device interface
	if (SUCCEEDED (Hr = pUnk->QueryInterface(__uuidof(IVideoDeviceControl),(void **)&m_pIVideoDeviceControl)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_pIVideoDeviceControl=0x%08lX", _fx_, m_pIVideoDeviceControl));
	}
	else
	{
		m_pIVideoDeviceControl = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: IOCTL failed Hr=0x%08lX", _fx_, Hr));
	}

	// Get the VfW capture device dialogs interface
	if (SUCCEEDED (Hr = pUnk->QueryInterface(__uuidof(IAMVfwCaptureDialogs),(void **)&m_pIAMVfwCaptureDialogs)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_pIAMVfwCaptureDialogs=0x%08lX", _fx_, m_pIAMVfwCaptureDialogs));
	}
	else
	{
		m_pIAMVfwCaptureDialogs = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: IOCTL failed Hr=0x%08lX", _fx_, Hr));
	}

	// It's Ok if we couldn't get interface pointers
	// We'll just grey the controls in the property page
	// to make it clear to the user that they can't
	// control those properties on the device
	Hr = NOERROR;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CDEVICEPMETHOD
 *
 *  @mfunc HRESULT | CDeviceProperties | OnDisconnect | This
 *    method is called when the property page is disconnected from the owning
 *    filter.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CDeviceProperties::OnDisconnect()
{
	FX_ENTRY("CDeviceProperties::OnDisconnect")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters: we seem to get called several times here
	// Make sure the interface pointer is still valid
	if (!m_pIVideoDeviceControl)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: already disconnected!", _fx_));
	}
	else
	{
		// Release the interface
		m_pIVideoDeviceControl->Release();
		m_pIVideoDeviceControl = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: releasing m_pIVideoDeviceControl", _fx_));
	}

	// Make sure the interface pointer is still valid
	if (!m_pIAMVfwCaptureDialogs)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: already disconnected!", _fx_));
	}
	else
	{
		// Release the interface
		m_pIAMVfwCaptureDialogs->Release();
		m_pIAMVfwCaptureDialogs = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: releasing m_pIAMVfwCaptureDialogs", _fx_));
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CDEVICEPMETHOD
 *
 *  @mfunc BOOL | CDeviceProperties | OnReceiveMessage | This
 *    method is called when a message is sent to the property page dialog box.
 *
 *  @rdesc By default, returns the value returned by the Win32 DefWindowProc function.
 ***************************************************************************/
BOOL CDeviceProperties::OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
	VIDEOCAPTUREDEVICEINFO	DeviceInfo;
	DWORD		dwDeviceIndex;
	DWORD		dwNumDevices;

	switch (uMsg)
	{
		case WM_INITDIALOG:
			EnableWindow(GetDlgItem(hWnd, IDC_Device_SourceDlg), (BOOL)(m_pIAMVfwCaptureDialogs && m_pIAMVfwCaptureDialogs->HasDialog(VfwCaptureDialog_Source) == S_OK));
			EnableWindow(GetDlgItem(hWnd, IDC_Device_FormatDlg), (BOOL)(m_pIAMVfwCaptureDialogs && m_pIAMVfwCaptureDialogs->HasDialog(VfwCaptureDialog_Format) == S_OK));
			EnableWindow(GetDlgItem(hWnd, IDC_Device_DisplayDlg), (BOOL)(m_pIAMVfwCaptureDialogs && m_pIAMVfwCaptureDialogs->HasDialog(VfwCaptureDialog_Display) == S_OK));
			if (m_pIVideoDeviceControl && SUCCEEDED(m_pIVideoDeviceControl->GetNumDevices(&dwNumDevices)) && dwNumDevices && SUCCEEDED(m_pIVideoDeviceControl->GetCurrentDevice(&dwDeviceIndex)))
			{
				m_dwOriginalDeviceIndex = dwDeviceIndex;

				// Populate the combo box
				ComboBox_ResetContent(GetDlgItem(hWnd, IDC_Device_Selection));
				for (dwDeviceIndex = 0; dwDeviceIndex < dwNumDevices; dwDeviceIndex++)
				{
					if (SUCCEEDED(m_pIVideoDeviceControl->GetDeviceInfo(dwDeviceIndex, &DeviceInfo)))
					{
						ComboBox_AddString(GetDlgItem(hWnd, IDC_Device_Selection), DeviceInfo.szDeviceDescription);

						// Update current device information
						if (dwDeviceIndex == m_dwOriginalDeviceIndex)
						{
							ComboBox_SetCurSel(GetDlgItem(hWnd, IDC_Device_Selection), m_dwOriginalDeviceIndex);
							SetDlgItemText(hWnd, IDC_Overlay_Support, DeviceInfo.fHasOverlay ? "Available" : "Not Available");
							SetDlgItemText(hWnd, IDC_Capture_Mode, DeviceInfo.nCaptureMode == CaptureMode_FrameGrabbing ? "Frame Grabbing" : "Streaming");
							SetDlgItemText(hWnd, IDC_Device_Type,
                                                                       DeviceInfo.nDeviceType ==  DeviceType_VfW ? "VfW Driver" :
                                                                       (DeviceInfo.nDeviceType ==  DeviceType_DShow ? "DShow Special" :
                                                                        "WDM Driver"));
							SetDlgItemText(hWnd, IDC_Device_Version, DeviceInfo.szDeviceVersion);
						}
					}
				}
			}
			else
			{
				EnableWindow(GetDlgItem(hWnd, IDC_Device_Selection), FALSE);
				EnableWindow(GetDlgItem(hWnd, IDC_CONTROL_DEFAULT), FALSE);
			}
			return TRUE; // Don't call setfocus

		case WM_COMMAND:

			// This message gets sent even before OnActivate() has been
			// called(!). We need to test and make sure the controls have
			// beeen initialized before we can use them.

			switch (LOWORD(wParam))
			{
				case IDC_Device_SourceDlg:
					if (m_pIAMVfwCaptureDialogs)
						m_pIAMVfwCaptureDialogs->ShowDialog(VfwCaptureDialog_Source, hWnd);
					break;

				case IDC_Device_FormatDlg:
					if (m_pIAMVfwCaptureDialogs)
						m_pIAMVfwCaptureDialogs->ShowDialog(VfwCaptureDialog_Format, hWnd);
					break;

				case IDC_Device_DisplayDlg:
					if (m_pIAMVfwCaptureDialogs)
						m_pIAMVfwCaptureDialogs->ShowDialog(VfwCaptureDialog_Display, hWnd);
					break;

				case IDC_Device_Selection:
					if (HIWORD(wParam) == CBN_SELCHANGE)
					{
						// Get the index of the selected device
						m_dwCurrentDeviceIndex = ComboBox_GetCurSel(GetDlgItem(hWnd, IDC_Device_Selection));
						if (SUCCEEDED(m_pIVideoDeviceControl->GetDeviceInfo(m_dwCurrentDeviceIndex, &DeviceInfo)))
						{
							// Update current device information
							SetDlgItemText(hWnd, IDC_Overlay_Support, DeviceInfo.fHasOverlay ? "Available" : "Not Available");
							SetDlgItemText(hWnd, IDC_Capture_Mode, DeviceInfo.nCaptureMode == CaptureMode_FrameGrabbing ? "Frame Grabbing" : "Streaming");
							SetDlgItemText(hWnd, IDC_Device_Type, DeviceInfo.nDeviceType ==  DeviceType_VfW ? "VfW Driver" :
                                                                       (DeviceInfo.nDeviceType ==  DeviceType_DShow ? "DShow Special" :
                                                                        "WDM Driver"));
							SetDlgItemText(hWnd, IDC_Device_Version, DeviceInfo.szDeviceVersion);
						}
					}
					break;

				default:
					break;
			}
			break;

		default:
			return FALSE;
	}

	return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\devicep.h ===
/****************************************************************************
 *  @doc INTERNAL DEVICEP
 *
 *  @module DeviceP.h | Header file for the <c CDeviceProperties>
 *    class used to implement a property page to test the <i IAMVfwCaptureDialogs>
 *    and <i IVideoDeviceControl> interfaces.
 *
 *  @comm This code tests the TAPI Capture Filter <i IVideoDeviceControl>
 *    and <i IAMVfwCaptureDialogs> implementations. This code is only compiled
 *    if USE_PROPERTY_PAGES is defined.
 ***************************************************************************/

#ifndef _DEVICEP_H_
#define _DEVICEP_H_

#ifdef USE_PROPERTY_PAGES

/****************************************************************************
 *  @doc INTERNAL CDEVICEPCLASS
 *
 *  @class CDeviceProperties | This class implements a property page
 *    to test the new TAPI internal interface <i IVideoDeviceControl>.
 *
 *  @mdata IVideoDeviceControl* | CDeviceProperties | m_pIVideoDeviceControl | Pointer
 *    to the <i IVideoDeviceControl> interface.
 *
 *  @mdata IAMVfwCaptureDialogs* | CDeviceProperties | m_pIAMVfwCaptureDialogs | Pointer
 *    to the <i IAMVfwCaptureDialogs> interface.
 *
 *  @comm This code tests the TAPI Capture Pin <i IVideoDeviceControl>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
 ***************************************************************************/
class CDeviceProperties : public CBasePropertyPage
{
	public:
	CDeviceProperties(LPUNKNOWN pUnk, HRESULT *pHr);
	~CDeviceProperties();


	HRESULT OnConnect(IUnknown *pUnk);
	HRESULT OnDisconnect();
	BOOL    OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

	private:
	IVideoDeviceControl *m_pIVideoDeviceControl;
	IAMVfwCaptureDialogs *m_pIAMVfwCaptureDialogs;

	DWORD m_dwOriginalDeviceIndex;
	DWORD m_dwCurrentDeviceIndex;
};

#endif // USE_PROPERTY_PAGES

#endif // _DEVICEP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\formats.cpp ===
/****************************************************************************
 *  @doc INTERNAL FORMATS
 *
 *  @module Formats.cpp | Source file for the <c CTAPIBasePin>
 *    class methods used to implement the video capture and preview output
 *    pin format manipulation methods. This includes the <i IAMStreamConfig>
 *    interface methods.
 ***************************************************************************/

#include "Precomp.h"

// H.263 Version 1 CIF size
#define CIF_BUFFER_SIZE 32768
#define D_X_CIF 352
#define D_Y_CIF 288

const VIDEO_STREAM_CONFIG_CAPS VSCC_M26X_Capture_CIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // GUID
    AnalogVideo_None,                                           // VideoStandard
    D_X_CIF, D_Y_CIF,                                           // InputSize, (the inherent size of the incoming signal with every digitized pixel unique)
    D_X_CIF, D_Y_CIF,                                           // MinCroppingSize, smallest rcSrc cropping rect allowed
    D_X_CIF, D_Y_CIF,                                           // MaxCroppingSize, largest  rcSrc cropping rect allowed
    1,                                                                          // CropGranularityX, granularity of cropping size
    1,                                                                          // CropGranularityY
    1,                                                                          // CropAlignX, alignment of cropping rect
    1,                                                                          // CropAlignY;
    D_X_CIF, D_Y_CIF,                                           // MinOutputSize, smallest bitmap stream can produce
    D_X_CIF, D_Y_CIF,                                           // MaxOutputSize, largest  bitmap stream can produce
    1,                                                                          // OutputGranularityX, granularity of output bitmap size
    1,                                                                          // OutputGranularityY;
    0,                                                                          // StretchTapsX
    0,                                                                          // StretchTapsY
    0,                                                                          // ShrinkTapsX
    0,                                                                          // ShrinkTapsY
    MIN_FRAME_INTERVAL,                                         // MinFrameInterval, 100 nS units
    MAX_FRAME_INTERVAL,                                         // MaxFrameInterval, 100 nS units
    0,                                                                          // MinBitsPerSecond
    CIF_BUFFER_SIZE * 30 * 8                            // MaxBitsPerSecond;
};

const VIDEOINFOHEADER_H263 VIH_M263_Capture_CIF =
{
    0,0,0,0,                                                            // RECT  rcSource;
    0,0,0,0,                                                            // RECT  rcTarget;
    CIF_BUFFER_SIZE * 30 * 8,                           // DWORD dwBitRate;
    0L,                                                                         // DWORD dwBitErrorRate;
    MIN_FRAME_INTERVAL,                                         // REFERENCE_TIME  AvgTimePerFrame;

        {
                sizeof (BITMAPINFOHEADER_H263),         // DWORD biSize;
                D_X_CIF,                                                        // LONG  biWidth;
                D_Y_CIF,                                                        // LONG  biHeight;
                1,                                                                      // WORD  biPlanes;
#ifdef USE_OLD_FORMAT_DEFINITION
                24,                                                                     // WORD  biBitCount;
#else
                0,                                                                      // WORD  biBitCount;
#endif
                FOURCC_M263,                                            // DWORD biCompression;
                CIF_BUFFER_SIZE,                                        // DWORD biSizeImage;
                0,                                                                      // LONG  biXPelsPerMeter;
                0,                                                                      // LONG  biYPelsPerMeter;
                0,                                                                      // DWORD biClrUsed;
                0,                                                                      // DWORD biClrImportant;

#ifndef USE_OLD_FORMAT_DEFINITION
                // H.263 specific fields
                CIF_BUFFER_SIZE * 30 * 8 / 100,     // dwMaxBitrate
                CIF_BUFFER_SIZE * 8 / 1024,                     // dwBppMaxKb
                0,                                                                      // dwHRD_B

                //Options
                0,                                                                      // fUnrestrictedVector
                0,                                                                      // fArithmeticCoding
                0,                                                                      // fAdvancedPrediction
                0,                                                                      // fPBFrames
                0,                                                                      // fErrorCompensation
                0,                                                                      // fAdvancedIntraCodingMode
                0,                                                                      // fDeblockingFilterMode
                0,                                                                      // fImprovedPBFrameMode
                0,                                                                      // fUnlimitedMotionVectors
                0,                                                                      // fFullPictureFreeze
                0,                                                                      // fPartialPictureFreezeAndRelease
                0,                                                                      // fResizingPartPicFreezeAndRelease
                0,                                                                      // fFullPictureSnapshot
                0,                                                                      // fPartialPictureSnapshot
                0,                                                                      // fVideoSegmentTagging
                0,                                                                      // fProgressiveRefinement
                0,                                                                      // fDynamicPictureResizingByFour
                0,                                                                      // fDynamicPictureResizingSixteenthPel
                0,                                                                      // fDynamicWarpingHalfPel
                0,                                                                      // fDynamicWarpingSixteenthPel
                0,                                                                      // fIndependentSegmentDecoding
                0,                                                                      // fSlicesInOrder-NonRect
                0,                                                                      // fSlicesInOrder-Rect
                0,                                                                      // fSlicesNoOrder-NonRect
                0,                                                                      // fSlicesNoOrder-NonRect
                0,                                                                      // fAlternateInterVLCMode
                0,                                                                      // fModifiedQuantizationMode
                0,                                                                      // fReducedResolutionUpdate
                0,                                                                      // fReserved

                // Reserved
                0, 0, 0, 0                                                      // dwReserved[4]
#endif
        }
};

const AM_MEDIA_TYPE AMMT_M263_Capture_CIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // majortype
    STATIC_MEDIASUBTYPE_H263_V1,                        // subtype
    FALSE,                                                                      // bFixedSizeSamples (all samples same size?)
    TRUE,                                                                       // bTemporalCompression (uses prediction?)
    0,                                                                          // lSampleSize => VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
        NULL,                                                                   // pUnk
        sizeof (VIH_M263_Capture_CIF),                  // cbFormat
        (LPBYTE)&VIH_M263_Capture_CIF,                  // pbFormat
};

// H.263 Version 1 QCIF size
#define QCIF_BUFFER_SIZE 8192
#define D_X_QCIF 176
#define D_Y_QCIF 144

const VIDEO_STREAM_CONFIG_CAPS VSCC_M26X_Capture_QCIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                                             // GUID
    AnalogVideo_None,                                           // VideoStandard
    D_X_QCIF, D_Y_QCIF,                                         // InputSize, (the inherent size of the incoming signal with every digitized pixel unique)
    D_X_QCIF, D_Y_QCIF,                                         // MinCroppingSize, smallest rcSrc cropping rect allowed
    D_X_QCIF, D_Y_QCIF,                                         // MaxCroppingSize, largest  rcSrc cropping rect allowed
    1,                                                                          // CropGranularityX, granularity of cropping size
    1,                                                                          // CropGranularityY
    1,                                                                          // CropAlignX, alignment of cropping rect
    1,                                                                          // CropAlignY;
    D_X_QCIF, D_Y_QCIF,                                         // MinOutputSize, smallest bitmap stream can produce
    D_X_QCIF, D_Y_QCIF,                                         // MaxOutputSize, largest  bitmap stream can produce
    1,                                                                          // OutputGranularityX, granularity of output bitmap size
    1,                                                                          // OutputGranularityY;
    0,                                                                          // StretchTapsX
    0,                                                                          // StretchTapsY
    0,                                                                          // ShrinkTapsX
    0,                                                                          // ShrinkTapsY
    MIN_FRAME_INTERVAL,                                         // MinFrameInterval, 100 nS units
    MAX_FRAME_INTERVAL,                                         // MaxFrameInterval, 100 nS units
    0,                                                                          // MinBitsPerSecond
    QCIF_BUFFER_SIZE * 30 * 8                           // MaxBitsPerSecond;
};

const VIDEOINFOHEADER_H263 VIH_M263_Capture_QCIF =
{
    0,0,0,0,                                                            // RECT  rcSource;
    0,0,0,0,                                                            // RECT  rcTarget;
    QCIF_BUFFER_SIZE * 30 * 8,                          // DWORD dwBitRate;
    0L,                                                                         // DWORD dwBitErrorRate;
    MIN_FRAME_INTERVAL,                                         // REFERENCE_TIME  AvgTimePerFrame;

        {
                sizeof (BITMAPINFOHEADER_H263),         // DWORD biSize;
                D_X_QCIF,                                                       // LONG  biWidth;
                D_Y_QCIF,                                                       // LONG  biHeight;
                1,                                                                      // WORD  biPlanes;
#ifdef USE_OLD_FORMAT_DEFINITION
                24,                                                                     // WORD  biBitCount;
#else
                0,                                                                      // WORD  biBitCount;
#endif
                FOURCC_M263,                                            // DWORD biCompression;
                QCIF_BUFFER_SIZE,                                       // DWORD biSizeImage;
                0,                                                                      // LONG  biXPelsPerMeter;
                0,                                                                      // LONG  biYPelsPerMeter;
                0,                                                                      // DWORD biClrUsed;
                0,                                                                      // DWORD biClrImportant;

#ifndef USE_OLD_FORMAT_DEFINITION
                // H.263 specific fields
                QCIF_BUFFER_SIZE * 30 * 8 / 100,        // dwMaxBitrate
                QCIF_BUFFER_SIZE * 8 / 1024,            // dwBppMaxKb
                0,                                                                      // dwHRD_B

                //Options
                0,                                                                      // fUnrestrictedVector
                0,                                                                      // fArithmeticCoding
                0,                                                                      // fAdvancedPrediction
                0,                                                                      // fPBFrames
                0,                                                                      // fErrorCompensation
                0,                                                                      // fAdvancedIntraCodingMode
                0,                                                                      // fDeblockingFilterMode
                0,                                                                      // fImprovedPBFrameMode
                0,                                                                      // fUnlimitedMotionVectors
                0,                                                                      // fFullPictureFreeze
                0,                                                                      // fPartialPictureFreezeAndRelease
                0,                                                                      // fResizingPartPicFreezeAndRelease
                0,                                                                      // fFullPictureSnapshot
                0,                                                                      // fPartialPictureSnapshot
                0,                                                                      // fVideoSegmentTagging
                0,                                                                      // fProgressiveRefinement
                0,                                                                      // fDynamicPictureResizingByFour
                0,                                                                      // fDynamicPictureResizingSixteenthPel
                0,                                                                      // fDynamicWarpingHalfPel
                0,                                                                      // fDynamicWarpingSixteenthPel
                0,                                                                      // fIndependentSegmentDecoding
                0,                                                                      // fSlicesInOrder-NonRect
                0,                                                                      // fSlicesInOrder-Rect
                0,                                                                      // fSlicesNoOrder-NonRect
                0,                                                                      // fSlicesNoOrder-NonRect
                0,                                                                      // fAlternateInterVLCMode
                0,                                                                      // fModifiedQuantizationMode
                0,                                                                      // fReducedResolutionUpdate
                0,                                                                      // fReserved

                // Reserved
                0, 0, 0, 0                                                      // dwReserved[4]
#endif
        }
};

const AM_MEDIA_TYPE AMMT_M263_Capture_QCIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // majortype
    STATIC_MEDIASUBTYPE_H263_V1,                        // subtype
    FALSE,                                                                      // bFixedSizeSamples (all samples same size?)
    TRUE,                                                                       // bTemporalCompression (uses prediction?)
    0,                                                                          // lSampleSize => VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
        NULL,                                                                   // pUnk
        sizeof (VIH_M263_Capture_QCIF),                 // cbFormat
        (LPBYTE)&VIH_M263_Capture_QCIF,                 // pbFormat
};

// H.263 Versions 1 SQCIF size
#define SQCIF_BUFFER_SIZE 8192
#define D_X_SQCIF 128
#define D_Y_SQCIF 96

const VIDEO_STREAM_CONFIG_CAPS VSCC_M263_Capture_SQCIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                                             // GUID
    AnalogVideo_None,                                           // VideoStandard
    D_X_SQCIF, D_Y_SQCIF,                                       // InputSize, (the inherent size of the incoming signal with every digitized pixel unique)
    D_X_SQCIF, D_Y_SQCIF,                                       // MinCroppingSize, smallest rcSrc cropping rect allowed
    D_X_SQCIF, D_Y_SQCIF,                                       // MaxCroppingSize, largest  rcSrc cropping rect allowed
    1,                                                                          // CropGranularityX, granularity of cropping size
    1,                                                                          // CropGranularityY
    1,                                                                          // CropAlignX, alignment of cropping rect
    1,                                                                          // CropAlignY;
    D_X_SQCIF, D_Y_SQCIF,                                       // MinOutputSize, smallest bitmap stream can produce
    D_X_SQCIF, D_Y_SQCIF,                                       // MaxOutputSize, largest  bitmap stream can produce
    1,                                                                          // OutputGranularityX, granularity of output bitmap size
    1,                                                                          // OutputGranularityY;
    0,                                                                          // StretchTapsX
    0,                                                                          // StretchTapsY
    0,                                                                          // ShrinkTapsX
    0,                                                                          // ShrinkTapsY
    MIN_FRAME_INTERVAL,                                         // MinFrameInterval, 100 nS units
    MAX_FRAME_INTERVAL,                                         // MaxFrameInterval, 100 nS units
    0,                                                                          // MinBitsPerSecond
    SQCIF_BUFFER_SIZE * 30 * 8                          // MaxBitsPerSecond;
};

const VIDEOINFOHEADER_H263 VIH_M263_Capture_SQCIF =
{
    0,0,0,0,                                                            // RECT  rcSource;
    0,0,0,0,                                                            // RECT  rcTarget;
    SQCIF_BUFFER_SIZE * 30 * 8,                         // DWORD dwBitRate;
    0L,                                                                         // DWORD dwBitErrorRate;
    MIN_FRAME_INTERVAL,                                         // REFERENCE_TIME  AvgTimePerFrame;

        {
                sizeof (BITMAPINFOHEADER_H263),         // DWORD biSize;
                D_X_SQCIF,                                                      // LONG  biWidth;
                D_Y_SQCIF,                                                      // LONG  biHeight;
                1,                                                                      // WORD  biPlanes;
#ifdef USE_OLD_FORMAT_DEFINITION
                24,                                                                     // WORD  biBitCount;
#else
                0,                                                                      // WORD  biBitCount;
#endif
                FOURCC_M263,                                            // DWORD biCompression;
                SQCIF_BUFFER_SIZE,                                      // DWORD biSizeImage;
                0,                                                                      // LONG  biXPelsPerMeter;
                0,                                                                      // LONG  biYPelsPerMeter;
                0,                                                                      // DWORD biClrUsed;
                0,                                                                      // DWORD biClrImportant;

#ifndef USE_OLD_FORMAT_DEFINITION
                // H.263 specific fields
                SQCIF_BUFFER_SIZE * 30 * 8 / 100,       // dwMaxBitrate
                SQCIF_BUFFER_SIZE * 8 / 1024,           // dwBppMaxKb
                0,                                                                      // dwHRD_B

                //Options
                0,                                                                      // fUnrestrictedVector
                0,                                                                      // fArithmeticCoding
                0,                                                                      // fAdvancedPrediction
                0,                                                                      // fPBFrames
                0,                                                                      // fErrorCompensation
                0,                                                                      // fAdvancedIntraCodingMode
                0,                                                                      // fDeblockingFilterMode
                0,                                                                      // fImprovedPBFrameMode
                0,                                                                      // fUnlimitedMotionVectors
                0,                                                                      // fFullPictureFreeze
                0,                                                                      // fPartialPictureFreezeAndRelease
                0,                                                                      // fResizingPartPicFreezeAndRelease
                0,                                                                      // fFullPictureSnapshot
                0,                                                                      // fPartialPictureSnapshot
                0,                                                                      // fVideoSegmentTagging
                0,                                                                      // fProgressiveRefinement
                0,                                                                      // fDynamicPictureResizingByFour
                0,                                                                      // fDynamicPictureResizingSixteenthPel
                0,                                                                      // fDynamicWarpingHalfPel
                0,                                                                      // fDynamicWarpingSixteenthPel
                0,                                                                      // fIndependentSegmentDecoding
                0,                                                                      // fSlicesInOrder-NonRect
                0,                                                                      // fSlicesInOrder-Rect
                0,                                                                      // fSlicesNoOrder-NonRect
                0,                                                                      // fSlicesNoOrder-NonRect
                0,                                                                      // fAlternateInterVLCMode
                0,                                                                      // fModifiedQuantizationMode
                0,                                                                      // fReducedResolutionUpdate
                0,                                                                      // fReserved

                // Reserved
                0, 0, 0, 0                                                      // dwReserved[4]
#endif
        }
};

const AM_MEDIA_TYPE AMMT_M263_Capture_SQCIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // majortype
    STATIC_MEDIASUBTYPE_H263_V1,                        // subtype
    FALSE,                                                                      // bFixedSizeSamples (all samples same size?)
    TRUE,                                                                       // bTemporalCompression (uses prediction?)
    0,                                                                          // lSampleSize => VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
        NULL,                                                                   // pUnk
        sizeof (VIH_M263_Capture_SQCIF),                // cbFormat
        (LPBYTE)&VIH_M263_Capture_SQCIF,                // pbFormat
};

// H.261 CIF size
const VIDEOINFOHEADER_H261 VIH_M261_Capture_CIF =
{
    0,0,0,0,                                                            // RECT  rcSource;
    0,0,0,0,                                                            // RECT  rcTarget;
    CIF_BUFFER_SIZE * 30 * 8,                           // DWORD dwBitRate;
    0L,                                                                         // DWORD dwBitErrorRate;
    MIN_FRAME_INTERVAL,                                         // REFERENCE_TIME  AvgTimePerFrame;

        {
                sizeof (BITMAPINFOHEADER_H261),         // DWORD biSize;
                D_X_CIF,                                                        // LONG  biWidth;
                D_Y_CIF,                                                        // LONG  biHeight;
                1,                                                                      // WORD  biPlanes;
#ifdef USE_OLD_FORMAT_DEFINITION
                24,                                                                     // WORD  biBitCount;
#else
                0,                                                                      // WORD  biBitCount;
#endif
                FOURCC_M261,                                            // DWORD biCompression;
                CIF_BUFFER_SIZE,                                        // DWORD biSizeImage;
                0,                                                                      // LONG  biXPelsPerMeter;
                0,                                                                      // LONG  biYPelsPerMeter;
                0,                                                                      // DWORD biClrUsed;
                0,                                                                      // DWORD biClrImportant;

#ifndef USE_OLD_FORMAT_DEFINITION
                // H.261 specific fields
                CIF_BUFFER_SIZE * 30 * 8 / 100,     // dwMaxBitrate
                0,                                                                      // fStillImageTransmission

                // Reserved
                0, 0, 0, 0                                                      // dwReserved[4]
#endif
        }
};

const AM_MEDIA_TYPE AMMT_M261_Capture_CIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // majortype
    STATIC_MEDIASUBTYPE_H261,                           // subtype
    FALSE,                                                                      // bFixedSizeSamples (all samples same size?)
    TRUE,                                                                       // bTemporalCompression (uses prediction?)
    0,                                                                          // lSampleSize => VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
        NULL,                                                                   // pUnk
        sizeof (VIH_M261_Capture_CIF),                  // cbFormat
        (LPBYTE)&VIH_M261_Capture_CIF,                  // pbFormat
};

// H.261 QCIF size
const VIDEOINFOHEADER_H261 VIH_M261_Capture_QCIF =
{
    0,0,0,0,                                                            // RECT  rcSource;
    0,0,0,0,                                                            // RECT  rcTarget;
    QCIF_BUFFER_SIZE * 30 * 8,                          // DWORD dwBitRate;
    0L,                                                                         // DWORD dwBitErrorRate;
    MIN_FRAME_INTERVAL,                                         // REFERENCE_TIME  AvgTimePerFrame;

        {
                sizeof (BITMAPINFOHEADER_H261),         // DWORD biSize;
                D_X_QCIF,                                                       // LONG  biWidth;
                D_Y_QCIF,                                                       // LONG  biHeight;
                1,                                                                      // WORD  biPlanes;
#ifdef USE_OLD_FORMAT_DEFINITION
                24,                                                                     // WORD  biBitCount;
#else
                0,                                                                      // WORD  biBitCount;
#endif
                FOURCC_M261,                                            // DWORD biCompression;
                QCIF_BUFFER_SIZE,                                       // DWORD biSizeImage;
                0,                                                                      // LONG  biXPelsPerMeter;
                0,                                                                      // LONG  biYPelsPerMeter;
                0,                                                                      // DWORD biClrUsed;
                0,                                                                      // DWORD biClrImportant;

#ifndef USE_OLD_FORMAT_DEFINITION
                // H.261 specific fields
                QCIF_BUFFER_SIZE * 30 * 8 / 100,        // dwMaxBitrate
                0,                                                                      // fStillImageTransmission

                // Reserved
                0, 0, 0, 0                                                      // dwReserved[4]
#endif
        }
};

const AM_MEDIA_TYPE AMMT_M261_Capture_QCIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // majortype
    STATIC_MEDIASUBTYPE_H261,                           // subtype
    FALSE,                                                                      // bFixedSizeSamples (all samples same size?)
    TRUE,                                                                       // bTemporalCompression (uses prediction?)
    0,                                                                          // lSampleSize => VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
        NULL,                                                                   // pUnk
        sizeof (VIH_M261_Capture_QCIF),                 // cbFormat
        (LPBYTE)&VIH_M261_Capture_QCIF,                 // pbFormat
};

// Array of all capture formats
const AM_MEDIA_TYPE* const CaptureFormats[] =
{
    (AM_MEDIA_TYPE*) &AMMT_M263_Capture_QCIF,
    (AM_MEDIA_TYPE*) &AMMT_M263_Capture_CIF,
    (AM_MEDIA_TYPE*) &AMMT_M263_Capture_SQCIF,
    (AM_MEDIA_TYPE*) &AMMT_M261_Capture_QCIF,
    (AM_MEDIA_TYPE*) &AMMT_M261_Capture_CIF
};
const VIDEO_STREAM_CONFIG_CAPS* const CaptureCaps[] =
{
        (VIDEO_STREAM_CONFIG_CAPS*) &VSCC_M26X_Capture_QCIF,
        (VIDEO_STREAM_CONFIG_CAPS*) &VSCC_M26X_Capture_CIF,
        (VIDEO_STREAM_CONFIG_CAPS*) &VSCC_M263_Capture_SQCIF,
        (VIDEO_STREAM_CONFIG_CAPS*) &VSCC_M26X_Capture_QCIF,
        (VIDEO_STREAM_CONFIG_CAPS*) &VSCC_M26X_Capture_CIF
};
const DWORD CaptureCapsStringIDs[] =
{
        (DWORD)IDS_M263_Capture_QCIF,
        (DWORD)IDS_M263_Capture_CIF,
        (DWORD)IDS_M263_Capture_SQCIF,
        (DWORD)IDS_M261_Capture_QCIF,
        (DWORD)IDS_M261_Capture_CIF
};
//165048: accessing the string array below replaces the usage of the string table IDs above (resources not linked in when building common dll)
const WCHAR *CaptureCapsStrings[] =
{
    L"H.263 v.1 QCIF",
    L"H.263 v.1 CIF",
    L"H.263 v.1 SQCIF",
    L"H.261 QCIF",
    L"H.261 CIF"
};


const DWORD RTPPayloadTypes[] =
{
        (DWORD)H263_PAYLOAD_TYPE,
        (DWORD)H263_PAYLOAD_TYPE,
        (DWORD)H263_PAYLOAD_TYPE,
        (DWORD)H261_PAYLOAD_TYPE,
        (DWORD)H261_PAYLOAD_TYPE
};

// RGBx CIF size
#define D_X_CIF 352
#define D_Y_CIF 288
#define RGB24_CIF_BUFFER_SIZE WIDTHBYTES(D_X_CIF * 24) * D_Y_CIF
#define RGB16_CIF_BUFFER_SIZE WIDTHBYTES(D_X_CIF * 16) * D_Y_CIF
#define RGB8_CIF_BUFFER_SIZE WIDTHBYTES(D_X_CIF * 8) * D_Y_CIF
#define RGB4_CIF_BUFFER_SIZE WIDTHBYTES(D_X_CIF * 4) * D_Y_CIF

const VIDEO_STREAM_CONFIG_CAPS VSCC_RGB24_Preview_CIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // GUID
    AnalogVideo_None,                                           // VideoStandard
    D_X_CIF, D_Y_CIF,                                           // InputSize, (the inherent size of the incoming signal with every digitized pixel unique)
    D_X_CIF, D_Y_CIF,                                           // MinCroppingSize, smallest rcSrc cropping rect allowed
    D_X_CIF, D_Y_CIF,                                           // MaxCroppingSize, largest  rcSrc cropping rect allowed
    1,                                                                          // CropGranularityX, granularity of cropping size
    1,                                                                          // CropGranularityY
    1,                                                                          // CropAlignX, alignment of cropping rect
    1,                                                                          // CropAlignY;
    D_X_CIF, D_Y_CIF,                                           // MinOutputSize, smallest bitmap stream can produce
    D_X_CIF, D_Y_CIF,                                           // MaxOutputSize, largest  bitmap stream can produce
    1,                                                                          // OutputGranularityX, granularity of output bitmap size
    1,                                                                          // OutputGranularityY;
    0,                                                                          // StretchTapsX
    0,                                                                          // StretchTapsY
    0,                                                                          // ShrinkTapsX
    0,                                                                          // ShrinkTapsY
    MIN_FRAME_INTERVAL,                                         // MinFrameInterval, 100 nS units
    MAX_FRAME_INTERVAL,                                         // MaxFrameInterval, 100 nS units
    0,                                                                          // MinBitsPerSecond
    RGB24_CIF_BUFFER_SIZE * 30 * 8                      // MaxBitsPerSecond;
};

const VIDEO_STREAM_CONFIG_CAPS VSCC_RGB16_Preview_CIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // GUID
    AnalogVideo_None,                                           // VideoStandard
    D_X_CIF, D_Y_CIF,                                           // InputSize, (the inherent size of the incoming signal with every digitized pixel unique)
    D_X_CIF, D_Y_CIF,                                           // MinCroppingSize, smallest rcSrc cropping rect allowed
    D_X_CIF, D_Y_CIF,                                           // MaxCroppingSize, largest  rcSrc cropping rect allowed
    1,                                                                          // CropGranularityX, granularity of cropping size
    1,                                                                          // CropGranularityY
    1,                                                                          // CropAlignX, alignment of cropping rect
    1,                                                                          // CropAlignY;
    D_X_CIF, D_Y_CIF,                                           // MinOutputSize, smallest bitmap stream can produce
    D_X_CIF, D_Y_CIF,                                           // MaxOutputSize, largest  bitmap stream can produce
    1,                                                                          // OutputGranularityX, granularity of output bitmap size
    1,                                                                          // OutputGranularityY;
    0,                                                                          // StretchTapsX
    0,                                                                          // StretchTapsY
    0,                                                                          // ShrinkTapsX
    0,                                                                          // ShrinkTapsY
    MIN_FRAME_INTERVAL,                                         // MinFrameInterval, 100 nS units
    MAX_FRAME_INTERVAL,                                         // MaxFrameInterval, 100 nS units
    0,                                                                          // MinBitsPerSecond
    RGB16_CIF_BUFFER_SIZE * 30 * 8                      // MaxBitsPerSecond;
};

const VIDEO_STREAM_CONFIG_CAPS VSCC_RGB8_Preview_CIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // GUID
    AnalogVideo_None,                                           // VideoStandard
    D_X_CIF, D_Y_CIF,                                           // InputSize, (the inherent size of the incoming signal with every digitized pixel unique)
    D_X_CIF, D_Y_CIF,                                           // MinCroppingSize, smallest rcSrc cropping rect allowed
    D_X_CIF, D_Y_CIF,                                           // MaxCroppingSize, largest  rcSrc cropping rect allowed
    1,                                                                          // CropGranularityX, granularity of cropping size
    1,                                                                          // CropGranularityY
    1,                                                                          // CropAlignX, alignment of cropping rect
    1,                                                                          // CropAlignY;
    D_X_CIF, D_Y_CIF,                                           // MinOutputSize, smallest bitmap stream can produce
    D_X_CIF, D_Y_CIF,                                           // MaxOutputSize, largest  bitmap stream can produce
    1,                                                                          // OutputGranularityX, granularity of output bitmap size
    1,                                                                          // OutputGranularityY;
    0,                                                                          // StretchTapsX
    0,                                                                          // StretchTapsY
    0,                                                                          // ShrinkTapsX
    0,                                                                          // ShrinkTapsY
    MIN_FRAME_INTERVAL,                                         // MinFrameInterval, 100 nS units
    MAX_FRAME_INTERVAL,                                         // MaxFrameInterval, 100 nS units
    0,                                                                          // MinBitsPerSecond
    RGB8_CIF_BUFFER_SIZE * 30 * 8                       // MaxBitsPerSecond;
};

const VIDEO_STREAM_CONFIG_CAPS VSCC_RGB4_Preview_CIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // GUID
    AnalogVideo_None,                                           // VideoStandard
    D_X_CIF, D_Y_CIF,                                           // InputSize, (the inherent size of the incoming signal with every digitized pixel unique)
    D_X_CIF, D_Y_CIF,                                           // MinCroppingSize, smallest rcSrc cropping rect allowed
    D_X_CIF, D_Y_CIF,                                           // MaxCroppingSize, largest  rcSrc cropping rect allowed
    1,                                                                          // CropGranularityX, granularity of cropping size
    1,                                                                          // CropGranularityY
    1,                                                                          // CropAlignX, alignment of cropping rect
    1,                                                                          // CropAlignY;
    D_X_CIF, D_Y_CIF,                                           // MinOutputSize, smallest bitmap stream can produce
    D_X_CIF, D_Y_CIF,                                           // MaxOutputSize, largest  bitmap stream can produce
    1,                                                                          // OutputGranularityX, granularity of output bitmap size
    1,                                                                          // OutputGranularityY;
    0,                                                                          // StretchTapsX
    0,                                                                          // StretchTapsY
    0,                                                                          // ShrinkTapsX
    0,                                                                          // ShrinkTapsY
    MIN_FRAME_INTERVAL,                                         // MinFrameInterval, 100 nS units
    MAX_FRAME_INTERVAL,                                         // MaxFrameInterval, 100 nS units
    0,                                                                          // MinBitsPerSecond
    RGB4_CIF_BUFFER_SIZE * 30 * 8                       // MaxBitsPerSecond;
};

const VIDEOINFOHEADER VIH_RGB24_Preview_CIF =
{
    0,0,0,0,                                                            // RECT  rcSource;
    0,0,0,0,                                                            // RECT  rcTarget;
    RGB24_CIF_BUFFER_SIZE * 30 * 8,                     // DWORD dwBitRate;
    0L,                                                                         // DWORD dwBitErrorRate;
    MIN_FRAME_INTERVAL,                                         // REFERENCE_TIME  AvgTimePerFrame;

        {
                sizeof (BITMAPINFOHEADER),                      // DWORD biSize;
                D_X_CIF,                                                        // LONG  biWidth;
                D_Y_CIF,                                                        // LONG  biHeight;
                1,                                                                      // WORD  biPlanes;
                24,                                                                     // WORD  biBitCount;
                0,                                                                      // DWORD biCompression;
                RGB24_CIF_BUFFER_SIZE,                          // DWORD biSizeImage;
                0,                                                                      // LONG  biXPelsPerMeter;
                0,                                                                      // LONG  biYPelsPerMeter;
                0,                                                                      // DWORD biClrUsed;
                0                                                                       // DWORD biClrImportant;
        }
};

const AM_MEDIA_TYPE AMMT_RGB24_Preview_CIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // majortype
    STATIC_MEDIASUBTYPE_RGB24,                          // subtype
    TRUE,                                                                       // bFixedSizeSamples (all samples same size?)
    FALSE,                                                                      // bTemporalCompression (uses prediction?)
    RGB24_CIF_BUFFER_SIZE,                                      // lSampleSize => !VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
        NULL,                                                                   // pUnk
        sizeof (VIH_RGB24_Preview_CIF),                 // cbFormat
        (LPBYTE)&VIH_RGB24_Preview_CIF,                 // pbFormat
};

const VIDEOINFOHEADER VIH_RGB16_Preview_CIF =
{
    0,0,0,0,                                                            // RECT  rcSource;
    0,0,0,0,                                                            // RECT  rcTarget;
    RGB16_CIF_BUFFER_SIZE * 30 * 8,                     // DWORD dwBitRate;
    0L,                                                                         // DWORD dwBitErrorRate;
    MIN_FRAME_INTERVAL,                                         // REFERENCE_TIME  AvgTimePerFrame;

        {
                sizeof (BITMAPINFOHEADER),                      // DWORD biSize;
                D_X_CIF,                                                        // LONG  biWidth;
                D_Y_CIF,                                                        // LONG  biHeight;
                1,                                                                      // WORD  biPlanes;
                16,                                                                     // WORD  biBitCount;
                0,                                                                      // DWORD biCompression;
                RGB16_CIF_BUFFER_SIZE,                          // DWORD biSizeImage;
                0,                                                                      // LONG  biXPelsPerMeter;
                0,                                                                      // LONG  biYPelsPerMeter;
                0,                                                                      // DWORD biClrUsed;
                0                                                                       // DWORD biClrImportant;
        }
};

const AM_MEDIA_TYPE AMMT_RGB16_Preview_CIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // majortype
    STATIC_MEDIASUBTYPE_RGB16,                          // subtype
    TRUE,                                                                       // bFixedSizeSamples (all samples same size?)
    FALSE,                                                                      // bTemporalCompression (uses prediction?)
    RGB16_CIF_BUFFER_SIZE,                                      // lSampleSize => !VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
        NULL,                                                                   // pUnk
        sizeof (VIH_RGB16_Preview_CIF),                 // cbFormat
        (LPBYTE)&VIH_RGB16_Preview_CIF,                 // pbFormat
};

VIDEOINFO VIH_RGB8_Preview_CIF =
{
    0,0,0,0,                                                            // RECT  rcSource;
    0,0,0,0,                                                            // RECT  rcTarget;
    RGB8_CIF_BUFFER_SIZE * 30 * 8,                      // DWORD dwBitRate;
    0L,                                                                         // DWORD dwBitErrorRate;
    MIN_FRAME_INTERVAL,                                         // REFERENCE_TIME  AvgTimePerFrame;

        {
                sizeof (BITMAPINFOHEADER),                      // DWORD biSize;
                D_X_CIF,                                                        // LONG  biWidth;
                D_Y_CIF,                                                        // LONG  biHeight;
                1,                                                                      // WORD  biPlanes;
                8,                                                                      // WORD  biBitCount;
                0,                                                                      // DWORD biCompression;
                RGB8_CIF_BUFFER_SIZE,                           // DWORD biSizeImage;
                0,                                                                      // LONG  biXPelsPerMeter;
                0,                                                                      // LONG  biYPelsPerMeter;
                256,                                                            // DWORD biClrUsed;
                256                                                                     // DWORD biClrImportant;
        },

        // Palette
        {0}
};

AM_MEDIA_TYPE AMMT_RGB8_Preview_CIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // majortype
    STATIC_MEDIASUBTYPE_RGB8,                           // subtype
    TRUE,                                                                       // bFixedSizeSamples (all samples same size?)
    FALSE,                                                                      // bTemporalCompression (uses prediction?)
    RGB8_CIF_BUFFER_SIZE,                                       // lSampleSize => !VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
        NULL,                                                                   // pUnk
        sizeof (VIH_RGB8_Preview_CIF),                  // cbFormat
        (LPBYTE)&VIH_RGB8_Preview_CIF,                  // pbFormat
};

VIDEOINFO VIH_RGB4_Preview_CIF =
{
    0,0,0,0,                                                            // RECT  rcSource;
    0,0,0,0,                                                            // RECT  rcTarget;
    RGB4_CIF_BUFFER_SIZE * 30 * 8,                      // DWORD dwBitRate;
    0L,                                                                         // DWORD dwBitErrorRate;
    MIN_FRAME_INTERVAL,                                         // REFERENCE_TIME  AvgTimePerFrame;

        {
                sizeof (BITMAPINFOHEADER),                      // DWORD biSize;
                D_X_CIF,                                                        // LONG  biWidth;
                D_Y_CIF,                                                        // LONG  biHeight;
                1,                                                                      // WORD  biPlanes;
                4,                                                                      // WORD  biBitCount;
                0,                                                                      // DWORD biCompression;
                RGB4_CIF_BUFFER_SIZE,                           // DWORD biSizeImage;
                0,                                                                      // LONG  biXPelsPerMeter;
                0,                                                                      // LONG  biYPelsPerMeter;
                16,                                                                     // DWORD biClrUsed;
                16                                                                      // DWORD biClrImportant;
        },

        // Palette
        {0}
};

AM_MEDIA_TYPE AMMT_RGB4_Preview_CIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // majortype
    STATIC_MEDIASUBTYPE_RGB4,                           // subtype
    TRUE,                                                                       // bFixedSizeSamples (all samples same size?)
    FALSE,                                                                      // bTemporalCompression (uses prediction?)
    RGB4_CIF_BUFFER_SIZE,                                       // lSampleSize => !VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
        NULL,                                                                   // pUnk
        sizeof (VIH_RGB4_Preview_CIF),                  // cbFormat
        (LPBYTE)&VIH_RGB4_Preview_CIF,                  // pbFormat
};

// RGBx QCIF size
#define RGB24_QCIF_BUFFER_SIZE WIDTHBYTES(D_X_QCIF * 24) * D_Y_QCIF
#define RGB16_QCIF_BUFFER_SIZE WIDTHBYTES(D_X_QCIF * 16) * D_Y_QCIF
#define RGB8_QCIF_BUFFER_SIZE WIDTHBYTES(D_X_QCIF * 8) * D_Y_QCIF
#define RGB4_QCIF_BUFFER_SIZE WIDTHBYTES(D_X_QCIF * 4) * D_Y_QCIF

const VIDEO_STREAM_CONFIG_CAPS VSCC_RGB24_Preview_QCIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // GUID
    AnalogVideo_None,                                           // VideoStandard
    D_X_QCIF, D_Y_QCIF,                                         // InputSize, (the inherent size of the incoming signal with every digitized pixel unique)
    D_X_QCIF, D_Y_QCIF,                                         // MinCroppingSize, smallest rcSrc cropping rect allowed
    D_X_QCIF, D_Y_QCIF,                                         // MaxCroppingSize, largest  rcSrc cropping rect allowed
    1,                                                                          // CropGranularityX, granularity of cropping size
    1,                                                                          // CropGranularityY
    1,                                                                          // CropAlignX, alignment of cropping rect
    1,                                                                          // CropAlignY;
    D_X_QCIF, D_Y_QCIF,                                         // MinOutputSize, smallest bitmap stream can produce
    D_X_QCIF, D_Y_QCIF,                                         // MaxOutputSize, largest  bitmap stream can produce
    1,                                                                          // OutputGranularityX, granularity of output bitmap size
    1,                                                                          // OutputGranularityY;
    0,                                                                          // StretchTapsX
    0,                                                                          // StretchTapsY
    0,                                                                          // ShrinkTapsX
    0,                                                                          // ShrinkTapsY
    MIN_FRAME_INTERVAL,                                         // MinFrameInterval, 100 nS units
    MAX_FRAME_INTERVAL,                                         // MaxFrameInterval, 100 nS units
    0,                                                                          // MinBitsPerSecond
    RGB24_QCIF_BUFFER_SIZE * 30 * 8                     // MaxBitsPerSecond;
};

const VIDEO_STREAM_CONFIG_CAPS VSCC_RGB16_Preview_QCIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // GUID
    AnalogVideo_None,                                           // VideoStandard
    D_X_QCIF, D_Y_QCIF,                                         // InputSize, (the inherent size of the incoming signal with every digitized pixel unique)
    D_X_QCIF, D_Y_QCIF,                                         // MinCroppingSize, smallest rcSrc cropping rect allowed
    D_X_QCIF, D_Y_QCIF,                                         // MaxCroppingSize, largest  rcSrc cropping rect allowed
    1,                                                                          // CropGranularityX, granularity of cropping size
    1,                                                                          // CropGranularityY
    1,                                                                          // CropAlignX, alignment of cropping rect
    1,                                                                          // CropAlignY;
    D_X_QCIF, D_Y_QCIF,                                         // MinOutputSize, smallest bitmap stream can produce
    D_X_QCIF, D_Y_QCIF,                                         // MaxOutputSize, largest  bitmap stream can produce
    1,                                                                          // OutputGranularityX, granularity of output bitmap size
    1,                                                                          // OutputGranularityY;
    0,                                                                          // StretchTapsX
    0,                                                                          // StretchTapsY
    0,                                                                          // ShrinkTapsX
    0,                                                                          // ShrinkTapsY
    MIN_FRAME_INTERVAL,                                         // MinFrameInterval, 100 nS units
    MAX_FRAME_INTERVAL,                                         // MaxFrameInterval, 100 nS units
    0,                                                                          // MinBitsPerSecond
    RGB16_QCIF_BUFFER_SIZE * 30 * 8                     // MaxBitsPerSecond;
};

const VIDEO_STREAM_CONFIG_CAPS VSCC_RGB8_Preview_QCIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // GUID
    AnalogVideo_None,                                           // VideoStandard
    D_X_QCIF, D_Y_QCIF,                                         // InputSize, (the inherent size of the incoming signal with every digitized pixel unique)
    D_X_QCIF, D_Y_QCIF,                                         // MinCroppingSize, smallest rcSrc cropping rect allowed
    D_X_QCIF, D_Y_QCIF,                                         // MaxCroppingSize, largest  rcSrc cropping rect allowed
    1,                                                                          // CropGranularityX, granularity of cropping size
    1,                                                                          // CropGranularityY
    1,                                                                          // CropAlignX, alignment of cropping rect
    1,                                                                          // CropAlignY;
    D_X_QCIF, D_Y_QCIF,                                         // MinOutputSize, smallest bitmap stream can produce
    D_X_QCIF, D_Y_QCIF,                                         // MaxOutputSize, largest  bitmap stream can produce
    1,                                                                          // OutputGranularityX, granularity of output bitmap size
    1,                                                                          // OutputGranularityY;
    0,                                                                          // StretchTapsX
    0,                                                                          // StretchTapsY
    0,                                                                          // ShrinkTapsX
    0,                                                                          // ShrinkTapsY
    MIN_FRAME_INTERVAL,                                         // MinFrameInterval, 100 nS units
    MAX_FRAME_INTERVAL,                                         // MaxFrameInterval, 100 nS units
    0,                                                                          // MinBitsPerSecond
    RGB8_QCIF_BUFFER_SIZE * 30 * 8                      // MaxBitsPerSecond;
};

const VIDEO_STREAM_CONFIG_CAPS VSCC_RGB4_Preview_QCIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // GUID
    AnalogVideo_None,                                           // VideoStandard
    D_X_QCIF, D_Y_QCIF,                                         // InputSize, (the inherent size of the incoming signal with every digitized pixel unique)
    D_X_QCIF, D_Y_QCIF,                                         // MinCroppingSize, smallest rcSrc cropping rect allowed
    D_X_QCIF, D_Y_QCIF,                                         // MaxCroppingSize, largest  rcSrc cropping rect allowed
    1,                                                                          // CropGranularityX, granularity of cropping size
    1,                                                                          // CropGranularityY
    1,                                                                          // CropAlignX, alignment of cropping rect
    1,                                                                          // CropAlignY;
    D_X_QCIF, D_Y_QCIF,                                         // MinOutputSize, smallest bitmap stream can produce
    D_X_QCIF, D_Y_QCIF,                                         // MaxOutputSize, largest  bitmap stream can produce
    1,                                                                          // OutputGranularityX, granularity of output bitmap size
    1,                                                                          // OutputGranularityY;
    0,                                                                          // StretchTapsX
    0,                                                                          // StretchTapsY
    0,                                                                          // ShrinkTapsX
    0,                                                                          // ShrinkTapsY
    MIN_FRAME_INTERVAL,                                         // MinFrameInterval, 100 nS units
    MAX_FRAME_INTERVAL,                                         // MaxFrameInterval, 100 nS units
    0,                                                                          // MinBitsPerSecond
    RGB4_QCIF_BUFFER_SIZE * 30 * 8                      // MaxBitsPerSecond;
};

const VIDEOINFOHEADER VIH_RGB24_Preview_QCIF =
{
    0,0,0,0,                                                            // RECT  rcSource;
    0,0,0,0,                                                            // RECT  rcTarget;
    RGB24_QCIF_BUFFER_SIZE * 30 * 8,            // DWORD dwBitRate;
    0L,                                                                         // DWORD dwBitErrorRate;
    MIN_FRAME_INTERVAL,                                         // REFERENCE_TIME  AvgTimePerFrame;

        {
                sizeof (BITMAPINFOHEADER),                      // DWORD biSize;
                D_X_QCIF,                                                       // LONG  biWidth;
                D_Y_QCIF,                                                       // LONG  biHeight;
                1,                                                                      // WORD  biPlanes;
                24,                                                                     // WORD  biBitCount;
                0,                                                                      // DWORD biCompression;
                RGB24_QCIF_BUFFER_SIZE,                         // DWORD biSizeImage;
                0,                                                                      // LONG  biXPelsPerMeter;
                0,                                                                      // LONG  biYPelsPerMeter;
                0,                                                                      // DWORD biClrUsed;
                0                                                                       // DWORD biClrImportant;
        }
};

const AM_MEDIA_TYPE AMMT_RGB24_Preview_QCIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // majortype
    STATIC_MEDIASUBTYPE_RGB24,                          // subtype
    TRUE,                                                                       // bFixedSizeSamples (all samples same size?)
    FALSE,                                                                      // bTemporalCompression (uses prediction?)
    RGB24_QCIF_BUFFER_SIZE,                                     // lSampleSize => !VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
        NULL,                                                                   // pUnk
        sizeof (VIH_RGB24_Preview_QCIF),                // cbFormat
        (LPBYTE)&VIH_RGB24_Preview_QCIF,                // pbFormat
};

const VIDEOINFOHEADER VIH_RGB16_Preview_QCIF =
{
    0,0,0,0,                                                            // RECT  rcSource;
    0,0,0,0,                                                            // RECT  rcTarget;
    RGB16_QCIF_BUFFER_SIZE * 30 * 8,                    // DWORD dwBitRate;
    0L,                                                                         // DWORD dwBitErrorRate;
    MIN_FRAME_INTERVAL,                                         // REFERENCE_TIME  AvgTimePerFrame;

        {
                sizeof (BITMAPINFOHEADER),                      // DWORD biSize;
                D_X_QCIF,                                                       // LONG  biWidth;
                D_Y_QCIF,                                                       // LONG  biHeight;
                1,                                                                      // WORD  biPlanes;
                16,                                                                     // WORD  biBitCount;
                0,                                                                      // DWORD biCompression;
                RGB16_QCIF_BUFFER_SIZE,                         // DWORD biSizeImage;
                0,                                                                      // LONG  biXPelsPerMeter;
                0,                                                                      // LONG  biYPelsPerMeter;
                0,                                                                      // DWORD biClrUsed;
                0                                                                       // DWORD biClrImportant;
        }
};

const AM_MEDIA_TYPE AMMT_RGB16_Preview_QCIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // majortype
    STATIC_MEDIASUBTYPE_RGB16,                          // subtype
    TRUE,                                                                       // bFixedSizeSamples (all samples same size?)
    FALSE,                                                                      // bTemporalCompression (uses prediction?)
    RGB16_QCIF_BUFFER_SIZE,                                     // lSampleSize => !VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
        NULL,                                                                   // pUnk
        sizeof (VIH_RGB16_Preview_QCIF),                // cbFormat
        (LPBYTE)&VIH_RGB16_Preview_QCIF,                // pbFormat
};

VIDEOINFO VIH_RGB8_Preview_QCIF =
{
    0,0,0,0,                                                            // RECT  rcSource;
    0,0,0,0,                                                            // RECT  rcTarget;
    RGB8_QCIF_BUFFER_SIZE * 30 * 8,                     // DWORD dwBitRate;
    0L,                                                                         // DWORD dwBitErrorRate;
    MIN_FRAME_INTERVAL,                                         // REFERENCE_TIME  AvgTimePerFrame;

        {
                sizeof (BITMAPINFOHEADER),                      // DWORD biSize;
                D_X_QCIF,                                                       // LONG  biWidth;
                D_Y_QCIF,                                                       // LONG  biHeight;
                1,                                                                      // WORD  biPlanes;
                8,                                                                      // WORD  biBitCount;
                0,                                                                      // DWORD biCompression;
                RGB8_QCIF_BUFFER_SIZE,                          // DWORD biSizeImage;
                0,                                                                      // LONG  biXPelsPerMeter;
                0,                                                                      // LONG  biYPelsPerMeter;
                256,                                                            // DWORD biClrUsed;
                256                                                                     // DWORD biClrImportant;
        },

        // Palette
        {0}
};

AM_MEDIA_TYPE AMMT_RGB8_Preview_QCIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // majortype
    STATIC_MEDIASUBTYPE_RGB8,                           // subtype
    TRUE,                                                                       // bFixedSizeSamples (all samples same size?)
    FALSE,                                                                      // bTemporalCompression (uses prediction?)
    RGB8_QCIF_BUFFER_SIZE,                                      // lSampleSize => !VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
        NULL,                                                                   // pUnk
        sizeof (VIH_RGB8_Preview_QCIF),                 // cbFormat
        (LPBYTE)&VIH_RGB8_Preview_QCIF,                 // pbFormat
};

VIDEOINFO VIH_RGB4_Preview_QCIF =
{
    0,0,0,0,                                                            // RECT  rcSource;
    0,0,0,0,                                                            // RECT  rcTarget;
    RGB4_QCIF_BUFFER_SIZE * 30 * 8,                     // DWORD dwBitRate;
    0L,                                                                         // DWORD dwBitErrorRate;
    MIN_FRAME_INTERVAL,                                         // REFERENCE_TIME  AvgTimePerFrame;

        {
                sizeof (BITMAPINFOHEADER),                      // DWORD biSize;
                D_X_QCIF,                                                       // LONG  biWidth;
                D_Y_QCIF,                                                       // LONG  biHeight;
                1,                                                                      // WORD  biPlanes;
                4,                                                                      // WORD  biBitCount;
                0,                                                                      // DWORD biCompression;
                RGB4_QCIF_BUFFER_SIZE,                          // DWORD biSizeImage;
                0,                                                                      // LONG  biXPelsPerMeter;
                0,                                                                      // LONG  biYPelsPerMeter;
                16,                                                                     // DWORD biClrUsed;
                16                                                                      // DWORD biClrImportant;
        },

        // Palette
        {0}
};

AM_MEDIA_TYPE AMMT_RGB4_Preview_QCIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // majortype
    STATIC_MEDIASUBTYPE_RGB4,                           // subtype
    TRUE,                                                                       // bFixedSizeSamples (all samples same size?)
    FALSE,                                                                      // bTemporalCompression (uses prediction?)
    RGB4_QCIF_BUFFER_SIZE,                                      // lSampleSize => !VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
        NULL,                                                                   // pUnk
        sizeof (VIH_RGB4_Preview_QCIF),                 // cbFormat
        (LPBYTE)&VIH_RGB4_Preview_QCIF,                 // pbFormat
};

// RGBx SQCIF size
#define RGB24_SQCIF_BUFFER_SIZE WIDTHBYTES(D_X_SQCIF * 24) * D_Y_SQCIF
#define RGB16_SQCIF_BUFFER_SIZE WIDTHBYTES(D_X_SQCIF * 16) * D_Y_SQCIF
#define RGB8_SQCIF_BUFFER_SIZE WIDTHBYTES(D_X_SQCIF * 8) * D_Y_SQCIF
#define RGB4_SQCIF_BUFFER_SIZE WIDTHBYTES(D_X_SQCIF * 4) * D_Y_SQCIF

const VIDEO_STREAM_CONFIG_CAPS VSCC_RGB24_Preview_SQCIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // GUID
    AnalogVideo_None,                                           // VideoStandard
    D_X_SQCIF, D_Y_SQCIF,                                       // InputSize, (the inherent size of the incoming signal with every digitized pixel unique)
    D_X_SQCIF, D_Y_SQCIF,                                       // MinCroppingSize, smallest rcSrc cropping rect allowed
    D_X_SQCIF, D_Y_SQCIF,                                       // MaxCroppingSize, largest  rcSrc cropping rect allowed
    1,                                                                          // CropGranularityX, granularity of cropping size
    1,                                                                          // CropGranularityY
    1,                                                                          // CropAlignX, alignment of cropping rect
    1,                                                                          // CropAlignY;
    D_X_SQCIF, D_Y_SQCIF,                                       // MinOutputSize, smallest bitmap stream can produce
    D_X_SQCIF, D_Y_SQCIF,                                       // MaxOutputSize, largest  bitmap stream can produce
    1,                                                                          // OutputGranularityX, granularity of output bitmap size
    1,                                                                          // OutputGranularityY;
    0,                                                                          // StretchTapsX
    0,                                                                          // StretchTapsY
    0,                                                                          // ShrinkTapsX
    0,                                                                          // ShrinkTapsY
    MIN_FRAME_INTERVAL,                                         // MinFrameInterval, 100 nS units
    MAX_FRAME_INTERVAL,                                         // MaxFrameInterval, 100 nS units
    0,                                                                          // MinBitsPerSecond
    RGB24_SQCIF_BUFFER_SIZE * 30 * 8            // MaxBitsPerSecond;
};

const VIDEO_STREAM_CONFIG_CAPS VSCC_RGB16_Preview_SQCIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // GUID
    AnalogVideo_None,                                           // VideoStandard
    D_X_SQCIF, D_Y_SQCIF,                                       // InputSize, (the inherent size of the incoming signal with every digitized pixel unique)
    D_X_SQCIF, D_Y_SQCIF,                                       // MinCroppingSize, smallest rcSrc cropping rect allowed
    D_X_SQCIF, D_Y_SQCIF,                                       // MaxCroppingSize, largest  rcSrc cropping rect allowed
    1,                                                                          // CropGranularityX, granularity of cropping size
    1,                                                                          // CropGranularityY
    1,                                                                          // CropAlignX, alignment of cropping rect
    1,                                                                          // CropAlignY;
    D_X_SQCIF, D_Y_SQCIF,                                       // MinOutputSize, smallest bitmap stream can produce
    D_X_SQCIF, D_Y_SQCIF,                                       // MaxOutputSize, largest  bitmap stream can produce
    1,                                                                          // OutputGranularityX, granularity of output bitmap size
    1,                                                                          // OutputGranularityY;
    0,                                                                          // StretchTapsX
    0,                                                                          // StretchTapsY
    0,                                                                          // ShrinkTapsX
    0,                                                                          // ShrinkTapsY
    MIN_FRAME_INTERVAL,                                         // MinFrameInterval, 100 nS units
    MAX_FRAME_INTERVAL,                                         // MaxFrameInterval, 100 nS units
    0,                                                                          // MinBitsPerSecond
    RGB16_SQCIF_BUFFER_SIZE * 30 * 8            // MaxBitsPerSecond;
};

const VIDEO_STREAM_CONFIG_CAPS VSCC_RGB8_Preview_SQCIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // GUID
    AnalogVideo_None,                                           // VideoStandard
    D_X_SQCIF, D_Y_SQCIF,                                       // InputSize, (the inherent size of the incoming signal with every digitized pixel unique)
    D_X_SQCIF, D_Y_SQCIF,                                       // MinCroppingSize, smallest rcSrc cropping rect allowed
    D_X_SQCIF, D_Y_SQCIF,                                       // MaxCroppingSize, largest  rcSrc cropping rect allowed
    1,                                                                          // CropGranularityX, granularity of cropping size
    1,                                                                          // CropGranularityY
    1,                                                                          // CropAlignX, alignment of cropping rect
    1,                                                                          // CropAlignY;
    D_X_SQCIF, D_Y_SQCIF,                                       // MinOutputSize, smallest bitmap stream can produce
    D_X_SQCIF, D_Y_SQCIF,                                       // MaxOutputSize, largest  bitmap stream can produce
    1,                                                                          // OutputGranularityX, granularity of output bitmap size
    1,                                                                          // OutputGranularityY;
    0,                                                                          // StretchTapsX
    0,                                                                          // StretchTapsY
    0,                                                                          // ShrinkTapsX
    0,                                                                          // ShrinkTapsY
    MIN_FRAME_INTERVAL,                                         // MinFrameInterval, 100 nS units
    MAX_FRAME_INTERVAL,                                         // MaxFrameInterval, 100 nS units
    0,                                                                          // MinBitsPerSecond
    RGB8_SQCIF_BUFFER_SIZE * 30 * 8                     // MaxBitsPerSecond;
};

const VIDEO_STREAM_CONFIG_CAPS VSCC_RGB4_Preview_SQCIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // GUID
    AnalogVideo_None,                                           // VideoStandard
    D_X_SQCIF, D_Y_SQCIF,                                       // InputSize, (the inherent size of the incoming signal with every digitized pixel unique)
    D_X_SQCIF, D_Y_SQCIF,                                       // MinCroppingSize, smallest rcSrc cropping rect allowed
    D_X_SQCIF, D_Y_SQCIF,                                       // MaxCroppingSize, largest  rcSrc cropping rect allowed
    1,                                                                          // CropGranularityX, granularity of cropping size
    1,                                                                          // CropGranularityY
    1,                                                                          // CropAlignX, alignment of cropping rect
    1,                                                                          // CropAlignY;
    D_X_SQCIF, D_Y_SQCIF,                                       // MinOutputSize, smallest bitmap stream can produce
    D_X_SQCIF, D_Y_SQCIF,                                       // MaxOutputSize, largest  bitmap stream can produce
    1,                                                                          // OutputGranularityX, granularity of output bitmap size
    1,                                                                          // OutputGranularityY;
    0,                                                                          // StretchTapsX
    0,                                                                          // StretchTapsY
    0,                                                                          // ShrinkTapsX
    0,                                                                          // ShrinkTapsY
    MIN_FRAME_INTERVAL,                                         // MinFrameInterval, 100 nS units
    MAX_FRAME_INTERVAL,                                         // MaxFrameInterval, 100 nS units
    0,                                                                          // MinBitsPerSecond
    RGB4_SQCIF_BUFFER_SIZE * 30 * 8                     // MaxBitsPerSecond;
};

const VIDEOINFOHEADER VIH_RGB24_Preview_SQCIF =
{
    0,0,0,0,                                                            // RECT  rcSource;
    0,0,0,0,                                                            // RECT  rcTarget;
    RGB24_SQCIF_BUFFER_SIZE * 30 * 8,           // DWORD dwBitRate;
    0L,                                                                         // DWORD dwBitErrorRate;
    MIN_FRAME_INTERVAL,                                         // REFERENCE_TIME  AvgTimePerFrame;

        {
                sizeof (BITMAPINFOHEADER),                      // DWORD biSize;
                D_X_SQCIF,                                                      // LONG  biWidth;
                D_Y_SQCIF,                                                      // LONG  biHeight;
                1,                                                                      // WORD  biPlanes;
                24,                                                                     // WORD  biBitCount;
                0,                                                                      // DWORD biCompression;
                RGB24_SQCIF_BUFFER_SIZE,                        // DWORD biSizeImage;
                0,                                                                      // LONG  biXPelsPerMeter;
                0,                                                                      // LONG  biYPelsPerMeter;
                0,                                                                      // DWORD biClrUsed;
                0                                                                       // DWORD biClrImportant;
        }
};

const AM_MEDIA_TYPE AMMT_RGB24_Preview_SQCIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // majortype
    STATIC_MEDIASUBTYPE_RGB24,                          // subtype
    TRUE,                                                                       // bFixedSizeSamples (all samples same size?)
    FALSE,                                                                      // bTemporalCompression (uses prediction?)
    RGB24_SQCIF_BUFFER_SIZE,                            // lSampleSize => !VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
        NULL,                                                                   // pUnk
        sizeof (VIH_RGB24_Preview_SQCIF),               // cbFormat
        (LPBYTE)&VIH_RGB24_Preview_SQCIF,               // pbFormat
};

const VIDEOINFOHEADER VIH_RGB16_Preview_SQCIF =
{
    0,0,0,0,                                                            // RECT  rcSource;
    0,0,0,0,                                                            // RECT  rcTarget;
    RGB16_SQCIF_BUFFER_SIZE * 30 * 8,           // DWORD dwBitRate;
    0L,                                                                         // DWORD dwBitErrorRate;
    MIN_FRAME_INTERVAL,                                         // REFERENCE_TIME  AvgTimePerFrame;

        {
                sizeof (BITMAPINFOHEADER),                      // DWORD biSize;
                D_X_SQCIF,                                                      // LONG  biWidth;
                D_Y_SQCIF,                                                      // LONG  biHeight;
                1,                                                                      // WORD  biPlanes;
                16,                                                                     // WORD  biBitCount;
                0,                                                                      // DWORD biCompression;
                RGB16_SQCIF_BUFFER_SIZE,                        // DWORD biSizeImage;
                0,                                                                      // LONG  biXPelsPerMeter;
                0,                                                                      // LONG  biYPelsPerMeter;
                0,                                                                      // DWORD biClrUsed;
                0                                                                       // DWORD biClrImportant;
        }
};

const AM_MEDIA_TYPE AMMT_RGB16_Preview_SQCIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // majortype
    STATIC_MEDIASUBTYPE_RGB16,                          // subtype
    TRUE,                                                                       // bFixedSizeSamples (all samples same size?)
    FALSE,                                                                      // bTemporalCompression (uses prediction?)
    RGB16_SQCIF_BUFFER_SIZE,                            // lSampleSize => !VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
        NULL,                                                                   // pUnk
        sizeof (VIH_RGB16_Preview_SQCIF),               // cbFormat
        (LPBYTE)&VIH_RGB16_Preview_SQCIF,               // pbFormat
};

VIDEOINFO VIH_RGB8_Preview_SQCIF =
{
    0,0,0,0,                                                            // RECT  rcSource;
    0,0,0,0,                                                            // RECT  rcTarget;
    RGB8_SQCIF_BUFFER_SIZE * 30 * 8,                    // DWORD dwBitRate;
    0L,                                                                         // DWORD dwBitErrorRate;
    MIN_FRAME_INTERVAL,                                         // REFERENCE_TIME  AvgTimePerFrame;

        {
                sizeof (BITMAPINFOHEADER),                      // DWORD biSize;
                D_X_SQCIF,                                                      // LONG  biWidth;
                D_Y_SQCIF,                                                      // LONG  biHeight;
                1,                                                                      // WORD  biPlanes;
                8,                                                                      // WORD  biBitCount;
                0,                                                                      // DWORD biCompression;
                RGB8_SQCIF_BUFFER_SIZE,                         // DWORD biSizeImage;
                0,                                                                      // LONG  biXPelsPerMeter;
                0,                                                                      // LONG  biYPelsPerMeter;
                256,                                                            // DWORD biClrUsed;
                256                                                                     // DWORD biClrImportant;
        },

        // Palette
        {0}
};

AM_MEDIA_TYPE AMMT_RGB8_Preview_SQCIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // majortype
    STATIC_MEDIASUBTYPE_RGB8,                           // subtype
    TRUE,                                                                       // bFixedSizeSamples (all samples same size?)
    FALSE,                                                                      // bTemporalCompression (uses prediction?)
    RGB8_SQCIF_BUFFER_SIZE,                                     // lSampleSize => !VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
        NULL,                                                                   // pUnk
        sizeof (VIH_RGB8_Preview_SQCIF),                // cbFormat
        (LPBYTE)&VIH_RGB8_Preview_SQCIF,                // pbFormat
};

VIDEOINFO VIH_RGB4_Preview_SQCIF =
{
    0,0,0,0,                                                            // RECT  rcSource;
    0,0,0,0,                                                            // RECT  rcTarget;
    RGB4_SQCIF_BUFFER_SIZE * 30 * 8,            // DWORD dwBitRate;
    0L,                                                                         // DWORD dwBitErrorRate;
    MIN_FRAME_INTERVAL,                                         // REFERENCE_TIME  AvgTimePerFrame;

        {
                sizeof (BITMAPINFOHEADER),                      // DWORD biSize;
                D_X_SQCIF,                                                      // LONG  biWidth;
                D_Y_SQCIF,                                                      // LONG  biHeight;
                1,                                                                      // WORD  biPlanes;
                4,                                                                      // WORD  biBitCount;
                0,                                                                      // DWORD biCompression;
                RGB4_SQCIF_BUFFER_SIZE,                         // DWORD biSizeImage;
                0,                                                                      // LONG  biXPelsPerMeter;
                0,                                                                      // LONG  biYPelsPerMeter;
                16,                                                                     // DWORD biClrUsed;
                16                                                                      // DWORD biClrImportant;
        },

        // Palette
        {0}
};

const AM_MEDIA_TYPE AMMT_RGB4_Preview_SQCIF =
{
    STATIC_KSDATAFORMAT_TYPE_VIDEO,                     // majortype
    STATIC_MEDIASUBTYPE_RGB4,                           // subtype
    TRUE,                                                                       // bFixedSizeSamples (all samples same size?)
    FALSE,                                                                      // bTemporalCompression (uses prediction?)
    RGB4_SQCIF_BUFFER_SIZE,                                     // lSampleSize => !VBR
    STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO,// formattype
        NULL,                                                                   // pUnk
        sizeof (VIH_RGB4_Preview_SQCIF),                // cbFormat
        (LPBYTE)&VIH_RGB4_Preview_SQCIF,                // pbFormat
};

// Array of all preview formats
const AM_MEDIA_TYPE* const Preview_RGB24_Formats[] =
{
    (AM_MEDIA_TYPE*) &AMMT_RGB24_Preview_QCIF,
    (AM_MEDIA_TYPE*) &AMMT_RGB24_Preview_CIF,
    (AM_MEDIA_TYPE*) &AMMT_RGB24_Preview_SQCIF
};

const AM_MEDIA_TYPE* const Preview_RGB16_Formats[] =
{
    (AM_MEDIA_TYPE*) &AMMT_RGB16_Preview_QCIF,
    (AM_MEDIA_TYPE*) &AMMT_RGB16_Preview_CIF,
    (AM_MEDIA_TYPE*) &AMMT_RGB16_Preview_SQCIF
};

AM_MEDIA_TYPE* Preview_RGB8_Formats[] =
{
    (AM_MEDIA_TYPE*) &AMMT_RGB8_Preview_QCIF,
    (AM_MEDIA_TYPE*) &AMMT_RGB8_Preview_CIF,
    (AM_MEDIA_TYPE*) &AMMT_RGB8_Preview_SQCIF
};

AM_MEDIA_TYPE* Preview_RGB4_Formats[] =
{
    (AM_MEDIA_TYPE*) &AMMT_RGB4_Preview_QCIF,
    (AM_MEDIA_TYPE*) &AMMT_RGB4_Preview_CIF,
    (AM_MEDIA_TYPE*) &AMMT_RGB4_Preview_SQCIF
};

// Array of all preview caps
const VIDEO_STREAM_CONFIG_CAPS* const Preview_RGB24_Caps[] =
{
        (VIDEO_STREAM_CONFIG_CAPS*) &VSCC_RGB24_Preview_QCIF,
        (VIDEO_STREAM_CONFIG_CAPS*) &VSCC_RGB24_Preview_CIF,
        (VIDEO_STREAM_CONFIG_CAPS*) &VSCC_RGB24_Preview_SQCIF
};

const VIDEO_STREAM_CONFIG_CAPS* const Preview_RGB16_Caps[] =
{
        (VIDEO_STREAM_CONFIG_CAPS*) &VSCC_RGB16_Preview_QCIF,
        (VIDEO_STREAM_CONFIG_CAPS*) &VSCC_RGB16_Preview_CIF,
        (VIDEO_STREAM_CONFIG_CAPS*) &VSCC_RGB16_Preview_SQCIF
};

const VIDEO_STREAM_CONFIG_CAPS* const Preview_RGB8_Caps[] =
{
        (VIDEO_STREAM_CONFIG_CAPS*) &VSCC_RGB8_Preview_QCIF,
        (VIDEO_STREAM_CONFIG_CAPS*) &VSCC_RGB8_Preview_CIF,
        (VIDEO_STREAM_CONFIG_CAPS*) &VSCC_RGB8_Preview_SQCIF
};

const VIDEO_STREAM_CONFIG_CAPS* const Preview_RGB4_Caps[] =
{
        (VIDEO_STREAM_CONFIG_CAPS*) &VSCC_RGB4_Preview_QCIF,
        (VIDEO_STREAM_CONFIG_CAPS*) &VSCC_RGB4_Preview_CIF,
        (VIDEO_STREAM_CONFIG_CAPS*) &VSCC_RGB4_Preview_SQCIF
};

// RTP packetization descriptor formats
#define STATIC_KSDATAFORMAT_TYPE_RTP_PD 0x9e2fb490L, 0x2051, 0x46cd, 0xb9, 0xf0, 0x06, 0x33, 0x07, 0x99, 0x69, 0x35

const RTP_PD_CONFIG_CAPS Rtp_Pd_Cap_H263 =
{
                MIN_RTP_PACKET_SIZE,                            // dwSmallestRTPPacketSize
                MAX_RTP_PACKET_SIZE,                            // dwLargestRTPPacketSize
                1,                                                                      // dwRTPPacketSizeGranularity
                1,                                                                      // dwSmallestNumLayers
                1,                                                                      // dwLargestNumLayers
                0,                                                                      // dwNumLayersGranularity
                1,                                                                      // dwNumStaticPayloadTypes
                H263_PAYLOAD_TYPE, 0, 0, 0,                     // dwStaticPayloadTypes[4]
                1,                                                                      // dwNumDescriptorVersions
                VERSION_1, 0, 0, 0,                                     // dwDescriptorVersions[4]
                0, 0, 0, 0                                                      // dwReserved[4]
};

const RTP_PD_CONFIG_CAPS Rtp_Pd_Cap_H261 =
{
                MIN_RTP_PACKET_SIZE,                            // dwSmallestRTPPacketSize
                MAX_RTP_PACKET_SIZE,                            // dwLargestRTPPacketSize
                1,                                                                      // dwRTPPacketSizeGranularity
                1,                                                                      // dwSmallestNumLayers
                1,                                                                      // dwLargestNumLayers
                0,                                                                      // dwNumLayersGranularity
                1,                                                                      // dwNumStaticPayloadTypes
                H261_PAYLOAD_TYPE, 0, 0, 0,                     // dwStaticPayloadTypes[4]
                1,                                                                      // dwNumDescriptorVersions
                VERSION_1, 0, 0, 0,                                     // dwDescriptorVersions[4]
                0, 0, 0, 0                                                      // dwReserved[4]
};

const RTP_PD_INFO Rtp_Pd_Info_H263_LAN =
{
    MIN_FRAME_INTERVAL,                                 // AvgTimePerFrameDescriptors
    MAX_RTP_PD_BUFFER_SIZE,                             // dwMaxRTPPacketizationDescriptorBufferSize
    12,                                                                 // dwMaxRTPPayloadHeaderSize (Mode C Payload Header)
    DEFAULT_RTP_PACKET_SIZE,                    // dwMaxRTPPacketSize
    1,                                                                  // dwNumLayers
        H263_PAYLOAD_TYPE,                                      // dwPayloadType
        VERSION_1,                                                      // dwDescriptorVersion
        0, 0, 0, 0                                                      // dwReserved[4]
};

const RTP_PD_INFO Rtp_Pd_Info_H263_Internet =
{
    MIN_FRAME_INTERVAL,                                 // AvgTimePerFrameDescriptors
    MAX_RTP_PD_BUFFER_SIZE,                             // dwMaxRTPPacketizationDescriptorBufferSize
    12,                                                                 // dwMaxRTPPayloadHeaderSize (Mode C Payload Header)
    MIN_RTP_PACKET_SIZE,                                // dwMaxRTPPacketSize
    1,                                                                  // dwNumLayers
        H263_PAYLOAD_TYPE,                                      // dwPayloadType
        VERSION_1,                                                      // dwDescriptorVersion
        0, 0, 0, 0                                                      // dwReserved[4]
};

const RTP_PD_INFO Rtp_Pd_Info_H261_LAN =
{
    MIN_FRAME_INTERVAL,                                 // AvgTimePerFrameDescriptors
    MAX_RTP_PD_BUFFER_SIZE,                             // dwMaxRTPPacketizationDescriptorBufferSize
    12,                                                                 // dwMaxRTPPayloadHeaderSize (Mode C Payload Header)
    DEFAULT_RTP_PACKET_SIZE,                    // dwMaxRTPPacketSize
    1,                                                                  // dwNumLayers
        H261_PAYLOAD_TYPE,                                      // dwPayloadType
        VERSION_1,                                                      // dwDescriptorVersion
        0, 0, 0, 0                                                      // dwReserved[4]
};

const RTP_PD_INFO Rtp_Pd_Info_H261_Internet =
{
    MIN_FRAME_INTERVAL,                                 // AvgTimePerFrameDescriptors
    MAX_RTP_PD_BUFFER_SIZE,                             // dwMaxRTPPacketizationDescriptorBufferSize
    12,                                                                 // dwMaxRTPPayloadHeaderSize (Mode C Payload Header)
    MIN_RTP_PACKET_SIZE,                                // dwMaxRTPPacketSize
    1,                                                                  // dwNumLayers
        H261_PAYLOAD_TYPE,                                      // dwPayloadType
        VERSION_1,                                                      // dwDescriptorVersion
        0, 0, 0, 0                                                      // dwReserved[4]
};

const AM_MEDIA_TYPE AMMT_Rtp_Pd_H263_LAN =
{
    STATIC_KSDATAFORMAT_TYPE_RTP_PD,            // majortype
    STATIC_KSDATAFORMAT_SUBTYPE_NONE,           // subtype
    TRUE,                                                                       // bFixedSizeSamples (all samples same size?)
    FALSE,                                                                      // bTemporalCompression (uses prediction?)
    MAX_RTP_PD_BUFFER_SIZE,                                     // lSampleSize => !VBR
    STATIC_KSDATAFORMAT_SPECIFIER_NONE,         // formattype
        NULL,                                                                   // pUnk
        sizeof (Rtp_Pd_Info_H263_LAN),                  // cbFormat
        (LPBYTE)&Rtp_Pd_Info_H263_LAN                   // pbFormat
};

const AM_MEDIA_TYPE AMMT_Rtp_Pd_H263_Internet =
{
    STATIC_KSDATAFORMAT_TYPE_RTP_PD,            // majortype
    STATIC_KSDATAFORMAT_SUBTYPE_NONE,           // subtype
    TRUE,                                                                       // bFixedSizeSamples (all samples same size?)
    FALSE,                                                                      // bTemporalCompression (uses prediction?)
    MAX_RTP_PD_BUFFER_SIZE,                                     // lSampleSize => !VBR
    STATIC_KSDATAFORMAT_SPECIFIER_NONE,         // formattype
        NULL,                                                                   // pUnk
        sizeof (Rtp_Pd_Info_H263_Internet),             // cbFormat
        (LPBYTE)&Rtp_Pd_Info_H263_Internet              // pbFormat
};

const AM_MEDIA_TYPE AMMT_Rtp_Pd_H261_LAN =
{
    STATIC_KSDATAFORMAT_TYPE_RTP_PD,            // majortype
    STATIC_KSDATAFORMAT_SUBTYPE_NONE,           // subtype
    TRUE,                                                                       // bFixedSizeSamples (all samples same size?)
    FALSE,                                                                      // bTemporalCompression (uses prediction?)
    MAX_RTP_PD_BUFFER_SIZE,                                     // lSampleSize => !VBR
    STATIC_KSDATAFORMAT_SPECIFIER_NONE,         // formattype
        NULL,                                                                   // pUnk
        sizeof (Rtp_Pd_Info_H261_LAN),                  // cbFormat
        (LPBYTE)&Rtp_Pd_Info_H261_LAN                   // pbFormat
};

const AM_MEDIA_TYPE AMMT_Rtp_Pd_H261_Internet =
{
    STATIC_KSDATAFORMAT_TYPE_RTP_PD,            // majortype
    STATIC_KSDATAFORMAT_SUBTYPE_NONE,           // subtype
    TRUE,                                                                       // bFixedSizeSamples (all samples same size?)
    FALSE,                                                                      // bTemporalCompression (uses prediction?)
    MAX_RTP_PD_BUFFER_SIZE,                                     // lSampleSize => !VBR
    STATIC_KSDATAFORMAT_SPECIFIER_NONE,         // formattype
        NULL,                                                                   // pUnk
        sizeof (Rtp_Pd_Info_H261_Internet),             // cbFormat
        (LPBYTE)&Rtp_Pd_Info_H261_Internet              // pbFormat
};

// Array of all RTP packetization descriptor formats
const AM_MEDIA_TYPE* const Rtp_Pd_Formats[] =
{
    (AM_MEDIA_TYPE*) &AMMT_Rtp_Pd_H263_LAN,
    (AM_MEDIA_TYPE*) &AMMT_Rtp_Pd_H263_Internet,
    (AM_MEDIA_TYPE*) &AMMT_Rtp_Pd_H261_LAN,
    (AM_MEDIA_TYPE*) &AMMT_Rtp_Pd_H261_Internet
};

// Array of all RTP packetization descriptor caps
const RTP_PD_CONFIG_CAPS* const Rtp_Pd_Caps[] =
{
        (RTP_PD_CONFIG_CAPS*) &Rtp_Pd_Cap_H263,
        (RTP_PD_CONFIG_CAPS*) &Rtp_Pd_Cap_H263,
        (RTP_PD_CONFIG_CAPS*) &Rtp_Pd_Cap_H261,
        (RTP_PD_CONFIG_CAPS*) &Rtp_Pd_Cap_H261
};

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | Reconnect | This method is used to
 *    reconnect a pin to a downstream pin with a new format.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIBasePin::Reconnect()
{
        HRESULT hr = NOERROR;

        FX_ENTRY("CTAPIBasePin::Reconnect")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    hr = SetFormat(&m_mt);

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end, hr=%x", _fx_, hr));

        return hr;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | SetFormat | This method is used to
 *    set a specific media type on a pin.
 *
 *  @parm AM_MEDIA_TYPE* | pmt | Specifies a pointer to an <t AM_MEDIA_TYPE>
 *    structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::SetFormat(IN AM_MEDIA_TYPE *pmt)
{
        HRESULT hr = NOERROR;
        BOOL    fWasStreaming = FALSE;

        FX_ENTRY("CTAPIBasePin::SetFormat")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    // To make sure we're not in the middle of start/stop streaming
    CAutoLock cObjectLock(m_pCaptureFilter->m_pLock);

        // Validate input parameters
        ASSERT(pmt);
        if (!pmt)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid input parameter!", _fx_));
                hr = E_POINTER;
                goto MyExit;
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Trying to set %s %dx%d", _fx_, HEADER(pmt->pbFormat)->biCompression == FOURCC_M263 ? "H.263" : HEADER(pmt->pbFormat)->biCompression == FOURCC_M261 ? "H.261" : "????", HEADER(pmt->pbFormat)->biWidth, HEADER(pmt->pbFormat)->biHeight));

        // If this is the same format as we already are using, don't bother
    if (m_mt == *pmt)
                goto MyExit;

        // See if we like this type
        if (FAILED(hr = CheckMediaType((CMediaType *)pmt)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Format rejected!", _fx_));
                goto MyExit;
        }

        // If we are currently capturing data, stop this process before changing the format
        if (m_pCaptureFilter->ThdExists() && m_pCaptureFilter->m_state != TS_Stop)
        {
                // Remember that we were streaming
                fWasStreaming = TRUE;

                // Tell the worker thread to stop and begin cleaning up
                m_pCaptureFilter->StopThd();

                // Wait for the worker thread to die
                m_pCaptureFilter->DestroyThd();
        }

        if (FAILED(hr = SetMediaType((CMediaType *)pmt)))
    {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: SetMediaType failed! hr = ", _fx_, hr));
                goto MyExit;
    }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Format set successfully", _fx_));

    // Let the fun restart
        if (fWasStreaming)
        {
                // Re-create the capture thread
                if (!m_pCaptureFilter->CreateThd())
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Coutdn't create the capture thread!", _fx_));
                        hr = E_FAIL;
                        goto MyExit;
                }

                // Wait until the worker thread is done with initialization and has entered the paused state
                if (!m_pCaptureFilter->PauseThd())
                {
                        // Something went wrong. Destroy thread before we get confused
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Capture thread failed to enter Paused state!", _fx_));
                        hr = E_FAIL;
                        m_pCaptureFilter->StopThd();
                        m_pCaptureFilter->DestroyThd();
                }

                // Let the fun begin
                if (!m_pCaptureFilter->RunThd() || m_pCaptureFilter->m_state != TS_Run)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Couldn't run the capture thread!", _fx_));
                        hr = E_FAIL;
                        goto MyExit;
                }
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return hr;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | GetFormat | This method is used to
 *    retrieve the current media type on a pin.
 *
 *  @parm AM_MEDIA_TYPE** | ppmt | Specifies the address of a pointer to an
 *    <t AM_MEDIA_TYPE> structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 *
 *  @comm Note that we return the output type, not the format at which
 *    we are capturing. Only the filter really cares about how the data is
 *    being captured.
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::GetFormat(OUT AM_MEDIA_TYPE **ppmt)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIBasePin::GetFormat")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(ppmt);
        if (!ppmt)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Return a copy of our current format
        *ppmt = CreateMediaType(&m_mt);

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | GetNumberOfCapabilities | This method is
 *    used to retrieve the number of stream capabilities structures.
 *
 *  @parm int* | piCount | Specifies a pointer to an int to receive the
 *    number of <t VIDEO_STREAM_CONFIG_CAPS> structures supported.
 *
 *  @parm int* | piSize | Specifies a pointer to an int to receive the
 *    size of the <t VIDEO_STREAM_CONFIG_CAPS> configuration structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::GetNumberOfCapabilities(OUT int *piCount, OUT int *piSize)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIBasePin::GetNumberOfCapabilities")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(piCount);
        ASSERT(piSize);
        if (!piCount || !piSize)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Return releavant info
        *piCount = m_dwNumFormats;
        *piSize = sizeof(VIDEO_STREAM_CONFIG_CAPS);

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Returning %ld formats of max size %ld bytes", _fx_, *piCount, *piSize));

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | GetStreamCaps | This method is
 *    used to retrieve a video stream capability pair.
 *
 *  @parm int | iIndex | Specifies the index to the desired media type
 *    and capability pair.
 *
 *  @parm AM_MEDIA_TYPE** | ppmt | Specifies the address of a pointer to an
 *    <t AM_MEDIA_TYPE> structure.
 *
 *  @parm LPBYTE | pSCC | Specifies a pointer to a
 *    <t VIDEO_STREAM_CONFIG_CAPS> configuration structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::GetStreamCaps(IN int iIndex, OUT AM_MEDIA_TYPE **ppmt, OUT LPBYTE pSCC)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIBasePin::GetStreamCaps")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(iIndex < (int)m_dwNumFormats);
        if (!(iIndex < (int)m_dwNumFormats))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid iIndex argument!", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }

        // Return a copy of the requested AM_MEDIA_TYPE structure
    if (ppmt)
    {
            if (!(*ppmt = CreateMediaType(m_aFormats[iIndex])))
            {
                    DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory!", _fx_));
                    Hr = E_OUTOFMEMORY;
                    goto MyExit;
            }
    }

        // Return a copy of the requested VIDEO_STREAM_CONFIG_CAPS structure
    if (pSCC)
    {
            CopyMemory(pSCC, m_aCapabilities[iIndex], sizeof(VIDEO_STREAM_CONFIG_CAPS));
    }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Returning format index %ld: %s %ld bpp %ldx%ld", _fx_, iIndex, HEADER(m_aFormats[iIndex]->pbFormat)->biCompression == FOURCC_M263 ? "H.263" : HEADER(m_aFormats[iIndex]->pbFormat)->biCompression == FOURCC_M261 ? "H.261" : HEADER(m_aFormats[iIndex]->pbFormat)->biCompression == BI_RGB ? "RGB" : "????", HEADER(m_aFormats[iIndex]->pbFormat)->biBitCount, HEADER(m_aFormats[iIndex]->pbFormat)->biWidth, HEADER(m_aFormats[iIndex]->pbFormat)->biHeight));

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | GetMediaType | This method retrieves one
 *    of the media types supported by the pin, which is used by enumerators.
 *
 *  @parm int | iPosition | Specifies a position in the media type list.
 *
 *  @parm CMediaType* | pMediaType | Specifies a pointer to the media type at
 *    the <p iPosition> position in the list of supported media types.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag VFW_S_NO_MORE_ITEMS | End of the list of media types has been reached
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIBasePin::GetMediaType(IN int iPosition, OUT CMediaType *pMediaType)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CTAPIBasePin::GetMediaType")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(iPosition >= 0);
        ASSERT(pMediaType);
        if (iPosition < 0)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid iPosition argument", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }
        if (iPosition >= (int)m_dwNumFormats)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: End of the list of media types has been reached", _fx_));
                Hr = VFW_S_NO_MORE_ITEMS;
                goto MyExit;
        }
        if (!pMediaType)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Return our media type
        if (m_iCurrFormat == -1L)
                *pMediaType = *m_aFormats[iPosition];
        else
        {
                if (iPosition == 0L)
                        *pMediaType = *m_aFormats[m_iCurrFormat];
                else
                        Hr = VFW_S_NO_MORE_ITEMS;
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | CheckMediaType | This method is used to
 *    determine if the pin can support a specific media type.
 *
 *  @parm CMediaType* | pMediaType | Specifies a pointer to the media type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag VFW_E_INVALIDMEDIATYPE | An invalid media type was specified
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIBasePin::CheckMediaType(IN const CMediaType *pMediaType)
{
        HRESULT Hr = NOERROR;
        BOOL fFormatMatch = FALSE;
        DWORD dwIndex;

        FX_ENTRY("CTAPIBasePin::CheckMediaType")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pMediaType);
        if (!pMediaType || !pMediaType->pbFormat)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }


        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Checking %s (%x) %dbpp %dx%d", _fx_,
            HEADER(pMediaType->pbFormat)->biCompression == FOURCC_M263 ? "H.263" :
            HEADER(pMediaType->pbFormat)->biCompression == FOURCC_M261 ? "H.261" :
            HEADER(pMediaType->pbFormat)->biCompression == BI_RGB ? "RGB" :
            "????",
            HEADER(pMediaType->pbFormat)->biCompression,
            HEADER(pMediaType->pbFormat)->biBitCount, HEADER(pMediaType->pbFormat)->biWidth,
            HEADER(pMediaType->pbFormat)->biHeight));

        // We only support MEDIATYPE_Video and FORMAT_VideoInfo
        if (*pMediaType->Type() != MEDIATYPE_Video || *pMediaType->FormatType() != FORMAT_VideoInfo)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Media type or format type not recognized!", _fx_));
                Hr = VFW_E_INVALIDMEDIATYPE;
                goto MyExit;
        }

    // Quickly test to see if this is the current format (what we provide in GetMediaType). We accept that
    if (m_mt == *pMediaType)
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: Identical to current format", _fx_));
                goto MyExit;
    }

        // Check the media subtype and image resolution
        for (dwIndex = 0; dwIndex < m_dwNumFormats && !fFormatMatch;  dwIndex++)
        {
                if ((HEADER(pMediaType->pbFormat)->biCompression == HEADER(m_aFormats[dwIndex]->pbFormat)->biCompression)
                        && (HEADER(pMediaType->pbFormat)->biWidth == HEADER(m_aFormats[dwIndex]->pbFormat)->biWidth)
                        && (HEADER(pMediaType->pbFormat)->biHeight == HEADER(m_aFormats[dwIndex]->pbFormat)->biHeight))
                        fFormatMatch = TRUE;
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   %s", _fx_, fFormatMatch ? "SUCCESS: Format supported" : "ERROR: Format notsupported"));

        if (!fFormatMatch)
                Hr = E_FAIL;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

HRESULT CTAPIBasePin::ChangeFormatHelper()
{
        FX_ENTRY("CTAPIBasePin::ChangeFormatHelper")

        // If we are connected to somebody, make sure they like it too
        if (!IsConnected())
        {
        return S_OK;
    }

    HRESULT hr;

    hr = m_Connected->ReceiveConnection(this, &m_mt);
    if(FAILED(hr))
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: ReceiveConnection failed hr=%x", _fx_, hr));
                return hr;
    }

    // Does this pin use the local memory transport?
    if(NULL != m_pInputPin) {
        // This function assumes that m_pInputPin and m_Connected are
        // two different interfaces to the same object.
        ASSERT(::IsEqualObject(m_Connected, m_pInputPin));

        ALLOCATOR_PROPERTIES apInputPinRequirements;
        apInputPinRequirements.cbAlign = 0;
        apInputPinRequirements.cbBuffer = 0;
        apInputPinRequirements.cbPrefix = 0;
        apInputPinRequirements.cBuffers = 0;

        m_pInputPin->GetAllocatorRequirements(&apInputPinRequirements);

        // A zero allignment does not make any sense.
        if(0 == apInputPinRequirements.cbAlign) {
            apInputPinRequirements.cbAlign = 1;
        }

        hr = m_pAllocator->Decommit();
        if(FAILED(hr)) {
            DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: Decommit failed hr=%x", _fx_, hr));
            return hr;
        }

        hr = DecideBufferSize(m_pAllocator,  &apInputPinRequirements);
        if(FAILED(hr)) {
            DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: DecideBufferSize failed hr=%x", _fx_, hr));
            return hr;
        }

        hr = m_pAllocator->Commit();
        if(FAILED(hr)) {
            DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: Commit failed hr=%x", _fx_, hr));
            return hr;
        }

        hr = m_pInputPin->NotifyAllocator(m_pAllocator, 0);
        if(FAILED(hr)) {
            DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: NotifyAllocator failed hr=%x", _fx_, hr));
            return hr;
        }
    }
    return S_OK;
}


HRESULT CTAPIBasePin::NotifyDeviceFormatChange(IN CMediaType *pMediaType)
{
        FX_ENTRY("CTAPIBasePin::NotifyDeviceFormatChange")

    // make sure our image size is the same as new size.
    if (HEADER(pMediaType->pbFormat)->biHeight == HEADER(m_mt.pbFormat)->biHeight
        && HEADER(pMediaType->pbFormat)->biWidth == HEADER(m_mt.pbFormat)->biWidth)
    {
        // we are in sync with the driver.
        return S_OK;
    }

        // Which one of our formats is this exactly?
        for (DWORD dwIndex=0; dwIndex < m_dwNumFormats;  dwIndex++)
        {
                        if ((HEADER(pMediaType->pbFormat)->biWidth == HEADER(m_aFormats[dwIndex]->pbFormat)->biWidth)
                        && (HEADER(pMediaType->pbFormat)->biHeight == HEADER(m_aFormats[dwIndex]->pbFormat)->biHeight))
                        break;
        }

        if (dwIndex >= m_dwNumFormats)
    {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:Invalid size, (%d, %d)",
            _fx_, HEADER(pMediaType->pbFormat)->biWidth, HEADER(pMediaType->pbFormat)->biHeight));
                return E_FAIL;
    }

    HRESULT Hr;
    if (FAILED(Hr = CBasePin::SetMediaType((CMediaType*)m_aFormats[dwIndex])))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:SetMediaType failed, hr=%x)", _fx_, Hr));
                return E_FAIL;
    }

    if (FAILED(Hr = ChangeFormatHelper()))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:ChangeFormatHelper failed, hr=%x)", _fx_, Hr));
                return E_FAIL;
    }

        // Update current format
        m_iCurrFormat = (int)dwIndex;

        // Update bitrate controls
        m_lTargetBitrate = m_aCapabilities[dwIndex]->MaxBitsPerSecond / 10;
        m_lCurrentBitrate = 0;
        m_lBitrateRangeMin = m_aCapabilities[dwIndex]->MinBitsPerSecond;
        m_lBitrateRangeMax = m_aCapabilities[dwIndex]->MaxBitsPerSecond;
        m_lBitrateRangeSteppingDelta = (m_aCapabilities[dwIndex]->MaxBitsPerSecond - m_aCapabilities[dwIndex]->MinBitsPerSecond) / 100;
        m_lBitrateRangeDefault = m_aCapabilities[dwIndex]->MaxBitsPerSecond / 10;

        // Update frame rate controls
        m_lMaxAvgTimePerFrame = (LONG)m_aCapabilities[dwIndex]->MinFrameInterval;
        m_lCurrentAvgTimePerFrame = m_lMaxAvgTimePerFrame;
        m_lAvgTimePerFrameRangeMin = (LONG)m_aCapabilities[dwIndex]->MinFrameInterval;
        m_lAvgTimePerFrameRangeMax = (LONG)m_aCapabilities[dwIndex]->MaxFrameInterval;
        m_lAvgTimePerFrameRangeSteppingDelta = (LONG)(m_aCapabilities[dwIndex]->MaxFrameInterval - m_aCapabilities[dwIndex]->MinFrameInterval) / 100;
        m_lAvgTimePerFrameRangeDefault = (LONG)m_aCapabilities[dwIndex]->MinFrameInterval;

    return S_OK;
}

/****************************************************************************
 *  @doc INTERNAL CBASEPINMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | SetMediaType | This method is used to
 *    set a specific media type on a pin.
 *
 *  @parm CMediaType* | pMediaType | Specifies a pointer to the media type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CTAPIBasePin::SetMediaType(IN CMediaType *pMediaType)
{
        HRESULT Hr = NOERROR;
        DWORD   dwIndex;

        FX_ENTRY("CTAPIBasePin::SetMediaType")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Let the capture device decide how to capture to generate
        // video frames of the same resolution and frame rate
        // @todo Beware if you are previewing at the same time!
        if (FAILED(Hr = m_pCaptureFilter->m_pCapDev->SendFormatToDriver(
        HEADER(pMediaType->pbFormat)->biWidth,
        HEADER(pMediaType->pbFormat)->biHeight,
        HEADER(pMediaType->pbFormat)->biCompression,
        HEADER(pMediaType->pbFormat)->biBitCount,
        ((VIDEOINFOHEADER *)(pMediaType->pbFormat))->AvgTimePerFrame,
        FALSE
        )))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: SendFormatToDriver() failed!", _fx_));
                goto MyExit;
        }

        // Update the capture mode field for this device
        if (!m_pCaptureFilter->m_pCapDev->m_dwStreamingMode
        || (m_pCaptureFilter->m_pCapDev->m_dwStreamingMode == FRAME_GRAB_LARGE_SIZE
            && m_pCaptureFilter->m_user.pvi->bmiHeader.biHeight < 240
            && m_pCaptureFilter->m_user.pvi->bmiHeader.biWidth < 320))
    {
                g_aDeviceInfo[m_pCaptureFilter->m_dwDeviceIndex].nCaptureMode = CaptureMode_Streaming;
    }
        else
    {
                g_aDeviceInfo[m_pCaptureFilter->m_dwDeviceIndex].nCaptureMode = CaptureMode_FrameGrabbing;
    }

    if(m_pCaptureFilter->m_pCapDev->m_bCached_vcdi)
        m_pCaptureFilter->m_pCapDev->m_vcdi.nCaptureMode=g_aDeviceInfo[m_pCaptureFilter->m_dwDeviceIndex].nCaptureMode;


    if (SUCCEEDED(Hr = CBasePin::SetMediaType(pMediaType)))
        {
        Hr = ChangeFormatHelper();
        if (FAILED(Hr))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:Reconnect CapturePin failed", _fx_));
            goto MyExit;
        }

                // Which one of our formats is this exactly?
                for (dwIndex=0; dwIndex < m_dwNumFormats;  dwIndex++)
                {
                        if ((HEADER(pMediaType->pbFormat)->biCompression == HEADER(m_aFormats[dwIndex]->pbFormat)->biCompression)
                                && (HEADER(pMediaType->pbFormat)->biWidth == HEADER(m_aFormats[dwIndex]->pbFormat)->biWidth)
                                && (HEADER(pMediaType->pbFormat)->biHeight == HEADER(m_aFormats[dwIndex]->pbFormat)->biHeight))
                                break;
                }

                if (dwIndex < m_dwNumFormats)
                {
                        // Update current format
                        m_iCurrFormat = (int)dwIndex;

                        // Update bitrate controls
                        m_lTargetBitrate = m_aCapabilities[dwIndex]->MaxBitsPerSecond / 10;
                        m_lCurrentBitrate = 0;
                        m_lBitrateRangeMin = m_aCapabilities[dwIndex]->MinBitsPerSecond;
                        m_lBitrateRangeMax = m_aCapabilities[dwIndex]->MaxBitsPerSecond;
                        m_lBitrateRangeSteppingDelta = (m_aCapabilities[dwIndex]->MaxBitsPerSecond - m_aCapabilities[dwIndex]->MinBitsPerSecond) / 100;
                        m_lBitrateRangeDefault = m_aCapabilities[dwIndex]->MaxBitsPerSecond / 10;

                        // Update frame rate controls
                        m_lMaxAvgTimePerFrame = (LONG)m_aCapabilities[dwIndex]->MinFrameInterval;
                        m_lCurrentAvgTimePerFrame = m_lMaxAvgTimePerFrame;
                        m_lAvgTimePerFrameRangeMin = (LONG)m_aCapabilities[dwIndex]->MinFrameInterval;
                        m_lAvgTimePerFrameRangeMax = (LONG)m_aCapabilities[dwIndex]->MaxFrameInterval;
                        m_lAvgTimePerFrameRangeSteppingDelta = (LONG)(m_aCapabilities[dwIndex]->MaxFrameInterval - m_aCapabilities[dwIndex]->MinFrameInterval) / 100;
                        m_lAvgTimePerFrameRangeDefault = (LONG)m_aCapabilities[dwIndex]->MinFrameInterval;

                        if (m_pCaptureFilter->m_pCapturePin)
                        {
                Hr = m_pCaptureFilter->m_pCapturePin->NotifyDeviceFormatChange(pMediaType);
                if (FAILED(Hr))
                {
                    goto MyExit;
                }

                                ((VIDEOINFOHEADER *)m_pCaptureFilter->m_pCapturePin->m_mt.pbFormat)->AvgTimePerFrame = max(((VIDEOINFOHEADER *)m_pCaptureFilter->m_pCapturePin->m_mt.pbFormat)->AvgTimePerFrame, m_pCaptureFilter->m_user.pvi->AvgTimePerFrame);
                                m_pCaptureFilter->m_pCapturePin->m_lAvgTimePerFrameRangeMin = max(m_pCaptureFilter->m_pCapturePin->m_lAvgTimePerFrameRangeMin, (long)m_pCaptureFilter->m_user.pvi->AvgTimePerFrame);
                                m_pCaptureFilter->m_pCapturePin->m_lMaxAvgTimePerFrame = max(m_pCaptureFilter->m_pCapturePin->m_lMaxAvgTimePerFrame, (long)m_pCaptureFilter->m_user.pvi->AvgTimePerFrame);
                                m_pCaptureFilter->m_pCapturePin->m_lAvgTimePerFrameRangeDefault = m_pCaptureFilter->m_pCapturePin->m_lCurrentAvgTimePerFrame = m_pCaptureFilter->m_pCapturePin->m_lMaxAvgTimePerFrame;
                        }
                        if (m_pCaptureFilter->m_pPreviewPin)
                        {
                Hr = m_pCaptureFilter->m_pPreviewPin->NotifyDeviceFormatChange(pMediaType);
                if (FAILED(Hr))
                {
                    goto MyExit;
                }

                                ((VIDEOINFOHEADER *)m_pCaptureFilter->m_pPreviewPin->m_mt.pbFormat)->AvgTimePerFrame = max(((VIDEOINFOHEADER *)m_pCaptureFilter->m_pPreviewPin->m_mt.pbFormat)->AvgTimePerFrame, m_pCaptureFilter->m_user.pvi->AvgTimePerFrame);
                                m_pCaptureFilter->m_pPreviewPin->m_lAvgTimePerFrameRangeMin = max(m_pCaptureFilter->m_pPreviewPin->m_lAvgTimePerFrameRangeMin, (long)m_pCaptureFilter->m_user.pvi->AvgTimePerFrame);
                                m_pCaptureFilter->m_pPreviewPin->m_lMaxAvgTimePerFrame = max(m_pCaptureFilter->m_pPreviewPin->m_lMaxAvgTimePerFrame, (long)m_pCaptureFilter->m_user.pvi->AvgTimePerFrame);
                                m_pCaptureFilter->m_pPreviewPin->m_lAvgTimePerFrameRangeDefault = m_pCaptureFilter->m_pPreviewPin->m_lCurrentAvgTimePerFrame = m_pCaptureFilter->m_pPreviewPin->m_lMaxAvgTimePerFrame;
                        }
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid input format!", _fx_));
                        Hr = E_FAIL;
                        goto MyExit;
                }

        // Remember to send a sample with a new format attached to it
            m_fFormatChanged = TRUE;
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPINMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | SetMediaType | This method is used to
 *    set a specific media type on a pin.
 *
 *  @parm CMediaType* | pMediaType | Specifies a pointer to the media type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CCapturePin::SetMediaType(IN CMediaType *pMediaType)
{
        HRESULT Hr;

        FX_ENTRY("CCapturePin::SetMediaType")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        if (SUCCEEDED(Hr = CTAPIBasePin::SetMediaType(pMediaType)))
        {
                if (m_iCurrFormat == -1L)
                        m_dwRTPPayloadType = RTPPayloadTypes[0];
                else
                        m_dwRTPPayloadType = RTPPayloadTypes[m_iCurrFormat];
                if (m_pCaptureFilter->m_pRtpPdPin)
                        m_pCaptureFilter->m_pRtpPdPin->m_dwRTPPayloadType = m_dwRTPPayloadType;
        }
#ifdef DEBUG
        else if (pMediaType && pMediaType->pbFormat)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed to set %s %dx%d", _fx_, HEADER(pMediaType->pbFormat)->biCompression == FOURCC_M263 ? "H.263" : HEADER(pMediaType->pbFormat)->biCompression == FOURCC_M261 ? "H.261" : "????", HEADER(pMediaType->pbFormat)->biWidth, HEADER(pMediaType->pbFormat)->biHeight));
        }
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid format", _fx_));
        }
#endif

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPINMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | SetFormat | This method is used to
 *    set a specific media type on a pin. It is only implemented by the
 *    output pin of video encoders.
 *
 *  @parm DWORD | dwRTPPayloadType | Specifies the payload type associated
 *    to the pointer to the <t AM_MEDIA_TYPE> structure passed in.
 *
 *  @parm AM_MEDIA_TYPE* | pMediaType | Specifies a pointer to an
 *    <t AM_MEDIA_TYPE> structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CCapturePin::SetFormat(IN DWORD dwRTPPayloadType, IN AM_MEDIA_TYPE *pMediaType)
{
        HRESULT Hr;

        FX_ENTRY("CCapturePin::SetFormat")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        if (SUCCEEDED(Hr = CTAPIBasePin::SetFormat(pMediaType)))
        {
                m_dwRTPPayloadType = dwRTPPayloadType;
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: Setting %s %dx%d", _fx_, HEADER(pMediaType->pbFormat)->biCompression == FOURCC_M263 ? "H.263" : HEADER(pMediaType->pbFormat)->biCompression == FOURCC_M261 ? "H.261" : "????", HEADER(pMediaType->pbFormat)->biWidth, HEADER(pMediaType->pbFormat)->biHeight));
        }
#ifdef DEBUG
        else if (pMediaType && pMediaType->pbFormat)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed to set %s %dx%d", _fx_, HEADER(pMediaType->pbFormat)->biCompression == FOURCC_M263 ? "H.263" : HEADER(pMediaType->pbFormat)->biCompression == FOURCC_M261 ? "H.261" : "????", HEADER(pMediaType->pbFormat)->biWidth, HEADER(pMediaType->pbFormat)->biHeight));
        }
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid format", _fx_));
        }
#endif

    //

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPINMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | GetFormat | This method is used to
 *    retrieve the current media type on a pin.
 *
 *  @parm DWORD* | pdwRTPPayloadType | Specifies the address of a DWORD
 *    to receive the payload type associated to an <t AM_MEDIA_TYPE> structure.
 *
 *  @parm AM_MEDIA_TYPE** | ppMediaType | Specifies the address of a pointer
 *    to an <t AM_MEDIA_TYPE> structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 *
 *  @comm Note that we return the output type, not the format at which
 *    we are capturing. Only the filter really cares about how the data is
 *    being captured.
 ***************************************************************************/
STDMETHODIMP CCapturePin::GetFormat(OUT DWORD *pdwRTPPayloadType, OUT AM_MEDIA_TYPE **ppMediaType)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CCapturePin::GetFormat")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pdwRTPPayloadType);
        ASSERT(ppMediaType);
        if (!pdwRTPPayloadType || !ppMediaType)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Return a copy of our current format
        Hr = CTAPIBasePin::GetFormat(ppMediaType);

        // Return the payload type associated to the current format
        *pdwRTPPayloadType = m_dwRTPPayloadType;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPINMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | GetNumberOfCapabilities | This method is
 *    used to retrieve the number of stream capabilities structures.
 *
 *  @parm DWORD* | pdwCount | Specifies a pointer to a DWORD to receive the
 *    number of <t TAPI_STREAM_CONFIG_CAPS> structures supported.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CCapturePin::GetNumberOfCapabilities(OUT DWORD *pdwCount)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CCapturePin::GetNumberOfCapabilities")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pdwCount);
        if (!pdwCount)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Return relevant info
        *pdwCount = m_dwNumFormats;

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Returning %ld formats", _fx_, *pdwCount));

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPINMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | GetStreamCaps | This method is
 *    used to retrieve a video stream capability pair.
 *
 *  @parm DWORD | dwIndex | Specifies the index to the desired media type
 *    and capability pair.
 *
 *  @parm AM_MEDIA_TYPE** | ppMediaType | Specifies the address of a pointer
 *    to an <t AM_MEDIA_TYPE> structure.
 *
 *  @parm TAPI_STREAM_CONFIG_CAPS* | pTSCC | Specifies a pointer to a
 *    <t TAPI_STREAM_CONFIG_CAPS> configuration structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CCapturePin::GetStreamCaps(IN DWORD dwIndex, OUT AM_MEDIA_TYPE **ppMediaType, OUT TAPI_STREAM_CONFIG_CAPS *pTSCC, OUT DWORD *pdwRTPPayLoadType)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CCapturePin::GetStreamCaps")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(dwIndex < m_dwNumFormats);
        ASSERT(ppMediaType);
        if (!ppMediaType)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }
        if (!(dwIndex < m_dwNumFormats))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid dwIndex argument!", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }

        // Return a copy of the requested AM_MEDIA_TYPE structure
        if (!(*ppMediaType = CreateMediaType(m_aFormats[dwIndex])))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory!", _fx_));
                Hr = E_OUTOFMEMORY;
                goto MyExit;
        }

        // Return a copy of the requested TAPI_STREAM_CONFIG_CAPS structure
        if (pTSCC)
    {
                pTSCC->CapsType = VideoStreamConfigCaps;
                lstrcpynW(pTSCC->VideoCap.Description, CaptureCapsStrings[dwIndex], MAX_DESCRIPTION_LEN); //this replaces the line below: see 165048
                //GetStringFromStringTable(CaptureCapsStringIDs[dwIndex], pTSCC->VideoCap.Description);
        CopyMemory(&pTSCC->VideoCap.VideoStandard, &m_aCapabilities[dwIndex]->VideoStandard, sizeof(VIDEO_STREAM_CONFIG_CAPS) - sizeof(GUID));
    }

        if (pdwRTPPayLoadType)
        {
                *pdwRTPPayLoadType = RTPPayloadTypes[dwIndex];
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Returning format index %ld: %s %ld bpp %ldx%ld", _fx_, dwIndex, HEADER(m_aFormats[dwIndex]->pbFormat)->biCompression == FOURCC_M263 ? "H.263" : HEADER(m_aFormats[dwIndex]->pbFormat)->biCompression == FOURCC_M261 ? "H.261" : HEADER(m_aFormats[dwIndex]->pbFormat)->biCompression == BI_RGB ? "RGB" : "????", HEADER(m_aFormats[dwIndex]->pbFormat)->biBitCount, HEADER(m_aFormats[dwIndex]->pbFormat)->biWidth, HEADER(m_aFormats[dwIndex]->pbFormat)->biHeight))
;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPINMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | GetStringFromStringTable | This method is
 *    used to retrieve the description string of a video format.
 *
 *  @parm UINT | uStringID | Specifies the string resource ID.
 *
 *  @parm WCHAR* | pwchDescription | Specifies the address of a string to
 *    receive the video format description.
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 *
 *  @comm Based on Article ID: Q200893
 *
 *  If an application has a string localized to multiple languages and
 *  mapped to the same ID in each language, the correct version of the
 *  string might not be loaded on Windows 95 or Windows 98 using the
 *  Win32 function ::LoadString. To load the correct version of the string
 *  you need to load the string using the Win32 functions FindResourceEx
 *  and LoadResource.
 ***************************************************************************/
STDMETHODIMP CCapturePin::GetStringFromStringTable(IN UINT uStringID, OUT WCHAR* pwchDescription)
{
        HRESULT         Hr = NOERROR;
        WCHAR           *pwchCur;
        UINT            idRsrcBlk = uStringID / 16UL + 1;
        DWORD           dwStrIndex  = uStringID % 16UL;
        HINSTANCE       hModule = NULL;
        HRSRC           hResource = NULL;
        DWORD           dwIndex;

        FX_ENTRY("CCapturePin::GetStringFromStringTable")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(IDS_M263_Capture_QCIF <= uStringID && uStringID <= IDS_M261_Capture_CIF);
        ASSERT(pwchDescription);
        if (!pwchDescription)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        if (!(hResource = FindResourceEx(g_hInst, RT_STRING, MAKEINTRESOURCE(idRsrcBlk), MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT))))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: FindResourceEx failed", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }

        if (!(pwchCur = (WCHAR *)LoadResource(g_hInst, hResource)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: LoadResource failed", _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

        // Get the description string
        for (dwIndex = 0; dwIndex<16UL; dwIndex++)
        {
                if (*pwchCur)
                {
                        int cchString = *pwchCur;  // String size in characters.

                        pwchCur++;

                        if (dwIndex == dwStrIndex)
                        {
                                // The string has been found in the string table.
                                lstrcpynW(pwchDescription, pwchCur, min(cchString + 1, MAX_DESCRIPTION_LEN));
                        }
                        pwchCur += cchString;
                }
                else
                        pwchCur++;
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

#ifdef TEST_ISTREAMCONFIG
STDMETHODIMP CCapturePin::TestIStreamConfig()
{
        HRESULT Hr = NOERROR;
        DWORD   dw, dwCount, dwRTPPayLoadType;
        AM_MEDIA_TYPE *pAMMediaType;
        TAPI_STREAM_CONFIG_CAPS TSCC;

        FX_ENTRY("CCapturePin::TestIStreamConfig")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Test GetNumberOfCapabilities
        GetNumberOfCapabilities(&dwCount);

        for (dw=0; dw < dwCount; dw++)
        {
                // Test GetStreamCaps
                GetStreamCaps(dw, &pAMMediaType, &TSCC);

                // Test SetFormat
                SetFormat(96, pAMMediaType);
                DeleteMediaType(pAMMediaType);

                // Test GetFormat
                GetFormat(&dwRTPPayLoadType, &pAMMediaType);
                DeleteMediaType(pAMMediaType);
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\devicev.cpp ===
/****************************************************************************
 *  @doc INTERNAL DEVICEV
 *
 *  @module DeviceV.cpp | Source file for the <c CVfWCapDev>
 *    base class used to communicate with a VfW capture device.
 ***************************************************************************/

#include "Precomp.h"

#ifdef DEBUG
#define DBGUTIL_ENABLE
#endif

#define DEVICEV_DEBUG

  //the define below signales the dbgutil.cpp folowing after that the .cpp it is actually *included*
  //and not compiled standalone
  #define __DBGUTIL_INCLUDED__
  //hack to avoid adding the file below in sources;
  //all other files using dbgutil functions should include dbgutil.h instead
  //--//#include "dbgutil.cpp"
  //the above includes dbgutil.h that defines the __DBGUTIL_H__

#if defined(DBGUTIL_ENABLE) && defined(__DBGUTIL_H__)

  #ifdef DEVICEV_DEBUG
    DEFINE_DBG_VARS(DeviceV, (NTSD_OUT | LOG_OUT), 0x0);
  #else
    DEFINE_DBG_VARS(DeviceV, 0, 0);
  #endif
  #define D(f) if(g_dbg_DeviceV & (f))

#else
  #undef DEVICEV_DEBUG

  #define D(f) ; / ## /
  #define dprintf ; / ## /
  #define dout ; / ## /
#endif


/****************************************************************************
 *  @doc INTERNAL CFWCAPDEVMETHOD
 *
 *  @mfunc void | CVfWCapDev | CVfWCapDev | This method is the constructor
 *    for the <c CVfWCapDev> object.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CVfWCapDev::CVfWCapDev(IN TCHAR *pObjectName, IN CTAPIVCap *pCaptureFilter, IN LPUNKNOWN pUnkOuter, IN DWORD dwDeviceIndex, IN HRESULT *pHr) : CCapDev(pObjectName, pCaptureFilter, pUnkOuter, dwDeviceIndex, pHr)
{
        FX_ENTRY("CVfWCapDev::CVfWCapDev")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        if (!pHr || FAILED(*pHr))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Base class error or invalid input parameter", _fx_));
                goto MyExit;
        }

        // Default inits
        m_dwDeviceID = g_aDeviceInfo[m_dwDeviceIndex].dwVfWIndex;
        m_hVideoIn = NULL;
        m_hVideoExtIn = NULL;
        m_hVideoExtOut = NULL;
        m_bHasOverlay = FALSE;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CVFWCAPDEVMETHOD
 *
 *  @mfunc void | CVfWCapDev | ~CVfWCapDev | This method is the destructor
 *    for the <c CVfWCapDev> object.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CVfWCapDev::~CVfWCapDev()
{
        FX_ENTRY("CVfWCapDev::~CVfWCapDev")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CVFWCAPDEVMETHOD
 *
 *  @mfunc CVfWCapDev* | CVfWCapDev | CreateVfWCapDev | This
 *    helper function creates an object to interact with the VfW capture
 *    device.
 *
 *  @parm CTAPIVCap* | pCaptureFilter | Specifies a pointer to the owner
 *    filter.
 *
 *  @parm CCapDev** | ppCapDev | Specifies the address of a pointer to the
 *    newly created <c CVfWCapDev> object.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_OUTOFMEMORY | Out of memory
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CALLBACK CVfWCapDev::CreateVfWCapDev(IN CTAPIVCap *pCaptureFilter, IN DWORD dwDeviceIndex, OUT CCapDev **ppCapDev)
{
        HRESULT Hr = NOERROR;
        IUnknown *pUnkOuter;

        FX_ENTRY("CVfWCapDev::CreateVfWCapDev")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pCaptureFilter);
        ASSERT(ppCapDev);
        if (!pCaptureFilter || !ppCapDev)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Get the outer unknown
        pCaptureFilter->QueryInterface(IID_IUnknown, (void **)&pUnkOuter);

        // Only keep the pUnkOuter reference
        pCaptureFilter->Release();

        // Create an instance of the capture device
        if (!(*ppCapDev = (CCapDev *) new CVfWCapDev(NAME("VfW Capture Device"), pCaptureFilter, pUnkOuter, dwDeviceIndex, &Hr)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                Hr = E_OUTOFMEMORY;
                goto MyExit;
        }

        // If initialization failed, delete the stream array and return the error
        if (FAILED(Hr) && *ppCapDev)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Initialization failed", _fx_));
                Hr = E_FAIL;
                delete *ppCapDev, *ppCapDev = NULL;
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVFWCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CVfWCapDev | NonDelegatingQueryInterface | This
 *    method is the nondelegating interface query function. It returns a pointer
 *    to the specified interface if supported. The only interfaces explicitly
 *    supported being <i IAMVfWCaptureDialogs>.
 *
 *  @parm REFIID | riid | Specifies the identifier of the interface to return.
 *
 *  @parm PVOID* | ppv | Specifies the place in which to put the interface
 *    pointer.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 *
 *  @todo Add interfaces specific to this derived class or remove this code
 *    and let the base class do the work.
 ***************************************************************************/
STDMETHODIMP CVfWCapDev::NonDelegatingQueryInterface(IN REFIID riid, OUT void **ppv)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CVfWCapDev::NonDelegatingQueryInterface")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        if (FAILED(Hr = CCapDev::NonDelegatingQueryInterface(riid, ppv)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, WARN, "%s:   WARNING: NDQI for {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX} failed Hr=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], Hr));
        }
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX}*=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], *ppv));
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVFWCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CVfWCapDev | ConnectToDriver | This method is used to
 *    open a VfW capture device, get its format capibilities, and set a default
 *    format.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CVfWCapDev::ConnectToDriver()
{
        HRESULT Hr = NOERROR;
        MMRESULT mmr;

        FX_ENTRY("CVfWCapDev::ConnectToDriver")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Open and initialize all the channels in the SAME ORDER that AVICap did,
        // for compatability with buggy drivers like Broadway and BT848.

        // Open the VIDEO_IN driver, the one we mostly talk to, and who provides
        // the video FORMAT dialog
        m_hVideoIn = NULL;
        if (mmr = videoOpen(&m_hVideoIn, m_dwDeviceID, VIDEO_IN))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed VIDEO_IN videoOpen - Aborting!", _fx_));
                Hr = VFW_E_NO_CAPTURE_HARDWARE;
                goto MyExit;
        }

        // Now open the EXTERNALIN device. It's only good for providing the video
        // SOURCE dialog, so it doesn't really matter if we can't get it
        m_hVideoExtIn = NULL;
        if (mmr = videoOpen(&m_hVideoExtIn, m_dwDeviceID, VIDEO_EXTERNALIN))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: Failed VIDEO_EXTERNALIN videoOpen", _fx_));
                dprintf("V ! %s:   WARNING: Failed VIDEO_EXTERNALIN videoOpen", _fx_);
        }

        // Now open the EXTERNALOUT device. It's only good for providing the video
        // DISPLAY dialog, and for overlay, so it doesn't really matter if we can't
        // get it
        m_bHasOverlay = FALSE;
        m_hVideoExtOut = NULL;
#ifdef USE_OVERLAY
        if (videoOpen(&m_hVideoExtOut, m_dwDeviceID, VIDEO_EXTERNALOUT) == DV_ERR_OK)
        {
                CHANNEL_CAPS VideoCapsExternalOut;
                if (m_hVideoExtOut && videoGetChannelCaps(m_hVideoExtOut, &VideoCapsExternalOut, sizeof(CHANNEL_CAPS)) == DV_ERR_OK)
                {
                        m_bHasOverlay = (BOOL)(VideoCapsExternalOut.dwFlags & (DWORD)VCAPS_OVERLAY);
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING:  videoGetChannelCaps failed", _fx_));
                }
        }
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING:  Failed VIDEO_EXTERNALOUT videoOpen", _fx_));
        }
#endif

        // VidCap does this, so I better too or some cards will refuse to preview
        if (mmr == 0)
                videoStreamInit(m_hVideoExtIn, 0, 0, 0, 0);

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: Driver %s OVERLAY", _fx_, m_bHasOverlay ? "supports" : "doesn't support"));

        // Get the formats from the registry - if this fail we'll profile the device
        if (FAILED(Hr = CCapDev::GetFormatsFromRegistry()))
        {
                if (FAILED(Hr = CCapDev::ProfileCaptureDevice()))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: ProfileCaptureDevice failed!", _fx_));
                        Hr = VFW_E_NO_CAPTURE_HARDWARE;
                        goto MyExit;
                }
#ifdef DEVICEV_DEBUG
                else    dout(3, g_dwVideoCaptureTraceID, TRCE,"%s:    ProfileCaptureDevice", _fx_);
#endif
        }
#ifdef DEVICEV_DEBUG
        else    dout(3, g_dwVideoCaptureTraceID, TRCE,"%s:    GetFormatsFromRegistry", _fx_);

        dump_video_format_image_size(m_dwImageSize);
        dump_video_format_num_colors(m_dwFormat);
#endif




MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVFWCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CVfWCapDev | DisconnectFromDriver | This method is used to
 *    release the capture device.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CVfWCapDev::DisconnectFromDriver()
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CVfWCapDev::DisconnectFromDriver")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));
        if (m_hVideoIn)
        {
                Hr = videoClose (m_hVideoIn);
                ASSERT(Hr == NOERROR);
                m_hVideoIn=NULL;
        }


        ASSERT(Hr ==  NOERROR);
        if (m_hVideoExtIn)
        {
                Hr = videoStreamFini(m_hVideoExtIn); // this one was streaming
                ASSERT(Hr ==  NOERROR);
                Hr = videoClose (m_hVideoExtIn);
                ASSERT(Hr == NOERROR);
                m_hVideoExtIn=NULL;
        }

        ASSERT(Hr ==  NOERROR);
        if (m_hVideoExtOut) {
                Hr = videoClose (m_hVideoExtOut);
                ASSERT(Hr == NOERROR);
                m_hVideoExtOut=NULL;
        }
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVFWCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CVfWCapDev | ProfileCaptureDevice | This method is used to
 *    determine the list of formats supported by a VfW capture device.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_UNEXPECTED | Unrecoverable error
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CVfWCapDev::ProfileCaptureDevice()
{
        FX_ENTRY("CVfWCapDev::ProfileCaptureDevice")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Provide defaults
        m_dwDialogs = FORMAT_DLG_OFF | SOURCE_DLG_OFF | DISPLAY_DLG_OFF;

        // Ask the driver what dialogs it supports.
        if (m_hVideoExtIn && videoDialog(m_hVideoExtIn, GetDesktopWindow(), VIDEO_DLG_QUERY) == 0)
                m_dwDialogs |= SOURCE_DLG_ON;
        if (m_hVideoIn && videoDialog(m_hVideoIn, GetDesktopWindow(), VIDEO_DLG_QUERY) == 0)
                m_dwDialogs |= FORMAT_DLG_ON;
        if (m_hVideoExtOut && videoDialog(m_hVideoExtOut, GetDesktopWindow(), VIDEO_DLG_QUERY) == 0)
                m_dwDialogs |= DISPLAY_DLG_ON;

        // Disable streaming of large size by default on VfW devices
        m_dwStreamingMode = FRAME_GRAB_LARGE_SIZE;

    // Let the base class complete the profiling
        return CCapDev::ProfileCaptureDevice();
}

/****************************************************************************
 *  @doc INTERNAL CVFWCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CVfWCapDev | SendFormatToDriver | This method is used to
 *    tell the VfW capture device what format to use.
 *
 *  @parm LONG | biWidth | Specifies the image width.
 *
 *  @parm LONG | biHeight | Specifies the image height.
 *
 *  @parm DWORD | biCompression | Specifies the format type.
 *
 *  @parm WORD | biBitCount | Specifies the number of bits per pixel.
 *
 *  @parm REFERENCE_TIME | AvgTimePerFrame | Specifies the frame rate.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CVfWCapDev::SendFormatToDriver(IN LONG biWidth, IN LONG biHeight, IN DWORD biCompression, IN WORD biBitCount, IN REFERENCE_TIME AvgTimePerFrame, BOOL fUseExactFormat)
{
        HRESULT Hr = NOERROR;
        BITMAPINFOHEADER bmih;
        int nFormat, nBestFormat;
        int     i, delta, best, tmp;

        FX_ENTRY("CVfWCapDev::SendFormatToDriver")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));
        dprintf("+ %s\n",_fx_);

        // Validate input parameters
        ASSERT(m_hVideoIn);
        if (!m_hVideoIn)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid input parameter!", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Trying to set %dx%d at %ld fps", _fx_, biWidth, biHeight, AvgTimePerFrame != 0 ? (LONG)(10000000 / AvgTimePerFrame) : 0));

        // Common to all formats
        bmih.biSize = sizeof(BITMAPINFOHEADER);
        bmih.biPlanes = 1;
        bmih.biXPelsPerMeter = bmih.biYPelsPerMeter = bmih.biClrUsed = bmih.biClrImportant = 0;

        if (!fUseExactFormat)
        {
                D(1) dprintf("V Not using 'fUseExactFormat' .... m_dwFormat = 0x%08lx\n", m_dwFormat);
                D(1) dprintf("V Looking for 4cc %lX : '%.4s'\n", biCompression, &biCompression);
                // Can we directly capture data in this format?
                for (nFormat=0, nBestFormat=-1; nFormat<NUM_BITDEPTH_ENTRIES; nFormat++)
                {
                        // Try a format supported by the device
                        // @todo Rename those variables - it's the format, not the number of colors...
                        if (aiFormat[nFormat] & m_dwFormat)
                        {
                                // Remember the device supports this format
                                if (nBestFormat == -1)
                                        nBestFormat = nFormat;

                                // Is this the format we're being asked to use?
                                if (aiFourCCCode[nFormat] == biCompression)
                                        break;
                        }
                }

                // If we found a match, use this format. Otherwise, pick
                // whatever else this device can do
                if (nFormat == NUM_BITDEPTH_ENTRIES)
                {
                        nFormat = nBestFormat;
                }
                D(1) dprintf("V nFormat = %d\n", nFormat);

                bmih.biBitCount = aiBitDepth[nFormat];
                bmih.biCompression = aiFourCCCode[nFormat];

                // Find the best image size to capture at
                // Assume the next resolution will be correctly truncated to the output size
                best = -1;
                delta = 999999;
                dprintf("V biWidth, biHeight = %ld, %ld\n",biWidth, biHeight);
                for (i=0; i<VIDEO_FORMAT_NUM_RESOLUTIONS; i++)
                {
                        if (awResolutions[i].dwRes & m_dwImageSize)
                        {
                                tmp = awResolutions[i].framesize.cx - biWidth;
                                if (tmp < 0) tmp = -tmp;
                                if (tmp < delta)
                                {
                                        delta = tmp;
                                        best = i;
                                }
                                tmp = awResolutions[i].framesize.cy - biHeight;
                                if (tmp < 0) tmp = -tmp;
                                if (tmp < delta)
                                {
                                        delta = tmp;
                                        best = i;
                                }
                        }
                }

                if (best < 0)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Can't find appropriate format!", _fx_));
                        Hr = E_FAIL;
                        goto MyExit;
                }

                bmih.biWidth = awResolutions[best].framesize.cx;
                bmih.biHeight = awResolutions[best].framesize.cy;
        }
        else
        {
                bmih.biWidth = biWidth;
                bmih.biHeight = biHeight;
                bmih.biBitCount = biBitCount;
                bmih.biCompression = biCompression;
        }
#ifdef DEVICEV_DEBUG
        dprintf("V 4CC used = %lX : '%.4s'\n", bmih.biCompression, &bmih.biCompression);
        g_dbg_4cc=bmih.biCompression;
        g_dbg_bc =bmih.biBitCount;
        g_dbg_w  =bmih.biWidth;
        g_dbg_h = bmih.biHeight;
#endif
        bmih.biSizeImage = DIBSIZE(bmih);

        // @todo Copy the palette if there is one

        // Update last format fields
        if (biCompression == BI_RGB)
        {
                if (biBitCount == 4)
                {
                        bmih.biClrUsed = 0;     //WDM version says 16 here...
                        bmih.biClrImportant = 16;
                }
                else if (biBitCount == 8)
                {
                        bmih.biClrUsed = 0;     //WDM version says 256 here...
                        bmih.biClrImportant = 256;
                }
        }

        dprintf("V >>>>>> Asking for: (bmih.) biWidth = %ld, biHeight = %ld, biCompression = '%.4s'\n", bmih.biWidth, bmih.biHeight, &bmih.biCompression);
        D(1) dprintf("V bmih Before:\n");
        D(1) DumpBMIH(&bmih);
        // Do a final check of this format with the capture device
        if (videoConfigure(m_hVideoIn, DVM_FORMAT, VIDEO_CONFIGURE_SET, NULL, &bmih, bmih.biSize, NULL, 0))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid input format!", _fx_));
                Hr = VFW_E_INVALIDMEDIATYPE;
                goto MyExit;
        }

        D(1) dprintf("V bmih After:\n");
        D(1) DumpBMIH(&bmih);
        // @todo Do I need to set a palette too?  Do I care?

        // Allocate space for a videoinfo that will hold current format
        if (m_pCaptureFilter->m_user.pvi)
                delete m_pCaptureFilter->m_user.pvi, m_pCaptureFilter->m_user.pvi = NULL;

        //VFWCAPTUREOPTIONS
        D(1) dprintf("V The m_pCaptureFilter->m_user.pvi Before:\n");
        D(1) dprintf("V  m_pCaptureFilter->m_user.pvi = %p\n",m_pCaptureFilter->m_user.pvi);

        GetFormatFromDriver(&m_pCaptureFilter->m_user.pvi);
        D(1) dprintf("V The m_pCaptureFilter->m_user.pvi After:\n");
        D(1) DumpVIH(m_pCaptureFilter->m_user.pvi);
        D(1) DumpBMIH(&m_pCaptureFilter->m_user.pvi->bmiHeader);


        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: Setting %dx%d at %ld fps", _fx_, biWidth, biHeight, (LONG)AvgTimePerFrame));

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        dprintf("- %s : returning 0x%08x\n",_fx_,(DWORD)Hr);
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVFWCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CVfWCapDev | GetFormatFromDriver | This method is used to
 *    retrieve the VfW capture device format in use.
 *
 *  @parm VIDEOINFOHEADER ** | ppvi | Specifies the address of a pointer to
 *    a video info header structure to receive the video format description.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CVfWCapDev::GetFormatFromDriver(VIDEOINFOHEADER **ppvi)
{
        HRESULT                         Hr = NOERROR;
        DWORD                           biSize = 0;
        UINT                            cb;
        VIDEOINFOHEADER         *pvi = NULL;
        LPBITMAPINFOHEADER      pbih = NULL;
        struct
        {
                WORD         wVersion;
                WORD         wNumEntries;
                PALETTEENTRY aEntry[256];
        } Palette;

        FX_ENTRY("CVfWCapDev::GetFormatFromDriver")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(m_hVideoIn);
        if (!m_hVideoIn)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid input parameter!", _fx_));
                Hr = E_UNEXPECTED;
                goto MyExit;
        }

        // How large is the BITMAPINFOHEADER?
        videoConfigure(m_hVideoIn, DVM_FORMAT, VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_QUERYSIZE, &biSize, 0, 0, NULL, 0);
        if (!biSize)
                biSize = sizeof(BITMAPINFOHEADER);

        // Allocate space for a videoinfo that will hold it
        cb = sizeof(VIDEOINFOHEADER) + biSize - sizeof(BITMAPINFOHEADER) + sizeof(RGBQUAD) * 256;       // space for PALETTE or BITFIELDS
        pvi = (VIDEOINFOHEADER *)(new BYTE[cb]);
        pbih = &pvi->bmiHeader;
        if (!(*ppvi = pvi))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory!", _fx_));
                Hr = E_OUTOFMEMORY;
                goto MyExit;
        }

        // Get the current format
        if (videoConfigure(m_hVideoIn, DVM_FORMAT, VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_CURRENT, NULL, pbih, biSize, NULL, 0))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Can't get current format from driver!", _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

        // Get the palette if necessary
        if (pvi->bmiHeader.biCompression == BI_RGB && pvi->bmiHeader.biBitCount <= 8)
        {
                RGBQUAD *pRGB;
                PALETTEENTRY *pe;

                Palette.wVersion = 0x0300;
                Palette.wNumEntries = pvi->bmiHeader.biBitCount == 8 ? 256 : 16;
                videoConfigure(m_hVideoIn, DVM_PALETTE, VIDEO_CONFIGURE_GET | VIDEO_CONFIGURE_CURRENT, NULL, &Palette, sizeof(Palette), NULL, 0);

                // Convert the palette into a bitmapinfo set of RGBQUAD's
                pRGB = ((LPBITMAPINFO)&pvi->bmiHeader)->bmiColors;
                pe   = Palette.aEntry;
                for (UINT ii = 0; ii < (UINT)Palette.wNumEntries; ++ii, ++pRGB, ++pe)
                {
                        pRGB->rgbBlue  = pe->peBlue;
                        pRGB->rgbGreen = pe->peGreen;
                        pRGB->rgbRed   = pe->peRed;
                        pRGB->rgbReserved = pe->peFlags;
                }

                pvi->bmiHeader.biClrUsed = Palette.wNumEntries;
        }

        // Fix broken bitmap info headers
        if (pvi->bmiHeader.biSizeImage == 0 && (pvi->bmiHeader.biCompression == BI_RGB || pvi->bmiHeader.biCompression == BI_BITFIELDS))
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   WARNING: Fixing broken bitmap info header!", _fx_));
                pvi->bmiHeader.biSizeImage = DIBSIZE(pvi->bmiHeader);
        }
        if (pvi->bmiHeader.biCompression == VIDEO_FORMAT_YVU9 && pvi->bmiHeader.biBitCount != 9)
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   WARNING: Fixing broken bitmap info header!", _fx_));
                pvi->bmiHeader.biBitCount = 9;
                pvi->bmiHeader.biSizeImage = DIBSIZE(pvi->bmiHeader);
        }
        if (pvi->bmiHeader.biBitCount > 8 && pvi->bmiHeader.biClrUsed)
        {
                // BOGUS cap is broken and doesn't reset num colours
                // WINNOV reports 256 colours of 24 bit YUV8 - scary!
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   WARNING: Fixing broken bitmap info header!", _fx_));
                pvi->bmiHeader.biClrUsed = 0;
        }

        // Start with no funky rectangles
        pvi->rcSource.top = 0; pvi->rcSource.left = 0;
        pvi->rcSource.right = 0; pvi->rcSource.bottom = 0;
        pvi->rcTarget.top = 0; pvi->rcTarget.left = 0;
        pvi->rcTarget.right = 0; pvi->rcTarget.bottom = 0;
        pvi->dwBitRate = 0;
        pvi->dwBitErrorRate = 0;
        pvi->AvgTimePerFrame = 333333L;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVFWCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CVfWCapDev | InitializeStreaming | This method is used to
 *    initialize a VfW capture device for streaming.
 *
 *  @parm DWORD | usPerFrame | Specifies the frame rate to be used.
 *
 *  @parm DWORD_PTR | hEvtBufferDone | Specifies a handle to the event to be
 *    signaled whenever a frame is available.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CVfWCapDev::InitializeStreaming(DWORD usPerFrame, DWORD_PTR hEvtBufferDone)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CVfWCapDev::InitializeStreaming")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(m_hVideoIn);
        if (!m_hVideoIn)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid m_hVideoIn!", _fx_));
                Hr = E_UNEXPECTED;
                goto MyExit;
        }

        if (!m_dwStreamingMode || (m_dwStreamingMode == FRAME_GRAB_LARGE_SIZE && m_pCaptureFilter->m_user.pvi->bmiHeader.biHeight < 240 && m_pCaptureFilter->m_user.pvi->bmiHeader.biWidth < 320))
                if (videoStreamInit(m_hVideoIn, usPerFrame, hEvtBufferDone, 0, CALLBACK_EVENT))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: videoStreamInit failed", _fx_));
                        Hr = E_FAIL;
                }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVFWCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CVfWCapDev | StartStreaming | This method is used to
 *    start streaming from a VfW capture device.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CVfWCapDev::StartStreaming()
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CVfWCapDev::StartStreaming")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(m_hVideoIn);
        if (!m_hVideoIn)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid m_hVideoIn!", _fx_));
                Hr = E_UNEXPECTED;
                goto MyExit;
        }

        if (!m_dwStreamingMode || (m_dwStreamingMode == FRAME_GRAB_LARGE_SIZE && m_pCaptureFilter->m_user.pvi->bmiHeader.biHeight < 240 && m_pCaptureFilter->m_user.pvi->bmiHeader.biWidth < 320))
                videoStreamStart(m_hVideoIn);

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVFWCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CVfWCapDev | StopStreaming | This method is used to
 *    stop streaming from a VfW capture device.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CVfWCapDev::StopStreaming()
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CVfWCapDev::StopStreaming")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(m_hVideoIn);
        if (!m_hVideoIn)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid m_hVideoIn!", _fx_));
                Hr = E_UNEXPECTED;
                goto MyExit;
        }

        if (!m_dwStreamingMode || (m_dwStreamingMode == FRAME_GRAB_LARGE_SIZE && m_pCaptureFilter->m_user.pvi->bmiHeader.biHeight < 240 && m_pCaptureFilter->m_user.pvi->bmiHeader.biWidth < 320))
                Hr = videoStreamStop(m_hVideoIn);
                ASSERT(Hr == NOERROR);

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVFWCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CVfWCapDev | TerminateStreaming | This method is used to
 *    tell a VfW capture device to terminate streaming.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CVfWCapDev::TerminateStreaming()
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CVfWCapDev::TerminateStreaming")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(m_hVideoIn);
        if (!m_hVideoIn)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid m_hVideoIn!", _fx_));
                Hr = E_UNEXPECTED;
                goto MyExit;
        }

        if (!m_dwStreamingMode || (m_dwStreamingMode == FRAME_GRAB_LARGE_SIZE && m_pCaptureFilter->m_user.pvi->bmiHeader.biHeight < 240 && m_pCaptureFilter->m_user.pvi->bmiHeader.biWidth < 320))
        {
                Hr = videoStreamReset (m_hVideoIn);
                ASSERT(Hr ==  NOERROR);
                Hr = vidxFreeHeaders (m_hVideoIn);
                ASSERT(Hr ==  NOERROR);
                Hr = videoStreamFini (m_hVideoIn);
                ASSERT(Hr ==  NOERROR);
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVFWCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CVfWCapDev | GrabFrame | This method is used to
 *    grab a video frame from a VfW capture device.
 *
 *  @parm PVIDEOHDR | pVHdr | Specifies a pointer to a VIDEOHDR structure to
 *    receive the video frame.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CVfWCapDev::GrabFrame(PVIDEOHDR pVHdr)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CVfWCapDev::GrabFrame")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(m_hVideoIn);
        ASSERT(pVHdr);
        if (!m_hVideoIn || !pVHdr || !pVHdr->lpData)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid m_hVideoIn, pVHdr, pVHdr->lpData", _fx_));
                Hr = E_UNEXPECTED;
                goto MyExit;
        }

        if (vidxFrame(m_hVideoIn, pVHdr))
                Hr = E_FAIL;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVFWCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CVfWCapDev | AllocateBuffer | This method is used to allocate
 *    a data buffer when video streaming from a VfW capture device.
 *
 *  @parm LPTHKVIDEOHDR * | pptvh | Specifies the address of a pointer to a
 *    THKVIDEOHDR structure to receive the video buffer.
 *
 *  @parm DWORD | dwIndex | Specifies the positional index of the video buffer.
 *
 *  @parm DWORD | cbBuffer | Specifies the size of the video buffer.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CVfWCapDev::AllocateBuffer(LPTHKVIDEOHDR *pptvh, DWORD dwIndex, DWORD cbBuffer)
{
        HRESULT Hr = NOERROR;
        DWORD vidxErr = 0;

        FX_ENTRY("CVfWCapDev::AllocateBuffer")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(m_hVideoIn);
        ASSERT(pptvh);
        ASSERT(cbBuffer);
        if (!m_hVideoIn || !pptvh || !cbBuffer)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid m_hVideoIn, pptvh, cbVHdr or cbBuffer!", _fx_));
                Hr = E_UNEXPECTED;
                goto MyExit;
        }
        if (!m_dwStreamingMode || (m_dwStreamingMode == FRAME_GRAB_LARGE_SIZE && m_pCaptureFilter->m_user.pvi->bmiHeader.biHeight < 240 && m_pCaptureFilter->m_user.pvi->bmiHeader.biWidth < 320))
        {
                if (vidxErr = vidxAllocBuffer (m_hVideoIn, dwIndex, (LPVOID *)pptvh, cbBuffer)) {
                        Hr = E_FAIL;
                        goto MyExit;
                }

        }
        else
        {
                (*pptvh)->vh.dwBufferLength = cbBuffer;
                if (vidxErr = vidxAllocPreviewBuffer(m_hVideoIn, (LPVOID *)&((*pptvh)->vh.lpData), sizeof(VIDEOHDR), cbBuffer)) {
                        Hr = E_FAIL;
                        goto MyExit;
                }
                (*pptvh)->p32Buff = (*pptvh)->vh.lpData;
                (*pptvh)->pStart  = (*pptvh)->vh.lpData; //chg:1
        }

        ASSERT (!IsBadWritePtr((*pptvh)->p32Buff, cbBuffer));

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVFWCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CVfWCapDev | AddBuffer | This method is used to
 *    post a data buffer to a VfW capture device when video streaming.
 *
 *  @parm PVIDEOHDR | pVHdr | Specifies a pointer to a
 *    PVIDEOHDR structure identifying the video buffer.
 *
 *  @parm DWORD | cbVHdr | Specifies the size of the structure pointed to by
 *    the <p pVHdr> parameter.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CVfWCapDev::AddBuffer(PVIDEOHDR pVHdr, DWORD cbVHdr)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CVfWCapDev::AddBuffer")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(m_hVideoIn);
        ASSERT(pVHdr);
        ASSERT(cbVHdr);
        if (!m_hVideoIn || !pVHdr || !cbVHdr)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid m_hVideoIn, pVHdr, cbVHdr", _fx_));
                Hr = E_UNEXPECTED;
                goto MyExit;
        }

        if (vidxAddBuffer(m_hVideoIn, pVHdr, cbVHdr))
                Hr = E_FAIL;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVFWCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CVfWCapDev | FreeBuffer | This method is used to
 *    free a data buffer that was used with a VfW capture device in streaming
 *    mode.
 *
 *  @parm PVIDEOHDR | pVHdr | Specifies a pointer to a
 *    PVIDEOHDR structure identifying the video buffer.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CVfWCapDev::FreeBuffer(LPTHKVIDEOHDR pVHdr) //PVIDEOHDR pVHdr)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CVfWCapDev::FreeBuffer")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(m_hVideoIn);
        ASSERT(pVHdr);
        if (!m_hVideoIn || !pVHdr)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid m_hVideoIn or pVHdr!", _fx_));
                Hr = E_UNEXPECTED;
                goto MyExit;
        }

        if (!m_dwStreamingMode || (m_dwStreamingMode == FRAME_GRAB_LARGE_SIZE && m_pCaptureFilter->m_user.pvi->bmiHeader.biHeight < 240 && m_pCaptureFilter->m_user.pvi->bmiHeader.biWidth < 320))
                vidxFreeBuffer(m_hVideoIn, (DWORD)pVHdr);
        else
                //vidxFreePreviewBuffer(m_hVideoIn, (LPVOID *)&pVHdr->vh.lpData);       // this is definitely wrong: lpData might ALIGNED
                //*vidxFreePreviewBuffer(m_hVideoIn, (LPVOID *)&pVHdr->p32Buff);
                vidxFreePreviewBuffer(m_hVideoIn, (LPVOID *)&pVHdr->pStart);


MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVFWCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CVfWCapDev | AllocateHeaders | This method is used to
 *    video headers for data buffers used with a VfW capture device in streaming
 *    mode.
 *
 *  @parm DWORD | dwNumHdrs | Specifies the number of video headers to allocate.
 *
 *  @parm DWORD | cbHdr | Specifies the size of the video headers to allocate.
 *
 *  @parm LPVOID* | ppaHdr | Specifies the address of a pointer to receive
 *    the video headers allocated.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CVfWCapDev::AllocateHeaders(DWORD dwNumHdrs, DWORD cbHdr, LPVOID *ppaHdr)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CVfWCapDev::AllocateHeaders")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(m_hVideoIn);
        ASSERT(ppaHdr);
        ASSERT(cbHdr);
        if (!m_hVideoIn || !ppaHdr || !cbHdr)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid m_hVideoIn, cbHdr or pVHdr!", _fx_));
                Hr = E_UNEXPECTED;
                goto MyExit;
        }

        if (!m_dwStreamingMode || (m_dwStreamingMode == FRAME_GRAB_LARGE_SIZE && m_pCaptureFilter->m_user.pvi->bmiHeader.biHeight < 240 && m_pCaptureFilter->m_user.pvi->bmiHeader.biWidth < 320))
        {
                if (vidxAllocHeaders(m_hVideoIn, dwNumHdrs, sizeof(THKVIDEOHDR) + sizeof(DWORD), ppaHdr))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory!", _fx_));
                        Hr = E_OUTOFMEMORY;
                }
        }
        else
        {
                if (!(*ppaHdr = (struct CTAPIVCap::_cap_parms::_cap_hdr *)new BYTE[(sizeof(THKVIDEOHDR) + sizeof(DWORD)) * dwNumHdrs]))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory!", _fx_));
                        Hr = E_OUTOFMEMORY;
                }
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CVFWCAPDEVMETHOD
 *
 *  @mfunc BOOL | CVfWCapDev | IsBufferDone | This method is used to
 *    check the DONE status of a video streaming buffer.
 *
 *  @parm PVIDEOHDR | pVHdr | Specifies a pointer to a
 *    PVIDEOHDR structure identifying the video buffer.
 *
 *  @rdesc This method returns TRUE if the buffer is DONE, FALSE otherwise.
 ***************************************************************************/
BOOL CVfWCapDev::IsBufferDone(PVIDEOHDR pVHdr)
{
        ASSERT(pVHdr);

        if (!pVHdr || !(pVHdr->dwFlags & VHDR_DONE))
                return FALSE;
        else
        return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\devices.cpp ===
#include "Precomp.h"
#include "dbgxtra.h"
#include <qedit.h>
#include <atlbase.h>

#define ABS(x) (((x) > 0) ? (x) : -(x))

HRESULT CALLBACK CDShowCapDev::CreateDShowCapDev(IN CTAPIVCap *pCaptureFilter, IN DWORD dwDeviceIndex, OUT CCapDev **ppCapDev)
{
    HRESULT Hr = NOERROR;
    IUnknown *pUnkOuter;

    FX_ENTRY("CDShowCapDev::CreateDShowCapDev")

    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

    ASSERT(pCaptureFilter);
    ASSERT(ppCapDev);
    if (!pCaptureFilter || !ppCapDev)
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
        Hr = E_POINTER;
        goto MyExit;
    }

    // Get the outer unknown
    pCaptureFilter->QueryInterface(IID_IUnknown, (void **)&pUnkOuter);

    // Only keep the pUnkOuter reference
    pCaptureFilter->Release();

    // Create an instance of the capture device
    if (!(*ppCapDev = (CCapDev *) new CDShowCapDev(NAME("DShow Capture Device"), pCaptureFilter, pUnkOuter, dwDeviceIndex, &Hr)))
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
        Hr = E_OUTOFMEMORY;
        goto MyExit;
    }

    // If initialization failed, delete the stream array and return the error
    if (FAILED(Hr) && *ppCapDev)
    {
        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Initialization failed", _fx_));
        Hr = E_FAIL;
        delete *ppCapDev, *ppCapDev = NULL;
    }

MyExit:
    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
    return Hr;
}

CDShowCapDev::CDShowCapDev(
    IN TCHAR *pObjectName, IN CTAPIVCap *pCaptureFilter, IN LPUNKNOWN pUnkOuter,
    IN DWORD dwDeviceIndex, IN HRESULT *pHr) :
        CCapDev(pObjectName, pCaptureFilter, pUnkOuter, dwDeviceIndex, pHr)
{
    // which device we're talking to
    m_dwDeviceIndex = dwDeviceIndex;

    ZeroMemory(&m_mt, sizeof(AM_MEDIA_TYPE));

    m_hEvent = NULL;
    m_pBuffer = NULL;
    m_cbBuffer = 0;
    m_cbBufferValid = 0;
    m_fEventMode = FALSE;
    m_cBuffers = 0;
    m_nTop = 0;
    m_nBottom = 0;
}

/****************************************************************************
 *  @doc INTERNAL CDShowCAPDEVMETHOD
 *
 *  @mfunc void | CDShowCapDev | ~CDShowCapDev | This method is the destructor
 *    for the <c CDShowCapDev> object. Closes the driver file handle and
 *    releases the video data range memory
 *
 *  @rdesc Nada.
 ***************************************************************************/
CDShowCapDev::~CDShowCapDev()
{
    DisconnectFromDriver();
    FreeMediaType(m_mt);
    delete [] m_pBuffer;
}


STDMETHODIMP CDShowCapDev::NonDelegatingQueryInterface(IN REFIID riid, OUT void **ppv)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CDShowCapDev::NonDelegatingQueryInterface")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Retrieve interface pointer
        if (riid == __uuidof(IVideoProcAmp))
        {
            *ppv = static_cast<IVideoProcAmp*>(this);
            GetOwner()->AddRef();
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: IAMVideoProcAmp*=0x%08lX", _fx_, *ppv));
                goto MyExit;
        }
#ifndef USE_SOFTWARE_CAMERA_CONTROL
        else if (riid == __uuidof(ICameraControl))
        {
            *ppv = static_cast<ICameraControl*>(this);
            GetOwner()->AddRef();
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: ICameraControl*=0x%08lX", _fx_, *ppv));
                goto MyExit;
        }
#endif
        else if (FAILED(Hr = CCapDev::NonDelegatingQueryInterface(riid, ppv)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, WARN, "%s:   WARNING: NDQI for {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX} failed Hr=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], Hr));
        }
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX}*=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], *ppv));
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

// Device control


//
HRESULT CDShowCapDev::ProfileCaptureDevice()
{
    // no dialogs for now
    m_dwDialogs = FORMAT_DLG_OFF | SOURCE_DLG_OFF | DISPLAY_DLG_OFF;

    // Frame grab has an extra memory copy, so never do it (WDM grabs for
    // large sizes)
    // m_dwStreamingMode = FRAME_GRAB_LARGE_SIZE;
    m_dwStreamingMode = STREAM_ALL_SIZES;

    // Let the base class complete the profiling
    return CCapDev::ProfileCaptureDevice();
}


// set up everything
//
HRESULT CDShowCapDev::ConnectToDriver()
{
    HRESULT hr;

    WCHAR wchar[MAX_PATH];
    char chDesc[MAX_PATH];
    lstrcpyW(wchar, L"@device:pnp:");	// must be prefixed with this
    MultiByteToWideChar(CP_ACP, 0, g_aDeviceInfo[m_dwDeviceIndex].szDevicePath, -1,
                        wchar + lstrlenW(wchar), MAX_PATH);

    // this will strip the "-SVideo" suffix off the description so the profile
    // code won't get confused by it.  Remember the original
    lstrcpyA(chDesc, g_aDeviceInfo[m_dwDeviceIndex].szDeviceDescription);
    
    hr = CSharedGraph::CreateInstance(wchar, g_aDeviceInfo[m_dwDeviceIndex].szDeviceDescription, &m_psg);
    if (FAILED(hr))
        return hr;

    // Don't build a graph yet, we'll just have to tear it down and build a
    // new one when we find out what format to use anyway

    // Get the formats from the registry - if this fails we profile the device
    if (FAILED(hr = GetFormatsFromRegistry())) {
        if (FAILED(hr = ProfileCaptureDevice())) {
            hr = VFW_E_NO_CAPTURE_HARDWARE;
        }
    }

    // now put the suffix back on the description so we'll know next time we
    // choose the device which input to use
    lstrcpyA(g_aDeviceInfo[m_dwDeviceIndex].szDeviceDescription, chDesc);

    return hr;
}


HRESULT CDShowCapDev::BuildGraph(AM_MEDIA_TYPE& mt)
{
    if (m_psg)
        return m_psg->BuildGraph(&mt, 0);
    else
        return E_UNEXPECTED;
}


HRESULT CDShowCapDev::DisconnectFromDriver()
{
    StopStreaming();    // just in case
    m_psg.Release();
    return S_OK;
}


//
HRESULT CDShowCapDev::SendFormatToDriver(
    IN LONG biWidth, IN LONG biHeight, IN DWORD biCompression, IN WORD biBitCount,
    IN REFERENCE_TIME AvgTimePerFrame, BOOL fUseExactFormat)
{
    VIDEOINFOHEADER viNew;
    
    if (m_psg == NULL)
        return E_UNEXPECTED;

    // don't attempt > 15fps, that's probably a waste of time
    if (AvgTimePerFrame && AvgTimePerFrame < 666667)
        AvgTimePerFrame = 666667;

    HRESULT hr = m_psg->SetVideoFormat(biWidth, biHeight, biCompression,
                biBitCount, AvgTimePerFrame,  fUseExactFormat, &viNew);
    if(SUCCEEDED(hr))
    {
        delete m_pCaptureFilter->m_user.pvi;
        m_pCaptureFilter->m_user.pvi = (VIDEOINFOHEADER *)new VIDEOINFOHEADER;
        if(m_pCaptureFilter->m_user.pvi == 0) {
            return E_OUTOFMEMORY;
        }
        CopyMemory(m_pCaptureFilter->m_user.pvi, &viNew, sizeof(VIDEOINFOHEADER));
        // this is our new fps to use
        m_usPerFrame = (DWORD)(AvgTimePerFrame / 10);

        // new fmt may need a new size 
        m_cbBuffer = 0;
    
    }

    return hr;
}


// we must use NEW to allocate it
// caller must "delete pvi"
//
HRESULT CDShowCapDev::GetFormatFromDriver(OUT VIDEOINFOHEADER **ppvi)
{
    if (m_psg == NULL)
        return E_UNEXPECTED;

    // this will only be called if we don't have a graph built yet from the
    // profiling code, which needs this to succeed, so FORCE a graph to be
    // built.
    return m_psg->GetVideoFormat(ppvi, TRUE);
}

// Streaming and frame grabbing control

HRESULT CDShowCapDev::InitializeStreaming(DWORD usPerFrame, DWORD_PTR hEvtBufferDone)
{
    ASSERT(!m_fEventMode);
    HRESULT hr = S_OK;

    // we shouldn't ever close this handle, right?
    m_hEvent = (HANDLE)hEvtBufferDone;

    m_fEventMode = TRUE;    // this is event fire mode (not grab mode)

    // don't attempt > 15fps, that's probably a waste of time
    if (usPerFrame && usPerFrame < 66667)
        usPerFrame = 66667;

    m_usPerFrame = usPerFrame; // remember this

    return hr;
}


HRESULT CDShowCapDev::StartStreaming()
{
    if (m_psg == NULL)
        return E_UNEXPECTED;

    // note the buffer is empty
    m_cbBufferValid = 0;

    ASSERT(m_pBuffer == NULL);
    ASSERT(m_cbBuffer);

    // make a new buffer
    m_pBuffer = new BYTE[m_cbBuffer];
    if (m_pBuffer == NULL)
	return E_OUTOFMEMORY;

    return m_psg->RunVideo(this, CDShowCapDev::VideoCallback, m_usPerFrame);
}


HRESULT CDShowCapDev::StopStreaming()
{
    if (m_psg == NULL)
        return E_UNEXPECTED;

    m_psg->StopVideo();
    
    delete [] m_pBuffer;
    m_pBuffer = NULL;
    
    return S_OK;
}


// What should we do here?
//
HRESULT CDShowCapDev::TerminateStreaming()
{
    ASSERT(m_fEventMode);
    m_fEventMode = FALSE;   // exit event mode

    return S_OK;
}


HRESULT CDShowCapDev::GrabFrame(PVIDEOHDR pVHdr)
{
    HRESULT hr = NOERROR;

    // Validate input parameters
    ASSERT(pVHdr);
    if (!pVHdr || !pVHdr->lpData) {
        return E_INVALIDARG;
    }

    // timeout after no less than 10sec instead of hanging
    int x=0;
    while (!m_cbBufferValid && x++ < 1000) {
	Sleep(10);
    }
    if (!m_cbBufferValid)
        return E_UNEXPECTED;

    // don't read and write here at the same time
    CAutoLock foo(&m_csBuffer);
    
    ASSERT((int)pVHdr->dwBufferLength >= m_cbBuffer);

    // !!! I do 2 memory copies in frame grab mode
    CopyMemory(pVHdr->lpData, m_pBuffer, m_cbBuffer);
        
    pVHdr->dwTimeCaptured = timeGetTime();  // !!! not right
    pVHdr->dwBytesUsed = m_cbBufferValid;
    pVHdr->dwFlags |= VHDR_KEYFRAME;	    // !!! can't be sure

    return hr;
}


HRESULT CDShowCapDev::AllocateBuffer(LPTHKVIDEOHDR *pptvh, DWORD dwIndex, DWORD cbBuffer)
{
    HRESULT Hr = NOERROR;

    // Validate input parameters
    ASSERT(pptvh);
    ASSERT(cbBuffer);
    if (!pptvh || !cbBuffer)
    {
        return E_INVALIDARG;
    }

    // note how big buffers need to be
    ASSERT(m_cbBuffer == 0 || m_cbBuffer == cbBuffer);
    m_cbBuffer = cbBuffer;

    *pptvh = &m_pCaptureFilter->m_cs.paHdr[dwIndex].tvh;
    (*pptvh)->vh.dwBufferLength = cbBuffer;
    if (!((*pptvh)->vh.lpData = new BYTE[cbBuffer]))
    {
            return E_OUTOFMEMORY;
    }
    (*pptvh)->p32Buff = (*pptvh)->vh.lpData;

    ASSERT (!IsBadWritePtr((*pptvh)->p32Buff, cbBuffer));
    ZeroMemory((*pptvh)->p32Buff,cbBuffer);

    ASSERT(m_cBuffers == dwIndex);
    m_cBuffers++;   // keep track of how many buffers there are
    
    // add this buffer to the initial list (we don't get add buffers the 1st time through)
    m_aStack[m_nTop++] = dwIndex;

    return Hr;
}


HRESULT CDShowCapDev::AddBuffer(PVIDEOHDR pVHdr, DWORD cbVHdr)
{
    // Which buffer is this?  (Stupid thing doesn't know!)
    DWORD dwIndex;    
    for (dwIndex=0; dwIndex < m_pCaptureFilter->m_cs.nHeaders; dwIndex++) {
        if (&m_pCaptureFilter->m_cs.paHdr[dwIndex].tvh.vh == pVHdr)
            break;
    }

    // Can't find it!
    if (dwIndex == m_pCaptureFilter->m_cs.nHeaders) {
        ASSERT(FALSE);
	return E_INVALIDARG;
    }
			       
    // IsBufferDone might be looking at m_nTop - don't let it be MAX
    CAutoLock foo(&m_csStack);

    // add this to our list
    m_aStack[m_nTop++] = dwIndex;
    if (m_nTop == MAX_BSTACK)
	m_nTop = 0;
        
    return S_OK;
}


HRESULT CDShowCapDev::FreeBuffer(LPTHKVIDEOHDR pVHdr)
{
    HRESULT Hr = NOERROR;

    // Validate input parameters
    ASSERT(pVHdr);
    if (!pVHdr || !pVHdr->vh.lpData)
    {
        return E_POINTER;
    }

    delete pVHdr->vh.lpData, pVHdr->vh.lpData = NULL;
    pVHdr->p32Buff = NULL;

    m_cBuffers--;

    m_nTop = m_nBottom = 0; // back to empty stack

    return Hr;
}


HRESULT CDShowCapDev::AllocateHeaders(DWORD dwNumHdrs, DWORD cbHdr, LPVOID *ppaHdr)
{
    HRESULT Hr = NOERROR;
    CheckPointer(ppaHdr, E_POINTER);
    ASSERT(cbHdr);
    if (!cbHdr) {
        return E_INVALIDARG;
    }

    // MUST use NEW
    if (!(*ppaHdr = new BYTE[cbHdr * dwNumHdrs])) {
        return E_OUTOFMEMORY;
    }

    ZeroMemory(*ppaHdr, cbHdr * dwNumHdrs);

    m_nTop = m_nBottom = 0; // start with empty stack

    return Hr;
}


BOOL CDShowCapDev::IsBufferDone(PVIDEOHDR pVHdr)
{
    // don't let anybody mess up m_nTop or m_nBottom
    CAutoLock foo(&m_csStack);

    // walk the list of things not done
    BOOL fDone = TRUE;
    int iTop = m_nTop >= m_nBottom ? m_nTop : m_nTop + MAX_BSTACK;
    for (int z = m_nBottom; z < iTop; z++) {
	PVIDEOHDR pv = &m_pCaptureFilter->m_cs.paHdr[m_aStack[z % MAX_BSTACK]].tvh.vh;
        if (pv == pVHdr) {
            fDone = FALSE;
            break;
        }
    }

    return fDone;
}


// sample grabber stuff
//
void CDShowCapDev::VideoCallback(void *pContext, IMediaSample *pSample)
{
    CDShowCapDev *pThis = (CDShowCapDev *)pContext;
    int cbSrc = pSample->GetActualDataLength();

    // oh uh, this frame is too big
    ASSERT(cbSrc <= pThis->m_cbBuffer);

    // oh uh, this frame is too small
    if (cbSrc <= 0)
        return;

    BYTE *pSrc;
    pSample->GetPointer(&pSrc);
				   
    // GRAB FRAME MODE - save it away
    if (!pThis->m_fEventMode) {
	// don't read and write here at the same time
	CAutoLock foo(&pThis->m_csBuffer);

	// !!! I do 2 memory copies in frame grab mode
	CopyMemory(pThis->m_pBuffer, pSrc, cbSrc);
	pThis->m_cbBufferValid = cbSrc;

    // STREAMING MODE - send it off
    } else {

	// no place to put this frame, drop it
	if (pThis->m_nTop == pThis->m_nBottom) {
	    return;
	}

        // IsBufferDone might be looking at m_nBottom - don't let it be MAX
        pThis->m_csStack.Lock();

	PVIDEOHDR pv = &pThis->m_pCaptureFilter->m_cs.paHdr[pThis->m_aStack[pThis->m_nBottom++]].tvh.vh;
	if (pThis->m_nBottom == MAX_BSTACK)
	    pThis->m_nBottom = 0;
        pThis->m_csStack.Unlock();

	CopyMemory(pv->lpData, pSrc, cbSrc);
        
	pv->dwTimeCaptured = timeGetTime();  // !!! not right
	pv->dwBytesUsed = cbSrc;
	pv->dwFlags |= VHDR_KEYFRAME;	     // !!! can't be sure

        

	SetEvent(pThis->m_hEvent);

    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\devicew.cpp ===
/****************************************************************************
 *  @doc INTERNAL DEVICEW
 *
 *  @module DeviceW.cpp | Source file for the <c CWDMCapDev>
 *    base class used to communicate with a WDM capture device.
 ***************************************************************************/

#include "Precomp.h"

// @todo Remove this before checkin!
//#define DUMP_DRIVER_CHARACTERISTICS 1
//#define DEBUG_STREAMING

//#define XTRA_TRACE -- moved into ...\skywalker\filters\filters.inc
#include "dbgxtra.h"

#ifdef XTRA_TRACE

#define LOLA 0x414C4F4C  //LOLA
#define BOLA 0x414C4F42  //BOLA
#define MAGIC_TAG_SET(a)   m_tag=a
UINT savi;
DWORD GetOvResErr[6];

#define CLEAR_GetOvResErr   memset(GetOvResErr,0,sizeof(GetOvResErr))
#define SET_GetOvResErr(i,value)        GetOvResErr[(i)]=(value);
#define SET_I(sav,i)    sav=(i)


#else

#define MAGIC_TAG_SET(a)
#define CLEAR_GetOvResErr
#define SET_GetOvResErr(i,value)
#define SET_I(sav,i)
#endif //XTRA_TRACE

#ifdef DEBUG
#define DBGUTIL_ENABLE
#endif

#define DEVICEW_DEBUG
//--//#include "dbgutil.h" // this defines the __DBGUTIL_H__ below
#if defined(DBGUTIL_ENABLE) && defined(__DBGUTIL_H__)

  #ifdef DEVICEW_DEBUG
    DEFINE_DBG_VARS(DeviceW, (NTSD_OUT | LOG_OUT), 0x0);
  #else
    DEFINE_DBG_VARS(DeviceW, 0, 0);
  #endif
  #define D(f) if(g_dbg_DeviceW & (f))

#else
  #undef DEVICEW_DEBUG

  #define D(f) ; / ## /
  #define dprintf ; / ## /
  #define dout ; / ## /
#endif



/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc void | CWDMCapDev | CWDMCapDev | This method is the constructor
 *    for the <c CWDMCapDev> object.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CWDMCapDev::CWDMCapDev(IN TCHAR *pObjectName, IN CTAPIVCap *pCaptureFilter, IN LPUNKNOWN pUnkOuter, IN DWORD dwDeviceIndex, IN HRESULT *pHr) : CCapDev(pObjectName, pCaptureFilter, pUnkOuter, dwDeviceIndex, pHr)
{
        FX_ENTRY("CWDMCapDev::CWDMCapDev")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        if (!pHr || FAILED(*pHr))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Base class error or invalid input parameter", _fx_));
                goto MyExit;
        }

    MAGIC_TAG_SET(LOLA);   //magic seq. set 2 string LOLA
        // Default inits
        m_hDriver                       = NULL;
        m_pVideoDataRanges      = NULL;
        m_dwCapturePinId        = INVALID_PIN_ID;
        m_dwPreviewPinId        = INVALID_PIN_ID;
        m_hKSPin                        = NULL;
        m_hKsUserDLL            = NULL;
        m_pKsCreatePin          = NULL;
        m_fStarted                      = FALSE;
    m_pWDMVideoBuff     = NULL;
        m_cntNumVidBuf  = 0;
MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc void | CWDMCapDev | ~CWDMCapDev | This method is the destructor
 *    for the <c CWDMCapDev> object. Closes the driver file handle and
 *    releases the video data range memory
 *
 *  @rdesc Nada.
 ***************************************************************************/
CWDMCapDev::~CWDMCapDev()
{
        FX_ENTRY("CWDMCapDev::~CWDMCapDev")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Closing the WDM driver, m_hDriver=0x%08lX", _fx_, m_hDriver));

        if (m_hDriver)
                DisconnectFromDriver();

    if (m_pWDMVideoBuff) delete [] m_pWDMVideoBuff;

        if (m_pVideoDataRanges)
        {
                delete [] m_pVideoDataRanges;
                m_pVideoDataRanges = (PVIDEO_DATA_RANGES)NULL;
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc CWDMCapDev* | CWDMCapDev | CreateWDMCapDev | This
 *    helper function creates an object to interact with the WDM capture
 *    device.
 *
 *  @parm CTAPIVCap* | pCaptureFilter | Specifies a pointer to the owner
 *    filter.
 *
 *  @parm CCapDev** | ppCapDev | Specifies the address of a pointer to the
 *    newly created <c CWDMCapDev> object.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_OUTOFMEMORY | Out of memory
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CALLBACK CWDMCapDev::CreateWDMCapDev(IN CTAPIVCap *pCaptureFilter, IN DWORD dwDeviceIndex, OUT CCapDev **ppCapDev)
{
        HRESULT Hr = NOERROR;
        IUnknown *pUnkOuter;

        FX_ENTRY("CWDMCapDev::CreateWDMCapDev")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        //LOG_MSG_VAL(_fx_,0,0,0);
        // Validate input parameters
        ASSERT(pCaptureFilter);
        ASSERT(ppCapDev);
        if (!pCaptureFilter || !ppCapDev)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Get the outer unknown
        pCaptureFilter->QueryInterface(IID_IUnknown, (void **)&pUnkOuter);

        // Only keep the pUnkOuter reference
        pCaptureFilter->Release();

        // Create an instance of the capture device
        if (!(*ppCapDev = (CCapDev *) new CWDMCapDev(NAME("WDM Capture Device"), pCaptureFilter, pUnkOuter, dwDeviceIndex, &Hr)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                Hr = E_OUTOFMEMORY;
                goto MyExit;
        }

        // If initialization failed, delete the stream array and return the error
        if (FAILED(Hr) && *ppCapDev)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Initialization failed", _fx_));
                Hr = E_FAIL;
                delete *ppCapDev, *ppCapDev = NULL;
        }

        //LOG_MSG_VAL(_fx_,0,0,1);
MyExit:
        //LOG_MSG_VAL(_fx_,0,0,0xffff);
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | NonDelegatingQueryInterface | This
 *    method is the nondelegating interface query function. It returns a pointer
 *    to the specified interface if supported. The only interfaces explicitly
 *    supported being <i IAMVfWCaptureDialogs>.
 *
 *  @parm REFIID | riid | Specifies the identifier of the interface to return.
 *
 *  @parm PVOID* | ppv | Specifies the place in which to put the interface
 *    pointer.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 *
 *  @todo Add interfaces specific to this derived class or remove this code
 *    and let the base class do the work.
 ***************************************************************************/
STDMETHODIMP CWDMCapDev::NonDelegatingQueryInterface(IN REFIID riid, OUT void **ppv)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CWDMCapDev::NonDelegatingQueryInterface")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Retrieve interface pointer
        if (riid == __uuidof(IVideoProcAmp))
        {
            *ppv = static_cast<IVideoProcAmp*>(this);
            GetOwner()->AddRef();
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: IAMVideoProcAmp*=0x%08lX", _fx_, *ppv));
                goto MyExit;
        }
#ifndef USE_SOFTWARE_CAMERA_CONTROL
        else if (riid == __uuidof(ICameraControl))
        {
            *ppv = static_cast<ICameraControl*>(this);
            GetOwner()->AddRef();
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: ICameraControl*=0x%08lX", _fx_, *ppv));
                goto MyExit;
        }
#endif
        else if (FAILED(Hr = CCapDev::NonDelegatingQueryInterface(riid, ppv)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, WARN, "%s:   WARNING: NDQI for {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX} failed Hr=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], Hr));
        }
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX}*=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], *ppv));
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | ConnectToDriver | This method is used to
 *    open a WDM capture device, get its format capibilities, and set a default
 *    format.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 *
 *  @todo Verify error management
 ***************************************************************************/
HRESULT CWDMCapDev::ConnectToDriver()
{
        HRESULT Hr = NOERROR;
        KSP_PIN KsProperty;
        DWORD dwPinCount = 0UL;
        DWORD cbReturned;
        DWORD dwPinId;
        GUID guidCategory;

        FX_ENTRY("CWDMCapDev::ConnectToDriver")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Don't re-open the driver
        if (m_hDriver)
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Class driver already opened", _fx_));
                goto MyExit;
        }

        // Validate driver path
        if (lstrlen(g_aDeviceInfo[m_dwDeviceIndex].szDevicePath) == 0)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   Invalid driver path", _fx_));
                Hr = E_FAIL;
                goto MyError;
        }
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Using m_dwDeviceIndex %d", _fx_, m_dwDeviceIndex));
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Opening class driver '%s'", _fx_, g_aDeviceInfo[m_dwDeviceIndex].szDevicePath));

        // All we care is to wet the hInheritHanle = TRUE;
        SECURITY_ATTRIBUTES SecurityAttributes;
        SecurityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);  // use pointers
        SecurityAttributes.bInheritHandle = TRUE;
        SecurityAttributes.lpSecurityDescriptor = NULL; // GetInitializedSecurityDescriptor();

        // Really open the driver
        if ((m_hDriver = CreateFile(g_aDeviceInfo[m_dwDeviceIndex].szDevicePath, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, &SecurityAttributes, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL)) == INVALID_HANDLE_VALUE)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   CreateFile failed with Path=%s GetLastError()=%d", _fx_, g_aDeviceInfo[m_dwDeviceIndex].szDevicePath, GetLastError()));
                m_hDriver = NULL;
                Hr = E_FAIL;
                goto MyError;
        }

        // Get the number of pins
        KsProperty.PinId                        = 0;
        KsProperty.Reserved                     = 0;
        KsProperty.Property.Set         = KSPROPSETID_Pin;
        KsProperty.Property.Id          = KSPROPERTY_PIN_CTYPES;
        KsProperty.Property.Flags       = KSPROPERTY_TYPE_GET;

        if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &KsProperty, sizeof(KsProperty), &dwPinCount, sizeof(dwPinCount), &cbReturned) == FALSE)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   Couldn't get the number of pins supported by the device", _fx_));
                Hr = E_FAIL;
                goto MyError;
        }
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Number of pins: %ld", _fx_, dwPinCount));
        }

        // Look for the capture, preview and RTP pins
        // Get the properties of each pin
    for (dwPinId = 0; dwPinId < dwPinCount; dwPinId++)
        {
                // Get the pin category
                KsProperty.PinId                        = dwPinId;
                KsProperty.Reserved                     = 0;
                KsProperty.Property.Set         = KSPROPSETID_Pin;
                KsProperty.Property.Id          = KSPROPERTY_PIN_CATEGORY;
                KsProperty.Property.Flags       = KSPROPERTY_TYPE_GET;

                if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &KsProperty, sizeof(KsProperty), &guidCategory, sizeof(guidCategory), &cbReturned) == FALSE)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Couldn't get the GUID category", _fx_));
                }
                else
                {
                        if (guidCategory == PINNAME_VIDEO_PREVIEW)
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Found a PINNAME_VIDEO_PREVIEW pin. Id=#%ld", _fx_, dwPinId));
                                m_dwPreviewPinId = dwPinId;
                        }
                        else if (guidCategory == PINNAME_VIDEO_CAPTURE)
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Found a PINNAME_VIDEO_CAPTURE pin. Id=#%ld", _fx_, dwPinId));
                                m_dwCapturePinId = dwPinId;
                        }
                        else
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: Pin has unknown GUID category", _fx_));
                        }
                }
        }

        // If there is no capture or preview pin, just bail
        if ((m_dwPreviewPinId == INVALID_PIN_ID) && (m_dwCapturePinId == INVALID_PIN_ID))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: No capture of preview pin supported by this device. Just bail", _fx_));
                Hr = E_FAIL;
                goto MyError;
        }

#if defined(DUMP_DRIVER_CHARACTERISTICS) && defined(DEBUG)
        GetDriverDetails();
#endif

        // If there is no valid data range, we cannot stream
        if (!CreateDriverSupportedDataRanges())
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: No capture of preview pin supported by this device. Just bail", _fx_));
                Hr = E_FAIL;
                goto MyError;
        }

        // Load KSUSER.DLL and get a proc address
        if (!(m_hKsUserDLL = LoadLibrary("KSUSER")))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: KsUser.dll load failed!", _fx_));
                Hr = E_FAIL;
                goto MyError;
        }
        if (!(m_pKsCreatePin = (LPFNKSCREATEPIN)GetProcAddress(m_hKsUserDLL, "KsCreatePin")))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: Couldn't find KsCreatePin on KsUser.dll!", _fx_));
                Hr = E_FAIL;
                goto MyError;
        }

        // Get the formats from the registry - if this fail we'll profile the device
        if (FAILED(Hr = GetFormatsFromRegistry()))
        {
                if (FAILED(Hr = ProfileCaptureDevice()))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: ProfileCaptureDevice failed!", _fx_));
                        Hr = VFW_E_NO_CAPTURE_HARDWARE;
                        goto MyExit;
                }
#ifdef DEVICEW_DEBUG
                else    dout(3, g_dwVideoCaptureTraceID, TRCE,"%s:    ProfileCaptureDevice", _fx_);
#endif
        }
#ifdef DEVICEW_DEBUG
        else    dout(3, g_dwVideoCaptureTraceID, TRCE,"%s:    GetFormatsFromRegistry", _fx_);

        dump_video_format_image_size(m_dwImageSize);
        dump_video_format_num_colors(m_dwFormat);
#endif

        goto MyExit;

MyError:
        DisconnectFromDriver();
MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | DisconnectFromDriver | This method is used to
 *    release the capture device.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CWDMCapDev::DisconnectFromDriver()
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CWDMCapDev::DisconnectFromDriver")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Close the underlying video kernel streaming pin
        if (m_hKSPin)
        {
                if (!(CloseHandle(m_hKSPin)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   CloseHandle(m_hKSPin=0x%08lX) failed with GetLastError()=0x%08lX", _fx_, m_hKSPin, GetLastError()));
                }

                m_hKSPin = NULL;
        }

        // Release kernel streaming DLL (KSUSER.DLL)
        if (m_hKsUserDLL)
                FreeLibrary(m_hKsUserDLL);

        // Close drivere handle
        if (m_hDriver && (m_hDriver != INVALID_HANDLE_VALUE))
        {
                if (!CloseHandle(m_hDriver))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   CloseHandle(m_hDriver=0x%08lX) failed with GetLastError()=0x%08lX", _fx_, m_hDriver, GetLastError()));
                }
        }
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Nothing to close", _fx_));
        }

        m_hDriver = NULL;

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | ProfileCaptureDevice | This method is used to
 *    determine the list of formats supported by a WDM capture device.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_UNEXPECTED | Unrecoverable error
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CWDMCapDev::ProfileCaptureDevice()
{
        FX_ENTRY("CWDMCapDev::ProfileCaptureDevice")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // We'll always provide a source dialog for WDM devices in order to
        // make it easy for apps that don't want to call IAMVideoProcAmp. They
        // will still be able to allow users to mess with brigthness and other
        // video settings with this simulation of the VfW source dialog.
        m_dwDialogs = FORMAT_DLG_OFF | SOURCE_DLG_ON | DISPLAY_DLG_OFF;

        // Disable streaming of large size by default on WDM devices
        m_dwStreamingMode = FRAME_GRAB_LARGE_SIZE;

    // Let the base class complete the profiling
        return CCapDev::ProfileCaptureDevice();
}

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | SendFormatToDriver | This method is used to
 *    tell the VfW capture device what format to use.
 *
 *  @parm LONG | biWidth | Specifies the image width.
 *
 *  @parm LONG | biHeight | Specifies the image height.
 *
 *  @parm DWORD | biCompression | Specifies the format type.
 *
 *  @parm WORD | biBitCount | Specifies the number of bits per pixel.
 *
 *  @parm REFERENCE_TIME | AvgTimePerFrame | Specifies the frame rate.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CWDMCapDev::SendFormatToDriver(IN LONG biWidth, IN LONG biHeight, IN DWORD biCompression, IN WORD biBitCount, IN REFERENCE_TIME AvgTimePerFrame, BOOL fUseExactFormat)
{
        HRESULT Hr = NOERROR;
        BITMAPINFOHEADER bmih;
        int nFormat, nBestFormat;
        int     i, delta, best, tmp;
        DWORD dwPinId;
        BOOL fValidMatch;
        DATAPINCONNECT DataConnect;
        PKS_DATARANGE_VIDEO pSelDRVideo;
#ifdef DEBUG
        char szFourCC[5] = {0};
#endif
        DWORD dwErr;
        DWORD cb;

        FX_ENTRY("CWDMCapDev::SendFormatToDriver")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(m_pKsCreatePin);
        if (!m_pKsCreatePin)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid m_pKsCreatePin!", _fx_));
                Hr = E_UNEXPECTED;
                goto MyExit;
        }

        // @todo Fix units for fps
        dout(g_dbg_DeviceW_log,g_dwVideoCaptureTraceID, FAIL, "%s:   Trying to set %dx%d at %ld fps\n", _fx_, biWidth, biHeight, AvgTimePerFrame != 0 ? (LONG)(10000000 / AvgTimePerFrame) : 0);
        D(1) dprintf("W **** Initial arguments: biWidth = %ld, biHeight = %ld, biCompression = '%.4s', AvgTimePerFrame = %I64u\n", biWidth, biHeight, &biCompression, AvgTimePerFrame);
        // Common to all formats
        bmih.biSize = sizeof(BITMAPINFOHEADER);
        bmih.biPlanes = 1;
        bmih.biXPelsPerMeter = bmih.biYPelsPerMeter = bmih.biClrUsed = bmih.biClrImportant = 0;

        if (!fUseExactFormat)
        {
                D(1) dprintf("W Not using 'fUseExactFormat' .... m_dwFormat = 0x%08lx\n", m_dwFormat);
                D(1) dprintf("W Looking for 4cc %lX : '%.4s'\n", biCompression, &biCompression);
                // Can we directly capture data in this format?
                for (nFormat=0, nBestFormat=-1; nFormat<NUM_BITDEPTH_ENTRIES; nFormat++)
                {
                        // Try a format supported by the device
                        if (aiFormat[nFormat] & m_dwFormat)
                        {
                                // Remember the device supports this format
                                if (nBestFormat == -1)
                                        nBestFormat = nFormat;

                                // Is this the format we're being asked to use?
                                if (aiFourCCCode[nFormat] == biCompression) {
                                        D(1) dprintf("W aiFourCCCode[nFormat] = %lX : '%.4s'\n", aiFourCCCode[nFormat], &aiFourCCCode[nFormat]); // aiFourCCCode[nFormat] & 0xff, (aiFourCCCode[nFormat]>>8) & 0xff, (aiFourCCCode[nFormat]>>16) & 0xff, (aiFourCCCode[nFormat]>>24) & 0xff);
                                        break;
                                }
                        }
                }

                // If we found a match, use this format. Otherwise, pick
                // whatever else this device can do
                if (nFormat == NUM_BITDEPTH_ENTRIES)
                {
                        nFormat = nBestFormat;
                }
                D(1) dprintf("W nFormat = %d\n", nFormat);

                bmih.biBitCount = aiBitDepth[nFormat];
                bmih.biCompression = aiFourCCCode[nFormat];

                // Find the best image size to capture at
                // Assume the next resolution will be correctly truncated to the output size
                best = -1;
                delta = 999999;
                D(1) dprintf("W biWidth, biHeight = %ld, %ld\n",biWidth, biHeight);
                for (i=0; i<VIDEO_FORMAT_NUM_RESOLUTIONS; i++)
                {
                        if (awResolutions[i].dwRes & m_dwImageSize)
                        {
                                //dprintf("Trying awResolutions[%d].dwRes = %lu (%ld,%ld)\n", i, awResolutions[i].dwRes, awResolutions[i].framesize.cx, awResolutions[i].framesize.cy);
                                tmp = awResolutions[i].framesize.cx - biWidth;
                                if (tmp < 0) tmp = -tmp;
                                if (tmp < delta)
                                {       //dprintf("\t... X. i=%d : delta, tmp =  %ld, %ld\n", i, delta, tmp);
                                        delta = tmp;
                                        best = i;
                                }
                                tmp = awResolutions[i].framesize.cy - biHeight;
                                if (tmp < 0) tmp = -tmp;
                                if (tmp < delta)
                                {       //dprintf("\t... Y. i=%d : delta, tmp =  %ld, %ld\n", i, delta, tmp);
                                        delta = tmp;
                                        best = i;
                                }
                        }
                }

                if (best < 0)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Can't find appropriate format!", _fx_));
                        Hr = E_FAIL;
                        goto MyExit;
                }

                bmih.biWidth = awResolutions[best].framesize.cx;
                bmih.biHeight = awResolutions[best].framesize.cy;
        }
        else
        {
                bmih.biBitCount = biBitCount;
                bmih.biCompression = biCompression;
                bmih.biWidth = biWidth;
                bmih.biHeight = biHeight;
        }

#ifdef DEVICEW_DEBUG
        dprintf("W 4CC used = %lX : '%.4s'\n", bmih.biCompression, &bmih.biCompression); // aiFourCCCode[nFormat] & 0xff, (aiFourCCCode[nFormat]>>8) & 0xff, (aiFourCCCode[nFormat]>>16) & 0xff, (aiFourCCCode[nFormat]>>24) & 0xff);
        g_dbg_4cc=bmih.biCompression;
        g_dbg_bc =bmih.biBitCount;
        g_dbg_w  =bmih.biWidth;
        g_dbg_h = bmih.biHeight;
#endif
        bmih.biSizeImage = DIBSIZE(bmih);

        // @todo Copy the palette if there is one

        // Update last format fields
        if (biCompression == BI_RGB)
        {
                if (biBitCount == 4)
                {
                        bmih.biClrUsed = 16;
                        bmih.biClrImportant = 16;
                }
                else if (biBitCount == 8)
                {
                        bmih.biClrUsed = 256;
                        bmih.biClrImportant = 256;
                }
        }

        // Get a PinId from the driver
        D(1) dprintf("W ---------- m_dwCapturePinId = 0x%08lx\n", m_dwCapturePinId);
        if (m_dwCapturePinId != INVALID_PIN_ID)
        {
                dwPinId = m_dwCapturePinId;
        }
        else
        {
                if (m_dwPreviewPinId != INVALID_PIN_ID)
                {
                        dwPinId = m_dwPreviewPinId;
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Can't find appropriate pin to open!", _fx_));
                        Hr = E_FAIL;
                        goto MyExit;
                }
        }

        dprintf("W >>>>>> Asking for: (bmih.) biWidth = %ld, biHeight = %ld, biCompression = '%.4s'\n", bmih.biWidth, bmih.biHeight, &bmih.biCompression);

        // We need to find a video data range that matches the bitmap info header passed in
        fValidMatch = FALSE;
        if (FAILED(Hr = FindMatchDataRangeVideo(&bmih, (DWORD)AvgTimePerFrame, &fValidMatch, &pSelDRVideo)) || !fValidMatch)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Can't open pin with this format!", _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

        // Allocate space for a videoinfo that will hold it
        if (m_pCaptureFilter->m_user.pvi)
                delete m_pCaptureFilter->m_user.pvi, m_pCaptureFilter->m_user.pvi = NULL;

        cb = sizeof(VIDEOINFOHEADER) + pSelDRVideo->VideoInfoHeader.bmiHeader.biSize - sizeof(BITMAPINFOHEADER);
        if (pSelDRVideo->VideoInfoHeader.bmiHeader.biBitCount == 8 && pSelDRVideo->VideoInfoHeader.bmiHeader.biCompression == BI_RGB)
                cb += sizeof(RGBQUAD) * 256;    // space for PALETTE or BITFIELDS
        else if (pSelDRVideo->VideoInfoHeader.bmiHeader.biBitCount == 4 && pSelDRVideo->VideoInfoHeader.bmiHeader.biCompression == BI_RGB)
                cb += sizeof(RGBQUAD) * 16;         // space for PALETTE or BITFIELDS
        if (!(m_pCaptureFilter->m_user.pvi = (VIDEOINFOHEADER *)(new BYTE[cb])))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory!", _fx_));
                Hr = E_OUTOFMEMORY;
                goto MyExit;
        }

        // Copy the default format
        CopyMemory(m_pCaptureFilter->m_user.pvi, &pSelDRVideo->VideoInfoHeader, cb);
        D(1) dprintf("- - - - Init m_pCaptureFilter->m_user.pvi ... CWDMCapDev this = %p , m_pCaptureFilter = %p\n",this,m_pCaptureFilter);
        D(1) DumpVIH(m_pCaptureFilter->m_user.pvi);

        D(1) dprintf("**** m_pCaptureFilter->m_user.pvi->AvgTimePerFrame                   = %I64u (from pSelDRVideo->VideoInfoHeader)\n",                m_pCaptureFilter->m_user.pvi->AvgTimePerFrame);
#ifdef DEVICEW_DEBUG
        D(1)
        {
            if(m_pCaptureFilter->m_pCapturePin!=NULL)
                    D(1) dprintf("**** m_pCaptureFilter->m_pCapturePin->m_lAvgTimePerFrameRangeDefault = %lu (is this just a DWORD ?!!!?) \n",                        m_pCaptureFilter->m_pCapturePin->m_lAvgTimePerFrameRangeDefault);
            else {
                    D(1) dprintf("**** m_pCaptureFilter->m_pCapturePin == NULL ! ! ! ! !\a\n");
                    D(2) DebugBreak();
            }
        }
#endif
        // Fix broken bitmap info headers
        if (HEADER(m_pCaptureFilter->m_user.pvi)->biSizeImage == 0 && (HEADER(m_pCaptureFilter->m_user.pvi)->biCompression == BI_RGB || HEADER(m_pCaptureFilter->m_user.pvi)->biCompression == BI_BITFIELDS))
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   WARNING: Fixing broken bitmap info header!", _fx_));
                HEADER(m_pCaptureFilter->m_user.pvi)->biSizeImage = DIBSIZE(*HEADER(m_pCaptureFilter->m_user.pvi));
        }
        if (HEADER(m_pCaptureFilter->m_user.pvi)->biCompression == VIDEO_FORMAT_YVU9 && HEADER(m_pCaptureFilter->m_user.pvi)->biBitCount != 9)
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   WARNING: Fixing broken bitmap info header!", _fx_));
                HEADER(m_pCaptureFilter->m_user.pvi)->biBitCount = 9;
                HEADER(m_pCaptureFilter->m_user.pvi)->biSizeImage = DIBSIZE(*HEADER(m_pCaptureFilter->m_user.pvi));
        }
        if (HEADER(m_pCaptureFilter->m_user.pvi)->biBitCount > 8 && HEADER(m_pCaptureFilter->m_user.pvi)->biClrUsed != 0)
        {
                // BOGUS cap is broken and doesn't reset num colours
                // WINNOV reports 256 colours of 24 bit YUV8 - scary!
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   WARNING: Fixing broken bitmap info header!", _fx_));
                HEADER(m_pCaptureFilter->m_user.pvi)->biClrUsed = 0;
        }

        // If we already have a pin, nuke it
        if (m_hKSPin)
                CloseHandle(m_hKSPin), m_hKSPin = NULL;

        // Connect to a new kernel streaming PIN.
        ZeroMemory(&DataConnect, sizeof(DATAPINCONNECT));
        DataConnect.Connect.PinId                                               = dwPinId;
        DataConnect.Connect.PinToHandle                                 = NULL;                                                         // no "connect to"
        DataConnect.Connect.Interface.Set                               = KSINTERFACESETID_Standard;
        DataConnect.Connect.Interface.Id                                = KSINTERFACE_STANDARD_STREAMING;       // STREAMING
        DataConnect.Connect.Medium.Set                                  = KSMEDIUMSETID_Standard;
        DataConnect.Connect.Medium.Id                                   = KSMEDIUM_STANDARD_DEVIO;
        DataConnect.Connect.Priority.PriorityClass              = KSPRIORITY_NORMAL;
        DataConnect.Connect.Priority.PrioritySubClass   = 1;

        // @todo Allocate size for DATAPINCONNECT dynamically
        //dout("%s:   pSelDRVideo->DataRange.FormatSize = %lx \nsizeof(KS_DATARANGE_VIDEO_PALETTE) = %lx \nsizeof(KS_VIDEOINFO) = %lx \nsizeof(KS_DATAFORMAT_VIDEOINFO_PALETTE) = %lx\n",
        //        _fx_, pSelDRVideo->DataRange.FormatSize,sizeof(KS_DATARANGE_VIDEO_PALETTE),sizeof(KS_VIDEOINFO),sizeof(KS_DATAFORMAT_VIDEOINFO_PALETTE));
        ASSERT((pSelDRVideo->DataRange.FormatSize - (sizeof(KS_DATARANGE_VIDEO_PALETTE) - sizeof(KS_VIDEOINFO))) <= sizeof(KS_DATAFORMAT_VIDEOINFO_PALETTE));
        CopyMemory(&DataConnect.Data.DataFormat, &pSelDRVideo->DataRange, sizeof(KSDATARANGE));
        //dout("%s:   ##############::::::::: count bytes to copy: %ld\n", _fx_, pSelDRVideo->DataRange.FormatSize - (sizeof(KS_DATARANGE_VIDEO_PALETTE) - sizeof(KS_VIDEOINFO)));
        CopyMemory(&DataConnect.Data.VideoInfo, &pSelDRVideo->VideoInfoHeader, pSelDRVideo->DataRange.FormatSize - (sizeof(KS_DATARANGE_VIDEO_PALETTE) - sizeof(KS_VIDEOINFO)));
        DataConnect.Data.DataFormat.FormatSize = sizeof(KSDATARANGE) + pSelDRVideo->DataRange.FormatSize - (sizeof(KS_DATARANGE_VIDEO_PALETTE) - sizeof(KS_VIDEOINFO));
        //dout("%s:   DataConnect.Data.DataFormat.FormatSize = %lx\n", _fx_, DataConnect.Data.DataFormat.FormatSize);
        D(1) dprintf("DataConnect structure at %p\n",&DataConnect);
        D(1) DumpVIH((VIDEOINFOHEADER *)&DataConnect.Data.VideoInfo);
        D(1) DumpBMIH((PBITMAPINFOHEADER)&(((VIDEOINFOHEADER *)&DataConnect.Data.VideoInfo)->bmiHeader));

        D(1) dprintf("*********** initial bmih..... *****************\n");
        D(1) DumpBMIH(&bmih);

        // Adjust the image sizes if necessary
        if (fValidMatch)
        {
                DataConnect.Data.VideoInfo.bmiHeader.biWidth            = bmih.biWidth;
                DataConnect.Data.VideoInfo.bmiHeader.biHeight           = abs(bmih.biHeight); // Support only +biHeight!
                // The Kodak DVC 323 returns a bogus value for the image size
                // in YVU9 mode and won't work with the correct value... so leave
                // it that way.
                // DataConnect.Data.VideoInfo.bmiHeader.biSizeImage     = bmih.biSizeImage;
                m_pCaptureFilter->m_user.pvi->bmiHeader.biWidth     = bmih.biWidth;
                m_pCaptureFilter->m_user.pvi->bmiHeader.biHeight    = abs(bmih.biHeight);
                m_pCaptureFilter->m_user.pvi->bmiHeader.biSizeImage = bmih.biSizeImage;
                dprintf("W > > > > Adjusted : (bmih.) biWidth = %ld, biHeight = %ld, biCompression = '%.4s'\n", bmih.biWidth, bmih.biHeight, &bmih.biCompression);
        }
        // @todo Read this from somewhere
        if (m_pCaptureFilter->m_pCapturePin && m_pCaptureFilter->m_pCapturePin->m_lAvgTimePerFrameRangeDefault) {
                //dprintf("... %s: :max of next 2:\n\t\tDataConnect.Data.VideoInfo.AvgTimePerFrame = %I64u\t\n\nm_pCaptureFilter->m_pCapturePin->m_lAvgTimePerFrameRangeDefault = %lu\n",
                //        _fx_, DataConnect.Data.VideoInfo.AvgTimePerFrame,m_pCaptureFilter->m_pCapturePin->m_lAvgTimePerFrameRangeDefault);

                //** AvgTimePerFrame = max(DataConnect.Data.VideoInfo.AvgTimePerFrame, m_pCaptureFilter->m_pCapturePin->m_lAvgTimePerFrameRangeDefault);

                AvgTimePerFrame = max(DataConnect.Data.VideoInfo.AvgTimePerFrame, AvgTimePerFrame);

                if(AvgTimePerFrame > pSelDRVideo->ConfigCaps.MaxFrameInterval)
                                AvgTimePerFrame = pSelDRVideo->ConfigCaps.MaxFrameInterval;
                if(AvgTimePerFrame < pSelDRVideo->ConfigCaps.MinFrameInterval)
                                AvgTimePerFrame = pSelDRVideo->ConfigCaps.MinFrameInterval;
                m_pCaptureFilter->m_user.pvi->AvgTimePerFrame = DataConnect.Data.VideoInfo.AvgTimePerFrame
                                 = AvgTimePerFrame;
                D(1) dprintf(".... %s:result is     : m_pCaptureFilter->m_user.pvi->AvgTimePerFrame = DataConnect.Data.VideoInfo.AvgTimePerFrame =\n\t\t\t\t\t%I64u\n",        _fx_, DataConnect.Data.VideoInfo.AvgTimePerFrame);
        }
        //if(DataConnect.Data.VideoInfo.AvgTimePerFrame >= 1666665) DebugBreak();
#ifdef DEBUG
    *((DWORD*)&szFourCC) = DataConnect.Data.VideoInfo.bmiHeader.biCompression;
        if (m_pCaptureFilter->m_pCapturePin && m_pCaptureFilter->m_pCapturePin->m_lAvgTimePerFrameRangeDefault)
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Requesting format FourCC(%.4s) %d * %d pixels, %d bytes per frame, %ld.%ldfps",
                        _fx_, szFourCC, DataConnect.Data.VideoInfo.bmiHeader.biWidth, DataConnect.Data.VideoInfo.bmiHeader.biHeight,
                        DataConnect.Data.VideoInfo.bmiHeader.biSizeImage,
                        10000000/m_pCaptureFilter->m_pCapturePin->m_lAvgTimePerFrameRangeDefault,
                        1000000000/m_pCaptureFilter->m_pCapturePin->m_lAvgTimePerFrameRangeDefault
                                - (10000000/m_pCaptureFilter->m_pCapturePin->m_lAvgTimePerFrameRangeDefault) * 100));
        else
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Requesting format FourCC(%.4s) %d * %d pixels, %d bytes per frame, 0fps", _fx_, szFourCC, DataConnect.Data.VideoInfo.bmiHeader.biWidth, DataConnect.Data.VideoInfo.bmiHeader.biHeight, DataConnect.Data.VideoInfo.bmiHeader.biSizeImage));
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   m_hKSPin was=0x%08lX...", _fx_, m_hKSPin));
#endif

        dwErr = (*m_pKsCreatePin)(m_hDriver, (PKSPIN_CONNECT)&DataConnect, GENERIC_READ | GENERIC_WRITE, &m_hKSPin);

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   ...m_hKSPin is now=0x%08lX", _fx_, m_hKSPin));

        if (dwErr || (m_hKSPin == NULL))
        {
        // dwErr is an NtCreateFile error
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   ERROR: KsCreatePin returned 0x%08lX failure and m_hKSPin=0x%08lX", _fx_, dwErr, m_hKSPin));

                if (m_hKSPin == INVALID_HANDLE_VALUE)
                {
                        m_hKSPin = NULL;
                }

        // return error
        Hr = E_FAIL;

                goto MyExit;
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: Setting %dx%d at %ld fps", _fx_, biWidth, biHeight, (LONG)AvgTimePerFrame));

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | GetFormatFromDriver | This method is used to
 *    retrieve the WDM capture device format in use.
 *
 *  @parm VIDEOINFOHEADER ** | ppvi | Specifies the address of a pointer to
 *    a video info header structure to receive the video format description.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CWDMCapDev::GetFormatFromDriver(VIDEOINFOHEADER **ppvi)
{
        HRESULT                         Hr = NOERROR;
        UINT                            cb;
        BOOL                            fValidMatch;
        PKS_DATARANGE_VIDEO pSelDRVideo;

        FX_ENTRY("CWDMCapDev::GetFormatFromDriver")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(ppvi);
        if (!ppvi)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid input parameter!", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }

        if (m_pCaptureFilter->m_user.pvi)
        {
                // Allocate space for a videoinfo that will hold it
                cb = sizeof(VIDEOINFOHEADER) + HEADER(m_pCaptureFilter->m_user.pvi)->biSize - sizeof(BITMAPINFOHEADER);
                if (HEADER(m_pCaptureFilter->m_user.pvi)->biBitCount == 8 && HEADER(m_pCaptureFilter->m_user.pvi)->biCompression == BI_RGB)
                        cb += sizeof(RGBQUAD) * 256;    // space for PALETTE or BITFIELDS
                else if (HEADER(m_pCaptureFilter->m_user.pvi)->biBitCount == 4 && HEADER(m_pCaptureFilter->m_user.pvi)->biCompression == BI_RGB)
                        cb += sizeof(RGBQUAD) * 16;         // space for PALETTE or BITFIELDS
                if (!(*ppvi = (VIDEOINFOHEADER *)(new BYTE[cb])))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory!", _fx_));
                        Hr = E_OUTOFMEMORY;
                        goto MyExit;
                }

                // Copy the current format
                CopyMemory(*ppvi, m_pCaptureFilter->m_user.pvi, cb);
                D(1) dprintf("W existing from m_pCaptureFilter->m_user.pvi:\n");
                D(1) DumpVIH(*ppvi);
        }
        else
        {
                // Get the default format from the driver
                if (FAILED(Hr = FindMatchDataRangeVideo(NULL, 0L, &fValidMatch, &pSelDRVideo)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: FindMatchDataRangeVideo failed!", _fx_));
                        goto MyExit;
                }

                // Allocate space for a videoinfo that will hold it
                cb = sizeof(VIDEOINFOHEADER) + pSelDRVideo->VideoInfoHeader.bmiHeader.biSize - sizeof(BITMAPINFOHEADER);
                if (pSelDRVideo->VideoInfoHeader.bmiHeader.biBitCount == 8 && pSelDRVideo->VideoInfoHeader.bmiHeader.biCompression == BI_RGB)
                        cb += sizeof(RGBQUAD) * 256;    // space for PALETTE or BITFIELDS
                else if (pSelDRVideo->VideoInfoHeader.bmiHeader.biBitCount == 4 && pSelDRVideo->VideoInfoHeader.bmiHeader.biCompression == BI_RGB)
                        cb += sizeof(RGBQUAD) * 16;     // space for PALETTE or BITFIELDS
                if (!(*ppvi = (VIDEOINFOHEADER *)(new BYTE[cb])))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory!", _fx_));
                        Hr = E_OUTOFMEMORY;
                        goto MyExit;
                }

                // Copy the default foramt
                CopyMemory(*ppvi, &pSelDRVideo->VideoInfoHeader, cb);
#ifdef DEVICEW_DEBUG
                {
                    PBITMAPINFOHEADER pbInfo;
                    D(1) dprintf("W FindMatchDataRangeVideo:\n");
                    D(1) DumpVIH(*ppvi);
                    D(1) pbInfo = &((*ppvi)->bmiHeader);
                    D(1) dprintf("%s :\n", _fx_);
                    D(1) dumpfield(BITMAPINFOHEADER,pbInfo, biHeight,      "%ld");
                    D(1) dprintf("\t+0x%03x %-17s : %08x '%.4s'\n", FIELDOFFSET(BITMAPINFOHEADER, biCompression), "biCompression", (pbInfo)->biCompression, &((pbInfo)->biCompression));
                    D(1) ASSERT(pbInfo->biHeight > 0);
                }
#endif
                // Fix broken bitmap info headers
                if ((*ppvi)->bmiHeader.biSizeImage == 0 && ((*ppvi)->bmiHeader.biCompression == BI_RGB || (*ppvi)->bmiHeader.biCompression == BI_BITFIELDS))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   WARNING: Fixing broken bitmap info header!", _fx_));
                        (*ppvi)->bmiHeader.biSizeImage = DIBSIZE((*ppvi)->bmiHeader);
                }
                if ((*ppvi)->bmiHeader.biCompression == VIDEO_FORMAT_YVU9 && (*ppvi)->bmiHeader.biBitCount != 9)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   WARNING: Fixing broken bitmap info header!", _fx_));
                        (*ppvi)->bmiHeader.biBitCount = 9;
                        (*ppvi)->bmiHeader.biSizeImage = DIBSIZE((*ppvi)->bmiHeader);
                }
                if ((*ppvi)->bmiHeader.biBitCount > 8 && (*ppvi)->bmiHeader.biClrUsed != 0)
                {
                        // BOGUS cap is broken and doesn't reset num colours
                        // WINNOV reports 256 colours of 24 bit YUV8 - scary!
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   WARNING: Fixing broken bitmap info header!", _fx_));
                        (*ppvi)->bmiHeader.biClrUsed = 0;
                }
        }


MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | InitializeStreaming | This method is used to
 *    initialize a WDM capture device for streaming.
 *
 *  @parm DWORD | usPerFrame | Specifies the frame rate to be used.
 *
 *  @parm DWORD_PTR | hEvtBufferDone | Specifies a handle to the event to be
 *    signaled whenever a frame is available.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CWDMCapDev::InitializeStreaming(DWORD usPerFrame, DWORD_PTR hEvtBufferDone)
{
        HRESULT Hr = NOERROR;
    ULONG       i;

        FX_ENTRY("CWDMCapDev::InitializeStreaming")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Initialize data memmbers
        if (!m_dwStreamingMode || (m_dwStreamingMode == FRAME_GRAB_LARGE_SIZE && m_pCaptureFilter->m_user.pvi->bmiHeader.biHeight < 240 && m_pCaptureFilter->m_user.pvi->bmiHeader.biWidth < 320))
        {
                // Validate input parameters
                ASSERT(hEvtBufferDone);
                if (!hEvtBufferDone)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid hEvtBufferDone!", _fx_));
                        Hr = E_INVALIDARG;
                        goto MyExit;
                }

                m_fVideoOpen            = TRUE;
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: Creating %d read video buffers", _fx_, m_cntNumVidBuf));

        if (m_pWDMVideoBuff) delete [] m_pWDMVideoBuff;

                if (!(m_pWDMVideoBuff = (WDMVIDEOBUFF *) new WDMVIDEOBUFF[m_cntNumVidBuf]))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: m_pWDMVideoBuff allocation failed!", _fx_));
                        Hr = E_OUTOFMEMORY;
                        goto MyError;
                }

                for(i=0; i<m_cntNumVidBuf; i++)
                {
                        // Create the overlapped structures
                        ZeroMemory(&(m_pWDMVideoBuff[i].Overlap), sizeof(OVERLAPPED));
                        m_pWDMVideoBuff[i].Overlap.hEvent = (HANDLE)hEvtBufferDone;
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: Event %d is handle 0x%08lX", _fx_, i, m_pWDMVideoBuff[i].Overlap.hEvent));
                }
        }

        goto MyExit;

MyError:
        m_fVideoOpen = FALSE;
MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc LPVIDEOHDR | CWDMCapDev | DeQueueHeader | This function dequeues a
 *    video buffer from the list of video buffers used for streaming.
 *
 *  @rdesc Returns a valid pointer if successful, or NULL otherwise.
 ***************************************************************************/
LPVIDEOHDR CWDMCapDev::DeQueueHeader()
{
    LPVIDEOHDR lpVHdr;

        FX_ENTRY("CWDMCapDev::DeQueueHeader");

    lpVHdr = m_lpVHdrFirst;

    if (lpVHdr)
        {
        lpVHdr->dwFlags &= ~VHDR_INQUEUE;

        m_lpVHdrFirst = (LPVIDEOHDR)(lpVHdr->dwReserved[0]);

        if (m_lpVHdrFirst == NULL)
            m_lpVHdrLast = NULL;
    }

    return lpVHdr;
}

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc void | CWDMCapDev | QueueHeader | This function actually adds the
 *    video buffer to the list of video buffers used for streaming.
 *
 *  @parm LPVIDEOHDR | lpVHdr | Pointer to a <t VIDEOHDR> structure describing
 *    a video buffer to add to the list of streaming buffers.
 ***************************************************************************/
void CWDMCapDev::QueueHeader(LPVIDEOHDR lpVHdr)
{
        FX_ENTRY("CWDMCapDev::QueueHeader");
        // Initialize status flags
    lpVHdr->dwFlags &= ~VHDR_DONE;
    lpVHdr->dwFlags |= VHDR_INQUEUE;
    lpVHdr->dwBytesUsed = 0;

        *(lpVHdr->dwReserved) = NULL;

        if (m_lpVHdrLast)
                *(m_lpVHdrLast->dwReserved) = (DWORD)(LPVOID)lpVHdr;
        else
                m_lpVHdrFirst = lpVHdr;

        m_lpVHdrLast = lpVHdr;
}

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc BOOL | CWDMCapDev | QueueRead | This function queues a read
 *    operation on a video streaming pin.
 *
 *  @parm DWORD | dwIndex | Index of the video structure in read buffer.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMCapDev::QueueRead(DWORD dwIndex)
{
        FX_ENTRY("CWDMCapDev::QueueRead");

        DWORD cbReturned;
        BOOL  bShouldBlock = FALSE;
#if defined(DEBUG) && defined(DEBUG_STREAMING)
        // @todo Remove this before checkin!
        char szDebug[512];
#endif

        //DBGOUT((g_dwVideoCaptureTraceID, TRCE, TEXT("%s: Queue read buffer %d on pin handle 0x%08lX"), _fx_, dwIndex, m_hKSPin));

        // Get a buffer from the queue of video buffers
        m_pWDMVideoBuff[dwIndex].pVideoHdr = DeQueueHeader();
#if defined(DEBUG) && defined(DEBUG_STREAMING)
        wsprintf(szDebug, "Queueing m_pWDMVideoBuff[%ld].pVideoHdr=0x%08lX\n", dwIndex, m_pWDMVideoBuff[dwIndex].pVideoHdr);
        OutputDebugString(szDebug);
#endif

        if (m_pWDMVideoBuff[dwIndex].pVideoHdr)
        {
                ZeroMemory(&m_pWDMVideoBuff[dwIndex].SHGetImage, sizeof(m_pWDMVideoBuff[dwIndex].SHGetImage));
                m_pWDMVideoBuff[dwIndex].SHGetImage.StreamHeader.Size                   = sizeof (KS_HEADER_AND_INFO);
                m_pWDMVideoBuff[dwIndex].SHGetImage.FrameInfo.ExtendedHeaderSize        = sizeof (KS_FRAME_INFO);
                m_pWDMVideoBuff[dwIndex].SHGetImage.StreamHeader.Data                   = m_pWDMVideoBuff[dwIndex].pVideoHdr->lpData;
                m_pWDMVideoBuff[dwIndex].SHGetImage.StreamHeader.FrameExtent            = m_pWDMVideoBuff[dwIndex].pVideoHdr->dwBufferLength;

                // Submit the read
                BOOL bRet = ::DeviceIoControl(m_hKSPin, IOCTL_KS_READ_STREAM,  &m_pWDMVideoBuff[dwIndex].SHGetImage,
                                                                                sizeof(m_pWDMVideoBuff[dwIndex].SHGetImage),
                                                                               &m_pWDMVideoBuff[dwIndex].SHGetImage,
                                                                                sizeof(m_pWDMVideoBuff[dwIndex].SHGetImage),
                                                                               &cbReturned,
                                                                               &m_pWDMVideoBuff[dwIndex].Overlap);

                if (!bRet)
                {
                        DWORD dwErr = GetLastError();
                        switch(dwErr)
                        {
                                case ERROR_IO_PENDING:
                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: An overlapped IO is going to take place", _fx_));
#if defined(DEBUG) && defined(DEBUG_STREAMING)
                                        OutputDebugString("An overlapped IO is going to take place\n");
#endif
                                        bShouldBlock = TRUE;
                                        break;

                                // Something bad happened
                                default:
                                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: DeviceIoControl() failed badly dwErr=%d", _fx_, dwErr));
#if defined(DEBUG) && defined(DEBUG_STREAMING)
                                        wsprintf(szDebug, "DeviceIoControl() failed badly dwErr=%d\n",dwErr);
                                        OutputDebugString(szDebug);
#endif
                                        break;
                        }
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: Overlapped IO won't take place - no need to wait", _fx_));
#if defined(DEBUG) && defined(DEBUG_STREAMING)
                        OutputDebugString("Overlapped IO won't take place - no need to wait\n");
#endif
                        SetEvent(m_pWDMVideoBuff[dwIndex].Overlap.hEvent);
                }
        }
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: We won't queue the read - no buffer available", _fx_));
#if defined(DEBUG) && defined(DEBUG_STREAMING)
                OutputDebugString("We won't queue the read - no buffer available\n");
#endif
        }

        m_pWDMVideoBuff[dwIndex].fBlocking = bShouldBlock;

        return bShouldBlock;
}

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | StartStreaming | This method is used to
 *    start streaming from a VfW capture device.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CWDMCapDev::StartStreaming()
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CWDMCapDev::StartStreaming")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        //LOG_MSG_VAL(_fx_,(DWORD)this,0,0);

        if (!m_dwStreamingMode || (m_dwStreamingMode == FRAME_GRAB_LARGE_SIZE && m_pCaptureFilter->m_user.pvi->bmiHeader.biHeight < 240 && m_pCaptureFilter->m_user.pvi->bmiHeader.biWidth < 320))
        {
                // Validate input parameters
                ASSERT(m_fVideoOpen);
                if (!m_fVideoOpen)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: InitializeStreaming() needs to be called first!", _fx_));
                        Hr = E_UNEXPECTED;
                        goto MyExit;
                }

                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: Streaming in %d video buffers", _fx_, m_cntNumVidBuf));

                // Put the pin in streaming mode
                if (!Start())
            {
                    DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Cannot set kernel streaming state to KSSTATE_RUN!", _fx_));
                    Hr = E_FAIL;
                    goto MyExit;
            }

                // Send the buffers to the driver
                for (DWORD i = 0; i < m_pCaptureFilter->m_cs.nHeaders; ++i)
                {
                        ASSERT (m_pCaptureFilter->m_cs.cbVidHdr >= sizeof(VIDEOHDR));
                        if (FAILED(AddBuffer(&m_pCaptureFilter->m_cs.paHdr[i].tvh.vh, m_pCaptureFilter->m_cs.cbVidHdr)))
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: AddBuffer failed", _fx_));
                                Hr = E_FAIL;
                                goto MyExit;
                        }
                }
        }
        //LOG_MSG_VAL(_fx_,(DWORD)this,0,1);

MyExit:
        //LOG_MSG_VAL(_fx_,(DWORD)this,0,0xffff);

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | StopStreaming | This method is used to
 *    stop streaming from a VfW capture device.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CWDMCapDev::StopStreaming()
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CWDMCapDev::StopStreaming")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        if (!m_dwStreamingMode || (m_dwStreamingMode == FRAME_GRAB_LARGE_SIZE && m_pCaptureFilter->m_user.pvi->bmiHeader.biHeight < 240 && m_pCaptureFilter->m_user.pvi->bmiHeader.biWidth < 320))
        {
                // Validate input parameters
                ASSERT(m_fVideoOpen);
                if (!m_fVideoOpen)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Stream is not even open!", _fx_));
                        Hr = E_UNEXPECTED;
                        goto MyExit;
                }
        }

        if (!Stop())
    {
            DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Cannot set kernel streaming state to KSSTATE_PAUSE/KSSTATE_STOP!", _fx_));
            Hr = E_FAIL;
    }





MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | TerminateStreaming | This method is used to
 *    tell a WDM capture device to terminate streaming.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CWDMCapDev::TerminateStreaming()
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CWDMCapDev::TerminateStreaming")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        //LOG_MSG_VAL(_fx_,(DWORD)this,0,0);

        if (!m_dwStreamingMode || (m_dwStreamingMode == FRAME_GRAB_LARGE_SIZE && m_pCaptureFilter->m_user.pvi->bmiHeader.biHeight < 240 && m_pCaptureFilter->m_user.pvi->bmiHeader.biWidth < 320))
        {
                // Validate input parameters
                ASSERT(m_fVideoOpen);
                if (!m_fVideoOpen)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Stream is not even open!", _fx_));
                        Hr = E_UNEXPECTED;
                        goto MyExit;
                }

                // Ask the pin to stop streaming.
                if (!Stop())
            {
                    DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Cannot set kernel streaming state to KSSTATE_PAUSE/KSSTATE_STOP!", _fx_));
                    Hr = E_FAIL;
                    goto MyExit;
            }

        CLEAR_GetOvResErr;

        DWORD dwNum;
        DWORD dwErr;

                for (UINT i=0; i<m_cntNumVidBuf; i++)
                {
                SET_GetOvResErr(i,0);
                SET_I(savi,i);
                if (m_pWDMVideoBuff!=NULL && m_pWDMVideoBuff[i].Overlap.hEvent)
                {
                        DWORD dwStartTime = timeGetTime();
                        SET_GetOvResErr(i,0x30787878);
                        //LOG_MSG_VAL(_fx_,(DWORD)this,i,0x10);

                        // we don't want to wait for the event, 'cause it has been shared.
                        while (!GetOverlappedResult (
                                m_hDriver,
                                &m_pWDMVideoBuff[i].Overlap,
                                &dwNum,
                                FALSE))
                              {
                                  dwErr = GetLastError ();
                                  SET_GetOvResErr(i,dwErr);

                                  if (dwErr == ERROR_OPERATION_ABORTED)
                                  {
                                      // expected
                                      break;
                                  }
                                  else if (dwErr == ERROR_IO_INCOMPLETE)
                                  {
                                      SleepEx (10, TRUE);
                                  }
                                  else if (dwErr == ERROR_IO_PENDING)
                                  {
                                      // should not happen
                                      DBGOUT((g_dwVideoCaptureTraceID, FAIL,
                                              "%s: failed to get overlapped result. error: io pending", _fx_));

                                      SleepEx (10, TRUE);
                                  }
                                  else
                                  {
                                      DBGOUT((g_dwVideoCaptureTraceID, FAIL,
                                              "%s: failed to get overlapped result. error: %d",
                                              _fx_, dwErr));

                                      SleepEx (10, TRUE);

                                      // should we break? [YES (cristiai; 09/15/2000; see bug 183855)]
                                      break;
                                  }

                                  // issue: this is a temporary solution to make sure we won't loop infinitely
                                  // we don't trust SDK documents all possible return values from
                                  // GetOverlappedResult
                                  //
                                  if (timeGetTime() - dwStartTime > 10000)
                                  {
                                          SET_GetOvResErr(i,0x31787878);
#if defined(DBG)
                                          DebugBreak();          // The driver has a problem.
#else
                                          break;
#endif
                                  }
                        }

                        // WaitForSingleObject (m_pWDMVideoBuff[i].Overlap.hEvent, INFINITE);
                                        SetEvent(m_pWDMVideoBuff[i].Overlap.hEvent);
                                        // CloseHandle(m_pWDMVideoBuff[i].Overlap.hEvent);
                                        m_pWDMVideoBuff[i].Overlap.hEvent = NULL;
                        }
                }

#if EARLYDELETE
        if (m_pWDMVideoBuff)
                {
                        delete []m_pWDMVideoBuff;
                        m_pWDMVideoBuff = (WDMVIDEOBUFF *)NULL;
                }
#endif

                //LOG_MSG_VAL("CWDMCapDev::TerminateStreaming m_lpVHdr... are made NULL",(DWORD)this,0,0);
                m_lpVHdrFirst = NULL;
                m_lpVHdrLast = NULL;
        }
        //LOG_MSG_VAL(_fx_,(DWORD)this,0,1);

MyExit:
        //LOG_MSG_VAL(_fx_,(DWORD)this,0,0xffff);

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

#if defined(DBG)
void DumpDataRangeVideo(PKS_DATARANGE_VIDEO     pDRVideo)
{
        FX_ENTRY("DumpDataRangeVideo");

        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_);

        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s: Video datarange pDRVideo %p:", _fx_, pDRVideo);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->DataRange.FormatSize=%ld", _fx_, pDRVideo->DataRange.FormatSize);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->DataRange.Flags=%ld", _fx_, pDRVideo->DataRange.Flags);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->DataRange.SampleSize=%ld", _fx_, pDRVideo->DataRange.SampleSize);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->DataRange.Reserved=%ld", _fx_, pDRVideo->DataRange.Reserved);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->DataRange.MajorFormat=0x%lX", _fx_, pDRVideo->DataRange.MajorFormat);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->DataRange.SubFormat=0x%lX", _fx_, pDRVideo->DataRange.SubFormat);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->DataRange.Specifier=KSDATAFORMAT_SPECIFIER_VIDEOINFO", _fx_);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->bFixedSizeSamples=%ld", _fx_, pDRVideo->bFixedSizeSamples);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->bTemporalCompression=%ld", _fx_, pDRVideo->bTemporalCompression);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->StreamDescriptionFlags=0x%lX", _fx_, pDRVideo->StreamDescriptionFlags);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->MemoryAllocationFlags=0x%lX", _fx_, pDRVideo->MemoryAllocationFlags);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.VideoStandard=KS_AnalogVideo_None", _fx_);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.InputSize(cx=%ld, cy=%ld)", _fx_, pDRVideo->ConfigCaps.InputSize.cx, pDRVideo->ConfigCaps.InputSize.cy);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.MinCroppingSize(cx=%ld, cy=%ld)", _fx_, pDRVideo->ConfigCaps.MinCroppingSize.cx, pDRVideo->ConfigCaps.MinCroppingSize.cy);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.MaxCroppingSize(cx=%ld, cy=%ld)", _fx_, pDRVideo->ConfigCaps.MaxCroppingSize.cx, pDRVideo->ConfigCaps.MaxCroppingSize.cy);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.CropGranularityX=%ld", _fx_, pDRVideo->ConfigCaps.CropGranularityY);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.CropGranularityY=%ld", _fx_, pDRVideo->ConfigCaps.CropGranularityY);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.CropAlignX=%ld", _fx_, pDRVideo->ConfigCaps.CropAlignX);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.CropAlignY=%ld", _fx_, pDRVideo->ConfigCaps.CropAlignY);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.MinOutputSize(cx=%ld, cy=%ld)", _fx_, pDRVideo->ConfigCaps.MinOutputSize.cx, pDRVideo->ConfigCaps.MinOutputSize.cy);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.MaxOutputSize(cx=%ld, cy=%ld)", _fx_, pDRVideo->ConfigCaps.MaxOutputSize.cx, pDRVideo->ConfigCaps.MaxOutputSize.cy);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.OutputGranularityX=%ld", _fx_, pDRVideo->ConfigCaps.OutputGranularityX);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.OutputGranularityY=%ld", _fx_, pDRVideo->ConfigCaps.OutputGranularityY);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.StretchTapsX=%ld", _fx_, pDRVideo->ConfigCaps.StretchTapsX);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.StretchTapsY=%ld", _fx_, pDRVideo->ConfigCaps.StretchTapsY);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.ShrinkTapsX=%ld", _fx_, pDRVideo->ConfigCaps.ShrinkTapsX);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.ShrinkTapsY=%ld", _fx_, pDRVideo->ConfigCaps.ShrinkTapsY);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.MinFrameInterval=%ld", _fx_, (DWORD)pDRVideo->ConfigCaps.MinFrameInterval);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.MaxFrameInterval=%ld", _fx_, (DWORD)pDRVideo->ConfigCaps.MaxFrameInterval);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.MinBitsPerSecond=%ld", _fx_, pDRVideo->ConfigCaps.MinBitsPerSecond);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.MaxBitsPerSecond=%ld", _fx_, pDRVideo->ConfigCaps.MaxBitsPerSecond);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->VideoInfoHeader.rcSource(left=%ld, top=%ld, right=%ld, bottom=%ld)", _fx_, pDRVideo->VideoInfoHeader.rcSource.left, pDRVideo->VideoInfoHeader.rcSource.top, pDRVideo->VideoInfoHeader.rcSource.right, pDRVideo->VideoInfoHeader.rcSource.bottom);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->VideoInfoHeader.rcTarget(left=%ld, top=%ld, right=%ld, bottom=%ld)", _fx_, pDRVideo->VideoInfoHeader.rcTarget.left, pDRVideo->VideoInfoHeader.rcTarget.top, pDRVideo->VideoInfoHeader.rcTarget.right, pDRVideo->VideoInfoHeader.rcTarget.bottom);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->VideoInfoHeader.dwBitRate=%ld", _fx_, pDRVideo->VideoInfoHeader.dwBitRate);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->VideoInfoHeader.dwBitErrorRate=%ld", _fx_, pDRVideo->VideoInfoHeader.dwBitErrorRate);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->VideoInfoHeader.AvgTimePerFrame=%ld", _fx_, (DWORD)pDRVideo->VideoInfoHeader.AvgTimePerFrame);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->VideoInfoHeader.bmiHeader.biSize=%ld", _fx_, (DWORD)pDRVideo->VideoInfoHeader.bmiHeader.biSize);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->VideoInfoHeader.bmiHeader.biWidth=%ld", _fx_, (DWORD)pDRVideo->VideoInfoHeader.bmiHeader.biWidth);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->VideoInfoHeader.bmiHeader.biHeight=%ld", _fx_, (DWORD)pDRVideo->VideoInfoHeader.bmiHeader.biHeight);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->VideoInfoHeader.bmiHeader.biPlanes=%ld", _fx_, (DWORD)pDRVideo->VideoInfoHeader.bmiHeader.biPlanes);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->VideoInfoHeader.bmiHeader.biBitCount=%ld", _fx_, (DWORD)pDRVideo->VideoInfoHeader.bmiHeader.biBitCount);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->VideoInfoHeader.bmiHeader.biCompression=%ld", _fx_, (DWORD)pDRVideo->VideoInfoHeader.bmiHeader.biCompression);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->VideoInfoHeader.bmiHeader.biSizeImage=%ld", _fx_, (DWORD)pDRVideo->VideoInfoHeader.bmiHeader.biSizeImage);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->VideoInfoHeader.bmiHeader.biClrUsed=%ld", _fx_, (DWORD)pDRVideo->VideoInfoHeader.bmiHeader.biClrUsed);
        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->VideoInfoHeader.bmiHeader.biClrImportant=%ld", _fx_, (DWORD)pDRVideo->VideoInfoHeader.bmiHeader.biClrImportant);

        dout(1,g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_);
        D(2) DebugBreak();
}
#endif


/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc BOOL | CWDMCapDev | FindMatchDataRangeVideo | This method either
 *    finds a video data range compatible with the bitamp info header passed
 *    in, or the prefered video data range.
 *
 *  @parm PBITMAPINFOHEADER | pbiHdr | Bitmap info header to match.
 *
 *  @parm BOOL | pfValidMatch | Set to TRUE if a match was found, FALSE
 *    otherwise.
 *
 *  @rdesc Returns a valid pointer to a <t KS_DATARANGE_VIDEO> structure if
 *    successful, or a NULL pointer otherwise.
 *
 *  @comm \\redrum\slmro\proj\wdm10\src\dvd\amovie\proxy\filter\ksutil.cpp(207):KsGetMediaTypes(
 ***************************************************************************/
HRESULT CWDMCapDev::FindMatchDataRangeVideo(PBITMAPINFOHEADER pbiHdr, DWORD dwAvgTimePerFrame, BOOL *pfValidMatch, PKS_DATARANGE_VIDEO *ppSelDRVideo)
{
        HRESULT                         Hr = NOERROR;
        PVIDEO_DATA_RANGES      pDataRanges;
        PKS_DATARANGE_VIDEO     pDRVideo;
        PKS_DATARANGE_VIDEO     pFirstDRVideo;          // 1st usable data range
        PKS_DATARANGE_VIDEO     pFirstMatchDRVideo;     // 1st data range that fits requests
        PKS_DATARANGE_VIDEO     pMatchDRVideo;          // data range that matches requests *including* framerate (average time per frame)
        KS_BITMAPINFOHEADER     *pbInfo;
        DWORD                           i;
        long            deltamin=0x7fffffff;
        long            deltamax=0x7fffffff;

        FX_ENTRY("CWDMCapDev::FindMatchDataRangeVideo");

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pfValidMatch);
        ASSERT(ppSelDRVideo);
        if (!pfValidMatch || !ppSelDRVideo)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid input parameter!", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Defaults
        *pfValidMatch = FALSE;
        *ppSelDRVideo = NULL;

        // Get the list of formats supported by the device
        if (FAILED(Hr = GetDriverSupportedDataRanges(&pDataRanges)) || !pDataRanges)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: GetDriverSupportedDataRanges failed!", _fx_));
                goto MyExit;
        }

        // Walk the list of data ranges and find a match
        pDRVideo = &pDataRanges->Data;
        pFirstDRVideo = pFirstMatchDRVideo = pMatchDRVideo = NULL;
        for (i = 0; i < pDataRanges->Count; i++)
        {
                // Meaningless unless it is *_VIDEOINFO
                if (pDRVideo->DataRange.Specifier == KSDATAFORMAT_SPECIFIER_VIDEOINFO)
                {
                        // We don't care about TV Tuner like devices
                        if (pDRVideo->ConfigCaps.VideoStandard == KS_AnalogVideo_None)
                        {

                                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: data range #%ld (pbiHdr %p pDRVideo %p) .....", _fx_,i, pbiHdr, pDRVideo));
                                // Save first useable data range
                                if (!pFirstDRVideo)
                                {
                                        pFirstDRVideo = pDRVideo;
                                        if (!pbiHdr && dwAvgTimePerFrame == 0L) {
                                                pFirstMatchDRVideo = pMatchDRVideo = pDRVideo;
                                                dout(3,g_dwVideoCaptureTraceID, FAIL, "%s:   1st data range saved (pbiHdr %p)", _fx_,pbiHdr);
                                                D(2) DebugBreak();
                                                break;
                                                }
                                }

                                pbInfo = &((pDRVideo->VideoInfoHeader).bmiHeader);

                                D(1) dprintf("%s : pbInfo\n", _fx_);
                                D(1) dumpfield(BITMAPINFOHEADER,pbInfo, biHeight,      "%ld");
                                D(1) dprintf("\t+0x%03x %-17s : %08x '%.4s'\n", FIELDOFFSET(BITMAPINFOHEADER, biCompression), "biCompression", (pbInfo)->biCompression, &((pbInfo)->biCompression));
                                D(1) ASSERT(pbInfo->biHeight >0);
                                if (   (pbInfo->biBitCount == pbiHdr->biBitCount)
                                    && (pbInfo->biCompression == pbiHdr->biCompression)
                                    && (
                                         (
                                            ((pDRVideo->ConfigCaps.OutputGranularityX == 0) || (pDRVideo->ConfigCaps.OutputGranularityY == 0))
                                         && (pDRVideo->ConfigCaps.InputSize.cx == pbiHdr->biWidth)
                                         && (pDRVideo->ConfigCaps.InputSize.cy == pbiHdr->biHeight)
                                         ) ||
                                         (
                                            (pDRVideo->ConfigCaps.MinOutputSize.cx <= pbiHdr->biWidth)
                                         && (pbiHdr->biWidth <= pDRVideo->ConfigCaps.MaxOutputSize.cx)
                                         && (pDRVideo->ConfigCaps.MinOutputSize.cy <= pbiHdr->biHeight)
                                         && (pbiHdr->biHeight <= pDRVideo->ConfigCaps.MaxOutputSize.cy)
                                         && ((pbiHdr->biWidth % pDRVideo->ConfigCaps.OutputGranularityX) == 0)
                                         && ((pbiHdr->biHeight % pDRVideo->ConfigCaps.OutputGranularityY) == 0)
                                         )
                                       )
                                   )
                                {
                                        pFirstMatchDRVideo = pDRVideo;
                                        *pfValidMatch = TRUE;
                                        if(dwAvgTimePerFrame == 0L) {
                                                D(2) DumpDataRangeVideo(pDRVideo);
                                                break;
                                        }
                                        if((LONG)pDRVideo->ConfigCaps.MinFrameInterval <= (LONG)dwAvgTimePerFrame) {
                                           if((LONG)pDRVideo->ConfigCaps.MaxFrameInterval >= (LONG)dwAvgTimePerFrame) {
                                                pMatchDRVideo = pDRVideo;
                                                deltamin=deltamax=0;
                                           }
                                           else {
                                                if((LONG)dwAvgTimePerFrame - (LONG)pDRVideo->ConfigCaps.MaxFrameInterval < deltamax) {
                                                        deltamax = (LONG)dwAvgTimePerFrame - (LONG)pDRVideo->ConfigCaps.MaxFrameInterval;
                                                        if(deltamax < deltamin)
                                                                pMatchDRVideo = pDRVideo;
                                                        }
                                           }
                                        }
                                        else {
                                                if((LONG)pDRVideo->ConfigCaps.MinFrameInterval - (LONG)dwAvgTimePerFrame < deltamin) {
                                                        deltamin = (LONG)pDRVideo->ConfigCaps.MinFrameInterval - (LONG)dwAvgTimePerFrame;
                                                        if(deltamin < deltamax)
                                                                pMatchDRVideo = pDRVideo;
                                                        }
                                        }
                                        if(deltamin == 0 || deltamax == 0) {    // if we already found smth. good enough ...
                                                //*ppSelDRVideo = pDRVideo;
                                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: Match found #%d pDRVideo %p:", _fx_, i, pDRVideo));
                                                break;
                                        }
                                        // else keep lookin' ...
                                }
#if defined(ZZZ) // temporary no debug here ... lower noise
                                else {
                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: Video datarange #%ld: no match: below are conditions that failed", _fx_, i));
                                        if(!(pbInfo->biBitCount == pbiHdr->biBitCount))                          DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: %s", _fx_, "pbInfo->biBitCount == pbiHdr->biBitCount"));
                                        if(!(pbInfo->biCompression == pbiHdr->biCompression))                    DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: %s", _fx_, "pbInfo->biCompression == pbiHdr->biCompression"));
                                        if(!((pDRVideo->ConfigCaps.OutputGranularityX == 0) || (pDRVideo->ConfigCaps.OutputGranularityY == 0)))
                                                                                                                 DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: %s", _fx_, "(pDRVideo->ConfigCaps.OutputGranularityX == 0) || (pDRVideo->ConfigCaps.OutputGranularityY == 0)"));
                                        if(!(pDRVideo->ConfigCaps.InputSize.cx == pbiHdr->biWidth))              DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: %s", _fx_, "pDRVideo->ConfigCaps.InputSize.cx == pbiHdr->biWidth"));
                                        if(!(pDRVideo->ConfigCaps.InputSize.cy == pbiHdr->biHeight))             DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: %s", _fx_, "pDRVideo->ConfigCaps.InputSize.cy == pbiHdr->biHeight"));
                                        if(!(pDRVideo->ConfigCaps.MinOutputSize.cx <= pbiHdr->biWidth))          DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: %s", _fx_, "pDRVideo->ConfigCaps.MinOutputSize.cx <= pbiHdr->biWidth"));
                                        if(!(pbiHdr->biWidth <= pDRVideo->ConfigCaps.MaxOutputSize.cx))          DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: %s", _fx_, "pbiHdr->biWidth <= pDRVideo->ConfigCaps.MaxOutputSize.cx"));
                                        if(!(pDRVideo->ConfigCaps.MinOutputSize.cy <= pbiHdr->biHeight))         DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: %s", _fx_, "pDRVideo->ConfigCaps.MinOutputSize.cy <= pbiHdr->biHeight"));
                                        if(!(pbiHdr->biHeight <= pDRVideo->ConfigCaps.MaxOutputSize.cy))         DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: %s", _fx_, "pbiHdr->biHeight <= pDRVideo->ConfigCaps.MaxOutputSize.cy"));
                                        if(!((pbiHdr->biWidth % pDRVideo->ConfigCaps.OutputGranularityX) == 0))  DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: %s", _fx_, "(pbiHdr->biWidth % pDRVideo->ConfigCaps.OutputGranularityX) == 0"));
                                        if(!((pbiHdr->biHeight % pDRVideo->ConfigCaps.OutputGranularityY) == 0)) DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: %s", _fx_, "(pbiHdr->biHeight % pDRVideo->ConfigCaps.OutputGranularityY) == 0"));
                                }
#endif
                        } // VideoStandard
                } // Specifier

                pDRVideo = (PKS_DATARANGE_VIDEO)((PBYTE)pDRVideo + ((pDRVideo->DataRange.FormatSize + 7) & ~7));  // Next KS_DATARANGE_VIDEO
        }


        *ppSelDRVideo = pMatchDRVideo;
        if (!*ppSelDRVideo) {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   1st data range that fits requests used -- framerate might need adjustment in caller (*pfValidMatch %d)", _fx_,*pfValidMatch));
                *ppSelDRVideo = pFirstMatchDRVideo;
                }


        // If no valid match, use the first range found
        if (!*pfValidMatch) {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   1st data range used (*pfValidMatch %d)", _fx_,*pfValidMatch));
                *ppSelDRVideo = pFirstDRVideo;
                }

        // Have we found anything?
        if (!*ppSelDRVideo) {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   nothing found", _fx_));
                Hr = E_FAIL;
                }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}


/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc BOOL | CWDMCapDev | DeviceIoControl | This function wraps around
 *    ::DeviceIOControl.
 *
 *  @parm HANDLE | hFile | Handle to the device that is to perform the
 *    operation.
 *
 *  @parm DWORD | dwIoControlCode | Specifies the control code for the
 *    operation.
 *
 *  @parm LPVOID | lpInBuffer | Pointer to a buffer that contains the data
 *    required to perform the operation.
 *
 *  @parm DWORD | nInBufferSize | Specifies the size, in bytes, of the buffer
 *    pointed to by <p lpInBuffer>.
 *
 *  @parm LPVOID | lpOutBuffer | Pointer to a buffer that receives the
 *    operation's output data.
 *
 *  @parm DWORD | nOutBufferSize | Specifies the size, in bytes, of the
 *    buffer pointed to by <p lpOutBuffer>.
 *
 *  @parm LPDWORD | lpBytesReturned | Pointer to a variable that receives the
 *    size, in bytes, of the data stored into the buffer pointed to by
 *    <p lpOutBuffer>.
 *
 *  @parm BOOL | bOverlapped | If TRUE, the operation is performed
 *    asynchronously, if FALSE, the operation is synchronous.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMCapDev::DeviceIoControl(HANDLE hFile, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, BOOL bOverlapped)
{
        FX_ENTRY("CWDMCapDev::DeviceIoControl");

        if (hFile && (hFile != INVALID_HANDLE_VALUE))
        {
                LPOVERLAPPED lpOverlapped=NULL;
                BOOL bRet;
                OVERLAPPED ov;
                DWORD dwErr;

                if (bOverlapped)
                {
                        ov.Offset            = 0;
                        ov.OffsetHigh        = 0;
                        ov.hEvent            = CreateEvent( NULL, FALSE, FALSE, NULL );
                        if (ov.hEvent == (HANDLE) 0)
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: CreateEvent has failed", _fx_));
                        }
                        lpOverlapped        =&ov;
                }

                bRet = ::DeviceIoControl(hFile, dwIoControlCode, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesReturned, lpOverlapped);

                if (bOverlapped)
                {
                        BOOL bShouldBlock=FALSE;

                        if (!bRet)
                        {
                                dwErr=GetLastError();
                                switch (dwErr)
                                {
                                        case ERROR_IO_PENDING:    // the overlapped IO is going to take place.
                                                bShouldBlock=TRUE;
                                                break;

                                        default:    // some other strange error has happened.
                                                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: DevIoControl failed with GetLastError=%d", _fx_, dwErr));
                                                break;
                                }
                        }

                        if (bShouldBlock)
                        {
                                DWORD    tmStart, tmEnd, tmDelta;
                                tmStart = timeGetTime();

                                DWORD dwRtn = WaitForSingleObject( ov.hEvent, 1000 * 10);  // USB has a max of 5 SEC bus reset

                                tmEnd = timeGetTime();
                                tmDelta = tmEnd - tmStart;
#ifdef DEBUG
                                if (tmDelta >= 1000)
                                {
                                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: WaitObj waited %d msec", _fx_, tmDelta));
                                }
#endif

                                switch (dwRtn)
                                {
                                        case WAIT_ABANDONED:
                                                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: WaitObj: non-signaled ! WAIT_ABANDONED!", _fx_));
                                                bRet = FALSE;
                                                break;

                                        case WAIT_OBJECT_0:
                                                bRet = TRUE;
                                                break;

                                        case WAIT_TIMEOUT:
                                                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: WaitObj: TIMEOUT after %d msec! rtn FALSE", _fx_, tmDelta));
                                                bRet = FALSE;
                                                break;

                                        default:
                                                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: WaitObj: unknown return ! rtn FALSE", _fx_));
                                                bRet = FALSE;
                                                break;
                                }
                        }

                        CloseHandle(ov.hEvent);
                }

                return bRet;
        }

        return FALSE;
}

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc DWORD | CWDMCapDev | CreateDriverSupportedDataRanges | This method
 *    builds the list of video data ranges supported by the capture device.
 *
 *  @rdesc Returns the number of valid data ranges in the list.
 ***************************************************************************/
DWORD CWDMCapDev::CreateDriverSupportedDataRanges()
{
        DWORD dwCount = 0UL;

        FX_ENTRY("CWDMCapDev::CreateDriverSupportedDataRanges");

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        DWORD cbReturned;
        DWORD dwSize = 0UL;

        // Initialize property structure to get video data ranges
        KSP_PIN KsProperty = {0};

        KsProperty.PinId                        = (m_dwCapturePinId != INVALID_PIN_ID) ? m_dwCapturePinId : m_dwPreviewPinId;
        KsProperty.Property.Set         = KSPROPSETID_Pin;
        KsProperty.Property.Id          = KSPROPERTY_PIN_DATARANGES ;
        KsProperty.Property.Flags       = KSPROPERTY_TYPE_GET;

        // Get the size of the video data range structure
        if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &KsProperty, sizeof(KsProperty), &dwSize, sizeof(dwSize), &cbReturned) == FALSE)
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: Couldn't get the size for the video data ranges", _fx_));
                goto MyExit;
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: Get video data ranges needs %d bytes", _fx_, dwSize));

        // Allocate memory to hold video data ranges
        if (m_pVideoDataRanges)
                delete [] m_pVideoDataRanges;
        m_pVideoDataRanges = (PVIDEO_DATA_RANGES) new BYTE[dwSize];

        if (!m_pVideoDataRanges)
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: Couldn't allocate memory for the video data ranges", _fx_));
                goto MyExit;
        }

        // Really get the video data ranges
        if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &KsProperty, sizeof(KsProperty), m_pVideoDataRanges, dwSize, &cbReturned) == 0)
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: Problem getting the data ranges themselves", _fx_));
                goto MyError;
        }

        // Sanity check
        if (cbReturned < m_pVideoDataRanges->Size || m_pVideoDataRanges->Count == 0)
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: cbReturned < m_pDataRanges->Size || m_pDataRanges->Count == 0", _fx_));
                goto MyError;
        }

        dwCount = m_pVideoDataRanges->Count;

#ifdef DEBUG
        // Dump dataranges
        PKS_DATARANGE_VIDEO     pDRVideo;
        ULONG i;
        // Walk the list of data ranges
        for (i = 0, pDRVideo = &m_pVideoDataRanges->Data; i < m_pVideoDataRanges->Count; i++)
        {
                // Meaningless unless it is *_VIDEOINFO
                if (pDRVideo->DataRange.Specifier == KSDATAFORMAT_SPECIFIER_VIDEOINFO)
                {
                        // We don't care about TV Tuner like devices
                        if (pDRVideo->ConfigCaps.VideoStandard == KS_AnalogVideo_None)
                        {
                                // Dump useable data range
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: Video datarange #%ld:", _fx_, i));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->DataRange.FormatSize=%ld", _fx_, pDRVideo->DataRange.FormatSize));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->DataRange.Flags=%ld", _fx_, pDRVideo->DataRange.Flags));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->DataRange.SampleSize=%ld", _fx_, pDRVideo->DataRange.SampleSize));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->DataRange.Reserved=%ld", _fx_, pDRVideo->DataRange.Reserved));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->DataRange.MajorFormat=0x%lX", _fx_, pDRVideo->DataRange.MajorFormat));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->DataRange.SubFormat=0x%lX", _fx_, pDRVideo->DataRange.SubFormat));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->DataRange.Specifier=KSDATAFORMAT_SPECIFIER_VIDEOINFO", _fx_));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->bFixedSizeSamples=%ld", _fx_, pDRVideo->bFixedSizeSamples));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->bTemporalCompression=%ld", _fx_, pDRVideo->bTemporalCompression));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->StreamDescriptionFlags=0x%lX", _fx_, pDRVideo->StreamDescriptionFlags));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->MemoryAllocationFlags=0x%lX", _fx_, pDRVideo->MemoryAllocationFlags));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.VideoStandard=KS_AnalogVideo_None", _fx_));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.InputSize(cx=%ld, cy=%ld)", _fx_, pDRVideo->ConfigCaps.InputSize.cx, pDRVideo->ConfigCaps.InputSize.cy));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.MinCroppingSize(cx=%ld, cy=%ld)", _fx_, pDRVideo->ConfigCaps.MinCroppingSize.cx, pDRVideo->ConfigCaps.MinCroppingSize.cy));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.MaxCroppingSize(cx=%ld, cy=%ld)", _fx_, pDRVideo->ConfigCaps.MaxCroppingSize.cx, pDRVideo->ConfigCaps.MaxCroppingSize.cy));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.CropGranularityX=%ld", _fx_, pDRVideo->ConfigCaps.CropGranularityY));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.CropGranularityY=%ld", _fx_, pDRVideo->ConfigCaps.CropGranularityY));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.CropAlignX=%ld", _fx_, pDRVideo->ConfigCaps.CropAlignX));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.CropAlignY=%ld", _fx_, pDRVideo->ConfigCaps.CropAlignY));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.MinOutputSize(cx=%ld, cy=%ld)", _fx_, pDRVideo->ConfigCaps.MinOutputSize.cx, pDRVideo->ConfigCaps.MinOutputSize.cy));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.MaxOutputSize(cx=%ld, cy=%ld)", _fx_, pDRVideo->ConfigCaps.MaxOutputSize.cx, pDRVideo->ConfigCaps.MaxOutputSize.cy));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.OutputGranularityX=%ld", _fx_, pDRVideo->ConfigCaps.OutputGranularityX));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.OutputGranularityY=%ld", _fx_, pDRVideo->ConfigCaps.OutputGranularityY));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.StretchTapsX=%ld", _fx_, pDRVideo->ConfigCaps.StretchTapsX));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.StretchTapsY=%ld", _fx_, pDRVideo->ConfigCaps.StretchTapsY));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.ShrinkTapsX=%ld", _fx_, pDRVideo->ConfigCaps.ShrinkTapsX));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.ShrinkTapsY=%ld", _fx_, pDRVideo->ConfigCaps.ShrinkTapsY));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.MinFrameInterval=%ld", _fx_, (DWORD)pDRVideo->ConfigCaps.MinFrameInterval));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.MaxFrameInterval=%ld", _fx_, (DWORD)pDRVideo->ConfigCaps.MaxFrameInterval));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.MinBitsPerSecond=%ld", _fx_, pDRVideo->ConfigCaps.MinBitsPerSecond));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->ConfigCaps.MaxBitsPerSecond=%ld", _fx_, pDRVideo->ConfigCaps.MaxBitsPerSecond));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->VideoInfoHeader.rcSource(left=%ld, top=%ld, right=%ld, bottom=%ld)", _fx_, pDRVideo->VideoInfoHeader.rcSource.left, pDRVideo->VideoInfoHeader.rcSource.top, pDRVideo->VideoInfoHeader.rcSource.right, pDRVideo->VideoInfoHeader.rcSource.bottom));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->VideoInfoHeader.rcTarget(left=%ld, top=%ld, right=%ld, bottom=%ld)", _fx_, pDRVideo->VideoInfoHeader.rcTarget.left, pDRVideo->VideoInfoHeader.rcTarget.top, pDRVideo->VideoInfoHeader.rcTarget.right, pDRVideo->VideoInfoHeader.rcTarget.bottom));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->VideoInfoHeader.dwBitRate=%ld", _fx_, pDRVideo->VideoInfoHeader.dwBitRate));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->VideoInfoHeader.dwBitErrorRate=%ld", _fx_, pDRVideo->VideoInfoHeader.dwBitErrorRate));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->VideoInfoHeader.AvgTimePerFrame=%ld", _fx_, (DWORD)pDRVideo->VideoInfoHeader.AvgTimePerFrame));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->VideoInfoHeader.bmiHeader.biSize=%ld", _fx_, (DWORD)pDRVideo->VideoInfoHeader.bmiHeader.biSize));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->VideoInfoHeader.bmiHeader.biWidth=%ld", _fx_, (DWORD)pDRVideo->VideoInfoHeader.bmiHeader.biWidth));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->VideoInfoHeader.bmiHeader.biHeight=%ld", _fx_, (DWORD)pDRVideo->VideoInfoHeader.bmiHeader.biHeight));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->VideoInfoHeader.bmiHeader.biPlanes=%ld", _fx_, (DWORD)pDRVideo->VideoInfoHeader.bmiHeader.biPlanes));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->VideoInfoHeader.bmiHeader.biBitCount=%ld", _fx_, (DWORD)pDRVideo->VideoInfoHeader.bmiHeader.biBitCount));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->VideoInfoHeader.bmiHeader.biCompression=%ld", _fx_, (DWORD)pDRVideo->VideoInfoHeader.bmiHeader.biCompression));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->VideoInfoHeader.bmiHeader.biSizeImage=%ld", _fx_, (DWORD)pDRVideo->VideoInfoHeader.bmiHeader.biSizeImage));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->VideoInfoHeader.bmiHeader.biClrUsed=%ld", _fx_, (DWORD)pDRVideo->VideoInfoHeader.bmiHeader.biClrUsed));
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   pDRVideo->VideoInfoHeader.bmiHeader.biClrImportant=%ld", _fx_, (DWORD)pDRVideo->VideoInfoHeader.bmiHeader.biClrImportant));
                        } // VideoStandard
                        else
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: Video datarange's VideoStandard != KS_AnalogVideo_None", _fx_));
                        }
                } // Specifier
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: Video datarange's Specifier != KSDATAFORMAT_SPECIFIER_VIDEOINFO", _fx_));
                }

                pDRVideo = (PKS_DATARANGE_VIDEO)((PBYTE)pDRVideo + ((pDRVideo->DataRange.FormatSize + 7) & ~7));  // Next KS_DATARANGE_VIDEO
        }
#endif

        goto MyExit;

MyError:
        delete [] m_pVideoDataRanges;
        m_pVideoDataRanges = (PVIDEO_DATA_RANGES)NULL;
MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return dwCount;
}

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc DWORD | CWDMCapDev | GetDriverSupportedDataRanges | This method
 *    returns the list of video data ranges supported by the capture device.
 *
 *  @rdesc Returns the number of valid data ranges in the list.
 ***************************************************************************/
HRESULT CWDMCapDev::GetDriverSupportedDataRanges(PVIDEO_DATA_RANGES *ppDataRanges)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CWDMCapDev::GetDriverSupportedDataRanges");

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(ppDataRanges);
        if (!ppDataRanges)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Return pointer to our data range array
        *ppDataRanges = m_pVideoDataRanges;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

#if defined(DUMP_DRIVER_CHARACTERISTICS) && defined(DEBUG)

typedef struct identifiers : public KSMULTIPLE_ITEM {
    KSIDENTIFIER aIdentifiers[1];
} IDENTIFIERS, *PIDENTIFIERS;

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | GetDriverDetails | This method is used to
 *    dump the list of capabilities of a WDM capture device. This code should
 *    used in DEBUG mode only!
 *
 *  @rdesc Nade
 ***************************************************************************/
void CWDMCapDev::GetDriverDetails()
{
        KSP_PIN KsProperty;
        DWORD dwPinCount = 0UL;
        DWORD dwSize = 0UL;
    PKSMULTIPLE_ITEM pCategories = NULL;
    PIDENTIFIERS pInterfaces = NULL;
    PIDENTIFIERS pMediums = NULL;
    PIDENTIFIERS pNodes = NULL;
    KSTOPOLOGY Topology;
        KSPIN_CINSTANCES Instances;
        DWORD cbReturned;
        DWORD dwFlowDirection;
        DWORD dwCommunication;
        DWORD dwPinId;
        WCHAR wstrPinName[256];
        GUID guidCategory;

        FX_ENTRY("CWDMCapDev::GetDriverDetails");

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: Device properties:", _fx_));

        // Get the topology
        KsProperty.PinId                        = 0;
        KsProperty.Reserved                     = 0;
        KsProperty.Property.Set         = KSPROPSETID_Topology;
        KsProperty.Property.Id          = KSPROPERTY_TOPOLOGY_CATEGORIES;
        KsProperty.Property.Flags       = KSPROPERTY_TYPE_GET;

        // Get the size of the topology
        if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &KsProperty, sizeof(KsProperty), &dwSize, sizeof(dwSize), &cbReturned) == FALSE)
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Couldn't get the size for the topology", _fx_));
        }
        else
        {
                // Allocate memory to hold the topology
                if (!(pCategories = (PKSMULTIPLE_ITEM) new BYTE[dwSize]))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Couldn't allocate memory for the topology", _fx_));
                }
                else
                {
                        // Really get the topology structures
                        if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &KsProperty, sizeof(KsProperty), pCategories, dwSize, &cbReturned) == 0)
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Couldn't get the topology", _fx_));
                        }
                        else
                        {
                                if (pCategories)
                                {
                                        Topology.CategoriesCount = pCategories->Count;
                                        Topology.Categories = (GUID*)(pCategories + 1);

                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Supported categories: %ld", _fx_, pCategories->Count));

                                        for (DWORD i = 0; i < pCategories->Count; i++)
                                        {
                                                if (Topology.Categories[i] == KSCATEGORY_BRIDGE)
                                                {
                                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     KSCATEGORY_BRIDGE", _fx_));
                                                }
                                                else if (Topology.Categories[i] == KSCATEGORY_CAPTURE)
                                                {
                                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     KSCATEGORY_CAPTURE", _fx_));
                                                }
                                                else if (Topology.Categories[i] == KSCATEGORY_TVTUNER)
                                                {
                                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     KSCATEGORY_TVTUNER", _fx_));
                                                }
                                                else if (Topology.Categories[i] == KSCATEGORY_TVAUDIO)
                                                {
                                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     KSCATEGORY_TVAUDIO", _fx_));
                                                }
                                                else if (Topology.Categories[i] == KSCATEGORY_CROSSBAR)
                                                {
                                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     KSCATEGORY_CROSSBAR", _fx_));
                                                }
                                                else if (Topology.Categories[i] == KSCATEGORY_VIDEO)
                                                {
                                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     KSCATEGORY_VIDEO", _fx_));
                                                }
                                                else if (Topology.Categories[i] == KSCATEGORY_RENDER)
                                                {
                                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     KSCATEGORY_RENDER", _fx_));
                                                }
                                                else if (Topology.Categories[i] == KSCATEGORY_MIXER)
                                                {
                                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     KSCATEGORY_MIXER", _fx_));
                                                }
                                                else if (Topology.Categories[i] == KSCATEGORY_SPLITTER)
                                                {
                                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     KSCATEGORY_SPLITTER", _fx_));
                                                }
                                                else if (Topology.Categories[i] == KSCATEGORY_DATACOMPRESSOR)
                                                {
                                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     KSCATEGORY_DATACOMPRESSOR", _fx_));
                                                }
                                                else if (Topology.Categories[i] == KSCATEGORY_DATADECOMPRESSOR)
                                                {
                                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     KSCATEGORY_DATADECOMPRESSOR", _fx_));
                                                }
                                                else if (Topology.Categories[i] == KSCATEGORY_DATATRANSFORM)
                                                {
                                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     KSCATEGORY_DATATRANSFORM", _fx_));
                                                }
                                                else if (Topology.Categories[i] == KSCATEGORY_COMMUNICATIONSTRANSFORM)
                                                {
                                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     KSCATEGORY_COMMUNICATIONSTRANSFORM", _fx_));
                                                }
                                                else if (Topology.Categories[i] == KSCATEGORY_INTERFACETRANSFORM)
                                                {
                                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     KSCATEGORY_INTERFACETRANSFORM", _fx_));
                                                }
                                                else if (Topology.Categories[i] == KSCATEGORY_MEDIUMTRANSFORM)
                                                {
                                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     KSCATEGORY_MEDIUMTRANSFORM", _fx_));
                                                }
                                                else if (Topology.Categories[i] == PINNAME_VIDEO_STILL)
                                                {
                                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     PINNAME_VIDEO_STILL", _fx_));
                                                }
                                                else
                                                {
                                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     Unknown category", _fx_));
                                                }
                                        }
                                }
                        }

                        delete pCategories;
                }
        }

        // Get the topology nodes
        KsProperty.PinId                        = 0;
        KsProperty.Reserved                     = 0;
        KsProperty.Property.Set         = KSPROPSETID_Topology;
        KsProperty.Property.Id          = KSPROPERTY_TOPOLOGY_NODES;
        KsProperty.Property.Flags       = KSPROPERTY_TYPE_GET;

        // Get the size of the topology node structures
        dwSize = 0UL;
        if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &KsProperty, sizeof(KsProperty), &dwSize, sizeof(dwSize), &cbReturned) == FALSE)
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Couldn't get the size for the topology nodes", _fx_));
        }
        else
        {
                // Allocate memory to hold the topology node structures
                if (!(pNodes = (PIDENTIFIERS) new BYTE[dwSize]))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Couldn't allocate memory for the topology nodes", _fx_));
                }
                else
                {
                        // Really get the topology nodes
                        if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &KsProperty, sizeof(KsProperty), pNodes, dwSize, &cbReturned) == 0)
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Couldn't get the topology nodes", _fx_));
                        }
                        else
                        {
                                if (pNodes)
                                {
                                        Topology.TopologyNodesCount = pNodes->Count;
                                        Topology.TopologyNodes = (GUID*)(pNodes + 1);

                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Number of topology nodes: %ld", _fx_, pNodes->Count));

                                        for (DWORD i = 0; i < pNodes->Count; i++)
                                        {
                                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     Node #%ld: {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX}", _fx_, i, Topology.TopologyNodes[i].Data1, Topology.TopologyNodes[i].Data2, Topology.TopologyNodes[i].Data3, Topology.TopologyNodes[i].Data4[0], Topology.TopologyNodes[i].Data4[1], Topology.TopologyNodes[i].Data4[2], Topology.TopologyNodes[i].Data4[3], Topology.TopologyNodes[i].Data4[4], Topology.TopologyNodes[i].Data4[5], Topology.TopologyNodes[i].Data4[6], Topology.TopologyNodes
[i].Data4[7]));
                                        }
                                }
                        }

                        delete pNodes;
                }
        }

        // Get the topology node connections
        KsProperty.PinId                        = 0;
        KsProperty.Reserved                     = 0;
        KsProperty.Property.Set         = KSPROPSETID_Topology;
        KsProperty.Property.Id          = KSPROPERTY_TOPOLOGY_CONNECTIONS;
        KsProperty.Property.Flags       = KSPROPERTY_TYPE_GET;

        // Get the size of the topology node connection structures
        dwSize = 0UL;
        if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &KsProperty, sizeof(KsProperty), &dwSize, sizeof(dwSize), &cbReturned) == FALSE)
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Couldn't get the size for the topology node connections", _fx_));
        }
        else
        {
                // Allocate memory to hold the topology node connection structures
                if (!(pNodes = (PIDENTIFIERS) new BYTE[dwSize]))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Couldn't allocate memory for the topology node connections", _fx_));
                }
                else
                {
                        // Really get the topology node connections
                        if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &KsProperty, sizeof(KsProperty), pNodes, dwSize, &cbReturned) == 0)
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Couldn't get the topology node connections", _fx_));
                        }
                        else
                        {
                                if (pNodes)
                                {
                                        Topology.TopologyConnectionsCount = pNodes->Count;
                                        Topology.TopologyConnections = (KSTOPOLOGY_CONNECTION*)(pNodes + 1);

                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Number of topology node connections: %ld", _fx_, pNodes->Count));

                                        for (DWORD i = 0; i < pNodes->Count; i++)
                                        {
                                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     Connection #%ld: From node #%ld, from node pin #%ld, to node #%ld, to node pin #%ld", _fx_, i, Topology.TopologyConnections[i].FromNode, Topology.TopologyConnections[i].FromNodePin, Topology.TopologyConnections[i].ToNode, Topology.TopologyConnections[i].ToNodePin));
                                        }
                                }
                        }

                        delete pNodes;
                }
        }

        // Get the number of pins
        KsProperty.PinId                        = 0;
        KsProperty.Reserved                     = 0;
        KsProperty.Property.Set         = KSPROPSETID_Pin;
        KsProperty.Property.Id          = KSPROPERTY_PIN_CTYPES;
        KsProperty.Property.Flags       = KSPROPERTY_TYPE_GET;

        if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &KsProperty, sizeof(KsProperty), &dwPinCount, sizeof(dwPinCount), &cbReturned) == FALSE)
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Couldn't get the number of pin types supported by the device", _fx_));
        }
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Number of pin types: %ld", _fx_, dwPinCount));
        }

        // Get the properties of each pin
    for (dwPinId = 0; dwPinId < dwPinCount; dwPinId++)
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Properties of pin type #%ld:", _fx_, dwPinId));

                // Get the number of instances
                KsProperty.PinId                        = dwPinId;
                KsProperty.Reserved                     = 0;
                KsProperty.Property.Set         = KSPROPSETID_Pin;
                KsProperty.Property.Id          = KSPROPERTY_PIN_CINSTANCES;
                KsProperty.Property.Flags       = KSPROPERTY_TYPE_GET;

                if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &KsProperty, sizeof(KsProperty), &Instances, sizeof(KSPIN_CINSTANCES), &cbReturned) == FALSE)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     Couldn't get the number of available instances", _fx_));
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     Number of available instances: %ld", _fx_, Instances.PossibleCount));
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     Number of used instances: %ld", _fx_, Instances.CurrentCount));
                }

                // Get the flow direction
                KsProperty.PinId                        = dwPinId;
                KsProperty.Reserved                     = 0;
                KsProperty.Property.Set         = KSPROPSETID_Pin;
                KsProperty.Property.Id          = KSPROPERTY_PIN_DATAFLOW;
                KsProperty.Property.Flags       = KSPROPERTY_TYPE_GET;

                dwFlowDirection = 0UL;

                if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &KsProperty, sizeof(KsProperty), &dwFlowDirection, sizeof(dwFlowDirection), &cbReturned) == FALSE)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     Couldn't get the flow direction", _fx_));
                }
                else
                {
                        if (dwFlowDirection == KSPIN_DATAFLOW_IN)
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     Flow direction is KSPIN_DATAFLOW_IN", _fx_));
                        else if (dwFlowDirection == KSPIN_DATAFLOW_OUT)
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     Flow direction is KSPIN_DATAFLOW_OUT", _fx_));
                        else
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     Flow direction is unknown", _fx_));
                }

                // Get the communication requirements
                KsProperty.PinId                        = dwPinId;
                KsProperty.Reserved                     = 0;
                KsProperty.Property.Set         = KSPROPSETID_Pin;
                KsProperty.Property.Id          = KSPROPERTY_PIN_COMMUNICATION;
                KsProperty.Property.Flags       = KSPROPERTY_TYPE_GET;

                dwCommunication = 0UL;

                if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &KsProperty, sizeof(KsProperty), &dwCommunication, sizeof(dwCommunication), &cbReturned) == FALSE)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     Couldn't get the communication requirements", _fx_));
                }
                else
                {
                        if (dwCommunication & KSPIN_COMMUNICATION_NONE)
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     Communication requirements: KSPIN_COMMUNICATION_NONE", _fx_));
                        if (dwCommunication & KSPIN_COMMUNICATION_SINK)
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     Communication requirements: KSPIN_COMMUNICATION_SINK", _fx_));
                        if (dwCommunication & KSPIN_COMMUNICATION_SOURCE)
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     Communication requirements: KSPIN_COMMUNICATION_SOURCE", _fx_));
                        if (dwCommunication & KSPIN_COMMUNICATION_BOTH)
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     Communication requirements: KSPIN_COMMUNICATION_BOTH", _fx_));
                        if (dwCommunication & KSPIN_COMMUNICATION_BRIDGE)
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     Communication requirements: KSPIN_COMMUNICATION_BRIDGE", _fx_));
                }

                // Get the pin category
                KsProperty.PinId                        = dwPinId;
                KsProperty.Reserved                     = 0;
                KsProperty.Property.Set         = KSPROPSETID_Pin;
                KsProperty.Property.Id          = KSPROPERTY_PIN_CATEGORY;
                KsProperty.Property.Flags       = KSPROPERTY_TYPE_GET;

                if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &KsProperty, sizeof(KsProperty), &guidCategory, sizeof(guidCategory), &cbReturned) == FALSE)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     Couldn't get the GUID category", _fx_));
                }
                else
                {
                        if (guidCategory == PINNAME_VIDEO_PREVIEW)
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     GUID category: PINNAME_VIDEO_PREVIEW", _fx_));
                        else if (guidCategory == PINNAME_VIDEO_CAPTURE)
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     GUID category: PINNAME_VIDEO_CAPTURE", _fx_));
                        else
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Unknown GUID category", _fx_));
                }

                // Get pin name
                KsProperty.PinId                        = dwPinId;
                KsProperty.Reserved                     = 0;
                KsProperty.Property.Set         = KSPROPSETID_Pin;
                KsProperty.Property.Id          = KSPROPERTY_PIN_NAME;
                KsProperty.Property.Flags       = KSPROPERTY_TYPE_GET;

                if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &KsProperty, sizeof(KsProperty), &wstrPinName[0], sizeof(wstrPinName), &cbReturned) == 0)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Couldn't get the pin name", _fx_));
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     Pin name: %S", _fx_, &wstrPinName[0]));
                }

                // Get pin interfaces
                KsProperty.PinId                        = dwPinId;
                KsProperty.Reserved                     = 0;
                KsProperty.Property.Set         = KSPROPSETID_Pin;
                KsProperty.Property.Id          = KSPROPERTY_PIN_INTERFACES;
                KsProperty.Property.Flags       = KSPROPERTY_TYPE_GET;

                // Get the size of the interface structures
                dwSize = 0UL;
                if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &KsProperty, sizeof(KsProperty), &dwSize, sizeof(dwSize), &cbReturned) == FALSE)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Couldn't get the size for the interfaces", _fx_));
                }
                else
                {
                        // Allocate memory to hold the interface structures
                        if (!(pInterfaces = (PIDENTIFIERS) new BYTE[dwSize]))
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Couldn't allocate memory for the interfaces", _fx_));
                        }
                        else
                        {
                                // Really get the list of interfaces
                                if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &KsProperty, sizeof(KsProperty), pInterfaces, dwSize, &cbReturned) == 0)
                                {
                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Couldn't get the interfaces", _fx_));
                                }
                                else
                                {
                                        // Dump list of supported interfaces
                                        for (DWORD i = 0; i < pInterfaces->Count; i++)
                                        {
                                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     Interface #%ld", _fx_, i));
                                                if (pInterfaces->aIdentifiers[i].Set == KSINTERFACESETID_Standard)
                                                {
                                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:       Set: KSINTERFACESETID_Standard", _fx_));
                                                        if (pInterfaces->aIdentifiers[i].Id == KSINTERFACE_STANDARD_STREAMING)
                                                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:       Id: KSINTERFACE_STANDARD_STREAMING", _fx_));
                                                        else if (pInterfaces->aIdentifiers[i].Id == KSINTERFACE_STANDARD_LOOPED_STREAMING)
                                                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:       Id: KSINTERFACE_STANDARD_LOOPED_STREAMING", _fx_));
                                                        else if (pInterfaces->aIdentifiers[i].Id == KSINTERFACE_STANDARD_CONTROL)
                                                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:       Id: KSINTERFACE_STANDARD_CONTROL", _fx_));
                                                        else
                                                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:       Id: %ld", _fx_, pInterfaces->aIdentifiers[i].Id));
                                                }
                                                else
                                                {
                                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:       Set: {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX}", _fx_, pInterfaces->aIdentifiers[i].Set.Data1, pInterfaces->aIdentifiers[i].Set.Data2, pInterfaces->aIdentifiers[i].Set.Data3, pInterfaces->aIdentifiers[i].Set.Data4[0], pInterfaces->aIdentifiers[i].Set.Data4[1], pInterfaces->aIdentifiers[i].Set.Data4[2], pInterfaces->aIdentifiers[i].Set.Data4[3], pInterfaces->aIdentifiers[i].Set.Data4[4], pInterfaces->aIdentifiers[i].Set.Data4[5], p
Interfaces->aIdentifiers[i].Set.Data4[6], pInterfaces->aIdentifiers[i].Set.Data4[7]));
                                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:       Id: %ld", _fx_, pInterfaces->aIdentifiers[i].Id));
                                                }
                                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:       Flags: %ld", _fx_, pInterfaces->aIdentifiers[i].Flags));
                                        }
                                }

                                delete pInterfaces;
                        }
                }

                // Get pin mediums
                KsProperty.PinId                        = dwPinId;
                KsProperty.Reserved                     = 0;
                KsProperty.Property.Set         = KSPROPSETID_Pin;
                KsProperty.Property.Id          = KSPROPERTY_PIN_MEDIUMS;
                KsProperty.Property.Flags       = KSPROPERTY_TYPE_GET;

                // Get the size of the medium structures
                dwSize = 0UL;
                if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &KsProperty, sizeof(KsProperty), &dwSize, sizeof(dwSize), &cbReturned) == FALSE)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Couldn't get the size for the mediums", _fx_));
                }
                else
                {
                        // Allocate memory to hold the medium structures
                        if (!(pMediums = (PIDENTIFIERS) new BYTE[dwSize]))
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Couldn't allocate memory for the mediums", _fx_));
                        }
                        else
                        {
                                // Really get the list of mediums
                                if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &KsProperty, sizeof(KsProperty), pMediums, dwSize, &cbReturned) == 0)
                                {
                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Couldn't get the mediums", _fx_));
                                }
                                else
                                {
                                        // Dump list of supported mediums
                                        for (DWORD i = 0; i < pMediums->Count; i++)
                                        {
                                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     Medium #%ld", _fx_, i));
                                                if (pMediums->aIdentifiers[i].Set == KSMEDIUMSETID_Standard)
                                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:       Set: KSMEDIUMSETID_Standard", _fx_));
                                                else if (pMediums->aIdentifiers[i].Set == KSMEDIUMSETID_FileIo)
                                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:       Set: KSMEDIUMSETID_FileIo", _fx_));
                                                else
                                                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:       Set: {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX}", _fx_, pMediums->aIdentifiers[i].Set.Data1, pMediums->aIdentifiers[i].Set.Data2, pMediums->aIdentifiers[i].Set.Data3, pMediums->aIdentifiers[i].Set.Data4[0], pMediums->aIdentifiers[i].Set.Data4[1], pMediums->aIdentifiers[i].Set.Data4[2], pMediums->aIdentifiers[i].Set.Data4[3], pMediums->aIdentifiers[i].Set.Data4[4], pMediums->aIdentifiers[i].Set.Data4[5], pMediums->aIdentifiers[i].Se
t.Data4[6], pMediums->aIdentifiers[i].Set.Data4[7]));
                                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:       Id: %ld", _fx_, pMediums->aIdentifiers[i].Id));
                                                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:       Flags: %ld", _fx_, pMediums->aIdentifiers[i].Flags));
                                        }
                                }

                                delete pMediums;
                        }
                }
        }
}
#endif

// Used to query/set video property values and ranges
typedef struct {
    KSPROPERTY_DESCRIPTION      proDesc;
    KSPROPERTY_MEMBERSHEADER  proHdr;
    union {
        KSPROPERTY_STEPPING_LONG  proData;
        ULONG ulData;
    };
    union {
        KSPROPERTY_STEPPING_LONG  proData2;
        ULONG ulData2;
    };
} PROCAMP_MEMBERSLIST;

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | GetPropertyValue | This function gets the
 *    current value of a video property of a capture device.
 *
 *  @parm GUID | guidPropertySet | GUID of the KS property set we are touching. It
 *    is either PROPSETID_VIDCAP_VIDEOPROCAMP or PROPSETID_VIDCAP_CAMERACONTROL.
 *
 *  @parm ULONG | ulPropertyId | ID of the property we are touching. It is
 *    either KSPROPERTY_VIDEOPROCAMP_* or KSPROPERTY_CAMERACONTROL_*.
 *
 *  @parm PLONG | plValue | Pointer to a LONG to receive the current value.
 *
 *  @parm PULONG | pulFlags | Pointer to a ULONG to receive the current
 *    flags. We only care about KSPROPERTY_*_FLAGS_MANUAL or
 *    KSPROPERTY_*_FLAGS_AUTO.
 *
 *  @parm PULONG | pulCapabilities | Pointer to a ULONG to receive the
 *    capabilities. We only care about KSPROPERTY_*_FLAGS_MANUAL or
 *    KSPROPERTY_*_FLAGS_AUTO.
 *
 *  @devnote KSPROPERTY_VIDEOPROCAMP_S == KSPROPERTY_CAMERACONTROL_S.
 ***************************************************************************/
HRESULT CWDMCapDev::GetPropertyValue(GUID guidPropertySet, ULONG ulPropertyId, PLONG plValue, PULONG pulFlags, PULONG pulCapabilities)
{
        HRESULT                                         Hr = NOERROR;
        ULONG                                           cbReturned;
        KSPROPERTY_VIDEOPROCAMP_S       VideoProperty;

        FX_ENTRY("CWDMCapDev::GetPropertyValue")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Inititalize video property structure
        ZeroMemory(&VideoProperty, sizeof(KSPROPERTY_VIDEOPROCAMP_S));

        VideoProperty.Property.Set   = guidPropertySet;      // KSPROPERTY_VIDEOPROCAMP_S/CAMERACONTRO_S
        VideoProperty.Property.Id    = ulPropertyId;         // KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
        VideoProperty.Property.Flags = KSPROPERTY_TYPE_GET;
        VideoProperty.Flags          = 0;

        // Get property value from driver
        if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &VideoProperty, sizeof(VideoProperty), &VideoProperty, sizeof(VideoProperty), &cbReturned, TRUE) == 0)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: This property is not supported by this minidriver/device", _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

        *plValue         = VideoProperty.Value;
        *pulFlags        = VideoProperty.Flags;
        *pulCapabilities = VideoProperty.Capabilities;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}


/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | GetDefaultValue | This function gets the
 *    default value of a video property of a capture device.
 *
 *  @parm GUID | guidPropertySet | GUID of the KS property set we are touching. It
 *    is either PROPSETID_VIDCAP_VIDEOPROCAMP or PROPSETID_VIDCAP_CAMERACONTROL.
 *
 *  @parm ULONG | ulPropertyId | ID of the property we are touching. It is
 *    either KSPROPERTY_VIDEOPROCAMP_* or KSPROPERTY_CAMERACONTROL_*.
 *
 *  @parm PLONG | plDefValue | Pointer to a LONG to receive the default value.
 ***************************************************************************/
HRESULT CWDMCapDev::GetDefaultValue(GUID guidPropertySet, ULONG ulPropertyId, PLONG plDefValue)
{
        HRESULT                         Hr = NOERROR;
        ULONG                           cbReturned;
        KSPROPERTY                      Property;
        PROCAMP_MEMBERSLIST     proList;

        FX_ENTRY("CWDMCapDev::GetDefaultValue")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Initialize property structures
        ZeroMemory(&Property, sizeof(KSPROPERTY));
        ZeroMemory(&proList, sizeof(PROCAMP_MEMBERSLIST));

        Property.Set   = guidPropertySet;
        Property.Id    = ulPropertyId;  // e.g. KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
        Property.Flags = KSPROPERTY_TYPE_DEFAULTVALUES;

        // Get the default values from the driver
        if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &(Property), sizeof(Property), &proList, sizeof(proList), &cbReturned, TRUE) == 0)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Couldn't *get* the current property of the control", _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

        // Sanity check
        if (proList.proDesc.DescriptionSize < sizeof(KSPROPERTY_DESCRIPTION))
        {
                Hr = E_FAIL;
        }
        else
        {
                *plDefValue = proList.ulData;
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}


/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | GetRangeValues | This function gets the
 *    range values of a video property of a capture device.
 *
 *  @parm GUID | guidPropertySet | GUID of the KS property set we are touching. It
 *    is either PROPSETID_VIDCAP_VIDEOPROCAMP or PROPSETID_VIDCAP_CAMERACONTROL.
 *
 *  @parm ULONG | ulPropertyId | ID of the property we are touching. It is
 *    either KSPROPERTY_VIDEOPROCAMP_* or KSPROPERTY_CAMERACONTROL_*.
 *
 *  @parm PLONG | plMin | Pointer to a LONG to receive the minimum value.
 *
 *  @parm PLONG | plMax | Pointer to a LONG to receive the maximum value.
 *
 *  @parm PLONG | plStep | Pointer to a LONG to receive the step value.
 ***************************************************************************/
HRESULT CWDMCapDev::GetRangeValues(GUID guidPropertySet, ULONG ulPropertyId, PLONG plMin, PLONG plMax, PLONG plStep)
{
        HRESULT                                 Hr = NOERROR;
        ULONG                                   cbReturned;
        KSPROPERTY                              Property;
        PROCAMP_MEMBERSLIST             proList;

        FX_ENTRY("CWDMCapDev::GetRangeValues")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Initialize property structures
        ZeroMemory(&Property, sizeof(KSPROPERTY));
        ZeroMemory(&proList, sizeof(PROCAMP_MEMBERSLIST));

        Property.Set   = guidPropertySet;
        Property.Id    = ulPropertyId;  // e.g. KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
        Property.Flags = KSPROPERTY_TYPE_BASICSUPPORT;

        // Get range values from the driver
        if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &(Property), sizeof(Property), &proList, sizeof(proList), &cbReturned, TRUE) == 0)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Couldn't *get* the range valuesof the control", _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: proList.proData.Bounds.SignedMinimum = %ld\r\n", _fx_, proList.proData.Bounds.SignedMinimum));
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: proList.proData.Bounds.SignedMaximum = %ld\r\n", _fx_, proList.proData.Bounds.SignedMaximum));
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: proList.proData.SteppingDelta = %ld\r\n", _fx_, proList.proData.SteppingDelta));
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: proList.proData2.Bounds.SignedMinimum = %ld\r\n", _fx_, proList.proData2.Bounds.SignedMinimum));
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: proList.proData2.Bounds.SignedMaximum = %ld\r\n", _fx_, proList.proData2.Bounds.SignedMaximum));
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: proList.proData2.SteppingDelta = %ld\r\n", _fx_, proList.proData2.SteppingDelta));

        *plMin  = proList.proData.Bounds.SignedMinimum;
        *plMax  = proList.proData.Bounds.SignedMaximum;
        *plStep = proList.proData.SteppingDelta;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | SetPropertyValue | This function sets the
 *    current value of a video property of a capture device.
 *
 *  @parm GUID | guidPropertySet | GUID of the KS property set we are touching. It
 *    is either PROPSETID_VIDCAP_VIDEOPROCAMP or PROPSETID_VIDCAP_CAMERACONTROL.
 *
 *  @parm ULONG | ulPropertyId | ID of the property we are touching. It is
 *    either KSPROPERTY_VIDEOPROCAMP_* or KSPROPERTY_CAMERACONTROL_*.
 *
 *  @parm LONG | lValue | New value.
 *
 *  @parm ULONG | ulFlags | New flags. We only care about KSPROPERTY_*_FLAGS_MANUAL
 *    or KSPROPERTY_*_FLAGS_AUTO.
 *
 *  @parm ULONG | ulCapabilities | New capabilities. We only care about
 *    KSPROPERTY_*_FLAGS_MANUAL or KSPROPERTY_*_FLAGS_AUTO.
 *
 *  @devnote KSPROPERTY_VIDEOPROCAMP_S == KSPROPERTY_CAMERACONTROL_S.
 ***************************************************************************/
HRESULT CWDMCapDev::SetPropertyValue(GUID guidPropertySet, ULONG ulPropertyId, LONG lValue, ULONG ulFlags, ULONG ulCapabilities)
{
        HRESULT                                         Hr = NOERROR;
        ULONG                                           cbReturned;
        KSPROPERTY_VIDEOPROCAMP_S       VideoProperty;

        FX_ENTRY("CWDMCapDev::SetPropertyValue")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Initialize property structure
        ZeroMemory(&VideoProperty, sizeof(KSPROPERTY_VIDEOPROCAMP_S) );

        VideoProperty.Property.Set   = guidPropertySet;      // KSPROPERTY_VIDEOPROCAMP_S/CAMERACONTRO_S
        VideoProperty.Property.Id    = ulPropertyId;         // KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS
        VideoProperty.Property.Flags = KSPROPERTY_TYPE_SET;

        VideoProperty.Flags        = ulFlags;
        VideoProperty.Value        = lValue;
        VideoProperty.Capabilities = ulCapabilities;

        // Set the property value on the driver
        if (DeviceIoControl(m_hDriver, IOCTL_KS_PROPERTY, &VideoProperty, sizeof(VideoProperty), &VideoProperty, sizeof(VideoProperty), &cbReturned, TRUE) == 0)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Couldn't *set* the value of the control", _fx_));
                Hr = E_FAIL;
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | GrabFrame | This method is used to
 *    grab a video frame from a VfW capture device.
 *
 *  @parm PVIDEOHDR | pVHdr | Specifies a pointer to a VIDEOHDR structure to
 *    receive the video frame.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CWDMCapDev::GrabFrame(PVIDEOHDR pVHdr)
{
        HRESULT                         Hr = NOERROR;
        DWORD                           bRtn;
        DWORD                           cbBytesReturned;
        KS_HEADER_AND_INFO      SHGetImage;

        FX_ENTRY("CWDMCapDev::GrabFrame")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pVHdr);
        if (!pVHdr || !pVHdr->lpData)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid pVHdr, pVHdr->lpData", _fx_));
                Hr = E_UNEXPECTED;
                goto MyExit;
        }

        // Defaults
        pVHdr->dwBytesUsed = 0UL;

        // Put the kernel streaming pin in streaming mode
        if (!Start())
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Cannot set kernel streaming state to KSSTATE_RUN!", _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

        // Initialize structure to do a read on the kernel streaming video pin
        ZeroMemory(&SHGetImage,sizeof(SHGetImage));
        SHGetImage.StreamHeader.Data = (LPDWORD)pVHdr->lpData;
        SHGetImage.StreamHeader.Size = sizeof (KS_HEADER_AND_INFO);
        SHGetImage.StreamHeader.FrameExtent = pVHdr->dwBufferLength;
        SHGetImage.FrameInfo.ExtendedHeaderSize = sizeof (KS_FRAME_INFO);

        // Grab a frame from the kernel streaming video pin
        bRtn = DeviceIoControl(m_hKSPin, IOCTL_KS_READ_STREAM, &SHGetImage, sizeof(SHGetImage), &SHGetImage, sizeof(SHGetImage), &cbBytesReturned);
        if (!(bRtn))
        {
            DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: DevIo rtn (%d), GetLastError=%d. StreamState->STOP", _fx_, bRtn, GetLastError()));

            // Stop streaming on the video pin
            if (!Stop())
            {
                    DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Cannot set kernel streaming state to KSSTATE_PAUSE/KSSTATE_STOP!", _fx_));
            }
            Hr = E_FAIL;
            goto MyExit;
        }

        // Sanity check
        ASSERT(SHGetImage.StreamHeader.FrameExtent >= SHGetImage.StreamHeader.DataUsed);
        if (SHGetImage.StreamHeader.FrameExtent < SHGetImage.StreamHeader.DataUsed)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: We've corrupted memory!", _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: Extended info for video buffer:", _fx_));
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   ExtendedHeaderSize=%ld", _fx_, SHGetImage.FrameInfo.ExtendedHeaderSize));
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   dwFrameFlags=0x%lX", _fx_, SHGetImage.FrameInfo.dwFrameFlags));
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   PictureNumber=%ld", _fx_, SHGetImage.FrameInfo.PictureNumber));
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   DropCount=%ld", _fx_, SHGetImage.FrameInfo.DropCount));
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Duration=%ld", _fx_, (DWORD)SHGetImage.StreamHeader.Duration));
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Presentation time:", _fx_));
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     Time=%ld", _fx_, (DWORD)SHGetImage.StreamHeader.PresentationTime.Time));
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     Numerator=%ld", _fx_, (DWORD)SHGetImage.StreamHeader.PresentationTime.Numerator));
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:     Denominator=%ld", _fx_, (DWORD)SHGetImage.StreamHeader.PresentationTime.Denominator));

        pVHdr->dwTimeCaptured = timeGetTime();
        pVHdr->dwBytesUsed  = SHGetImage.StreamHeader.DataUsed;
        pVHdr->dwFlags |= VHDR_KEYFRAME;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

#define BUF_PADDING 512 // required for 1394 allocations alignment

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | AllocateBuffer | This method is used to allocate
 *    a data buffer when video streaming from a VfW capture device.
 *
 *  @parm LPTHKVIDEOHDR * | pptvh | Specifies the address of a pointer to a
 *    THKVIDEOHDR structure to receive the video buffer.
 *
 *  @parm DWORD | dwIndex | Specifies the positional index of the video buffer.
 *
 *  @parm DWORD | cbBuffer | Specifies the size of the video buffer.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CWDMCapDev::AllocateBuffer(LPTHKVIDEOHDR *pptvh, DWORD dwIndex, DWORD cbBuffer)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CWDMCapDev::AllocateBuffer")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pptvh);
        ASSERT(cbBuffer);
        if (!pptvh || !cbBuffer)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid m_hVideoIn, pptvh, cbVHdr or cbBuffer!", _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

        *pptvh = &m_pCaptureFilter->m_cs.paHdr[dwIndex].tvh;
        (*pptvh)->vh.dwBufferLength = cbBuffer;
        if (!((*pptvh)->vh.lpData = new BYTE[cbBuffer + BUF_PADDING]))
        {
                Hr = E_FAIL;
                goto MyExit;
        }
        (*pptvh)->p32Buff = (*pptvh)->vh.lpData;

        ASSERT (!IsBadWritePtr((*pptvh)->p32Buff, cbBuffer + BUF_PADDING));
        ZeroMemory((*pptvh)->p32Buff,cbBuffer + BUF_PADDING);
        //save the start in the pStart member ...
        (*pptvh)->pStart  = (*pptvh)->vh.lpData;        //chg:1
        // now align to 512 both p32Buff and vh.lpData
        (*pptvh)->vh.lpData = (LPBYTE)ALIGNUP((*pptvh)->vh.lpData, BUF_PADDING);
        (*pptvh)->p32Buff   = (LPBYTE)ALIGNUP((*pptvh)->p32Buff, BUF_PADDING);

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | AddBuffer | This method is used to
 *    post a data buffer to a VfW capture device when video streaming.
 *
 *  @parm PVIDEOHDR | pVHdr | Specifies a pointer to a
 *    PVIDEOHDR structure identifying the video buffer.
 *
 *  @parm DWORD | cbVHdr | Specifies the size of the structure pointed to by
 *    the <p pVHdr> parameter.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CWDMCapDev::AddBuffer(PVIDEOHDR pVHdr, DWORD cbVHdr)
{
        HRESULT Hr = NOERROR;
        DWORD dwIndex;

        FX_ENTRY("CWDMCapDev::AddBuffer")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pVHdr);
        ASSERT(cbVHdr);
        ASSERT(m_fVideoOpen);
        if (!pVHdr || !cbVHdr || !m_fVideoOpen)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid pVHdr, cbVHdr, m_fVideoOpen", _fx_));
                Hr = E_UNEXPECTED;
                goto MyExit;
        }

    QueueHeader(pVHdr);

        // Which video streaming buffer are we talking about here?
        for (dwIndex=0; dwIndex < m_pCaptureFilter->m_cs.nHeaders; dwIndex++)
        {
                if (&m_pCaptureFilter->m_cs.paHdr[dwIndex].tvh.vh == pVHdr)
                        break;
        }

        // The video streaming buffer is done if .DataUsed has been initialized
        if (dwIndex != m_pCaptureFilter->m_cs.nHeaders)
        {
                QueueRead(m_pCaptureFilter->m_cs.paHdr[dwIndex].tvh.dwIndex);
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | FreeBuffer | This method is used to
 *    free a data buffer that was used with a VfW capture device in streaming
 *    mode.
 *
 *  @parm PVIDEOHDR | pVHdr | Specifies a pointer to a
 *    PVIDEOHDR structure identifying the video buffer.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CWDMCapDev::FreeBuffer(LPTHKVIDEOHDR pVHdr) // PVIDEOHDR pVHdr)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CWDMCapDev::FreeBuffer")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pVHdr);
        if (!pVHdr || !pVHdr->vh.lpData || !pVHdr->p32Buff || !pVHdr->pStart)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid pVHdr or pVHdr->vh.lpData or pVHdr->pStart!", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        //dprintf("pVHdr->lpData = %p , pVHdr->p32Buff = %p , pVHdr->pStart = %p\n",pVHdr->vh.lpData , pVHdr->p32Buff , pVHdr->pStart);
        //the original code is bad anyway:
        //delete pVHdr->lpData, pVHdr->lpData = NULL; //wrong: lpData might be aligned

        delete pVHdr->pStart, pVHdr->pStart = pVHdr->p32Buff = pVHdr->vh.lpData = NULL;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | AllocateHeaders | This method is used to
 *    video headers for data buffers used with a WDM capture device in streaming
 *    mode.
 *
 *  @parm DWORD | dwNumHdrs | Specifies the number of video headers to allocate.
 *
 *  @parm DWORD | cbHdr | Specifies the size of the video headers to allocate.
 *
 *  @parm LPVOID* | ppaHdr | Specifies the address of a pointer to receive
 *    the video headers allocated.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CWDMCapDev::AllocateHeaders(DWORD dwNumHdrs, DWORD cbHdr, LPVOID *ppaHdr)
{
        HRESULT Hr = NOERROR;
        CaptureMode cm;
#if defined(DEBUG) && defined(DEBUG_STREAMING)
        // @todo Remove this before checkin!
        char szDebug[128];
#endif

        FX_ENTRY("CWDMCapDev::AllocateHeaders")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(ppaHdr);
        ASSERT(cbHdr);
        if (!ppaHdr || !cbHdr)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid m_hVideoIn, cbHdr or ppaHdr!", _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

        if (!(*ppaHdr = new BYTE[cbHdr * dwNumHdrs]))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory!", _fx_));
                Hr = E_OUTOFMEMORY;
        goto MyExit;
        }

        m_cntNumVidBuf = dwNumHdrs;
        m_lpVHdrFirst = NULL;
        m_lpVHdrLast  = NULL;

        ZeroMemory(*ppaHdr, cbHdr * dwNumHdrs);
        if(m_bCached_vcdi)
                cm = m_vcdi.nCaptureMode;
        else
                cm = g_aDeviceInfo[m_dwDeviceIndex].nCaptureMode;

        if ( cm == CaptureMode_Streaming)
        {
                for (dwNumHdrs = 0; dwNumHdrs < m_cntNumVidBuf; dwNumHdrs++)
                {
                        QueueHeader((LPVIDEOHDR)((LPBYTE)*ppaHdr + cbHdr * dwNumHdrs));
#if defined(DEBUG) && defined(DEBUG_STREAMING)
                        wsprintf(szDebug, "Allocating and queueing pVideoHdr=0x%08lX\n", (LPVIDEOHDR)((LPBYTE)*ppaHdr + cbHdr * dwNumHdrs));
                        OutputDebugString(szDebug);
#endif
                }
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc BOOL | CWDMCapDev | Start | This function puts the kernel streaming
 *    video pin in streaming mode.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMCapDev::Start()
{
        ASSERT(m_hKSPin);

        if (m_fStarted)
                return TRUE;

        if (SetState(KSSTATE_PAUSE))
                m_fStarted = SetState(KSSTATE_RUN);

        return m_fStarted;
}

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc BOOL | CWDMCapDev | Stop | This function stops streaming on the
 *    kernel streaming video pin.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMCapDev::Stop()
{
        ASSERT(m_hKSPin);

        if (m_fStarted)
        {
                if (SetState(KSSTATE_PAUSE))
                        if (SetState(KSSTATE_STOP))
                                m_fStarted = FALSE;
        }

        return (BOOL)(m_fStarted == FALSE);
}

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc BOOL | CWDMCapDev | SetState | This function sets the state of the
 *    kernel streaming video pin.
 *
 *  @parm KSSTATE | ksState | New state.
 *
 *  @rdesc Returns TRUE if successful, or FALSE otherwise.
 ***************************************************************************/
BOOL CWDMCapDev::SetState(KSSTATE ksState)
{
        KSPROPERTY      ksProp = {0};
        DWORD           cbRet;

        ASSERT(m_hKSPin);

        ksProp.Set              = KSPROPSETID_Connection;
        ksProp.Id               = KSPROPERTY_CONNECTION_STATE;
        ksProp.Flags    = KSPROPERTY_TYPE_SET;

        return DeviceIoControl(m_hKSPin, IOCTL_KS_PROPERTY, &ksProp, sizeof(ksProp), &ksState, sizeof(KSSTATE), &cbRet);
}

/****************************************************************************
 *  @doc INTERNAL CWDMCAPDEVMETHOD
 *
 *  @mfunc BOOL | CWDMCapDev | IsBufferDone | This method is used to
 *    check the DONE status of a video streaming buffer.
 *
 *  @parm PVIDEOHDR | pVHdr | Specifies a pointer to a
 *    PVIDEOHDR structure identifying the video buffer.
 *
 *  @rdesc This method returns TRUE if the buffer is DONE, FALSE otherwise.
 ***************************************************************************/
BOOL CWDMCapDev::IsBufferDone(PVIDEOHDR pVHdr)
{
        DWORD dwIndex;

        FX_ENTRY("CWDMCapDev::IsBufferDone")

        // Validate input parameter
        ASSERT(pVHdr);
        if (!pVHdr)
                return FALSE;

        // Which video streaming buffer are we talking about here?
        for (dwIndex=0; dwIndex < m_cntNumVidBuf; dwIndex++)
        {
                if (m_pWDMVideoBuff[dwIndex].pVideoHdr == pVHdr)
                        break;
        }


        if(dwIndex == m_cntNumVidBuf) { DWORD i;
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: pVHdr %p not found among m_pWDMVideoBuff[0..%d].pVideoHdr values", _fx_,pVHdr,m_cntNumVidBuf));
                for(i=0; i<m_cntNumVidBuf; i++)
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: m_pWDMVideoBuff[%d].pVideoHdr %p", _fx_,i,m_pWDMVideoBuff[i].pVideoHdr));
#if defined(DEBUG) && defined(DEBUG_STREAMING)
                ASSERT(dwIndex < m_cntNumVidBuf);
#endif
        }

        // The video streaming buffer is done if .DataUsed has been initialized
        if ((dwIndex != m_cntNumVidBuf) && m_pWDMVideoBuff[dwIndex].SHGetImage.StreamHeader.DataUsed)
        {
            pVHdr->dwFlags |= VHDR_DONE;
                pVHdr->dwBytesUsed = m_pWDMVideoBuff[dwIndex].SHGetImage.StreamHeader.DataUsed;
                if ((m_pWDMVideoBuff[dwIndex].SHGetImage.FrameInfo.dwFrameFlags & 0x00f0) == KS_VIDEO_FLAG_I_FRAME)
                        pVHdr->dwFlags |= VHDR_KEYFRAME;
                return TRUE;
        }
        else
        {
                return FALSE;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\formats.h ===
/****************************************************************************
 *  @doc INTERNAL FORMATS
 *
 *  @module Formats.h | Header file for the <c CCapturePin> and <c CPreviewPin>
 *    class methods used to implement the video capture and preview output
 *    pin format manipulations. This includes the <i IAMStreamConfig>
 *    interface methods.
 *
 *  @todo That'a whole lot of const data. Do this dynamically whenever
 *    appropriate.
 ***************************************************************************/

#ifndef _FORMATS_H_
#define _FORMATS_H_

// #define USE_OLD_FORMAT_DEFINITION 1

// Video subtypes
#define STATIC_MEDIASUBTYPE_H263_V1 0x3336324DL, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71
#define STATIC_MEDIASUBTYPE_H261 0x3136324DL, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71
#define STATIC_MEDIASUBTYPE_H263_V2 0x3336324EL, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71
#define STATIC_MEDIASUBTYPE_RGB24 0xe436eb7d, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
#define STATIC_MEDIASUBTYPE_RGB16 0xe436eb7c, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
#define STATIC_MEDIASUBTYPE_RGB8 0xe436eb7a, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
#define STATIC_MEDIASUBTYPE_RGB4 0xe436eb79, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70

// Video FourCCs
#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )                                \
                ( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |    \
                ( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif
#define FOURCC_M263     mmioFOURCC('M', '2', '6', '3')
#define FOURCC_M261     mmioFOURCC('M', '2', '6', '1')
#define FOURCC_N263     mmioFOURCC('N', '2', '6', '3')

// List of capture formats supported
#define MAX_FRAME_INTERVAL 10000000L
#define MIN_FRAME_INTERVAL 333333L
#define STILL_FRAME_INTERVAL 10000000

#define NUM_H245VIDEOCAPABILITYMAPS 5
#define NUM_RATES_PER_RESOURCE 5
#define NUM_ITU_SIZES 3
#define QCIF_SIZE 0
#define CIF_SIZE 1
#define SQCIF_SIZE 2

#define R263_QCIF_H245_CAPID 0UL
#define R263_CIF_H245_CAPID 1UL
#define R263_SQCIF_H245_CAPID 2UL
#define R261_QCIF_H245_CAPID 3UL
#define R261_CIF_H245_CAPID 4UL

/*****************************************************************************
 * @doc EXTERNAL CONSTANTS
 *
 * @const WAVE_FORMAT_UNKNOWN | VIDEO_FORMAT_UNKNOWN | Constant for unknown video format.
 *
 * @const BI_RGB | VIDEO_FORMAT_BI_RGB | RGB video format.
 *
 * @const BI_RLE8 | VIDEO_FORMAT_BI_RLE8 | RLE 8 video format.
 *
 * @const BI_RLE4 | VIDEO_FORMAT_BI_RLE4 | RLE 4 video format.
 *
 * @const BI_BITFIELDS | VIDEO_FORMAT_BI_BITFIELDS | RGB Bit Fields video format.
 *
 * @const MAKEFOURCC('c','v','i','d') | VIDEO_FORMAT_CVID | Cinepack video format.
 *
 * @const MAKEFOURCC('I','V','3','2') | VIDEO_FORMAT_IV32 | Intel Indeo IV32 video format.
 *
 * @const MAKEFOURCC('Y','V','U','9') | VIDEO_FORMAT_YVU9 | Intel Indeo YVU9 video format.
 *
 * @const MAKEFOURCC('M','S','V','C') | VIDEO_FORMAT_MSVC | Microsoft CRAM video format.
 *
 * @const MAKEFOURCC('M','R','L','E') | VIDEO_FORMAT_MRLE | Microsoft RLE video format.
 *
 * @const MAKEFOURCC('h','2','6','3') | VIDEO_FORMAT_INTELH263 | Intel H.263 video format.
 *
 * @const MAKEFOURCC('h','2','6','1') | VIDEO_FORMAT_INTELH261 | Intel H.261 video format.
 *
 * @const MAKEFOURCC('M','2','6','3') | VIDEO_FORMAT_MSH263 | Microsoft H.263 video format.
 *
 * @const MAKEFOURCC('M','2','6','1') | VIDEO_FORMAT_MSH261 | Microsoft H.261 video format.
 *
 * @const MAKEFOURCC('V','D','E','C') | VIDEO_FORMAT_VDEC | Color QuickCam video format.
 *
 ****************************************************************************/
#define VIDEO_FORMAT_UNKNOWN            WAVE_FORMAT_UNKNOWN

#define VIDEO_FORMAT_BI_RGB                     BI_RGB
#define VIDEO_FORMAT_BI_RLE8            BI_RLE8
#define VIDEO_FORMAT_BI_RLE4            BI_RLE4
#define VIDEO_FORMAT_BI_BITFIELDS       BI_BITFIELDS
#define VIDEO_FORMAT_CVID                       MAKEFOURCC('C','V','I','D')     // hex: 0x44495643
#define VIDEO_FORMAT_IV31                       MAKEFOURCC('I','V','3','1')     // hex: 0x31335649
#define VIDEO_FORMAT_IV32                       MAKEFOURCC('I','V','3','2')     // hex: 0x32335649
#define VIDEO_FORMAT_YVU9                       MAKEFOURCC('Y','V','U','9')     // hex: 0x39555659
#define VIDEO_FORMAT_I420                       MAKEFOURCC('I','4','2','0')
#define VIDEO_FORMAT_IYUV                       MAKEFOURCC('I','Y','U','V')
#define VIDEO_FORMAT_MSVC                       MAKEFOURCC('M','S','V','C')     // hex: 0x4356534d
#define VIDEO_FORMAT_MRLE                       MAKEFOURCC('M','R','L','E')     // hex: 0x454c524d
#define VIDEO_FORMAT_INTELH263          MAKEFOURCC('H','2','6','3')     // hex: 0x33363248
#define VIDEO_FORMAT_INTELH261          MAKEFOURCC('H','2','6','1')     // hex: 0x31363248
#define VIDEO_FORMAT_INTELI420          MAKEFOURCC('I','4','2','0')     // hex: 0x30323449
#define VIDEO_FORMAT_INTELRT21          MAKEFOURCC('R','T','2','1')     // hex: 0x31325452
#define VIDEO_FORMAT_MSH263                     MAKEFOURCC('M','2','6','3')     // hex: 0x3336324d
#define VIDEO_FORMAT_MSH261                     MAKEFOURCC('M','2','6','1')     // hex: 0x3136324d
#if !defined(_ALPHA_) && defined(USE_BILINEAR_MSH26X)
#define VIDEO_FORMAT_MSH26X                     MAKEFOURCC('M','2','6','X')     // hex: 0x5836324d
#endif
#define VIDEO_FORMAT_Y411                       MAKEFOURCC('Y','4','1','1')     // hex:
#define VIDEO_FORMAT_YUY2                       MAKEFOURCC('Y','U','Y','2')     // hex:
#define VIDEO_FORMAT_YVYU                       MAKEFOURCC('Y','V','Y','U')     // hex:
#define VIDEO_FORMAT_UYVY                       MAKEFOURCC('U','Y','V','Y')     // hex:
#define VIDEO_FORMAT_Y211                       MAKEFOURCC('Y','2','1','1')     // hex:
// VDOnet VDOWave codec
#define VIDEO_FORMAT_VDOWAVE            MAKEFOURCC('V','D','O','W')     // hex:
// Color QuickCam video codec
#define VIDEO_FORMAT_VDEC                       MAKEFOURCC('V','D','E','C')     // hex: 0x43454456
// Dec Alpha
#define VIDEO_FORMAT_DECH263            MAKEFOURCC('D','2','6','3')     // hex: 0x33363248
#define VIDEO_FORMAT_DECH261            MAKEFOURCC('D','2','6','1')     // hex: 0x31363248
// MPEG4 Scrunch codec
#ifdef USE_MPEG4_SCRUNCH
#define VIDEO_FORMAT_MPEG4_SCRUNCH      MAKEFOURCC('M','P','G','4')     // hex:
#endif

/*****************************************************************************
 * @doc EXTERNAL CONSTANTS
 *
 * @const 16 | NUM_4BIT_ENTRIES | Number of entries in a 4bit palette.
 *
 * @const 256 | NUM_8BIT_ENTRIES | Number of entries in an 8bit palette.
 *
 ****************************************************************************/
#define NUM_4BIT_ENTRIES 16
#define NUM_8BIT_ENTRIES 256

// dwImageSize of VIDEOINCAPS
/*****************************************************************************
 * @doc EXTERNAL CONSTANTS
 *
 * @const 27 | VIDEO_FORMAT_NUM_IMAGE_SIZE | Number of video input sizes used by the device.
 *
 * @const 0x00000001 | VIDEO_FORMAT_IMAGE_SIZE_40_30 | Video input device uses 40x30 pixel frames.
 *
 * @const 0x00000002 | VIDEO_FORMAT_IMAGE_SIZE_64_48 | Video input device uses 64x48 pixel frames.
 *
 * @const 0x00000004 | VIDEO_FORMAT_IMAGE_SIZE_80_60 | Video input device uses 80x60 pixel frames.
 *
 * @const 0x00000008 | VIDEO_FORMAT_IMAGE_SIZE_96_64 | Video input device uses 96x64 pixel frames.
 *
 * @const 0x00000010 | VIDEO_FORMAT_IMAGE_SIZE_112_80 | Video input device uses 112x80 pixel frames.
 *
 * @const 0x00000020 | VIDEO_FORMAT_IMAGE_SIZE_120_90 | Video input device uses 120x90 pixel frames.
 *
 * @const 0x00000040 | VIDEO_FORMAT_IMAGE_SIZE_128_96 | Video input device uses 128x96 (SQCIF) pixel frames.
 *
 * @const 0x00000080 | VIDEO_FORMAT_IMAGE_SIZE_144_112 | Video input device uses 144x112 pixel frames.
 *
 * @const 0x00000100 | VIDEO_FORMAT_IMAGE_SIZE_160_120 | Video input device uses 160x120 pixel frames.
 *
 * @const 0x00000200 | VIDEO_FORMAT_IMAGE_SIZE_160_128 | Video input device uses 160x128 pixel frames.
 *
 * @const 0x00000400 | VIDEO_FORMAT_IMAGE_SIZE_176_144 | Video input device uses 176x144 (QCIF) pixel frames.
 *
 * @const 0x00000800 | VIDEO_FORMAT_IMAGE_SIZE_192_160 | Video input device uses 192x160 pixel frames.
 *
 * @const 0x00001000 | VIDEO_FORMAT_IMAGE_SIZE_200_150 | Video input device uses 200x150 pixel frames.
 *
 * @const 0x00002000 | VIDEO_FORMAT_IMAGE_SIZE_208_176 | Video input device uses 208x176 pixel frames.
 *
 * @const 0x00004000 | VIDEO_FORMAT_IMAGE_SIZE_224_192 | Video input device uses 224x192 pixel frames.
 *
 * @const 0x00008000 | VIDEO_FORMAT_IMAGE_SIZE_240_180 | Video input device uses 240x180 pixel frames.
 *
 * @const 0x00010000 | VIDEO_FORMAT_IMAGE_SIZE_240_208 | Video input device uses 240x208 pixel frames.
 *
 * @const 0x00020000 | VIDEO_FORMAT_IMAGE_SIZE_256_224 | Video input device uses 256x224 pixel frames.
 *
 * @const 0x00040000 | VIDEO_FORMAT_IMAGE_SIZE_272_240 | Video input device uses 272x240 pixel frames.
 *
 * @const 0x00080000 | VIDEO_FORMAT_IMAGE_SIZE_280_210 | Video input device uses 280x210 pixel frames.
 *
 * @const 0x00100000 | VIDEO_FORMAT_IMAGE_SIZE_288_256 | Video input device uses 288x256 pixel frames.
 *
 * @const 0x00200000 | VIDEO_FORMAT_IMAGE_SIZE_304_272 | Video input device uses 304x272 pixel frames.
 *
 * @const 0x00400000 | VIDEO_FORMAT_IMAGE_SIZE_320_240 | Video input device uses 320x240 pixel frames.
 *
 * @const 0x00800000 | VIDEO_FORMAT_IMAGE_SIZE_320_288 | Video input device uses 320x288 pixel frames.
 *
 * @const 0x01000000 | VIDEO_FORMAT_IMAGE_SIZE_336_288 | Video input device uses 336x288 pixel frames.
 *
 * @const 0x02000000 | VIDEO_FORMAT_IMAGE_SIZE_352_288 | Video input device uses 352x288 (CIF) pixel frames.
 *
 * @const 0x04000000 | VIDEO_FORMAT_IMAGE_SIZE_640_480 | Video input device uses 640x480 pixel frames.
 *
 ****************************************************************************/
#define VIDEO_FORMAT_NUM_IMAGE_SIZE     27

#define VIDEO_FORMAT_IMAGE_SIZE_40_30   0x00000001
#define VIDEO_FORMAT_IMAGE_SIZE_64_48   0x00000002
#define VIDEO_FORMAT_IMAGE_SIZE_80_60   0x00000004
#if !defined(_ALPHA_) && defined(USE_BILINEAR_MSH26X)
#define VIDEO_FORMAT_IMAGE_SIZE_80_64   0x00000008
#else
#define VIDEO_FORMAT_IMAGE_SIZE_96_64   0x00000008
#endif
#define VIDEO_FORMAT_IMAGE_SIZE_112_80  0x00000010
#define VIDEO_FORMAT_IMAGE_SIZE_120_90  0x00000020
#define VIDEO_FORMAT_IMAGE_SIZE_128_96  0x00000040
#define VIDEO_FORMAT_IMAGE_SIZE_144_112 0x00000080
#define VIDEO_FORMAT_IMAGE_SIZE_160_120 0x00000100
#define VIDEO_FORMAT_IMAGE_SIZE_160_128 0x00000200
#define VIDEO_FORMAT_IMAGE_SIZE_176_144 0x00000400
#define VIDEO_FORMAT_IMAGE_SIZE_192_160 0x00000800
#define VIDEO_FORMAT_IMAGE_SIZE_200_150 0x00001000
#define VIDEO_FORMAT_IMAGE_SIZE_208_176 0x00002000
#define VIDEO_FORMAT_IMAGE_SIZE_224_192 0x00004000
#define VIDEO_FORMAT_IMAGE_SIZE_240_180 0x00008000
#define VIDEO_FORMAT_IMAGE_SIZE_240_208 0x00010000
#define VIDEO_FORMAT_IMAGE_SIZE_256_224 0x00020000
#define VIDEO_FORMAT_IMAGE_SIZE_272_240 0x00040000
#define VIDEO_FORMAT_IMAGE_SIZE_280_210 0x00080000
#define VIDEO_FORMAT_IMAGE_SIZE_288_256 0x00100000
#define VIDEO_FORMAT_IMAGE_SIZE_304_272 0x00200000
#define VIDEO_FORMAT_IMAGE_SIZE_320_240 0x00400000
#define VIDEO_FORMAT_IMAGE_SIZE_320_288 0x00800000
#define VIDEO_FORMAT_IMAGE_SIZE_336_288 0x01000000
#define VIDEO_FORMAT_IMAGE_SIZE_352_288 0x02000000
#define VIDEO_FORMAT_IMAGE_SIZE_640_480 0x04000000

#define VIDEO_FORMAT_IMAGE_SIZE_USE_DEFAULT 0x80000000

// dwNumColors of VIDEOINCAPS
/*****************************************************************************
 * @doc EXTERNAL CONSTANTS
 *
 * @const 0x00000001 | VIDEO_FORMAT_NUM_COLORS_16 | Video input device uses 16 colors.
 *
 * @const 0x00000002 | VIDEO_FORMAT_NUM_COLORS_256 | Video input device uses 256 colors.
 *
 * @const 0x00000004 | VIDEO_FORMAT_NUM_COLORS_65536 | Video input device uses 65536 colors.
 *
 * @const 0x00000008 | VIDEO_FORMAT_NUM_COLORS_16777216 | Video input device uses 16777216 colors.
 *
 * @const 0x00000010 | VIDEO_FORMAT_NUM_COLORS_YVU9 | Video input device uses the YVU9 compressed format.
 *
 * @const 0x00000020 | VIDEO_FORMAT_NUM_COLORS_I420 | Video input device uses the I420 compressed format.
 *
 * @const 0x00000040 | VIDEO_FORMAT_NUM_COLORS_IYUV | Video input device uses the IYUV compressed format.
 *
 * @const 0x00000080 | VIDEO_FORMAT_NUM_COLORS_YUY2 | Video input device uses the YUY2 compressed format.
 *
 * @const 0x00000100 | VIDEO_FORMAT_NUM_COLORS_UYVY | Video input device uses the UYVY compressed format.
 *
 * @const 0x00000200 | VIDEO_FORMAT_NUM_COLORS_M261 | Video input device uses the M261 compressed format.
 *
 * @const 0x00000400 | VIDEO_FORMAT_NUM_COLORS_M263 | Video input device uses the M263 compressed format.
 ****************************************************************************/
#define VIDEO_FORMAT_NUM_COLORS_16                      0x00000001
#define VIDEO_FORMAT_NUM_COLORS_256                     0x00000002
#define VIDEO_FORMAT_NUM_COLORS_65536           0x00000004
#define VIDEO_FORMAT_NUM_COLORS_16777216        0x00000008
#define VIDEO_FORMAT_NUM_COLORS_YVU9            0x00000010
#define VIDEO_FORMAT_NUM_COLORS_I420            0x00000020
#define VIDEO_FORMAT_NUM_COLORS_IYUV            0x00000040
#define VIDEO_FORMAT_NUM_COLORS_YUY2            0x00000080
#define VIDEO_FORMAT_NUM_COLORS_UYVY            0x00000100
#define VIDEO_FORMAT_NUM_COLORS_MSH261          0x00000200
#define VIDEO_FORMAT_NUM_COLORS_MSH263          0x00000400

// dwDialogs of VIDEOINCAPS
/*****************************************************************************
 * @doc EXTERNAL CONSTANTS
 *
 * @const 0x00000000 | FORMAT_DLG_OFF | Disable video format dialog.
 *
 * @const 0x00000000 | SOURCE_DLG_OFF | Disable source dialog.
 *
 * @const 0x00000000 | DISPLAY_DLG_OFF | Disable display dialog.
 *
 * @const 0x00000001 | FORMAT_DLG_ON | Enable video format dialog.
 *
 * @const 0x00000002 | SOURCE_DLG_ON | Enable source dialog.
 *
 * @const 0x00000002 | DISPLAY_DLG_ON | Enable display dialog.
 ****************************************************************************/
#define FORMAT_DLG_OFF  0x00000000
#define SOURCE_DLG_OFF  0x00000000
#define DISPLAY_DLG_OFF 0x00000000
#define FORMAT_DLG_ON   0x00000001
#define SOURCE_DLG_ON   0x00000002
#define DISPLAY_DLG_ON  0x00000004

// dwStreamingMode of VIDEOINCAPS
/*****************************************************************************
 * @doc EXTERNAL CONSTANTS
 *
 * @const 0x00000000 | STREAM_ALL_SIZES | Use streaming mode at all sizes.
 *
 * @const 0x00000001 | FRAME_GRAB_LARGE_SIZE | Use streaming mode at all but large size (>= 320x240).
 *
 * @const 0x00000002 | FRAME_GRAB_ALL_SIZES | Use frame grabbing mode at all sizes.
 ****************************************************************************/
#define STREAM_ALL_SIZES                0x00000000
#define FRAME_GRAB_LARGE_SIZE   0x00000001
#define FRAME_GRAB_ALL_SIZES    0x00000002

// TAPI Reg keys for capture device formats
#define RTCKEYROOT HKEY_CURRENT_USER
#define szRegDeviceKey          TEXT("SOFTWARE\\Microsoft\\Conferencing\\CaptureDevices")
#define szRegCaptureDefaultKey  TEXT("SOFTWARE\\Microsoft\\Conferencing\\CaptureDefaultFormats")
#define szRegRTCKey             TEXT("SOFTWARE\\Microsoft\\RTC\\VideoCapture")
#define szRegConferencingKey    TEXT("SOFTWARE\\Microsoft\\Conferencing")
#define szRegdwImageSizeKey       TEXT("dwImageSize")
#define szRegdwNumColorsKey       TEXT("dwNumColors")
#define szRegdwStreamingModeKey   TEXT("dwStreamingMode")
#define szRegdwDialogsKey         TEXT("dwDialogs")
// WinSE #28804, regarding Sony MPEG2 R-Engine
#define szRegdwDoNotUseDShow    TEXT("DoNotUseDShow")
#define SONY_MOTIONEYE_CAM_NAME TEXT("Sony MPEG2 R-Engine")
// @todo Use the two following keys or get rid of them
#define szRegbmi4bitColorsKey   TEXT("bmi4bitColors")
#define szRegbmi8bitColorsKey   TEXT("bmi8bitColors")

#define szDisableYUY2VFlipKey   TEXT("dwDisableYUY2VFlip")

// The order of the bit depths matches what I think is the
// preferred format if more than one is supported.
// For color, 16bit is almost as good as 24 but uses less memory
// and is faster for color QuickCam.
// For greyscale, 16 greyscale levels is Ok, not as good as 64,
// but Greyscale QuickCam is too slow at 64 levels.
#define NUM_BITDEPTH_ENTRIES 11
#define VIDEO_FORMAT_NUM_RESOLUTIONS 6
#define MAX_VERSION 80
extern const WORD aiBitDepth[NUM_BITDEPTH_ENTRIES];
extern const DWORD aiFormat[NUM_BITDEPTH_ENTRIES];
extern const DWORD aiFourCCCode[NUM_BITDEPTH_ENTRIES];
extern const DWORD aiClrUsed[NUM_BITDEPTH_ENTRIES];

typedef struct
{
    DWORD dwRes;
    SIZE framesize;
} MYFRAMESIZE;

extern const MYFRAMESIZE awResolutions[VIDEO_FORMAT_NUM_RESOLUTIONS];

extern const AM_MEDIA_TYPE* const CaptureFormats[];
extern const VIDEO_STREAM_CONFIG_CAPS* const CaptureCaps[];
extern const AM_MEDIA_TYPE* const Preview_RGB24_Formats[];
extern const VIDEO_STREAM_CONFIG_CAPS* const Preview_RGB24_Caps[];
extern const AM_MEDIA_TYPE* const Preview_RGB16_Formats[];
extern const VIDEO_STREAM_CONFIG_CAPS* const Preview_RGB16_Caps[];
extern AM_MEDIA_TYPE* Preview_RGB8_Formats[];
extern const VIDEO_STREAM_CONFIG_CAPS* const Preview_RGB8_Caps[];
extern AM_MEDIA_TYPE* Preview_RGB4_Formats[];
extern const VIDEO_STREAM_CONFIG_CAPS* const Preview_RGB4_Caps[];
extern const AM_MEDIA_TYPE* const Rtp_Pd_Formats[];
extern const RTP_PD_CONFIG_CAPS* const Rtp_Pd_Caps[];
extern const DWORD RTPPayloadTypes[];

#define NUM_RGB24_PREVIEW_FORMATS       3
#define NUM_RGB16_PREVIEW_FORMATS       3
#define NUM_RGB8_PREVIEW_FORMATS        3
#define NUM_RGB4_PREVIEW_FORMATS        3
#define NUM_CAPTURE_FORMATS                     5
#define NUM_RTP_PD_FORMATS                      4

// RTP packetization descriptor formats
#define VERSION_1 1UL
#define H263_PAYLOAD_TYPE 34UL
#define H261_PAYLOAD_TYPE 31UL

#endif // _FORMATS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\fpsrate.cpp ===
/****************************************************************************
 *  @doc INTERNAL FPSRATE
 *
 *  @module FpsRate.cpp | Source file for the <c CTAPIBasePin> and <c CPreviewPin>
 *    class methods used to implement the video capture and preview output
 *    pins frame rate control methods.
 ***************************************************************************/

#include "Precomp.h"

/****************************************************************************
 *  @doc INTERNAL CFPSCMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | Set | This method is used to set the
 *    value of a frame rate control property.
 *
 *  @parm FrameRateControlProperty | Property | Used to specifiy the property
 *    to set the value of.
 *
 *  @parm long | lValue | Used to specify the value to set on the property.
 *
 *  @parm TAPIControlFlags | lFlags | Used to specify the flags to set on
 *    the property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::Set(IN FrameRateControlProperty Property, IN long lValue, IN TAPIControlFlags lFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIOutputPin::Set (FrameRateControlProperty)")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(lValue >= m_lAvgTimePerFrameRangeMin);
	ASSERT(lValue <= m_lAvgTimePerFrameRangeMax);
	ASSERT(Property >= FrameRateControl_Maximum && Property <= FrameRateControl_Current);

	// Set relevant values
	if (Property == FrameRateControl_Maximum)
	{
		if (!lValue || lValue < m_lAvgTimePerFrameRangeMin || lValue > m_lAvgTimePerFrameRangeMax)
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
			Hr = E_INVALIDARG;
			goto MyExit;
		}
		m_lMaxAvgTimePerFrame = lValue;
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   New target frame rate: %ld.%ld fps", _fx_, 10000000/m_lMaxAvgTimePerFrame, 1000000000/m_lMaxAvgTimePerFrame - (10000000/m_lMaxAvgTimePerFrame) * 100));
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
		Hr = E_PROP_ID_UNSUPPORTED;
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CFPSCMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | Get | This method is used to retrieve
 *    the value of the current or maximum frame rate advertized.
 *
 *  @parm FrameRateControlProperty | Property | Used to specifiy the property
 *    to retrieve the value of.
 *
 *  @parm long* | plValue | Used to receive the value of the property, in
 *    100-nanosecond units.
 *
 *  @parm TAPIControlFlags* | plFlags | Used to receive the value of the flag
 *    associated to the property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::Get(IN FrameRateControlProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIOutputPin::Get (FrameRateControlProperty)")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(plValue);
	ASSERT(plFlags);
	if (!plValue || !plFlags)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT(Property >= FrameRateControl_Maximum && Property <= FrameRateControl_Current);

	// Return relevant values
	*plFlags = TAPIControl_Flags_None;
	if (Property == FrameRateControl_Maximum)
		*plValue = m_lMaxAvgTimePerFrame;
	else if (Property == FrameRateControl_Current)
		*plValue = m_lCurrentAvgTimePerFrame;
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid Property argument", _fx_));
		Hr = E_PROP_ID_UNSUPPORTED;
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CFPSCMETHOD
 *
 *  @mfunc HRESULT | CTAPIBasePin | GetRange | This method is used to
 *    retrieve support, minimum, maximum, and default values of the current
 *    or maximum frame rate advertized.
 *
 *  @parm FrameRateControlProperty | Property | Used to specifiy the property
 *    to retrieve the range values of.
 *
 *  @parm long* | plMin | Used to retrieve the minimum value of the
 *    property, in 100-nanosecond units.
 *
 *  @parm long* | plMax | Used to retrieve the maximum value of the
 *    property, in 100-nanosecond units.
 *
 *  @parm long* | plSteppingDelta | Used to retrieve the stepping delta
 *    of the property, in 100-nanosecond units.
 *
 *  @parm long* | plDefault | Used to retrieve the default value of the
 *    property, in 100-nanosecond units.
 *
 *  @parm TAPIControlFlags* | plCApsFlags | Used to receive the flags
 *    suppported by the property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CTAPIBasePin::GetRange(IN FrameRateControlProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CTAPIOutputPin::GetRange (FrameRateControlProperty)")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(plMin);
	ASSERT(plMax);
	ASSERT(plSteppingDelta);
	ASSERT(plDefault);
	ASSERT(plCapsFlags);
	if (!plMin || !plMax || !plSteppingDelta || !plDefault || !plCapsFlags)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT(Property >= FrameRateControl_Maximum && Property <= FrameRateControl_Current);
	if (Property != FrameRateControl_Maximum && Property != FrameRateControl_Current)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid Property argument", _fx_));
		Hr = E_PROP_ID_UNSUPPORTED;
		goto MyExit;
	}

	// Return relevant values
	*plCapsFlags = TAPIControl_Flags_None;
	*plMin = m_lAvgTimePerFrameRangeMin;
	*plMax = m_lAvgTimePerFrameRangeMax;
	*plSteppingDelta = m_lAvgTimePerFrameRangeSteppingDelta;
	*plDefault = m_lAvgTimePerFrameRangeDefault;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   Ranges: Min=%ld, Max=%ld, Step=%ld, Default=%ld", _fx_, m_lAvgTimePerFrameRangeMin, m_lAvgTimePerFrameRangeMax, m_lAvgTimePerFrameRangeSteppingDelta, m_lAvgTimePerFrameRangeDefault));

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\h245vidc.cpp ===
/****************************************************************************
 *  @doc INTERNAL H245VIDC
 *
 *  @module H245VidC.cpp | Source file for the <c CCapturePin> class methods
 *    used to implement the <i IH245Capability> TAPI inteface.
 *
 *  @comm For now, use the NM heuristics.
 ***************************************************************************/

#include "Precomp.h"

/****************************************************************************
 *  @doc INTERNAL CH245VIDCMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | GetH245VersionID | This method is used to
 *    retrieve a DWORD value that identifies the platform version that the
 *    TAPI MSP Video Capture filter was designed for. The platform version is
 *    defined as TAPI_H245_VERSION_ID.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CCapturePin::GetH245VersionID(OUT DWORD *pdwVersionID)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CCapturePin::GetH245VersionID")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameter
        ASSERT(pdwVersionID);
        if (!pdwVersionID)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument!", _fx_));
                Hr = E_POINTER;
        }
        else
        {
                *pdwVersionID = TAPI_H245_VERSION_ID;
                Hr = NOERROR;
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CH245VIDCMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | GetFormatTable | This method is used to
 *    obtain <t H245MediaCapabilityMap> structures for all formats and format
 *    options that the TAPI MSP Video Capture filter supports. The content of
 *    the capability information that the TAPI MSP Capability module obtains
 *    via this method is a two dimensional table that relates every supported
 *    receive format to steady-state resource requirements of that format.
 *
 *  @parm H245MediaCapabilityTable* | pTable | Specifies a pointer to an
 *    <t H245MediaCapabilityTable> structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 *
 *  @comm The memory allocated by <mf CCapturePin.GetFormatTable> is released
 *    by calling <mf CCapturePin.ReleaseFormatTable>
 ***************************************************************************/
STDMETHODIMP CCapturePin::GetFormatTable(OUT H245MediaCapabilityTable *pTable)
{
        HRESULT                                 Hr = NOERROR;
        int                                             nNormalizedSpeed;
        LONG                                    lRate, lRateCIF, lRateQCIF, lRateSQCIF;
        DWORD                                   dwNumQCIFBounds, dwNumCIFBounds, dwNumSQCIFBounds;
        DWORD                                   dwCPUUsage;
        DWORD                                   dwBitsPerSec;

        FX_ENTRY("CCapturePin::GetFormatTable")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pTable);
        if (!pTable)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // We support H.261 QCIF and CIF, as well as H.263 SQCIF, QCIF, and CIF

        // Allocate memory to describe the capabilities of these formats
        if (!(m_pH245MediaCapabilityMap = new H245MediaCapabilityMap[NUM_H245VIDEOCAPABILITYMAPS]))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Initialize the array of capabilities
        ZeroMemory(m_pH245MediaCapabilityMap, NUM_H245VIDEOCAPABILITYMAPS * sizeof(H245MediaCapabilityMap));

        // Allocate memory to describe the resource bounds of our capabilities
        if (!(m_pVideoResourceBounds = new VideoResourceBounds[NUM_ITU_SIZES * NUM_RATES_PER_RESOURCE]))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                Hr = E_POINTER;
                goto MyError1;
        }

        // Initialize the array of resource bounds
        ZeroMemory(m_pVideoResourceBounds, NUM_ITU_SIZES * NUM_RATES_PER_RESOURCE * sizeof(FormatResourceBounds));

        // Allocate memory to describe the format bounds of our capabilities
        if (!(m_pFormatResourceBounds = new FormatResourceBounds[NUM_ITU_SIZES * NUM_RATES_PER_RESOURCE]))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                Hr = E_POINTER;
                goto MyError2;
        }

        // Initialize the array of resource bounds
        ZeroMemory(m_pFormatResourceBounds, NUM_ITU_SIZES * NUM_RATES_PER_RESOURCE * sizeof(FormatResourceBounds));

        // Get the CPU properties
        GetNormalizedCPUSpeed(&nNormalizedSpeed);

        // Initialize frame rate limits
        if (nNormalizedSpeed > SLOW_CPU_MHZ && nNormalizedSpeed < FAST_CPU_MHZ)
        {
                // 110MHz < CPUs < 200MhZ
                lRateCIF   = CIF_RATE_SLOW;
                lRateQCIF  = QCIF_RATE_SLOW;
                lRateSQCIF = SQCIF_RATE_SLOW;
        }
        else if (nNormalizedSpeed >= FAST_CPU_MHZ && nNormalizedSpeed < VERYFAST_CPU_MHZ)
        {
                // 200MHz < CPUs < 400MhZ
                lRateCIF   = CIF_RATE_FAST;
                lRateQCIF  = QCIF_RATE_FAST;
                lRateSQCIF = SQCIF_RATE_FAST;
        }
        else if (nNormalizedSpeed >= VERYFAST_CPU_MHZ)
        {
                // CPUs > 400MhZ
                // It would be better if we could scale between 15 and 30 frames/sec
                // depending on the CPU speed. But H.245 doesn't have any values
                // between 15 and 30. (See definition of Minimum Picture Interval)
                // So for now, 30 frames per sec CIF for all 400mhz and faster machines
                lRateCIF = CIF_RATE_VERYFAST;
                lRateQCIF = QCIF_RATE_FAST;
                lRateSQCIF = SQCIF_RATE_FAST;
        }
        else
        {
                // CPUs < 110MHZ
                lRateCIF   = CIF_RATE_VERYSLOW;
                lRateQCIF  = QCIF_RATE_VERYSLOW;
                lRateSQCIF = SQCIF_RATE_VERYSLOW;
        }
        //it was #define HUNDREDSBITSPERPIC 640
        //#define BITSPERPIC (64*1024)
        #define BITSPERPIC (8*1024)
        // Compute resources bounds
        for (lRate = lRateQCIF, dwNumQCIFBounds = 0, dwCPUUsage = MAX_CPU_USAGE; lRate; lRate >>= 1, dwCPUUsage >>= 1)
        {
                dwBitsPerSec = lRate * BITSPERPIC;
                if(dwBitsPerSec < (DWORD)m_lBitrateRangeMin || dwBitsPerSec > (DWORD)m_lBitrateRangeMax ) {
                //if(dwBitsPerSec > (DWORD)m_lTargetBitrate) {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   QCIF: At lRate=%ld, dwBitsPerSec(%lu) > m_lTargetBitrate(%ld). Skipped...", _fx_,lRate,dwBitsPerSec,m_lTargetBitrate));
                        continue;
                }
                m_pVideoResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumQCIFBounds].dwBitsPerPicture = BITSPERPIC;
                m_pVideoResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumQCIFBounds].lPicturesPerSecond = lRate;
                m_pFormatResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumQCIFBounds].dwCPUUtilization = dwCPUUsage;
                m_pFormatResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumQCIFBounds].dwBitsPerSecond = dwBitsPerSec;
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   QCIF: lRate=%ld, dwBitsPerSec(%lu) [%lu]", _fx_,lRate,dwBitsPerSec,dwNumQCIFBounds));
                dwNumQCIFBounds++ ;
        }
        for (lRate = lRateCIF, dwNumCIFBounds = 0, dwCPUUsage = MAX_CPU_USAGE; lRate; lRate >>= 1, dwCPUUsage >>= 1)
        {
                dwBitsPerSec = lRate * BITSPERPIC;
                if(dwBitsPerSec < (DWORD)m_lBitrateRangeMin || dwBitsPerSec > (DWORD)m_lBitrateRangeMax ) {
                //if(dwBitsPerSec > (DWORD)m_lTargetBitrate) {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:    CIF: At lRate=%ld, dwBitsPerSec(%lu) > m_lTargetBitrate(%ld). Skipped...", _fx_,lRate,dwBitsPerSec,m_lTargetBitrate));
                        continue;
                }
                m_pVideoResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumCIFBounds].dwBitsPerPicture = BITSPERPIC;
                m_pVideoResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumCIFBounds].lPicturesPerSecond = lRate;
                m_pFormatResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumCIFBounds].dwCPUUtilization = dwCPUUsage;
                m_pFormatResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumCIFBounds].dwBitsPerSecond = dwBitsPerSec;
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:    CIF: lRate=%ld, dwBitsPerSec(%lu) [%lu]", _fx_,lRate,dwBitsPerSec,dwNumCIFBounds));
                dwNumCIFBounds++;
        }
        for (lRate = lRateSQCIF, dwNumSQCIFBounds = 0, dwCPUUsage = MAX_CPU_USAGE; lRate; lRate >>= 1, dwCPUUsage >>= 1)
        {
                dwBitsPerSec = lRate * BITSPERPIC;
                if(dwBitsPerSec < (DWORD)m_lBitrateRangeMin || dwBitsPerSec > (DWORD)m_lBitrateRangeMax ) {
                //if(dwBitsPerSec > (DWORD)m_lTargetBitrate) {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:  SQCIF: At lRate=%ld, dwBitsPerSec(%lu) > m_lTargetBitrate(%ld). Skipped...", _fx_,lRate,dwBitsPerSec,m_lTargetBitrate));
                        continue;
                }
                m_pVideoResourceBounds[SQCIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumSQCIFBounds].dwBitsPerPicture = BITSPERPIC;
                m_pVideoResourceBounds[SQCIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumSQCIFBounds].lPicturesPerSecond = lRate;
                m_pFormatResourceBounds[SQCIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumSQCIFBounds].dwCPUUtilization = dwCPUUsage;
                m_pFormatResourceBounds[SQCIF_SIZE * NUM_RATES_PER_RESOURCE + dwNumSQCIFBounds].dwBitsPerSecond = dwBitsPerSec;
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:  SQCIF: lRate=%ld, dwBitsPerSec(%lu) [%lu]", _fx_,lRate,dwBitsPerSec,dwNumSQCIFBounds));
                dwNumSQCIFBounds++;
        }

        // Initialise H.263 QCIF H245MediaCapabilityMap
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].dwUniqueID = R263_QCIF_H245_CAPID;
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].filterGuid = __uuidof(TAPIVideoCapture);
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].uNumEntries = dwNumQCIFBounds;
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].pResourceBoundArray = &m_pFormatResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE];
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].h245MediaCapability.media_type = H245MediaType_Video;
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].h245MediaCapability.capability.video_cap.choice = h263VideoCapability_chosen;
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.bit_mask = H263VideoCapability_qcifMPI_present;
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.qcifMPI = (WORD)(30 / lRateQCIF);
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.maxBitRate =
        min((WORD)(8192 * 8 * lRateQCIF / 100), MAX_BITRATE_H263); // The max frame size we can decode is 8192 bytes
        m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.bppMaxKb = 64; // The max frame size we can decode is 8192 = 64 * 1024 bytes

        // Initialise H.263 CIF H245MediaCapabilityMap
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].dwUniqueID = R263_CIF_H245_CAPID;
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].filterGuid = __uuidof(TAPIVideoCapture);
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].uNumEntries = dwNumCIFBounds;
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].pResourceBoundArray = &m_pFormatResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE];
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].h245MediaCapability.media_type = H245MediaType_Video;
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].h245MediaCapability.capability.video_cap.choice = h263VideoCapability_chosen;
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.bit_mask = H263VideoCapability_cifMPI_present;
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.cifMPI = (WORD)(30 / lRateCIF);
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.maxBitRate =
        min((WORD)(32768 * 8 * lRateCIF / 100), MAX_BITRATE_H263); // The max frame size we can decode is 32768 bytes
        m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.bppMaxKb = 256; // The max frame size we can decode is 32768 = 256 * 1024 bytes

        // Initialise H.263 SQCIF H245MediaCapabilityMap
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].dwUniqueID = R263_SQCIF_H245_CAPID;
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].filterGuid = __uuidof(TAPIVideoCapture);
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].uNumEntries = dwNumSQCIFBounds;
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].pResourceBoundArray = &m_pFormatResourceBounds[SQCIF_SIZE * NUM_RATES_PER_RESOURCE];
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].h245MediaCapability.media_type = H245MediaType_Video;
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].h245MediaCapability.capability.video_cap.choice = h263VideoCapability_chosen;
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.bit_mask = H263VideoCapability_sqcifMPI_present;
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.sqcifMPI = (WORD)(30 / lRateSQCIF);
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.maxBitRate =
        min((WORD)(32768 * 8 * lRateSQCIF / 100), MAX_BITRATE_H263); // The max frame size we can decode is 32768 bytes
        m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h263VideoCapability.bppMaxKb = 64; // The max frame size we can decode is 8192 = 64 * 1024 bytes

        // Initialise H.261 QCIF H245MediaCapabilityMap
        m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].dwUniqueID = R261_QCIF_H245_CAPID;
        m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].filterGuid = __uuidof(TAPIVideoCapture);
        m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].uNumEntries = dwNumQCIFBounds;
        m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].pResourceBoundArray = &m_pFormatResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE];
        m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].h245MediaCapability.media_type = H245MediaType_Video;
        m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].h245MediaCapability.capability.video_cap.choice = h261VideoCapability_chosen;
        m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h261VideoCapability.bit_mask = H261VideoCapability_qcifMPI_present;
        m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h261VideoCapability.qcifMPI = (WORD)(30 / lRateQCIF);
        m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h261VideoCapability.maxBitRate =
        min((WORD)(8192 * 8 * lRateQCIF / 100), MAX_BITRATE_H261); // The max frame size we can decode is 8192 bytes

        // Initialise H.261 CIF H245MediaCapabilityMap
        m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].dwUniqueID = R261_CIF_H245_CAPID;
        m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].filterGuid = __uuidof(TAPIVideoCapture);
        m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].uNumEntries = dwNumCIFBounds;
        m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].pResourceBoundArray = &m_pFormatResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE];
        m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].h245MediaCapability.media_type = H245MediaType_Video;
        m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].h245MediaCapability.capability.video_cap.choice = h261VideoCapability_chosen;
        m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h261VideoCapability.bit_mask = H261VideoCapability_cifMPI_present;
        m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h261VideoCapability.cifMPI = (WORD)(30 / lRateCIF);
        m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].h245MediaCapability.capability.video_cap.u.h261VideoCapability.maxBitRate =
        min((WORD)(32768 * 8 * lRateCIF / 100), MAX_BITRATE_H261); // The max frame size we can decode is 32768 bytes

        // Return our H245MediaCapabilityTable
        pTable->uMappedCapabilities = NUM_H245VIDEOCAPABILITYMAPS;
        pTable->pCapabilityArray = m_pH245MediaCapabilityMap;

        goto MyExit;

MyError2:
        if (m_pVideoResourceBounds)
                delete[] m_pVideoResourceBounds, m_pVideoResourceBounds = NULL;
MyError1:
        if (m_pH245MediaCapabilityMap)
                delete[] m_pH245MediaCapabilityMap, m_pH245MediaCapabilityMap = NULL;
MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CH245VIDCMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | ReleaseFormatTable | This method is used to
 *    to release memory allocated by the <mf CCapturePin.GetFormatTable> method.
 *
 *  @parm H245MediaCapabilityTable* | pTable | Specifies a pointer to an
 *    <t H245MediaCapabilityTable> structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 *
 *  @xref <mf CCapturePin.GetFormatTable>
 ***************************************************************************/
STDMETHODIMP CCapturePin::ReleaseFormatTable(IN H245MediaCapabilityTable *pTable)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CCapturePin::ReleaseFormatTable")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters - if it is our table, it should have NUM_H245VIDEOCAPABILITYMAPS entries
        ASSERT(pTable);
        if (!pTable || !pTable->pCapabilityArray)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }
        ASSERT(pTable->uMappedCapabilities == NUM_H245VIDEOCAPABILITYMAPS && pTable->pCapabilityArray == m_pH245MediaCapabilityMap);
        if (pTable->uMappedCapabilities != NUM_H245VIDEOCAPABILITYMAPS || pTable->pCapabilityArray != m_pH245MediaCapabilityMap)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }

        // Release the table of H245MediaCapabilityMap structures
        if (m_pH245MediaCapabilityMap)
                delete[] m_pH245MediaCapabilityMap, m_pH245MediaCapabilityMap = NULL;
        if (m_pVideoResourceBounds)
                delete[] m_pVideoResourceBounds, m_pVideoResourceBounds = NULL;
        if (m_pFormatResourceBounds)
                delete[] m_pFormatResourceBounds, m_pFormatResourceBounds = NULL;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CH245VIDCMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | Refine | This method is used to
 *    refine the content of an <t H245MediaCapability> structure based on the
 *    CPU and bandwidth limitations passed in.
 *
 *  @parm H245MediaCapability* | pLocalCapability | Specifies the H.245 video
 *    format, including all parameters and options defined by H.245, of a
 *    local video capability.
 *
 *  @parm DWORD | dwUniqueID | Specifies the unique ID of the local capability
 *    structure passed in.
 *
 *  @parm DWORD | dwResourceBoundIndex | Specifies the resource limitations to
 *    be applied on the local capability structure passed in.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_FAIL | Unsupported format
 *  @flag NOERROR | No error
 *
 *  @xref <mf CCapturePin.GetNegotiatedLimitProperty>
 ***************************************************************************/
STDMETHODIMP CCapturePin::Refine(IN OUT H245MediaCapability *pLocalCapability, IN DWORD dwUniqueID, IN DWORD dwResourceBoundIndex)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CCapturePin::Refine")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pLocalCapability);
        if (!pLocalCapability)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }
        ASSERT(pLocalCapability->media_type == H245MediaType_Video);
        if (pLocalCapability->media_type != H245MediaType_Video)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }

        // Update the relevant fields
        ASSERT(dwUniqueID <= R261_CIF_H245_CAPID);
        switch (dwUniqueID)
        {
                case R263_QCIF_H245_CAPID:
                        ASSERT(dwResourceBoundIndex < m_pH245MediaCapabilityMap[R263_QCIF_H245_CAPID].uNumEntries);
                        if (m_pVideoResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond)
                        {
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.qcifMPI = (WORD)(30 / m_pVideoResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond);
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate = (WORD)(8192 * 8 * m_pVideoResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond / 100); // The max frame size we can decode is 8192 bytes
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate = min(pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate, MAX_BITRATE_H263);
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.bppMaxKb = 64; // The max frame size we can decode is 8192 = 64 * 1024 bytes
                        }
                        else
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                                Hr = E_INVALIDARG;
                        }
                        break;
                case R263_CIF_H245_CAPID:
                        ASSERT(dwResourceBoundIndex < m_pH245MediaCapabilityMap[R263_CIF_H245_CAPID].uNumEntries);
                        if (m_pVideoResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond)
                        {
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.cifMPI = (WORD)(30 / m_pVideoResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond);
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate = (WORD)(32768 * 8 * m_pVideoResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond / 100); // The max frame size we can decode is 32768 bytes
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate = min(pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate, MAX_BITRATE_H263);
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.bppMaxKb = 256; // The max frame size we can decode is 32768 = 256 * 1024 bytes
                        }
                        else
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                                Hr = E_INVALIDARG;
                        }
                        break;
                case R263_SQCIF_H245_CAPID:
                        ASSERT(dwResourceBoundIndex < m_pH245MediaCapabilityMap[R263_SQCIF_H245_CAPID].uNumEntries);
                        if (m_pVideoResourceBounds[SQCIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond)
                        {
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.sqcifMPI = (WORD)(30 / m_pVideoResourceBounds[SQCIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond);
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate = (WORD)(8192 * 8 * m_pVideoResourceBounds[SQCIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond / 100); // The max frame size we can decode is 8192 bytes
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate = min(pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate, MAX_BITRATE_H263);
                                pLocalCapability->capability.video_cap.u.h263VideoCapability.bppMaxKb = 64; // The max frame size we can decode is 8192 = 64 * 1024 bytes
                        }
                        else
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                                Hr = E_INVALIDARG;
                        }
                        break;
                case R261_QCIF_H245_CAPID:
                        ASSERT(dwResourceBoundIndex < m_pH245MediaCapabilityMap[R261_QCIF_H245_CAPID].uNumEntries);
                        if (m_pVideoResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond)
                        {
                                pLocalCapability->capability.video_cap.u.h261VideoCapability.qcifMPI = (WORD)(30 / m_pVideoResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond);
                                pLocalCapability->capability.video_cap.u.h261VideoCapability.maxBitRate = (WORD)(8192 * 8 * m_pVideoResourceBounds[QCIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond / 100); // The max frame size we can decode is 8192 bytes
                                pLocalCapability->capability.video_cap.u.h261VideoCapability.maxBitRate = min(pLocalCapability->capability.video_cap.u.h261VideoCapability.maxBitRate, MAX_BITRATE_H261);
                        }
                        else
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                                Hr = E_INVALIDARG;
                        }
                        break;
                case R261_CIF_H245_CAPID:
                        ASSERT(dwResourceBoundIndex < m_pH245MediaCapabilityMap[R261_CIF_H245_CAPID].uNumEntries);
                        if (m_pVideoResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond)
                        {
                                pLocalCapability->capability.video_cap.u.h261VideoCapability.cifMPI = (WORD)(30 / m_pVideoResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond);
                                pLocalCapability->capability.video_cap.u.h261VideoCapability.maxBitRate = (WORD)(32768 * 8 * m_pVideoResourceBounds[CIF_SIZE * NUM_RATES_PER_RESOURCE + dwResourceBoundIndex].lPicturesPerSecond / 100); // The max frame size we can decode is 32768 bytes
                                pLocalCapability->capability.video_cap.u.h261VideoCapability.maxBitRate = min(pLocalCapability->capability.video_cap.u.h261VideoCapability.maxBitRate, MAX_BITRATE_H261);
                        }
                        else
                        {
                                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                                Hr = E_INVALIDARG;
                        }
                        break;
                default:
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                        Hr = E_INVALIDARG;
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CH245VIDCMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | IntersectFormats | This method is used to
 *    compare and intersect one local capability and one remote capability
 *    and to obtain configuration parameters.
 *
 *  @parm DWORD | dwUniqueID | Specifies the unique idea for the local H.245
 *    video capability passed in.
 *
 *  @parm H245MediaCapability* | pLocalCapability | Specifies the H.245 video
 *    format, including all parameters and options defined by H.245, of a
 *    local video capability.
 *
 *  @parm H245MediaCapability* | pRemoteCapability | Specifies the H.245
 *    video format, including all parameters and options defined by H.245, of
 *    a remote video capability.
 *
 *  @parm H245MediaCapability* | pIntersectedCapability | Specifies the H.245
 *    video format, of the resolved common local and remote capability
 *    options and limits.
 *
 *  @parm DWORD* | pdwPayloadType | Specifies RTP payload type to be used.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_FAIL | Unsupported format
 *  @flag NOERROR | No error
 *
 *  @xref <mf CCapturePin.GetNegotiatedLimitProperty>
 ***************************************************************************/
STDMETHODIMP CCapturePin::IntersectFormats(
    IN DWORD dwUniqueID,
    IN const H245MediaCapability *pLocalCapability,
    IN const H245MediaCapability *pRemoteCapability,
    OUT H245MediaCapability **ppIntersectedCapability,
    OUT  DWORD *pdwPayloadType
    )
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CCapturePin::IntersectFormats")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pLocalCapability);
    ASSERT(pdwPayloadType);

        if (!pLocalCapability || !pdwPayloadType)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
        return E_POINTER;
        }

    *pdwPayloadType = RTPPayloadTypes[dwUniqueID];

    // initialize intersected cap
    if (ppIntersectedCapability) *ppIntersectedCapability = NULL;

    if (pRemoteCapability == NULL)
    {
        // if this is NULL, the caller just want a copy of the local caps.

        // Allocate memory to describe the capabilities of these formats
            if (!(*ppIntersectedCapability = new H245MediaCapability))
            {
                    DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                    Hr = E_OUTOFMEMORY;
                    goto MyExit;
            }

        *(*ppIntersectedCapability) = *pLocalCapability;

                Hr = S_OK;
                goto MyExit;
    }

 // First: test for basic similarity between local and remote format.
        if(pLocalCapability->capability.audio_cap.choice != pRemoteCapability->
                capability.audio_cap.choice)
        {
                Hr = E_INVALIDARG; // E_NO_INTERSECTION ?
                goto MyExit;
        }

    ASSERT (ppIntersectedCapability != NULL);

#if 0 // we will never hit this condition on the transmit side.
    if (ppIntersectedCapability == NULL)
    {
        // just test to see if we like it.
            if (pRemoteCapability->media_type == H245MediaType_Video
            && pRemoteCapability->capability.video_cap.choice == h263VideoCapability_chosen)
        {
            if (!(pLocalCapability->capability.video_cap.u.h263VideoCapability.bit_mask
                & pRemoteCapability->capability.video_cap.u.h263VideoCapability.bit_mask))
            {
                return E_FAIL;
            }

            if (pLocalCapability->capability.video_cap.u.h263VideoCapability.bppMaxKb <
                pRemoteCapability->capability.video_cap.u.h263VideoCapability.bppMaxKb)
            {
                return E_FAIL;
            }

            if (pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate <
                pRemoteCapability->capability.video_cap.u.h263VideoCapability.maxBitRate)
            {
                return E_FAIL;
            }

            if (pLocalCapability->capability.video_cap.u.h263VideoCapability.qcifMPI >
                pRemoteCapability->capability.video_cap.u.h263VideoCapability.qcifMPI)
            {
                return E_FAIL;
            }

            if (pLocalCapability->capability.video_cap.u.h263VideoCapability.cifMPI >
                pRemoteCapability->capability.video_cap.u.h263VideoCapability.cifMPI)
            {
                return E_FAIL;
            }

            if (pLocalCapability->capability.video_cap.u.h263VideoCapability.sqcifMPI >
                pRemoteCapability->capability.video_cap.u.h263VideoCapability.sqcifMPI)
            {
                return E_FAIL;
            }
        }
            else if (pRemoteCapability->media_type == H245MediaType_Video
            && pRemoteCapability->capability.video_cap.choice == h261VideoCapability_chosen)
        {
            if (!(pLocalCapability->capability.video_cap.u.h261VideoCapability.bit_mask
                & pRemoteCapability->capability.video_cap.u.h261VideoCapability.bit_mask))
            {
                return E_FAIL;
            }

            if (pLocalCapability->capability.video_cap.u.h261VideoCapability.maxBitRate <
                pRemoteCapability->capability.video_cap.u.h261VideoCapability.maxBitRate)
            {
                return E_FAIL;
            }

            if (pLocalCapability->capability.video_cap.u.h261VideoCapability.qcifMPI >
                pRemoteCapability->capability.video_cap.u.h261VideoCapability.qcifMPI)
            {
                return E_FAIL;
            }

            if (pLocalCapability->capability.video_cap.u.h261VideoCapability.cifMPI >
                pRemoteCapability->capability.video_cap.u.h261VideoCapability.cifMPI)
            {
                return E_FAIL;
            }
        }
        else
        {
            return E_UNEXPECTED;
        }
        return S_OK;
    }
#endif

        // Allocate memory to describe the capabilities of these formats
        if (!(*ppIntersectedCapability = new H245MediaCapability))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                Hr = E_OUTOFMEMORY;
                goto MyExit;
        }

        // Initialize the intersected capability
        ZeroMemory(*ppIntersectedCapability, sizeof(H245MediaCapability));

        // Resolve the capabilities
        if (pRemoteCapability->media_type == H245MediaType_Video
        && pRemoteCapability->capability.video_cap.choice == h263VideoCapability_chosen)
        {
                (*ppIntersectedCapability)->media_type = H245MediaType_Video;

                (*ppIntersectedCapability)->capability.video_cap.choice = h263VideoCapability_chosen;

                (*ppIntersectedCapability)->capability.video_cap.u.h263VideoCapability.bit_mask =
                    pLocalCapability->capability.video_cap.u.h263VideoCapability.bit_mask
                    & pRemoteCapability->capability.video_cap.u.h263VideoCapability.bit_mask;

                if (!(*ppIntersectedCapability)->capability.video_cap.u.h263VideoCapability.bit_mask)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Unsupported format", _fx_));
                        Hr = E_FAIL;
                        goto MyExit;
                }

                if (pRemoteCapability->capability.video_cap.u.h263VideoCapability.bppMaxKb)
                {
                            (*ppIntersectedCapability)->capability.video_cap.u.h263VideoCapability.bppMaxKb =
                        min(pLocalCapability->capability.video_cap.u.h263VideoCapability.bppMaxKb,
                        pRemoteCapability->capability.video_cap.u.h263VideoCapability.bppMaxKb);
                }

                (*ppIntersectedCapability)->capability.video_cap.u.h263VideoCapability.maxBitRate =
                    min(pLocalCapability->capability.video_cap.u.h263VideoCapability.maxBitRate,
                    pRemoteCapability->capability.video_cap.u.h263VideoCapability.maxBitRate);

                (*ppIntersectedCapability)->capability.video_cap.u.h263VideoCapability.qcifMPI =
                    max(pLocalCapability->capability.video_cap.u.h263VideoCapability.qcifMPI,
                    pRemoteCapability->capability.video_cap.u.h263VideoCapability.qcifMPI);

                (*ppIntersectedCapability)->capability.video_cap.u.h263VideoCapability.cifMPI =
                    max(pLocalCapability->capability.video_cap.u.h263VideoCapability.cifMPI,
                    pRemoteCapability->capability.video_cap.u.h263VideoCapability.cifMPI);

                (*ppIntersectedCapability)->capability.video_cap.u.h263VideoCapability.sqcifMPI =
                    max(pLocalCapability->capability.video_cap.u.h263VideoCapability.sqcifMPI,
                    pRemoteCapability->capability.video_cap.u.h263VideoCapability.sqcifMPI);
        }
        else if (pRemoteCapability->media_type == H245MediaType_Video
        && pRemoteCapability->capability.video_cap.choice == h261VideoCapability_chosen)
        {
                (*ppIntersectedCapability)->media_type = H245MediaType_Video;

                (*ppIntersectedCapability)->capability.video_cap.choice = h261VideoCapability_chosen;

                (*ppIntersectedCapability)->capability.video_cap.u.h261VideoCapability.bit_mask =
                    pLocalCapability->capability.video_cap.u.h261VideoCapability.bit_mask
                    & pRemoteCapability->capability.video_cap.u.h261VideoCapability.bit_mask;

                if (!(*ppIntersectedCapability)->capability.video_cap.u.h261VideoCapability.bit_mask)
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Unsupported format", _fx_));
                        Hr = E_FAIL;
                        goto MyExit;
                }
                (*ppIntersectedCapability)->capability.video_cap.u.h261VideoCapability.maxBitRate =
                    min(pLocalCapability->capability.video_cap.u.h261VideoCapability.maxBitRate,
                    pRemoteCapability->capability.video_cap.u.h261VideoCapability.maxBitRate);

                (*ppIntersectedCapability)->capability.video_cap.u.h261VideoCapability.qcifMPI =
                    max(pLocalCapability->capability.video_cap.u.h261VideoCapability.qcifMPI,
                    pRemoteCapability->capability.video_cap.u.h261VideoCapability.qcifMPI);

                (*ppIntersectedCapability)->capability.video_cap.u.h261VideoCapability.cifMPI =
                    max(pLocalCapability->capability.video_cap.u.h261VideoCapability.cifMPI,
                    pRemoteCapability->capability.video_cap.u.h261VideoCapability.cifMPI);
        }
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Unsupported format", _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

MyExit:

    if (FAILED (Hr))
    {
        if (ppIntersectedCapability && *ppIntersectedCapability)
        {
            // clear allocated memory if we failed
            delete (*ppIntersectedCapability);
            *ppIntersectedCapability = NULL;
        }
    }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CH245VIDCMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | GetLocalFormat | This method is used to
 *    obtain the local TAPI MSP Video Capture filter configuration
 *    parameters that are compatible with a remote capability.
 *
 *  @parm DWORD | dwUniqueID | Specifies the unique idea for the intersected
 *    H.245 video capability passed in.
 *
 *  @parm H245MediaCapability* | pIntersectedCapability | Specifies the H.245
 *    video format, of the resolved common local and remote capability
 *    options and limits.
 *
 *  @parm AM_MEDIA_TYPE** | ppAMMediaType | Specifies the address of a pointer
 *    to an <t AM_MEDIA_TYPE> structure to be been initialized with regards
 *    to negotiated options.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument argument
 *  @flag NOERROR | No error
 *
 *  @xref <mf CCapturePin.GetNegotiatedLimitProperty>
 ***************************************************************************/
STDMETHODIMP CCapturePin::GetLocalFormat(IN DWORD dwUniqueID, IN const H245MediaCapability *pIntersectedCapability, OUT AM_MEDIA_TYPE **ppAMMediaType)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CCapturePin::GetLocalFormat")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pIntersectedCapability);
        ASSERT(ppAMMediaType);
        if (!pIntersectedCapability || !ppAMMediaType)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Find the DShow format the passed in capability structure matches
        ASSERT(pIntersectedCapability->media_type == H245MediaType_Video);
        ASSERT(dwUniqueID <= R261_CIF_H245_CAPID);
        if (!(dwUniqueID <= R261_CIF_H245_CAPID) || pIntersectedCapability->media_type != H245MediaType_Video)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Unsupported format", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }

        // Return a copy of the format that matches the capability negociated
        if (!(*ppAMMediaType = CreateMediaType(CaptureFormats[dwUniqueID])))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                Hr = E_OUTOFMEMORY;
                goto MyExit;
        }

        // Doctor the AM_MEDIA_TYPE fields to show the changes in frame
        // rate, bitrate, and max frame size in the negotiated capability
        switch (dwUniqueID)
        {
                case R263_QCIF_H245_CAPID:
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->AvgTimePerFrame =  pIntersectedCapability->capability.video_cap.u.h263VideoCapability.qcifMPI * MIN_FRAME_INTERVAL;
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->dwBitRate = pIntersectedCapability->capability.video_cap.u.h263VideoCapability.maxBitRate * 100L;
            if (pIntersectedCapability->capability.video_cap.u.h263VideoCapability.bppMaxKb)
            {
                ASSERT(((VIDEOINFOHEADER_H263 *)((*ppAMMediaType)->pbFormat))->bmiHeader.bmi.biSize == sizeof (BITMAPINFOHEADER_H263));
                ((VIDEOINFOHEADER_H263 *)((*ppAMMediaType)->pbFormat))->bmiHeader.dwBppMaxKb = pIntersectedCapability->capability.video_cap.u.h263VideoCapability.bppMaxKb;
            }
                        break;
                case R263_CIF_H245_CAPID:
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->AvgTimePerFrame =  pIntersectedCapability->capability.video_cap.u.h263VideoCapability.cifMPI * MIN_FRAME_INTERVAL;
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->dwBitRate = pIntersectedCapability->capability.video_cap.u.h263VideoCapability.maxBitRate * 100L;
            if (pIntersectedCapability->capability.video_cap.u.h263VideoCapability.bppMaxKb)
            {
                ASSERT(((VIDEOINFOHEADER_H263 *)((*ppAMMediaType)->pbFormat))->bmiHeader.bmi.biSize == sizeof (BITMAPINFOHEADER_H263));
                ((VIDEOINFOHEADER_H263 *)((*ppAMMediaType)->pbFormat))->bmiHeader.dwBppMaxKb = pIntersectedCapability->capability.video_cap.u.h263VideoCapability.bppMaxKb;
            }
                        break;
                case R263_SQCIF_H245_CAPID:
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->AvgTimePerFrame =  pIntersectedCapability->capability.video_cap.u.h263VideoCapability.sqcifMPI * MIN_FRAME_INTERVAL;
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->dwBitRate = pIntersectedCapability->capability.video_cap.u.h263VideoCapability.maxBitRate * 100L;
            if (pIntersectedCapability->capability.video_cap.u.h263VideoCapability.bppMaxKb)
            {
                ASSERT(((VIDEOINFOHEADER_H263 *)((*ppAMMediaType)->pbFormat))->bmiHeader.bmi.biSize == sizeof (BITMAPINFOHEADER_H263));
                ((VIDEOINFOHEADER_H263 *)((*ppAMMediaType)->pbFormat))->bmiHeader.dwBppMaxKb = pIntersectedCapability->capability.video_cap.u.h263VideoCapability.bppMaxKb;
            }
                        break;
                case R261_QCIF_H245_CAPID:
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->AvgTimePerFrame =  pIntersectedCapability->capability.video_cap.u.h261VideoCapability.qcifMPI * MIN_FRAME_INTERVAL;
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->dwBitRate = pIntersectedCapability->capability.video_cap.u.h261VideoCapability.maxBitRate * 100L;
                        break;
                case R261_CIF_H245_CAPID:
                default:
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->AvgTimePerFrame =  pIntersectedCapability->capability.video_cap.u.h261VideoCapability.cifMPI * MIN_FRAME_INTERVAL;
                        ((VIDEOINFOHEADER *)((*ppAMMediaType)->pbFormat))->dwBitRate = pIntersectedCapability->capability.video_cap.u.h261VideoCapability.maxBitRate * 100L;
                        break;
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CH245VIDCMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | ReleaseNegotiatedCapability | This method
 *    is used to release the TAPI MSP Video Capture filter internal memory
 *    allocated by either the <mf CCapturePin.IntersectFormats> or
 *    <mf CCapturePin.GetLocalFormat> method.
 *
 *  @parm H245MediaCapability* | pIntersectedCapability | Specifies the H.245
 *    video format, of the resolved common local and remote capability
 *    options and limits.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 *
 *  @xref <mf CCapturePin.IntersectFormats>, <mf CCapturePin.GetLocalFormat>
 ***************************************************************************/
STDMETHODIMP CCapturePin::ReleaseNegotiatedCapability(IN H245MediaCapability *pIntersectedCapability)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CCapturePin::ReleaseNegotiatedCapability")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pIntersectedCapability);
        if (!pIntersectedCapability)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        // Release the memory
        delete pIntersectedCapability;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CH245VIDCMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | FindIDByRange | This method is used to
 *    obtain the unique format ID of a capability that corresponds to an
 *    <t AM_MEDIA_TYPE>.
 *
 *  @parm AM_MEDIA_TYPE* | pAMMediaType | Specifies a pointer to an
 *    <t AM_MEDIA_TYPE> structure that has been initialized with a
 *    specific format.
 *
 *  @parm DWORD* | pdwID | Specifies a pointer to a DWORD output parameter
 *    that will contain the unique format ID.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CCapturePin::FindIDByRange(IN const AM_MEDIA_TYPE *pAMMediaType, OUT DWORD *pdwUniqueID)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CCapturePin::FindIDByRange")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pAMMediaType);
        ASSERT(pdwUniqueID);
        if (!pAMMediaType || !pdwUniqueID)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }
        ASSERT(pAMMediaType->majortype == MEDIATYPE_Video && pAMMediaType->formattype == FORMAT_VideoInfo && pAMMediaType->pbFormat);
        if (!pAMMediaType || !pdwUniqueID || pAMMediaType->majortype != MEDIATYPE_Video || pAMMediaType->formattype != FORMAT_VideoInfo || !pAMMediaType->pbFormat)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                Hr = E_INVALIDARG;
                goto MyExit;
        }

        // Which media type is this?
        if (HEADER(pAMMediaType->pbFormat)->biCompression == FOURCC_M263)
        {
                if (HEADER(pAMMediaType->pbFormat)->biWidth == 176 && HEADER(pAMMediaType->pbFormat)->biHeight == 144)
                {
                        *pdwUniqueID = R263_QCIF_H245_CAPID;
                }
                else if (HEADER(pAMMediaType->pbFormat)->biWidth == 352 && HEADER(pAMMediaType->pbFormat)->biHeight == 288)
                {
                        *pdwUniqueID = R263_CIF_H245_CAPID;
                }
                else if (HEADER(pAMMediaType->pbFormat)->biWidth == 128 && HEADER(pAMMediaType->pbFormat)->biHeight == 96)
                {
                        *pdwUniqueID = R263_SQCIF_H245_CAPID;
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                        Hr = E_INVALIDARG;
                }
        }
        else if (HEADER(pAMMediaType->pbFormat)->biCompression == FOURCC_M261)
        {
                if (HEADER(pAMMediaType->pbFormat)->biWidth == 176 && HEADER(pAMMediaType->pbFormat)->biHeight == 144)
                {
                        *pdwUniqueID = R261_QCIF_H245_CAPID;
                }
                else if (HEADER(pAMMediaType->pbFormat)->biWidth == 352 && HEADER(pAMMediaType->pbFormat)->biHeight == 288)
                {
                        *pdwUniqueID = R261_CIF_H245_CAPID;
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                        Hr = E_INVALIDARG;
                }
        }
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid argument", _fx_));
                Hr = E_INVALIDARG;
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

#ifdef TEST_H245_VID_CAPS
STDMETHODIMP CCapturePin::TestH245VidC()
{
        HRESULT Hr = NOERROR;
        DWORD   dw;
        H245MediaCapabilityTable Table;
        H245MediaCapability *pIntersectedCapability;
        AM_MEDIA_TYPE *pAMMediaType;

        FX_ENTRY("CCapturePin::TestH245VidC")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Test GetH245VersionID
        GetH245VersionID(&dw);

        // Test GetFormatTable
        GetFormatTable(&Table);

        for (DWORD i=0; i < Table.uMappedCapabilities; i++)
        {
                // Test Refine
                for (DWORD j=0; j < Table.pCapabilityArray[i].uNumEntries; j++)
                        Refine(&Table.pCapabilityArray[i].h245MediaCapability, Table.pCapabilityArray[i].dwUniqueID, j);

                // Test IntersectFormats
                IntersectFormats(Table.pCapabilityArray[i].dwUniqueID, &Table.pCapabilityArray[i].h245MediaCapability, &Table.pCapabilityArray[i].h245MediaCapability, &pIntersectedCapability);

                // Test GetLocalFormat
                GetLocalFormat(Table.pCapabilityArray[i].dwUniqueID, pIntersectedCapability, &pAMMediaType);

                // Test FindIDByRange
                FindIDByRange(pAMMediaType, &dw);

                // Test ReleaseNegotiatedCapability
                ReleaseNegotiatedCapability(pIntersectedCapability);
        }

        // Test ReleaseFormatTable
        ReleaseFormatTable(&Table);

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\h245vide.cpp ===
/****************************************************************************
 *  @doc INTERNAL H245VIDE
 *
 *  @module H245VidE.cpp | Source file for the <c CCapturePin> class methods
 *    used to implement the video capture output pin H.245 encoder command
 *    methods.
 ***************************************************************************/

#include "Precomp.h"

/*****************************************************************************
 *  @doc INTERNAL CCAPTUREH245VIDCSTRUCTENUM
 *
 *  @struct VIDEOFASTUPDATEGOB_S | The <t VIDEOFASTUPDATEGOB_S> structure is
 *    used with the KSPROPERTY_H245VIDENCCOMMAND_VIDEOFASTUPDATEGOB property.
 *
 *  @field DWORD | dwFirstGOB | Specifies the number of the first GOB to be
 *    updated. This value is only valid between 0 and 17.
 *
 *  @field DWORD | dwNumberOfGOBs | Specifies the number of GOBs to be
 *    updated. This value is only valid between 1 and 18.
 ***************************************************************************/
typedef struct {
	DWORD dwFirstGOB;
	DWORD dwNumberOfGOBs;
} VIDEOFASTUPDATEGOB_S;

/*****************************************************************************
 *  @doc INTERNAL CCAPTUREH245VIDCSTRUCTENUM
 *
 *  @struct VIDEOFASTUPDATEMB_S | The <t VIDEOFASTUPDATEMB_S> structure is
 *    used with the KSPROPERTY_H245VIDENCCOMMAND_VIDEOFASTUPDATEMB property.
 *
 *  @field DWORD | dwFirstGOB | Specifies the number of the first GOB to be
 *    updated and is only relative to H.263. This value is only valid between
 *    0 and 255.
 *
 *  @field DWORD | dwFirstMB | Specifies the number of the first MB to be
 *    updated and is only relative to H.261. This value is only valid
 *    between 1 and 8192.
 *
 *  @field DWORD | dwNumberOfMBs | Specifies the number of MBs to be
 *    updated. This value is only valid between 1 and 8192.
 ***************************************************************************/
typedef struct {
	DWORD dwFirstGOB;
	DWORD dwFirstMB;
	DWORD dwNumberOfMBs;
} VIDEOFASTUPDATEMB_S;

/*****************************************************************************
 *  @doc INTERNAL CCAPTUREH245VIDCSTRUCTENUM
 *
 *  @struct VIDEONOTDECODEDMBS_S | The <t VIDEONOTDECODEDMBS_S> structure is
 *    used with the KSPROPERTY_H245VIDENCINDICATION_VIDEONOTDECODEDMBS property.
 *
 *  @field DWORD | dwFirstMB | Specifies the number of the first MB treated
 *    as not coded. This value is only valid between 1 and 8192.
 *
 *  @field DWORD | dwNumberOfMBs | Specifies the number of MBs treated as not
 *    coded. This value is only valid between 1 and 8192.
 *
 *  @field DWORD | dwTemporalReference | Specifies the temporal reference of
 *    the picture containing not decoded MBs. This value is only valid
 *    between 0 and 255.
 ***************************************************************************/
typedef struct {
	DWORD dwFirstMB;
	DWORD dwNumberOfMBs;
	DWORD dwTemporalReference;
} VIDEONOTDECODEDMBS_S;

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPINMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | videoFastUpdatePicture | This
 *    method is used to specify to the compressed video output pin to enter
 *    the fast-update picture mode at its earliest opportunity.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CCapturePin::videoFastUpdatePicture()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCapturePin::videoFastUpdatePicture")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Remember to generate an I-frame 
	m_fFastUpdatePicture = TRUE;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPINMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | videoFastUpdateGOB | This
 *    method is used to specify to the compressed video output pin to
 *    perform a fast update of one or more GOBs.
 *
 *  @parm DWORD | dwFirstGOB | Specifies the number of the first GOB to be
 *    updated. This value is only valid between 0 and 17.
 *
 *  @parm DWORD | dwNumberOfGOBs | Specifies the number of GOBs to be
 *    updated. This value is only valid between 1 and 18.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CCapturePin::videoFastUpdateGOB(IN DWORD dwFirstGOB, IN DWORD dwNumberOfGOBs)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCapturePin::videoFastUpdateGOB")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(dwFirstGOB <= 17);
	ASSERT(dwNumberOfGOBs >= 1 && dwNumberOfGOBs <= 18);
	if (dwFirstGOB > 17 || dwNumberOfGOBs > 18 || dwNumberOfGOBs == 0)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	// Our encoder does not support this command 
	Hr = E_NOTIMPL;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPINMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | videoFastUpdateMB | This
 *    method is used to specify to the compressed video output pin to
 *    perform a fast update of one or more GOBs.
 *
 *  @parm DWORD | dwFirstGOB | Specifies the number of the first GOB to be
 *    updated and is only relative to H.263. This value is only valid
 *    between 0 and 255.
 *
 *  @parm DWORD | dwFirstMB | Specifies the number of the first MB to be
 *    updated and is only relative to H.261. This value is only valid
 *    between 1 and 8192.
 *
 *  @parm DWORD | dwNumberOfMBs | Specifies the number of MBs to be updated.
 *    This value is only valid between 1 and 8192.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CCapturePin::videoFastUpdateMB(IN DWORD dwFirstGOB, IN DWORD dwFirstMB, IN DWORD dwNumberOfMBs)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCapturePin::videoFastUpdateMB")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(dwFirstGOB <= 255);
	ASSERT(dwFirstMB >= 1 && dwFirstMB <= 8192);
	ASSERT(dwNumberOfMBs >= 1 && dwNumberOfMBs <= 8192);
	if (dwFirstGOB > 255 || dwFirstMB == 0 || dwFirstMB > 8192 || dwNumberOfMBs == 0 || dwNumberOfMBs > 8192)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	// Our encoder does not support this command 
	Hr = E_NOTIMPL;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPINMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | videoSendSyncEveryGOB | This
 *    method is used to specify to the compressed video output pin to use
 *    sync for every GOB as defined in H.263.
 *
 *  @parm BOOL | fEnable | If set to TRUE, specifies that the video
 *    output pin should use sync for every GOB; if set to FALSE, specifies
 *    that the video output pin should decide the frequency of GOB syncs on
 *    its own.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CCapturePin::videoSendSyncEveryGOB(IN BOOL fEnable)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCapturePin::videoSendSyncEveryGOB")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Our encoder does not support this command 
	Hr = E_NOTIMPL;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTUREPINMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | videoNotDecodedMBs | This
 *    method is used to indicate to the compressed video output pin that a
 *    set of MBs has been received with errors and that any MB in the
 *    specified set has been treated as not coded.
 *
 *  @parm DWORD | dwFirstMB | Specifies the number of the first MB
 *    treated as not coded. This value is only valid between 1 and 8192.
 *
 *  @parm DWORD | dwNumberOfMBs | Specifies the number of MBs treated as not
 *    coded. This value is only valid between 1 and 8192.
 *
 *  @parm DWORD | dwTemporalReference | Specifies the temporal reference of
 *    the picture containing not decoded MBs. This value is only valid
 *    between 0 and 255.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CCapturePin::videoNotDecodedMBs(IN DWORD dwFirstMB, IN DWORD dwNumberOfMBs, IN DWORD dwTemporalReference)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCapturePin::videoNotDecodedMBs")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(dwFirstMB >= 1 && dwFirstMB <= 8192);
	ASSERT(dwNumberOfMBs >= 1 && dwNumberOfMBs <= 8192);
	ASSERT(dwTemporalReference <= 255);
	if (dwTemporalReference > 255 || dwFirstMB == 0 || dwFirstMB > 8192 || dwNumberOfMBs == 0 || dwNumberOfMBs > 8192)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	// Our encoder does not handle this indication
	Hr = E_NOTIMPL;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\h26xenc.h ===
/****************************************************************************
 *  @doc INTERNAL H26XENC
 *
 *  @module H26XEnc.h | Header file for the <c CH26XEncoder> class methods
 *    used to implement the H.26X video encoder.
 ***************************************************************************/

#ifndef _H26XENC_H_
#define _H26XENC_H_

/****************************************************************************
 *  @doc INTERNAL CH26XENCCLASS
 *
 *  @class CH26XEncoder | This class implement the H.263 video encoder.
 ***************************************************************************/
class CH26XEncoder : public CConverter
{
	public:

	DECLARE_IUNKNOWN
	CH26XEncoder(IN TCHAR *pObjectName, IN CTAPIBasePin *pBasePin, IN PBITMAPINFOHEADER pbiIn, IN PBITMAPINFOHEADER pbiOut, IN HRESULT *pHr);
	~CH26XEncoder();
	static HRESULT CALLBACK CreateH26XEncoder(IN CTAPIBasePin *pBasePin, IN PBITMAPINFOHEADER pbiIn, IN PBITMAPINFOHEADER pbiOut, OUT CConverter **ppConverter);

	// Format conversion routines
	HRESULT ConvertFrame(IN PBYTE pbyInput, IN DWORD dwInputSize, IN PBYTE pbyOutput, OUT PDWORD pdwOutputSize, OUT PDWORD pdwBytesExtent, IN PBYTE pbyPreview, OUT PDWORD pdwPreviewSize, IN BOOL fSendKeyFrame);
	HRESULT OpenConverter();
	HRESULT CloseConverter();

	protected:

	LPFNDRIVERPROC	m_pDriverProc;	// DriverProc() function pointer
#if DXMRTP <= 0
	HINSTANCE		m_hTAPIH26XDLL;	// DLL Handle to TAPIH263.dll or TAPIH261.dll
#endif
	LPINST			m_pInstInfo;
};

#endif // _H26XENC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\ivideo32.h ===
/****************************************************************************/
/*                                                                          */
/*  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY   */
/*  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE     */
/*  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR   */
/*  PURPOSE.                                                                */
/*        MSVIDEO.H - Include file for Video APIs                           */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1993, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#include <vfw.h>

// unicode conversions
int Iwcstombs(LPSTR lpstr, LPCWSTR lpwstr, int len);
int Imbstowcs(LPWSTR lpwstr, LPCSTR lpstr, int len);

typedef unsigned __int64 QUADWORD;
#define HVIDEOX HVIDEO
#define PTR32   LPVOID
#define PTR16   LPVOID
#ifndef DWORD_PTR
#define DWORD_PTR unsigned long
#endif
#ifndef INT_PTR
#define INT_PTR int
#endif
#ifndef LONG_PTR
#define LONG_PTR long
#endif
#ifndef UINT_PTR
#define UINT_PTR unsigned int
#endif

// 'cooked' SMPTE timecode.  this is organized so that
// timecode values can be compared as a single QUAD operation
// so long as frame rates match.
//
// it is treated as a fixed point 48bit binary real number
// with the decimal point always at 32.16
//
// the only non-integral frame rate is 29.97 (NTSC) which is
// indicated by 0 in the frame rate field.
//
typedef union _vidxtimecode {
   struct {
      WORD  wFrameRate;  // 0 == 29.97 frame rate
      WORD  wFrameFract; // fractional frames. range 0-FFFF
      DWORD dwFrames;    // frame count.
      };
   QUADWORD qw;          // for copy/compare operations.
   } VIDXTIMECODE;

// timecode + userdata
//
typedef struct _vidxtimecodedata {
   VIDXTIMECODE time;
   DWORD    dwSMPTEFlags;
   DWORD    dwUser;
   } VIDXTIMECODEDATA;

// structure of memory shared between driver and quartz
// capture. used to allow Quartz to slave a clock to
// the vsync interrupt.
//
// This memory region will be locked down prior to being
// passed to the driver in Win95 so that it may be accessed at
// interrupt time. Because of the way the thunking layer works,
// it is not advisable for the driver to attempt to lock this
// memory. The memory will be visible in all process contexts.
//
// The driver is responsible for updating nVsyncCount on each VSYNC
// or as often as possible.  Whenever nVsyncCount is updated, qwSystemTime
// should be updated also, and if SMPTE timecode corresponding to this VSYNC
// is available, tcdata should be updated also.  If SMPTE timecode for this
// VSYNC is NOT available, dwFlags should be changed to indicate there is no
// timecode infomation (clear the VSYNCMEM_FLAGS_SMPTE bit of dwFlags)
//
// While updating, the driver should set the low bit of the dwInUse flag to 1.
//
// The driver should set the dwFlags field to indicated the presense
// of valid nVsyncCount/qwSystemTime and tcdata.
//
// The driver is allowed to choose between setting qwSystemTime to the return
// value of QueryPerformanceCounter or the value of the Pentium tick.  It is
// recommended to use QPC on NT as the pentium tick is not necessarily available
// to application code in that environment.
//
// When the Quartz capture wrapper reads from this shared memory, it will check
// the dwInUse flag and also read twice comparing results to insure that it reads
// valid, consistent data.
//
typedef struct _vsyncmem {
   DWORD        dwInUse;       // low bit is non-zero when the driver is
                               // updating this struture.  other bits reserved.

   DWORD        nVsyncCount;  // VSYNC count
   QUADWORD     qwSystemTime; // QueryPerformanceCounter value at this VSYNC

   DWORD        dwFlags;      // flags indicate which fields are in use
   #define VSYNCMEM_TIME_MASK    0x0000000F // mask to get type of qwSystemTime
   #define VSYNCMEM_TIME_QPC     0x00000001 // qwSystemTime is QueryPerformanceCounter
   #define VSYNCMEM_TIME_PENTIUM 0x00000002 // qwSystemTime is pentium CPU tick

   #define VSYNCMEM_FLAG_SMPTE   0x00000010  // set if tcdata is valid

   DWORD        dwSpare;      // spare to align the next field on Quad boundary
   VIDXTIMECODEDATA tcdata;   // SMPTE timecode associated with this VSYNC
   } VSYNCMEM;

// DVM_xxx messages are defined in VFW.H
//
#ifndef DVM_CONFIGURE_START
  #define DVM_CONFIGURE_START 0x1000
#endif
#define DVM_CLOCK_BUFFER     (UINT)(DVM_CONFIGURE_START+0x10)
   //
   // dw1 = ptr to VSYNCMEM. ptr is valid until next DVM_CLOCK_BUFFER message
   //       or until driver is closed.
   // dw2 = size of VSYNCMEM buffer
   //
   // driver should return MMSYSERR_NOERROR (0) to indicate that it is
   // capable of keeping the contents of the VSYNCMEM buffer up to date.
   //


// VIDEOHDR + extra fields used by the thunking layer
//
typedef struct _thk_videohdr {
    //VIDEOHDREX vh;
    VIDEOHDR vh;
    PTR32      p32Buff;
    PTR16      p16Alloc;
    DWORD      dwMemHandle;
    DWORD      dwTile;
    DWORD_PTR  dwUser;          // use this instead of dwUser in VIDEOHDR
                                // because some drivers trash it! (Miro DC30)
    DWORD      dwIndex;         // which header is this in our array?
    PTR32      pStart;
} THKVIDEOHDR, FAR *LPTHKVIDEOHDR;

DWORD WINAPI vidxAllocHeaders(
   HVIDEOX     hVideo,
   UINT        nHeaders,
   UINT        cbHeader,
   PTR32 FAR * lpHdrs);
DWORD WINAPI NTvidxAllocHeaders(
   HVIDEOX     hVideo,
   UINT        nHeaders,
   UINT        cbHeader,
   PTR32 FAR * lpHdrs);

DWORD WINAPI vidxFreeHeaders(
   HVIDEOX hv);
DWORD WINAPI NTvidxFreeHeaders(
   HVIDEOX hv);

DWORD WINAPI vidxAllocBuffer (
   HVIDEOX     hv,
   UINT        iHdr,
   PTR32 FAR * pp32Hdr,
   DWORD       dwSize);
DWORD WINAPI NTvidxAllocBuffer (
   HVIDEOX     hv,
   UINT        iHdr,
   PTR32 FAR * pp32Hdr,
   DWORD       dwSize);

DWORD WINAPI vidxFreeBuffer (
   HVIDEOX hv,
   DWORD   p32Hdr);
DWORD WINAPI NTvidxFreeBuffer (
   HVIDEOX hv,
   DWORD_PTR p32Hdr);

DWORD WINAPI vidxFrame (
   HVIDEOX       hVideo,
   //LPVIDEOHDREX lpVHdr);
   LPVIDEOHDR lpVHdr);
DWORD WINAPI NTvidxFrame (
   HVIDEOX       hVideo,
   //LPVIDEOHDREX lpVHdr);
   LPVIDEOHDR lpVHdr);

DWORD WINAPI vidxAddBuffer (
   HVIDEOX       hVideo,
   PTR32         lpVHdr,
   DWORD         cbData);
DWORD WINAPI NTvidxAddBuffer (
   HVIDEOX       hVideo,
   PTR32         lpVHdr,
   DWORD         cbData);

DWORD WINAPI vidxAllocPreviewBuffer (
   HVIDEOX      hVideo,
   PTR32 FAR *  lpBits,
   UINT         cbHdr,
   DWORD        cbData);
DWORD WINAPI NTvidxAllocPreviewBuffer (
   HVIDEOX      hVideo,
   PTR32 FAR *  lpBits,
   UINT         cbHdr,
   DWORD        cbData);

DWORD WINAPI vidxFreePreviewBuffer (
   HVIDEOX     hVideo,
   PTR32       lpBits);
DWORD WINAPI NTvidxFreePreviewBuffer (
   HVIDEOX     hVideo,
   PTR32       lpBits);

// Needed for Win9x thunking
VOID WINAPI OpenMMDEVLDR(void);
VOID WINAPI CloseMMDEVLDR(void);

BOOL NTvideoInitHandleList(void);
void NTvideoDeleteHandleList(void);
DWORD WINAPI videoOpen(LPHVIDEO lphVideo, DWORD dwDevice, DWORD dwFlags);
DWORD WINAPI NTvideoOpen(LPHVIDEO lphVideo, DWORD dwDevice, DWORD dwFlags);
DWORD WINAPI videoClose(HVIDEO hVideo);
DWORD WINAPI NTvideoClose(HVIDEO hVideo);
DWORD WINAPI videoDialog(HVIDEO hVideo, HWND hWndParent, DWORD dwFlags);
DWORD WINAPI NTvideoDialog(HVIDEO hVideo, HWND hWndParent, DWORD dwFlags);
DWORD WINAPI videoGetChannelCaps(HVIDEO hVideo, LPCHANNEL_CAPS lpChannelCaps, DWORD dwSize);
DWORD WINAPI NTvideoGetChannelCaps(HVIDEO hVideo, LPCHANNEL_CAPS lpChannelCaps, DWORD dwSize);
DWORD WINAPI videoConfigure(HVIDEO hVideo, UINT msg, DWORD dwFlags, LPDWORD lpdwReturn, LPVOID lpData1, DWORD dwSize1, LPVOID lpData2, DWORD dwSize2);
DWORD WINAPI NTvideoConfigure(HVIDEO hVideo, UINT msg, DWORD dwFlags, LPDWORD lpdwReturn, LPVOID lpData1, DWORD dwSize1, LPVOID lpData2, DWORD dwSize2);
DWORD WINAPI videoFrame(HVIDEO hVideo, LPVIDEOHDR lpVHdr);
DWORD WINAPI NTvideoFrame(HVIDEO hVideo, LPVIDEOHDR lpVHdr);
DWORD WINAPI videoStreamInit(HVIDEO hVideo, DWORD dwMicroSecPerFrame, DWORD_PTR dwCallback, DWORD_PTR dwCallbackInst, DWORD dwFlags);
DWORD WINAPI NTvideoStreamInit(HVIDEO hVideo, DWORD dwMicroSecPerFrame, DWORD_PTR dwCallback, DWORD_PTR dwCallbackInst, DWORD dwFlags);
DWORD WINAPI videoStreamFini(HVIDEO hVideo);
DWORD WINAPI NTvideoStreamFini(HVIDEO hVideo);
DWORD WINAPI videoStreamReset(HVIDEO hVideo);
DWORD WINAPI NTvideoStreamReset(HVIDEO hVideo);
DWORD WINAPI videoStreamStart(HVIDEO hVideo);
DWORD WINAPI NTvideoStreamStart(HVIDEO hVideo);
DWORD WINAPI videoStreamStop(HVIDEO hVideo);
DWORD WINAPI NTvideoStreamStop(HVIDEO hVideo);
DWORD WINAPI videoCapDriverDescAndVer(DWORD dwDeviceID, LPTSTR lpszDesc, UINT cbDesc, LPTSTR lpszVer, UINT cbVer, LPTSTR lpszDllName, UINT cbDllName);
DWORD WINAPI NTvideoCapDriverDescAndVer(DWORD dwDeviceID, LPTSTR lpszDesc, UINT cbDesc, LPTSTR lpszVer, UINT cbVer, LPTSTR lpszDllName, UINT cbDllName);
LONG  WINAPI videoMessage(HVIDEO hVideo, UINT uMsg, LPARAM dw1, LPARAM dw2);
LONG WINAPI NTvideoMessage(HVIDEO hVideo, UINT uMsg, LPARAM dw1, LPARAM dw2);
DWORD WINAPI videoGetNumDevs(BOOL);
DWORD WINAPI videoFreeDriverList(void);

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\overlay.cpp ===
/****************************************************************************
 *  @doc INTERNAL OVERLAY
 *
 *  @module Overlay.cpp | Source file for the <c COverlayPin> class methods
 *    used to implement the video overlay pin.
 ***************************************************************************/

#include "Precomp.h"

#ifdef USE_OVERLAY

/****************************************************************************
 *  @doc INTERNAL COVERLAYPINMETHOD
 *
 *  @mfunc COverlayPin* | COverlayPin | CreateOverlayPin | This
 *    helper function creates an output pin for overlay preview.
 *
 *  @parm CTAPIVCap* | pCaptureFilter | Specifies a pointer to the owner
 *    filter.
 *
 *  @parm HRESULT * | pHr | Specifies a pointer to the return error code.
 *
 *  @rdesc Returns a pointer to the preview pin.
 ***************************************************************************/
HRESULT CALLBACK COverlayPin::CreateOverlayPin(CTAPIVCap *pCaptureFilter, COverlayPin **ppOverlayPin)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("COverlayPin::CreateOverlayPin")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pCaptureFilter);
	ASSERT(ppOverlayPin);
	if (!pCaptureFilter || !ppOverlayPin)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		goto MyExit;
	}

	if (!(*ppOverlayPin = (COverlayPin *) new COverlayPin(NAME("Video Overlay Stream"), pCaptureFilter, &Hr, L"Overlay")))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
		Hr = E_OUTOFMEMORY;
		goto MyExit;
	}

	// If initialization failed, delete the stream array and return the error
	if (FAILED(Hr) && *ppOverlayPin)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Initialization failed", _fx_));
		Hr = E_FAIL;
		delete *ppOverlayPin;
		*ppOverlayPin = NULL;
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COVERLAYPINMETHOD
 *
 *  @mfunc HRESULT | COverlayPin | COverlayPin | This method is the
 *  constructorfor the <c COverlayPin> object
 *
 *  @rdesc Nada.
 ***************************************************************************/
COverlayPin::COverlayPin(IN TCHAR *pObjectName, IN CTAPIVCap *pCapture, IN HRESULT *pHr, IN LPCWSTR pName) : CBaseOutputPin(pObjectName, pCapture, &pCapture->m_lock, pHr, pName), m_pCaptureFilter(pCapture)
{
	FX_ENTRY("COverlayPin::COverlayPin")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL COVERLAYPINMETHOD
 *
 *  @mfunc void | COverlayPin | ~COverlayPin | This method is the destructor
 *    for the <c COverlayPin> object.
 *
 *  @rdesc Nada.
 ***************************************************************************/
COverlayPin::~COverlayPin()
{
	FX_ENTRY("COverlayPin::~COverlayPin")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL COVERLAYPINMETHOD
 *
 *  @mfunc HRESULT | COverlayPin | NonDelegatingQueryInterface | This
 *    method is the nondelegating interface query function. It returns a pointer
 *    to the specified interface if supported. The only interfaces explicitly
 *    supported being <i IAMStreamConfig>,
 *    <i IAMStreamControl>, <i ICPUControl>, <i IFrameRateControl>,
 *    <i IBitrateControl>, <i INetworkStats>, <i IH245EncoderCommand>
 *    and <i IProgressiveRefinement>.
 *
 *  @parm REFIID | riid | Specifies the identifier of the interface to return.
 *
 *  @parm PVOID* | ppv | Specifies the place in which to put the interface
 *    pointer.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP COverlayPin::NonDelegatingQueryInterface(IN REFIID riid, OUT void **ppv)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("COverlayPin::NonDelegatingQueryInterface")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(ppv);
	if (!ppv)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Retrieve interface pointer
	if (riid == __uuidof(IAMStreamConfig))
	{
		if (FAILED(Hr = GetInterface(static_cast<IAMStreamConfig*>(this), ppv)))
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: NDQI for IAMStreamConfig failed Hr=0x%08lX", _fx_, Hr));
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: IAMStreamConfig*=0x%08lX", _fx_, *ppv));
		}

		goto MyExit;
	}
	else if (riid == __uuidof(IAMStreamControl))
	{
		if (FAILED(Hr = GetInterface(static_cast<IAMStreamControl*>(this), ppv)))
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: NDQI for IAMStreamControl failed Hr=0x%08lX", _fx_, Hr));
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: IAMStreamControl*=0x%08lX", _fx_, *ppv));
		}

		goto MyExit;
	}

	if (FAILED(Hr = CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, WARN, "%s:   WARNING: NDQI for {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX} failed Hr=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], Hr));
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX}*=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], *ppv));
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COVERLAYPINMETHOD
 *
 *  @mfunc HRESULT | COverlayPin | GetMediaType | This method retrieves one
 *    of the media types supported by the pin, which is used by enumerators.
 *
 *  @parm int | iPosition | Specifies a position in the media type list.
 *
 *  @parm CMediaType* | pMediaType | Specifies a pointer to the media type at
 *    the <p iPosition> position in the list of supported media types.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag VFW_S_NO_MORE_ITEMS | End of the list of media types has been reached
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT COverlayPin::GetMediaType(IN int iPosition, OUT CMediaType *pMediaType)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("COverlayPin::GetMediaType")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(iPosition >= 0);
	ASSERT(pMediaType);
	if (iPosition < 0)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid input parameter!", _fx_));
		Hr = E_INVALIDARG;
		goto MyExit;
	}
	if (!pMediaType)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid input parameter!", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// @comm Put some real code here! 
	Hr = E_NOTIMPL;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COVERLAYPINMETHOD
 *
 *  @mfunc HRESULT | COverlayPin | CheckMediaType | This method is used to
 *    determine if the pin can support a specific media type.
 *
 *  @parm CMediaType* | pMediaType | Specifies a pointer to the media type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT COverlayPin::CheckMediaType(IN const CMediaType *pMediaType)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("COverlayPin::CheckMediaType")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pMediaType);
	if (!pMediaType)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid input parameter!", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// @comm Put some real code here! 
	Hr = E_NOTIMPL;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COVERLAYPINMETHOD
 *
 *  @mfunc HRESULT | COverlayPin | SetMediaType | This method is used to
 *    set a specific media type on a pin.
 *
 *  @parm CMediaType* | pMediaType | Specifies a pointer to the media type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT COverlayPin::SetMediaType(IN CMediaType *pMediaType)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("COverlayPin::SetMediaType")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pMediaType);
	if (!pMediaType)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid input parameter!", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// @comm Put some real code here! 
	Hr = E_NOTIMPL;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COVERLAYPINMETHOD
 *
 *  @mfunc HRESULT | COverlayPin | SetFormat | This method is used to
 *    set a specific media type on a pin.
 *
 *  @parm AM_MEDIA_TYPE* | pmt | Specifies a pointer to an <t AM_MEDIA_TYPE>
 *    structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP COverlayPin::SetFormat(AM_MEDIA_TYPE *pmt)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("COverlayPin::SetFormat")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pmt);
	if (!pmt)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid input parameter!", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// @comm Put some real code here! 
	Hr = E_NOTIMPL;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COVERLAYPINMETHOD
 *
 *  @mfunc HRESULT | COverlayPin | GetFormat | This method is used to
 *    retrieve the current media type on a pin.
 *
 *  @parm AM_MEDIA_TYPE** | ppmt | Specifies the address of a pointer to an
 *    <t AM_MEDIA_TYPE> structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP COverlayPin::GetFormat(OUT AM_MEDIA_TYPE **ppmt)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("COverlayPin::GetFormat")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(ppmt);
	if (!ppmt)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid input parameter!", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// @comm Put some real code here! 
	Hr = E_NOTIMPL;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COVERLAYPINMETHOD
 *
 *  @mfunc HRESULT | COverlayPin | GetNumberOfCapabilities | This method is
 *    used to retrieve the number of stream capabilities structures.
 *
 *  @parm int* | piCount | Specifies a pointer to an int to receive the
 *    number of <t VIDEO_STREAM_CONFIG_CAPS> structures supported.
 *
 *  @parm int* | piSize | Specifies a pointer to an int to receive the
 *    size of the <t VIDEO_STREAM_CONFIG_CAPS> configuration structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP COverlayPin::GetNumberOfCapabilities(OUT int *piCount, OUT int *piSize)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("COverlayPin::GetNumberOfCapabilities")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(piCount);
	ASSERT(piSize);
	if (!piCount || !piSize)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid input parameter!", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// @comm Put some real code here! 
	Hr = E_NOTIMPL;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COVERLAYPINMETHOD
 *
 *  @mfunc HRESULT | COverlayPin | GetStreamCaps | This method is
 *    used to retrieve a video stream capability pair.
 *
 *  @parm int | iIndex | Specifies the index to the desired media type
 *    and capability pair.
 *
 *  @parm AM_MEDIA_TYPE** | ppmt | Specifies the address of a pointer to an
 *    <t AM_MEDIA_TYPE> structure.
 *
 *  @parm LPBYTE | pSCC | Specifies a pointer to a
 *    <t VIDEO_STREAM_CONFIG_CAPS> configuration structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP COverlayPin::GetStreamCaps(IN int iIndex, OUT AM_MEDIA_TYPE **ppmt, OUT LPBYTE pSCC)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("COverlayPin::GetStreamCaps")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	// @comm Validate iIndex too
	ASSERT(ppmt);
	ASSERT(pSCC);
	if (!ppmt || !pSCC)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid input parameter!", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// @comm Put some real code here! 
	Hr = E_NOTIMPL;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COVERLAYPINMETHOD
 *
 *  @mfunc HRESULT | COverlayPin | DecideBufferSize | This method is
 *    used to retrieve the number and size of buffers required for transfer.
 *
 *  @parm IMemAllocator* | pAlloc | Specifies a pointer to the allocator
 *    assigned to the transfer.
 *
 *  @parm ALLOCATOR_PROPERTIES* | ppropInputRequest | Specifies a pointer to an
 *    <t ALLOCATOR_PROPERTIES> structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT COverlayPin::DecideBufferSize(IN IMemAllocator *pAlloc, OUT ALLOCATOR_PROPERTIES *ppropInputRequest)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("COverlayPin::DecideBufferSize")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	// @comm Validate iIndex too
	ASSERT(pAlloc);
	ASSERT(ppropInputRequest);
	if (!pAlloc || !ppropInputRequest)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid input parameter!", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// @comm Put some real code here! 
	Hr = E_NOTIMPL;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COVERLAYPINMETHOD
 *
 *  @mfunc HRESULT | COverlayPin | DecideAllocator | This method is
 *    used to negotiate the allocator to use.
 *
 *  @parm IMemInputPin* | pPin | Specifies a pointer to the IPin interface
 *    of the connecting pin.
 *
 *  @parm IMemAllocator** | ppAlloc | Specifies a pointer to the negotiated
 *    IMemAllocator interface.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT COverlayPin::DecideAllocator(IN IMemInputPin *pPin, OUT IMemAllocator **ppAlloc)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("COverlayPin::DecideAllocator")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	// @comm Validate iIndex too
	ASSERT(pPin);
	ASSERT(ppAlloc);
	if (!pPin || !ppAlloc)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid input parameter!", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// @comm Put some real code here! 
	Hr = E_NOTIMPL;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COVERLAYPINMETHOD
 *
 *  @mfunc HRESULT | COverlayPin | Active | This method is called by the
 *    <c CBaseFilter> implementation when the state changes from stopped to
 *    either paused or running.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT COverlayPin::Active()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("COverlayPin::Active")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// @comm Put some real code here! 
	Hr = E_NOTIMPL;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COVERLAYPINMETHOD
 *
 *  @mfunc HRESULT | COverlayPin | Inactive | This method is called by the
 *    <c CBaseFilter> implementation when the state changes from either
 *    paused or running to stopped.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT COverlayPin::Inactive()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("COverlayPin::Inactive")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// @comm Put some real code here! 
	Hr = E_NOTIMPL;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COVERLAYPINMETHOD
 *
 *  @mfunc HRESULT | COverlayPin | ActiveRun | This method is called by the
 *    <c CBaseFilter> implementation when the state changes from paused to
 *    running mode.
 *
 *  @parm REFERENCE_TIME | tStart | ???.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT COverlayPin::ActiveRun(IN REFERENCE_TIME tStart)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("COverlayPin::ActiveRun")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// @comm Put some real code here! 
	Hr = E_NOTIMPL;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COVERLAYPINMETHOD
 *
 *  @mfunc HRESULT | COverlayPin | ActivePause | This method is called by the
 *    <c CBaseFilter> implementation when the state changes from running to
 *    paused mode.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT COverlayPin::ActivePause()
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("COverlayPin::ActivePause")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// @comm Put some real code here! 
	Hr = E_NOTIMPL;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL COVERLAYPINMETHOD
 *
 *  @mfunc HRESULT | COverlayPin | Notify | This method is called by the
 *    <c CBaseFilter> implementation when the state changes from paused to
 *    running mode.
 *
 *  @parm IBaseFilter* | pSelf | Specifies a pointer to the filter that is
 *    sending the quality notification.
 *
 *  @parm Quality | q | Specifies a Quality notification structure.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP COverlayPin::Notify(IN IBaseFilter *pSelf, IN Quality q)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("COverlayPin::Notify")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pSelf);
	if (!pSelf)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid input parameter!", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// @comm Put some real code here! 
	Hr = E_NOTIMPL;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\h26xenc.cpp ===
/****************************************************************************
 *  @doc INTERNAL H26XENC
 *
 *  @module H26XEnc.cpp | Source file for the <c CH26XEncoder> class methods
 *    used to implement the H.26X video encoder.
 ***************************************************************************/

#include "Precomp.h"

#define MIN_IFRAME_REQUEST_INTERVAL 15000

//#define DEBUG_BITRATE
// ... && defined(DEBUG_BITRATE)
#undef D
#if defined(DEBUG)
  #include <stdio.h>
  #include <stdarg.h>

  static int dprintf( char * format, ... )
  {
      char out[1024];
      int r;
      va_list marker;
      va_start(marker, format);
      r=_vsnprintf(out, 1022, format, marker);
      va_end(marker);
      OutputDebugString( out );
      return r;
  }

  #ifdef DEBUG_BITRATE
    int g_dbg_H26XEnc=1;
  #else
    int g_dbg_H26XEnc=0;
  #endif

  #define D(f) if(g_dbg_H26XEnc & (f))

#else
  #define D(f)
  #define dprintf ; / ## /
#endif


/****************************************************************************
 *  @doc INTERNAL CH26XENCMETHOD
 *
 *  @mfunc void | CH26XEncoder | CH26XEncoder | This method is the constructor
 *    for the <c CH26XEncoder> object.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CH26XEncoder::CH26XEncoder(IN TCHAR *pObjectName, IN CTAPIBasePin *pBasePin, IN PBITMAPINFOHEADER pbiIn, IN PBITMAPINFOHEADER pbiOut, IN HRESULT *pHr) : CConverter(pObjectName, pBasePin, pbiIn, pbiOut, pHr)
{
        FX_ENTRY("CH26XEncoder::CH26XEncoder")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        if (!pHr || FAILED(*pHr))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null input pointer", _fx_));
                goto MyExit;
        }

        // Default inits
        m_pInstInfo             = NULL;
#if DXMRTP <= 0
        m_hTAPIH26XDLL  = NULL;
#endif
        m_pDriverProc   = NULL;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CH26XENCMETHOD
 *
 *  @mfunc void | CH26XEncoder | ~CH26XEncoder | This method is the destructor
 *    for the <c CH26XEncoder> object
 *
 *  @rdesc Nada.
 ***************************************************************************/
CH26XEncoder::~CH26XEncoder()
{
        FX_ENTRY("CH26XEncoder::~CH26XEncoder")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Default cleanup

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CH26XENCMETHOD
 *
 *  @mfunc CH26XEncoder* | CH26XEncoder | CreateCH26XEncoder | This
 *    helper function creates an object to interact with the H.26X encoder.
 *
 *  @parm CH26XEncoder** | ppCH26XEncoder | Specifies the address of a pointer to the
 *    newly created <c CH26XEncoder> object.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_OUTOFMEMORY | Out of memory
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CALLBACK CH26XEncoder::CreateH26XEncoder(IN CTAPIBasePin *pBasePin, IN PBITMAPINFOHEADER pbiIn, IN PBITMAPINFOHEADER pbiOut, OUT CConverter **ppH26XEncoder)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CH26XEncoder::CreateH26XEncoder")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pBasePin);
        ASSERT(ppH26XEncoder);
        if (!pBasePin || !ppH26XEncoder)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        if (pbiOut->biCompression == FOURCC_M263)
        {
                if (!(*ppH26XEncoder = (CConverter *) new CH26XEncoder(NAME("H.263 Encoder"), pBasePin, pbiIn, pbiOut, &Hr)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                        Hr = E_OUTOFMEMORY;
                        goto MyExit;
                }
        }
        else if (pbiOut->biCompression == FOURCC_M261)
        {
                if (!(*ppH26XEncoder = (CConverter *) new CH26XEncoder(NAME("H.261 Encoder"), pBasePin, pbiIn, pbiOut, &Hr)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                        Hr = E_OUTOFMEMORY;
                        goto MyExit;
                }
        }
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Not an H.26x encoder", _fx_));
                Hr = E_UNEXPECTED;
                goto MyExit;
        }

        // If initialization failed, delete the stream array and return the error
        if (FAILED(Hr) && *ppH26XEncoder)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Initialization failed", _fx_));
                Hr = E_FAIL;
                delete *ppH26XEncoder, *ppH26XEncoder = NULL;
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}


/****************************************************************************
 *  @doc INTERNAL CCONVERTMETHOD
 *
 *  @mfunc HRESULT | CH26XEncoder | OpenConverter | This method opens an H.26X
 *    encoder.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CH26XEncoder::OpenConverter()
{
        HRESULT                         Hr = NOERROR;
        LRESULT                         lRes;
        ICOPEN                          icOpen;
        ICCOMPRESSFRAMES        iccf = {0};
        PMSH26XCOMPINSTINFO     pciMSH26XInfo;
        PBITMAPINFOHEADER       pbiIn;

        FX_ENTRY("CH26XEncoder::OpenConverter")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(m_pbiIn);
        ASSERT(m_pbiOut);
        ASSERT(!m_pInstInfo);
        ASSERT(m_dwConversionType & CONVERSIONTYPE_ENCODE);
        if (m_pInstInfo || !m_pbiIn || !m_pbiOut || !(m_dwConversionType & CONVERSIONTYPE_ENCODE))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Previous converter needs to be closed first", _fx_));
                Hr = E_UNEXPECTED;
                goto MyExit;
        }

#if DXMRTP > 0
    m_pDriverProc = H26XDriverProc;
#else
        // Load TAPIH26X.DLL and get a proc address
        if (!(m_hTAPIH26XDLL = LoadLibrary("TAPIH26X")))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: TAPIH26X.dll load failed!", _fx_));
                Hr = E_FAIL;
                goto MyError3;
        }
        if (!(m_pDriverProc = (LPFNDRIVERPROC)GetProcAddress(m_hTAPIH26XDLL, "DriverProc")))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s: Couldn't find DriverProc on TAPIH26X.dll!", _fx_));
                Hr = E_FAIL;
                goto MyError3;
        }
#endif
        // Load encoder
        if (!(lRes = (*m_pDriverProc)(NULL, NULL, DRV_LOAD, 0L, 0L)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed to load encoder", _fx_));
                Hr = E_FAIL;
                goto MyError3;
        }

        // Open encoder
        icOpen.fccHandler = m_pbiOut->biCompression;
        icOpen.dwFlags = ICMODE_COMPRESS;
        if (!(m_pInstInfo = (LPINST)(*m_pDriverProc)(NULL, NULL, DRV_OPEN, 0L, (LPARAM)&icOpen)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed to open encoder", _fx_));
                Hr = E_FAIL;
                goto MyError3;
        }

        // Get info about this encoder
        m_dwFrame = 0L;
        // For now, issue a key frame every 15 seconds
        m_dwLastIFrameTime = GetTickCount();
        m_fPeriodicIFrames = TRUE;
        m_dwLastTimestamp = 0xFFFFFFFF;

        // Do any of the stuff that is MS H.263 or MS H.261 specific right here
        if (!(pciMSH26XInfo = (PMSH26XCOMPINSTINFO) new BYTE[sizeof(COMPINSTINFO)]))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory!", _fx_));
                Hr = E_OUTOFMEMORY;
                goto MyError4;
        }
        ZeroMemory(pciMSH26XInfo, sizeof(COMPINSTINFO));

        // Really configure the codec for compression
        pciMSH26XInfo->Configuration.bRTPHeader = TRUE;
        if (m_pBasePin->m_pCaptureFilter->m_pRtpPdPin)
                pciMSH26XInfo->Configuration.unPacketSize = m_pBasePin->m_pCaptureFilter->m_pRtpPdPin->m_dwMaxRTPPacketSize;
        else
                pciMSH26XInfo->Configuration.unPacketSize = DEFAULT_RTP_PACKET_SIZE;
        pciMSH26XInfo->Configuration.bEncoderResiliency = FALSE;
        pciMSH26XInfo->Configuration.unPacketLoss = 0;
        pciMSH26XInfo->Configuration.bBitRateState = TRUE;
        pciMSH26XInfo->Configuration.unBytesPerSecond = 1664;
        if (((DWORD) (*m_pDriverProc)((DWORD)m_pInstInfo, NULL, ICM_SETSTATE, (LPARAM)pciMSH26XInfo, sizeof(COMPINSTINFO))) != sizeof(COMPINSTINFO))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: ICSetState failed!", _fx_));
                Hr = E_FAIL;
                goto MyError5;
        }

        // Get rid of the state structure
        delete [] pciMSH26XInfo;

        // Initialize ICCOMPRESSFRAMES structure
        iccf.dwFlags = VIDCF_TEMPORAL | VIDCF_FASTTEMPORALC | VIDCF_CRUNCH | VIDCF_QUALITY;
        iccf.lQuality = 10000UL - (m_dwImageQuality * 322UL);
        iccf.lDataRate = m_dwImageQuality;
        iccf.lKeyRate = 0xFFFFFFFF;
        iccf.dwRate = 1000UL;
        iccf.dwScale = (LONG)m_pBasePin->m_lMaxAvgTimePerFrame / 1000UL;

        // Send this guy to the encoder
        if (((*m_pDriverProc)((DWORD)m_pInstInfo, NULL, ICM_COMPRESS_FRAMES_INFO, (DWORD)(LPVOID)&iccf, sizeof(iccf)) != ICERR_OK))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Codec failed to handle ICM_COMPRESS_FRAMES_INFO message correctly!", _fx_));
                Hr = E_FAIL;
                goto MyError4;
        }

        // Do we need to scale the input first?
        if (m_dwConversionType & CONVERSIONTYPE_SCALER)
        {
                pbiIn = m_pbiInt;

                // Do we need to prepare some stuff for the scaler to work?
                if (m_pbiInt->biCompression == BI_RGB && m_pbiInt->biBitCount == 8)
                {
                        if (!m_pBasePin->m_fNoImageStretch)
                        {
                                // Create a temporary palette
                                InitDst8(m_pbiInt);
                        }
                        else
                        {
                                // Look for the palette entry closest to black
                                InitBlack8(m_pbiIn);
                        }
                }
        }
        else
                pbiIn = m_pbiIn;

        // Start the encoder
        if (((*m_pDriverProc)((DWORD)m_pInstInfo, NULL, ICM_COMPRESS_BEGIN, (LPARAM)pbiIn, (LPARAM)m_pbiOut)) != MMSYSERR_NOERROR)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: ICCompressBegin failed!", _fx_));
                Hr = E_FAIL;
                goto MyError4;
        }

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: Compressor ready", _fx_));

        m_fConvert = TRUE;

        goto MyExit;

MyError5:
        if (pciMSH26XInfo)
                delete [] pciMSH26XInfo, pciMSH26XInfo = NULL;
MyError4:
        if (m_pInstInfo)
        {
                (*m_pDriverProc)((DWORD)m_pInstInfo, NULL, DRV_CLOSE, 0L, 0L);
                (*m_pDriverProc)((DWORD)m_pInstInfo, NULL, DRV_FREE, 0L, 0L);
                m_pInstInfo = NULL;
        }
MyError3:
        if (m_pbiInt)
                delete m_pbiInt, m_pbiInt = NULL;
        if (m_pbiOut)
                delete m_pbiOut, m_pbiOut = NULL;
        if (m_pbiIn)
                delete m_pbiIn, m_pbiIn = NULL;
MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

#define TARGETBITRATE m_pBasePin->m_pCaptureFilter->m_pCapturePin->m_lTargetBitrate
// below is in bps
#define BITRATE_LOWLIMIT        (25*1024)
#define LOWFRAMESIZE            5

#ifdef DEBUG
int g_skip_f = 0 ;
int g_skip_q = 0 ;
#endif

/****************************************************************************
 *  @doc INTERNAL CCONVERTMETHOD
 *
 *  @mfunc HRESULT | CH26XEncoder | ConvertFrame | This method converts
 *    a bitmap to H.26X.
 *
 *  @parm PBYTE | pbyInput | Pointer to the input buffer.
 *
 *  @parm DWORD | dwInputSize | Size of the input buffer.
 *
 *  @parm PBYTE | pbyOutput | Pointer to the output buffer.
 *
 *  @parm PDWORD | pdwOutputSize | Pointer to a DWORD to receive the size
 *    of the converted data.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CH26XEncoder::ConvertFrame(IN PBYTE pbyInput, IN DWORD dwInputSize, IN PBYTE pbyOutput, OUT PDWORD pdwOutputSize, OUT PDWORD pdwBytesExtent, IN PBYTE pbyPreview, IN OUT PDWORD pdwPreviewSize, IN BOOL fSendKeyFrame)
{
        HRESULT         Hr = NOERROR;
        BOOL            fKeyFrame;
    DWORD               dwMaxSizeThisFrame = 0xffffff;
        DWORD           ckid = 0UL;
        DWORD           dwFlags;
        DWORD           dwTimestamp;
        ICCOMPRESS      icCompress;
        PH26X_RTP_BSINFO_TRAILER pbsiT;
        RECT            rcRect;

        DWORD Min1;     // 1st term in the min operation performed to compute the dwMaxSizeThisFrame
        DWORD Min2;     // 2nd term in the min operation performed to compute the dwMaxSizeThisFrame
        DWORD aux;      // tmp var to adjust the above added for clarity (also debug print purposes)
#if defined(DEBUG) && defined(DEBUG_ENCODING)
        char szDebug[128];
#endif

        FX_ENTRY("CH26XEncoder::ConvertFrame")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pbyInput);
        ASSERT(pbyOutput);
        ASSERT(pdwOutputSize);
        ASSERT(m_pbiIn);
        ASSERT(m_pbiOut);
        ASSERT(m_fConvert);
        ASSERT(m_pInstInfo);
        if (!pbyInput || !pbyOutput || !pdwOutputSize)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }
        if (!m_pbiIn || !m_pbiOut || !m_fConvert || !m_pInstInfo)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Converter needs to be opened first", _fx_));
                Hr = E_UNEXPECTED;
                goto MyExit;
        }

        // Save the current time
        dwTimestamp = GetTickCount();

        // Compress
        fKeyFrame = fSendKeyFrame || (m_fPeriodicIFrames && (((dwTimestamp > m_dwLastIFrameTime) && ((dwTimestamp - m_dwLastIFrameTime) > MIN_IFRAME_REQUEST_INTERVAL)))) || (m_dwFrame == 0);
        dwFlags = fKeyFrame ? AVIIF_KEYFRAME : 0;

        Min1 = (DWORD)((LONGLONG)m_pBasePin->m_lCurrentAvgTimePerFrame * m_pBasePin->m_lTargetBitrate / 80000000);
        Min2 = ((VIDEOINFOHEADER_H263 *)(m_pBasePin->m_mt.pbFormat))->bmiHeader.dwBppMaxKb * 1024 / 8;

        D(1) dprintf("%s: dwMaxSizeThisFrame = min( %8lu , %8lu )\n",_fx_, Min1, Min2);

        dwMaxSizeThisFrame =
        min (
            Min1, // original 1st term : (DWORD)((LONGLONG)m_pBasePin->m_lCurrentAvgTimePerFrame * m_pBasePin->m_lTargetBitrate / 80000000),
            Min2  // original 2nd term : ((VIDEOINFOHEADER_H263 *)(m_pBasePin->m_mt.pbFormat))->bmiHeader.dwBppMaxKb * 1024 / 8
            );

#ifdef DEBUG
        if(!g_skip_f)
#endif
        { DWORD dwTargetBitrate=0;
          //now scale dwMaxSizeThisFrame between LOWFRAMESIZE .. dwMaxSizeThisFrame for values of the TARGETBITRATE between 0 .. BITRATE_LOWLIMIT
          //for a TARGETBITRATE 0 we want to have LOWFRAMESIZE, and for a bitrate BITRATE_LOWLIMIT the normal value that we started with
          // (that is dwMaxSizeThisFrame will be left untouched basically)
          // between these 2 limits, the scale is liniar; the formula below is computed from the equation of the straight line passing
          // through those coordinates
          // see above: #define TARGETBITRATE m_pBasePin->m_pCaptureFilter->m_pCapturePin->m_lTargetBitrate
          D(1) dprintf("%s: Initial Frame  = %8lu (CapturePin target bitrate = %lu )\n",_fx_,dwMaxSizeThisFrame,TARGETBITRATE);
          if (  m_pBasePin->m_pCaptureFilter->m_pCapturePin
             && (dwTargetBitrate=TARGETBITRATE) <= BITRATE_LOWLIMIT
             && dwMaxSizeThisFrame >= LOWFRAMESIZE) {
                  aux = ((dwMaxSizeThisFrame - LOWFRAMESIZE) * dwTargetBitrate) / BITRATE_LOWLIMIT + LOWFRAMESIZE ;
                  ASSERT(aux <= dwMaxSizeThisFrame && aux>=LOWFRAMESIZE);
                  dwMaxSizeThisFrame=aux;
                  D(1) dprintf("%s: Adjusted Frame = %8lu (CapturePin target bitrate = %lu )\n",_fx_,dwMaxSizeThisFrame,dwTargetBitrate);
          }
        }


#ifdef DEBUG
        if(!g_skip_q)
#endif
        { DWORD dwTargetBitrate=0;
          // see above: #define TARGETBITRATE m_pBasePin->m_pCaptureFilter->m_pCapturePin->m_lTargetBitrate
          // the value 31 is computed from 10000UL / 322UL
          if (  m_pBasePin->m_pCaptureFilter->m_pCapturePin
             && (dwTargetBitrate=TARGETBITRATE) <= BITRATE_LOWLIMIT) {
                  D(1) dprintf("%s: [2] Initial m_dwImageQuality = %lu (CapturePin target bitrate = %lu )\n",_fx_,m_dwImageQuality,dwTargetBitrate);
                  m_dwImageQuality = ((BITRATE_LOWLIMIT - dwTargetBitrate) * 31) / BITRATE_LOWLIMIT ;
                  ASSERT(m_dwImageQuality<=31);   // m_dwImageQuality >=0 anyway (DWORD)
                  D(1) dprintf("%s: [2] Using m_dwImageQuality = %lu (CapturePin target bitrate = %lu )\n",_fx_,m_dwImageQuality,dwTargetBitrate);
                  //D(1) dprintf("%s: [2] Using m_dwImageQuality = %lu (CapturePin target bitrate = %lu )\n",_fx_,m_dwImageQuality,dwTargetBitrate);
          }
        }


        // We need to modify the frame number so that the codec can generate
        // a valid TR. TRs use MPIs as their units. So we need to generate a
        // frame number assuming a 29.97Hz capture rate, even though we will be
        // capturing at some other rate.
        if (m_dwLastTimestamp == 0xFFFFFFFF)
        {
                // This is the first frame
                m_dwFrame = 0UL;

                // Save the current time
                m_dwLastTimestamp = dwTimestamp;
        }
        else
        {
                // Compare the current timestamp to the last one we saved. The difference
                // will let us normalize the frame count to 29.97Hz.
                if (fKeyFrame)
                {
                        m_dwFrame = 0UL;
                        m_dwLastTimestamp = dwTimestamp;
                }
                else
                        m_dwFrame = (dwTimestamp - m_dwLastTimestamp) * 2997 / 100000UL;
        }

        if (fKeyFrame)
        {
                m_dwLastIFrameTime = dwTimestamp;
        }

#ifdef USE_SOFTWARE_CAMERA_CONTROL
        // Do we need to apply camera control operators first?
        if (IsSoftCamCtrlNeeded())
        {
                if (!IsSoftCamCtrlInserted())
                        InsertSoftCamCtrl();
        }
        else
        {
                if (IsSoftCamCtrlInserted())
                        RemoveSoftCamCtrl();
        }
#endif
        // Do we need to scale the input first?
        if (m_dwConversionType & CONVERSIONTYPE_SCALER)
        {
                // Get the input rectangle
                ComputeRectangle(m_pbiIn, m_pbiInt, m_pBasePin->m_pCaptureFilter->m_pCapDev->m_lCCZoom, m_pBasePin->m_pCaptureFilter->m_pCapDev->m_lCCPan, m_pBasePin->m_pCaptureFilter->m_pCapDev->m_lCCTilt, &rcRect, m_pBasePin->m_fFlipHorizontal, m_pBasePin->m_fFlipVertical);

                // Scale DIB
                ScaleDIB(m_pbiIn, pbyInput, m_pbiInt, m_pbyOut, &rcRect, m_pBasePin->m_fFlipHorizontal, m_pBasePin->m_fFlipVertical, m_pBasePin->m_fNoImageStretch, m_pBasePin->m_dwBlackEntry);

                icCompress.lpbiInput = m_pbiInt;
                icCompress.lpInput = m_pbyOut;
        }
        else
        {
                icCompress.lpbiInput = m_pbiIn;
                icCompress.lpInput = pbyInput;
        }

        // Do we preview the compressed data?
        if (m_pBasePin->m_pCaptureFilter->m_fPreviewCompressedData && m_pBasePin->m_pCaptureFilter->m_pPreviewPin && pdwPreviewSize)
        {
                // Hey! You can only do this if you have connected the preview pin...
                ASSERT(m_pBasePin->m_pCaptureFilter->m_pPreviewPin->IsConnected());

                icCompress.lpbiPrev = HEADER(m_pBasePin->m_pCaptureFilter->m_pPreviewPin->m_mt.pbFormat);
                icCompress.lpPrev = pbyPreview;
                *pdwPreviewSize = HEADER(m_pBasePin->m_pCaptureFilter->m_pPreviewPin->m_mt.pbFormat)->biSizeImage;
        }
        else
        {
                icCompress.lpbiPrev = NULL;
                icCompress.lpPrev = NULL;
        }

        icCompress.dwFlags = fKeyFrame ? ICCOMPRESS_KEYFRAME : 0;
        icCompress.lpbiOutput = m_pbiOut;
        icCompress.lpOutput = pbyOutput;
        icCompress.dwFrameSize = dwMaxSizeThisFrame;
        icCompress.dwQuality = 10000UL - (m_dwImageQuality * 322UL);
        icCompress.lFrameNum = m_dwFrame++;
        // The following was referenced by the H.26x encoders -> references to this pointer to a flag are gone from encoders
        icCompress.lpdwFlags = NULL;
        icCompress.lpckid = NULL;
        if (!m_pInstInfo || ((*m_pDriverProc)((DWORD)m_pInstInfo, NULL, ICM_COMPRESS, (LPARAM)&icCompress, sizeof(icCompress)) != ICERR_OK))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Compression failed!", _fx_));
                Hr = E_FAIL;
                goto MyExit;
        }

        // Look for the bitstream info trailer
        pbsiT = (PH26X_RTP_BSINFO_TRAILER)(pbyOutput + m_pbiOut->biSizeImage - sizeof(H26X_RTP_BSINFO_TRAILER));

        // Update output size
        *pdwOutputSize = pbsiT->dwCompressedSize;
        *pdwBytesExtent = m_pbiOut->biSizeImage;

#if defined(DEBUG) && defined(DEBUG_ENCODING)
        wsprintf(szDebug, "Target: %ld bytes, Actual: %ld bytes\n", dwMaxSizeThisFrame, *pdwOutputSize);
        OutputDebugString(szDebug);
#endif

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCONVERTMETHOD
 *
 *  @mfunc HRESULT | CH26XEncoder | CloseConverter | This method closes a
 *    H.26X encoder.

 *  @rdesc This method returns NOERROR.
 ***************************************************************************/
HRESULT CH26XEncoder::CloseConverter()
{
        FX_ENTRY("CH26XEncoder::CloseConverter")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        ASSERT(m_fConvert);

        // Validate input parameters
        if (m_pInstInfo)
        {
                // Terminate H.26X compression
                (*m_pDriverProc)((DWORD)m_pInstInfo, NULL, ICM_COMPRESS_END, 0L, 0L);

                // Terminate H.26X encoder
                (*m_pDriverProc)((DWORD)m_pInstInfo, NULL, DRV_CLOSE, 0L, 0L);
                (*m_pDriverProc)((DWORD)m_pInstInfo, NULL, DRV_FREE, 0L, 0L);
                m_pInstInfo = NULL;
        }

#if DXMRTP <= 0
        // Release TAPIH26X.DLL
        if (m_hTAPIH26XDLL)
                FreeLibrary(m_hTAPIH26XDLL);
#endif

        CConverter::CloseConverter();

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

        return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\netstats.cpp ===
/****************************************************************************
 *  @doc INTERNAL NETSTATS
 *
 *  @module NetStats.cpp | Source file for the <c CCapturePin> class methods
 *    used to implement the video capture output pin network statistics
 *    methods.
 ***************************************************************************/

#include "Precomp.h"

#ifdef USE_NETWORK_STATISTICS

/****************************************************************************
 *  @doc INTERNAL CCAPTURENETSTATMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | SetChannelErrors | This
 *    method is used to inform the compressed output pin of the error channel
 *    conditions.
 *
 *  @parm CHANNELERRORS_S* | pChannelErrors | Specifies the error channel
 *    conditions.
 *
 *  @parm DWORD | dwLayerId | Specifies the ID of the encoding layer the
 *    call applies to. For standard audio and video encoders, this field is
 *    always set to 0. In the case of multi-layered encoders, this field
 *    shall be set to 0 for the base layer, 1 for the first enhancement
 *    layer, 2 for the next enhancement layer, etc
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag VFW_E_NOT_CONNECTED | Pin not connected yet
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CCapturePin::SetChannelErrors(IN CHANNELERRORS_S *pChannelErrors, IN DWORD dwLayerId)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCapturePin::SetChannelErrors")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pChannelErrors);
	if (!pChannelErrors)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT(dwLayerId == 0);
	if (dwLayerId)
	{
		// We don't implement multi-layered encoding in this filter
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	// Remember channel errors 
	m_ChannelErrors = *pChannelErrors;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTURENETSTATMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | GetChannelErrors | This
 *    method is used to supply to the network sink filter the error channel
 *    conditions an output pin is currently setup for.
 *
 *  @parm CHANNELERRORS_S* | pChannelErrors | Specifies a pointer to a
 *    structure to receive error channel conditions.
 *
 *  @parm DWORD | dwLayerId | Specifies the ID of the encoding layer the
 *    call applies to. For standard audio and video encoders, this field is
 *    always set to 0. In the case of multi-layered encoders, this field
 *    shall be set to 0 for the base layer, 1 for the first enhancement
 *    layer, 2 for the next enhancement layer, etc
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag VFW_E_NOT_CONNECTED | Pin not connected yet
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CCapturePin::GetChannelErrors(OUT CHANNELERRORS_S *pChannelErrors, IN WORD dwLayerId)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCapturePin::GetChannelErrors")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pChannelErrors);
	if (!pChannelErrors)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT(dwLayerId == 0);
	if (dwLayerId)
	{
		// We don't implement multi-layered encoding in this filter
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	// Return channel errors 
	*pChannelErrors = m_ChannelErrors;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTURENETSTATMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | GetChannelErrorsRange | This
 *    method is used to retrieve support, minimum, maximum, and default values
 *    for the channel error conditions an output pin may be setup for.
 *
 *  @parm CHANNELERRORS_S* | pMin | Used to retrieve the minimum values of
 *    channel error conditions an output pin maybe setup for.
 *
 *  @parm CHANNELERRORS_S* | pMax | Used to retrieve the maximum values of
 *    channel error conditions an output pin may be setup for.
 *
 *  @parm CHANNELERRORS_S* | pSteppingDelta | Used to retrieve the stepping
 *    delta values of channel error conditions an output pin may be setup for.
 *
 *  @parm CHANNELERRORS_S* | pDefault | Used to retrieve the default values
 *    of channel error conditions an output pin may be setup for.
 *
 *  @parm DWORD | dwLayerId | Specifies the ID of the encoding layer the
 *    call applies to. For standard audio and video encoders, this field is
 *    always set to 0. In the case of multi-layered encoders, this field
 *    shall be set to 0 for the base layer, 1 for the first enhancement
 *    layer, 2 for the next enhancement layer, etc
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag VFW_E_NOT_CONNECTED | Pin not connected yet
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CCapturePin::GetChannelErrorsRange(OUT CHANNELERRORS_S *pMin, OUT CHANNELERRORS_S *pMax, OUT CHANNELERRORS_S *pSteppingDelta, OUT CHANNELERRORS_S *pDefault, IN DWORD dwLayerId)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCapturePin::GetChannelErrorsRange")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pMin);
	ASSERT(pMax);
	ASSERT(pSteppingDelta);
	ASSERT(pDefault);
	if (!pMin || !pMax || !pSteppingDelta || !pDefault)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT(dwLayerId == 0);
	if (dwLayerId)
	{
		// We don't implement multi-layered encoding in this filter
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	// Return channel error ranges 
	*pMin = m_ChannelErrorsMin;
	*pMax = m_ChannelErrorsMax;
	*pSteppingDelta = m_ChannelErrorsSteppingDelta;
	*pDefault = m_ChannelErrorsDefault;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTURENETSTATMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | SetPacketLossRate | This
 *    method is used to inform an output pin of the channel packet loss rate.
 *
 *  @parm DWORD | dwPacketLossRate | Specifies the packet loss rate of the
 *    channel in multiples of 10-6.
 *
 *  @parm DWORD | dwLayerId | Specifies the ID of the encoding layer the
 *    call applies to. For standard audio and video encoders, this field is
 *    always set to 0. In the case of multi-layered encoders, this field
 *    shall be set to 0 for the base layer, 1 for the first enhancement
 *    layer, 2 for the next enhancement layer, etc
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag VFW_E_NOT_CONNECTED | Pin not connected yet
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CCapturePin::SetPacketLossRate(IN DWORD dwPacketLossRate, IN DWORD dwLayerId)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCapturePin::SetPacketLossRate")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(dwLayerId == 0);
	if (dwLayerId)
	{
		// We don't implement multi-layered encoding in this filter
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	// Remember packet loss rate 
	m_dwPacketLossRate = dwPacketLossRate;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTURENETSTATMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | GetPacketLossRate | This
 *    method is used to supply to the network sink filter the packet loss rate
 *    channel conditions an output pin is currently setup for.
 *
 *  @parm LPDWORD | pdwPacketLossRate | Specifies a pointer to a DWORD to
 *    receive the packet loss rate of the channel an audio output pin is
 *    currently setup for, in multiples of 10-6.
 *
 *  @parm DWORD | dwLayerId | Specifies the ID of the encoding layer the
 *    call applies to. For standard audio and video encoders, this field is
 *    always set to 0. In the case of multi-layered encoders, this field
 *    shall be set to 0 for the base layer, 1 for the first enhancement
 *    layer, 2 for the next enhancement layer, etc
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag VFW_E_NOT_CONNECTED | Pin not connected yet
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CCapturePin::GetPacketLossRate(OUT LPDWORD pdwPacketLossRate, IN DWORD dwLayerId)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCapturePin::GetPacketLossRate")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pdwPacketLossRate);
	if (!pdwPacketLossRate)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT(dwLayerId == 0);
	if (dwLayerId)
	{
		// We don't implement multi-layered encoding in this filter
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	// Return packet loss rate we are setup for
	*pdwPacketLossRate = m_dwPacketLossRate;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CCAPTURENETSTATMETHOD
 *
 *  @mfunc HRESULT | CCapturePin | GetPacketLossRateRange | This
 *    method is used to retrieve support, minimum, maximum, and default values
 *    for the packet loss rate conditions an output pin may be setup for.
 *
 *  @parm LPDWORD | pdwMin | Used to retrieve the minimum packet loss rate
 *    an output pin may be setup for.
 *
 *  @parm LPDWORD | pdwMax | Used to retrieve the maximum packet loss rate
 *    an output pin may be setup for.
 *
 *  @parm LPDWORD | pdwSteppingDelta | Used to retrieve the stepping delta
 *    values of packet loss rate an output pin may be setup for.
 *
 *  @parm LPDWORD | pdwDefault | Used to retrieve the default packet loss
 *    rate an output pin is setup for.
 *
 *  @parm DWORD | dwLayerId | Specifies the ID of the encoding layer the
 *    call applies to. For standard audio and video encoders, this field is
 *    always set to 0. In the case of multi-layered encoders, this field
 *    shall be set to 0 for the base layer, 1 for the first enhancement
 *    layer, 2 for the next enhancement layer, etc
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag VFW_E_NOT_CONNECTED | Pin not connected yet
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CCapturePin::GetPacketLossRateRange(OUT LPDWORD pdwMin, OUT LPDWORD pdwMax, OUT LPDWORD pdwSteppingDelta, OUT LPDWORD pdwDefault, IN DWORD dwLayerId)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CCapturePin::GetPacketLossRateRange")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pdwMin);
	ASSERT(pdwMax);
	ASSERT(pdwSteppingDelta);
	ASSERT(pdwDefault);
	if (!pdwMin || !pdwMax || !pdwSteppingDelta || !pdwDefault)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT(dwLayerId == 0);
	if (dwLayerId)
	{
		// We don't implement multi-layered encoding in this filter
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	// Return packet loss rate ranges 
	*pdwMin = m_dwPacketLossRateMin;
	*pdwMax = m_dwPacketLossRateMax;
	*pdwSteppingDelta = m_dwPacketLossRateSteppingDelta;
	*pdwDefault = m_dwPacketLossRateDefault;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\netstatp.cpp ===
/****************************************************************************
 *  @doc INTERNAL NETSTATP
 *
 *  @module NetStatP.cpp | Source file for the <c CNetworkStatsProperty>
 *    class used to implement a property page to test the new TAPI internal
 *    interface <i INetworkStats>.
 *
 *  @comm This code tests the TAPI Capture Pin <i INetworkStats>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
 ***************************************************************************/

#include "Precomp.h"

#ifdef USE_PROPERTY_PAGES

#ifdef USE_NETWORK_STATISTICS

// Some hack...
CHANNELERRORS_S g_CurrentChannelErrors = {0};
CHANNELERRORS_S g_MinChannelErrors = {0};
CHANNELERRORS_S g_MaxChannelErrors = {0};
CHANNELERRORS_S g_StepChannelErrors = {0};
CHANNELERRORS_S g_DefaultChannelErrors = {0};


/****************************************************************************
 *  @doc INTERNAL CNETSTATPMETHOD
 *
 *  @mfunc void | CNetworkStatsProperty | CNetworkStatsProperty | This
 *    method is the constructor for network statistics property objects. It
 *    calls the base class constructor, calls InitCommonControlsEx, and saves
 *    a pointer to the <i INetworkStats> interface.
 *
 *  @parm HWND | hDlg | Specifies a handle to the parent property page.
 *
 *  @parm ULONG | IDLabel | Specifies a label ID for the property.
 *
 *  @parm ULONG | IDMinControl | Specifies a label ID for the associated
 *    property edit control where the Minimum value of the property appears.
 *
 *  @parm ULONG | IDMaxControl | Specifies a label ID for the associated
 *    property edit control where the Maximum value of the property appears.
 *
 *  @parm ULONG | IDDefaultControl | Specifies a label ID for the associated
 *    property edit control where the Default value of the property appears.
 *
 *  @parm ULONG | IDStepControl | Specifies a label ID for the associated
 *    property edit control where the Stepping Delta value of the property appears.
 *
 *  @parm ULONG | IDEditControl | Specifies a label ID for the associated
 *    property edit control where the value of the property appears.
 *
 *  @parm ULONG | IDTrackbarControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProgressControl | Specifies a label ID for the associated
 *    property progress bar.
 *
 *  @parm ULONG | IDProperty | Specifies the ID of the Ks property.
 *
 *  @parm INetworkStats* | pInterface | Specifies a pointer to the
 *    <i INetworkStats> interface.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CNetworkStatsProperty::CNetworkStatsProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, INetworkStats *pInterface)
: CKSPropertyEditor(hDlg, IDLabel, IDMinControl, IDMaxControl, IDDefaultControl, IDStepControl, IDEditControl, IDTrackbarControl, IDProgressControl, IDProperty, IDAutoControl)
{
	INITCOMMONCONTROLSEX cc;

	FX_ENTRY("CNetworkStatsProperty::CNetworkStatsProperty")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	cc.dwSize = sizeof (INITCOMMONCONTROLSEX);
	cc.dwICC  = ICC_UPDOWN_CLASS | ICC_BAR_CLASSES;

	InitCommonControlsEx(&cc);

	// It's fine if the interface pointer is NULL, we'll grey the
	// associated items in the property page
	m_pInterface = pInterface;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CNETSTATPMETHOD
 *
 *  @mfunc void | CNetworkStatsProperty | ~CNetworkStatsProperty | This
 *    method is the destructor for network statistics property objects. It
 *    simply calls the base class destructor.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CNetworkStatsProperty::~CNetworkStatsProperty()
{
	FX_ENTRY("CNetworkStatsProperty::~CNetworkStatsProperty")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CNETSTATPMETHOD
 *
 *  @mfunc HRESULT | CNetworkStatsProperty | GetValue | This method queries for
 *    the value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CNetworkStatsProperty::GetValue()
{
	HRESULT Hr = E_NOTIMPL;

	FX_ENTRY("CNetworkStatsProperty::GetValue")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	switch (m_IDProperty)
	{
		case IDC_RandomBitErrorRate:
			if (m_pInterface && SUCCEEDED (Hr = m_pInterface->GetChannelErrors(&g_CurrentChannelErrors, 0UL)))
			{
				m_CurrentValue = g_CurrentChannelErrors.dwRandomBitErrorRate;
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: RandomBitErrorRate=%ld", _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: IOCTL failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_BurstErrorDuration:
			Hr = NOERROR;
			if (m_pInterface)
			{
				m_CurrentValue = g_CurrentChannelErrors.dwBurstErrorDuration;
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: BurstErrorDuration=%ld", _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: IOCTL failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_BurstErrorMaxFrequency:
			Hr = NOERROR;
			if (m_pInterface)
			{
				m_CurrentValue = g_CurrentChannelErrors.dwBurstErrorMaxFrequency;
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: BurstErrorMaxFrequency=%ld", _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: IOCTL failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_PacketLossRate:
			if (m_pInterface && SUCCEEDED (Hr = m_pInterface->GetPacketLossRate((LPDWORD)&m_CurrentValue, 0UL)))
			{
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: *pdwPacketLossRate=%ld", _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: IOCTL failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		default:
			Hr = E_UNEXPECTED;
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Unknown silence control property", _fx_));
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CNETSTATPMETHOD
 *
 *  @mfunc HRESULT | CNetworkStatsProperty | SetValue | This method sets the
 *    value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CNetworkStatsProperty::SetValue()
{
	HRESULT Hr = E_NOTIMPL;

	FX_ENTRY("CNetworkStatsProperty::SetValue")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	switch (m_IDProperty)
	{
		case IDC_RandomBitErrorRate:
			// We'll only apply this when we get to KSPROPERTY_NETWORKSTATS_CHANNELERRORS_BurstErrorMaxFrequency
			g_CurrentChannelErrors.dwRandomBitErrorRate = m_CurrentValue;
			Hr = NOERROR;
			if (m_pInterface)
			{
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: RandomBitErrorRate=%ld", _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: IOCTL failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_BurstErrorDuration:
			// We'll only apply this when we get to KSPROPERTY_NETWORKSTATS_CHANNELERRORS_BurstErrorMaxFrequency
			g_CurrentChannelErrors.dwBurstErrorDuration = m_CurrentValue;
			Hr = NOERROR;
			if (m_pInterface)
			{
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: BurstErrorDuration=%ld", _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: IOCTL failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_BurstErrorMaxFrequency:
			g_CurrentChannelErrors.dwBurstErrorMaxFrequency = m_CurrentValue;
			if (m_pInterface && SUCCEEDED (Hr = m_pInterface->SetChannelErrors(&g_CurrentChannelErrors, 0UL)))
			{
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: BurstErrorMaxFrequency=%ld", _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: IOCTL failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_PacketLossRate:
			if (m_pInterface && SUCCEEDED (Hr = m_pInterface->SetPacketLossRate((DWORD)m_CurrentValue, 0UL)))
			{
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: dwPacketLossRate=%ld", _fx_, m_CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: IOCTL failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		default:
			Hr = E_UNEXPECTED;
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Unknown silence control property", _fx_));
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CNETSTATPMETHOD
 *
 *  @mfunc HRESULT | CNetworkStatsProperty | GetRange | This method retrieves
 *    the range information of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CNetworkStatsProperty::GetRange()
{
	HRESULT Hr = E_NOTIMPL;

	FX_ENTRY("CNetworkStatsProperty::GetRange")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	switch (m_IDProperty)
	{
		case IDC_RandomBitErrorRate:
			if (m_pInterface && SUCCEEDED (Hr = m_pInterface->GetChannelErrorsRange(&g_MinChannelErrors, &g_MaxChannelErrors, &g_StepChannelErrors, &g_DefaultChannelErrors, 0UL)))
			{
				m_Min = g_MinChannelErrors.dwRandomBitErrorRate;
				m_Max = g_MaxChannelErrors.dwRandomBitErrorRate;
				m_SteppingDelta = g_StepChannelErrors.dwRandomBitErrorRate;
				m_DefaultValue = g_DefaultChannelErrors.dwRandomBitErrorRate;
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: RandomBitErrorRate=%ld %ld %ld %ld", _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: IOCTL failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_BurstErrorDuration:
			if (m_pInterface)
			{
				// We've already queried for the range information
				m_Min = g_MinChannelErrors.dwBurstErrorDuration;
				m_Max = g_MaxChannelErrors.dwBurstErrorDuration;
				m_SteppingDelta = g_StepChannelErrors.dwBurstErrorDuration;
				m_DefaultValue = g_DefaultChannelErrors.dwBurstErrorDuration;
				Hr = NOERROR;
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: BurstErrorDuration=%ld %ld %ld %ld", _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: IOCTL failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_BurstErrorMaxFrequency:
			if (m_pInterface)
			{
				// We've already queried for the range information
				m_Min = g_MinChannelErrors.dwBurstErrorMaxFrequency;
				m_Max = g_MaxChannelErrors.dwBurstErrorMaxFrequency;
				m_SteppingDelta = g_StepChannelErrors.dwBurstErrorMaxFrequency;
				m_DefaultValue = g_DefaultChannelErrors.dwBurstErrorMaxFrequency;
				Hr = NOERROR;
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: BurstErrorMaxFrequency=%ld %ld %ld %ld", _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: IOCTL failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_PacketLossRate:
			if (m_pInterface && SUCCEEDED (Hr = m_pInterface->GetPacketLossRateRange((LPDWORD)&m_Min, (LPDWORD)&m_Max, (LPDWORD)&m_SteppingDelta, (LPDWORD)&m_DefaultValue, 0UL)))
			{
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: *plMin=%ld, *plMax=%ld, *plSteppingDelta=%ld, *plDefault", _fx_, m_Min, m_Max, m_SteppingDelta, m_DefaultValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: IOCTL failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		default:
			Hr = E_UNEXPECTED;
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Unknown network statistics property", _fx_));
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CNETSTATPMETHOD
 *
 *  @mfunc HRESULT | CNetworkStatsProperty | CanAutoControl | This method
 *    retrieves the automatic control capabilities for a property.
 *
 *  @rdesc This method returns TRUE if automatic control is supported, FALSE
 *    otherwise.
 ***************************************************************************/
BOOL CNetworkStatsProperty::CanAutoControl(void)
{
	FX_ENTRY("CNetworkStatsProperty::CanAutoControl")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

	return FALSE;
}

/****************************************************************************
 *  @doc INTERNAL CNETSTATPMETHOD
 *
 *  @mfunc HRESULT | CNetworkStatsProperty | GetAuto | This method
 *    retrieves the current automatic control mode of a property.
 *
 *  @rdesc This method returns TRUE if automatic control is supported, FALSE
 *    otherwise.
 ***************************************************************************/
BOOL CNetworkStatsProperty::GetAuto(void)
{
	FX_ENTRY("CNetworkStatsProperty::GetAuto")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

	return FALSE; 
}

/****************************************************************************
 *  @doc INTERNAL CNETSTATPMETHOD
 *
 *  @mfunc HRESULT | CNetworkStatsProperty | SetAuto | This method
 *    sets the automatic control mode of a property.
 *
 *  @parm BOOL | fAuto | Specifies the automatic control mode.
 *
 *  @rdesc This method returns TRUE.
 ***************************************************************************/
BOOL CNetworkStatsProperty::SetAuto(BOOL fAuto)
{
	FX_ENTRY("CNetworkStatsProperty::SetAuto")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

	return TRUE; 
}

/****************************************************************************
 *  @doc INTERNAL CNETSTATPMETHOD
 *
 *  @mfunc CUnknown* | CNetworkStatsProperties | CreateInstance | This
 *    method is called by DShow to create an instance of a Network Statistics
 *    Property Page. It is referred to in the global structure <t g_Templates>.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Returns a pointer to the nondelegating CUnknown portion of the
 *    object, or NULL otherwise.
 ***************************************************************************/
CUnknown* CALLBACK CNetworkStatsPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr) 
{
	CUnknown *pUnknown = (CUnknown *)NULL;

	FX_ENTRY("CNetworkStatsPropertiesCreateInstance")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pHr);
	if (!pHr)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		goto MyExit;
	}

	if (!(pUnknown = new CNetworkStatsProperties(pUnkOuter, pHr)))
	{
		*pHr = E_OUTOFMEMORY;
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: new CNetworkStatsProperties failed", _fx_));
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: new CNetworkStatsProperties created", _fx_));
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return pUnknown;
}

/****************************************************************************
 *  @doc INTERNAL CNETSTATPMETHOD
 *
 *  @mfunc void | CNetworkStatsProperties | CNetworkStatsProperties | This
 *    method is the constructor for the property page object. It simply
 *    calls the constructor of the property page base class.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CNetworkStatsProperties::CNetworkStatsProperties(LPUNKNOWN pUnk, HRESULT *pHr) : CBasePropertyPage(NAME("NetworkStats Property Page"), pUnk, IDD_NetworkStatsProperties, IDS_NETWORKSTATSPROPNAME)
{
	FX_ENTRY("CNetworkStatsProperties::CNetworkStatsProperties")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	m_pINetworkStats = NULL;
	m_NumProperties = NUM_NETWORKSTATS_CONTROLS;

	for (int i = 0; i < m_NumProperties; i++)
		m_Controls[i] = NULL;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CNETSTATPMETHOD
 *
 *  @mfunc void | CNetworkStatsProperties | ~CNetworkStatsProperties | This
 *    method is the destructor for network statistics property page. It
 *    simply calls the base class destructor after deleting all the controls.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CNetworkStatsProperties::~CNetworkStatsProperties()
{
	int		j;

	FX_ENTRY("CNetworkStatsProperties::~CNetworkStatsProperties")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX", _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: control already freed", _fx_));
		}
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CNETSTATPMETHOD
 *
 *  @mfunc HRESULT | CNetworkStatsProperties | OnConnect | This
 *    method is called when the property page is connected to the filter.
 *
 *  @parm LPUNKNOWN | pUnknown | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CNetworkStatsProperties::OnConnect(IUnknown *pUnk)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CNetworkStatsProperties::OnConnect")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pUnk);
	if (!pUnk)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}

	// Get the network statistics interface
	if (SUCCEEDED (Hr = pUnk->QueryInterface(__uuidof(INetworkStats),(void **)&m_pINetworkStats)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_pINetworkStats=0x%08lX", _fx_, m_pINetworkStats));
	}
	else
	{
		m_pINetworkStats = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: IOCTL failed Hr=0x%08lX", _fx_, Hr));
	}

	// It's Ok if we couldn't get interface pointers
	// We'll just grey the controls in the property page
	// to make it clear to the user that they can't
	// control those properties on the audio device
	Hr = NOERROR;

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CNETSTATPMETHOD
 *
 *  @mfunc HRESULT | CNetworkStatsProperties | OnDisconnect | This
 *    method is called when the property page is disconnected from the owning
 *    filter.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CNetworkStatsProperties::OnDisconnect()
{
	FX_ENTRY("CNetworkStatsProperties::OnDisconnect")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters: we seem to get called several times here
	// Make sure the interface pointer is still valid
	if (!m_pINetworkStats)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: already disconnected!", _fx_));
	}
	else
	{
		// Release the interface
		m_pINetworkStats->Release();
		m_pINetworkStats = NULL;
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: releasing m_pINetworkStats", _fx_));
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CNETSTATPMETHOD
 *
 *  @mfunc HRESULT | CNetworkStatsProperties | OnActivate | This
 *    method is called when the property page is activated.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CNetworkStatsProperties::OnActivate()
{
	HRESULT	Hr = NOERROR;
	int		j;

	FX_ENTRY("CNetworkStatsProperties::OnActivate")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Create the controls for the properties
	if (m_Controls[0] = new CNetworkStatsProperty(m_hwnd, IDC_RandomBitErrorRate_Label, IDC_RandomBitErrorRate_Minimum, IDC_RandomBitErrorRate_Maximum, IDC_RandomBitErrorRate_Default, IDC_RandomBitErrorRate_Stepping, IDC_RandomBitErrorRate_Edit, IDC_RandomBitErrorRate_Slider, 0, IDC_RandomBitErrorRate, 0, m_pINetworkStats))
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[0]=0x%08lX", _fx_, m_Controls[0]));

		if (m_Controls[1] = new CNetworkStatsProperty(m_hwnd, IDC_BurstErrorDuration_Label, IDC_BurstErrorDuration_Minimum, IDC_BurstErrorDuration_Maximum, IDC_BurstErrorDuration_Default, IDC_BurstErrorDuration_Stepping, IDC_BurstErrorDuration_Edit, IDC_BurstErrorDuration_Slider, 0, IDC_BurstErrorDuration, 0, m_pINetworkStats))
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[1]=0x%08lX", _fx_, m_Controls[1]));

			if (m_Controls[2] = new CNetworkStatsProperty(m_hwnd, IDC_BurstErrorMaxFrequency_Label, IDC_BurstErrorMaxFrequency_Minimum, IDC_BurstErrorMaxFrequency_Maximum, IDC_BurstErrorMaxFrequency_Default, IDC_BurstErrorMaxFrequency_Stepping, IDC_BurstErrorMaxFrequency_Edit, IDC_BurstErrorMaxFrequency_Slider, 0, IDC_BurstErrorMaxFrequency, 0, m_pINetworkStats))
			{
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[2]=0x%08lX", _fx_, m_Controls[2]));

				if (m_Controls[3] = new CNetworkStatsProperty(m_hwnd, IDC_PacketLossRate_Label, IDC_PacketLossRate_Minimum, IDC_PacketLossRate_Maximum, IDC_PacketLossRate_Default, IDC_PacketLossRate_Stepping, IDC_PacketLossRate_Edit, IDC_PacketLossRate_Slider, 0, IDC_PacketLossRate, 0, m_pINetworkStats))
				{
					DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[3]=0x%08lX", _fx_, m_Controls[3]));
					Hr = NOERROR;
				}
				else
				{
					DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
					delete m_Controls[0], m_Controls[0] = NULL;
					delete m_Controls[1], m_Controls[1] = NULL;
					delete m_Controls[2], m_Controls[2] = NULL;
					Hr = E_OUTOFMEMORY;
					goto MyExit;
				}
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
				delete m_Controls[0], m_Controls[0] = NULL;
				delete m_Controls[1], m_Controls[1] = NULL;
				Hr = E_OUTOFMEMORY;
				goto MyExit;
			}
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
			delete m_Controls[0], m_Controls[0] = NULL;
			Hr = E_OUTOFMEMORY;
			goto MyExit;
		}
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
		Hr = E_OUTOFMEMORY;
		goto MyExit;
	}

	// Initialize all the controls. If the initialization fails, it's Ok. It just means
	// that the TAPI control interface isn't implemented by the device. The dialog item
	// in the property page will be greyed, showing this to the user.
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j]->Init())
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: m_Controls[%ld]->Init()", _fx_, j));
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: m_Controls[%ld]->Init() failed", _fx_, j));
		}
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CNETSTATPMETHOD
 *
 *  @mfunc HRESULT | CNetworkStatsProperties | OnDeactivate | This
 *    method is called when the property page is dismissed.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CNetworkStatsProperties::OnDeactivate()
{
	int		j;

	FX_ENTRY("CNetworkStatsProperties::OnDeactivate")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX", _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: control already freed", _fx_));
		}
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return NOERROR;
}

/****************************************************************************
 *  @doc INTERNAL CNETSTATPMETHOD
 *
 *  @mfunc HRESULT | CNetworkStatsProperties | OnApplyChanges | This
 *    method is called when the user applies changes to the property page.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CNetworkStatsProperties::OnApplyChanges()
{
	HRESULT	Hr = NOERROR;

	FX_ENTRY("CNetworkStatsProperties::OnApplyChanges")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Update packet loss rate
	ASSERT(m_Controls[3]);
	if (m_Controls[3])
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: calling m_Controls[3]=0x%08lX->OnApply", _fx_, m_Controls[3]));
		if (m_Controls[3]->HasChanged())
			m_Controls[3]->OnApply();
		Hr = NOERROR;
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: can't call m_Controls[3]=NULL->OnApply", _fx_));
		Hr = E_UNEXPECTED;
	}
	// Handle other network statistics in one shot
	ASSERT(m_Controls[0] && m_Controls[1] && m_Controls[2]);
	if (m_Controls[0] && m_Controls[1] && m_Controls[2])
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: calling m_Controls[0 - 2]=->OnApply", _fx_));
		if (m_Controls[0]->HasChanged() || m_Controls[1]->HasChanged() || m_Controls[2]->HasChanged())
		{
			m_Controls[0]->OnApply();
			m_Controls[1]->OnApply();
			m_Controls[2]->OnApply();
		}
		Hr = NOERROR;
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: can't call m_Controls[1 - 3]=NULL->OnApply", _fx_));
		Hr = E_UNEXPECTED;
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CNETSTATPMETHOD
 *
 *  @mfunc BOOL | CNetworkStatsProperties | OnReceiveMessage | This
 *    method is called when a message is sent to the property page dialog box.
 *
 *  @rdesc By default, returns the value returned by the Win32 DefWindowProc function.
 ***************************************************************************/
BOOL CNetworkStatsProperties::OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
	int iNotify = HIWORD (wParam);
	int j;

	switch (uMsg)
	{
		case WM_INITDIALOG:
			return TRUE; // Don't call setfocus

		case WM_HSCROLL:
		case WM_VSCROLL:
			// Process all of the Trackbar messages
			for (j = 0; j < m_NumProperties; j++)
			{
				ASSERT(m_Controls[j]);
				if (m_Controls[j]->GetTrackbarHWnd() == (HWND)lParam)
				{
					m_Controls[j]->OnScroll(uMsg, wParam, lParam);
					SetDirty();
				}
			}
			break;

		case WM_COMMAND:

			// This message gets sent even before OnActivate() has been
			// called(!). We need to test and make sure the controls have
			// beeen initialized before we can use them.

			// Process all of the edit box messages
			for (j = 0; j < m_NumProperties; j++)
			{
				if (m_Controls[j] && m_Controls[j]->GetEditHWnd() == (HWND)lParam)
				{
					m_Controls[j]->OnEdit(uMsg, wParam, lParam);
					SetDirty();
					break;
				}
			}

			switch (LOWORD(wParam))
			{
				case IDC_CONTROL_DEFAULT:
					for (j = 0; j < m_NumProperties; j++)
					{
						if (m_Controls[j])
							m_Controls[j]->OnDefault();
					}
					break;

				default:
					break;
			}
			break;

		default:
			return FALSE;
	}

	return TRUE;
}

/****************************************************************************
 *  @doc INTERNAL CNETSTATPMETHOD
 *
 *  @mfunc BOOL | CNetworkStatsProperties | SetDirty | This
 *    method notifies the property page site of changes.
 *
 *  @rdesc Nada.
 ***************************************************************************/
void CNetworkStatsProperties::SetDirty()
{
	m_bDirty = TRUE;
	if (m_pPageSite)
		m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
}

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\netstatp.h ===
/****************************************************************************
 *  @doc INTERNAL NETSTATP
 *
 *  @module NetStatP.h | Header file for the <c CNetworkStatsProperty>
 *    class used to implement a property page to test the new TAPI internal
 *    interface <i INetworkStats>.
 *
 *  @comm This code tests the TAPI Capture Pin <i INetworkStats>
 *    implementation. This code is only compiled if USE_PROPERTY_PAGES is
 *    defined.
 ***************************************************************************/

#ifndef _NETSTATP_H_
#define _NETSTATP_H_

#ifdef USE_PROPERTY_PAGES

#ifdef USE_NETWORK_STATISTICS

#define NUM_NETWORKSTATS_CONTROLS	4
#define IDC_RandomBitErrorRate		2
#define IDC_BurstErrorDuration		3
#define IDC_BurstErrorMaxFrequency	4
#define IDC_PacketLossRate			5

/****************************************************************************
 *  @doc INTERNAL CNETSTATPCLASS
 *
 *  @class CNetworkStatsProperty | This class implements handling of a
 *    single network statistics property in a property page.
 *
 *  @mdata int | CNetworkStatsProperty | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata INetworkStats * | CNetworkStatsProperty | m_pInterface | Pointer
 *    to the <i INetworkStats> interface.
 *
 *  @comm This code tests the <i INetworkStats> Ks interface handler. This
 *    code is only compiled if USE_PROPERTY_PAGES is defined.
***************************************************************************/
class CNetworkStatsProperty : public CKSPropertyEditor 
{
	public:
	CNetworkStatsProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, ULONG IDAutoControl, INetworkStats *pInterface);
	~CNetworkStatsProperty ();

	// CKSPropertyEditor base class pure virtual overrides
	HRESULT GetValue();
	HRESULT SetValue();
	HRESULT GetRange();
	BOOL CanAutoControl(void);
	BOOL GetAuto(void);
	BOOL SetAuto(BOOL fAuto);

	private:
	INetworkStats *m_pInterface;
};

/****************************************************************************
 *  @doc INTERNAL CNETSTATPCLASS
 *
 *  @class CNetworkStatsProperties | This class implements a property page
 *    to test the new TAPI internal interface <i INetworkStats>.
 *
 *  @mdata int | CNetworkStatsProperties | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata INetworkStats * | CNetworkStatsProperties | m_pINetworkStats | Pointer
 *    to the <i INetworkStats> interface.
 *
 *  @mdata CNetworkStatsProperty * | CNetworkStatsProperties | m_Controls[NUM_NETWORKSTATS_CONTROLS] | Array
 *    of network statistics properties.
 *
 *  @comm This code tests the <i INetworkStats> Ks interface handler. This
 *    code is only compiled if USE_PROPERTY_PAGES is defined.
***************************************************************************/
class CNetworkStatsProperties : public CBasePropertyPage
{
	public:
	CNetworkStatsProperties(LPUNKNOWN pUnk, HRESULT *pHr);
	~CNetworkStatsProperties();

	HRESULT OnConnect(IUnknown *pUnk);
	HRESULT OnDisconnect();
	HRESULT OnActivate();
	HRESULT OnDeactivate();
	HRESULT OnApplyChanges();
	BOOL    OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

	private:

	void SetDirty();

	int m_NumProperties;
	INetworkStats *m_pINetworkStats;
	CNetworkStatsProperty *m_Controls[NUM_NETWORKSTATS_CONTROLS];
};

#endif // USE_NETWORK_STATISTICS

#endif // USE_PROPERTY_PAGES

#endif // _NETSTATP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\overlay.h ===
/****************************************************************************
 *  @doc INTERNAL OVERLAY
 *
 *  @module Overlay.h | Header file for the <c COverlayPin> class methods
 *    used to implement the video overlay output pin.
 ***************************************************************************/

#ifndef _OVERLAY_H_
#define _OVERLAY_H_

#ifdef USE_OVERLAY

/****************************************************************************
 *  @doc INTERNAL COVERLAYPINCLASS
 *
 *  @class COverlayPin | This class implements the video overlay output pin.
 *
 *  @mdata CTAPIVCap* | COverlayPin | m_pCaptureFilter | Reference to the
 *    parent capture filter.
 *
 *  @comm Supports IPin. Never created by COM, so no CreateInstance or entry
 *    in global FactoryTemplate table. Only ever created by a <c CTAPIVCap>
 *    object and returned via the EnumPins interface
 ***************************************************************************/
class COverlayPin : public CBaseOutputPin, public IAMStreamConfig, public CBaseStreamControl
{
	public:
	DECLARE_IUNKNOWN
	COverlayPin(IN TCHAR *pObjectName, IN CTAPIVCap *pCapture, IN HRESULT *pHr, IN LPCWSTR pName);
	virtual ~COverlayPin();
	STDMETHODIMP NonDelegatingQueryInterface(IN REFIID riid, OUT PVOID *ppv);
	static HRESULT CALLBACK CreateOverlayPin(CTAPIVCap *pCaptureFilter, COverlayPin **ppOverlayPin);

	// Override CBasePin base class methods
	HRESULT GetMediaType(IN int iPosition, OUT CMediaType *pMediaType);
	HRESULT CheckMediaType(IN const CMediaType *pMediaType);
	HRESULT SetMediaType(IN CMediaType *pMediaType);

	// Implement IAMStreamConfig
	STDMETHODIMP SetFormat(IN AM_MEDIA_TYPE *pmt);
	STDMETHODIMP GetFormat(OUT AM_MEDIA_TYPE **ppmt);
	STDMETHODIMP GetNumberOfCapabilities(OUT int *piCount, OUT int *piSize);
	STDMETHODIMP GetStreamCaps(IN int iIndex, OUT AM_MEDIA_TYPE **ppmt, OUT LPBYTE pSCC);

	// Override CBaseOutputPin base class methods
	HRESULT DecideBufferSize(IN IMemAllocator *pAlloc, OUT ALLOCATOR_PROPERTIES *ppropInputRequest);
	HRESULT DecideAllocator(IN IMemInputPin *pPin, OUT IMemAllocator **ppAlloc);
	HRESULT Active();
	HRESULT Inactive();
	HRESULT ActiveRun(IN REFERENCE_TIME tStart);
	HRESULT ActivePause();

	// Override IQualityControl interface method to receive Notification messages
	STDMETHODIMP Notify(IN IBaseFilter *pSelf, IN Quality q);

	private:
	CTAPIVCap *m_pCaptureFilter;
};

#endif // USE_OVERLAY

#endif // _OVERLAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\precomp.h ===
/****************************************************************************
 *  @doc INTERNAL PRECOMP
 *
 *  @module Precomp.h | Master header file.
 ***************************************************************************/

#ifndef _PRECOMP_VCAP_H_
#define _PRECOMP_VCAP_H_

#include <windows.h>
#include <windowsx.h>
#include <mmsystem.h>
#include <streams.h>
#include <vfw.h>
#include <stdlib.h>
#if defined (NT_BUILD)
#include "vc50\msviddrv.h"
#else
#include "msviddrv.h"
#endif 
#include "devioctl.h"
#include "ks.h"
#include "ksmedia.h"
#include <commctrl.h>
#include <olectl.h>
#include <memory.h>
#include <ksproxy.h>
#include <TAPIVid.h>
#include <tptrace.h>
#include <filterid.h>
#include <H26XInc.h>
#include <TAPIH26X.h>
#include "DevEnum.h"
#include "IVideo32.h"
#include "PropEdit.h"
#include "Resource.h"
#include "NetStatP.h"
#include "ProgRefP.h"
#include "CPUCP.h"
#include "ProcAmpP.h"
#include "CameraCP.h"
#include "h245vid.h"
#include "TAPIVCap.h"
#include "BasePin.h"
#include "Convert.h"
#include "Device.h"
#include "DeviceP.h"
#include "Capture.h"
#include "CaptureP.h"
#include "Preview.h"
#include "PreviewP.h"
#include "RtpPd.h"
#include "RtpPdP.h"
#include "Formats.h"
#include "Overlay.h"
#include "Thunk.h"
#include "WDMDlgs.h"
#include "H26XEnc.h"
#include "ProcUtil.h"
#include "vidctemp.h"

#endif // _PRECOMP_VCAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\preview.cpp ===
/****************************************************************************
 *  @doc INTERNAL PREVIEW
 *
 *  @module Preview.cpp | Source file for the <c CPreviewPin> class methods
 *    used to implement the video capture preview pin.
 ***************************************************************************/

#include "Precomp.h"

const RGBQUAD g_IndeoPalette[256] =
{
                   0,       0,       0,              0,
                   0,       0,       0,              0,
                   0,       0,       0,              0,
                   0,       0,       0,              0,
                   0,       0,       0,              0,
                   0,       0,       0,              0,
                   0,       0,       0,              0,
                   0,       0,       0,              0,
                   0,       0,       0,              0,
                   0,       0,       0,              0,
                   0,  39+ 15,       0,  PC_NOCOLLAPSE,
                   0,  39+ 24,       0,  PC_NOCOLLAPSE,
                   0,  39+ 33,       0,  PC_NOCOLLAPSE,
                   0,  39+ 42,       0,  PC_NOCOLLAPSE,
                   0,  39+ 51, -44+ 51,  PC_NOCOLLAPSE,
         -55+ 60,  39+ 60, -44+ 60,  PC_NOCOLLAPSE,
         -55+ 69,  39+ 69, -44+ 69,  PC_NOCOLLAPSE,
         -55+ 78,  39+ 78, -44+ 78,  PC_NOCOLLAPSE,
         -55+ 87,  39+ 87, -44+ 87,  PC_NOCOLLAPSE,
         -55+ 96,  39+ 96, -44+ 96,  PC_NOCOLLAPSE,
         -55+105,  39+105, -44+105,  PC_NOCOLLAPSE,
         -55+114,  39+114, -44+114,  PC_NOCOLLAPSE,
         -55+123,  39+123, -44+123,  PC_NOCOLLAPSE,
         -55+132,  39+132, -44+132,  PC_NOCOLLAPSE,
         -55+141,  39+141, -44+141,  PC_NOCOLLAPSE,
         -55+150,  39+150, -44+150,  PC_NOCOLLAPSE,
         -55+159,  39+159, -44+159,  PC_NOCOLLAPSE,
         -55+168,  39+168, -44+168,  PC_NOCOLLAPSE,
         -55+177,  39+177, -44+177,  PC_NOCOLLAPSE,
         -55+186,  39+186, -44+186,  PC_NOCOLLAPSE,
         -55+195,  39+195, -44+195,  PC_NOCOLLAPSE,
         -55+204,  39+204, -44+204,  PC_NOCOLLAPSE,
         -55+213,  39+213, -44+213,  PC_NOCOLLAPSE,
         -55+222,     255, -44+222,  PC_NOCOLLAPSE,
         -55+231,     255, -44+231,  PC_NOCOLLAPSE,
         -55+240,     255, -44+240,  PC_NOCOLLAPSE,
                                                                        
           0+ 15,  26+ 15,       0,  PC_NOCOLLAPSE,
           0+ 24,  26+ 24,       0,  PC_NOCOLLAPSE,
           0+ 33,  26+ 33,       0,  PC_NOCOLLAPSE,
           0+ 42,  26+ 42,       0,  PC_NOCOLLAPSE,
           0+ 51,  26+ 51, -44+ 51,  PC_NOCOLLAPSE,
           0+ 60,  26+ 60, -44+ 60,  PC_NOCOLLAPSE,
           0+ 69,  26+ 69, -44+ 69,  PC_NOCOLLAPSE,
           0+ 78,  26+ 78, -44+ 78,  PC_NOCOLLAPSE,
           0+ 87,  26+ 87, -44+ 87,  PC_NOCOLLAPSE,
           0+ 96,  26+ 96, -44+ 96,  PC_NOCOLLAPSE,
           0+105,  26+105, -44+105,  PC_NOCOLLAPSE,
           0+114,  26+114, -44+114,  PC_NOCOLLAPSE,
           0+123,  26+123, -44+123,  PC_NOCOLLAPSE,
           0+132,  26+132, -44+132,  PC_NOCOLLAPSE,
           0+141,  26+141, -44+141,  PC_NOCOLLAPSE,
           0+150,  26+150, -44+150,  PC_NOCOLLAPSE,
           0+159,  26+159, -44+159,  PC_NOCOLLAPSE,
           0+168,  26+168, -44+168,  PC_NOCOLLAPSE,
           0+177,  26+177, -44+177,  PC_NOCOLLAPSE,
           0+186,  26+186, -44+186,  PC_NOCOLLAPSE,
           0+195,  26+195, -44+195,  PC_NOCOLLAPSE,
           0+204,  26+204, -44+204,  PC_NOCOLLAPSE,
           0+213,  26+213, -44+213,  PC_NOCOLLAPSE,
           0+222,  26+222, -44+222,  PC_NOCOLLAPSE,
           0+231,     255, -44+231,  PC_NOCOLLAPSE,
           0+240,     255, -44+240,  PC_NOCOLLAPSE,
                                                                        
          55+ 15,  14+ 15,       0,  PC_NOCOLLAPSE,
          55+ 24,  14+ 24,       0,  PC_NOCOLLAPSE,
          55+ 33,  14+ 33,       0,  PC_NOCOLLAPSE,
          55+ 42,  14+ 42,       0,  PC_NOCOLLAPSE,
          55+ 51,  14+ 51, -44+ 51,  PC_NOCOLLAPSE,
          55+ 60,  14+ 60, -44+ 60,  PC_NOCOLLAPSE,
          55+ 69,  14+ 69, -44+ 69,  PC_NOCOLLAPSE,
          55+ 78,  14+ 78, -44+ 78,  PC_NOCOLLAPSE,
          55+ 87,  14+ 87, -44+ 87,  PC_NOCOLLAPSE,
          55+ 96,  14+ 96, -44+ 96,  PC_NOCOLLAPSE,
          55+105,  14+105, -44+105,  PC_NOCOLLAPSE,
          55+114,  14+114, -44+114,  PC_NOCOLLAPSE,
          55+123,  14+123, -44+123,  PC_NOCOLLAPSE,
          55+132,  14+132, -44+132,  PC_NOCOLLAPSE,
                 255,     153,      51,  PC_NOCOLLAPSE,
                                                                        
          55+150,  14+150, -44+150,  PC_NOCOLLAPSE,
          55+159,  14+159, -44+159,  PC_NOCOLLAPSE,
          55+168,  14+168, -44+168,  PC_NOCOLLAPSE,
          55+177,  14+177, -44+177,  PC_NOCOLLAPSE,
          55+186,  14+186, -44+186,  PC_NOCOLLAPSE,
          55+195,  14+195, -44+195,  PC_NOCOLLAPSE,
                 255,  14+204, -44+204,  PC_NOCOLLAPSE,
                 255,  14+213, -44+213,  PC_NOCOLLAPSE,
                 255,     255, -44+222,  PC_NOCOLLAPSE,
                 255,     255, -44+231,  PC_NOCOLLAPSE,
                 255,     255, -44+240,  PC_NOCOLLAPSE,
                                                                        
                   0,  13+ 15,   0+ 15,  PC_NOCOLLAPSE,
                   0,  13+ 24,   0+ 24,  PC_NOCOLLAPSE,
                   0,  13+ 33,   0+ 33,  PC_NOCOLLAPSE,
                   0,  13+ 42,   0+ 42,  PC_NOCOLLAPSE,
                   0,  13+ 51,   0+ 51,  PC_NOCOLLAPSE,
         -55+ 60,  13+ 60,   0+ 60,  PC_NOCOLLAPSE,
         -55+ 69,  13+ 69,   0+ 69,  PC_NOCOLLAPSE,
         -55+ 78,  13+ 78,   0+ 78,  PC_NOCOLLAPSE,
         -55+ 87,  13+ 87,   0+ 87,  PC_NOCOLLAPSE,
         -55+ 96,  13+ 96,   0+ 96,  PC_NOCOLLAPSE,
         -55+105,  13+105,   0+105,  PC_NOCOLLAPSE,
         -55+114,  13+114,   0+114,  PC_NOCOLLAPSE,
         -55+123,  13+123,   0+123,  PC_NOCOLLAPSE,
         -55+132,  13+132,   0+132,  PC_NOCOLLAPSE,
         -55+141,  13+141,   0+141,  PC_NOCOLLAPSE,
         -55+150,  13+150,   0+150,  PC_NOCOLLAPSE,
         -55+159,  13+159,   0+159,  PC_NOCOLLAPSE,
         -55+168,  13+168,   0+168,  PC_NOCOLLAPSE,
         -55+177,  13+177,   0+177,  PC_NOCOLLAPSE,
         -55+186,  13+186,   0+186,  PC_NOCOLLAPSE,
         -55+195,  13+195,   0+195,  PC_NOCOLLAPSE,
         -55+204,  13+204,   0+204,  PC_NOCOLLAPSE,
         -55+213,  13+213,   0+213,  PC_NOCOLLAPSE,
         -55+222,  13+222,   0+222,  PC_NOCOLLAPSE,
         -55+231,  13+231,   0+231,  PC_NOCOLLAPSE,
         -55+240,  13+242,   0+240,  PC_NOCOLLAPSE,
                                                                        
           0+ 15,   0+ 15,   0+ 15,  PC_NOCOLLAPSE,
           0+ 24,   0+ 24,   0+ 24,  PC_NOCOLLAPSE,
           0+ 33,   0+ 33,   0+ 33,  PC_NOCOLLAPSE,
           0+ 42,   0+ 42,   0+ 42,  PC_NOCOLLAPSE,
           0+ 51,   0+ 51,   0+ 51,  PC_NOCOLLAPSE,
           0+ 60,   0+ 60,   0+ 60,  PC_NOCOLLAPSE,
           0+ 69,   0+ 69,   0+ 69,  PC_NOCOLLAPSE,
           0+ 78,   0+ 78,   0+ 78,  PC_NOCOLLAPSE,
           0+ 87,   0+ 87,   0+ 87,  PC_NOCOLLAPSE,
           0+ 96,   0+ 96,   0+ 96,  PC_NOCOLLAPSE,
           0+105,   0+105,   0+105,  PC_NOCOLLAPSE,
           0+114,   0+114,   0+114,  PC_NOCOLLAPSE,
           0+123,   0+123,   0+123,  PC_NOCOLLAPSE,
           0+132,   0+132,   0+132,  PC_NOCOLLAPSE,
           0+141,   0+141,   0+141,  PC_NOCOLLAPSE,
           0+150,   0+150,   0+150,  PC_NOCOLLAPSE,
           0+159,   0+159,   0+159,  PC_NOCOLLAPSE,
           0+168,   0+168,   0+168,  PC_NOCOLLAPSE,
           0+177,   0+177,   0+177,  PC_NOCOLLAPSE,
           0+186,   0+186,   0+186,  PC_NOCOLLAPSE,
           0+195,   0+195,   0+195,  PC_NOCOLLAPSE,
           0+204,   0+204,   0+204,  PC_NOCOLLAPSE,
           0+213,   0+213,   0+213,  PC_NOCOLLAPSE,
           0+222,   0+222,   0+222,  PC_NOCOLLAPSE,
           0+231,   0+231,   0+231,  PC_NOCOLLAPSE,
           0+240,   0+240,   0+240,  PC_NOCOLLAPSE,
                                                                        
          55+ 15, -13+ 15,   0+ 15,  PC_NOCOLLAPSE,
          55+ 24, -13+ 24,   0+ 24,  PC_NOCOLLAPSE,
          55+ 33, -13+ 33,   0+ 33,  PC_NOCOLLAPSE,
          55+ 42, -13+ 42,   0+ 42,  PC_NOCOLLAPSE,
          55+ 51, -13+ 51,   0+ 51,  PC_NOCOLLAPSE,
          55+ 60, -13+ 60,   0+ 60,  PC_NOCOLLAPSE,
          55+ 69, -13+ 69,   0+ 69,  PC_NOCOLLAPSE,
          55+ 78, -13+ 78,   0+ 78,  PC_NOCOLLAPSE,
          55+ 87, -13+ 87,   0+ 87,  PC_NOCOLLAPSE,
          55+ 96, -13+ 96,   0+ 96,  PC_NOCOLLAPSE,
          55+105, -13+105,   0+105,  PC_NOCOLLAPSE,
          55+114, -13+114,   0+114,  PC_NOCOLLAPSE,
          55+123, -13+123,   0+123,  PC_NOCOLLAPSE,
          55+132, -13+132,   0+132,  PC_NOCOLLAPSE,
          55+141, -13+141,   0+141,  PC_NOCOLLAPSE,
          55+150, -13+150,   0+150,  PC_NOCOLLAPSE,
          55+159, -13+159,   0+159,  PC_NOCOLLAPSE,
          55+168, -13+168,   0+168,  PC_NOCOLLAPSE,
          55+177, -13+177,   0+177,  PC_NOCOLLAPSE,
          55+186, -13+186,   0+186,  PC_NOCOLLAPSE,
          55+195, -13+195,   0+195,  PC_NOCOLLAPSE,
                 255, -13+204,   0+204,  PC_NOCOLLAPSE,
                 255, -13+213,   0+213,  PC_NOCOLLAPSE,
                 255, -13+222,   0+222,  PC_NOCOLLAPSE,
                 255, -13+231,   0+231,  PC_NOCOLLAPSE,
                 255, -13+240,   0+240,  PC_NOCOLLAPSE,
                                                                        
                   0, -14+ 15,  44+ 15,  PC_NOCOLLAPSE,
                   0, -14+ 24,  44+ 24,  PC_NOCOLLAPSE,
                   0, -14+ 33,  44+ 33,  PC_NOCOLLAPSE,
                   0, -14+ 42,  44+ 42,  PC_NOCOLLAPSE,
                   0, -14+ 51,  44+ 51,  PC_NOCOLLAPSE,
         -55+ 60, -14+ 60,  44+ 60,  PC_NOCOLLAPSE,
         -55+ 69, -14+ 69,  44+ 69,  PC_NOCOLLAPSE,
         -55+ 78, -14+ 78,  44+ 78,  PC_NOCOLLAPSE,
         -55+ 87, -14+ 87,  44+ 87,  PC_NOCOLLAPSE,
         -55+ 96, -14+ 96,  44+ 96,  PC_NOCOLLAPSE,
         -55+105, -14+105,  44+105,  PC_NOCOLLAPSE,
         -55+114, -14+114,  44+114,  PC_NOCOLLAPSE,
         -55+123, -14+123,  44+123,  PC_NOCOLLAPSE,
         -55+132, -14+132,  44+132,  PC_NOCOLLAPSE,
         -55+141, -14+141,  44+141,  PC_NOCOLLAPSE,
         -55+150, -14+150,  44+150,  PC_NOCOLLAPSE,
         -55+159, -14+159,  44+159,  PC_NOCOLLAPSE,
         -55+168, -14+168,  44+168,  PC_NOCOLLAPSE,
         -55+177, -14+177,  44+177,  PC_NOCOLLAPSE,
         -55+186, -14+186,  44+186,  PC_NOCOLLAPSE,
         -55+195, -14+195,  44+195,  PC_NOCOLLAPSE,
         -55+204, -14+204,  44+204,  PC_NOCOLLAPSE,
         -55+213, -14+213,     255,  PC_NOCOLLAPSE,
         -55+222, -14+222,     255,  PC_NOCOLLAPSE,
         -55+231, -14+231,     255,  PC_NOCOLLAPSE,
         -55+240, -14+242,     255,  PC_NOCOLLAPSE,
                                                                        
           0+ 15,       0,  44+ 15,  PC_NOCOLLAPSE,
           0+ 24,       0,  44+ 24,  PC_NOCOLLAPSE,
           0+ 33, -26+ 33,  44+ 33,  PC_NOCOLLAPSE,
           0+ 42, -26+ 42,  44+ 42,  PC_NOCOLLAPSE,
           0+ 51, -26+ 51,  44+ 51,  PC_NOCOLLAPSE,
           0+ 60, -26+ 60,  44+ 60,  PC_NOCOLLAPSE,
           0+ 69, -26+ 69,  44+ 69,  PC_NOCOLLAPSE,
           0+ 78, -26+ 78,  44+ 78,  PC_NOCOLLAPSE,
           0+ 87, -26+ 87,  44+ 87,  PC_NOCOLLAPSE,
           0+ 96, -26+ 96,  44+ 96,  PC_NOCOLLAPSE,
           0+105, -26+105,  44+105,  PC_NOCOLLAPSE,
           0+114, -26+114,  44+114,  PC_NOCOLLAPSE,
           0+123, -26+123,  44+123,  PC_NOCOLLAPSE,
           0+132, -26+132,  44+132,  PC_NOCOLLAPSE,
           0+141, -26+141,  44+141,  PC_NOCOLLAPSE,
           0+150, -26+150,  44+150,  PC_NOCOLLAPSE,
           0+159, -26+159,  44+159,  PC_NOCOLLAPSE,
           0+168, -26+168,  44+168,  PC_NOCOLLAPSE,
           0+177, -26+177,  44+177,  PC_NOCOLLAPSE,
           0+186, -26+186,  44+186,  PC_NOCOLLAPSE,
           0+195, -26+195,  44+195,  PC_NOCOLLAPSE,
           0+204, -26+204,  44+204,  PC_NOCOLLAPSE,
           0+213, -26+213,     255,  PC_NOCOLLAPSE,
           0+222, -26+222,     255,  PC_NOCOLLAPSE,
           0+231, -26+231,     255,  PC_NOCOLLAPSE,
           0+240, -26+240,     255,  PC_NOCOLLAPSE,
                                                                        
          55+ 15,       0,  44+ 15,  PC_NOCOLLAPSE,
          55+ 24,       0,  44+ 24,  PC_NOCOLLAPSE,
          55+ 33,       0,  44+ 33,  PC_NOCOLLAPSE,
          55+ 42, -39+ 42,  44+ 42,  PC_NOCOLLAPSE,
          55+ 51, -39+ 51,  44+ 51,  PC_NOCOLLAPSE,
          55+ 60, -39+ 60,  44+ 60,  PC_NOCOLLAPSE,
          55+ 69, -39+ 69,  44+ 69,  PC_NOCOLLAPSE,
          55+ 78, -39+ 78,  44+ 78,  PC_NOCOLLAPSE,
          55+ 87, -39+ 87,  44+ 87,  PC_NOCOLLAPSE,
          55+ 96, -39+ 96,  44+ 96,  PC_NOCOLLAPSE,
          55+105, -39+105,  44+105,  PC_NOCOLLAPSE,
          55+114, -39+114,  44+114,  PC_NOCOLLAPSE,
          55+123, -39+123,  44+123,  PC_NOCOLLAPSE,
          55+132, -39+132,  44+132,  PC_NOCOLLAPSE,
          55+141, -39+141,  44+141,  PC_NOCOLLAPSE,
          55+150, -39+150,  44+150,  PC_NOCOLLAPSE,
          55+159, -39+159,  44+159,  PC_NOCOLLAPSE,
          55+168, -39+168,  44+168,  PC_NOCOLLAPSE,
          55+177, -39+177,  44+177,  PC_NOCOLLAPSE,
          55+186, -39+186,  44+186,  PC_NOCOLLAPSE,
          55+195, -39+195,  44+195,  PC_NOCOLLAPSE,
                 255, -39+204,  44+204,  PC_NOCOLLAPSE,
                 255, -39+213,     255,  PC_NOCOLLAPSE,
                 255, -39+222,     255,  PC_NOCOLLAPSE,
                 255, -39+231,     255,  PC_NOCOLLAPSE,
                 255, -39+240,     255,  PC_NOCOLLAPSE,
                                                                        
                0x83,    0x81,    0x81,  PC_NOCOLLAPSE,
                0x84,    0x81,    0x81,  PC_NOCOLLAPSE,
                                                                        
                   0,       0,       0,              0,
                   0,       0,       0,              0,
                   0,       0,       0,              0,
                   0,       0,       0,              0,
                   0,       0,       0,              0,
                   0,       0,       0,              0,
                   0,       0,       0,              0,
                   0,       0,       0,              0,
                   0,       0,       0,              0,
                 255,     255,     255,              0
};

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPINMETHOD
 *
 *  @mfunc CPreviewPin* | CPreviewPin | CreatePreviewPin | This helper
 *    function creates a video output pin for preview.
 *
 *  @parm CTAPIVCap* | pCaptureFilter | Specifies a pointer to the owner
 *    filter.
 *
 *  @parm CPreviewPin** | ppPreviewPin | Specifies that address of a pointer
 *    to a <c CPreviewPin> object to receive the a pointer to the newly
 *    created pin.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CALLBACK CPreviewPin::CreatePreviewPin(CTAPIVCap *pCaptureFilter, CPreviewPin **ppPreviewPin)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CPreviewPin::CreatePreviewPin")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pCaptureFilter);
        ASSERT(ppPreviewPin);
        if (!pCaptureFilter || !ppPreviewPin)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        if (!(*ppPreviewPin = (CPreviewPin *) new CPreviewPin(NAME("Video Preview Stream"), pCaptureFilter, &Hr, L"Preview")))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Out of memory", _fx_));
                Hr = E_OUTOFMEMORY;
                goto MyExit;
        }

        // If initialization failed, delete the stream array and return the error
        if (FAILED(Hr) && *ppPreviewPin)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Initialization failed", _fx_));
                Hr = E_FAIL;
                delete *ppPreviewPin, *ppPreviewPin = NULL;
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPINMETHOD
 *
 *  @mfunc HRESULT | CPreviewPin | CPreviewPin | This method is the
 *  constructor for the <c CPreviewPin> object
 *
 *  @rdesc Nada.
 ***************************************************************************/
CPreviewPin::CPreviewPin(IN TCHAR *pObjectName, IN CTAPIVCap *pCaptureFilter, IN HRESULT *pHr, IN LPCWSTR pName) : CTAPIBasePin(pObjectName, pCaptureFilter, pHr, pName)
{
        VIDEOINFO       *ppvi = NULL;
        HDC                     hDC;
        int                     nBPP;

        FX_ENTRY("CPreviewPin::CPreviewPin")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pHr);
        ASSERT(pCaptureFilter);
        if (!pCaptureFilter || !pHr)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                if (pHr)
                        *pHr = E_POINTER;
        }

        if (pHr && FAILED(*pHr))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Base class error or invalid input parameter", _fx_));
                goto MyExit;
        }

        // Initialize to default format: RG24 176x144 at 30 fps... but
        // this really depends on the capabilities of the device.
        // If the device can capture in a YUV mode, then we'll use
        // this mode and convert from YUV to RGB24 using the appropriate
        // ICM decoder for the YUV mode. If the device is a RGB device,
        // then we will try to open it, preferrably, in 16, 24, 8 then 4
        // bit mode. The following code looks at the capabilities of the
        // device to build the list of preview formats supported by this
        // pin.
        //
        // If we are previewing the compressed data, we don't really care
        // about the format used to capture the data. We match the format
        // to the output bit depth of the screen.
        if (m_pCaptureFilter->m_fPreviewCompressedData)
        {
                // Get the current bitdepth
                hDC = GetDC(NULL);
                nBPP = GetDeviceCaps(hDC, BITSPIXEL) * GetDeviceCaps(hDC, PLANES);
                ReleaseDC(NULL, hDC);

                // Pick up the appropriate formats
                if (nBPP >= 24)
                {
                        m_mt = *Preview_RGB24_Formats[0];
                        m_aFormats = (AM_MEDIA_TYPE**)Preview_RGB24_Formats;
                        m_aCapabilities = Preview_RGB24_Caps;
                        m_dwNumFormats = NUM_RGB24_PREVIEW_FORMATS;
                }
                else if (nBPP == 16)
                {
                        m_mt = *Preview_RGB16_Formats[0];
                        m_aFormats = (AM_MEDIA_TYPE**)Preview_RGB16_Formats;
                        m_aCapabilities = Preview_RGB16_Caps;
                        m_dwNumFormats = NUM_RGB16_PREVIEW_FORMATS;
                }
                else if (nBPP < 16)
                {
                        m_mt = *Preview_RGB8_Formats[0];        //Assume 256 colors: [added: Cristiai (4 Dec 2000 21:54:12)]
                        m_aFormats = Preview_RGB8_Formats;
                        m_aCapabilities = Preview_RGB8_Caps;
                        m_dwNumFormats = NUM_RGB8_PREVIEW_FORMATS;
                        for (DWORD dw = 0; dw < m_dwNumFormats; dw++)
                        {
                                // Our video decoder uses the Indeo Palette
                                CopyMemory(((VIDEOINFO *)(m_aFormats[dw]->pbFormat))->bmiColors, g_IndeoPalette, 256 * sizeof(RGBQUAD));
                        }
                }
        }
        else if (m_pCaptureFilter->m_pCapDev->m_dwFormat & 0xFFFFFFF0)
        {
                // We'll use a YUV mode -> advertize RGB24
                m_mt = *Preview_RGB24_Formats[0];
                m_aFormats = (AM_MEDIA_TYPE**)Preview_RGB24_Formats;
                m_aCapabilities = Preview_RGB24_Caps;
                m_dwNumFormats = NUM_RGB24_PREVIEW_FORMATS;
        }
        else if (m_pCaptureFilter->m_pCapDev->m_dwFormat & VIDEO_FORMAT_NUM_COLORS_65536)
        {
                // We'll use RGB16
                m_mt = *Preview_RGB16_Formats[0];
                m_aFormats = (AM_MEDIA_TYPE**)Preview_RGB16_Formats;
                m_aCapabilities = Preview_RGB16_Caps;
                m_dwNumFormats = NUM_RGB16_PREVIEW_FORMATS;
        }
        else if (m_pCaptureFilter->m_pCapDev->m_dwFormat & VIDEO_FORMAT_NUM_COLORS_16777216)
        {
                // We'll use RGB24
                m_mt = *Preview_RGB24_Formats[0];
                m_aFormats = (AM_MEDIA_TYPE**)Preview_RGB24_Formats;
                m_aCapabilities = Preview_RGB24_Caps;
                m_dwNumFormats = NUM_RGB24_PREVIEW_FORMATS;
        }
        else if (m_pCaptureFilter->m_pCapDev->m_dwFormat & VIDEO_FORMAT_NUM_COLORS_256)
        {
                // We'll use RGB8
                m_aFormats = Preview_RGB8_Formats;
                m_aCapabilities = Preview_RGB8_Caps;
                m_dwNumFormats = NUM_RGB8_PREVIEW_FORMATS;

                // Now get the palette from the device
                if (SUCCEEDED(m_pCaptureFilter->m_pCapDev->GetFormatFromDriver((VIDEOINFOHEADER **)&ppvi)))
                {
                        // Copy the palette bits in all our formats
                        // The reason we only copy the palette is the size of the captured
                        // image maybe 160x120 for instance, from which we can generate a
                        // QCIF image through stretching/black banding. We only care about
                        // advertizing the stretched formats, not the captured one at this
                        // point.

                        // Another issue is the palette used. When we stretch from 160x120
                        // (or whatever VfW size) to one of the ITU-T size, we use a different
                        // palette in stretched mode. In black banding mode, we always use
                        // the palette of the capture device.
                        if (m_fNoImageStretch)
                        {
                                for (DWORD dw = 0; dw < m_dwNumFormats; dw++)
                                {
                                        CopyMemory(((VIDEOINFO *)(m_aFormats[dw]->pbFormat))->bmiColors, ppvi->bmiColors, ppvi->bmiHeader.biClrImportant ? ppvi->bmiHeader.biClrImportant * sizeof(RGBQUAD) : 256 * sizeof(RGBQUAD));
                                }
                        }
                        else
                        {
                                // Look for the palette to use
                                for (DWORD dw = 0; dw < m_dwNumFormats; dw++)
                                {
                                        // Is this size directly supported by the device?
                                        for (DWORD dw2 = 0; dw2 < VIDEO_FORMAT_NUM_RESOLUTIONS; dw2++)
                                        {
                                                if (((VIDEOINFOHEADER *)(m_aFormats[dw]->pbFormat))->bmiHeader.biHeight == awResolutions[dw2].framesize.cy && ((VIDEOINFOHEADER *)(m_aFormats[dw]->pbFormat))->bmiHeader.biWidth == awResolutions[dw2].framesize.cx)
                                                        break;
                                        }

                                        // If it is supported by the device, use the capture device palette
                                        if (dw2 < VIDEO_FORMAT_NUM_RESOLUTIONS && (m_pCaptureFilter->m_pCapDev->m_dwImageSize & awResolutions[dw2].dwRes))
                                        {
                                                CopyMemory(((VIDEOINFO *)(m_aFormats[dw]->pbFormat))->bmiColors, ppvi->bmiColors, ppvi->bmiHeader.biClrImportant ? ppvi->bmiHeader.biClrImportant * sizeof(RGBQUAD) : 256 * sizeof(RGBQUAD));
                                        }
                                        else
                                        {
                                            int r,g,b;
                                            DWORD *pdw;
                                            
                                            pdw = (DWORD *)(((VIDEOINFO *)(m_aFormats[dw]->pbFormat))->bmiColors);
                                            ((VIDEOINFOHEADER *)(m_aFormats[dw]->pbFormat))->bmiHeader.biClrUsed = 256;
                                            ((VIDEOINFOHEADER *)(m_aFormats[dw]->pbFormat))->bmiHeader.biClrImportant = 256;

#define NOCOLLAPSEPALETTERGBQ(r,g,b)   (0x04000000 | RGB(b,g,r))

                                                // This is the palette we use when we do stretching
                                            for (r=0; r<10; r++)
                                                        *pdw++ = 0UL;
                                            for (r=0; r<6; r++)
                                                for (g=0; g<6; g++)
                                                    for (b=0; b<6; b++)
                                                        *pdw++ = NOCOLLAPSEPALETTERGBQ(r*255/5,g*255/5,b*255/5);
                                                        //*pdw++ = RGB(b*255/5,g*255/5,r*255/5);
                                            for (r=0; r<30; r++)
                                                        *pdw++ = 0UL;
                                        }
                                }
                        }

                        delete ppvi;
                }

                // Now set the current format
                m_mt = *Preview_RGB8_Formats[0];
        }
        else
        {
                // Now get the palette from the device
                if (SUCCEEDED(m_pCaptureFilter->m_pCapDev->GetFormatFromDriver((VIDEOINFOHEADER **)&ppvi)))
                {
                        // Copy the palette bits in all our formats
                        // The reason we only copy the palette is the size of the captured
                        // image maybe 160x120 for instance, from which we can generate a
                        // QCIF image through stretching/black banding. We only care about
                        // advertizing the stretched formats, not the captured one at this
                        // point.

                        // Another issue is the palette used. When we stretch from 160x120
                        // (or whatever VfW size) to one of the ITU-T size, we use a different
                        // palette in stretched mode. In black banding mode, we always use
                        // the palette of the capture device.
                        if (m_fNoImageStretch)
                        {
                                // We'll use RGB4
                                m_aFormats = Preview_RGB4_Formats;
                                m_aCapabilities = Preview_RGB4_Caps;
                                m_dwNumFormats = NUM_RGB4_PREVIEW_FORMATS;

                                for (DWORD dw = 0; dw < m_dwNumFormats; dw++)
                                {
                                        CopyMemory(((VIDEOINFO *)(m_aFormats[dw]->pbFormat))->bmiColors, ppvi->bmiColors, ppvi->bmiHeader.biClrImportant ? ppvi->bmiHeader.biClrImportant * sizeof(RGBQUAD) : 16 * sizeof(RGBQUAD));
                                }

                                // Now set the current format
                                m_mt = *Preview_RGB4_Formats[0];
                        }
                        else
                        {

                                // When we stretch RGB4 data, we output to an RGB8 image.
                                m_aFormats = Preview_RGB8_Formats;
                                m_aCapabilities = Preview_RGB8_Caps;
                                m_dwNumFormats = NUM_RGB8_PREVIEW_FORMATS;

                                // Look for the palette to use
                                for (DWORD dw = 0; dw < m_dwNumFormats; dw++)
                                {
                                        // Is this size directly supported by the device?
                                        for (DWORD dw2 = 0; dw2 < VIDEO_FORMAT_NUM_RESOLUTIONS; dw2++)
                                        {
                                                if (((VIDEOINFOHEADER *)(m_aFormats[dw]->pbFormat))->bmiHeader.biHeight == awResolutions[dw2].framesize.cy && ((VIDEOINFOHEADER *)(m_aFormats[dw]->pbFormat))->bmiHeader.biWidth == awResolutions[dw2].framesize.cx)
                                                        break;
                                        }

                                        // If it is supported by the device, use the capture device palette
                                        if (dw2 < VIDEO_FORMAT_NUM_RESOLUTIONS && (m_pCaptureFilter->m_pCapDev->m_dwImageSize & awResolutions[dw2].dwRes))
                                        {
                                                m_aFormats[dw] = Preview_RGB4_Formats[dw];
                                                CopyMemory(((VIDEOINFO *)(m_aFormats[dw]->pbFormat))->bmiColors, ppvi->bmiColors, ppvi->bmiHeader.biClrImportant ? ppvi->bmiHeader.biClrImportant * sizeof(RGBQUAD) : 16 * sizeof(RGBQUAD));
                                        }
                                        else
                                        {
                                            int r,g,b;
                                            DWORD *pdw;
                                            
                                            pdw = (DWORD *)(((VIDEOINFO *)(m_aFormats[dw]->pbFormat))->bmiColors);
                                            ((VIDEOINFOHEADER *)(m_aFormats[dw]->pbFormat))->bmiHeader.biClrUsed = 256;
                                            ((VIDEOINFOHEADER *)(m_aFormats[dw]->pbFormat))->bmiHeader.biClrImportant = 256;

#define NOCOLLAPSEPALETTERGBQ(r,g,b)   (0x04000000 | RGB(b,g,r))

                                                // This is the palette we use when we do stretching
                                            for (r=0; r<10; r++)
                                                        *pdw++ = 0UL;
                                            for (r=0; r<6; r++)
                                                for (g=0; g<6; g++)
                                                    for (b=0; b<6; b++)
                                                        *pdw++ = NOCOLLAPSEPALETTERGBQ(r*255/5,g*255/5,b*255/5);
                                                        //*pdw++ = RGB(b*255/5,g*255/5,r*255/5);
                                            for (r=0; r<30; r++)
                                                        *pdw++ = 0UL;
                                        }
                                }

                                // Now set the current format
                                m_mt = *Preview_RGB8_Formats[0];
                        }

                        delete ppvi;
                }
        }

        // Update frame rate controls
        m_lMaxAvgTimePerFrame = (LONG)Preview_RGB24_Caps[0]->MinFrameInterval;
        m_lCurrentAvgTimePerFrame = m_lMaxAvgTimePerFrame;
        m_lAvgTimePerFrameRangeMin = (LONG)Preview_RGB24_Caps[0]->MinFrameInterval;
        m_lAvgTimePerFrameRangeMax = (LONG)Preview_RGB24_Caps[0]->MaxFrameInterval;
        m_lAvgTimePerFrameRangeSteppingDelta = (LONG)(Preview_RGB24_Caps[0]->MaxFrameInterval - Preview_RGB24_Caps[0]->MinFrameInterval) / 100;
        m_lAvgTimePerFrameRangeDefault = (LONG)Preview_RGB24_Caps[0]->MinFrameInterval;

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPINMETHOD
 *
 *  @mfunc void | CPreviewPin | ~CPreviewPin | This method is the destructor
 *    for the <c CPreviewPin> object.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CPreviewPin::~CPreviewPin()
{
        FX_ENTRY("CPreviewPin::~CPreviewPin")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPINMETHOD
 *
 *  @mfunc HRESULT | CPreviewPin | NonDelegatingQueryInterface | This
 *    method is the nondelegating interface query function. It returns a pointer
 *    to the specified interface if supported. The only interfaces explicitly
 *    supported being <i IAMStreamConfig>,
 *    <i IAMStreamControl>, <i ICPUControl>, <i IFrameRateControl>,
 *    <i IBitrateControl>, <i INetworkStats>, <i IH245EncoderCommand>
 *    and <i IProgressiveRefinement>.
 *
 *  @parm REFIID | riid | Specifies the identifier of the interface to return.
 *
 *  @parm PVOID* | ppv | Specifies the place in which to put the interface
 *    pointer.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CPreviewPin::NonDelegatingQueryInterface(IN REFIID riid, OUT void **ppv)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CPreviewPin::NonDelegatingQueryInterface")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(ppv);
        if (!ppv)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

        if (riid == __uuidof(IAMStreamControl))
        {
                if (FAILED(Hr = GetInterface(static_cast<IAMStreamControl*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: NDQI for IAMStreamControl failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: IAMStreamControl*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
#ifdef USE_PROPERTY_PAGES
        else if (riid == IID_ISpecifyPropertyPages)
        {
                if (FAILED(Hr = GetInterface(static_cast<ISpecifyPropertyPages*>(this), ppv)))
                {
                        DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: NDQI for ISpecifyPropertyPages failed Hr=0x%08lX", _fx_, Hr));
                }
                else
                {
                        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: ISpecifyPropertyPages*=0x%08lX", _fx_, *ppv));
                }

                goto MyExit;
        }
#endif

        if (FAILED(Hr = CTAPIBasePin::NonDelegatingQueryInterface(riid, ppv)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, WARN, "%s:   WARNING: NDQI for {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX} failed Hr=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], Hr));
        }
        else
        {
                DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: {%08lX-%04lX-%04lX-%02lX%02lX-%02lX%02lX%02lX%02lX%02lX%02lX}*=0x%08lX", _fx_, riid.Data1, riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7], *ppv));
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}

#ifdef USE_PROPERTY_PAGES
/****************************************************************************
 *  @doc INTERNAL CPREVIEWPINMETHOD
 *
 *  @mfunc HRESULT | CPreviewPin | GetPages | This method Fills a counted
 *    array of GUID values where each GUID specifies the CLSID of each
 *    property page that can be displayed in the property sheet for this
 *    object.
 *
 *  @parm CAUUID* | pPages | Specifies a pointer to a caller-allocated CAUUID
 *    structure that must be initialized and filled before returning. The
 *    pElems field in the CAUUID structure is allocated by the callee with
 *    CoTaskMemAlloc and freed by the caller with CoTaskMemFree.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_OUTOFMEMORY | Allocation failed
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CPreviewPin::GetPages(OUT CAUUID *pPages)
{
        HRESULT Hr = NOERROR;

        FX_ENTRY("CPreviewPin::GetPages")

        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

        // Validate input parameters
        ASSERT(pPages);
        if (!pPages)
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
                Hr = E_POINTER;
                goto MyExit;
        }

#ifdef USE_CPU_CONTROL
        pPages->cElems = 2;
#else
        pPages->cElems = 1;
#endif

        // Alloc memory for the page stuff
        if (!(pPages->pElems = (GUID *) QzTaskMemAlloc(sizeof(GUID) * pPages->cElems)))
        {
                DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
                Hr = E_OUTOFMEMORY;
        }
        else
        {
                pPages->pElems[0] = __uuidof(PreviewPropertyPage);
#ifdef USE_CPU_CONTROL
                pPages->pElems[1] = __uuidof(CPUCPropertyPage);
#endif
        }

MyExit:
        DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
        return Hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\procamp.cpp ===
/****************************************************************************
 *  @doc INTERNAL PROCAMP
 *
 *  @module ProcAmp.cpp | Source file for the <c CWDMCapDev>
 *    class methods used to implement the <i IAMVideoProcAmp> interface.
 ***************************************************************************/

#include "Precomp.h"

/****************************************************************************
 *  @doc INTERNAL CPROCAMPMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | Set | This method is used to set the value
 *    of a video quality setting.
 *
 *  @parm VideoProcAmpProperty | Property | Used to specify the video
 *    quality setting to set the value of. Use a member of the
 *    <t VideoProcAmpProperty> enumerated type.
 *
 *  @parm long | lValue | Used to specify the new value of the video quality
 *    setting.
 *
 *  @parm TAPIControlFlags | Flags | A member of the <t TAPIControlFlags> enumerated
 *    type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CWDMCapDev::Set(IN VideoProcAmpProperty Property, IN long lValue, IN TAPIControlFlags lFlags)
{
	HRESULT Hr = NOERROR;
	LONG lMin,lMax,lStep,lDefault;
	TAPIControlFlags lCtrlFlags;

	FX_ENTRY("CWDMCapDev::Set (VideoProcAmp)")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(Property >= VideoProcAmp_Brightness && Property <= VideoProcAmp_BacklightCompensation);
	if (Property < VideoProcAmp_Brightness || Property > VideoProcAmp_BacklightCompensation)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid Property argument", _fx_));
		Hr = E_INVALIDARG;
		goto MyExit;
	}
	ASSERT(lFlags == TAPIControl_Flags_Manual || lFlags == TAPIControl_Flags_Auto);
	if (lFlags != TAPIControl_Flags_Manual)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	//Get range (min/max/...)
	if(FAILED(Hr=GetRange(Property, &lMin, &lMax, &lStep, &lDefault, &lCtrlFlags))) {
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Couldn't get the range of values from driver", _fx_));
		goto MyExit;
	}
		
	if(lValue<lMin || lValue>lMax) {
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid Value: Out of range", _fx_));
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	// Set the property on the driver
	if (FAILED(Hr = SetPropertyValue(PROPSETID_VIDCAP_VIDEOPROCAMP, (ULONG)Property, lValue, (ULONG)lFlags, (ULONG)lFlags)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: SetPropertyValue failed", _fx_));
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: SetPropertyValue succeeded", _fx_));
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | Get | This method is used to retrieve the
 *    value of a video quality setting.
 *
 *  @parm VideoProcAmpProperty | Property | Used to specify the video
 *    quality setting to get the value of. Use a member of the
 *    <t VideoProcAmpProperty> enumerated type.
 *
 *  @parm long* | plValue | Used to retrieve the current value of the
 *    video quality setting.
 *
 *  @parm TAPIControlFlags* | plFlags | Pointer to a member of the <t TAPIControlFlags>
 *    enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CWDMCapDev::Get(IN VideoProcAmpProperty Property, OUT long *plValue, OUT TAPIControlFlags *plFlags)
{
	HRESULT Hr = NOERROR;
	ULONG ulCapabilities;

	FX_ENTRY("CWDMCapDev::Get (VideoProcAmp)")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(plValue);
	ASSERT(plFlags);
	if (!plValue || !plFlags)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT(Property >= VideoProcAmp_Brightness && Property <= VideoProcAmp_BacklightCompensation);
	if (Property < VideoProcAmp_Brightness || Property > VideoProcAmp_BacklightCompensation)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid Property argument", _fx_));
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	// Get the property from the driver
	if (FAILED(Hr = GetPropertyValue(PROPSETID_VIDCAP_VIDEOPROCAMP, (ULONG)Property, plValue, (PULONG)plFlags, &ulCapabilities)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: GetPropertyValue failed", _fx_));
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: GetPropertyValue succeeded", _fx_));
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPROCAMPMETHOD
 *
 *  @mfunc HRESULT | CWDMCapDev | GetRange | This method is used to retrieve
 *    the minimum, maximum, and default values for specific video quality
 *    settings.
 *
 *  @parm VideoProcAmpProperty | Property | Used to specify the video
 *    quality setting to determine the range of. Use a member of the
 *    <t VideoProcAmpProperty> enumerated type.
 *
 *  @parm long* | plMin | Used to retrieve the minimum value of the video
 *    quality setting range.
 *
 *  @parm long* | plMax | Used to retrieve the maximum value of the video
 *    quality setting range.
 *
 *  @parm long* | plSteppingDelta | Used to retrieve the stepping delta of
 *    the video quality setting range.
 *
 *  @parm long* | plDefault | Used to retrieve the default value of the
 *    video quality setting range.
 *
 *  @parm TAPIControlFlags* | plCapsFlags | Used to retrieve the capabilities of the
 *    video quality setting. Pointer to a member of the
 *    <t TAPIControlFlags> enumerated type.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_INVALIDARG | Invalid argument
 *  @flag E_PROP_ID_UNSUPPORTED | The specified property ID is not supported
 *    for the specified property set
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
STDMETHODIMP CWDMCapDev::GetRange(IN VideoProcAmpProperty Property, OUT long *plMin, OUT long *plMax, OUT long *plSteppingDelta, OUT long *plDefault, OUT TAPIControlFlags *plCapsFlags)
{
	HRESULT Hr = NOERROR;
	LONG  lCurrentValue;
	ULONG ulCurrentFlags;

	FX_ENTRY("CWDMCapDev::GetRange (VideoProcAmp)")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(plMin);
	ASSERT(plMax);
	ASSERT(plSteppingDelta);
	ASSERT(plDefault);
	ASSERT(plCapsFlags);
	if (!plMin || !plMax || !plSteppingDelta || !plDefault || !plCapsFlags)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Null pointer argument", _fx_));
		Hr = E_POINTER;
		goto MyExit;
	}
	ASSERT(Property >= VideoProcAmp_Brightness && Property <= VideoProcAmp_BacklightCompensation);
	if (Property < VideoProcAmp_Brightness || Property > VideoProcAmp_BacklightCompensation)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Invalid Property argument", _fx_));
		Hr = E_INVALIDARG;
		goto MyExit;
	}

	// Get the range values from the driver
	if (FAILED(Hr = GetRangeValues(PROPSETID_VIDCAP_VIDEOPROCAMP, (ULONG)Property, plMin, plMax, plSteppingDelta)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: GetRangeValues failed", _fx_));
		goto MyExit;
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: GetRangeValues succeeded", _fx_));
	}

	// Get the capability flags from the driver
	if (FAILED(Hr = GetPropertyValue(PROPSETID_VIDCAP_VIDEOPROCAMP, (ULONG)Property, &lCurrentValue, &ulCurrentFlags, (PULONG)plCapsFlags)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: GetRangeValues failed", _fx_));
		goto MyExit;
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: GetRangeValues succeeded", _fx_));
	}

	// Get the default value from the driver
	if (FAILED(Hr = GetDefaultValue(PROPSETID_VIDCAP_VIDEOPROCAMP, (ULONG)Property, plDefault)))
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: GetDefaultValue failed", _fx_));
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: GetDefaultValue succeeded", _fx_));
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\preview.h ===
/****************************************************************************
 *  @doc INTERNAL PREVIEW
 *
 *  @module Preview.h | Header file for the <c CPreviewPin> class methods
 *    used to implement the video preview output pin.
 ***************************************************************************/

#ifndef _PREVIEW_H_
#define _PREVIEW_H_

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPINCLASS
 *
 *  @class CPreviewPin | This class implements the video preview output pin.
 *
 *  @mdata CTAPIVCap* | CPreviewPin | m_pCaptureFilter | Reference to the
 *    parent capture filter.
 *
 *  @comm Supports IPin. Never created by COM, so no CreateInstance or entry
 *    in global FactoryTemplate table. Only ever created by a <c CTAPIVCap>
 *    object and returned via the EnumPins interface
 ***************************************************************************/
#ifdef USE_PROPERTY_PAGES
class CPreviewPin : public CTAPIBasePin, public ISpecifyPropertyPages
#else
class CPreviewPin : public CTAPIBasePin
#endif
{
	public:
	DECLARE_IUNKNOWN
	CPreviewPin(IN TCHAR *pObjectName, IN CTAPIVCap *pCaptureFilter, IN HRESULT *pHr, IN LPCWSTR pName);
	~CPreviewPin();
	STDMETHODIMP NonDelegatingQueryInterface(IN REFIID riid, OUT PVOID *ppv);
	static HRESULT CALLBACK CreatePreviewPin(CTAPIVCap *pCaptureFilter, CPreviewPin **ppPreviewPin);

#ifdef USE_PROPERTY_PAGES
	// ISpecifyPropertyPages methods
	STDMETHODIMP GetPages(OUT CAUUID *pPages);
#endif

	private:

	friend class CTAPIVCap;
	// friend class CCapturePin;
	friend class CAlloc;
	friend class CCapDev;
};

#endif // _PREVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\previewp.h ===
/****************************************************************************
 *  @doc INTERNAL PREVIEWP
 *
 *  @module PreviewP.h | Header file for the <c CPreviewProperty>
 *    class used to implement a property page to test the new TAPI internal
 *    interface <i IFrameRateControl> and dynamic format changes.
 *
 *  @comm This code tests the TAPI VfW Preview Pin <i IFrameRateControl>,
 *    and dynamic format change implementation. This code is only compiled
 *    if USE_PROPERTY_PAGES is defined.
 ***************************************************************************/

#ifndef _PREVIEWP_H_
#define _PREVIEWP_H_

#ifdef USE_PROPERTY_PAGES

#define NUM_PREVIEW_CONTROLS			4
#define IDC_Preview_FrameRate			0
#define IDC_Preview_CurrentFrameRate	1
#define IDC_Preview_FlipVertical		2
#define IDC_Preview_FlipHorizontal		3

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPCLASS
 *
 *  @class CPreviewProperty | This class implements handling of a
 *    single preview property in a property page.
 *
 *  @mdata int | CPreviewProperty | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata IFrameRateControl* | CPreviewProperty | m_pIFrameRateControl | Pointer
 *    to the <i IFrameRateControl> interface.
 *
 *  @comm This code tests the TAPI VfW Preview Pin <i IFrameRateControl>,
 *    and dynamic format change implementation. This code is only compiled
 *    if USE_PROPERTY_PAGES is defined.
***************************************************************************/
class CPreviewProperty : public CPropertyEditor 
{
	public:
	CPreviewProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, IFrameRateControl *pIFrameRateControl, IVideoControl *pIVideoControl);
	~CPreviewProperty ();

	// CPropertyEditor base class pure virtual overrides
	HRESULT GetValue();
	HRESULT SetValue();
	HRESULT GetRange();
	BOOL CanAutoControl(void);
	BOOL GetAuto(void);
	BOOL SetAuto(BOOL fAuto);

	private:
	IFrameRateControl *m_pIFrameRateControl;
	IVideoControl *m_pIVideoControl;
};

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPCLASS
 *
 *  @class CPreviewProperties | This class implements a property page
 *    to test the new TAPI internal interfaces <i IBitrateControl> and
 *    <i IFrameRateControl>.
 *
 *  @mdata int | CPreviewProperties | m_NumProperties | Keeps
 *    track of the number of properties.
 *
 *  @mdata IFrameRateControl* | CPreviewProperties | m_pInterface | Pointer
 *    to the <i IFrameRateControl> interface.
 *
 *  @mdata CPreviewProperty* | CPreviewProperties | m_Controls[NUM_PREVIEW_CONTROLS] | Array
 *    of capture properties.
 *
 *  @comm This code tests the TAPI VfW Preview Pin <i IFrameRateControl>,
 *    and dynamic format change implementation. This code is only compiled
 *    if USE_PROPERTY_PAGES is defined.
***************************************************************************/
class CPreviewProperties : public CBasePropertyPage
{
	public:
	CPreviewProperties(LPUNKNOWN pUnk, HRESULT *pHr);
	~CPreviewProperties();

	// Implement CBasePropertyPage virtual methods
	HRESULT OnConnect(IUnknown *pUnk);
	HRESULT OnDisconnect();
	HRESULT OnActivate();
	HRESULT OnDeactivate();
	HRESULT OnApplyChanges();
	BOOL    OnReceiveMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

	private:

	void SetDirty();

	// Format manipulation methods
	HRESULT InitialRangeScan();
	HRESULT OnFormatChanged();
	HRESULT GetCurrentMediaType(void);

	HWND						m_hWnd;
	int							m_NumProperties;
	IFrameRateControl			*m_pIFrameRateControl;
	IAMStreamConfig				*m_pIAMStreamConfig;
	IVideoControl				*m_pIVideoControl;
	int							m_RangeCount;
	VIDEO_STREAM_CONFIG_CAPS	m_RangeCaps;
	GUID						*m_SubTypeList;
	SIZE						*m_FrameSizeList;
	GUID						m_SubTypeCurrent;
	SIZE						m_FrameSizeCurrent;
	AM_MEDIA_TYPE				*m_CurrentMediaType;
	HWND						m_hWndFormat;
	BOOL						m_fActivated;
	int							m_CurrentFormat;
	int							m_OriginalFormat;

	CPreviewProperty *m_Controls[NUM_PREVIEW_CONTROLS];
};

#endif // USE_PROPERTY_PAGES

#endif // _PREVIEWP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\filters\video\tapivcap\previewp.cpp ===
/****************************************************************************
 *  @doc INTERNAL PREVIEWP
 *
 *  @module PreviewP.cpp | Source file for the <c CPreviewProperty>
 *    class used to implement a property page to test the new TAPI internal
 *    interface <i IFrameRateControl> and dynamic format changes.
 *
 *  @comm This code tests the TAPI VfW Preview Pin <i IFrameRateControl>,
 *    and dynamic format change implementation. This code is only compiled
 *    if USE_PROPERTY_PAGES is defined.
 ***************************************************************************/

#include "Precomp.h"

#if 0 // remove later.
// Video subtypes
EXTERN_C const GUID MEDIASUBTYPE_H263_V1;
EXTERN_C const GUID MEDIASUBTYPE_H263_V2;
EXTERN_C const GUID MEDIASUBTYPE_H261;
EXTERN_C const GUID MEDIASUBTYPE_I420;
EXTERN_C const GUID MEDIASUBTYPE_IYUV;
#endif

#ifdef USE_PROPERTY_PAGES

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPMETHOD
 *
 *  @mfunc void | CPreviewProperty | CPreviewProperty | This
 *    method is the constructor for frame rate property objects. It
 *    calls the base class constructor, calls InitCommonControlsEx, and saves
 *    pointers to the <i IFrameRateControl> and <i IVideoControl> interfaces.
 *
 *  @parm HWND | hDlg | Specifies a handle to the parent property page.
 *
 *  @parm ULONG | IDLabel | Specifies a label ID for the property.
 *
 *  @parm ULONG | IDMinControl | Specifies a label ID for the associated
 *    property edit control where the Minimum value of the property appears.
 *
 *  @parm ULONG | IDMaxControl | Specifies a label ID for the associated
 *    property edit control where the Maximum value of the property appears.
 *
 *  @parm ULONG | IDDefaultControl | Specifies a label ID for the associated
 *    property edit control where the Default value of the property appears.
 *
 *  @parm ULONG | IDStepControl | Specifies a label ID for the associated
 *    property edit control where the Stepping Delta value of the property appears.
 *
 *  @parm ULONG | IDEditControl | Specifies a label ID for the associated
 *    property edit control where the value of the property appears.
 *
 *  @parm ULONG | IDTrackbarControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProgressControl | Specifies a label ID for the associated
 *    property slide bar.
 *
 *  @parm ULONG | IDProperty | Specifies the ID of the Ks property.
 *
 *  @parm IFrameRateControl* | pIFrameRateControl | Specifies a pointer to the
 *    <i IFrameRateControl> interface.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CPreviewProperty::CPreviewProperty(HWND hDlg, ULONG IDLabel, ULONG IDMinControl, ULONG IDMaxControl, ULONG IDDefaultControl, ULONG IDStepControl, ULONG IDEditControl, ULONG IDTrackbarControl, ULONG IDProgressControl, ULONG IDProperty, IFrameRateControl *pIFrameRateControl, IVideoControl *pIVideoControl)
: CPropertyEditor(hDlg, IDLabel, IDMinControl, IDMaxControl, IDDefaultControl, IDStepControl, IDEditControl, IDTrackbarControl, IDProgressControl, IDProperty, 0)
{
	INITCOMMONCONTROLSEX cc;

	FX_ENTRY("CPreviewProperty::CPreviewProperty")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	cc.dwSize = sizeof (INITCOMMONCONTROLSEX);
	cc.dwICC  = ICC_UPDOWN_CLASS | ICC_BAR_CLASSES;

	InitCommonControlsEx(&cc);

	// It's fine if the interface pointers are NULL, we'll grey the
	// associated items in the property page
	m_pIFrameRateControl = pIFrameRateControl;
	m_pIVideoControl = pIVideoControl;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPMETHOD
 *
 *  @mfunc void | CPreviewProperty | ~CPreviewProperty | This
 *    method is the destructor for preview property objects. It
 *    simply calls the base class destructor.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CPreviewProperty::~CPreviewProperty()
{
	FX_ENTRY("CPreviewProperty::~CPreviewProperty")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPMETHOD
 *
 *  @mfunc HRESULT | CPreviewProperty | GetValue | This method queries for
 *    the value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CPreviewProperty::GetValue()
{
	HRESULT Hr = E_NOTIMPL;
	LONG CurrentValue;
	LONG Mode;

	FX_ENTRY("CPreviewProperty::GetValue")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	switch (m_IDProperty)
	{									
		case IDC_Preview_FrameRate:
			if (m_pIFrameRateControl && SUCCEEDED (Hr = m_pIFrameRateControl->Get(FrameRateControl_Maximum, &CurrentValue, (TAPIControlFlags *)&m_CurrentFlags)))
			{
				if (CurrentValue)
					m_CurrentValue = (LONG)(10000000 / CurrentValue);
				else
					m_CurrentValue = 0;
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: *pAvgTimePerFrame=%ld", _fx_, CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_Preview_CurrentFrameRate:
			if (m_pIFrameRateControl && SUCCEEDED (Hr = m_pIFrameRateControl->Get(FrameRateControl_Current, &CurrentValue, (TAPIControlFlags *)&m_CurrentFlags)))
			{
				if (CurrentValue)
					m_CurrentValue = (LONG)((10000000 + (CurrentValue / 2)) / CurrentValue);
				else
					m_CurrentValue = 0;
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: *pAvgTimePerFrame=%ld", _fx_, CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_Preview_FlipVertical:
			if (m_pIVideoControl && SUCCEEDED (Hr = m_pIVideoControl->GetMode(&Mode)))
			{
				// We have to be between 0 and 1
				m_CurrentValue = Mode & VideoControlFlag_FlipVertical ? TRUE : FALSE;
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: Vertical flip is %s"), _fx_, m_CurrentValue ? "ON" : "OFF");
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_Preview_FlipHorizontal:
			if (m_pIVideoControl && SUCCEEDED (Hr = m_pIVideoControl->GetMode(&Mode)))
			{
				// We have to be between 0 and 1
				m_CurrentValue = Mode & VideoControlFlag_FlipHorizontal ? TRUE : FALSE;
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: Horizontal flip is %s"), _fx_, m_CurrentValue ? "ON" : "OFF");
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		default:
			Hr = E_UNEXPECTED;
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Unknown preview property", _fx_));
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPMETHOD
 *
 *  @mfunc HRESULT | CPreviewProperty | SetValue | This method sets the
 *    value of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CPreviewProperty::SetValue()
{
	HRESULT Hr = E_NOTIMPL;
	LONG CurrentValue;
	LONG Mode;

	FX_ENTRY("CPreviewProperty::SetValue")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	switch (m_IDProperty)
	{
		case IDC_Preview_FrameRate:
			if (m_CurrentValue)
				CurrentValue = 10000000L / m_CurrentValue;
			if (m_pIFrameRateControl && SUCCEEDED (Hr = m_pIFrameRateControl->Set(FrameRateControl_Maximum, CurrentValue, (TAPIControlFlags)m_CurrentFlags)))
			{
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: AvgTimePerFrame=%ld", _fx_, CurrentValue));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_Preview_FlipVertical:
			if (m_pIVideoControl && SUCCEEDED (Hr = m_pIVideoControl->GetMode(&Mode)))
			{
				if (m_CurrentValue)
					Mode |= VideoControlFlag_FlipVertical;
				else
					Mode &= !VideoControlFlag_FlipVertical;
				if (SUCCEEDED (Hr = m_pIVideoControl->SetMode(Mode)))
				{
					DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: Vertical flip is %s"), _fx_, m_CurrentValue ? "ON" : "OFF");
				}
				else
				{
					DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
				}
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_Preview_FlipHorizontal:
			if (m_pIVideoControl && SUCCEEDED (Hr = m_pIVideoControl->GetMode(&Mode)))
			{
				if (m_CurrentValue)
					Mode |= VideoControlFlag_FlipHorizontal;
				else
					Mode &= !VideoControlFlag_FlipHorizontal;
				if (SUCCEEDED (Hr = m_pIVideoControl->SetMode(Mode)))
				{
					DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: Horizontal flip is %s"), _fx_, m_CurrentValue ? "ON" : "OFF");
				}
				else
				{
					DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
				}
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_Preview_CurrentFrameRate:
			// This is a read-only property. Don't do anything.
			Hr = NOERROR;
			break;
		default:
			Hr = E_UNEXPECTED;
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Unknown preview property", _fx_));
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPMETHOD
 *
 *  @mfunc HRESULT | CPreviewProperty | GetRange | This method retrieves
 *    the range information of a property.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CPreviewProperty::GetRange()
{
	HRESULT Hr = E_NOTIMPL;
	LONG Min;
	LONG Max;
	LONG SteppingDelta;
	LONG Default;

	FX_ENTRY("CPreviewProperty::GetRange")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	switch (m_IDProperty)
	{
		case IDC_Preview_FrameRate:
			if (m_pIFrameRateControl && SUCCEEDED (Hr = m_pIFrameRateControl->GetRange(FrameRateControl_Maximum, &Min, &Max, &SteppingDelta, &Default, (TAPIControlFlags *)&m_CapsFlags)))
			{
				if (Min)
					m_Max = (LONG)(10000000 / Min);
				else
					m_Max = 0;
				if (Max)
					m_Min = (LONG)(10000000 / Max);
				else
					m_Min = 0;
				if (SteppingDelta)
					m_SteppingDelta = (m_Max - m_Min) / (LONG)((Max - Min) / SteppingDelta);
				else
					m_SteppingDelta = 0;
				if (Default)
					m_DefaultValue = (LONG)(10000000 / Default);
				else
					m_DefaultValue = 0;
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: *pMin=%ld, *pMax=%ld, *pSteppingDelta=%ld, *pDefault=%ld", _fx_, Min, Max, SteppingDelta, Default));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_Preview_CurrentFrameRate:
			if (m_pIFrameRateControl && SUCCEEDED (Hr = m_pIFrameRateControl->GetRange(FrameRateControl_Current, &Min, &Max, &SteppingDelta, &Default, (TAPIControlFlags *)&m_CapsFlags)))
			{
				if (Min)
					m_Max = (LONG)(10000000 / Min);
				else
					m_Max = 0;
				if (Max)
					m_Min = (LONG)(10000000 / Max);
				else
					m_Min = 0;
				if (SteppingDelta)
					m_SteppingDelta = (LONG)(10000000 / SteppingDelta);
				else
					m_SteppingDelta = 0;
				if (Default)
					m_DefaultValue = (LONG)(10000000 / Default);
				else
					m_DefaultValue = 0;
				DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: *pMin=%ld, *pMax=%ld, *pSteppingDelta=%ld, *pDefault=%ld", _fx_, Min, Max, SteppingDelta, Default));
			}
			else
			{
				DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Failed Hr=0x%08lX", _fx_, Hr));
			}
			break;
		case IDC_Preview_FlipVertical:
		case IDC_Preview_FlipHorizontal:
			m_DefaultValue = m_CurrentValue;
			m_Min = 0;
			m_Max = 1;
			m_SteppingDelta = 1;
			Hr = NOERROR;
			break;
		default:
			Hr = E_UNEXPECTED;
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: Unknown preview property", _fx_));
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return Hr;
}

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPMETHOD
 *
 *  @mfunc HRESULT | CPreviewProperty | CanAutoControl | This method
 *    retrieves the automatic control capabilities for a property.
 *
 *  @rdesc This method returns TRUE if automatic control is supported, FALSE
 *    otherwise.
 ***************************************************************************/
BOOL CPreviewProperty::CanAutoControl(void)
{
	FX_ENTRY("CPreviewProperty::CanAutoControl")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

	return FALSE;
}

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPMETHOD
 *
 *  @mfunc HRESULT | CPreviewProperty | GetAuto | This method
 *    retrieves the current automatic control mode of a property.
 *
 *  @rdesc This method returns TRUE if automatic control is supported, FALSE
 *    otherwise.
 ***************************************************************************/
BOOL CPreviewProperty::GetAuto(void)
{
	FX_ENTRY("CPreviewProperty::GetAuto")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

	return FALSE; 
}

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPMETHOD
 *
 *  @mfunc HRESULT | CPreviewProperty | SetAuto | This method
 *    sets the automatic control mode of a property.
 *
 *  @parm BOOL | fAuto | Specifies the automatic control mode.
 *
 *  @rdesc This method returns TRUE.
 ***************************************************************************/
BOOL CPreviewProperty::SetAuto(BOOL fAuto)
{
	FX_ENTRY("CPreviewProperty::SetAuto")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));

	return TRUE; 
}

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPMETHOD
 *
 *  @mfunc CUnknown* | CPreviewProperties | CreateInstance | This
 *    method is called by DShow to create an instance of a TAPI Preview Pin
 *    Property Page. It is referred to in the global structure <t g_Templates>.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Returns a pointer to the nondelegating CUnknown portion of the
 *    object, or NULL otherwise.
 ***************************************************************************/
CUnknown* CALLBACK CPreviewPropertiesCreateInstance(LPUNKNOWN pUnkOuter, HRESULT *pHr) 
{
	CUnknown *pUnknown = (CUnknown *)NULL;

	FX_ENTRY("CPreviewPropertiesCreateInstance")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pHr);
	if (!pHr)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		goto MyExit;
	}

	if (!(pUnknown = new CPreviewProperties(pUnkOuter, pHr)))
	{
		*pHr = E_OUTOFMEMORY;
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: new CPreviewProperties failed", _fx_));
	}
	else
	{
		DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: new CPreviewProperties created", _fx_));
	}

MyExit:
	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
	return pUnknown;
}

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPMETHOD
 *
 *  @mfunc void | CPreviewProperties | CPreviewProperties | This
 *    method is the constructor for the property page object. It simply
 *    calls the constructor of the property page base class.
 *
 *  @parm LPUNKNOWN | pUnkOuter | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CPreviewProperties::CPreviewProperties(LPUNKNOWN pUnk, HRESULT *pHr) : CBasePropertyPage(NAME("TAPI Preview Pin Property Page"), pUnk, IDD_PreviewFormatProperties, IDS_PREVIEWFORMATSPROPNAME)
{
	FX_ENTRY("CPreviewProperties::CPreviewProperties")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	m_pIFrameRateControl = NULL;
	m_pIAMStreamConfig = NULL;
	m_pIVideoControl = NULL;
	m_NumProperties = NUM_PREVIEW_CONTROLS;
	m_fActivated = FALSE;
	m_hWndFormat = m_hWnd = NULL;
	m_RangeCount = 0;
	m_SubTypeList = NULL;
	m_FrameSizeList = NULL;
	m_CurrentMediaType = NULL;
	m_CurrentFormat = 0;
	m_OriginalFormat = 0;

	for (int i = 0; i < m_NumProperties; i++)
		m_Controls[i] = NULL;

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPMETHOD
 *
 *  @mfunc void | CPreviewProperties | ~CPreviewProperties | This
 *    method is the destructor for the preview pin property page. It
 *    simply calls the base class destructor after deleting all the controls.
 *
 *  @rdesc Nada.
 ***************************************************************************/
CPreviewProperties::~CPreviewProperties()
{
	int		j;

	FX_ENTRY("CPreviewProperties::~CPreviewProperties")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Free the controls
	for (j = 0; j < m_NumProperties; j++)
	{
		if (m_Controls[j])
		{
			DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s:   SUCCESS: deleting m_Controls[%ld]=0x%08lX", _fx_, j, m_Controls[j]));
			delete m_Controls[j], m_Controls[j] = NULL;
		}
		else
		{
			DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   WARNING: control already freed", _fx_));
		}
	}

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: end", _fx_));
}

/****************************************************************************
 *  @doc INTERNAL CPREVIEWPMETHOD
 *
 *  @mfunc HRESULT | CPreviewProperties | OnConnect | This
 *    method is called when the property page is connected to the filter.
 *
 *  @parm LPUNKNOWN | pUnknown | Specifies the outer unknown, if any.
 *
 *  @parm HRESULT* | pHr | Specifies the place in which to put any error return.
 *
 *  @rdesc This method returns an HRESULT value that depends on the
 *    implementation of the interface. HRESULT can include one of the
 *    following standard constants, or other values not listed:
 *
 *  @flag E_FAIL | Failure
 *  @flag E_POINTER | Null pointer argument
 *  @flag E_NOTIMPL | Method is not supported
 *  @flag NOERROR | No error
 ***************************************************************************/
HRESULT CPreviewProperties::OnConnect(IUnknown *pUnk)
{
	HRESULT Hr = NOERROR;

	FX_ENTRY("CPreviewProperties::OnConnect")

	DBGOUT((g_dwVideoCaptureTraceID, TRCE, "%s: begin", _fx_));

	// Validate input parameters
	ASSERT(pUnk);
	if (!pUnk)
	{
		DBGOUT((g_dwVideoCaptureTraceID, FAIL, "%s:   ERROR: invalid input parameter", _fx_));
		Hr = E_POINTER;
		goto 