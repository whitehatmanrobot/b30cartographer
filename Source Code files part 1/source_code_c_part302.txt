 = (long)LVal2;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        3,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONG LVal1,
    IN ULONG LVal2,
    IN ULONG LVal3,
    IN ULONGLONG PVal1
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[4];

    Params[0].Type = eeptiLongVal;
    Params[0].LVal = (long)LVal1;
    Params[1].Type = eeptiLongVal;
    Params[1].LVal = (long)LVal2;
    Params[2].Type = eeptiLongVal;
    Params[2].LVal = (long)LVal3;
    Params[3].Type = eeptiPointerVal;
    Params[3].PVal = PVal1;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        3,
        Params);
}


void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONG LVal1,
    IN ULONG LVal2,
    IN ULONG LVal3,
    IN ULONG LVal4
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[4];

    Params[0].Type = eeptiLongVal;
    Params[0].LVal = (long)LVal1;
    Params[1].Type = eeptiLongVal;
    Params[1].LVal = (long)LVal2;
    Params[2].Type = eeptiLongVal;
    Params[2].LVal = (long)LVal3;
    Params[3].Type = eeptiLongVal;
    Params[3].PVal = LVal4;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        4,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONGLONG PVal1,
    IN ULONGLONG PVal2,
    IN ULONGLONG PVal3,
    IN ULONGLONG PVal4
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[4];

    Params[0].Type = eeptiPointerVal;
    Params[0].PVal = PVal1;
    Params[1].Type = eeptiPointerVal;
    Params[1].PVal = PVal2;
    Params[2].Type = eeptiPointerVal;
    Params[2].PVal = PVal3;
    Params[3].Type = eeptiPointerVal;
    Params[3].PVal = PVal4;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        4,
        Params);
}

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorAddRecord (
    IN RPC_EXTENDED_ERROR_INFO *ErrorInfo
    )
/*++

Routine Description:

    Adds the supplied record to the top of the chain in the teb

Arguments:
    ErrorInfo - the eeinfo record to add to the chain

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    ExtendedErrorInfo *NewRecord;
    RPC_STATUS RpcStatus;

    if (ErrorInfo->Version != RPC_EEINFO_VERSION)
        return ERROR_INVALID_PARAMETER;

    if (ErrorInfo->ComputerName != NULL)
        return ERROR_INVALID_PARAMETER;

    if (ErrorInfo->Flags != 0)
        return ERROR_INVALID_PARAMETER;

    if (ErrorInfo->NumberOfParameters < 0)
        return ERROR_INVALID_PARAMETER;

    if (ErrorInfo->NumberOfParameters > MaxNumberOfEEInfoParams)
        return ERROR_INVALID_PARAMETER;

    if (ErrorInfo->DetectionLocation != 0)
        return ERROR_INVALID_PARAMETER;

    // make sure only valid constants come through. This can be the microsoft outside of RPC range
    // (currently bounded by EEInfoGCCOM to EEInfoGCFRS) or outside the microsoft range). If not, it
    // can be 0
    if ((ErrorInfo->GeneratingComponent != 0) 
        && 
        ( 
          (ErrorInfo->GeneratingComponent < EEInfoGCCOM)
          ||
          (
           (ErrorInfo->GeneratingComponent > EEInfoGCFRS)
           &&
           (ErrorInfo->GeneratingComponent < 0x80000000)
          )
        )
       )
        {
        return ERROR_INVALID_PARAMETER;
        }

    if (ErrorInfo->ProcessID != 0)
        return ERROR_INVALID_PARAMETER;

    NewRecord = AllocateExtendedErrorInfoRecord(ErrorInfo->NumberOfParameters);
    if (NewRecord == NULL)
        return RPC_S_OUT_OF_MEMORY;

    RpcStatus = ConvertPublicEEInfoToPrivateEEInfo(ErrorInfo, EEInfoDLApi, NewRecord);
    if (RpcStatus != RPC_S_OK)
        {
        FreeEEInfoRecordShallow(NewRecord);
        return RpcStatus;
        }

    RpcStatus = AddPrivateRecord(NewRecord);
    if (RpcStatus != RPC_S_OK)
        {
        FreeEEInfoRecord(NewRecord);
        }

    return RpcStatus;
}

RPCRTAPI
void 
RPC_ENTRY
RpcErrorClearInformation (
    void
    )
/*++

Routine Description:

    Clears the existing eeinfo on the teb (if any)

Arguments:
    void

Return Value:

    void

--*/
{
    ExtendedErrorInfo *EEInfo;
    THREAD *Thread;

    Thread = RpcpGetThreadPointer();
    if (Thread == NULL)
        return;

    EEInfo = Thread->GetEEInfo();
    Thread->SetEEInfo(NULL);
    FreeEEInfoChain(EEInfo);
}

BOOL
KnockOffLastButOneEEInfoRecord (
    IN ExtendedErrorInfo *EEInfo
    )
/*++

Routine Description:

    Will delete the last-but-one record from the chain. If there
    are two or less record, nothing is deleted, and FALSE gets
    returned.

Arguments:
    EEInfo - the extended error info chain

Return Value:
    TRUE - a record was deleted
    FALSE - there were two or less records, and nothing was deleted.

--*/
{
    ExtendedErrorInfo *NextRecord, *LastButOneRecord;
    ExtendedErrorInfo *PreviousRecord;

    LastButOneRecord = NextRecord = EEInfo;
    while ((NextRecord != NULL) && (NextRecord->Next != NULL))
        {
        PreviousRecord = LastButOneRecord;
        LastButOneRecord = NextRecord;
        NextRecord = NextRecord->Next;
        }

    if ((NextRecord == EEInfo) || (LastButOneRecord == EEInfo))
        {
        return FALSE;
        }

    PreviousRecord->Next = NextRecord;
    // indicate that the chain has been broken
    PreviousRecord->Flags |= EEInfoNextRecordsMissing;
    NextRecord->Flags |= EEInfoPreviousRecordsMissing;
    // move the computer name up if necessary
    if ((LastButOneRecord->ComputerName.Type == eecnpPresent)
        && (NextRecord->ComputerName.Type == eecnpNotPresent))
        {
        // N.B. Not covered by unit tests
        LastButOneRecord->ComputerName.Type = eecnpNotPresent;
        NextRecord->ComputerName.Type = eecnpPresent;
        NextRecord->ComputerName.Name.nLength = LastButOneRecord->ComputerName.Name.nLength;
        NextRecord->ComputerName.Name.pString = LastButOneRecord->ComputerName.Name.pString;
        }
    FreeEEInfoRecord(LastButOneRecord);
    return TRUE;
}

RPC_STATUS
TrimEEInfoToLengthByRemovingRecords (
    IN ExtendedErrorInfo *EEInfo,
    IN size_t MaxLength,
    OUT BOOL *fTrimmedEnough,
    OUT size_t *NeededLength
    )
/*++

Routine Description:

    This function removes records, until either two records are
    left, or the pickled length drops below MaxLength. If the
    pickled length is below the MaxLength to start with, no
    records should be dropped. The records are dropped starting
    from the last-but-one, and going backwards (towards the
    current record). The previous and next records should
    have their chain broken flags set, and the computer name
    should be moved up the chain, if the last record has
    no computer name.

Arguments:
    EEInfo - the EE chain
    MaxLength - the length that we need to trim to.
    fTrimmedEnough - will be set to TRUE if the pickled length
        on return from this function fits in MaxLength. Undefined
        if the return value is not RPC_S_OK
    NeededLength - if fTrimmedEnough was set to TRUE, and the
        return value is RPC_S_OK, the current pickled length.
        Otherwise, this value must not be touched (i.e. use
        a local variable until you're sure that both conditions
        are true).

Return Value:
    RPC_S_OK on success.
    != RPC_S_OK on error. On error, fTrimmedEnough is undefined, and
        NeededLength is not touched.

--*/
{
    ULONG EncodedSize;
    handle_t PickleHandle = NULL;
    char *TempBuffer;
    RPC_STATUS RpcStatus;
    ExtendedErrorInfoPtr *EEInfoPtr;
    PVOID Buffer = NULL;
    size_t CurrentlyNeededLength;
    size_t PickleLength;
    size_t BufferLength;
    BOOL Result;

    RpcStatus = MesEncodeDynBufferHandleCreate(&TempBuffer, &EncodedSize, &PickleHandle);
    if (RpcStatus != RPC_S_OK)
        {
        return RpcStatus;
        }

    // our first goal is to drive the pickled length to less than 2 times
    // the MaxLength. Since the actual pickling often takes less than the
    // estimated, we will do the fine tuning by actually pickling and measuring
    // the resulting size. For the rough tuning, we will use the estimate, and
    // knock off it, if we are over the estimate
    CurrentlyNeededLength = MaxLength * 2;
    while (TRUE)
        {
        EEInfoPtr = &EEInfo;

        // get the estimated size
        PickleLength = ExtendedErrorInfoPtr_AlignSize(PickleHandle, EEInfoPtr);
        if (PickleLength <= CurrentlyNeededLength)
            {
            break;
            }

        // knock off the last-but-one element
        Result = KnockOffLastButOneEEInfoRecord(EEInfo);
        if (Result == FALSE)
            {
            *fTrimmedEnough = FALSE;
            goto SuccessCleanupAndExit;
            }
        }

    // here, the PickleHandle should be valid, and ready for actual pickling
    // do the fine-tuned trimming - actually pickle, and see whether it fits
    Buffer = MIDL_user_allocate(PickleLength);
    if (Buffer == NULL)
        {
        RpcStatus = RPC_S_OUT_OF_MEMORY;
        goto CleanupAndExit;
        }

    BufferLength = PickleLength;

    TempBuffer = (char *)Buffer;

    CurrentlyNeededLength = MaxLength;

    while (TRUE)
        {
        // re-initialize the handle to fixed buffer
        RpcStatus = MesBufferHandleReset(PickleHandle, 
            MES_FIXED_BUFFER_HANDLE, 
            MES_ENCODE, 
            &TempBuffer, 
            BufferLength, 
            &EncodedSize);

        if (RpcStatus != RPC_S_OK)
            {
            goto CleanupAndExit;
            }

        RpcTryExcept
            {
            ExtendedErrorInfoPtr_Encode(PickleHandle, EEInfoPtr);
            }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
            RpcStatus = RpcExceptionCode();
            }
        RpcEndExcept

        if (RpcStatus != RPC_S_OK)
            {
            goto CleanupAndExit;
            }

        if (EncodedSize <= CurrentlyNeededLength)
            {
            *fTrimmedEnough = TRUE;
            *NeededLength = EncodedSize;
            goto SuccessCleanupAndExit;
            }

        Result = KnockOffLastButOneEEInfoRecord(EEInfo);
        if (Result == FALSE)
            {
            *fTrimmedEnough = FALSE;
            goto SuccessCleanupAndExit;
            }
        }

SuccessCleanupAndExit:
    RpcStatus = RPC_S_OK;

CleanupAndExit:
    if (Buffer != NULL)
        {
        MIDL_user_free(Buffer);
        }

    if (PickleHandle != NULL)
        {
        MesHandleFree(PickleHandle);
        }
    return RpcStatus;
}

RPC_STATUS
GetLengthOfPickledEEInfo (
    IN ExtendedErrorInfo *EEInfo,
    OUT size_t *NeededLength
    )
/*++

Routine Description:

    Calculate the length of the given eeinfo when pickled. It 
    does that by pickling it in a temporary buffer and 
    checking the resulting length.

Arguments:
    ErrorInfo - the eeinfo chain whose length we need to calculate
    NeededLength - the length in bytes

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    ULONG EncodedSize;
    handle_t PickleHandle = NULL;
    char *TempBuffer;
    RPC_STATUS RpcStatus;
    ExtendedErrorInfoPtr *EEInfoPtr;
    PVOID Buffer = NULL;
    size_t MarshallSize;

    RpcStatus = MesEncodeDynBufferHandleCreate(&TempBuffer, &EncodedSize, &PickleHandle);
    if (RpcStatus != RPC_S_OK)
        {
        return RpcStatus;
        }

    EEInfoPtr = &EEInfo;

    // get the estimated size
    MarshallSize = ExtendedErrorInfoPtr_AlignSize(PickleHandle, EEInfoPtr);
    Buffer = MIDL_user_allocate(MarshallSize);
    if (Buffer == NULL)
        {
        RpcStatus = RPC_S_OUT_OF_MEMORY;
        goto CleanupAndExit;
        }

    TempBuffer = (char *)Buffer;

    // re-initialize the handle to fixed buffer
    RpcStatus = MesBufferHandleReset(PickleHandle, 
        MES_FIXED_BUFFER_HANDLE, 
        MES_ENCODE, 
        &TempBuffer, 
        MarshallSize, 
        &EncodedSize);

    if (RpcStatus != RPC_S_OK)
        {
        goto CleanupAndExit;
        }

    RpcTryExcept
        {
        ExtendedErrorInfoPtr_Encode(PickleHandle, EEInfoPtr);
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        RpcStatus = RpcExceptionCode();
        }
    RpcEndExcept

    if (RpcStatus != RPC_S_OK)
        {
        goto CleanupAndExit;
        }

    *NeededLength = EncodedSize;

CleanupAndExit:
    if (Buffer != NULL)
        {
        MIDL_user_free(Buffer);
        }

    if (PickleHandle != NULL)
        {
        MesHandleFree(PickleHandle);
        }
    return RpcStatus;
}

RPC_STATUS
TrimEEInfoToLengthByRemovingStrings (
    IN ExtendedErrorInfo *EEInfo,
    IN size_t MaxLength,
    OUT BOOL *fTrimmedEnough,
    OUT size_t *NeededLength
    )
/*++

Routine Description:

    Try to trim the eeinfo to the given length by whacking any
    strings in the eeinfo chain. After each string is whacked
    a re-measurement is made

Arguments:
    ErrorInfo - the eeinfo chain that we need to fit in MaxLength
        bytes.
    MaxLength - the length we need to trim to
    fTrimmedEnough - non-zero if we were able to trim the length below
        MaxLength.
    NeededLength - the length in bytes of the trimmed eeinfo. Not
        touched if fTrimmedEnough is FALSE.

    N.B. This function should only be called after 
    TrimEEInfoToLengthByRemovingRecords

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    ExtendedErrorInfo *CurrentRecord;
    size_t CurrentLength;
    int i;
    RPC_STATUS RpcStatus;
    BOOL TrimLongParam;
    void *ParameterToTrim;

    // we shouldn't be here if there are more than two records
    if (EEInfo->Next && EEInfo->Next->Next)
        {
        ASSERT(0);
        }

    CurrentRecord = EEInfo;
    while (CurrentRecord != NULL)
        {
        // trim the parameters and remeasure. If still nothing, move on to
        // the computer name.
        for (i = 0; i < EEInfo->nLen; i ++)
            {
            TrimLongParam = FALSE;
            if ((CurrentRecord->Params[i].Type == eeptiAnsiString) 
                || (CurrentRecord->Params[i].Type == eeptiUnicodeString))
                {
                TrimLongParam = TRUE;
                // both string pointers occupy the same memory location,
                // so it is ok to free either
                ParameterToTrim = CurrentRecord->Params[i].AnsiString.pString;
                }
            else if (CurrentRecord->Params[i].Type == eeptiBinary)
                {
                TrimLongParam = TRUE;
                ParameterToTrim = CurrentRecord->Params[i].Blob.pBlob;
                }

            if (TrimLongParam)
                {
                MIDL_user_free(CurrentRecord->Params[i].AnsiString.pString);
                CurrentRecord->Params[i].Type = eeptiNone;

                // remeasure
                RpcStatus = GetLengthOfPickledEEInfo(EEInfo, &CurrentLength);
                if (RpcStatus != RPC_S_OK)
                    return RpcStatus;

                if (CurrentLength <= MaxLength)
                    {
                    *NeededLength = CurrentLength;
                    *fTrimmedEnough = TRUE;
                    return RPC_S_OK;
                    }
                }
            }

        // if the computer name is there, try to trim it. If nothing,
        // move on to the next record
        if (CurrentRecord->ComputerName.Type == eecnpPresent)
            {
            // N.B. Not covered by unit tests
            MIDL_user_free(CurrentRecord->ComputerName.Name.pString);
            CurrentRecord->ComputerName.Type = eecnpNotPresent;

            RpcStatus = GetLengthOfPickledEEInfo(EEInfo, &CurrentLength);
            if (RpcStatus != RPC_S_OK)
                return RpcStatus;

            if (CurrentLength <= MaxLength)
                {
                // N.B. Not covered by unit tests
                *NeededLength = CurrentLength;
                *fTrimmedEnough = TRUE;
                return RPC_S_OK;
                }
            // N.B. Not covered by unit tests
            }

        CurrentRecord = CurrentRecord->Next;
        }

    // N.B. In the current implementation, the minimum fragment length
    // belongs to LRPC, and is 0xb8. At this length, two records
    // with strings stripped always fit. Therefore, we can never be
    // here. The code below is untested, and is left only for future
    // work where we have a transport supporting fragment length
    // which doesn't hold two records with strings stripped
    ASSERT(0);
    // if we are here, obviously we couldn't trim enough
    *fTrimmedEnough = FALSE;
    return RPC_S_OK;
}

void
TrimEEInfoToLength (
    IN size_t MaxLength,
    OUT size_t *NeededLength
    )
/*++

Routine Description:

    Some protocols don't allow transmitting arbitrary lengths
    of information. This function will attempt to trim the pickled
    length of the existing error information so as to fit MaxLength.
    First, it will try to knock off records, starting from the
    last-but-one, and going back. If this is not sufficient, it will
    whack any string arguments/computer names in the record. If this
    is also, not sufficient, it should drop the top record. This should
    leave the total length to be about 128 bytes. All protocols must
    be able to transmit that, as this routine cannot trim it any
    further.
    If MaxLength is larger than the current pickled length, no trimming
    is done, and the actual pickled length will be returned in
    NeededLength

Arguments:
    MaxLength - the maximum length for this chain.
    NeededLength - on success, how much we actually need to transfer
        the existing extended error info. This must be less than
        MaxLength. If the function cannot get estimation for some
        reason (probably out-of-memory), or there is no extended
        error information, it will return 0 in this parameter.

Return Value:
    void

--*/
{
    RPC_STATUS RpcStatus;
    BOOL fTrimmedEnough;
    ExtendedErrorInfo *EEInfo;
    THREAD *Thread;
    ExtendedErrorInfo *LastRecord;

    ASSERT(MaxLength >= MinimumTransportEEInfoLength);

    *NeededLength = 0;
    Thread = RpcpGetThreadPointer();
    if (Thread == NULL)
        return;

    EEInfo = Thread->GetEEInfo();
    if (EEInfo == NULL)
        return;

    RpcStatus = TrimEEInfoToLengthByRemovingRecords(EEInfo, MaxLength, &fTrimmedEnough, NeededLength);
    if (RpcStatus != RPC_S_OK)
        return;

    // if fTrimmedEnough is set, NeededLength should have been set
    if (fTrimmedEnough == TRUE)
        {
        ASSERT(*NeededLength <= MaxLength);
        return;
        }
    ASSERT(*NeededLength == 0);

    RpcStatus = TrimEEInfoToLengthByRemovingStrings(EEInfo, MaxLength, &fTrimmedEnough, NeededLength);
    if (RpcStatus != RPC_S_OK)
        return;

    // if fTrimmedEnough is set, NeededLength should have been set
    if (fTrimmedEnough == TRUE)
        {
        ASSERT(*NeededLength <= MaxLength);
        return;
        }

    // N.B. In the current implementation, the minimum fragment length
    // belongs to LRPC, and is 0xb8. At this length, two records
    // with strings stripped always fit. Therefore, we can never be
    // here. The code below is untested, and is left only for future
    // work where we have a transport supporting fragment length
    // which doesn't hold two records with strings stripped

    ASSERT(0);
    // again, we couldn't trim it enough
    // drop the first record

    // make sure there are exactly two records
    // this is so, because if we have only one record,
    // it should have fit by now. If we had more than two
    // records, there is a bug in the trimming records code
    ASSERT(EEInfo->Next);
    ASSERT(EEInfo->Next->Next == NULL);

    LastRecord = EEInfo->Next;
    FreeEEInfoRecord(EEInfo);
    EEInfo = LastRecord;
    Thread->SetEEInfo(LastRecord);

#if DBG
    RpcStatus = GetLengthOfPickledEEInfo(EEInfo, NeededLength);
    if (RpcStatus != RPC_S_OK)
        return;

    ASSERT(*NeededLength <= MaxLength);
#endif
}

size_t
EstimateSizeOfEEInfo (
    void
    )
/*++

Routine Description:

    Takes the EEInfo from the teb (if any) and calculates the size
    of the pickled eeinfo

Arguments:
    void

Return Value:

    the size or 0 if it fails

--*/
{
    ExtendedErrorInfo *EEInfo;
    THREAD *Thread;
    RPC_STATUS RpcStatus;
    size_t NeededLength;

    Thread = RpcpGetThreadPointer();
    if (Thread == NULL)
        return 0;

    EEInfo = Thread->GetEEInfo();
    if (EEInfo == NULL)
        return 0;

    RpcStatus = GetLengthOfPickledEEInfo(EEInfo, &NeededLength);
    if (RpcStatus != RPC_S_OK)
        return 0;

    return NeededLength;
}

RPC_STATUS
PickleEEInfo (
    IN ExtendedErrorInfo *EEInfo,
    IN OUT unsigned char *Buffer,
    IN size_t BufferSize
    )
/*++

Routine Description:

    This routine does the actual pickling in a user supplied buffer.
    The buffer must have been allocated large enough to hold all
    pickled data. Some of the other functions should have been
    used to get the size of the pickled data and the buffer
    should have been allocated appropriately

Arguments:
    Buffer - the actual Buffer to pickle into
    BufferSize - the size of the Buffer.

Return Value:
    RPC_S_OK if the pickling was successful.
    other RPC_S_* codes if it failed.

--*/
{
    ULONG EncodedSize;
    handle_t PickleHandle = NULL;
    RPC_STATUS RpcStatus;
    ExtendedErrorInfoPtr *EEInfoPtr;

    ASSERT(((ULONG_PTR)Buffer & 0x7) == 0);
    RpcStatus = MesEncodeFixedBufferHandleCreate((char *)Buffer, BufferSize, &EncodedSize, &PickleHandle);
    if (RpcStatus != RPC_S_OK)
        {
        return RpcStatus;
        }

    EEInfoPtr = &EEInfo;

    RpcTryExcept
        {
        ExtendedErrorInfoPtr_Encode(PickleHandle, EEInfoPtr);
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        RpcStatus = RpcExceptionCode();
        }
    RpcEndExcept

    ASSERT(EncodedSize <= BufferSize);

    MesHandleFree(PickleHandle);
    return RpcStatus;
}

void
NukeStaleEEInfoIfNecessary (
    IN RPC_STATUS exception
    )
/*++

Routine Description:

    Matches the given error code to the error code in the
    first record of the eeinfo chain in the teb. If they match
    or if there is *no* Win32<->NT_STATUS correspondence b/n them
    the eeinfo in the teb is nuked

Arguments:
    exception - the error code to match against

Return Value:
    void

--*/
{
    THREAD *Thread;
    ExtendedErrorInfo *EEInfo;
    long ExceptionNtStatus;
    long EEInfoNtStatus;

    Thread = RpcpGetThreadPointer();
    if (Thread)
        {
        EEInfo = Thread->GetEEInfo();
        if (EEInfo && Thread->Context)
            {
            // there is extended info - try to match it to what we have
            ExceptionNtStatus = I_RpcMapWin32Status(exception);
            EEInfoNtStatus = I_RpcMapWin32Status(EEInfo->Status);
            if (EEInfoNtStatus != ExceptionNtStatus)
                {
                // they are not the same - nuke the stale info
                // to prevent confusion
                RpcpPurgeEEInfoFromThreadIfNecessary(Thread);
                }
            }
        }
}

LPWSTR
AllocateAndGetComputerName (
    IN ComputerNameAllocators AllocatorToUse,
    IN COMPUTER_NAME_FORMAT NameToRetrieve,
    IN size_t ExtraBytes,
    IN int StartingOffset,
    OUT DWORD *Size
    )
/*++

Routine Description:

    Allocates space for the computer name and gets it

Arguments:

    AllocatorToUse - cnaMidl or cnaNew. If cnaMidl is used, MIDL_user_allocate
        will be used to allocate the computer name, If cnaNew is used, new will
        be used for allocating.

    NameToRetreive - standard COMPUTER_NAME_FORMAT enumerator - see MSDN.

    ExtraBytes - extra bytes to allocate in the buffer (in bytes, not in characters!)

    StartingOffset - will put the computer name in the buffer starting at
        the given offset. In bytes, not in characters!

    Size - on output the size of the string in characters, including
        the terminating NULL, but not including the StartingOffset.

Return Value:

    The computer name or NULL of out-of-memory

--*/
{
    DWORD LocalSize = 0;
    BOOL Result;
    LPWSTR Buffer = NULL;
    DWORD LastError;

    Result = GetComputerNameEx(NameToRetrieve, 
        Buffer, 
        &LocalSize);
    ASSERT(Result == 0);

    LastError = GetLastError();
    if (LastError == ERROR_MORE_DATA)
        {
        if (AllocatorToUse == cnaMidl)
            {
            Buffer = (LPWSTR)MIDL_user_allocate(LocalSize * sizeof(RPC_CHAR) + ExtraBytes);
            }
        else
            {
            ASSERT(AllocatorToUse == cnaNew);
            Buffer = (RPC_CHAR *)new char[LocalSize * sizeof(RPC_CHAR) + ExtraBytes];
            }
        if (Buffer)
            {
            Result = GetComputerNameEx(NameToRetrieve, 
                (RPC_CHAR *)((char *)Buffer + StartingOffset), 
                &LocalSize);
            if (Result == 0)
                {
                if (AllocatorToUse == cnaMidl)
                    {
                    MIDL_user_free(Buffer);
                    }
                else
                    {
                    delete Buffer;
                    }
                Buffer = NULL;
                }
            else
                {
                // sometimes GetComputerNameEx returns the size
                // without the terminating NULL regardless of what
                // the MSDN says. The base group (Earhart, NeillC)
                // know about it but won't change it for now.
                // Code it in such a way that it works regardless
                // of when and if they change it.
                *Size = wcslen((RPC_CHAR *)((char *)Buffer + StartingOffset)) + 1;
                }
            }
        }

    return Buffer;
}

void
AddComputerNameToChain (
    ExtendedErrorInfo *EEInfo
    )
/*++

Routine Description:

    Checks the first record in eeinfo, and if it doesn't have
    a computer name to it, adds it.

Arguments:
    EEInfo - the eeinfo chain to add the computer name to

Return Value:
    void - best effort - no guarantees.

--*/
{
    LPWSTR Buffer;
    DWORD Size;

    if (EEInfo->ComputerName.Type == eecnpNotPresent)
        {
        Buffer = AllocateAndGetComputerName(cnaMidl,
            ComputerNamePhysicalDnsHostname,
            0,      // extra bytes
            0,      // starting offset
            &Size);
        if (Buffer)
            {
            EEInfo->ComputerName.Type = eecnpPresent;
            EEInfo->ComputerName.Name.nLength = (CSHORT)Size;
            EEInfo->ComputerName.Name.pString = Buffer;
            }
        }
}

void
StripComputerNameIfRedundant (
    ExtendedErrorInfo *EEInfo
    )
/*++

Routine Description:

    Checks the first record in eeinfo, and if it does have
    a computer name to it and it is the same as the computer
    name of this machine, remove it. This is done to keep
    the length of the chain short during local calls using
    remote protocols

Arguments:
    EEInfo - the eeinfo chain to remove the computer name from

Return Value:
    void

--*/
{
    LPWSTR Buffer = NULL;
    DWORD Size;

    if (EEInfo->ComputerName.Type == eecnpPresent)
        {
        Buffer = AllocateAndGetComputerName(cnaMidl,
            ComputerNamePhysicalDnsHostname,
            0,  // extra bytes
            0,      // starting offset
            &Size);
        if (Buffer)
            {
            if (Size != (DWORD)EEInfo->ComputerName.Name.nLength)
                goto CleanupAndExit;

            // The strings are Unicode - need to multiply by two
            if (RpcpMemoryCompare(Buffer, EEInfo->ComputerName.Name.pString, Size * 2) == 0)
                {
                MIDL_user_free(EEInfo->ComputerName.Name.pString);
                EEInfo->ComputerName.Type = eecnpNotPresent;
                }
            }
        }

CleanupAndExit:
    if (Buffer)
        {
        MIDL_user_free(Buffer);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\epclnt.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    epclnt.cxx

Abstract:

    This file contains the client runtime entry points into the
    endpoint mapper dll.

Author:

    Michael Montague (mikemon) 06-Jan-1992

Revision History:


--*/
#include <precomp.hxx>
#include <epmp.h>
#include <epmap.h>
#include <twrproto.h>
#include <CharConv.hxx>
#include <OsfPcket.hxx>
#include <BitSet.hxx>
#include <ProtBind.hxx>
#include <OsfClnt.hxx>
#include <sidcache.hxx>

extern RPC_STATUS __RPC_FAR
MapFromNcaStatusCode (
    IN unsigned long NcaStatus
    );

const static ProtseqEndpointPair EpMapperTable[] =

                                  {
                                     L"ncacn_np", L"\\pipe\\epmapper", NMP,
                                     L"ncalrpc", L"epmapper", LRPC, 
                                     L"ncacn_ip_tcp", L"135", TCP, 
                                     L"ncadg_ip_udp", L"135", UDP, 
#ifdef NETBIOS_ON
                                     L"ncacn_nb_nb", L"135", NBF, 
                                     L"ncacn_nb_tcp", L"135", NBT, 
                                     L"ncacn_nb_ipx", L"135", NBI, 
#endif
#ifdef SPX_ON
                                     L"ncacn_spx", L"34280", SPX, 
#endif
#ifdef IPX_ON
                                     L"ncadg_ipx", L"34280", IPX, 
#endif
#ifdef APPLETALK_ON
                                     L"ncacn_at_dsp", L"Endpoint Mapper", DSP, 
#endif
#ifdef NCADG_MQ_ON
                                     L"ncadg_mq", L"EpMapper", MSMQ, 
#endif
                                     L"ncacn_http", L"593", HTTP
                                   };

const int LrpcEpMapperEntry = 1;    // the entry in the table that contains LRPC

unsigned long PartialRetries = 0;
unsigned long ReallyTooBusy = 0;

typedef struct _EP_LOOKUP_DATA
{
    unsigned int NumberOfEndpoints;
    unsigned int MaximumEndpoints;
    unsigned int CurrentEndpoint;
    RPC_CHAR *  PAPI *  Endpoints;
} EP_LOOKUP_DATA;




RPC_STATUS RPC_ENTRY
EpResolveEndpoint (
    IN UUID PAPI * ObjectUuid, OPTIONAL
    IN RPC_SYNTAX_IDENTIFIER PAPI * IfId,
    IN RPC_SYNTAX_IDENTIFIER PAPI * XferId,
    IN RPC_CHAR PAPI * RpcProtocolSequence,
    IN RPC_CHAR PAPI * NetworkAddress,
    IN RPC_CHAR PAPI * Options,
    IN OUT void PAPI * PAPI * EpLookupHandle,
    IN unsigned ConnTimeout,
    IN ULONG CallTimeout,
    IN CLIENT_AUTH_INFO *AuthInfo, OPTIONAL
    OUT RPC_CHAR * PAPI * Endpoint
    )
/*++

Routine Description:

    The runtime will call this routine to resolve an endpoint.

Arguments:

    ObjectUuid - Optional specifies the object uuid in the binding
        for which we are trying to resolve an endpoint.

    Ifid - Pointer to the Syntax Identifier for the Interface

    Xferid - Pointer to the Syntax Identifier for the Transfer Syntax.

    RpcProtocolSequence - Supplies the rpc protocol sequence contained
        in the binding.

    NetworkAddress - Supplies the network address.  This will be used
        to contact the endpoint mapper on that machine in order to
        resolve the endpoint.

    EpLookupHandle - Supplies the current version of the lookup handle
        for this iteration through the endpoint mapper.  A new value
        for the lookup handle will be returned.  If RPC_S_NO_ENDPOINT_FOUND
        is returned, this parameter will be set to its initial value,
        zero.

    ConnTimeout - the connection timeout

    CallTimeout - the call timeout

    AutInfo - any auth info that needs to be used during the resolution process

    Endpoint - Returns the endpoint resolved by the endpoint mapper on
        the machine specified by the network address argument.  The
        storage for the endpoint must have been allocated using the
        runtime API I_RpcAllocate.

Return Value:

    RPC_S_OK - The endpoint was successfully resolved.

    EP_S_NOT_REGISTERED  - There are no more endpoints to be found
        for the specified combination of interface, network address,
        and lookup handle.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allow
        resolution of the endpoint.

    EP_S_CANT_PERFORM_OP - The operation failed due to misc. error e.g.
                           unable to bind to the EpMapper.

--*/
{
    RPC_BINDING_HANDLE MapperHandle = 0;
    RPC_STATUS RpcStatus;
    twr_p_t InputTower = 0;
    twr_p_t OutputTower[4];
    unsigned long Returned;
    error_status ErrorStatus;
    ept_lookup_handle_t ContextHandle = 0;
    EP_LOOKUP_DATA PAPI * EpLookupData = (EP_LOOKUP_DATA PAPI *)
            *EpLookupHandle;
    unsigned long RetryCount, i;
    unsigned char PAPI * EPoint;
    PSID SidToUse;
    int NormalizeRetryCount;
    BOOL SidFound;

    CHeapAnsi AnsiNWAddr, AnsiOptions;
    CStackAnsi AnsiProtseq;
    CNlUnicode nlEndpoint;

    // We have already taken all of the endpoints from the endpoint mapper;
    // now we just return them back to the runtime one at a time.

ReturnEndpointFromList:

    ASSERT(*Endpoint == 0);

    if ( EpLookupData != 0 )
        {

        // When we reach the end of the list of endpoints, return an error,
        // and set things up so that we will start at the beginning again.

        if ( EpLookupData->CurrentEndpoint == EpLookupData->NumberOfEndpoints )
            {
            RpcpErrorAddRecord(EEInfoGCRuntime, 
                EPT_S_NOT_REGISTERED,
                EEInfoDLEpResolveEndpoint10,
                RpcProtocolSequence,
                NetworkAddress,
                IfId->SyntaxGUID.Data1,
                (ULONG)((EpLookupData->CurrentEndpoint << 16) | EpLookupData->NumberOfEndpoints));
            EpLookupData->CurrentEndpoint = 0;
            return(EPT_S_NOT_REGISTERED);
            }

        *Endpoint = DuplicateString(
                EpLookupData->Endpoints[EpLookupData->CurrentEndpoint]);
        EpLookupData->CurrentEndpoint += 1;

        if ( *Endpoint == 0 )
            {
            return(RPC_S_OUT_OF_MEMORY);
            }

        return(RPC_S_OK);
        }

    // Otherwise, we need to take the list of endpoints from the endpoint
    // mapper.

    EpLookupData = (EP_LOOKUP_DATA PAPI *) RpcpFarAllocate(
            sizeof(EP_LOOKUP_DATA));
    if ( EpLookupData == 0 )
        {
        return(RPC_S_OUT_OF_MEMORY);
        }
    EpLookupData->MaximumEndpoints = 64;
    EpLookupData->Endpoints = (RPC_CHAR * PAPI *) RpcpFarAllocate(
            sizeof(RPC_CHAR PAPI *) * EpLookupData->MaximumEndpoints);
    if ( EpLookupData->Endpoints == 0 )
        {
        RpcStatus = RPC_S_OUT_OF_MEMORY;
        goto CleanupAndReturn;
        }
    EpLookupData->NumberOfEndpoints = 0;
    EpLookupData->CurrentEndpoint = 0;

    RpcStatus = AnsiNWAddr.Attach(NetworkAddress);
    if ( RpcStatus != RPC_S_OK )
        {
        ASSERT( RpcStatus == RPC_S_OUT_OF_MEMORY );
        goto CleanupAndReturn;
        }

    i = 1+RpcpStringLength(RpcProtocolSequence);
    *(AnsiProtseq.GetPAnsiString()) = (char *)_alloca(i);
    RpcStatus = AnsiProtseq.Attach(RpcProtocolSequence, i, i * 2);
    if ( RpcStatus != RPC_S_OK )
        {
        ASSERT( RpcStatus == RPC_S_OUT_OF_MEMORY );
        goto CleanupAndReturn;
        }

    RpcStatus = AnsiOptions.Attach(Options);
    if ( RpcStatus != RPC_S_OK )
        {
        ASSERT( RpcStatus == RPC_S_OUT_OF_MEMORY );
        goto CleanupAndReturn;
        }

    RpcStatus = BindToEpMapper(&MapperHandle, 
        NetworkAddress, 
        RpcProtocolSequence, 
        Options, 
        ConnTimeout,
        CallTimeout,
        AuthInfo
        );

    if ( RpcStatus != RPC_S_OK )
        {
        MapperHandle = 0;
        goto CleanupAndReturn;
        }

    RpcStatus = TowerConstruct((RPC_IF_ID PAPI *) IfId,
            (RPC_TRANSFER_SYNTAX PAPI *) XferId, (char PAPI *) AnsiProtseq,
            NULL, (char PAPI *) AnsiNWAddr, &InputTower);
    if ( RpcStatus != RPC_S_OK )
        {
        goto CleanupAndReturn;
        }

    NormalizeRetryCount = 0;
    SidFound = FALSE;
    for (RetryCount = 0;;)
        {

        OutputTower[0] = 0;
        OutputTower[1] = 0;
        OutputTower[2] = 0;
        OutputTower[3] = 0;

        if (AuthInfo && (AuthInfo->Capabilities & RPC_C_QOS_CAPABILITIES_LOCAL_MA_HINT) && (SidFound == FALSE))
            {
            // use ept_map_auth if we have the local hint and the SID.
            ASSERT(AuthInfo->ServerSid);
            RpcStatus = NormalizeAccountSid(AuthInfo->ServerSid, &SidToUse, &NormalizeRetryCount);
            if (RpcStatus != RPC_S_OK)
                {
                goto CleanupAndReturn;
                }
            }
        else
            SidToUse = NULL;

        RpcTryExcept
            {
            if (SidToUse)
                {
                ept_map_auth (MapperHandle, ObjectUuid, InputTower, (PISID)SidToUse, 
                        &ContextHandle, 4L, &Returned, &OutputTower[0], &ErrorStatus);
                }
            else
                {
                ept_map(MapperHandle, ObjectUuid, InputTower, &ContextHandle, 4L,
                        &Returned, &OutputTower[0], &ErrorStatus);
                }
            }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
            ErrorStatus = RpcExceptionCode();
            }
        RpcEndExcept

        if ((NormalizeRetryCount != 0) && (ErrorStatus == EP_S_NOT_REGISTERED))
            {
            ASSERT(AuthInfo);
            ASSERT(AuthInfo->ServerSid);
            ASSERT(AuthInfo->Capabilities & RPC_C_QOS_CAPABILITIES_LOCAL_MA_HINT);
            continue;
            }

        if ( ErrorStatus == RPC_S_SERVER_TOO_BUSY)
           {
           // RPC_S_SERVER_TOO_BUSY can happen only if we successfully
           // established connection. This means the SID was good.
           SidFound = TRUE;

           if (RetryCount < 3)
              {
              RetryCount ++;
              PartialRetries++;
              continue;
              }
           else
              {
              ReallyTooBusy++;
              }

           }

        if ( ErrorStatus != 0 )
            {
            // For DCE interop the endpoint mapper returns DCE errors on the
            // wire.  We need to map some of them to the MS RPC ones.

            // Remove this SPN from our cache in case it is no longer valid, to be safe we will
            // do this for any error code returned from the ep mapper
            if (AuthInfo && (AuthInfo->Capabilities & RPC_C_QOS_CAPABILITIES_LOCAL_MA_HINT))
                {
                (void) RemoveFromSIDCache(AuthInfo->ServerPrincipalName);
                }

            switch (ErrorStatus)
                {
                case EP_S_CANT_PERFORM_OP :
                    RpcStatus = EPT_S_CANT_PERFORM_OP;
                    break;

                case EP_S_NOT_REGISTERED :
                    RpcpErrorAddRecord(EEInfoGCRuntime, 
                        EPT_S_NOT_REGISTERED,
                        EEInfoDLEpResolveEndpoint20,
                        RpcProtocolSequence,
                        NetworkAddress,
                        IfId->SyntaxGUID.Data1,
                        (ULONGLONG)MapperHandle);
                    RpcStatus = EPT_S_NOT_REGISTERED;
                    break;

                default :
                    RpcStatus = MapFromNcaStatusCode(ErrorStatus);
                    break;
                }

            break;
            }

        // we completed one call successfully. Remember it so that we don't
        // normalize the sid again
        SidFound = TRUE;

        // If the received buffer is truncated we may receive no output towers with
        // a non-NULL ContextHandle.  This should not happen without corruption.
        CORRUPTION_ASSERT( ((Returned != 0) || (ContextHandle == 0)) && (Returned <= 4) );

        for (i = 0; i < Returned; i++)
            {
            if (OutputTower[i] == 0)
                {
                ASSERT(!"OutputTower[] contains a NULL element.\n");
                RpcStatus = RPC_S_OUT_OF_MEMORY ;
                break;
                }

            RpcStatus = TowerExplode(
                                 OutputTower[i],
                                 NULL,
                                 NULL,
                                 NULL,
                                 (char PAPI * PAPI *) &EPoint,
                                 NULL
                                 );

            if ( RpcStatus != RPC_S_OK )
                {
                break;
                }

            RpcStatus = nlEndpoint.Attach((char *)EPoint);
            *Endpoint = nlEndpoint;

            I_RpcFree(EPoint);

            if ( *Endpoint == 0 )
                {
                RpcStatus = RPC_S_OUT_OF_MEMORY;
                break;
                }

            EpLookupData->Endpoints[EpLookupData->NumberOfEndpoints] =
                                                                   *Endpoint;

            // We copied the endpoint into the list.  Erase its value so that we do not
            // return a bogus string in case we fail later, for example why exploding the
            // next tower.  The endpoint is a member of DceBinding and should remain NULL
            // on failure.
            *Endpoint = 0;

            EpLookupData->NumberOfEndpoints += 1;
            if ( EpLookupData->NumberOfEndpoints ==
                                             EpLookupData->MaximumEndpoints )
                {
                goto OutsideTheLoop;
                }
            }//..for Loop over parse all towers/eps in this loop

        for (i = 0; i < Returned; i++)
            {
            MIDL_user_free(OutputTower[i]);
            }

        if ( (ContextHandle == 0)  || (RpcStatus != RPC_S_OK) )
            {
            break;
            }
        } //..for loop over get all endpoints

OutsideTheLoop:

    ASSERT( InputTower != 0 );
    I_RpcFree(InputTower);

CleanupAndReturn:

    if ( MapperHandle != 0 )
        {
        RPC_STATUS Status = RpcBindingFree(&MapperHandle);
        ASSERT( Status == RPC_S_OK );
        MapperHandle = 0;
        }

    if ( ContextHandle != 0 )
        {
        RpcSsDestroyClientContext(&ContextHandle);
        ContextHandle = 0;
        }

    if (   ( RpcStatus == EPT_S_NOT_REGISTERED )
        || ( RpcStatus == RPC_S_OK ) )
        {
        if ( EpLookupData->NumberOfEndpoints != 0 )
            {
            *EpLookupHandle = EpLookupData;
            goto ReturnEndpointFromList;
            }
        RpcStatus = EPT_S_NOT_REGISTERED;
        }

    if ( EpLookupData != 0 )
        {
        if ( EpLookupData->Endpoints != 0 )
            {
            while ( EpLookupData->NumberOfEndpoints > 0 )
                {
                EpLookupData->NumberOfEndpoints -= 1;
                delete EpLookupData->Endpoints[EpLookupData->NumberOfEndpoints];
                }
            RpcpFarFree(EpLookupData->Endpoints);
            }
        RpcpFarFree(EpLookupData);
        }

    return(RpcStatus);
}


RPC_STATUS RPC_ENTRY
EpGetEpmapperEndpoint(
    IN OUT RPC_CHAR * PAPI * Endpoint,
    IN RPC_CHAR     PAPI * Protseq
    )
/*+

Routine Description:

    Returns the Endpoint mappers well known endpoint for a given
    protocol sequence.

Arguments:

    Endpoint  - Place to store the epmappers well known endpoint.

    Protsq   - Protocol sequence the client wishes to use.

Return Value:

    RPC_S_OK  - Found the protocol sequence in the epmapper table and
                am returning the associated well known endpoint.

    EPT_S_CANT_PERFORM_OP - Protocol sequence not found.

--*/

{
    RPC_STATUS          Status = EPT_S_CANT_PERFORM_OP;
    RPC_STATUS          rc;
    unsigned            int i, Count;

    if (Protseq != NULL)
        {
        Count = sizeof(EpMapperTable)/sizeof(EpMapperTable[0]);

        for (i = 0; i < Count; i++)
            {

            //Search for the protocol sequence client is using.
            if ( RpcpStringCompare(Protseq, EpMapperTable[i].Protseq) )
                {
                //Not yet found.
                continue;
                }
            else
                {
                //Found a match. Grab the epmapper known endpoint.

                *Endpoint = DuplicateString(EpMapperTable[i].Endpoint);
                if (*Endpoint == NULL)
                    return RPC_S_OUT_OF_MEMORY;
                else
                    {
                    Status = RPC_S_OK;
                    break;
                    }

                }
            } //for
        }//if

    return(Status);

}


RPC_STATUS  RPC_ENTRY
BindToEpMapper(
    OUT RPC_BINDING_HANDLE PAPI * MapperHandle,
    IN RPC_CHAR * NWAddress OPTIONAL,
    IN RPC_CHAR * Protseq OPTIONAL,
    IN RPC_CHAR * Options OPTIONAL,
    IN unsigned ConnTimeout,
    IN ULONG CallTimeout,
    IN CLIENT_AUTH_INFO *AuthInfo OPTIONAL
    )
/*+

Routine Description:

    This helper routine is used to by RpcEpRegister[NoReplace],
    RpcEpUnRegister and EpResolveEndpoint(epclnt.cxx) to bind to
    the EpMapper. If a Protseq is supplied, that particular protseq
    is tried, otherwise lrpc is used to connect to the local epmapper.
    If a NW Address is specified EpMapper at that host is contacted, else
    local Endpoint mapper is used.

Arguments:

    MapperHandle- Returns binding handle to the Endpoint mapper

    NWAddress - NW address of the Endpoint mapper to bind to.
                Ignored if protseq is NULL.

    Protseq   - Protocol sequence the client wishes to use.
                NULL indicates a call to the local endpoint mapper.

    ConnTimeout - the connection timeout

    CallTimeout - the call timeout

    AuthInfo - authentication information for the resolution

Return Value:

    RPC_S_OK - The ansi string was successfully converted into a unicode
        string.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available for the unicode
        string.

    EP_S_CANT_PERFORM_OP - The binding was unsuccessful, possibly because
                           the protocol sequence is not supported.

--*/
{
    RPC_STATUS Status = EPT_S_CANT_PERFORM_OP;
    RPC_CHAR * BindingString = NULL;
    unsigned int i, Count;
    BOOL IsLrpc = FALSE;
    RPC_SECURITY_QOS_V3 RpcSecurityQos;

    ASSERT(EpMapperTable[LrpcEpMapperEntry].ProtocolId == LRPC);

    Count = sizeof(EpMapperTable)/sizeof(EpMapperTable[0]);

    // If Protseq == NULL use lrpc.
    if (NULL == Protseq)
        {
        ASSERT(NWAddress == 0);
        BindingString = RPC_STRING_LITERAL("ncalrpc:[epmapper]");
        IsLrpc = TRUE;
        }
    else
        {
        for (i = 0; i < Count; i++)
            {
            if (RpcpStringCompare(Protseq, EpMapperTable[i].Protseq) )
                continue;

            // Found it.

            // skip the optimization if AuthInfo isn't present
            if (ARGUMENT_PRESENT(AuthInfo))
                {
                // convert local named pipes to use LRPC if necessary
                if (
                    (EpMapperTable[i].ProtocolId == NMP) 
                    && 
                    (
                     (NWAddress == NULL)
                     ||
                     (AuthInfo->Capabilities & RPC_C_QOS_CAPABILITIES_LOCAL_MA_HINT)
                    )
                   )
                    {
                    // move directly to the endpoint mapper entry for LRPC
                    i = LrpcEpMapperEntry;
                    }
                }

            IsLrpc = (EpMapperTable[i].ProtocolId == LRPC);

            Status = RpcStringBindingCompose( NULL,
                                              EpMapperTable[i].Protseq,
                                              NWAddress,
                                              EpMapperTable[i].Endpoint,
                                              (EpMapperTable[i].ProtocolId == HTTP ? Options : 0),
                                              &BindingString);
            break;
            }
        }

    if (BindingString)
       {
       Status = RpcBindingFromStringBinding(BindingString, MapperHandle);
       }

    if (BindingString != NULL && Protseq != NULL)
       {
       RpcStringFree(&BindingString);
       }

    if (Status != RPC_S_OK)
       {
       return(EPT_S_CANT_PERFORM_OP);
       }

    if (AuthInfo && (RpcpStringNCompare(Protseq, RPC_STRING_LITERAL("ncacn_"), 6) == 0))
        {
        Status = SetAuthInformation (*MapperHandle, AuthInfo);

        if (Status != RPC_S_OK)
            return Status;
        }
    else if (IsLrpc)
        {
        // mutually authenticate the endpoint mapper for LRPC
        RpcSecurityQos.Version = RPC_C_SECURITY_QOS_VERSION_3;
        RpcSecurityQos.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
        RpcSecurityQos.IdentityTracking = RPC_C_QOS_IDENTITY_STATIC;
        RpcSecurityQos.Capabilities 
            = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
        RpcSecurityQos.AdditionalSecurityInfoType = 0;
        RpcSecurityQos.u.HttpCredentials = NULL;
        RpcSecurityQos.Sid = (PVOID)&LocalSystem;
        Status = RpcBindingSetAuthInfoEx (*MapperHandle,
            NULL,
            RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
            RPC_C_AUTHN_WINNT,
            NULL,   // AuthIdentity
            NULL,   // AuthzSvc
            (RPC_SECURITY_QOS *)&RpcSecurityQos
            );

        if (Status != RPC_S_OK)
           {
           RpcBindingFree(MapperHandle);
           return(EPT_S_CANT_PERFORM_OP);
           }
        }

    Status = RpcMgmtSetComTimeout(*MapperHandle, ConnTimeout);

    if (Status != RPC_S_OK)
       {
       RpcBindingFree(MapperHandle);
       return(EPT_S_CANT_PERFORM_OP);
       }

    Status = RpcBindingSetOption(*MapperHandle,
        RPC_C_OPT_CALL_TIMEOUT,
        CallTimeout);
    if (Status != RPC_S_OK)
       {
       RpcBindingFree(MapperHandle);
       return(Status);
       }


    return(RPC_S_OK);
}

void RPC_ENTRY
EpFreeLookupHandle (
    IN void PAPI * EpLookupHandle
    )
{
    EP_LOOKUP_DATA PAPI * EpLookupData = (EP_LOOKUP_DATA PAPI *) EpLookupHandle;

    if ( EpLookupData->Endpoints != 0 )
        {
        while ( EpLookupData->NumberOfEndpoints > 0 )
            {
            EpLookupData->NumberOfEndpoints -= 1;
            delete EpLookupData->Endpoints[EpLookupData->NumberOfEndpoints];
            }
        RpcpFarFree(EpLookupData->Endpoints);
        }
    RpcpFarFree(EpLookupData);
}

HPROCESS hRpcssContext = 0;

RPC_STATUS RPC_ENTRY
I_RpcServerAllocateIpPort(
    IN DWORD Flags,
    OUT USHORT *pPort
    )
{
    USHORT Port;
    RPC_STATUS status;
    RPC_BINDING_HANDLE hServer;
    PORT_TYPE type;
    RPC_SECURITY_QOS_V3 RpcSecurityQos;

    *pPort = 0;

    // Figure out what sort of port to allocate

    if (Flags & RPC_C_USE_INTERNET_PORT)
        {
        type = PORT_INTERNET;
        Flags &= ~RPC_C_USE_INTERNET_PORT;
        }
    else if (Flags & RPC_C_USE_INTRANET_PORT)
        {
        type = PORT_INTRANET;
        Flags &= ~RPC_C_USE_INTRANET_PORT;
        }
    else
        {
        type = PORT_DEFAULT;
        }

    // Setup process context in the endpoint mapper if needed.

    if (hRpcssContext == 0)
        {
        HPROCESS hProcess;

        status = RpcBindingFromStringBinding(RPC_STRING_LITERAL("ncalrpc:[epmapper]"),
                                              &hServer);
        if (status != RPC_S_OK)
            {
            return(status);
            }

        // mutually authenticate the endpoint mapper
        RpcSecurityQos.Version = RPC_C_SECURITY_QOS_VERSION_3;
        RpcSecurityQos.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
        RpcSecurityQos.IdentityTracking = RPC_C_QOS_IDENTITY_STATIC;
        RpcSecurityQos.Capabilities 
            = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
        RpcSecurityQos.AdditionalSecurityInfoType = 0;
        RpcSecurityQos.u.HttpCredentials = NULL;
        RpcSecurityQos.Sid = (PVOID)&LocalSystem;
        status = RpcBindingSetAuthInfoEx (hServer,
            (RPC_CHAR *)&LocalSystem,
            RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
            RPC_C_AUTHN_WINNT,
            NULL,   // AuthIdentity
            NULL,   // AuthzSvc
            (RPC_SECURITY_QOS *)&RpcSecurityQos
            );

        if (status != RPC_S_OK)
           {
           return(status);
           }

        hProcess = 0;

        status = OpenEndpointMapper(hServer,
                                    &hProcess);

        RPC_STATUS statust =
        RpcBindingFree(&hServer);
        ASSERT(statust == RPC_S_OK);

        if (status != RPC_S_OK)
            {
            return(status);
            }

        GlobalMutexRequest();

        if (hRpcssContext != 0)
            {
            ASSERT(hRpcssContext != hProcess);
            RpcSmDestroyClientContext(&hProcess);
            }
        else
            {
            hRpcssContext = hProcess;
            }

        GlobalMutexClear();
        }

    // Actually allocate a port.

    RPC_STATUS allocstatus;

    status = AllocateReservedIPPort(hRpcssContext,
                                    type,
                                    &allocstatus,
                                    pPort);

    if (status != RPC_S_OK)
        {
        ASSERT(*pPort == 0);
        return(status);
        }

    return(allocstatus);
}

// Very special code for our older (NT 3.1 Era) servers.
//
// These server send out unique pointers which will confuse our
// stubs while unmarshalling.  Here we go through and fixup the
// node id's to look like full pointers.
//
// This code can be removed when support for NT 3.1 era servers
// is no longer required.

extern "C"
void FixupForUniquePointerServers(PRPC_MESSAGE pMessage)
{
    int CurrentPointer = 3;
    unsigned int NumberOfPointers;
    unsigned int i;
    unsigned long __RPC_FAR *pBuffer;

    pBuffer = (unsigned long __RPC_FAR *) pMessage->Buffer;

    // The output buffer looks like:

    // [ out-context handle (20b) ]
    // [ count (4b) ]
    // [ max (4b) ]
    // [ min (4b) ]
    // [ length (4b) ]      // should be the same as count
    // [ pointer node (count of them) ]

    ASSERT(pBuffer[5] == pBuffer[8]);

    NumberOfPointers = pBuffer[5];

    ASSERT(pMessage->BufferLength >= 4 * 9 + 4 * NumberOfPointers);

    for(i = 0; i < NumberOfPointers; i++)
        {
        if (pBuffer[9 + i] != 0)
            {
            pBuffer[9 + i] = CurrentPointer;
            CurrentPointer++;
            }
        }

    return;
}

#if defined(WIN) || defined(WIN32)

void __RPC_FAR * __RPC_API
MIDL_user_allocate(
       size_t  Size
      )
/*++

Routine Description:

    MIDL generated stubs need this routine.

Arguments:

    Size - Supplies the length of the memory to allocate in bytes.

Return Value:

    The buffer allocated will be returned, if there is sufficient memory,
    otherwise, zero will be returned.

--*/
{
    void PAPI * pvBuf;

    pvBuf = I_RpcAllocate(Size);

    return(pvBuf);
}

void __RPC_API
MIDL_user_free (
         void __RPC_FAR *Buf
         )
{

    I_RpcFree(Buf);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\hashtabl.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       hashtabl.cxx
//
//--------------------------------------------------------------------------

/*++

Module Name:

    hashtabl.cxx

Abstract:



Author:

    Jeff Roberts (jroberts)  9-Nov-1994

Revision History:

     9-Nov-1994     jroberts

        Created this module.

--*/

#include <precomp.hxx>
#include "hashtabl.hxx"


UUID_HASH_TABLE::UUID_HASH_TABLE(
    RPC_STATUS * pStatus,
    unsigned long SpinCount
    )
/*++

Routine Description:



Arguments:



Return Value:



Exceptions:



--*/
{
    unsigned u;
    for (u = 0; u < BUCKET_COUNT; ++u)
        {
#ifdef DEBUGRPC
        Counts[u] = 0;
#endif
        Buckets[u] = 0;
        }

    //
    // Allocate bucket mutexes.  If one or more fail to initialize,
    // continue anyway so that the pointer is valid for all 'u'.
    // They will be deleted in the destructor.
    // BUBUG this modification needs testing
    //
    for (u = 0; u < MUTEX_COUNT; ++u)
        {
        BucketMutexes[u] = new MUTEX(pStatus);
        if ((BucketMutexes[u] == NULL) || (*pStatus))
            {
            if (BucketMutexes[u] == NULL)
                *pStatus = RPC_S_OUT_OF_MEMORY;
            }
        else
            {
            BucketMutexes[u]->SetSpinCount(SpinCount);
            }
        }
}


UUID_HASH_TABLE::~UUID_HASH_TABLE(
    )
{
    unsigned u;
    for (u = 0; u < MUTEX_COUNT; ++u)
        {
        delete BucketMutexes[u];
        }
}


unsigned
UUID_HASH_TABLE::Add(
    UUID_HASH_TABLE_NODE * pNode,
    unsigned Hash
    )
{
    if (Hash == NO_HASH)
        {
        Hash = MakeHash(&pNode->Uuid);
        }

    ASSERT( Hash < BUCKET_COUNT );

    if (Buckets[Hash])
        {
        ASSERT(Buckets[Hash]->pPrev == 0);
        }

#ifdef DEBUGRPC

    BOOL Seen = FALSE;
    unsigned Count = 0;
    UUID_HASH_TABLE_NODE * pScan = Buckets[Hash];
    while (pScan)
        {
        ++Count;
        ASSERT(Count <= Counts[Hash]);

        if (pScan == pNode)
            {
            Seen = TRUE;
            }

        if (pScan->pNext)
            {
            ASSERT(pScan->pNext->pPrev == pScan);
            }

        pScan = pScan->pNext;
        }

    ASSERT(!Seen);
    ASSERT(Count == Counts[Hash]);

    ++Counts[Hash];

#endif

    pNode->pPrev = 0;
    pNode->pNext = Buckets[Hash];
    Buckets[Hash] = pNode;

    if (pNode->pNext)
        {
        pNode->pNext->pPrev = pNode;
        }
    return Hash;
}


void
UUID_HASH_TABLE::Remove(
    UUID_HASH_TABLE_NODE * pNode,
    unsigned Hash
    )
{
    if (Hash == NO_HASH)
        {
        Hash = MakeHash(&pNode->Uuid);
        }

    ASSERT( Hash < BUCKET_COUNT );

#ifdef DEBUGRPC

    BOOL Seen = FALSE;
    unsigned Count = 0;
    UUID_HASH_TABLE_NODE * pScan = Buckets[Hash];
    while (pScan)
        {
        ++Count;
        ASSERT(Count <= Counts[Hash]);

        if (pScan == pNode)
            {
            Seen = TRUE;
            }

        if (pScan->pNext)
            {
            ASSERT(pScan->pNext->pPrev == pScan);
            }

        pScan = pScan->pNext;
        }

    ASSERT(Seen);
    ASSERT(Count == Counts[Hash]);

    --Counts[Hash];

#endif

    ASSERT(pNode->pPrev != pNode);
    ASSERT(pNode->pNext != pNode);

    if (pNode->pPrev != 0)
        {
        ASSERT(pNode->pPrev->pNext == pNode);
        pNode->pPrev->pNext = pNode->pNext;
        }
    else
        {
        ASSERT(Buckets[Hash] == pNode);
        Buckets[Hash] = pNode->pNext;
        }

    if (pNode->pNext != 0)
        {
        ASSERT(pNode->pNext->pPrev == pNode);
        pNode->pNext->pPrev = pNode->pPrev;
        }

#ifdef DEBUGRPC

    pNode->pPrev = INVALID_NODE;
    pNode->pNext = INVALID_NODE;

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\gc.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    GC.cxx

Abstract:

    The garbage collection mechanism common code. See the comment
    below for more details.

Author:

    Kamen Moutafov (kamenm)   Apr 2000

Garbage Collection Mechanism:
    This comment describes how the garbage collection mechanism works.
    The code itself is spread in variety in places.

    Purpose:
    There are two types of garbage collection we perform - periodic
    and one-time. Periodic may be needed by the Osf idle connection
    cleanup mechanism, which tries to cleanup unused osf connections
    if the app explicitly asked for it via RpcMgmtEnableIdleCleanup.
    The one-time cleanup is used by the lingering associations. If
    an association is lingered, it will request cleanup to be performed
    after a certain period of time. The garbage collection needs to
    support both of those mechanisms.

    Design Goals:
    Have minimal memory and CPU consumption requirements
    Don't cause periodic background activity if there is no
    garbage collection to be performed.
    Guarantee that garbage collection will be performed in
    a reasonable amount of time after its request time (i.e. 10 minutes
    to an hour at worst case)

    Implementation:
    We use the worker threads in the thread pools to perform garbage
    collection. There are several thread pools - the Ioc thread pool
    (remote threads) as well as one thread pool for each LRPC address.
    Within each pool, from a gc perspective, we differentiate between
    two types of threads - threads on a short wait and threads on a
    long wait. Threads on a short wait are either threads waiting for
    something to happen with a timeout of gThreadTimeout or less, or
    threads performing a work item (threads doing both are also
    considered to be on a short wait). Threads on a long wait are
    threads waiting for more than that. As part of our thread management
    we will keep count of how many threads are on a short wait and how
    many are on a long wait.

    All threads in all thread pools will attempt to do garbage collection 
    when they timeout waiting for something to happen. Since all thread pools 
    need at least one listening thread, all thread pools are guaranteed to 
    have a thread timing out once every so often. The garbage collection attempt 
    will be cut very short if there is nothing to garbage collect, so the
    attempt is not performance expensive in the common case. The function
    to attempt garbage collection is PerformGarbageCollection

    If a thread times out on the completion port/LPC port, it will
    do garbage collection, and then will check whether there are
    more items to garbage collect (either one-time or periodic) and how
    many threads from this thread pool are on a short wait. If there is
    garbage collection to be done, and there are no other threads on short
    wait, this thread will not go on a long wait, but it will repeat its
    short wait. This ensures timely garbage collection. If all the threads
    have gone on a long wait, and a piece of code needs garbage collection,
    it will request the garbage collection and it will tickle a worker thread.
    The tickling consist of posting an empty message to the completion port
    or LPC port. All the synchronization b/n worker threads and threads
    requesting garbage collection is done using interlocks, to avoid perf
    hit. This introduces a couple of benign races through the code, which may
    prevent a thread from going on a long wait once, but that's ok.

    In order to ensure that we do gc only when needed, in most cases we refcount 
    the number of items that need garbage collection.

--*/

#include <precomp.hxx>
#include <hndlsvr.hxx>
#include <lpcpack.hxx>
#include <lpcsvr.hxx>
#include <osfpcket.hxx>
#include <bitset.hxx>
#include <queue.hxx>
#include <ProtBind.hxx>
#include <osfclnt.hxx>
#include <rpcqos.h>
#include <lpcclnt.hxx>

// used by periodic cleanup only - the period
// on which to do cleanup. This is in seconds
unsigned long WaitToGarbageCollectDelay = 0;

// The number of items on which garbage collection
// is needed. If 0, no periodic garbage collection
// is necessary. Each item that needs garbage collection
// will InterlockIncrement this when it is created,
// and will InterlockDecrement this when it is destroyed
long PeriodicGarbageCollectItems = 0;

// set non-zero when we need to cleanup idle LRPC_SCONTEXTs
unsigned int fEnableIdleLrpcSContextsCleanup = 0;

// set to non-zero when we enable garbage collection cleanup. This either
// happens when the user calls it explicitly with 
// RpcMgmtEnableIdleCleanup or implicitly if we gather too many 
// connection in an association
unsigned int fEnableIdleConnectionCleanup = 0;

unsigned int IocThreadStarted = 0;

// used by one-time garbage collection items only!
long GarbageCollectionRequested = 0;

// The semantics of this variable should be
// interpreted as follows - don't bother to cleanup
// before this time stamp - you won't find anything.
// This means that after this interval, there may be
// many items to cleanup later on - it just says the
// first is at this time.
// The timestamp is in millseconds. 
DWORD NextOneTimeCleanup = 0;


const int MaxPeriodsWithoutGC = 100;


BOOL
GarbageCollectionNeeded (
    IN BOOL fOneTimeCleanup,
    IN unsigned long GarbageCollectInterval
    )
/*++

Routine Description:

    A routine used by code throughout RPC to arrange
    for garbage collection to be performed. Currently,
    there are two types of garbage collecting -
    idle Osf connections and lingering associations.

Parameters:
    fOneTimeCleanup - if non-zero, this is a one time
    cleanup and GarbageCollectInterval is interpreted as the 
    minimum time after which we want garbage collection 
    performed. Note that the garbage collection code can kick
    off earlier than that. Appropriate arrangements must be
    made to protect items not due for garbage collection.
    If 0, this is a periodic cleanup, and 

    GarbageCollectInterval is interpreted as the period for
    which we wait before making the next garbage collection
    pass. Note that for the periodic cleanup, this is a hint 
    that can be ignored - don't count on it. The time is in
    milliseconds.

Return Value:
    non-zero - garbage collection is available and will be done
    FALSE - garbage collection is not available

--*/
{
    RPC_STATUS RpcStatus = RPC_S_OK;
    THREAD * Thread;
    DWORD LocalTickCount;
    LOADABLE_TRANSPORT *LoadableTransport;
    LOADABLE_TRANSPORT *FirstTransport = NULL;
    DictionaryCursor cursor;
    BOOL fRetVal = FALSE;
    LRPC_ADDRESS *CurrentAddress;
    LRPC_ADDRESS *LrpcAddressToTickle = NULL;

    if (fOneTimeCleanup)
        {
        LocalTickCount = GetTickCount();
        // N.B. There is a race here where two threads can set this -
        // the race is benign - the second thread will win and write
        // its time, which by virtue of the small race window will
        // be shortly after the first thread
        if (!GarbageCollectionRequested)
            {
            NextOneTimeCleanup = LocalTickCount + GarbageCollectInterval;
            GarbageCollectionRequested = 1;
#if defined (RPC_GC_AUDIT)
            DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) GC requested - tick count %d\n",
                GetCurrentProcessId(), GetCurrentProcessId(), LocalTickCount);
#endif

            }
        }
    else
        {
        // WaitToGarbageCollectDelay is a global variable - avoid sloshing
        if (WaitToGarbageCollectDelay == 0)
            WaitToGarbageCollectDelay = GarbageCollectInterval;

        InterlockedIncrement(&PeriodicGarbageCollectItems);
        }

    // is the completion port started? If yes, we will use it as the
    // preferred method of garbage collection
    if (IocThreadStarted)
        {
        // if we use the completion port, we either need a thread on a
        // short wait (i.e. it will perform garbage collection soon
        // anyway), or we need to tickle a thread on a long wait. We know
        // that one of these will be true, because we always keep
        // listening threads on the completion port - the only
        // question is whether it is on a long or short wait thread that
        // we have.

        // this dictionary is guaranteed to never grow beyond the initial
        // dictionary size and elements from it are never deleted - therefore, 
        // it is safe to iterate it without holding a mutex - we may miss
        // an element if it was just being added, but that's ok. The important
        // thing is that we can't fault
        LoadedLoadableTransports->Reset(cursor);
        while ((LoadableTransport
                = LoadedLoadableTransports->Next(cursor)) != 0)
            {

            if (LoadableTransport->GetThreadsDoingShortWait() > 0)
                {
#if defined (RPC_GC_AUDIT)
                DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Thread %X: there are Ioc threads on short wait - don't tickle\n",
                    GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId());
#endif
                // there is a transport with threads on short wait
                // garbage collection will be performed soon even without
                // our help - we can bail out
                FirstTransport = NULL;
                fRetVal = TRUE;
                break;
                }

            if (FirstTransport == NULL)
                FirstTransport = LoadableTransport;

            }
        }
    else if (LrpcAddressList 
        && (((RTL_CRITICAL_SECTION *)(NtCurrentPeb()->LoaderLock))->OwningThread != NtCurrentTeb()->ClientId.UniqueThread))
        {

        LrpcMutexRequest();

        // else, if there are Lrpc Addresses, check whether they are doing short wait
        // and can gc for us
        CurrentAddress = LrpcAddressList;
        while (CurrentAddress)
            {
            // can this address gc for us?
            if (CurrentAddress->GetNumberOfThreadsDoingShortWait() > 0)
                {
#if defined (RPC_GC_AUDIT)
                DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Thread %X: there are threads on short wait (%d) on address %X - don't tickle\n",
                    GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId(), CurrentAddress,
                    CurrentAddress->GetNumberOfThreadsDoingShortWait());
#endif
                LrpcAddressToTickle = NULL;
                fRetVal = TRUE;
                break;
                }

            if ((LrpcAddressToTickle == NULL) && (CurrentAddress->IsPreparedForLoopbackTickling()))
                {
                LrpcAddressToTickle = CurrentAddress;
                }
            CurrentAddress = CurrentAddress->GetNextAddress();
            }

        // N.B. It is possible that Osf associations need cleanup, but only LRPC worker
        // threads are available, and moreover, no LRPC associations were created, which
        // means none of the Lrpc addresses is prepared for loopback tickling. If this is
        // the case, choose the first address, and make sure it is prepared for tickling
        if ((LrpcAddressToTickle == NULL) && (fRetVal == FALSE))
            {
            LrpcAddressToTickle = LrpcAddressList;

            // prepare the selected address for tickling
            fRetVal = LrpcAddressToTickle->PrepareForLoopbackTicklingIfNecessary();
            if (fRetVal == FALSE)
                {
                // if this fails, zero out the address for tickling. This
                // will cause this function to return failure
                LrpcAddressToTickle = NULL;
                }
            }

        LrpcMutexClear();
        }
    else if (fEnableIdleConnectionCleanup)
        {
        // if fEnableIdleConnectionCleanup is set, we have to create a thread if there is't one yet
        RpcStatus = CreateGarbageCollectionThread();
        if (RpcStatus == RPC_S_OK)
            {
            // the thread creation was successful - tell our caller we
            // will be doing garbage collection
            fRetVal = TRUE;
            }
        }

    // neither Ioc nor the LRPC thread pools have threads on short wait
    // We have to tickle somebody - we try the Ioc thread pool first
    if (FirstTransport)
        {
        // we couldn't find any transport with threads on short wait -
        // tickle a thread from the RPC transport in order to ensure timely
        // cleanup
#if defined (RPC_GC_AUDIT)
        DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Thread %X: No Ioc threads on short wait found - tickling one\n",
            GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId());
#endif
        RpcStatus = TickleIocThread();
        if (RpcStatus == RPC_S_OK)
            fRetVal = TRUE;
        }
    else if (LrpcAddressToTickle)
        {
        // try to tickle the LRPC address
        fRetVal = LrpcAddressToTickle->LoopbackTickle();
        }

    return fRetVal;
}

RPC_STATUS CreateGarbageCollectionThread (
    void
    )
/*++

Routine Description:

    Make a best effort to create a garbage collection thread. In this
    implementation we simply choose to create a completion port thread,
    as it has many uses.

Return Value:

    RPC_S_OK on success or RPC_S_* on error

--*/
{
    TRANS_INFO *TransInfo;
    RPC_STATUS RpcStatus;

    if (IsGarbageCollectionAvailable())
        return RPC_S_OK;

    RpcStatus = LoadableTransportInfo(L"rpcrt4.dll", 
        L"ncacn_ip_tcp",
        &TransInfo);

    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    RpcStatus = TransInfo->CreateThread();

    return RpcStatus;
}


RPC_STATUS
EnableIdleConnectionCleanup (
    void
    )
/*++

Routine Description:

    We need to enable idle connection cleanup.

Return Value:

    RPC_S_OK - This value will always be returned.

--*/
{
    fEnableIdleConnectionCleanup = 1;

    return(RPC_S_OK);
}


RPC_STATUS
EnableIdleLrpcSContextsCleanup (
    void
    )
/*++

Routine Description:

    We need to enable idle LRPC SContexts cleanup.

Return Value:

    RPC_S_OK - This value will always be returned.

--*/
{
    // this is a global variable - prevent sloshing
    if (fEnableIdleLrpcSContextsCleanup == 0)
        fEnableIdleLrpcSContextsCleanup = 1;

    return(RPC_S_OK);
}


long GarbageCollectingInProgress = 0;
DWORD LastCleanupTime = 0;


void
PerformGarbageCollection (
    void
    )
/*++

Routine Description:

    This routine should be called periodically so that each protocol
    module can perform garbage collection of resources as necessary.

--*/
{
    DWORD LocalTickCount;
    DWORD Diff;

#if defined (RPC_GC_AUDIT)
    DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Thread %X: trying to garbage collect\n",
        GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId());
#endif
    if (InterlockedIncrement(&GarbageCollectingInProgress) > 1)
        {
        //
        // Don't need more than one thread garbage collecting
        //
#if defined (RPC_GC_AUDIT)
        DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Thread %X: beaten to GC - returning\n",
            GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId());
#endif
        InterlockedDecrement(&GarbageCollectingInProgress);
        return;
        }

    if ((fEnableIdleConnectionCleanup || fEnableIdleLrpcSContextsCleanup) && PeriodicGarbageCollectItems)
        {
        LocalTickCount = GetTickCount();
        // make sure we don't cleanup too often - this is unnecessary
        if (LocalTickCount - LastCleanupTime > WaitToGarbageCollectDelay)
            {
            LastCleanupTime = LocalTickCount;
#if defined (RPC_GC_AUDIT)
            DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Thread %X: Doing periodic garbage collection\n",
                GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId());
#endif

            // the periodic cleanup
            if (fEnableIdleLrpcSContextsCleanup)
                {
                GlobalRpcServer->EnumerateAndCallEachAddress(RPC_SERVER::actCleanupIdleSContext,
                    NULL);
                }

            if (fEnableIdleConnectionCleanup)
                {
                OSF_CCONNECTION::OsfDeleteIdleConnections();
                }
            }
        else
            {
#if defined (RPC_GC_AUDIT)
            DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Thread %X: Too soon for periodic gc - skipping (%d, %d)\n",
                GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId(), LocalTickCount,
                LastCleanupTime);
#endif
            }
        }

    if (GarbageCollectionRequested)
        {
        LocalTickCount = GetTickCount();

        Diff = LocalTickCount - NextOneTimeCleanup;
        if ((int)Diff >= 0)
            {
#if defined (RPC_GC_AUDIT)
            DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Thread %X: Doing one time gc\n",
                GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId());
#endif
            // assume the garbage collection will succeed. If it doesn't, the
            // functions called below have the responsibility to re-raise the flag
            // Note that there is a race condition where they may fail, but when
            // the flag was down, a thread went on a long wait. This again is ok,
            // because the current thread will figure out there is more garbage
            // collection to be done, because the flag is raised, and will do
            // a short wait. In worst case, the gc may be delayed because this
            // thread will pick a work item, and won't spawn another thread,
            // because there is already a thread in the IOCP, which is doing a
            // long wait. This may delay the gc from short to long wait. This is
            // Ok as it is in accordance with our design goals.
            GarbageCollectionRequested = 0;

            OSF_CASSOCIATION::OsfDeleteLingeringAssociations();
            LRPC_CASSOCIATION::LrpcDeleteLingeringAssociations();
            }
        else
            {
#if defined (RPC_GC_AUDIT)
            DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Thread %X: Too soon for one time gc - skipping (%d)\n",
                GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId(), (int)Diff);
#endif
            }
        }

    GarbageCollectingInProgress = 0;
}

BOOL
CheckIfGCShouldBeTurnedOn (
    IN ULONG DestroyedAssociations,
    IN const ULONG NumberOfDestroyedAssociationsToSample,
    IN const long DestroyedAssociationBatchThreshold,
    IN OUT ULARGE_INTEGER *LastDestroyedAssociationsBatchTimestamp
    )
/*++

Routine Description:

    Checks if it makes sense to turn on garbage collection
    for this process just for the pruposes of having
    association lingering available.

Parameters:
    DestroyedAssociations - the number of associations destroyed
    for this process so far (Osf and Lrpc may keep a separate 
    count)
    NumberOfDestroyedAssociationsToReach - how many associations
    it takes to destroy for gc to be turned on
    DestroyedAssociationBatchThreshold - the time interval for which
    we have to destroy NumberOfDestroyedAssociationsToReach in
    order for gc to kick in
    LastDestroyedAssociationsBatchTimestamp - the timestamp when
    we made the last check

Return Value:
    non-zero - GC should be turned on
    FALSE - GC is either already on, or should not be turned on

--*/
{
    FILETIME CurrentSystemTimeAsFileTime;
    ULARGE_INTEGER CurrentSystemTime;
    BOOL fEnableGarbageCollection;

    if (IsGarbageCollectionAvailable() 
        || ((DestroyedAssociations % NumberOfDestroyedAssociationsToSample) != 0))
        {
        return FALSE;
        }

    fEnableGarbageCollection = FALSE;

    GetSystemTimeAsFileTime(&CurrentSystemTimeAsFileTime);
    CurrentSystemTime.LowPart = CurrentSystemTimeAsFileTime.dwLowDateTime;
    CurrentSystemTime.HighPart = CurrentSystemTimeAsFileTime.dwHighDateTime;
    if (LastDestroyedAssociationsBatchTimestamp->QuadPart != 0)
        {
#if defined (RPC_GC_AUDIT)
        ULARGE_INTEGER Temp;
        Temp.QuadPart = CurrentSystemTime.QuadPart - LastDestroyedAssociationsBatchTimestamp->QuadPart;
        DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) LRPC time stamp diff: %X %X\n",
            GetCurrentProcessId(), GetCurrentProcessId(), Temp.HighPart, Temp.LowPart);
#endif
        if (CurrentSystemTime.QuadPart - LastDestroyedAssociationsBatchTimestamp->QuadPart <= 
            DestroyedAssociationBatchThreshold)
            {
            // we have destroyed plenty (NumberOfDestroyedAssociationsToSample) of
            // associations for less than DestroyedAssociationBatchThreshold
            // this process will probably benefit from garbage collection turned on as it
            // does a lot of binds. Return so to the caller
            fEnableGarbageCollection = TRUE;
            }
        }
#if defined (RPC_GC_AUDIT)
    else
        {
        DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Time stamp is 0 - set it\n",
            GetCurrentProcessId(), GetCurrentProcessId());
        }
#endif

    LastDestroyedAssociationsBatchTimestamp->QuadPart = CurrentSystemTime.QuadPart;

    return fEnableGarbageCollection;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\handle.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1990 - 1999
//
//  File:       handle.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

              Microsoft OS/2 LAN Manager
           Copyright(c) Microsoft Corp., 1990

-------------------------------------------------------------------- */
/* --------------------------------------------------------------------

File: handle.cxx

Description:

The actual code for all of the classes specified by handle.hxx is
contained in this file.  These routines are independent of the actual RPC
protocol / transport layer.  In addition, these routines are also
independent of the specific operating system in use.

History :

mikemon    ??-??-??    First bit in the bucket.
mikemon    12-28-90    Cleaned up the comments.

    Kamen Moutafov (KamenM) Dec 99 - Feb 2000 - Support for cell debugging stuff

-------------------------------------------------------------------- */

#include <precomp.hxx>
#include <epmap.h>
#include <rpccfg.h>

#include <dispatch.h>
#include <crypt.h>
#include <charconv.hxx>
#include <lmcons.h>
#include <ntlsa.h>
#include <lmerr.h>
#include <secobj.h>
#undef UNUSED       // netlib also defined UNUSED, but doesn't protect it with #ifndef
                    // Undef it here so that netlib compiles
#include <netlib.h>

extern unsigned  DefaultMaxDatagramLength = DEFAULT_MAX_DATAGRAM_LENGTH;
extern unsigned  DefaultConnectionBufferLength = DEFAULT_CONNECTION_BUFFER_LENGTH;

/*

   A helper routine to capture the logon ID of this thread, if it is
   impersonating another process.

   Routine returns RPC_S_OK on success. If the process is not impersonating,
   but running under its own process identity, this routine will fail.

   All failures, currently, get treated as if the thread is not impersonating

*/

RPC_STATUS
GetTokenStats(TOKEN_STATISTICS *pTokenStats)
{
    BOOL Result;
    HANDLE Handle;
    unsigned long Size;

    Result = OpenThreadToken(
                 GetCurrentThread(),
                 TOKEN_READ,
                 TRUE,
                 &Handle
                 );

    if (Result != TRUE)
        {
        return (GetLastError());
        }

    Result = GetTokenInformation(
                 Handle,
                 TokenStatistics,
                 pTokenStats,
                 sizeof(TOKEN_STATISTICS),
                 &Size
                 );

    CloseHandle(Handle);
    if (Result != TRUE)
        {
        return (GetLastError());
        }

    return RPC_S_OK;
}

RPC_STATUS
CaptureModifiedId(
    LUID * ModifiedId
    )
{
    TOKEN_STATISTICS TokenStatisticsInformation;
    RPC_STATUS Status;

    Status = GetTokenStats(&TokenStatisticsInformation);
    if (Status != RPC_S_OK)
        {
        return Status;
        }

    RpcpMemoryCopy(ModifiedId,
        &TokenStatisticsInformation.ModifiedId, sizeof(LUID));

    return (RPC_S_OK);
}

void WipeOutAuthIdentity (
    IN SEC_WINNT_AUTH_IDENTITY_W *AuthIdentity
    )
/*++

Routine Description:

    Wipes out the important parts of an auth identity structure.
    Works on encrypted and decrypted identities.

Arguments:

    AuthIdentity - the auth identity to wipe out.

Return Value:

--*/
{
    if (AuthIdentity == NULL)
        return;

    if (AuthIdentity->User != NULL)
        {
        RpcpMemorySet(AuthIdentity->User, 0, AuthIdentity->UserLength * sizeof(RPC_CHAR));
        }

    if (AuthIdentity->Domain != NULL)
        {
        RpcpMemorySet(AuthIdentity->Domain, 0, AuthIdentity->DomainLength * sizeof(RPC_CHAR));
        }

    if (AuthIdentity->Password != NULL)
        {
        RpcpMemorySet(AuthIdentity->Password, 0, AuthIdentity->PasswordLength * sizeof(RPC_CHAR));
        }
}

// if RTL_ENCRYPT_MEMORY_SIZE gets changed, the padding logic below
// must get changed also
C_ASSERT(RTL_ENCRYPT_MEMORY_SIZE == 8);

RPC_CHAR *
ReallocAndPad8IfNeccessary (
    IN RPC_CHAR *OldBuffer,
    IN OUT ULONG *Length
    )
/*++

Routine Description:

    Encrypts the important parts of an auth identity structure.
    On success, if reallocation was done, the old buffer is deleted.

Arguments:

    OldBuffer - the old, unpadded buffer

    Length - on input, the length of the old unpadded buffer in characters without
        the terminating null. On output the length of the encrypted buffer with
        padding. Unmodified on failure.

Return Value:

    The new buffer (may be the same as the old) or NULL if there is
    insufficient memory.

--*/
{
    ULONG NewLength;
    ULONG InputLength = *Length;
    RPC_CHAR *NewBuffer;
    
    NewLength = Align8(InputLength);
    if (NewLength == InputLength)
        {
        *Length = NewLength;
        return OldBuffer;
        }

    NewBuffer = new RPC_CHAR[NewLength + 1];
    if (NewBuffer == NULL)
        return NULL;

    RpcpMemoryCopy(NewBuffer, OldBuffer, (InputLength + 1) * sizeof(RPC_CHAR));

    // wipe out the old buffer before freeing it
    RpcpMemorySet(OldBuffer, 0, (InputLength + 1) * sizeof(RPC_CHAR));
    delete [] OldBuffer;

    *Length = NewLength;

    return NewBuffer;
}

RPC_STATUS EncryptAuthIdentity (
    IN SEC_WINNT_AUTH_IDENTITY_W *AuthIdentity
    )
/*++

Routine Description:

    Encrypts the important parts of an auth identity structure.

Arguments:

    AuthIdentity - the auth identity to encrypt.

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    RPC_STATUS RpcStatus;
    NTSTATUS NtStatus;

    if (AuthIdentity->User != NULL)
        {
        AuthIdentity->User = ReallocAndPad8IfNeccessary(AuthIdentity->User,
            &AuthIdentity->UserLength
            );
        if (AuthIdentity->User == NULL)
            {
            WipeOutAuthIdentity(AuthIdentity);
            return RPC_S_OUT_OF_MEMORY;
            }

        NtStatus = RtlEncryptMemory(AuthIdentity->User,
            AuthIdentity->UserLength * sizeof(RPC_CHAR),
            0);

        if (!NT_SUCCESS(NtStatus))
            {
            ASSERT(NtStatus != STATUS_INVALID_PARAMETER);
            WipeOutAuthIdentity(AuthIdentity);
            return RPC_S_OUT_OF_MEMORY;
            }
        }

    if (AuthIdentity->Domain != NULL)
        {
        AuthIdentity->Domain = ReallocAndPad8IfNeccessary(AuthIdentity->Domain,
            &AuthIdentity->DomainLength
            );
        if (AuthIdentity->Domain == NULL)
            {
            WipeOutAuthIdentity(AuthIdentity);
            return RPC_S_OUT_OF_MEMORY;
            }

        NtStatus = RtlEncryptMemory(AuthIdentity->Domain,
            AuthIdentity->DomainLength * sizeof(RPC_CHAR),
            0);

        if (!NT_SUCCESS(NtStatus))
            {
            ASSERT(NtStatus != STATUS_INVALID_PARAMETER);
            WipeOutAuthIdentity(AuthIdentity);
            return RPC_S_OUT_OF_MEMORY;
            }
        }

    if (AuthIdentity->Password != NULL)
        {
        AuthIdentity->Password = ReallocAndPad8IfNeccessary(AuthIdentity->Password,
            &AuthIdentity->PasswordLength
            );
        if (AuthIdentity->Password == NULL)
            {
            WipeOutAuthIdentity(AuthIdentity);
            return RPC_S_OUT_OF_MEMORY;
            }

        NtStatus = RtlEncryptMemory(AuthIdentity->Password,
            AuthIdentity->PasswordLength * sizeof(RPC_CHAR),
            0);

        if (!NT_SUCCESS(NtStatus))
            {
            ASSERT(NtStatus != STATUS_INVALID_PARAMETER);
            WipeOutAuthIdentity(AuthIdentity);
            return RPC_S_OUT_OF_MEMORY;
            }
        }

    return RPC_S_OK;
}

RPC_STATUS DecryptAuthIdentity (
    IN SEC_WINNT_AUTH_IDENTITY_W *AuthIdentity
    )
/*++

Routine Description:

    Decrypts the important parts of an auth identity structure.
    If decryption fails half way through, the auth identity will
    be wiped out.

Arguments:

    AuthIdentity - the auth identity to decrypt.

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    RPC_STATUS RpcStatus;
    NTSTATUS NtStatus;

    if (AuthIdentity->User != NULL)
        {
        NtStatus = RtlDecryptMemory(AuthIdentity->User,
            AuthIdentity->UserLength * sizeof(RPC_CHAR),
            0);

        if (!NT_SUCCESS(NtStatus))
            {
            WipeOutAuthIdentity(AuthIdentity);
            return RPC_S_OUT_OF_MEMORY;
            }

        AuthIdentity->UserLength = RpcpStringLength(AuthIdentity->User);
        }

    if (AuthIdentity->Domain != NULL)
        {
        NtStatus = RtlDecryptMemory(AuthIdentity->Domain,
            AuthIdentity->DomainLength * sizeof(RPC_CHAR),
            0);

        if (!NT_SUCCESS(NtStatus))
            {
            WipeOutAuthIdentity(AuthIdentity);
            return RPC_S_OUT_OF_MEMORY;
            }

        AuthIdentity->DomainLength = RpcpStringLength(AuthIdentity->Domain);
        }

    if (AuthIdentity->Password != NULL)
        {
        NtStatus = RtlDecryptMemory(AuthIdentity->Password,
            AuthIdentity->PasswordLength * sizeof(RPC_CHAR),
            0);

        if (!NT_SUCCESS(NtStatus))
            {
            WipeOutAuthIdentity(AuthIdentity);
            return RPC_S_OUT_OF_MEMORY;
            }

        AuthIdentity->PasswordLength = RpcpStringLength(AuthIdentity->Password);
        }

    return RPC_S_OK;
}

void FreeAuthIdentity (
    IN SEC_WINNT_AUTH_IDENTITY_W *AuthIdentity
    )
/*++

Routine Description:

    Frees an auth identity structure.

Arguments:

    AuthIdentity - the auth identity to free.

Return Value:

Notes:

    Does not wipe out the auth identity! It must
    have been wiped out by the caller.

--*/
{
    if (AuthIdentity->User != NULL)
        {
        delete [] AuthIdentity->User;
        AuthIdentity->User = NULL;
        }

    if (AuthIdentity->Domain != NULL)
        {
        delete [] AuthIdentity->Domain;
        AuthIdentity->Domain = NULL;
        }

    if (AuthIdentity->Password != NULL)
        {
        delete [] AuthIdentity->Password;
        AuthIdentity->Password = NULL;
        }

    delete AuthIdentity;
}

SEC_WINNT_AUTH_IDENTITY_W *DuplicateAuthIdentity (
    IN SEC_WINNT_AUTH_IDENTITY_W *AuthIdentity
    )
/*++

Routine Description:

    Duplicates an auth identity structure. It works on both
    encrypted and decrypted auth identity.

Arguments:

    AuthIdentity - the auth identity to copy from.

Return Value:

    Duplicated auth identity of NULL for failure

--*/
{
    SEC_WINNT_AUTH_IDENTITY_W *NewAuthIdentity;

    NewAuthIdentity = new SEC_WINNT_AUTH_IDENTITY_W;
    if (NewAuthIdentity == NULL)
        return NULL;

    RpcpMemoryCopy(NewAuthIdentity, AuthIdentity, sizeof(SEC_WINNT_AUTH_IDENTITY_W));
    NewAuthIdentity->User = NULL;
    NewAuthIdentity->Domain = NULL;
    NewAuthIdentity->Password = NULL;

    if (AuthIdentity->User)
        {
        NewAuthIdentity->User = new RPC_CHAR [AuthIdentity->UserLength + 1];
        if (NewAuthIdentity->User == NULL)
            {
            FreeAuthIdentity(NewAuthIdentity);
            return NULL;
            }
        RpcpMemoryCopy(NewAuthIdentity->User, 
            AuthIdentity->User, 
            (AuthIdentity->UserLength + 1) * sizeof(RPC_CHAR));
        }

    if (AuthIdentity->Domain)
        {
        NewAuthIdentity->Domain = new RPC_CHAR [AuthIdentity->DomainLength + 1];
        if (NewAuthIdentity->Domain == NULL)
            {
            WipeOutAuthIdentity(NewAuthIdentity);
            FreeAuthIdentity(NewAuthIdentity);
            return NULL;
            }
        RpcpMemoryCopy(NewAuthIdentity->Domain, 
            AuthIdentity->Domain, 
            (AuthIdentity->DomainLength + 1) * sizeof(RPC_CHAR));
        }

    if (AuthIdentity->Password)
        {
        NewAuthIdentity->Password = new RPC_CHAR [AuthIdentity->PasswordLength + 1];
        if (NewAuthIdentity->Password == NULL)
            {
            WipeOutAuthIdentity(NewAuthIdentity);
            FreeAuthIdentity(NewAuthIdentity);
            return NULL;
            }
        RpcpMemoryCopy(NewAuthIdentity->Password, 
            AuthIdentity->Password, 
            (AuthIdentity->PasswordLength + 1) * sizeof(RPC_CHAR));
        }

    return NewAuthIdentity;
}

int CompareAuthIdentity (
    IN SEC_WINNT_AUTH_IDENTITY_W *AuthIdentity1,
    IN SEC_WINNT_AUTH_IDENTITY_W *AuthIdentity2
    )
/*++

Routine Description:

    Compares 2 auth identity structures. Works on both
    encrypted and decrypted auth identities?

Arguments:

    AuthIdentity1 - first auth identity structure

    AuthIdentity2 - second auth identity structure

Return Value:

    0 if they are equal. non-zero otherwise.

--*/
{
    if (AuthIdentity1 == NULL)
        return (AuthIdentity2 != NULL);
    else if (AuthIdentity2 == NULL)
        return 1;

    if (AuthIdentity1->Flags != AuthIdentity2->Flags)
        return 1;

    if (AuthIdentity1->User)
        {
        if (AuthIdentity2->User == NULL)
            return 1;

        if (AuthIdentity1->UserLength != AuthIdentity2->UserLength)
            return 1;

        if (RpcpMemoryCompare(AuthIdentity1->User, 
            AuthIdentity2->User, 
            AuthIdentity1->UserLength * sizeof(RPC_CHAR)) != 0)
            return 1;
        }
    else if (AuthIdentity2->User != NULL)
        return 1;

    if (AuthIdentity1->Domain)
        {
        if (AuthIdentity2->Domain == NULL)
            return 1;

        if (AuthIdentity1->DomainLength != AuthIdentity2->DomainLength)
            return 1;

        if (RpcpMemoryCompare(AuthIdentity1->Domain, 
            AuthIdentity2->Domain, 
            AuthIdentity1->DomainLength * sizeof(RPC_CHAR)) != 0)
            return 1;
        }
    else if (AuthIdentity2->Domain != NULL)
        return 1;

    if (AuthIdentity1->Password)
        {
        if (AuthIdentity2->Password == NULL)
            return 1;

        if (AuthIdentity1->PasswordLength != AuthIdentity2->PasswordLength)
            return 1;

        if (RpcpMemoryCompare(AuthIdentity1->Password, 
            AuthIdentity2->Password, 
            AuthIdentity1->PasswordLength * sizeof(RPC_CHAR)) != 0)
            return 1;
        }
    else if (AuthIdentity2->Password != NULL)
        return 1;

    return 0;
}

SEC_WINNT_AUTH_IDENTITY_W *ConvertAuthIdentity (
    IN SEC_WINNT_AUTH_IDENTITY_A *AuthIdentity
    )
/*++

Routine Description:

    Converts an auth identity structure.
    Conversion is done on a separate copy.

Arguments:

    AuthIdentity - the auth identity to convert.

Return Value:

    Pointer to duplicated/converted auth identity. If failure,
    NULL.

--*/
{
    SEC_WINNT_AUTH_IDENTITY_W *NewAuthIdentity;

    ASSERT(AuthIdentity->Flags == SEC_WINNT_AUTH_IDENTITY_ANSI);

    NewAuthIdentity = new SEC_WINNT_AUTH_IDENTITY_W;
    if (NewAuthIdentity == NULL)
        return NULL;

    RpcpMemoryCopy(NewAuthIdentity, AuthIdentity, sizeof(SEC_WINNT_AUTH_IDENTITY_W));
    NewAuthIdentity->User = NULL;
    NewAuthIdentity->Domain = NULL;
    NewAuthIdentity->Password = NULL;
    NewAuthIdentity->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    if (AuthIdentity->User)
        {
        NewAuthIdentity->User = new RPC_CHAR [AuthIdentity->UserLength + 1];
        if (NewAuthIdentity->User == NULL)
            {
            FreeAuthIdentity(NewAuthIdentity);
            return NULL;
            }
        FullAnsiToUnicode((char *)AuthIdentity->User, NewAuthIdentity->User);
        }

    if (AuthIdentity->Domain)
        {
        NewAuthIdentity->Domain = new RPC_CHAR [AuthIdentity->DomainLength + 1];
        if (NewAuthIdentity->Domain == NULL)
            {
            WipeOutAuthIdentity(NewAuthIdentity);
            FreeAuthIdentity(NewAuthIdentity);
            return NULL;
            }
        FullAnsiToUnicode((char *)AuthIdentity->Domain, NewAuthIdentity->Domain);
        }

    if (AuthIdentity->Password)
        {
        NewAuthIdentity->Password = new RPC_CHAR [AuthIdentity->PasswordLength + 1];
        if (NewAuthIdentity->Password == NULL)
            {
            WipeOutAuthIdentity(NewAuthIdentity);
            FreeAuthIdentity(NewAuthIdentity);
            return NULL;
            }
        FullAnsiToUnicode((char *)AuthIdentity->Password, NewAuthIdentity->Password);
        }

    return NewAuthIdentity;
}

void FreeHttpTransportCredentials (
    IN RPC_HTTP_TRANSPORT_CREDENTIALS_W *Credentials
    )
/*++

Routine Description:

    Duplicates Http transport credentials.

Arguments:

    Credentials - the credentials to free.

Return Value:

--*/
{
    if (Credentials->AuthnSchemes != NULL)
        {
        delete [] Credentials->AuthnSchemes;
        Credentials->AuthnSchemes = NULL;
        }

    if (Credentials->ServerCertificateSubject != NULL)
        {
        delete [] Credentials->ServerCertificateSubject;
        Credentials->ServerCertificateSubject = NULL;
        }

    if (Credentials->TransportCredentials != NULL)
        {
        FreeAuthIdentity(Credentials->TransportCredentials);
        Credentials->TransportCredentials = NULL;
        }
}
    
RPC_HTTP_TRANSPORT_CREDENTIALS_W *DuplicateHttpTransportCredentials (
    const IN RPC_HTTP_TRANSPORT_CREDENTIALS_W *SourceCredentials
    )
/*++

Routine Description:

    Duplicates Http transport credentials.

Arguments:

    SourceCredentials - the credentials to duplicate.

Return Value:

    Duplicated credentials or NULL if there was not enough memory.

--*/
{
    RPC_HTTP_TRANSPORT_CREDENTIALS_W *NewCredentials;

    NewCredentials = new RPC_HTTP_TRANSPORT_CREDENTIALS_W;
    if (NewCredentials == NULL)
        return NewCredentials;

    NewCredentials->Flags = SourceCredentials->Flags;
    NewCredentials->AuthenticationTarget = SourceCredentials->AuthenticationTarget;
    NewCredentials->NumberOfAuthnSchemes = SourceCredentials->NumberOfAuthnSchemes;
    NewCredentials->AuthnSchemes = NULL;
    NewCredentials->ServerCertificateSubject = NULL;
    NewCredentials->TransportCredentials = NULL;
    if (SourceCredentials->AuthnSchemes)
        {
        NewCredentials->AuthnSchemes = new ULONG [SourceCredentials->NumberOfAuthnSchemes];
        if (NewCredentials->AuthnSchemes == NULL)
            {
            FreeHttpTransportCredentials(NewCredentials);
            return NULL;
            }

        RpcpMemoryCopy(NewCredentials->AuthnSchemes, 
            SourceCredentials->AuthnSchemes,
            SourceCredentials->NumberOfAuthnSchemes * sizeof(ULONG)
            );
        }

    if (SourceCredentials->ServerCertificateSubject)
        {
        NewCredentials->ServerCertificateSubject 
            = DuplicateString(SourceCredentials->ServerCertificateSubject);

        if (NewCredentials->ServerCertificateSubject == NULL)
            {
            FreeHttpTransportCredentials(NewCredentials);
            return NULL;
            }
        }

    if (SourceCredentials->TransportCredentials)
        {
        NewCredentials->TransportCredentials 
            = DuplicateAuthIdentity(SourceCredentials->TransportCredentials);
        if (NewCredentials->TransportCredentials == NULL)
            {
            FreeHttpTransportCredentials(NewCredentials);
            return NULL;
            }
        }

    return NewCredentials;
}

int CompareHttpTransportCredentials (
    const IN RPC_HTTP_TRANSPORT_CREDENTIALS_W *Credentials1,
    const IN RPC_HTTP_TRANSPORT_CREDENTIALS_W *Credentials2
    )
/*++

Routine Description:

    Compares Http transport credentials.

Arguments:

    Credentials1 - first set of credentials

    Credentials2 - second set of credentials

Return Value:

    0 if they are equal or non-zero if they are different

--*/
{
    if (Credentials1->Flags != Credentials2->Flags)
        return 1;

    if (Credentials1->AuthenticationTarget != Credentials2->AuthenticationTarget)
        return 1;

    if (Credentials1->NumberOfAuthnSchemes != Credentials2->NumberOfAuthnSchemes)
        return 1;

    if (Credentials1->AuthnSchemes != NULL)
        {
        if (RpcpMemoryCompare(Credentials1->AuthnSchemes, 
            Credentials2->AuthnSchemes, 
            Credentials1->NumberOfAuthnSchemes) != 0)
            {
            return 1;
            }
        }
    else if (Credentials1->AuthnSchemes != NULL)
        return 1;

    if (Credentials1->ServerCertificateSubject != NULL)
        {
        if (RpcpStringCompare(Credentials1->ServerCertificateSubject, 
            Credentials2->ServerCertificateSubject) != 0)
            {
            return 1;
            }
        }
    else if (Credentials1->ServerCertificateSubject != NULL)
        return 1;

    return CompareAuthIdentity(Credentials1->TransportCredentials, Credentials2->TransportCredentials);
}

RPC_HTTP_TRANSPORT_CREDENTIALS_W *ConvertToUnicodeHttpTransportCredentials (
    const IN RPC_HTTP_TRANSPORT_CREDENTIALS_A *SourceCredentials
    )
/*++

Routine Description:

    Converts Http transport credentials from ANSI to Unicode.
    Conversion is done on a separate copy.

Arguments:

    SourceCredentials - the credentials to convert.

Return Value:

    Pointer to duplicated/converted credentials. If failure,
    NULL.

--*/
{
    RPC_HTTP_TRANSPORT_CREDENTIALS_W *NewCredentials;
    ULONG Length;

    NewCredentials = new RPC_HTTP_TRANSPORT_CREDENTIALS_W;
    if (NewCredentials == NULL)
        return NewCredentials;

    NewCredentials->Flags = SourceCredentials->Flags;
    NewCredentials->AuthenticationTarget = SourceCredentials->AuthenticationTarget;
    NewCredentials->NumberOfAuthnSchemes = SourceCredentials->NumberOfAuthnSchemes;
    NewCredentials->AuthnSchemes = NULL;
    NewCredentials->ServerCertificateSubject = NULL;
    NewCredentials->TransportCredentials = NULL;
    if (SourceCredentials->AuthnSchemes)
        {
        NewCredentials->AuthnSchemes = new ULONG [SourceCredentials->NumberOfAuthnSchemes];
        if (NewCredentials->AuthnSchemes == NULL)
            {
            FreeHttpTransportCredentials(NewCredentials);
            return NULL;
            }

        RpcpMemoryCopy(NewCredentials->AuthnSchemes, 
            SourceCredentials->AuthnSchemes,
            SourceCredentials->NumberOfAuthnSchemes * sizeof(ULONG)
            );
        }

    if (SourceCredentials->ServerCertificateSubject)
        {
        Length = RpcpStringLengthA((const char *)SourceCredentials->ServerCertificateSubject) + 1;
        NewCredentials->ServerCertificateSubject = new RPC_CHAR[Length];
        if (NewCredentials->ServerCertificateSubject == NULL)
            {
            FreeHttpTransportCredentials(NewCredentials);
            return NULL;
            }

        FullAnsiToUnicode((char *)SourceCredentials->ServerCertificateSubject,
            NewCredentials->ServerCertificateSubject);
        }

    if (SourceCredentials->TransportCredentials)
        {
        NewCredentials->TransportCredentials 
            = ConvertAuthIdentity(SourceCredentials->TransportCredentials);
        if (NewCredentials->TransportCredentials == NULL)
            {
            FreeHttpTransportCredentials(NewCredentials);
            return NULL;
            }
        }

    return NewCredentials;
}

RPC_HTTP_TRANSPORT_CREDENTIALS_W *
I_RpcTransGetHttpCredentials (
    const IN RPC_HTTP_TRANSPORT_CREDENTIALS_W *SourceCredentials
    )
/*++

Routine Description:

    Takes runtime encrypted credentials and returns a duplicate,
        decrypted credentials.

Arguments:

    SourceCredentials - the encrypted runtime credentials given to the
        transport during Open.

Return Value:

    Pointer to duplicated/converted credentials. If failure,
    NULL.

--*/
{
    RPC_HTTP_TRANSPORT_CREDENTIALS_W *NewCredentials;
    RPC_STATUS RpcStatus;

    NewCredentials = DuplicateHttpTransportCredentials(SourceCredentials);
    if (NewCredentials && NewCredentials->TransportCredentials)
        {
        RpcStatus = DecryptAuthIdentity(NewCredentials->TransportCredentials);
        if (RpcStatus != RPC_S_OK)
            {
            // if Decrypt fails, it will wipe out the auth identity
            FreeHttpTransportCredentials(NewCredentials);
            NewCredentials = NULL;
            }

        // the credentials are not encrypted anymore
        NewCredentials->Flags &= ~RPC_C_HTTP_FLAG_AUTH_IDENTITY_ENCRYPTED;
        }

    return NewCredentials;
}

void I_RpcTransFreeHttpCredentials (
    IN RPC_HTTP_TRANSPORT_CREDENTIALS_W *SourceCredentials
    )
/*++

Routine Description:

    Frees credentials obtained by the transport through 
    I_RpcTransGetHttpCredentials.

Arguments:

    SourceCredentials - the credentials to free.

Return Value:

--*/
{
    ASSERT(SourceCredentials);

    WipeOutAuthIdentity(SourceCredentials->TransportCredentials);
    FreeHttpTransportCredentials(SourceCredentials);
}

/* ====================================================================

GENERIC_OBJECT

==================================================================== */

/* --------------------------------------------------------------------
This routine validates a handle.  The HandleType argument is a set of
flags specifying the valid handle types.  Note that the handle types
defined in handle.hxx are flags rather than being enumerated.
-------------------------------------------------------------------- */
unsigned int
GENERIC_OBJECT::InvalidHandle ( // Validate a handle.
    IN HANDLE_TYPE BaseType
    )
{

    // Checking for a 0 handle should work for all operating environments.  Where
    // we can (such as on NT), we should check for readable and writeable memory.

    if (this == 0)
        {
        return(1);
        }

    // Check the magic long.  This allows us to catch stale handles and handles
    // which are just passed in as arbitray pointers into memory.  It does not
    // handle the case of copying the contents of a handle.

    if (MagicLong != MAGICLONG)
        {
        return(1);
        }

    //
    // Finally, check that the type of handle is one of the allowed ones
    // specified by the HandleType argument.  Remember that the call to Type
    // is a virtual method which each type of handle will implement.
    //
    if (ObjectType & BaseType)
        {
        return 0;
        }

    return(1);
}

RPC_STATUS
MESSAGE_OBJECT::BindingCopy (
    OUT BINDING_HANDLE * PAPI * DestinationBinding,
    IN unsigned int MaintainContext
    )
{
    UNUSED(this);
    UNUSED(DestinationBinding);
    UNUSED(MaintainContext);

    ASSERT( 0 );
    return(RPC_S_INTERNAL_ERROR);
}


void
CLIENT_AUTH_INFO::ReferenceCredentials() const
{

  if (Credentials != 0)
      {
      Credentials->ReferenceCredentials();
      }
}


int
CLIENT_AUTH_INFO::CredentialsMatch(
     SECURITY_CREDENTIALS PAPI * SuppliedCredentials
     ) const
{
  return(Credentials->CompareCredentials(SuppliedCredentials) == 0);
}


CLIENT_AUTH_INFO::CLIENT_AUTH_INFO(
    const CLIENT_AUTH_INFO * SourceAuthInfo,
    RPC_STATUS __RPC_FAR * pStatus
    )
{
    if (SourceAuthInfo)
        {
        *this = *SourceAuthInfo;

        if (SourceAuthInfo->ServerSid)
            {
            PSID NewSid;

            NewSid = DuplicateSID (SourceAuthInfo->ServerSid);
            ServerSid = NewSid;
            if (0 == NewSid)
                {
                *pStatus = RPC_S_OUT_OF_MEMORY;
                }
            }

        if (SourceAuthInfo->ServerPrincipalName)
            {
            RPC_CHAR * NewString;

            NewString = DuplicateString(SourceAuthInfo->ServerPrincipalName);
            ServerPrincipalName = NewString;
            if (0 == NewString)
                {
                *pStatus = RPC_S_OUT_OF_MEMORY;
                }
            }

        ASSERT((AdditionalTransportCredentialsType == RPC_C_AUTHN_INFO_TYPE_HTTP)
            || (AdditionalTransportCredentialsType == 0));

        if (SourceAuthInfo->AdditionalTransportCredentialsType == RPC_C_AUTHN_INFO_TYPE_HTTP)
            {
            ASSERT(SourceAuthInfo->AdditionalCredentials != NULL);
            AdditionalCredentials = DuplicateHttpTransportCredentials(
                (const RPC_HTTP_TRANSPORT_CREDENTIALS_W *)SourceAuthInfo->AdditionalCredentials);
            if (AdditionalCredentials == NULL)
                {
                *pStatus = RPC_S_OUT_OF_MEMORY;
                }
            }
        SourceAuthInfo->ReferenceCredentials();
        }
    else
        {
        AuthenticationLevel   = RPC_C_AUTHN_LEVEL_NONE;
        AuthenticationService = RPC_C_AUTHN_NONE;
        AuthorizationService  = RPC_C_AUTHZ_NONE;
        ServerPrincipalName   = 0;
        AuthIdentity          = 0;
        Credentials           = 0;
        ImpersonationType     = RPC_C_IMP_LEVEL_IMPERSONATE;
        IdentityTracking      = RPC_C_QOS_IDENTITY_STATIC;
        Capabilities          = RPC_C_QOS_CAPABILITIES_DEFAULT;
        DefaultLogonId        = 1;
        AdditionalTransportCredentialsType = 0;
        AdditionalCredentials = NULL;
        ServerSid = NULL;
        }
}

CLIENT_AUTH_INFO::~CLIENT_AUTH_INFO(
    )
{
    delete ServerPrincipalName;
    delete [] ServerSid;

    if (Credentials)
        {
        Credentials->DereferenceCredentials();
        }

    ASSERT((AdditionalTransportCredentialsType == RPC_C_AUTHN_INFO_TYPE_HTTP)
        || (AdditionalTransportCredentialsType == 0));

    if (AdditionalTransportCredentialsType == RPC_C_AUTHN_INFO_TYPE_HTTP)
        {
        ASSERT(AdditionalCredentials != NULL);
        FreeHttpTransportCredentials((RPC_HTTP_TRANSPORT_CREDENTIALS_W *)AdditionalCredentials);
        AdditionalCredentials = NULL;
        }
}

RPC_STATUS
CLIENT_AUTH_INFO::IsSupportedAuthInfo (
    IN const CLIENT_AUTH_INFO * ClientAuthInfo,
    IN NamedPipeType NPType,
    IN BOOL IsExclusiveConnection,
    OUT BOOL *Supported
    ) const
/*++

Arguments:

    ClientAuthInfo - Supplies the authentication and authorization information
        required of this connection.  A value of zero (the pointer is
        zero) indicates that we want an unauthenticated connection.

    NPType - the type of transport w.r.t. to named pipes. See the definition
        of NamedPipeType for description of the bitmasks

    IsExclusiveConnection - if NPType is not named pipe, this parameter is ignored.
        Otherwise non-zero means the connection is exclusive. Zero means the
        connection is non-exclusive.

    Supported - on output, non-zero if the auth info is supported, zero otherwise.
        Undefined on failure.

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    if ( ClientAuthInfo == 0 )
        {
        *Supported = (AuthenticationLevel == RPC_C_AUTHN_LEVEL_NONE);
        return RPC_S_OK;
        }

    // presume failure for now
    *Supported = FALSE;

    if ( ClientAuthInfo->AuthenticationService != AuthenticationService )
        {
        return RPC_S_OK;
        }

    if (ClientAuthInfo->AuthenticationService == RPC_C_AUTHN_NONE)
        {
        // if this is a named pipe, and it is either remote, or static, or non-exclusive
        // we must match the identity. For full description of the named pipe
        // transport logic, see the comment in the NPType member in OSF_BINDING_HANDLE
        if (IsNamedPipe(NPType) 
            && 
            (
             (IsStaticNamedPipe(NPType))
             ||
             (IsRemoteNamedPipe(NPType))
             ||
             (IsExclusiveConnection == FALSE)
            ) )
            {
            if ((ClientAuthInfo->DefaultLogonId != DefaultLogonId)
                || ((ClientAuthInfo->DefaultLogonId == FALSE)
                    && (!FastCompareLUIDAligned(&ClientAuthInfo->ModifiedId, &ModifiedId))))
                {
                return RPC_S_OK;
                }
            }

        if (ClientAuthInfo->ServerSid && ServerSid)
            *Supported = EqualSid (ClientAuthInfo->ServerSid, ServerSid);
        else
            *Supported = TRUE;
        return RPC_S_OK;
        }

    if ( ClientAuthInfo->AuthenticationLevel
                != AuthenticationLevel )
        {
        return RPC_S_OK;
        }


    if ( ClientAuthInfo->AuthorizationService != AuthorizationService )
        {
        return RPC_S_OK;
        }

    if (CredentialsMatch(ClientAuthInfo->Credentials) == 0)
        {
        //Credentials Dont Match
        return RPC_S_OK;
        }

    if ( ClientAuthInfo->ImpersonationType != ImpersonationType )
        {
        return RPC_S_OK;
        }

    if ( (ClientAuthInfo->IdentityTracking == RPC_C_QOS_IDENTITY_DYNAMIC)
         && (IdentityTracking == RPC_C_QOS_IDENTITY_DYNAMIC)
         && (
             (ClientAuthInfo->DefaultLogonId != DefaultLogonId)
            || (
                (ClientAuthInfo->DefaultLogonId == FALSE)
              && (!FastCompareLUIDAligned(&ClientAuthInfo->ModifiedId, &ModifiedId))  
               )
            )
       || (ClientAuthInfo->IdentityTracking != IdentityTracking) )
        {
        return RPC_S_OK;
        }

    if ( (ClientAuthInfo->Capabilities != Capabilities)
       &&(ClientAuthInfo->Capabilities != RPC_C_QOS_CAPABILITIES_DEFAULT) )
        {
        return RPC_S_OK;
        }

    ASSERT((AdditionalTransportCredentialsType == RPC_C_AUTHN_INFO_TYPE_HTTP)
        || (AdditionalTransportCredentialsType == 0));

    if (AdditionalTransportCredentialsType == RPC_C_AUTHN_INFO_TYPE_HTTP)
        {
        if (CompareHttpTransportCredentials((RPC_HTTP_TRANSPORT_CREDENTIALS_W *)AdditionalCredentials,
            (RPC_HTTP_TRANSPORT_CREDENTIALS_W *)ClientAuthInfo->AdditionalCredentials) != 0)
            {
            return RPC_S_OK;
            }
        }

    // if the SPN and SID are equal, this is supported
    return CompareSPNAndSID (ClientAuthInfo, Supported);
}

RPC_STATUS
CLIENT_AUTH_INFO::CompareSPNAndSID (
    IN const CLIENT_AUTH_INFO *AuthInfo,
    OUT BOOL *Equal
    ) const
/*++

Routine Description:

    Compares the SPN and SID of two auth info classes
        and determines whether they are equal

Arguments:

    AuthInfo - the second class to compare to.

    Equal - on output, if non-zero, they are equal. If zero,
        they are not equal. Undefined on failure.

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    PSID Sid;
    RPC_STATUS RpcStatus;
    // Bypass the cache for all comparisons
    BOOL fCachedSid = FALSE;

    // the table of relationships b/n SID and SPN is as follows:
    // Case This:                    AuthInfo:
    //      SPN      SID             SPN         SID
    // 1    0        0               0           0
    // 2    0        0               0           1
    // 3    0        0               1           0
    // 4    0        0               1           1
    // 5    0        1               0           0
    // 6    0        1               0           1
    // 7    0        1               1           0
    // 8    0        1               1           1
    // 9    1        0               0           0
    // 10   1        0               0           1
    // 11   1        0               1           0
    // 12   1        0               1           1
    // 13   1        1               0           0
    // 14   1        1               0           1
    // 15   1        1               1           0
    // 16   1        1               1           1

    // cases 6, 8, 14, 16
    if (AuthInfo->ServerSid && ServerSid)
        {
        // sid comparison is final and authoritative
        *Equal = EqualSid (AuthInfo->ServerSid, ServerSid);
        return RPC_S_OK;
        }

    // cases 11, 12, 15
    if (AuthInfo->ServerPrincipalName && ServerPrincipalName)
        {
        *Equal = !RpcpStringCompare(AuthInfo->ServerPrincipalName,
                                 ServerPrincipalName);
        return RPC_S_OK;
        }

    // if both SPNs are not present, the SIDs matter. Cases 1, 2, 5
    if (   (AuthInfo->ServerPrincipalName == 0)
        && (ServerPrincipalName == 0) )
        {
        // we know we can't have both SIDs here. At least one of them is NULL
        *Equal = (AuthInfo->ServerSid == ServerSid);
        return RPC_S_OK;
        }

    // if both SIDs are not present, the SPNs matter. Cases 3 and 9
    if (   (AuthInfo->ServerSid == 0)
        && (ServerSid == 0) )
        {
        // we know we can't have both SPNs here. At least one of them is NULL
        *Equal = (AuthInfo->ServerPrincipalName == ServerPrincipalName);
        return RPC_S_OK;
        }

    // here either one has both, and the other neither, or they are criss-crossed
    // case 4
    if (AuthInfo->ServerPrincipalName && AuthInfo->ServerSid)
        {
        ASSERT(ServerPrincipalName == NULL);
        ASSERT(ServerSid == NULL);
        *Equal = FALSE;
        return RPC_S_OK;
        }

    // case 13
    if (ServerPrincipalName && ServerSid)
        {
        ASSERT(AuthInfo->ServerPrincipalName == NULL);
        ASSERT(AuthInfo->ServerSid == NULL);
        *Equal = FALSE;
        return RPC_S_OK;
        }

    // they must be criss-crossed. Convert the one with an SPN to a SID.
    // Case 10
    if (ServerPrincipalName)
        {
        ASSERT(ServerSid == NULL);
        ASSERT(AuthInfo->ServerSid);
        RpcStatus = RpcpLookupAccountName (ServerPrincipalName,
            &fCachedSid,
            &Sid);
        if (RpcStatus != RPC_S_OK)
            return RpcStatus;
        if (InterlockedCompareExchangePointer((PVOID *)&ServerSid,
            Sid,
            NULL) != NULL)
            {
            // somebody beat us to the punch - free the sid
            delete [] Sid;
            }
        // fall through to comparison
        }

    // case 7
    if (AuthInfo->ServerPrincipalName)
        {
        ASSERT(ServerSid);
        ASSERT(AuthInfo->ServerSid == NULL);
        RpcStatus = RpcpLookupAccountName (AuthInfo->ServerPrincipalName,
            &fCachedSid,
            &Sid);
        if (RpcStatus != RPC_S_OK)
            return RpcStatus;
        if (InterlockedCompareExchangePointer((PVOID *)&AuthInfo->ServerSid,
            Sid,
            NULL) != NULL)
            {
            // somebody beat us to the punch - free the sid
            delete [] Sid;
            }
        // fall through to comparison
        }

    ASSERT(AuthInfo->ServerSid);
    ASSERT(ServerSid);

    *Equal = EqualSid (AuthInfo->ServerSid, ServerSid);

    return RPC_S_OK;    
}


RPC_STATUS
CALL::Cancel(
    void * ThreadHandle
    )
{
    return RPC_S_OK;
}

unsigned
CALL::TestCancel(
    )
{
    return 0;
}


/* ====================================================================

CCALL

==================================================================== */

RPC_STATUS CCALL::SetDebugClientCallInformation(OUT DebugClientCallInfo **ppClientCallInfo,
                                                OUT CellTag *ClientCallInfoCellTag,
                                                OUT DebugCallTargetInfo **ppCallTargetInfo,
                                                OUT CellTag *CallTargetInfoCellTag,
                                                IN OUT PRPC_MESSAGE Message,
                                                IN DebugThreadInfo *ThreadDebugCell OPTIONAL,
                                                IN CellTag ThreadCellTag OPTIONAL)
{
    RPC_STATUS Status;
    DebugClientCallInfo *ClientCallInfo;
    DebugCallTargetInfo *CallTargetInfo;

    Status = InitializeServerSideCellHeapIfNecessary();

    if (Status != RPC_S_OK)
        return Status;

    ClientCallInfo = (DebugClientCallInfo *) AllocateCell(ClientCallInfoCellTag);
    if (ClientCallInfo == NULL)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    CallTargetInfo = (DebugCallTargetInfo *) AllocateCell(CallTargetInfoCellTag);
    if (CallTargetInfo == NULL)
        {
        FreeCell(ClientCallInfo, ClientCallInfoCellTag);
        return RPC_S_OUT_OF_MEMORY;
        }

    ClientCallInfo->TypeHeader = 0;
    ClientCallInfo->Type = dctClientCallInfo;
    ClientCallInfo->IfStart = *((DWORD *)Message->RpcInterfaceInformation + 1);
    ClientCallInfo->ProcNum = (unsigned short)Message->ProcNum;

    GetDebugCellIDFromDebugCell((DebugCellUnion *)CallTargetInfo,
        CallTargetInfoCellTag, &ClientCallInfo->CallTargetID);

    if (ThreadDebugCell)
        {
        GetDebugCellIDFromDebugCell((DebugCellUnion *)ThreadDebugCell,
            &ThreadCellTag, &ClientCallInfo->ServicingThread);
        }
    else
        {
        ClientCallInfo->ServicingThread.CellID = 0;
        ClientCallInfo->ServicingThread.SectionID = 0;
        }

    CallTargetInfo->TypeHeader = 0;
    CallTargetInfo->Type = dctCallTargetInfo;
    CallTargetInfo->LastUpdateTime = NtGetTickCount();

    *ppClientCallInfo = ClientCallInfo;
    *ppCallTargetInfo = CallTargetInfo;
    return RPC_S_OK;
}

/* ====================================================================

BINDING_HANDLE

==================================================================== */


BINDING_HANDLE::BINDING_HANDLE (
    IN OUT RPC_STATUS *pStatus
    ) : BindingMutex(pStatus)
/*++

Routine Description:

    In addition to initializing a binding handle instance in this
    constructor, we also need to put the binding handle into a global
    set of binding handle.  This is necessary only for windows.

--*/
{
    Timeout = RPC_C_BINDING_DEFAULT_TIMEOUT;
    NullObjectUuidFlag = 1;
    ObjectUuid.SetToNullUuid();
    EntryNameSyntax = 0;
    EntryName = 0;
    EpLookupHandle = 0;

    pvTransportOptions = NULL;
    OptionsVector = NULL;
}

BINDING_HANDLE::~BINDING_HANDLE (
    )
{
    if (EpLookupHandle != 0)
        {
        EpFreeLookupHandle(EpLookupHandle);
        }

    delete EntryName;

    if (pvTransportOptions)
        {
        I_RpcFree(pvTransportOptions);
        }

    if (OptionsVector)
        {
        I_RpcFree(OptionsVector);
        }
}

RPC_STATUS
BINDING_HANDLE::BaseClone (
                      BINDING_HANDLE * Handle
                      )
{
    RPC_STATUS Status = 0;

    Timeout            = Handle->Timeout;
    ObjectUuid         = Handle->ObjectUuid;
    NullObjectUuidFlag = Handle->NullObjectUuidFlag;

    /*
    All of these duplicate what is done in the constructor.

    EntryName          = 0;
    EntryNameSyntax    = 0;
    EpLookupHandle     = 0;
    pvTransportOptions = 0;
    OptionsVector      = 0;
    */

    if (Handle->OptionsVector)
        {
        OptionsVector = new ULONG_PTR[ RPC_C_OPT_MAX_OPTIONS ];
        if (OptionsVector == 0)
            {
            return RPC_S_OUT_OF_MEMORY;
            }

        RpcpMemoryCopy( OptionsVector, Handle->OptionsVector, RPC_C_OPT_MAX_OPTIONS * sizeof( ULONG_PTR) );
        }

    return Status;
}

RPC_STATUS
BINDING_HANDLE::Clone (
                      BINDING_HANDLE * Handle
                      )
{
    RPC_STATUS Status = 0;

    Status = BaseClone(Handle);
    if(Status != RPC_S_OK)
        {
        return Status;
        }

    CLIENT_AUTH_INFO * AuthInfo;
    if ((AuthInfo = Handle->InquireAuthInformation()) != 0)
        {
        Status = SetAuthInformation(
                                AuthInfo->ServerPrincipalName,
                                AuthInfo->AuthenticationLevel,
                                AuthInfo->AuthenticationService,
                                AuthInfo->AuthIdentity,
                                AuthInfo->AuthorizationService,
                                AuthInfo->Credentials,
                                AuthInfo->ImpersonationType,
                                AuthInfo->IdentityTracking,
                                AuthInfo->Capabilities,
                                FALSE,      // bAcquireNewCredentials
                                AuthInfo->AdditionalTransportCredentialsType,
                                AuthInfo->AdditionalCredentials,
                                AuthInfo->ServerSid
                                );

        if (Status != RPC_S_OK)
            {
            ASSERT(Status == RPC_S_OUT_OF_MEMORY);
            //
            // Previous code maps all security errors to this.
            //
            return RPC_S_OUT_OF_MEMORY;
            }
        }

    return Status;
}

void
BINDING_HANDLE::InquireObjectUuid (
    OUT RPC_UUID PAPI * ObjectUuid
    )
/*++

Routine Description:

    This routine copies the object uuid from the binding handle into
    the supplied ObjectUuid argument.

Arguments:

    ObjectUuid - Returns a copy of the object uuid in the binding handle.

--*/
{
    ObjectUuid->CopyUuid(&(this->ObjectUuid));
}


void
BINDING_HANDLE::SetObjectUuid (
    IN RPC_UUID PAPI * ObjectUuid
    )
/*++

Routine Description:

    This routine copies the object uuid supplied in the ObjectUuid argument
    into the binding handle.

Arguments:

    ObjectUuid - Supplies the object uuid to copy into the binding handle.

--*/
{
    if (   ( ObjectUuid == 0 )
    || ( ObjectUuid->IsNullUuid() != 0 ) )
    {
    NullObjectUuidFlag = 1;
    this->ObjectUuid.SetToNullUuid();
    }
    else
    {
    this->ObjectUuid.CopyUuid(ObjectUuid);
    NullObjectUuidFlag = 0;
    }
}


RPC_STATUS
BINDING_HANDLE::SetComTimeout (
    IN unsigned int Timeout
    )
/*++

Routine Description:

    This routine sets the communications timeout value in this binding
    handle.  The specified timeout is range checked.

Arguments:

    Timeout - Supplies the new communications timeout value for this
    binding handle.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_INVALID_TIMEOUT - The specified timeout value is not in the
    correct range.

--*/
{
    // We just need to check to see if the timeout value is too large,
    // since the timeout is unsigned and the lowest value is zero.

    if (Timeout > RPC_C_BINDING_INFINITE_TIMEOUT)
    return(RPC_S_INVALID_TIMEOUT);

    this->Timeout = Timeout;
    return(RPC_S_OK);
}

RPC_CHAR *pNS_DLL_NAME = RPC_STRING_LITERAL("RPCNS4");
const char *pNS_ENTRYPOINT_NAME = "I_GetDefaultEntrySyntax";


typedef unsigned long (RPC_ENTRY * GET_DEFAULT_ENTRY_FN)();




RPC_STATUS
BINDING_HANDLE::InquireEntryName (
    IN unsigned long EntryNameSyntax,
    OUT RPC_CHAR PAPI * PAPI * EntryName
    )
/*++

Routine Description:

    This method is used to obtain the entry name for the binding handle,
    if it has one.  The entry name is the name of the name service object
    from which a binding handle is imported or looked up.  If the binding
    handle was not imported or looked up, then it has no entry name.

Arguments:

    EntryNameSyntax - Supplies the entry name syntax which the caller
    wants the entry name to be returned in.  This may require that
    we convert the entry name in the binding handle into a different
    syntax.

    EntryName - Returns the entry name of the binding handle in the
    requested entry name syntax.

Return Value:

    RPC_S_OK - This binding handle has an entry name, and we were able
    to convert the entry name in the binding handle into the requested
    entry name syntax.

    RPC_S_NO_ENTRY_NAME - The binding handle does not have an entry
    name.  If this value is returned, the entry name return value
    will be set to point to a newly allocated empty string.

    RPC_S_INVALID_NAME_SYNTAX - The entry name in the binding handle
    can not be converted to the entry name syntax requested.

    RPC_S_UNSUPPORTED_NAME_SYNTAX - The entry name syntax requested
    is not supported by the current configuration.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete
    the operation.

--*/
{

    if ( this->EntryName == 0 )
        {
        *EntryName = AllocateEmptyStringPAPI();
        if (*EntryName == 0)
            return(RPC_S_OUT_OF_MEMORY);
        return(RPC_S_NO_ENTRY_NAME);
        }

    //
    // If he chose the default syntax and the binding has an entry,
    // ask the name service for the default entry syntax.
    // The NS dll should already be loaded because otherwise we'd not have an
    // associated entry.
    //
    if (EntryNameSyntax == RPC_C_NS_SYNTAX_DEFAULT)
        {
        HINSTANCE NsDll = GetModuleHandle((const RPC_SCHAR *)pNS_DLL_NAME);
        if (NsDll)
            {
            GET_DEFAULT_ENTRY_FN GetDefaultEntry =
                       (GET_DEFAULT_ENTRY_FN)
                       GetProcAddress(NsDll,
                              pNS_ENTRYPOINT_NAME
                              );

            if (GetDefaultEntry)
                {
                EntryNameSyntax = (*GetDefaultEntry)();
                }
            else
                {
                //
                // leave EntryNameSyntax zero; the fn will fail
                // with invalid_name_syntax
                //
                }
            }
        else
            {
            //
            // leave EntryNameSyntax zero; the fn will fail
            // with invalid_name_syntax
            //
            }
        }

    if (EntryNameSyntax == this->EntryNameSyntax)
        {
        *EntryName = DuplicateStringPAPI(this->EntryName);
        if (*EntryName == 0)
            return(RPC_S_OUT_OF_MEMORY);
        return(RPC_S_OK);
        }

    return(RPC_S_INVALID_NAME_SYNTAX);
}


RPC_STATUS
BINDING_HANDLE::SetEntryName (
    IN unsigned long EntryNameSyntax,
    IN RPC_CHAR PAPI * EntryName
    )
/*++

Routine Description:

    This method is used to set the entry name and entry name syntax
    for a binding handle.

Arguments:

    EntryNameSyntax - Supplies the syntax of the entry name argument.

    EntryName - Supplies the entry name for this binding handle.

Return Value:

    RPC_S_OK - We successfully set the entry name (and entry name syntax)
    for this binding handle.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to set the
    entry name.

--*/
{
    RPC_CHAR * NewEntryName;

    NewEntryName = DuplicateString(EntryName);
    if (NewEntryName == 0)
        return(RPC_S_OUT_OF_MEMORY);

    this->EntryNameSyntax = EntryNameSyntax;
    if (this->EntryName != 0)
        delete this->EntryName;
    this->EntryName = NewEntryName;
    return(RPC_S_OK);
}


RPC_STATUS
BINDING_HANDLE::InquireDynamicEndpoint (
    OUT RPC_CHAR PAPI * PAPI * DynamicEndpoint
    )
/*++

Routine Description:

    This routine is used to obtain the dynamic endpoint from a binding
    handle which was created from an rpc address.  For all other binding
    handles, we just return the fact that there is no dynamic endpoint.

Arguments:

    DynamicEndpoint - Returns a pointer to the dynamic endpoint, if there
    is one, or zero.

Return Value:

    RPC_S_OK - This value will always be returned.

--*/
{
    *DynamicEndpoint = 0;
    return(RPC_S_OK);
}

unsigned long
BINDING_HANDLE::MapAuthenticationLevel (
    IN unsigned long AuthenticationLevel
    )
/*++

Routine Description:

    This method is to provide a way for a protocol module to map a requested
    authentication level into one supported by that protocol module.

Arguments:

    AuthenticationLevel - Supplies the proposed authentication level; this
    value has already been validated.

Return Value:

    The authentication level to be used is returned.

--*/
{

    return(AuthenticationLevel);
}

BOOL
BINDING_HANDLE::SetTransportAuthentication(
    IN  unsigned long  ulAuthenticationLevel,
    IN  unsigned long  ulAuthenticationService,
    OUT RPC_STATUS    *pStatus )
/*
 Routine Descritpion:

    Called inside of SetAuthInformation(), this function allows for
    transport level authentication to be set. If this function is not
    overridden then it returns RPC_S_NOT_SUPPORTED and the normal RPC
    level authentication is used.
*/
{
   *pStatus = RPC_S_CANNOT_SUPPORT;

   return TRUE;
}

RPC_STATUS
BINDING_HANDLE::SendReceive (
    IN OUT PRPC_MESSAGE Message
    )
{
    UNUSED(Message);

    ASSERT( 0 );
    return(RPC_S_INTERNAL_ERROR);
}




RPC_STATUS
BINDING_HANDLE::Send (
    IN OUT PRPC_MESSAGE Message
    )
{
    UNUSED(Message);

    ASSERT( 0 );
    return(RPC_S_INTERNAL_ERROR);
}



RPC_STATUS
BINDING_HANDLE::Receive (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned int Size
    )
{
    UNUSED(Message);

    ASSERT( 0 );
    return(RPC_S_INTERNAL_ERROR);
}

void
BINDING_HANDLE::FreeBuffer (
    IN PRPC_MESSAGE Message
    )
{
    UNUSED(Message);

    ASSERT( 0 );
}

RPC_STATUS
BINDING_HANDLE::ReAcquireCredentialsIfNecessary(
         )
{
    LUID CurrentModifiedId;
    RPC_STATUS Status = CaptureModifiedId(&CurrentModifiedId);
    SECURITY_CREDENTIALS * SecurityCredentials;
    BOOL MyDefaultLogonId;

    if (Status == RPC_S_OK)
        {
        MyDefaultLogonId = FALSE;
        }
    else
        {
        MyDefaultLogonId = TRUE;
        }

    if (MyDefaultLogonId != ClientAuthInfo.DefaultLogonId
        || (MyDefaultLogonId == FALSE
         && (FastCompareLUIDAligned(&CurrentModifiedId,
                              &ClientAuthInfo.ModifiedId) == FALSE)))
       {
        ClientAuthInfo.DefaultLogonId = MyDefaultLogonId;
        Status = RPC_S_OK;

        SecurityCredentials = new SECURITY_CREDENTIALS(&Status);
        if ((SecurityCredentials == 0) || (Status != RPC_S_OK))
            {
            if (SecurityCredentials == 0)
                {
                Status = RPC_S_OUT_OF_MEMORY;
                }
            delete SecurityCredentials;
            return (Status);
            }

        // Dynamic identity tracking - need to get the current credentials.
        Status = SecurityCredentials->AcquireCredentialsForClient(
                                        ClientAuthInfo.AuthIdentity,
                                        ClientAuthInfo.AuthenticationService,
                                        ClientAuthInfo.AuthenticationLevel
                                        );
        if ( Status != RPC_S_OK )
            {
            VALIDATE(Status)
                {
                RPC_S_OUT_OF_MEMORY,
                RPC_S_UNKNOWN_AUTHN_SERVICE,
                RPC_S_UNKNOWN_AUTHN_LEVEL,
                RPC_S_SEC_PKG_ERROR,
                ERROR_SHUTDOWN_IN_PROGRESS,
                RPC_S_INVALID_AUTH_IDENTITY
                } END_VALIDATE;

            delete SecurityCredentials;
            return(Status);
            }

        if (ClientAuthInfo.CredentialsMatch(SecurityCredentials) != 0)
            {
            SecurityCredentials->DereferenceCredentials();
            }
        else
            {
            BindingMutex.Request();

            if (ClientAuthInfo.Credentials != 0)
                {
                ClientAuthInfo.Credentials->DereferenceCredentials();
                }

            ClientAuthInfo.Credentials = SecurityCredentials;
            BindingMutex.Clear();
            }

        FastCopyLUIDAligned(&ClientAuthInfo.ModifiedId, &CurrentModifiedId);
        }

      return (RPC_S_OK);

}

RPC_STATUS
BINDING_HANDLE::SetTransportOption( IN unsigned long option,
                                    IN ULONG_PTR     optionValue )
{
    if (option > RPC_C_OPT_MAX_OPTIONS)
        {
        return RPC_S_INVALID_ARG;
        }

    if (OptionsVector == NULL)
        {
        BindingMutex.Request();
        if (OptionsVector == NULL)
            {
            OptionsVector = new ULONG_PTR[ RPC_C_OPT_MAX_OPTIONS ];
            if (OptionsVector == 0)
                {
                BindingMutex.Clear();

                return RPC_S_OUT_OF_MEMORY;
                }

            RpcpMemorySet(OptionsVector, 0, RPC_C_OPT_MAX_OPTIONS * sizeof(OptionsVector[0]) );
            }
        BindingMutex.Clear();
        }

    OptionsVector[option] = optionValue;

    return RPC_S_OK;
}


RPC_STATUS
BINDING_HANDLE::InqTransportOption( IN  unsigned long option,
                                    OUT ULONG_PTR   * pOptionValue )
{
    if (OptionsVector == NULL)
        {
        *pOptionValue = 0;
        }
    else
        {
        *pOptionValue = OptionsVector[option];
        }

    return RPC_S_OK;
}



RPC_STATUS
CALL::Send (
    IN OUT PRPC_MESSAGE Message
    )
/*++
Function Name:Send

Parameters:

Description:

Returns:

--*/
{
    ASSERT(!"improper CCALL member called\n");
    return (RPC_S_CANNOT_SUPPORT) ;
}



RPC_STATUS
CALL::Receive (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned int Size
    )
/*++
Function Name:Receive

Parameters:

Description:

Returns:

--*/
{
    ASSERT(!"improper CCALL member called\n");
    return (RPC_S_CANNOT_SUPPORT) ;
}


RPC_STATUS
CALL::AsyncSend (
    IN OUT PRPC_MESSAGE Message
    )
/*++
Function Name:AsyncSend

Parameters:

Description:

Returns:

--*/
{
    ASSERT(!"improper CCALL member called\n");
    return (RPC_S_CANNOT_SUPPORT) ;
}

RPC_STATUS
CALL::AsyncReceive (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned int Size
    )
/*++
Function Name:AsyncReceive

Parameters:

Description:

Returns:

--*/
{
    ASSERT(!"improper CCALL member called\n");
    return (RPC_S_CANNOT_SUPPORT) ;
}

RPC_STATUS
CALL::AbortAsyncCall (
    IN PRPC_ASYNC_STATE pAsync,
    IN unsigned long ExceptionCode
    )
/*++
Function Name:AbortAsyncCall

Parameters:

Description:

Returns:

--*/
{
    ASSERT(!"improper CCALL member called\n");
    return (RPC_S_CANNOT_SUPPORT) ;
}

void
CALL::ProcessResponse (
    IN BOOL fDirectCall
    )
/*++
Function Name:ProcessResponse

Parameters:

Description:

Returns:

--*/
{
}

void
CALL::FreeAPCInfo (
    IN RPC_APC_INFO *pAPCInfo
    )
/*++
Function Name:FreeAPCInfo

Parameters:

Description:

Returns:

--*/
{
    if (pAPCInfo == &CachedAPCInfo)
        {
        CachedAPCInfoAvailable = 1;
        }
    else
        {
        delete pAPCInfo ;
        }
}


BOOL
CALL::QueueAPC (
    IN RPC_ASYNC_EVENT Event,
    IN void *Context
    )
/*++
Function Name:QueueAPC

Parameters:

Description:

Returns:

--*/
{
    RPC_APC_INFO *pAPCInfo ;
    HANDLE hThread ;

    if (CachedAPCInfoAvailable)
        {
        pAPCInfo = &CachedAPCInfo ;
        CachedAPCInfoAvailable = 0;
        }
    else
        {
        pAPCInfo = new RPC_APC_INFO ;
        }

    if (pAPCInfo == 0)
        {
        return 0 ;
        }

    pAPCInfo->Context = Context;
    pAPCInfo->Event = Event ;
    pAPCInfo->pAsync = pAsync ;
    pAPCInfo->hCall = this ;

    if (pAsync->u.APC.hThread)
        {
        hThread = pAsync->u.APC.hThread ;
        }
    else
        {
        ASSERT(CallingThread != 0);
        hThread = CallingThread->ThreadHandle() ;
        }

    if (!QueueUserAPC(
            (PAPCFUNC) I_RpcAPCRoutine,
            hThread,
            (ULONG_PTR) pAPCInfo))
        {
#if DBG
        PrintToDebugger("RPC: QueueUserAPC failed: %d\n", GetLastError());
#endif
        return 0 ;
        }

    return 1;
}


BOOL
RpcPostMessageWrapper (
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);

typedef BOOL (*RPCPOSTMESSAGE) (
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam);
RPCPOSTMESSAGE RpcPostMessage = RpcPostMessageWrapper;

BOOL
RpcPostMessageWrapper (
    HWND hWnd,
    UINT Msg,
    WPARAM wParam,
    LPARAM lParam)
/*++
Function Name:RpcPostMessageWrapper

Parameters:

Description:

Returns:

--*/
{
    HMODULE hLibrary;

    if (RpcPostMessage == RpcPostMessageWrapper)
        {
        GlobalMutexRequest();
        if (RpcPostMessage == RpcPostMessageWrapper)
            {
            hLibrary = LoadLibrary(RPC_CONST_SSTRING("user32.dll"));
            if (hLibrary == 0)
                {
                GlobalMutexClear();

                return FALSE;
                }

            RpcPostMessage =
                (RPCPOSTMESSAGE) GetProcAddress(hLibrary, "PostMessageW");

            if (RpcPostMessage == 0)
                {
                RpcPostMessage = RpcPostMessageWrapper;
                FreeLibrary(hLibrary);

                GlobalMutexClear();
                return FALSE;
                }
            }
        GlobalMutexClear();
        }

    return RpcPostMessage(hWnd, Msg, wParam, lParam);
}

BOOL
CALL::IssueNotificationEntry (
    IN RPC_ASYNC_EVENT Event
    )
{
    int Retries = 0;

    if (pAsync == 0
        || (Event == RpcCallComplete
            && InterlockedIncrement(&NotificationIssued) > 0))
        {
#if DBG
        PrintToDebugger("RPC: IssueCallCompleteNotification was a no-op\n") ;
#endif
        return 0;
        }

    // An unlikely, but possible race condition - the send thread hasn't
    // yet returned to the NDR code, which means the NdrLock is still held -
    // we cannot issue a notification until it is released, or the
    // client thread cannot complete the call.
    //
    // The send thread may still be executing "above" NDR code if it is issuing
    // a send-complete notification during a pipe call, in which case we should not wait.
    // We also should not wait while issuing a receive-complete notification, since
    // one can issue pulls before the call returns from NDR.
    if (Event == RpcCallComplete)
        {
        while (TRUE)
            {
            if (pAsync->Lock > 0)
                {
                PauseExecution(200);
                // yes, we don't break if the Retries go through the roof -
                // this is just to figure out how many times we have looped
                // on a checked build
                Retries ++;
                }
            else
                break;
            }
        }

    ASSERT(pAsync->Size == RPC_ASYNC_VERSION_1_0);
    LogEvent(SU_SCALL, EV_NOTIFY, CallingThread, this, (ULONG_PTR) pAsync, 1);

    pAsync->Event = Event;

    return 1;
}

BOOL
CALL::IssueNotificationMain (
    IN RPC_ASYNC_EVENT Event
    )
{
    switch (pAsync->NotificationType)
        {
        case RpcNotificationTypeNone:
            break;

        case RpcNotificationTypeHwnd:
            RpcPostMessage(
                           pAsync->u.HWND.hWnd,
                           pAsync->u.HWND.Msg,
                           0,
                           (LPARAM) pAsync) ;
            break;

        case RpcNotificationTypeCallback:
            pAsync->u.NotificationRoutine(pAsync, 0, Event);
            break;

        case RpcNotificationTypeEvent:
            if (!SetEvent(pAsync->u.hEvent))
                {
#if DBG
                PrintToDebugger("RPC: SetEvent failed: %d\n", GetLastError());
#endif
                return 0;
                }
            break;

        case RpcNotificationTypeApc:
            if (!QueueAPC(Event))
                {
#if DBG
                PrintToDebugger("RPC: QueueAPC failed\n");
#endif
                return 0;
                }
            break;

        case RpcNotificationTypeIoc:
            if (!PostQueuedCompletionStatus(
                    pAsync->u.IOC.hIOPort,
                    pAsync->u.IOC.dwNumberOfBytesTransferred,
                    pAsync->u.IOC.dwCompletionKey,
                    pAsync->u.IOC.lpOverlapped))
                {
#if DBG
                PrintToDebugger("RPC: PostQueuedCompletionStatus failed %d\n",
                                GetLastError());
#endif
                return 0;
                }
            break;

        default:
            ASSERT(!"Invalid notification type") ;
            return 0;
        }

    return 1;
}


BOOL
CALL::IssueNotification (
    IN RPC_ASYNC_EVENT Event
    )
/*++
Function Name:IssueNotification

Parameters:

Description:

Returns:

--*/
{
    if (IssueNotificationEntry(Event))
        return IssueNotificationMain(Event);
    else
        return 0;
}


void
CALL::ProcessEvent (
    )
/*++
Function Name:ProcessEvent

Parameters:

Description:

Returns:

--*/
{
    ASSERT(0) ;
}

RPC_STATUS
DispatchCallback(
    IN PRPC_DISPATCH_TABLE DispatchTableCallback,
    IN OUT PRPC_MESSAGE Message,
    OUT RPC_STATUS PAPI * ExceptionCode
    )
/*++

Routine Description:

    This method is used to dispatch remote procedure calls to the
    appropriate stub and hence to the appropriate manager entry point.
    This routine is used for calls having a null UUID (implicit or
    explicit).

Arguments:

    DispatchTableCallback - Callback table.

    Message - Supplies the response message and returns the reply
    message.

    ExceptionCode - Returns the remote exception code if
    RPC_P_EXCEPTION_OCCURED is returned.

Return Value:

    RPC_S_OK - Everything worked just fine.

    RPC_P_EXCEPTION_OCCURED - An exception of some sort occured.  The
    exact exception code will be returned in the ExceptionCode
    argument.

    RPC_S_PROCNUM_OUT_OF_RANGE - The supplied operation number in the
    message is too large.

--*/
{
    RPC_STATUS RpcStatus = RPC_S_OK;
    void PAPI *OriginalBuffer = Message->Buffer;

    //
    // Callbacks are unsafe and on their way towards deprication.
    // When running with the RPC verifier, we should flag their use
    // and issue a warning message.
    //
    if (gfRPCVerifierEnabledWithBreaks)
        {
        RPC_VERIFIER_WARNING_MSG("Possible security threat: Client is dispatching a callback",
                                 RPC_VERIFIER_UNSAFE_FEATURE);
        DbgPrint("RPC: Callback routine: 0x%x\n", DispatchTableCallback->DispatchTable[Message->ProcNum]);
        DbgPrint("RPC: To determine the symbolic name of the callback, do an \"ln\" on the above address in the context of the faulting process.\n\n");
        }

    // N.B. We could reset the flag after sendreceive is completed for
    // each protocol engine
    Message->RpcFlags |= RPC_BUFFER_COMPLETE ;

    if ( Message->ProcNum >= DispatchTableCallback->DispatchTableCount )
        {
        return(RPC_S_PROCNUM_OUT_OF_RANGE);
        }

    Message->ManagerEpv = 0;

    RpcpPurgeEEInfo();

    if ( DispatchToStubInC(DispatchTableCallback->DispatchTable[
        Message->ProcNum], Message, ExceptionCode) != 0 )
        {
        RpcStatus = RPC_P_EXCEPTION_OCCURED;
        }

    if (((MESSAGE_OBJECT *) Message->Handle)->IsSyncCall())
        {
        if (OriginalBuffer == Message->Buffer && RpcStatus == RPC_S_OK)
            {
            //
            // If the stub has NO out data, it may skip the call to
            // I_RpcGetBuffer().  If it called I_RpcGetBuffer and
            // still has the same Buffer, we have a bug!
            //

            Message->BufferLength = 0;
            ((MESSAGE_OBJECT *) Message->Handle)->GetBuffer(Message, 0);
            }
        }

    return(RpcStatus);
}


/* ====================================================================

Client DLL initialization routine.

==================================================================== */

int
InitializeClientDLL (void
    )
{
    // We don't want to do this under DOS. The first time
    // LoadableTransportClientInfo (in tranclnt.cxx) is called, it will
    // perform the appropriate initialization. See the first few lines
    // of that routine for more description.

    if (InitializeLoadableTransportClient() != 0)
        return(1);

    if (InitializeRpcProtocolOfsClient() != 0)
        return(1);

    if (InitializeRpcProtocolDgClient() != 0)
        return(1);

    return(0);
}



RPC_STATUS
BINDING_HANDLE::SetAuthInformation (
    IN RPC_CHAR PAPI * ServerPrincipalName, OPTIONAL
    IN unsigned long AuthenticationLevel,
    IN unsigned long AuthenticationService,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthorizationService,
    IN SECURITY_CREDENTIALS * Credentials,
    IN unsigned long ImpersonationType,
    IN unsigned long IdentityTracking,
    IN unsigned long Capabilities,
    IN BOOL bAcquireNewCredentials, OPTIONAL
    IN ULONG AdditionalTransportCredentialsType, OPTIONAL
    IN void *AdditionalCredentials, OPTIONAL
    IN PSID Sid OPTIONAL
    )
/*++

Routine Description:

    We set the authentication and authorization information in this binding
    handle.

Arguments:

    ServerPrincipalName - Optionally supplies the server principal name.

    AuthenticationLevel - Supplies the authentication level to use.

    AuthenticationService - Supplies the authentication service to use.

    AuthIdentity - Optionally supplies the security context to use.

    AuthorizationService - Supplies the authorization service to use.

    AdditionalTransportCredentialsType  - the type of additional credentials
        supplied in AdditionalCredentials

    AdditionalCredentials - pointer to additional credentials if any

    Sid - the SID to mutually authenticate to

Return Value:

    RPC_S_OK - The supplied authentication and authorization information has
    been set in the binding handle.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete the
    operation.

    RPC_S_UNKNOWN_AUTHN_SERVICE - The specified authentication service is
    not supported.

    RPC_S_UNKNOWN_AUTHN_LEVEL - The specified authentication level is
    not supported.

    RPC_S_INVALID_AUTH_IDENTITY - The specified security context (supplied
    by the auth identity argument) is invalid.

    RPC_S_UNKNOWN_AUTHZ_SERVICE - The specified authorization service is
    not supported.

--*/
{
    RPC_CHAR * NewString;
    RPC_STATUS RpcStatus = RPC_S_OK;
    SECURITY_CREDENTIALS * SecurityCredentials = NULL;
    unsigned long MappedAuthenticationLevel;
    PSID SidToDeleteOnFailure;
    RPC_CHAR *AllocatedSPN;
    BOOL fCachedSid = TRUE;
    RPC_HTTP_TRANSPORT_CREDENTIALS_W *HttpCredentials;

    if ( AuthenticationLevel == RPC_C_AUTHN_LEVEL_DEFAULT )
        {
        RpcpGetDefaultSecurityProviderInfo();
        AuthenticationLevel = DefaultAuthLevel;
        }

    if ( AuthenticationLevel > RPC_C_AUTHN_LEVEL_PKT_PRIVACY )
        {
        return(RPC_S_UNKNOWN_AUTHN_LEVEL);
        }

    MappedAuthenticationLevel = MapAuthenticationLevel(AuthenticationLevel);

    ASSERT( MappedAuthenticationLevel != RPC_C_AUTHN_LEVEL_DEFAULT &&
            MappedAuthenticationLevel <= RPC_C_AUTHN_LEVEL_PKT_PRIVACY );

    //
    // See if this is transport level authentication:
    //

    if (!SetTransportAuthentication( MappedAuthenticationLevel,
                                     AuthenticationService,
                                     &RpcStatus ))
       {
       return RpcStatus;
       }

    RpcStatus = RPC_S_OK;

    //
    // Clear out stuff for NULL AUTHN_SVC
    //

    ASSERT((AdditionalTransportCredentialsType == RPC_C_AUTHN_INFO_TYPE_HTTP)
        || (AdditionalTransportCredentialsType == 0));

    if (AdditionalTransportCredentialsType == RPC_C_AUTHN_INFO_TYPE_HTTP)
        {
        ClientAuthInfo.AdditionalCredentials 
            = DuplicateHttpTransportCredentials (
                (const RPC_HTTP_TRANSPORT_CREDENTIALS_W *) AdditionalCredentials);

        if (ClientAuthInfo.AdditionalCredentials == NULL)
            return RPC_S_OUT_OF_MEMORY;

        HttpCredentials = (RPC_HTTP_TRANSPORT_CREDENTIALS_W *)(ClientAuthInfo.AdditionalCredentials);

        if (HttpCredentials->TransportCredentials)
            {
            // encrypt only if we haven't yet
            if ((HttpCredentials->Flags & RPC_C_HTTP_FLAG_AUTH_IDENTITY_ENCRYPTED) == 0)
                {
                RpcStatus = EncryptAuthIdentity(HttpCredentials->TransportCredentials);
                if (RpcStatus != RPC_S_OK)
                    {
                    FreeAuthIdentity(HttpCredentials->TransportCredentials);
                    return RpcStatus;
                    }
                // remember that the credentials are encrypted now
                HttpCredentials->Flags |= RPC_C_HTTP_FLAG_AUTH_IDENTITY_ENCRYPTED;
                }
            }
        else
            {
            // no credentials were specified this time around - take down the encryption flag
            HttpCredentials->Flags &= ~RPC_C_HTTP_FLAG_AUTH_IDENTITY_ENCRYPTED;
            }
        }
    else
        {
        ASSERT(AdditionalCredentials == NULL);
        }

    if (Sid)
        {
        SidToDeleteOnFailure = DuplicateSID(Sid);
        if (SidToDeleteOnFailure == NULL)
            return RPC_S_OUT_OF_MEMORY;
        }
    else
        {
        RequestGlobalMutex();
        if (ClientAuthInfo.ServerSid)
            {
            delete [] ClientAuthInfo.ServerSid;
            ClientAuthInfo.ServerSid = NULL;
            }
        ClearGlobalMutex();

        // if we were given the local MA hint, we will need a SID anyway - try to resolve
        // it now
        if (Capabilities & RPC_C_QOS_CAPABILITIES_LOCAL_MA_HINT)
            {
            // we must have an SPN here. Caller should have verified that
            ASSERT(ServerPrincipalName);
            RpcStatus = RpcpLookupAccountName (ServerPrincipalName,
                &fCachedSid,
                &SidToDeleteOnFailure);
            if (RpcStatus != RPC_S_OK)
                return RpcStatus;
            }
        else
            SidToDeleteOnFailure = NULL;
        }

    if (AuthenticationService == RPC_C_AUTHN_NONE)
        {
        //
        // Dereference Credentials.. ServerPrincipal Name is
        // handled by deleting CLIENT_AUTH_INFO .. Each AUTH_INFO explicitly
        // copy the credentials around...
        //
        if (ClientAuthInfo.Credentials != 0)
            {
            ClientAuthInfo.Credentials->DereferenceCredentials();
            ClientAuthInfo.Credentials = 0;
            }
        }
    else
        {
        // if we were asked to do normal mutual auth, but were given only a SID (no SPN),
        // then lookup the SPN now. This doesn't apply to SChannel though, because
        // its SPNs cannot be looked up from SIDs for SChannel
        if ( (AuthenticationService != RPC_C_AUTHN_GSS_SCHANNEL)
            && 
             ((ServerPrincipalName == NULL)
             ||
             (ServerPrincipalName[0] == '\0'))
            && (Sid)
            )
            {
            ASSERT(Sid != NULL);
            RpcStatus = RpcpLookupAccountSid (Sid,
                &ServerPrincipalName
                );
            if (RpcStatus != RPC_S_OK)
                {
                delete [] SidToDeleteOnFailure;
                return RpcStatus;
                }
            AllocatedSPN = ServerPrincipalName;
            }
        else
            {
            AllocatedSPN = NULL;
            }

        if (bAcquireNewCredentials == FALSE)
            {
            ASSERT(Credentials);
            Credentials->ReferenceCredentials();
            SecurityCredentials = Credentials;
            }
         else
            {
            SecurityCredentials = new SECURITY_CREDENTIALS(&RpcStatus);
            if ((SecurityCredentials == 0) || (RpcStatus != RPC_S_OK))
                {
                if (SecurityCredentials == 0)
                    {
                    RpcStatus = RPC_S_OUT_OF_MEMORY;
                    }
                delete SecurityCredentials;
                delete [] SidToDeleteOnFailure;
                delete [] AllocatedSPN;
                return (RpcStatus);
                }

            RpcStatus = SecurityCredentials->AcquireCredentialsForClient(
                                        AuthIdentity,
                                        AuthenticationService,
                                        MappedAuthenticationLevel
                                        );
            if ( RpcStatus != RPC_S_OK )
                {
                VALIDATE(RpcStatus)
                    {
                    RPC_S_OUT_OF_MEMORY,
                    RPC_S_UNKNOWN_AUTHN_SERVICE,
                    RPC_S_UNKNOWN_AUTHN_LEVEL,
                    RPC_S_SEC_PKG_ERROR,
                    ERROR_SHUTDOWN_IN_PROGRESS,
                    RPC_S_INVALID_AUTH_IDENTITY
                    } END_VALIDATE;

                delete SecurityCredentials;
                delete [] SidToDeleteOnFailure;
                delete [] AllocatedSPN;
                return(RpcStatus);
                }
            }


        if (ARGUMENT_PRESENT(ServerPrincipalName))
            {
            //
            // SSL has unique SPN requirements.
            //
            if (AuthenticationService == RPC_C_AUTHN_GSS_SCHANNEL)
                {
                RpcStatus = ValidateSchannelPrincipalName(ServerPrincipalName);
                if (RpcStatus != RPC_S_OK)
                    {
                    VALIDATE(RpcStatus)
                        {
                        ERROR_INVALID_PARAMETER
                        }
                    END_VALIDATE;

                    if (SecurityCredentials)
                        SecurityCredentials->DereferenceCredentials();

                    delete [] SidToDeleteOnFailure;
                    ASSERT(AllocatedSPN == NULL);

                    return RpcStatus;
                    }
                }

            if (AllocatedSPN)
                {
                NewString = AllocatedSPN;
                AllocatedSPN = NULL;
                }
            else
                NewString = DuplicateString(ServerPrincipalName);

            if ( NewString == 0 )
                {
                if (SecurityCredentials)
                    SecurityCredentials->DereferenceCredentials();
                delete [] SidToDeleteOnFailure;
                return(RPC_S_OUT_OF_MEMORY);
                }

            RequestGlobalMutex();
            if ( ClientAuthInfo.ServerPrincipalName != 0 )
                {
                delete ClientAuthInfo.ServerPrincipalName;
                }
            ClientAuthInfo.ServerPrincipalName = NewString;
            ClearGlobalMutex();
            }
        else
            {
            RequestGlobalMutex();
            if ( ClientAuthInfo.ServerPrincipalName != 0 )
                {
                delete ClientAuthInfo.ServerPrincipalName;
                }
            ClientAuthInfo.ServerPrincipalName = NULL;
            ClearGlobalMutex();            
            }

        if ( (ClientAuthInfo.Credentials != 0 ) &&
             (ClientAuthInfo.CredentialsMatch(SecurityCredentials) != 0) )
            {
            SecurityCredentials->DereferenceCredentials();
            }
        else
            {
            if (ClientAuthInfo.Credentials != 0)
                {
                ClientAuthInfo.Credentials->DereferenceCredentials();
                }
            ClientAuthInfo.Credentials = SecurityCredentials;
            }


        if (IdentityTracking == RPC_C_QOS_IDENTITY_DYNAMIC)
            {

            RpcStatus = CaptureModifiedId(&ClientAuthInfo.ModifiedId);

            //
            // If The Thread is not impersonating CaptureLogonId fails
            // All failures get treated as if this process is using *default*
            // identity. Mark the AuthId as such and proceed
            //

            if (RpcStatus != RPC_S_OK)
                {
                ClientAuthInfo.DefaultLogonId = TRUE;
                }
            else
                {
                ClientAuthInfo.DefaultLogonId = FALSE;
                }
            }

         }

    ClientAuthInfo.AuthenticationService = AuthenticationService;
    ClientAuthInfo.AuthorizationService = AuthorizationService;
    ClientAuthInfo.AuthIdentity = AuthIdentity;
    ClientAuthInfo.AdditionalTransportCredentialsType 
        = AdditionalTransportCredentialsType;

    if (AuthenticationService == RPC_C_AUTHN_NONE)
        {
        ClientAuthInfo.IdentityTracking  =  RPC_C_QOS_IDENTITY_STATIC;
        ClientAuthInfo.AuthenticationLevel = RPC_C_AUTHN_LEVEL_NONE;
        }
    else
        {
        ClientAuthInfo.AuthenticationLevel = MappedAuthenticationLevel;
        ClientAuthInfo.IdentityTracking  =  IdentityTracking;
        }

    ClientAuthInfo.ImpersonationType =  ImpersonationType;
    ClientAuthInfo.Capabilities      = Capabilities;

    RequestGlobalMutex();
    if (ClientAuthInfo.ServerSid)
        {
        delete [] ClientAuthInfo.ServerSid;
        ClientAuthInfo.ServerSid = NULL;
        }
    ClearGlobalMutex();

    // we didn't fail - copy the sid
    ClientAuthInfo.ServerSid = SidToDeleteOnFailure;

    return(RPC_S_OK);
}

PSID g_pMachineAccountSid = NULL;      // a per-process cache for the machine account sid.
                                    // Once initialized, it never changes. Must be initalized
                                    // in thread safe manner.

RPC_STATUS MachineAccountSidLastError = RPC_S_OK;   // in case of failure to retrieve the machine
                                    // account, the last error will be stored here to avoid
                                    // repeating the failed operation too often.

ULONG MachineAccountLastFailureTickCount = 0;     // the timestamp (as a tick count) of the last
                                    // failure to retrieve the machine account. Using this variable
                                    // we can avoid constant machine account lookups in the failure 
                                    // case.

const ULONG TimeBetweenMachineAccountFailures = 3000;     // in milliseconds

typedef NET_API_STATUS 
(NET_API_FUNCTION *I_NetlogonGetTrustRidFn) 
    (
    IN LPWSTR ServerName OPTIONAL,
    IN LPWSTR DomainName OPTIONAL,
    OUT PULONG Rid
    );

RPC_STATUS GetMachineAccountSid (
    OUT PSID *Sid
    )
/*++

Routine Description:

    Gets the machine account sid. The goal is to minimize perf impact
    and to try to avoid at all costs hitting the network. The following approach
    was chosen with ample input and neat tricks from KahrenT & CliffV.

    If machine is in W2K or higher domain:
         I_NetlogonGetTrustRid( NULL, NULL, &Rid );  (In netapi32.dll) 
         LsaOpenPolicy (local machine policy) 
         LsaQueryInformationPolicy(..., PolicyPrimaryDomainInformation (to use the Sid field) 
         LsaClose 
         Concatenate the primary domain sid from step 3 and the rid from step 1 using 
            NetpDomainIdToSid (in netlib.lib). You could do this step manually or might already 
            have a routine to do it. 

    If machine is in NT4 domain we apply the following logic.
        A. We know this function is called only as part of NormalizeAccountSid.
        B. We know that NormalizeAccountSid only cares about normalizing the domain SID
            of the machine account
        C. We know that NormalizeSid is only called to normalize a SID, not a machine account
            SPN.
        D. We know that machine accounts cannot be translated to domain SIDs in an NT4 domain.
        We know that the SID we had was produced by translation in an NT4 domain cannot be 
        the domain SID of the machine account because of D. We know we have such a SID because
        of A and C. This allows us to conclude that we don't need the machine account in such
        case because of B. Thus in the case of B, we simply return an error we know our caller
        will ignore and thus avoid normalization of the SID in NT4 domain.

    If machine is in NT4 domain, I_NetlogonGetTrustRid will fail with ERROR_NOT_SUPPORTED.

Arguments:

    Sid - on output will contain the machine account Sid. This is a constant
        pointer that callers must not modify or free. Undefined on failure.

Return Value:

    RPC_S_OK or RPC_S_* error.

--*/
{
    HMODULE NetApi32 = NULL;
    I_NetlogonGetTrustRidFn I_NetlogonGetTrustRidFnPtr;
    RPC_STATUS RpcStatus;
    NET_API_STATUS NetStatus;
    ULONG Rid;
    NTSTATUS NtStatus;
	LSA_OBJECT_ATTRIBUTES loa = { sizeof(LSA_OBJECT_ATTRIBUTES), NULL, NULL, 0, NULL, NULL };
    LSA_HANDLE PolicyHandle;
    POLICY_PRIMARY_DOMAIN_INFO *DomainInfo;
    PSID MachineAccountSid;

    // check the cache first
    if (g_pMachineAccountSid)
        {
        *Sid = g_pMachineAccountSid;
        return RPC_S_OK;
        }

    // before we lookup again, check for recent failure. If there is a recent failure,
    // don't try again for TimeBetweenMachineAccountFailures.
    if (MachineAccountSidLastError)
        {
        RTL_SOFT_ASSERT(MachineAccountLastFailureTickCount != 0);
        if (NtGetTickCount() - MachineAccountLastFailureTickCount < TimeBetweenMachineAccountFailures)
            {
            return MachineAccountSidLastError;
            }
        }

    // there was nothing in the cache - go the long route
    PolicyHandle = NULL;
    DomainInfo = NULL;
    MachineAccountSid = NULL;

    NetApi32 = LoadLibrary(RPC_CONST_SSTRING("netapi32.dll"));
    if (NetApi32 == NULL)
        return RPC_S_OUT_OF_MEMORY;

    I_NetlogonGetTrustRidFnPtr = (I_NetlogonGetTrustRidFn)GetProcAddress(NetApi32, "I_NetlogonGetTrustRid");
    if (I_NetlogonGetTrustRidFnPtr == NULL)
        {
        RpcStatus = RPC_S_INTERNAL_ERROR;
        goto CleanupAndExit;
        }

    // get the RID
    NetStatus = I_NetlogonGetTrustRidFnPtr(NULL,    // ServerName
                    NULL,       // DomainName
                    &Rid
                    );

    if (NetStatus != NERR_Success)
        {
        if (NetStatus == RPC_S_UNKNOWN_IF
            || NetStatus == ERROR_ACCESS_DENIED) 
            return NetStatus;

        if (NetStatus == ERROR_NOT_SUPPORTED)
            {
            // we're in NT4 domain - drop the operation altogether as described
            // in the function header
            NetStatus = ERROR_NO_LOGON_SERVERS;
            }

        if ((NetStatus == ERROR_TRUSTED_RELATIONSHIP_FAILURE)
            || (NetStatus == ERROR_NO_LOGON_SERVERS) )
            {
            MachineAccountSidLastError = NetStatus;
            MachineAccountLastFailureTickCount = NtGetTickCount();
            return NetStatus;
            }

        RpcpErrorAddRecord(EEInfoGCRuntime, 
            RPC_S_OUT_OF_MEMORY, 
            EEInfoDLGetMachineAccountSid10,
            NetStatus);

        RpcStatus = RPC_S_OUT_OF_MEMORY;
        goto CleanupAndExit;
        }

    // open the local policy
    NtStatus = LsaOpenPolicy (NULL,     // SystemName
        &loa,       // ObjectAttributes
        POLICY_VIEW_LOCAL_INFORMATION,
        &PolicyHandle
        );

    if (!NT_SUCCESS(NtStatus))
        {
        RpcStatus = RtlNtStatusToDosError(NtStatus);
        RpcpErrorAddRecord(EEInfoGCRuntime, 
            RpcStatus, 
            EEInfoDLGetMachineAccountSid20,
            NtStatus);

        goto CleanupAndExit;
        }

    // get the domain info
    NtStatus = LsaQueryInformationPolicy (PolicyHandle,
        PolicyPrimaryDomainInformation,
        (PVOID *)&DomainInfo
        );
        
    if (!NT_SUCCESS(NtStatus))
        {
        RpcStatus = RtlNtStatusToDosError(NtStatus);
        RpcpErrorAddRecord(EEInfoGCRuntime, 
            RpcStatus, 
            EEInfoDLGetMachineAccountSid30,
            NtStatus);

        goto CleanupAndExit;
        }

    // translate the domain id and the RID to a SID
    NetStatus = NetpDomainIdToSid (DomainInfo->Sid,
        Rid,
        &MachineAccountSid
        );

    if (NetStatus != NERR_Success)
        {
        RpcpErrorAddRecord(EEInfoGCRuntime, 
            RPC_S_OUT_OF_MEMORY, 
            EEInfoDLGetMachineAccountSid40,
            NetStatus);

        RpcStatus = RPC_S_OUT_OF_MEMORY;
        goto CleanupAndExit;
        }

    // we must have the machine account SID here
    ASSERT(MachineAccountSid);
    if (InterlockedCompareExchangePointer(&g_pMachineAccountSid,
            MachineAccountSid,
            NULL) != NULL)
        {
        // somebody beat us to the punch - free the memory and return
        // the cached value
        NetpMemoryFree(MachineAccountSid);
        }

    *Sid = g_pMachineAccountSid;

    MachineAccountSidLastError = RPC_S_OK;

    RpcStatus = RPC_S_OK;

CleanupAndExit:
    if (NetApi32 != NULL)
        FreeLibrary(NetApi32);

    if (PolicyHandle)
        {
        NtStatus = LsaClose(PolicyHandle);
        // The underlying context handle may be invalidated under
        // corruption injection.
        CORRUPTION_ASSERT(NT_SUCCESS(NtStatus));
        }

    if (DomainInfo)
        LsaFreeMemory(DomainInfo);

    return RpcStatus;
}

RPC_STATUS NormalizeAccountSid (
    IN PSID Sid,
    OUT PSID *NormalizedSid,
    IN OUT int *RetryCount
    )
/*++

Routine Description:

    Takes a sid and normalizes it. This involves checking for the machine account
        sid, and if a match is found, translating it to a local system, local service
        or network service SID. If not translation is necessary, the normalized sid 
        will be the input sid.

Arguments:

    Sid - on input, the sid that we are trying to normalize

    NormalizedSid - on output will contain the normalized Sid. This can be a constant
        pointer that callers must not modify or free. Undefined on failure.

    RetryCount - keeps the number of retries to normalize the SID. Caller initializes
        the count to 0 on first call, and this function keeps updating it on each
        retry. If the function sets it to 0 on output, it cannot do any more retries.
        This is necessary because the local machine account sid can be local system,
        network service or local service (S-1-5-18, S-1-5-20 or S-1-5-19) respectively.

Return Value:

    RPC_S_OK or RPC_S_* error.

--*/
{
    PSID MachineAccountSid;
    RPC_STATUS RpcStatus;

    RpcStatus = GetMachineAccountSid (&MachineAccountSid);
    if (RpcStatus != RPC_S_OK)
        {
        // if netlogon hasn't started yet, or isn't configured to run, or
        // the DC cannot be contacted, or we do not have enough priveleges to
        // retrieve the machine account - we cannot retrieve the machine account, 
        // and therefore, we will return the original Sid
        if ((RpcStatus == RPC_S_UNKNOWN_IF) 
            || (RpcStatus == ERROR_TRUSTED_RELATIONSHIP_FAILURE)
            || (RpcStatus == ERROR_NO_LOGON_SERVERS)
            || (RpcStatus == ERROR_ACCESS_DENIED))
            {
            *NormalizedSid = Sid;
            *RetryCount = 0;
            return RPC_S_OK;
            }

#if DBG
        DbgPrint("RPCRT4: %X: NormalizeAccountSid: Failed to obtain machine account sid: %X\n", 
            GetCurrentProcessId(), RpcStatus);
#endif  // DBG
        return RpcStatus;
        }

    if (EqualSid(MachineAccountSid, Sid))
        {
        switch (*RetryCount)
            {
            case 0:
                *NormalizedSid = (PSID)&LocalSystem;
                (*RetryCount) ++;
                break;

            case 1:
                *NormalizedSid = (PSID)&LocalService;
                (*RetryCount) ++;
                break;

            case 2:
                *NormalizedSid = (PSID)&NetworkService;
                *RetryCount = 0;
                break;

            default:
                ASSERT(!"Invalid RetryCount passed to NormalizeAccountSid");
            }
        }
    else
        {
        *RetryCount = 0;
        *NormalizedSid = Sid;
        }

    return RPC_S_OK;
}

const RPC_SYNTAX_IDENTIFIER NDR20TransferSyntaxValue
    = {{0x8A885D04, 0x1CEB, 0x11C9, {0x9F, 0xE8, 0x08, 0x00, 0x2B, 0x10, 0x48, 0x60}}, {2, 0}};
const RPC_SYNTAX_IDENTIFIER *NDR20TransferSyntax = &NDR20TransferSyntaxValue;

const RPC_SYNTAX_IDENTIFIER NDR64TransferSyntaxValue
    = {{0x71710533, 0xBEBA, 0x4937, {0x83, 0x19, 0xB5, 0xDB, 0xEF, 0x9C, 0xCC, 0x36}}, {1, 0}};
const RPC_SYNTAX_IDENTIFIER *NDR64TransferSyntax = &NDR64TransferSyntaxValue;

const RPC_SYNTAX_IDENTIFIER NDRTestTransferSyntaxValue
    = {{0xb4537da9, 0x3d03, 0x4f6b, {0xb5, 0x94, 0x52, 0xb2, 0x87, 0x4e, 0xe9, 0xd0}}, {1, 0}};
const RPC_SYNTAX_IDENTIFIER *NDRTestTransferSyntax = &NDRTestTransferSyntaxValue;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\locks.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    Locks.cxx

Abstract:

    Out of line methods for some of the syncronization classes
    defined in locks.hxx.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     03-14-95    Moved from misc.cxx.
    MarioGo     01-27-96    Changed from busy (Sleep(0)) wait to event

--*/

#include <precomp.hxx>
#include <locks.hxx>

//
// CShareLock methods
//


#if defined(NTENV) && !defined(_WIN64)
// extern DWORD GetCurrentThreadId(void);
#define GetCurrentThreadId() ((DWORD)NtCurrentTeb()->ClientId.UniqueThread)
#endif

CSharedLock::CSharedLock(RPC_STATUS &status)
{
    exclusive_owner = 0;
    writers = 0;
    hevent = INVALID_HANDLE_VALUE;  // Flag in the d'tor
    recursion_count = 0;

    if (status == RPC_S_OK)
        {
        __try
            {
            InitializeCriticalSection(&lock);
            }
        __except( GetExceptionCode() == STATUS_NO_MEMORY )
            {
            status = RPC_S_OUT_OF_MEMORY;
            }
    
        if (status == RPC_S_OK)
            {
            hevent = CreateEvent(0, FALSE, FALSE, 0);
            if (0 == hevent)
                {
                status = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
        }
}

CSharedLock::~CSharedLock()
{
    if (hevent != INVALID_HANDLE_VALUE)
        {
        DeleteCriticalSection(&lock);

        if (hevent) CloseHandle(hevent);
        }
}

void
CSharedLock::LockShared()
{
    // If the current thread owns this lock exclusively, then taking
    // a shared lock is just a no-op.
    readers++;

    LogEvent(SU_MUTEX, EV_INC, this, 0, readers);

    if (!HeldExclusive())
        {
        if (writers)
            {
            if ((readers--) == 0)
                {
                SetEvent(hevent);
                }

            EnterCriticalSection(&lock);
            readers++;
            LeaveCriticalSection(&lock);
            }
            ASSERT(exclusive_owner == 0);
        }
}

void
CSharedLock::UnlockShared(void)
{
    if (HeldExclusive())
        {
        ASSERT((LONG)readers > 0);

        readers--;
        }
    else
        {
        ASSERT((LONG)readers > 0);
        ASSERT(exclusive_owner == 0);

        if ( (readers--) == 0 && writers)
            {
            SetEvent(hevent);
            }
        }
    LogEvent(SU_MUTEX, EV_DEC, this, 0, readers);
}

void
CSharedLock::LockExclusive(void)
{
    EnterCriticalSection(&lock);

    // If the thread is an exclusive owner then a recursive lock
    // is a no-op.
    if (HeldExclusive())
        {
        LogEvent(SU_MUTEX, EV_INC, this, ULongToPtr(0x99999999), writers+1);
        }
    else
        {
        LogEvent(SU_MUTEX, EV_INC, this, ULongToPtr(0x99999999), writers+1);

        writers++;
        while(readers)
            {
            WaitForSingleObject(hevent, INFINITE);
            }
        ASSERT(writers);
        exclusive_owner = GetCurrentThreadId();
        }

    recursion_count++;
}

void
CSharedLock::UnlockExclusive(void)
{
    LogEvent(SU_MUTEX, EV_DEC, this, ULongToPtr(0x99999999), writers-1);
    ASSERT(HeldExclusive());
    ASSERT(writers);
    ASSERT(recursion_count >= 1);

    recursion_count--;

    // If the lock is held recursively, then releasing it is a no-op.
    if (recursion_count == 0)
        {
        exclusive_owner = 0;
        writers--;
        LeaveCriticalSection(&lock);
        }
}

void
CSharedLock::Unlock()
{
    // Either the lock is held exclusively by this thread or the thread
    // has a shared lock. (or the caller has a bug).

    if (HeldExclusive())
        {
        UnlockExclusive();
        }
    else
        {
        UnlockShared();
        }
}

void
CSharedLock::ConvertToExclusive(void)
{
    // If a shared lock is held recursively with an exclusive lock,
    // all that's needed is to unlock the shared lock and take an exclusive lock.
    if (HeldExclusive())
        {
        UnlockShared();
        LockExclusive();
        }
    else
        {
        ASSERT((LONG)readers > 0);
        ASSERT(exclusive_owner == 0);

        if ( (readers--) == 0 && writers )
            SetEvent(hevent);

        EnterCriticalSection(&lock);
        writers++;
        while(readers)
            {
            WaitForSingleObject(hevent, INFINITE);
            }
        ASSERT(writers);
        exclusive_owner = GetCurrentThreadId();

        recursion_count++;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\lpcclnt.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    lpcclnt.cxx

Abstract:

    Implementation of the RPC on LPC protocol engine for the client.

Revision History:
    Mazhar Mohammed: Code fork from spcclnt.cxx, 08/02/95

    Tony Chan: Added Singled Security Model, 12/15/95

    Mazhar Mohammed  Merged WMSG and LRPC into a single protocol 05-06-96
    Mazhar Mohammed  Added Pipes Support
    Mazhar Mohammed  Added support for Async RPC 08-14-96
    Kamen Moutafov      (KamenM)    Jan-2000            Support for multiple transfer syntaxes
    Kamen Moutafov      (KamenM) Dec 99 - Feb 2000      Support for cell debugging stuff
    Kamen Moutafov      (KamenM)    Mar-2000            Support for extended error info
--*/

#include <precomp.hxx>
#include <limits.h>
#include <rpcqos.h>
#include <queue.hxx>
#include <lpcpack.hxx>
#include <hndlsvr.hxx>
#include <lpcsvr.hxx>
#include <ProtBind.hxx>
#include <lpcclnt.hxx>
#include <epmap.h>
#include <sidcache.hxx>
#include <CharConv.hxx>

// These need to be the same because client and server will be receiving lpc
// reply messages into LRPC_MESSAGE structures and they must have sufficient space.
C_ASSERT(sizeof(LRPC_MESSAGE) == PORT_MAXIMUM_MESSAGE_LENGTH);

// This is a sanity check to make sure as we modify the format of the
// bind message we leave enough space for the old security contexts.
C_ASSERT(MAX_LRPC_CONTEXTS >= 8);

const SECURITY_IMPERSONATION_LEVEL RpcToNtImp[] =
{
    // RPC_C_IMP_LEVEL_DEFAULT
    SecurityImpersonation,

    // RPC_C_IMP_LEVEL_ANONYMOUS
    SecurityAnonymous,

    // RPC_C_IMP_LEVEL_IDENTIFY
    SecurityIdentification,

    //RPC_C_IMP_LEVEL_IMPERSONATE
    SecurityImpersonation,

    //RPC_C_IMP_LEVEL_DELEGATE
    SecurityDelegation
};

const unsigned long NtToRpcImp[] =
{
    //SecurityAnonymous,
    RPC_C_IMP_LEVEL_ANONYMOUS,

    //SecurityIdentification,
    RPC_C_IMP_LEVEL_IDENTIFY,

    // SecurityImpersonation,
    RPC_C_IMP_LEVEL_IMPERSONATE,

    //SecurityDelegation
    RPC_C_IMP_LEVEL_DELEGATE
};

SECURITY_IMPERSONATION_LEVEL
MapRpcToNtImp (
    IN unsigned long ImpersonationType
   )
{
    if (ImpersonationType <= RPC_C_IMP_LEVEL_DELEGATE)
        {
        return RpcToNtImp[ImpersonationType];
        }

    ASSERT(0) ;
    return SecurityImpersonation ;
}

unsigned long
MapNtToRpcImp (
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    )
{
    if (ImpersonationLevel <= SecurityDelegation)
        {
        return NtToRpcImp[ImpersonationLevel];
        }

    ASSERT(0);
    return RPC_C_IMP_LEVEL_IMPERSONATE;
}

RPC_STATUS
InitializeLrpcIfNecessary(
   ) ;

RPC_STATUS
InitializeAsyncLrpcIfNecessary (
    )
/*++

Routine Description:

    We need to perform the required initialization for Async RPC to
    work. If we currently don't have a listening thread. We need to
    add a note in the docs that if the app ever plans to start a
    listening thread on the client (ie: become a server),
    it should do it before it makes the first Async RPC call. This is
    not a requirement, it is just an effeciency consideration.

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/
{
    RPC_STATUS Status;

    Status = InitializeLrpcIfNecessary();
    if (Status != RPC_S_OK)
        {
#if DBG
        PrintToDebugger("LRPC: InitializeLrpcIfNecessary failed: %x\n", Status) ;
#endif
        return RPC_S_OUT_OF_MEMORY ;
        }

    return GlobalLrpcServer->InitializeAsync();
}


LRPC_BINDING_HANDLE::LRPC_BINDING_HANDLE (
    OUT RPC_STATUS * Status
    ) : BINDING_HANDLE (Status),
    BindingReferenceCount(1)
/*++

Routine Description:

    We just allocate an LRPC_BINDING_HANDLE and initialize things so that
    we can use it later.

Arguments:

    Status - Returns the result of initializing the binding mutex.

--*/
{
    BindingMutex.SetSpinCount(4000);
    ObjectType = LRPC_BINDING_HANDLE_TYPE;
    CurrentAssociation = 0;
    DceBinding = 0;
    AuthInfoInitialized = 0;
    StaticTokenHandle = 0;
    EffectiveOnly = TRUE;
}


LRPC_BINDING_HANDLE::~LRPC_BINDING_HANDLE (
    )
/*++

--*/
{
    LRPC_CASSOCIATION *Association;
    DictionaryCursor cursor;

    if (SecAssociation.Size() != 0)
        {
        SecAssociation.Reset(cursor);
        while ((Association  = SecAssociation.Next(cursor)) != 0)
            {
            if (Association != 0)
                {
                // take away from the bindinghandle dictionary
                RemoveAssociation(Association);
                // take away from the global dict
                Association->RemoveBindingHandleReference();
                }
            }
        }

    delete DceBinding;

    if (StaticTokenHandle)
        {
        CloseHandle(StaticTokenHandle);
        }
}

RPC_STATUS
LRPC_BINDING_HANDLE::NegotiateTransferSyntax (
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:

Arguments:

    Message - Supplies the length of the buffer required, and returns the
        new buffer.

Return Value:


--*/
{
    LRPC_CCALL * CCall;
    RPC_STATUS Status;
    int  RetryCount = 0;
    static long  nInitialized = -1 ;
    LRPC_CASSOCIATION *Association ;
    DictionaryCursor cursor;

    for (;;)
        {
        for (;;)
            {
            Status = AllocateCCall(&CCall, (RPC_CLIENT_INTERFACE  *)
                                Message->RpcInterfaceInformation,
                                Message);
            if (Status != RPC_S_SERVER_UNAVAILABLE)
                {
                break;
                }
            if (!fDynamicEndpoint)
                {
                break;
                }

            // If we reach here, it means that we are iterating through the
            // list of endpoints obtained from the endpoint mapper.

            BindingMutex.Request() ;
            if (BindingReferenceCount.GetInteger() == 1)
                {
                if (SecAssociation.Size() != 0)
                    {
                    DceBinding = CurrentAssociation->DuplicateDceBinding();
                    if(DceBinding == 0)
                        {
                        BindingMutex.Clear() ;

                        return(RPC_S_OUT_OF_MEMORY);
                        }
                    CurrentAssociation = 0;
                    DceBinding->MaybeMakePartiallyBound(
                        (PRPC_CLIENT_INTERFACE)Message->RpcInterfaceInformation,
                        InqPointerAtObjectUuid());

                    if ( *InquireEpLookupHandle() != 0 )
                        {
                        EpFreeLookupHandle(*InquireEpLookupHandle());
                        *InquireEpLookupHandle() = 0;
                        }

                    // remove references
                    SecAssociation.Reset(cursor);
                    while((Association  = SecAssociation.Next(cursor)) != 0)
                        {
                        if (Association != 0)
                            {
                            // in the AssociationDict all DceBinding should be the same
                            // may be we can take out this line. or remove ref
                            // on the first Association
                            RemoveAssociation(Association);
                            Association->RemoveReference();
                            }
                        }
                    }
                }

            BindingMutex.Clear() ;

            RetryCount ++;
            if (RetryCount > 2)
                {
                break;
                }

            RpcpPurgeEEInfo();
            }

        if (Status == RPC_S_OK)
            {
            break;
            }

        if (InqComTimeout() != RPC_C_BINDING_INFINITE_TIMEOUT)
            {
            return(Status);
            }

        if ((Status != RPC_S_SERVER_UNAVAILABLE)
            && (Status != RPC_S_SERVER_TOO_BUSY))
            {
            return(Status);
            }
        }

    Message->TransferSyntax = CCall->Binding->GetTransferSyntaxId();
    Message->Handle = CCall;
    return RPC_S_OK;
}


RPC_STATUS
LRPC_BINDING_HANDLE::GetBuffer (
    IN OUT PRPC_MESSAGE Message,
    IN UUID *ObjectUuid
    )
/*++

Routine Description:

Arguments:

    Message - Supplies the length of the buffer required, and returns the
        new buffer.

Return Value:


--*/
{
    ASSERT(!"We should never be here - the binding handle cannot allocate a buffer");
    return RPC_S_INTERNAL_ERROR;
}


RPC_STATUS
LRPC_BINDING_HANDLE::BindingCopy (
    OUT BINDING_HANDLE *  * DestinationBinding,
    IN unsigned int MaintainContext
    )
/*++

Routine Description:

    We will make a copy of this binding handle in one of two ways, depending
    on whether on not this binding handle has an association.

Arguments:

    DestinationBinding - Returns a copy of this binding handle.

    MaintainContext - Supplies a flag that indicates whether or not context
        is being maintained over this binding handle.  A non-zero value
        indicates that context is being maintained.

Return Value:

    RPC_S_OK - This binding handle has been successfully copied.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to make a copy
        of this binding handle.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    LRPC_BINDING_HANDLE * NewBindingHandle;
    CLIENT_AUTH_INFO * AuthInfo;
    LRPC_CASSOCIATION *SecAssoc;
    DictionaryCursor cursor;
    int Key;

    UNUSED(MaintainContext);

    NewBindingHandle = new LRPC_BINDING_HANDLE(&Status);
    if (NewBindingHandle == 0)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    if (Status != RPC_S_OK)
        {
        delete NewBindingHandle;
        return(Status);
        }

    BindingMutex.Request();
    
    Status = NewBindingHandle->BINDING_HANDLE::BaseClone(this);
    if (Status != RPC_S_OK)
        {
        delete NewBindingHandle;
        BindingMutex.Clear();
        return(Status);
        }

    NewBindingHandle->fDynamicEndpoint = fDynamicEndpoint;

    if ((AuthInfo = InquireAuthInformation()) != 0)
        {
        Status = NewBindingHandle->SetAuthInformation(
                                AuthInfo->ServerPrincipalName,
                                AuthInfo->AuthenticationLevel,
                                AuthInfo->AuthenticationService,
                                NULL,
                                AuthInfo->AuthorizationService,
                                0,
                                AuthInfo->ImpersonationType,
                                AuthInfo->IdentityTracking,
                                AuthInfo->Capabilities,
                                FALSE,      // bAcquireNewCredentials
                                AuthInfo->AdditionalTransportCredentialsType,
                                AuthInfo->AdditionalCredentials,
                                AuthInfo->ServerSid
                                );

        if (Status != RPC_S_OK)
            {
            ASSERT (Status == RPC_S_OUT_OF_MEMORY);
            delete NewBindingHandle;
            BindingMutex.Clear();
            return(RPC_S_OUT_OF_MEMORY);
            }
        }


    if (SecAssociation.Size() == 0)
        {
        NewBindingHandle->DceBinding = DceBinding->DuplicateDceBinding();
        if (NewBindingHandle->DceBinding == 0)
            {
            BindingMutex.Clear() ;
            delete NewBindingHandle;
            return(RPC_S_OUT_OF_MEMORY);
            }
        }
    else
        {
        // copy all sec associations
        SecAssociation.Reset(cursor);
        while((SecAssoc = SecAssociation.Next(cursor)) != 0)
            {
            Key = NewBindingHandle->AddAssociation(SecAssoc);
            if (Key == -1)
                {
                BindingMutex.Clear() ;
                delete NewBindingHandle;
                return (RPC_S_OUT_OF_MEMORY);
                }
            SecAssoc->DuplicateAssociation();
            }

        // since the CurrentAssociation is in the SecAssociation dictionary,
        // it should have already been copied. Just assign it
        NewBindingHandle->CurrentAssociation = CurrentAssociation;
        }
    BindingMutex.Clear();

    *DestinationBinding = (BINDING_HANDLE *) NewBindingHandle;
    return(RPC_S_OK);
}


RPC_STATUS
LRPC_BINDING_HANDLE::BindingFree (
    )
/*++

Routine Description:

    When the application is done with a binding handle, this routine will
    get called.

Return Value:

    RPC_S_OK - This operation always succeeds.

--*/
{
    int LocalRefCount;

    LocalRefCount = BindingReferenceCount.Decrement();

    if (LocalRefCount == 0)
        {
        delete this;
        }

    return(RPC_S_OK);
}


RPC_STATUS
LRPC_BINDING_HANDLE::PrepareBindingHandle (
    IN TRANS_INFO  * TransportInformation,
    IN DCE_BINDING * DceBinding
    )
/*++

Routine Description:

    This method will be called just before a new binding handle is returned
    to the user.  We just stack the binding information so that we can use
    it later when the first remote procedure call is made.  At that time,
    we will actually bind to the interface.

Arguments:

    TransportInformation - Unused.

    DceBinding - Supplies the binding information for this binding handle.

--*/
{
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    RPC_STATUS Status;

    UNUSED(TransportInformation);

    if (DceBinding->InqNetworkOptions() != 0 &&
        DceBinding->InqNetworkOptions()[0] != 0)
        {
        Status = I_RpcParseSecurity(DceBinding->InqNetworkOptions(),
                           &SecurityQualityOfService);
        if (Status != RPC_S_OK)
            {
            ASSERT(Status == RPC_S_INVALID_NETWORK_OPTIONS);
            return(Status);
            }

        Status = SetAuthInformation(NULL,
                                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                    RPC_C_AUTHN_WINNT,
                                    NULL,
                                    NULL,
                                    0,
                                    MapNtToRpcImp(SecurityQualityOfService.ImpersonationLevel),
                                    SecurityQualityOfService.ContextTrackingMode,
                                    RPC_C_QOS_CAPABILITIES_DEFAULT,
                                    TRUE);
        if (Status != RPC_S_OK)
            {
            return Status;
            }
        EffectiveOnly = SecurityQualityOfService.EffectiveOnly;
        }

    this->DceBinding = DceBinding;
    fDynamicEndpoint = DceBinding->IsNullEndpoint();

    return RPC_S_OK;
}


RPC_STATUS
LRPC_BINDING_HANDLE::ToStringBinding (
    OUT RPC_CHAR  *  * StringBinding
    )
/*++

Routine Description:

    We need to convert the binding handle into a string binding.  If the
    handle is unbound, use the DceBinding directly, otherwise, get it from
    the association.

Arguments:

    StringBinding - Returns the string representation of the binding
        handle.

Return Value:

    RPC_S_OK - The binding handle has successfully been converted into a
        string binding.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate the
        string.

--*/
{
    if (CurrentAssociation == 0)
        {
        *StringBinding = DceBinding->StringBindingCompose(
                InqPointerAtObjectUuid());
        }
    else
        {
        *StringBinding = CurrentAssociation->StringBindingCompose(
                InqPointerAtObjectUuid());
        }

    if (*StringBinding == 0)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    return(RPC_S_OK);
}


RPC_STATUS
LRPC_BINDING_HANDLE::ResolveBinding (
    IN RPC_CLIENT_INTERFACE  * RpcClientInterface
    )
/*++

Routine Description:

    We need to try and resolve the endpoint for this binding handle
    if necessary (the binding handle is partially-bound).  If there is
    isn't a association allocated, call the binding management routines
    to do it.

Arguments:

    RpcClientInterface - Supplies interface information to be used
        in resolving the endpoint.

Return Value:

    RPC_S_OK - This binding handle is a full resolved binding handle.

    RPC_S_NO_ENDPOINT_FOUND - The endpoint can not be resolved.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to resolve
        the endpoint.

    EPT_S_NOT_REGISTERED  - There are no more endpoints to be found
        for the specified combination of interface, network address,
        and lookup handle.

    EPT_S_CANT_PERFORM_OP - The operation failed due to misc. error e.g.
        unable to bind to the EpMapper.

--*/
{
    RPC_STATUS Status;

    if (CurrentAssociation == 0)
        {
        BindingMutex.Request();
        Status = DceBinding->ResolveEndpointIfNecessary(
                RpcClientInterface, 
                InqPointerAtObjectUuid(),
                InquireEpLookupHandle(), 
                FALSE, 
                InqComTimeout(), 
                INFINITE,    // CallTimeout
                NULL                        // AuthInfo
                );
        BindingMutex.Clear();
        return(Status);
        }

    return(RPC_S_OK);
}


RPC_STATUS
LRPC_BINDING_HANDLE::BindingReset (
    )
/*++

Routine Description:

    This routine will set the endpoint of this binding handle to zero,
    if possible.  The binding handle will become partially bound as a
    result.  If a remote procedure call has been made on this binding
    handle, it will fail as well.

Return Value:

    RPC_S_OK - The binding handle has successfully been made partially
        bound.

    RPC_S_WRONG_KIND_OF_BINDING - The binding handle currently has remote
        procedure calls active.

--*/
{
    LRPC_CASSOCIATION *Association ;
    DictionaryCursor cursor;

    BindingMutex.Request() ;
    if (CurrentAssociation != 0)
        {
        if (BindingReferenceCount.GetInteger() != 1)
            {
            BindingMutex.Clear() ;
            return(RPC_S_WRONG_KIND_OF_BINDING);
            }

        DceBinding = CurrentAssociation->DuplicateDceBinding();
        if(DceBinding == 0)
            {
            BindingMutex.Clear() ;
            return(RPC_S_OUT_OF_MEMORY);
            }
        CurrentAssociation = 0;
        SecAssociation.Reset(cursor);
        while((Association  = SecAssociation.Next(cursor)) != 0)
            {
            RemoveAssociation(Association);
            Association->RemoveBindingHandleReference();
            }
        }

    fDynamicEndpoint = TRUE;
    DceBinding->MakePartiallyBound();

    if (*InquireEpLookupHandle() != 0)
        {
        EpFreeLookupHandle(*InquireEpLookupHandle());
        *InquireEpLookupHandle() = 0;
        }

    BindingMutex.Clear() ;
    return(RPC_S_OK);
}


void
LRPC_BINDING_HANDLE::FreeCCall (
    IN LRPC_CCALL * CCall
    )
/*++

Routine Description:

    This routine will get called to notify this binding handle that a remote
    procedure call on this binding handle has completed.

Arguments:

    CCall - Supplies the remote procedure call which has completed.

--*/
{
    int LocalRefCount;

    CCall->InqAssociation()->FreeCCall(CCall);

    // do not touch the association beyond this. It could be freed.

    LocalRefCount = BindingReferenceCount.Decrement();

    if (LocalRefCount == 0)
        {
        delete this;
        }
}


RPC_STATUS
LRPC_BINDING_HANDLE::AllocateCCall (
    OUT LRPC_CCALL ** CCall,
    IN PRPC_CLIENT_INTERFACE RpcInterfaceInformation,
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:

    This method will allocate an LRPC_CCALL which has been bound to the
    interface specified by the interface information.  First, we have got
    to see if we have an association for this binding.  If not, we need
    to find or create one.  Before we can find or create an association,
    we need to resolve the endpoint if necessary.  Next we need to see
    if there is already an LRPC_CCALL allocated for this interface and
    thread.  Otherwise, we need to ask the association to allocate a
    LRPC_CCALL for us.

Arguments:

    CCall - Returns the allocated LRPC_CCALL which has been bound to
        the interface specified by the rpc interface information.

    RpcInterfaceInformation - Supplies information describing the
        interface to which we wish to bind.

Return Value:


--*/
{
    RPC_STATUS Status;
    BOOL Boolean;
    BOOL FoundSameAuthInfo = FALSE;
    LRPC_CASSOCIATION * Association;
    LRPC_CASSOCIATION *MyAssociation = NULL;
    DictionaryCursor cursor;
    int LocalRefCount;
    BOOL Supported;

    BindingMutex.Request();

    if (AuthInfoInitialized == 0)
        {
        Status = SetAuthInformation(NULL,
                                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                    RPC_C_AUTHN_WINNT,
                                    NULL,
                                    NULL,
                                    0,
                                    RPC_C_IMP_LEVEL_IMPERSONATE,
                                    RPC_C_QOS_IDENTITY_DYNAMIC,
                                    RPC_C_QOS_CAPABILITIES_DEFAULT,
                                    TRUE);
        if (Status != RPC_S_OK)
            {
            BindingMutex.Clear();
            return Status;
            }
        }

    // First we need to check if there is already a call active for this
    // thread and interface.  To make the common case quicker, we will check
    // to see if there are any calls in the dictionary first.

    if (RecursiveCalls.Size() != 0)
        {
        RecursiveCalls.Reset(cursor);
        while ((*CCall = RecursiveCalls.Next(cursor)) != 0)
            {
            if ((*CCall)->IsThisMyActiveCall(
                                             GetThreadIdentifier(),
                                             RpcInterfaceInformation) != 0)
                {
                BindingMutex.Clear();
                return(RPC_S_OK);
                }
            }
        }

    // To start off, see if the binding handle points to an association
    // yet.  If not, we have got to get one.

    if (CurrentAssociation == 0)
        {
        // Before we even bother to find or create an association, lets
        // check to make sure that we are on the same machine as the server.

        ASSERT(DceBinding->InqNetworkAddress() != 0);

        if (DceBinding->InqNetworkAddress()[0] != 0)
            {
            if (RpcpStringCompareInt(DceBinding->InqNetworkAddress(),
                                     gLocalComputerName) != 0)
                {
                BindingMutex.Clear();
                RpcpErrorAddRecord(EEInfoGCRuntime, 
                    RPC_S_SERVER_UNAVAILABLE,
                    EEInfoDLLRPC_BINDING_HANDLE__AllocateCCall10,
                    DceBinding->InqNetworkAddress(),
                    gLocalComputerName);
                return(RPC_S_SERVER_UNAVAILABLE);
                }
            }

        if (DceBinding->IsNullEndpoint())
            {
            LrpcMutexRequest();
            MyAssociation = FindOrCreateLrpcAssociation(
                                           DceBinding,
                                           InquireAuthInformation(),
                                           RpcInterfaceInformation);
            LrpcMutexClear();

            // don't do anything in the both success and failure
            // case. In failure case we'll try full endpoint resolution
            // In success case, we leave FoundSameAuthInfo to be FALSE,
            // and the code below will figure out we have something
            // in MyAssociation and will do the housekeeping tasks
            // associated with finding an association
            ASSERT(DceBinding);
            }

        if (!MyAssociation)
            {
            Status = DceBinding->ResolveEndpointIfNecessary(
                    RpcInterfaceInformation, 
                    InqPointerAtObjectUuid(),
                    InquireEpLookupHandle(), 
                    FALSE, 
                    InqComTimeout(), 
                    INFINITE,    // CallTimeout
                    &ClientAuthInfo             // AuthInfo
                    );
            if (Status != RPC_S_OK)
                {
                BindingMutex.Clear();

                RpcpErrorAddRecord(EEInfoGCRuntime, 
                    Status,
                    EEInfoDLLRPC_BINDING_HANDLE__AllocateCCall20,
                    RpcInterfaceInformation->InterfaceId.SyntaxGUID.Data1);
                return(Status);
                }
            }
        }
    else
        {
        Status = CurrentAssociation->IsSupportedAuthInfo(InquireAuthInformation(),
                &Supported);
        if (Status != RPC_S_OK)
            {
            BindingMutex.Clear();
            return(Status);
            }

        if (Supported)
            {
            MyAssociation = CurrentAssociation ;
            FoundSameAuthInfo = TRUE;
            }
        else
            {
            SecAssociation.Reset(cursor);
            while ((Association = SecAssociation.Next(cursor)) != 0)
                {
                Status = Association->IsSupportedAuthInfo(InquireAuthInformation(),
                    &Supported);
                if (Status != RPC_S_OK)
                    {
                    BindingMutex.Clear();
                    return(Status);
                    }

                if(Supported)
                    {
                    MyAssociation = Association ;
                    FoundSameAuthInfo = TRUE;
                    break;
                    }
                }
            }
        }

    if (FoundSameAuthInfo == FALSE)
        {
        // we have some association in the dictionary, check for security level
        if (DceBinding == 0)
            {
            SecAssociation.Reset(cursor);
            Association  = SecAssociation.Next(cursor);
            // it will get deleted when Assoc goes
            DceBinding = Association->DuplicateDceBinding();
            if(DceBinding == 0)
                {
                BindingMutex.Clear() ;

                return(RPC_S_OUT_OF_MEMORY);
                }
            }

        // if we still haven't found the association
        // (may do so during the interface based search for
        // an endpoint).
        if (!MyAssociation)
            {
            LrpcMutexRequest();
            MyAssociation = FindOrCreateLrpcAssociation(
                                           DceBinding,
                                           InquireAuthInformation(),
                                           NULL);
            LrpcMutexClear();
            }

        if (CurrentAssociation == 0)
            {
            CurrentAssociation = MyAssociation ;
            }

        if (MyAssociation == 0)
            {
            BindingMutex.Clear();
            return(RPC_S_OUT_OF_MEMORY);
            }

        // The association now owns the DceBinding.
        DceBinding = 0;

        if((AddAssociation(MyAssociation)) == -1)
            {
            delete MyAssociation;
            if (CurrentAssociation == MyAssociation)
                {
                CurrentAssociation = 0;
                }

            BindingMutex.Clear();
            return (RPC_S_OUT_OF_MEMORY);
            }
        }

    BindingReferenceCount.Increment();

    BindingMutex.Clear();

    ASSERT(MyAssociation) ;

    Status = MyAssociation->AllocateCCall(
                                          this,
                                          CCall,
                                          Message,
                                          RpcInterfaceInformation);

    if (Status != RPC_S_OK)
        {
        LocalRefCount = BindingReferenceCount.Decrement();
        ASSERT(LocalRefCount != 0);
        }

    return(Status);
}

RPC_STATUS
LRPC_BINDING_HANDLE::SetAuthInformation (
    IN RPC_CHAR  * ServerPrincipalName, OPTIONAL
    IN unsigned long AuthenticationLevel,
    IN unsigned long AuthenticationService,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthorizationService,
    IN SECURITY_CREDENTIALS * Credentials,
    IN unsigned long ImpersonationType,
    IN unsigned long IdentityTracking,
    IN unsigned long Capabilities,
    IN BOOL bAcquireNewCredentials,
    IN ULONG AdditionalTransportCredentialsType, OPTIONAL
    IN void *AdditionalCredentials, OPTIONAL
    IN PSID Sid OPTIONAL
    )
/*++

Routine Description:

    We set the authentication and authorization information in this binding
    handle.

Arguments:

    ServerPrincipalName - Optionally supplies the server principal name.

    AuthenticationLevel - Supplies the authentication level to use.

    AuthenticationService - Supplies the authentication service to use.

    AuthIdentity - Optionally supplies the security context to use.

    AuthorizationService - Supplies the authorization service to use.

    AdditionalTransportCredentialsType  - the type of additional credentials
        supplied in AdditionalCredentials. Not supported for LRPC.

    AdditionalCredentials - pointer to additional credentials if any. Not supported
        for LRPC.

    Sid - the SID to mutually authenticate to

Return Value:

    RPC_S_OK - The supplied authentication and authorization information has
    been set in the binding handle.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete the
    operation.

    RPC_S_UNKNOWN_AUTHN_SERVICE - The specified authentication service is
    not supported.

    RPC_S_UNKNOWN_AUTHN_LEVEL - The specified authentication level is
    not supported.

    RPC_S_INVALID_AUTH_IDENTITY - The specified security context (supplied
    by the auth identity argument) is invalid.

    RPC_S_UNKNOWN_AUTHZ_SERVICE - The specified authorization service is
    not supported.

--*/
{

    RPC_CHAR * NewString ;
    RPC_STATUS Status;
    HANDLE hToken;
    unsigned long MappedAuthenticationLevel;
    PSID ServerSid = NULL;
    ULONG SidLength;
    BOOL Result;
    BOOL fCachedSid = TRUE;

    if ((AdditionalTransportCredentialsType != 0) || (AdditionalCredentials != NULL))
        return RPC_S_CANNOT_SUPPORT;

    if (AuthenticationLevel == RPC_C_AUTHN_LEVEL_DEFAULT)
        {
        AuthenticationLevel = RPC_C_AUTHN_LEVEL_CONNECT;
        }

    MappedAuthenticationLevel = MapAuthenticationLevel(AuthenticationLevel);

    if (AuthenticationLevel > RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
        {
        return(RPC_S_UNKNOWN_AUTHN_LEVEL);
        }

    ClientAuthInfo.AuthenticationLevel = MappedAuthenticationLevel;
    ClientAuthInfo.AuthenticationService = AuthenticationService;
    ClientAuthInfo.AuthIdentity = AuthIdentity;
    ClientAuthInfo.AuthorizationService = AuthorizationService;
    ClientAuthInfo.IdentityTracking = IdentityTracking;

    if (MappedAuthenticationLevel == RPC_C_AUTHN_LEVEL_NONE)
        {
        ClientAuthInfo.ImpersonationType = RPC_C_IMP_LEVEL_ANONYMOUS;
        }
    else
        {
        ClientAuthInfo.ImpersonationType = ImpersonationType;
        }

    if (AuthenticationService == RPC_C_AUTHN_NONE)
        {
        AuthInfoInitialized = 0;

        return (RPC_S_OK);
        }

    if(AuthenticationService != RPC_C_AUTHN_WINNT)
        {
        return(RPC_S_UNKNOWN_AUTHN_SERVICE) ;
        }

    // For LRPC, MA implies local MA hint.
    if (Capabilities & RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH)
        {
        Capabilities |= RPC_C_QOS_CAPABILITIES_LOCAL_MA_HINT;

        // if the SPN is not translated to a SID, we must do that now
        if (!ARGUMENT_PRESENT(Sid))
            {
            Status = RpcpLookupAccountName (ServerPrincipalName,
                &fCachedSid,
                &ServerSid);
            if (Status != RPC_S_OK)
                return Status;
            Sid = ServerSid;
            // fall through to SID processing code below
            }
        }
    ClientAuthInfo.Capabilities = Capabilities;

    if (ARGUMENT_PRESENT(Sid))
        {
        // duplicate if not already allocated
        if (ServerSid == NULL)
            {
            ServerSid = DuplicateSID (Sid);
            if (ServerSid == NULL)
                return(RPC_S_OUT_OF_MEMORY);
            }

        BindingMutex.Request();
        if ( ClientAuthInfo.ServerSid != 0 )
            {
            delete ClientAuthInfo.ServerSid;
            }

        ClientAuthInfo.ServerSid = ServerSid;
        BindingMutex.Clear();
        }

    if (ARGUMENT_PRESENT(ServerPrincipalName) && (*ServerPrincipalName))
        {
        NewString = DuplicateString(ServerPrincipalName);
        if ( NewString == 0 )
            {
            return(RPC_S_OUT_OF_MEMORY);
            }

        BindingMutex.Request();
        if ( ClientAuthInfo.ServerPrincipalName != 0 )
            {
            delete ClientAuthInfo.ServerPrincipalName;
            }
        ClientAuthInfo.ServerPrincipalName = NewString;
        BindingMutex.Clear();
        }
    else
        {
        BindingMutex.Request();
        if ( ClientAuthInfo.ServerPrincipalName != 0 )
            {
            delete ClientAuthInfo.ServerPrincipalName;
            }
        ClientAuthInfo.ServerPrincipalName = NULL;
        BindingMutex.Clear();
        }

    if (IdentityTracking == RPC_C_QOS_IDENTITY_STATIC)
        {
        if (StaticTokenHandle)
            {
            CloseHandle(StaticTokenHandle);
            }

        if (OpenThreadToken (GetCurrentThread(),
                         TOKEN_IMPERSONATE | TOKEN_QUERY,
                         TRUE,
                         &StaticTokenHandle) == FALSE)
            {
            StaticTokenHandle = 0;
            }

        Status = ReAcquireCredentialsIfNecessary();
        if (Status != RPC_S_OK)
            {
            return Status;
            }
        }

    AuthInfoInitialized = 1;

    return(RPC_S_OK);
}


unsigned long
LRPC_BINDING_HANDLE::MapAuthenticationLevel (
    IN unsigned long AuthenticationLevel
    )
/*++

Routine Description:

    The connection oriented protocol module supports all authentication
    levels except for RPC_C_AUTHN_LEVEL_CALL.  We just need to map it
    to RPC_C_AUTHN_LEVEL_PKT.

--*/
{
    UNUSED(this);

    if (AuthenticationLevel >= RPC_C_AUTHN_LEVEL_CONNECT)
        {
        return(RPC_C_AUTHN_LEVEL_PKT_PRIVACY);
        }

    return(AuthenticationLevel);
}


inline int
LRPC_BINDING_HANDLE::AddAssociation (
    IN LRPC_CASSOCIATION * Association
    )
/*++

Routine Description:

    This supplied remote procedure call needs to be put into the dictionary
    of association

--*/
{
    int err;
    BindingMutex.Request() ;
    err = SecAssociation.Insert(Association) ;
    BindingMutex.Clear() ;

    return(err);

}


inline void
LRPC_BINDING_HANDLE::RemoveAssociation (
    IN LRPC_CASSOCIATION * Association
    )
/*++

Routine Description:

    Remove Association from BindingHandle, can keep a Key for Association because
    1 association may be added to many BINDINGHANDLE::SecAssociationDict, 1 key per
    Association won't do the job. Therefore, we delete Association this way.
    Remember, there will be 5 Association in the SecAssoc the most, 1 per SecurityLevel

--*/
{
    BindingMutex.Request() ;
    SecAssociation.DeleteItemByBruteForce(Association);
    BindingMutex.Clear() ;
}

RPC_STATUS
LRPC_BINDING_HANDLE::SetTransportOption( IN unsigned long option,
                                    IN ULONG_PTR     optionValue )
{
    if (option == RPC_C_OPT_DONT_LINGER)
        {
        if (CurrentAssociation == NULL)
            return RPC_S_WRONG_KIND_OF_BINDING;

        if (CurrentAssociation->GetDontLingerState())
            return RPC_S_OK;

        CurrentAssociation->SetDontLingerState((BOOL)optionValue);

        return RPC_S_OK;
        }
    else
        {
        return BINDING_HANDLE::SetTransportOption(option, optionValue);
        }
}

RPC_STATUS
LRPC_BINDING_HANDLE::InqTransportOption( IN  unsigned long option,
                                    OUT ULONG_PTR   * pOptionValue )
{
    if (option == RPC_C_OPT_DONT_LINGER)
        {
        if (CurrentAssociation == NULL)
            return RPC_S_WRONG_KIND_OF_BINDING;

        *pOptionValue = CurrentAssociation->GetDontLingerState();

        return RPC_S_OK;
        }
    else
        {
        return BINDING_HANDLE::InqTransportOption(option, pOptionValue);
        }
}


MTSyntaxBinding *CreateLrpcBinding(
        IN RPC_SYNTAX_IDENTIFIER *InterfaceId,
        IN TRANSFER_SYNTAX_STUB_INFO *TransferSyntaxInfo,
        IN int CapabilitiesBitmap
        )
{
    return new LRPC_BINDING(InterfaceId, 
        TransferSyntaxInfo,
        CapabilitiesBitmap);
}



// protected by the LrpcMutex
LRPC_CASSOCIATION_DICT * LrpcAssociationDict = 0;
long LrpcLingeredAssociations = 0;
unsigned long LrpcDestroyedAssociations = 0;
ULARGE_INTEGER LastDestroyedAssociationsBatchTimestamp;


LRPC_CASSOCIATION::LRPC_CASSOCIATION (
    IN DCE_BINDING * DceBinding,
    IN CLIENT_AUTH_INFO *pClientAuthInfo,
    IN USHORT MySequenceNumber,
    OUT RPC_STATUS * Status
    ) : AssociationMutex(Status, 4000),
        AssocAuthInfo(pClientAuthInfo, Status)
/*++

Routine Description:

    This association will be initialized, so that it is ready to be
    placed into the dictionary of associations.

Arguments:

    DceBinding - Supplies the DCE_BINDING which will name this association.

    Status - Returns the result of creating the association mutex.

--*/
{
    ObjectType = LRPC_CASSOCIATION_TYPE;
    this->DceBinding = DceBinding;
    LpcClientPort = 0;
    LpcReceivePort = 0;
    BackConnectionCreated = 0;
    CallIdCounter = 1;
    SequenceNumber = MySequenceNumber;
    Linger.fAssociationLingered = FALSE;
    DeletedContextCount = 0;
    BindingHandleReferenceCount = 1;
    RefCount.SetInteger(2);
    CachedCCall = NULL;
    DontLinger = FALSE;
    LastSecContextTrimmingTimestamp = 0;

    // Generate the bind back cookie.
    // The cookie will be used to verify that bind back
    // originates from a legitimate server.
    GenerateRandomNumber((unsigned char *)BindBackCookie, BIND_BACK_COOKIE_SIZE);

    if (*Status == RPC_S_OK)
        {
        CachedCCall = new LRPC_CCALL(Status);
        if (*Status == RPC_S_OK)
            {
            if (CachedCCall == 0)
                {
                *Status = RPC_S_OUT_OF_MEMORY ;
                return;
                }

            CachedCCall->SetAssociation(this);
            CachedCCallFlag = 1;
            }
        }
}


LRPC_CASSOCIATION::~LRPC_CASSOCIATION (
   )
{
    LRPC_BINDING * Binding;
    LRPC_CCALL * CCall ;
    LRPC_CCONTEXT *SecurityContext;
    DictionaryCursor cursor;

    if (DceBinding != 0)
        {
        delete DceBinding;
        }

    Bindings.Reset(cursor);
    while ((Binding = Bindings.RemoveNext(cursor)) != 0)
        {
        Binding->RemoveReference();
        }

    SecurityContextDict.Reset(cursor);
    while (SecurityContext = SecurityContextDict.RemoveNext(cursor))
        {
        delete SecurityContext;
        }

    // delete all CCalls
    ActiveCCalls.Reset(cursor) ;
    while ((CCall = ActiveCCalls.Next(cursor, TRUE)) != 0)
        {
        delete CCall ;
        }

    if (CachedCCallFlag != 0)
        {
        delete CachedCCall;
        }

    FreeCCalls.Reset(cursor);
    while ((CCall = FreeCCalls.Next(cursor)) != 0)
        {
        delete CCall;
        }

    CloseLpcClientPort();
}



RPC_STATUS
LRPC_CASSOCIATION::CreateBackConnection (
    IN LRPC_BINDING_HANDLE *BindingHandle
    )
/*++

Routine Description:

 Ask the server to create a back connection to us. Used in
 conjuction with Async RPC.

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/

{
#if defined(BUILD_WOW6432)
    char LrpcMessageBuffer[sizeof(LRPC_BIND_BACK_MESSAGE) + 8];
    char LrpcReplyBuffer[sizeof(LRPC_MESSAGE) + 8];
    LRPC_BIND_BACK_MESSAGE *LrpcMessagePtr = (LRPC_BIND_BACK_MESSAGE *) AlignPtr8(LrpcMessageBuffer);
    LRPC_MESSAGE *LrpcReplyPtr = (LRPC_MESSAGE *)AlignPtr8(LrpcReplyBuffer);
#else
    LRPC_BIND_BACK_MESSAGE LrpcMessageBuffer;
    LRPC_MESSAGE LrpcReplyBuffer;
    LRPC_BIND_BACK_MESSAGE *LrpcMessagePtr = &LrpcMessageBuffer;
    LRPC_MESSAGE *LrpcReplyPtr = &LrpcReplyBuffer;
#endif
    NTSTATUS NtStatus ;
    RPC_STATUS Status = RPC_S_OK;

    if (BackConnectionCreated == 0)
        {
        Status = AssociationMutex.RequestSafe() ;
        if (Status)
            return Status;

        if (BackConnectionCreated)
            {
            AssociationMutex.Clear() ;
            return RPC_S_OK ;
            }

        if (LpcClientPort == 0)
            {
            Status = OpenLpcPort(BindingHandle, TRUE) ;
            if (Status != RPC_S_OK)
                {
                AssociationMutex.Clear() ;

                RpcpErrorAddRecord(EEInfoGCRuntime, 
                    Status,
                    EEInfoDLLRPC_CASSOCIATION__CreateBackConnection10,
                    InqEndpoint());

                return Status ;
                }
            }
        else
            {
            // zero out the message to prevent data leak
            RpcpMemorySet(LrpcMessagePtr, 0, sizeof(*LrpcMessagePtr));

            LrpcGetEndpoint((RPC_CHAR *) LrpcMessagePtr->szPortName) ;

            LrpcMessagePtr->LpcHeader.u1.s1.DataLength =
                    sizeof(LRPC_BIND_BACK_MESSAGE) - sizeof(PORT_MESSAGE);
            LrpcMessagePtr->LpcHeader.u1.s1.TotalLength =
                    sizeof(LRPC_BIND_BACK_MESSAGE);
            LrpcMessagePtr->LpcHeader.u2.ZeroInit = 0;
            LrpcMessagePtr->MessageType = LRPC_MSG_BIND_BACK;

            // Make sure we can't be impersonated on the transport level.
            // A legitimate Lrpc server will never do this on a bind back.
            LrpcMessagePtr->LpcHeader.u2.s2.Type |= LPC_NO_IMPERSONATE;

            DWORD Key;
            LPC_KEY *LpcKey = (LPC_KEY *) &Key;

            LpcKey->SeqNumber = SequenceNumber;
            LpcKey->AssocKey = (unsigned short) AssociationDictKey;

            LrpcMessagePtr->AssocKey = Key;


            // Initialize a cookie to be sent in the message.
            RpcpMemoryCopy(LrpcMessagePtr->Cookie, BindBackCookie, BIND_BACK_COOKIE_SIZE);

            NtStatus = NtRequestWaitReplyPort(LpcClientPort,
                                             (PORT_MESSAGE *) LrpcMessagePtr,
                                             (PORT_MESSAGE *) LrpcReplyPtr) ;

            if (NT_ERROR(NtStatus))
                {
                AssociationMutex.Clear() ;

                if (NtStatus == STATUS_NO_MEMORY)
                    {
                    Status = RPC_S_OUT_OF_MEMORY;
                    }
                else if (NtStatus == STATUS_INSUFFICIENT_RESOURCES)
                    {
                    Status = RPC_S_OUT_OF_RESOURCES;
                    }
                else
                    {
                    VALIDATE(NtStatus)
                        {
                        STATUS_INVALID_PORT_HANDLE,
                        STATUS_INVALID_HANDLE,
                        STATUS_PORT_DISCONNECTED,
                        STATUS_LPC_REPLY_LOST
                        } END_VALIDATE;
                    Status = RPC_S_SERVER_UNAVAILABLE;
                    }

                RpcpErrorAddRecord(EEInfoGCLPC, 
                    Status,
                    EEInfoDLLRPC_CASSOCIATION__CreateBackConnection20,
                    NtStatus);

                return (Status);
                }

            ASSERT(LrpcReplyPtr->Ack.MessageType == LRPC_MSG_ACK) ;
            if (LrpcReplyPtr->Ack.RpcStatus != RPC_S_OK)
                {
                AssociationMutex.Clear() ;

                RpcpErrorAddRecord(EEInfoGCRuntime, 
                    LrpcReplyPtr->Ack.RpcStatus,
                    EEInfoDLLRPC_CASSOCIATION__CreateBackConnection30);

                return LrpcReplyPtr->Ack.RpcStatus;
                }
            }

        BackConnectionCreated = 1 ;
        AssociationMutex.Clear() ;
        }

    return Status ;
}

void 
LRPC_CASSOCIATION::RemoveBindingHandleReference (
    void
    )
{
    BOOL fWillLinger = FALSE;
    LRPC_CASSOCIATION *CurrentAssociation;
    LRPC_CASSOCIATION *OldestAssociation = NULL;
    DWORD OldestAssociationTimestamp;
    DictionaryCursor cursor;
    BOOL fEnableGarbageCollection = FALSE;

    LrpcMutexRequest();

    LogEvent(SU_CASSOC, EV_DEC, this, 0, BindingHandleReferenceCount, 1, 1);
    BindingHandleReferenceCount --;
    if (BindingHandleReferenceCount == 0)
        {
        if (LpcClientPort && IsGarbageCollectionAvailable() && (!DontLinger))
            {
            fWillLinger = PrepareForLoopbackTicklingIfNecessary();
            if (fWillLinger)
                {
                if (LrpcLingeredAssociations >= MaxLrpcLingeredAssociations)
                    {
                    OldestAssociationTimestamp = ~(DWORD)0;

                    // need to walk the dictionary and clean up the oldest item
                    LrpcAssociationDict->Reset(cursor);
                    while ((CurrentAssociation = LrpcAssociationDict->Next(cursor)) != 0)
                        {
                        if (CurrentAssociation->Linger.fAssociationLingered)
                            {
                            // yes, if the tick count wraps around, we may make a
                            // suboptimal decision and destroy a newer lingering
                            // association. That's ok - it will be a slight perf hit once
                            // every ~47 days - it won't be a bug
                            if (OldestAssociationTimestamp > CurrentAssociation->Linger.Timestamp)
                                {
                                OldestAssociation = CurrentAssociation;
                                }
                            }
                        }

                    // there must be an oldest association here
                    ASSERT(OldestAssociation);
                    LrpcAssociationDict->Delete(OldestAssociation->AssociationDictKey);
                    OldestAssociation->AssociationDictKey = -1;

                    // no need to update LrpcLingeredAssociations - we removed one,
                    // but we add one, so the balance is the same
                    }
                else
                    {
                    LrpcLingeredAssociations ++;
                    ASSERT(LrpcLingeredAssociations <= MaxLrpcLingeredAssociations);
                    }

                Linger.Timestamp = GetTickCount() + gThreadTimeout;
                Linger.fAssociationLingered = TRUE;
                }
            }

        if (!fWillLinger)
            {
            LrpcDestroyedAssociations ++;
            fEnableGarbageCollection = CheckIfGCShouldBeTurnedOn(
                LrpcDestroyedAssociations, 
                NumberOfLrpcDestroyedAssociationsToSample,
                DestroyedLrpcAssociationBatchThreshold,
                &LastDestroyedAssociationsBatchTimestamp
                );

            Delete();
            }
        }

    LrpcMutexClear();

    if (fEnableGarbageCollection)
        {
        // ignore the return value - we'll make a best effort to
        // create the thread, but if there's no memory, that's
        // still ok as the garbage collection thread only
        // provides better perf in this case
        (void) CreateGarbageCollectionThread();
        }

    if (OldestAssociation)
        {
#if defined (RPC_GC_AUDIT)
        int Diff;

        Diff = (int)(GetTickCount() - OldestAssociation->Linger.Timestamp);
        DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) LRPC association sync gc'ed %d ms after expire\n",
            GetCurrentProcessId(), GetCurrentProcessId(), Diff);
#endif
        OldestAssociation->Delete();
        }

    if (fWillLinger)
        {
        fWillLinger = GarbageCollectionNeeded(TRUE, gThreadTimeout);
        if (fWillLinger == FALSE)
            {
            // uh-oh - we couldn't register for garbage collection - probably
            // extremely low on memory. If nobody has picked us up in the meantime, 
            // delete this association. Otherwise, let it go - somebody is using
            // it and we don't need to worry about gc'ing it. We also need to guard
            // against the gc thread trying to do Delete on this also. If it does
            // so, it will set the AssociationDictKey to -1 before it releases 
            // the mutex - therefore we can check for this. A gc thread cannot
            // completely kill the object as we will hold one reference on it
            LrpcMutexRequest();
            if (AssociationDictKey != -1)
                {
                LrpcLingeredAssociations --;
                ASSERT(LrpcLingeredAssociations >= 0);
                if (Linger.fAssociationLingered)
                    Delete();
                }
            LrpcMutexClear();
            }
#if defined (RPC_GC_AUDIT)
        else
            {
            DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) LRPC association lingered %X\n",
                GetCurrentProcessId(), GetCurrentProcessId(), this);
            }
#endif
        }

    // removing the reference should be the last thing to do. Otherwise we're racing
    // with a gc thread which may kill the this pointer underneath us
    REFERENCED_OBJECT::RemoveReference();
}

void LRPC_CASSOCIATION::Delete(void)
{
    int MyCount;

    if (SetDeletedFlag())
        {
        if (AssociationDictKey != -1)
            {
            LrpcMutexRequest();

            LrpcAssociationDict->Delete(AssociationDictKey);

            LrpcMutexClear();
            }

        REFERENCED_OBJECT::RemoveReference();
        }

}

BOOL
LRPC_CASSOCIATION::DoesBindingForInterfaceExist (
    IN PRPC_CLIENT_INTERFACE RpcInterfaceInformation
    )
/*++

Routine Description:

    Checks if an association supports a binding for this interface.

Arguments:

    RpcInterfaceInformation - Supplies the interface information for
        which we are looking for an osf binding object.

Return Value:

    FALSE if it doesn't. Non-zero if it does.

--*/
{
    LRPC_BINDING *Binding;
    DictionaryCursor cursor;
    BOOL fRetVal = FALSE;
    BOOL fMutexTaken;

    fMutexTaken = AssociationMutex.TryRequest();
    if (!fMutexTaken)
        return FALSE;

    Bindings.Reset(cursor);
    while ((Binding = Bindings.Next(cursor)) != 0)
        {
        // if we have a binding on the same interface,
        // return TRUE
        if (RpcpMemoryCompare(Binding->GetInterfaceId(), 
            &RpcInterfaceInformation->InterfaceId,
            sizeof(RPC_SYNTAX_IDENTIFIER)) == 0)
            {
            fRetVal = TRUE;
            break;
            }
        }
    AssociationMutex.Clear();

    return fRetVal;
}


RPC_STATUS
LRPC_CASSOCIATION::AllocateCCall (
    IN LRPC_BINDING_HANDLE *BindingHandle,
    OUT LRPC_CCALL ** CCall,
    IN OUT PRPC_MESSAGE Message,
    IN PRPC_CLIENT_INTERFACE RpcInterfaceInformation
    )
/*++

Routine Description:

    This method will allocate an LRPC_CCALL which has been bound to the
    interface specified by the interface information.  This means that
    first we need to find the presentation context corresponding to the
    requested interface.

Arguments:

    CCall - Returns the allocated LRPC_CCALL which has been bound to
        the interface specified by the rpc interface information.

    RpcInterfaceInformation - Supplies information describing the
        interface to which we wish to bind.

Return Value:


--*/
{
    LRPC_BINDING *SelectedBinding;
    int RetryCount;
    RPC_STATUS Status;
    LRPC_CCONTEXT *SecurityContext;
    BOOL fAlterSecurityContextNeeded = FALSE;
    BOOL fAlterContextNeeded = FALSE;
    LRPC_CCONTEXT *CurrentSecurityContext = NULL;
    BOOL fUpdateCredentials = FALSE;
    LUID CurrentModifiedId;
    DictionaryCursor cursor;
    LRPC_BINDING *BindingsForThisInterface[MaximumNumberOfTransferSyntaxes];
    int NumberOfBindingsAvailable;
    BOOL BindingCreated[MaximumNumberOfTransferSyntaxes];
    int i;
    int PreferredTransferSyntax;
    int MatchingTransferSyntax;
    BOOL IsBackConnectionNeeded = IsNonsyncMessage(Message);
    RPC_STATUS CaptureStatus;
    LRPC_BINDING *CurrentBinding;
    BOOL fAssociationAborted = FALSE;
    ULONG EffectiveIdentityTracking;

    if (IsBackConnectionNeeded)
        {
        CLIENT_AUTH_INFO * AuthInfo;

        AuthInfo = BindingHandle->InquireAuthInformation();

        ASSERT(AuthInfo);

        if (AuthInfo->IdentityTracking == RPC_C_QOS_IDENTITY_DYNAMIC)
            {
            CaptureStatus = CaptureModifiedId(&CurrentModifiedId);
            fUpdateCredentials = TRUE;
            }
        }

    Status = AssociationMutex.RequestSafe();
    if (Status)
        return Status;

    if (fUpdateCredentials)
        {
        BindingHandle->UpdateCredentials((CaptureStatus != RPC_S_OK), &CurrentModifiedId);
        }

    RetryCount = 0;

    EffectiveIdentityTracking = BindingHandle->GetIdentityTracking();

    do
        {
        //
        // We need to look at two things here. Presentation context
        // and security context (in the async dynamic case only). If both match
        // then we can allocate the call. Otherwise, we need to first bind
        // in order to negotiate the interface/presentation context.
        //
        if (IsBackConnectionNeeded
            || EffectiveIdentityTracking == RPC_C_QOS_IDENTITY_STATIC)
            {
            SecurityContextDict.Reset(cursor);

            while (SecurityContext = SecurityContextDict.Next(cursor))
                {
                if (BindingHandle->CompareCredentials(SecurityContext))
                    {
                    CurrentSecurityContext = SecurityContext;
                    CurrentSecurityContext->AddReference();
                    CurrentSecurityContext->UpdateTimestamp();
                    break;
                    }
                }

            if (SecurityContext == 0)
                {
                fAlterSecurityContextNeeded = TRUE;
                }
            }

        Status = MTSyntaxBinding::FindOrCreateBinding(RpcInterfaceInformation,
            Message, 
            &Bindings, 
            CreateLrpcBinding, 
            NULL,       // CheckBinding
            NULL,       // CallbackContext
            &NumberOfBindingsAvailable,
            (MTSyntaxBinding **)BindingsForThisInterface, 
            BindingCreated
            );

        if (Status != RPC_S_OK)
            {
            goto Cleanup;
            }

        PreferredTransferSyntax = -1;
        MatchingTransferSyntax = -1;
        for (i = 0; i < NumberOfBindingsAvailable; i ++)
            {
            // do we support the preferred server
            if (BindingsForThisInterface[i]->IsTransferSyntaxServerPreferred())
                {
                PreferredTransferSyntax = i;
                break;
                }
            else if ((BindingCreated[i] == FALSE) && (MatchingTransferSyntax < 0))
                {
                MatchingTransferSyntax = i;
                }
            }

        // is there a syntax preferred by the server
        if (PreferredTransferSyntax >= 0)
            {
            // do we already support it (i.e. the binding was not created)
            if (BindingCreated[PreferredTransferSyntax] == FALSE)
                {
                // then we're all set - just use it
                fAlterContextNeeded = FALSE;
                SelectedBinding = BindingsForThisInterface[PreferredTransferSyntax];
                }
            else
                {
                // we don't support it - negotiate it. We know this
                // will succeed, because the server preferences
                // are set. This should be hit in the auto-retry case only
                fAlterContextNeeded = TRUE;
                ASSERT(_NOT_COVERED_);
                }
            }
        else
            {
            // no preferred syntax - any will do. Check if we found anything supported
            if (MatchingTransferSyntax >= 0)
                {
                SelectedBinding = BindingsForThisInterface[MatchingTransferSyntax];
                fAlterContextNeeded = FALSE;
                }
            else
                {
                fAlterContextNeeded = TRUE;
                }
            }

        if (fAlterContextNeeded == FALSE)
            {
            if (IsBackConnectionNeeded)
                {
                Status = InitializeAsyncLrpcIfNecessary() ;
                if (Status == RPC_S_OK)
                    {
                    Status = CreateBackConnection(BindingHandle);
                    }

                if (Status != RPC_S_OK)
                    {
                    goto Cleanup;
                    }
                }
            }

        if (fAlterContextNeeded || fAlterSecurityContextNeeded)
            {
            Status = ActuallyDoBinding(
                                   BindingHandle,
                                   IsBackConnectionNeeded,
                                   fAlterContextNeeded,
                                   fAlterSecurityContextNeeded,
                                   BindingHandle->ClientAuthInfo.DefaultLogonId,
                                   NumberOfBindingsAvailable,
                                   BindingsForThisInterface,
                                   &SelectedBinding,
                                   &CurrentSecurityContext);
            if (Status != RPC_S_SERVER_UNAVAILABLE) 
                {
                
                fAssociationAborted = FALSE;
                break;
                }


            // The server appears to have gone away, close the port and retry.

            RetryCount++;

            SelectedBinding = 0;

            // both the creation in ActuallyDoBinding and the
            // retrieval from the cache will add a refcount -
            // remove it
            if (CurrentSecurityContext)
                {
                CurrentSecurityContext->RemoveReference();
                CurrentSecurityContext = NULL; 
                }
            fAlterContextNeeded = TRUE;

            if (IsBackConnectionNeeded
                || EffectiveIdentityTracking == RPC_C_QOS_IDENTITY_STATIC)
                {
                fAlterSecurityContextNeeded = TRUE;
                }

            AbortAssociation();

            if (RetryCount < 3)
                {
                RpcpPurgeEEInfo();
                }

            fAssociationAborted = TRUE;
            }
        else
            {
            Status = RPC_S_OK;
            break;
            }

    } while(RetryCount < 3);

    if (Status == RPC_S_OK)
        {
        ASSERT(SelectedBinding != 0);

        Status = ActuallyAllocateCCall(
                                       CCall,
                                       SelectedBinding,
                                       IsBackConnectionNeeded,
                                       BindingHandle,
                                       CurrentSecurityContext);
        }
    else
        {
        // if the association was aborted, the bindings were already removed from the
        // dictionary - don't do it again
        if (fAssociationAborted == FALSE)
            {
            // the binding failed - remove the created bindings from the dictionary
            for (i = 0; i < NumberOfBindingsAvailable; i ++)
                {
                if (BindingCreated[i])
                    {
                    CurrentBinding = Bindings.Delete(BindingsForThisInterface[i]->GetPresentationContext());
                    ASSERT(CurrentBinding == BindingsForThisInterface[i]);
                    delete CurrentBinding;
                    }
                }
            }
        }

Cleanup:
    if (CurrentSecurityContext)
        {
        if (Status == RPC_S_OK)
            {
            (*CCall)->SetCurrentSecurityContext(CurrentSecurityContext);
            }
        else
            {
            // remove the added reference
            CurrentSecurityContext->RemoveReference();
            }
        }
    AssociationMutex.Clear();

    return(Status);
}


RPC_STATUS
LRPC_CASSOCIATION::ActuallyAllocateCCall (
    OUT LRPC_CCALL ** CCall,
    IN LRPC_BINDING * Binding,
    IN BOOL IsBackConnectionNeeded,
    IN LRPC_BINDING_HANDLE * BindingHandle,
    IN LRPC_CCONTEXT *SecurityContext
    )
/*++

Routine Description:

    We need to allocate a LRPC_CCALL object for the call.  We also need
    to initialize it so that it specified the correct bound interface.

Arguments:

    CCall - Returns the allocated LRPC_CCALL which has been bound to
        the interface specified by the rpc interface information.

    Binding - Supplies a representation of the interface to which the
        remote procedure call is supposed to be directed.

Return Value:

    RPC_S_OK - An LRPC_CCALL has been allocated and is ready to be used
        to make a remote procedure call.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate
        the LRPC_CALL object.

Notes:

    The global mutex will be held when this routine is called.

--*/
{
    RPC_STATUS Status = RPC_S_OK ;
    DictionaryCursor cursor;
    LRPC_CCALL *LocalCall;
    THREAD *ThisThread;

    if (CachedCCallFlag != 0)
        {
        LocalCall = CachedCCall ;
        CachedCCallFlag = 0;
        }
    else
        {
        ThisThread = RpcpGetThreadPointer();

        ASSERT(ThisThread);

        if (ThisThread->GetCachedLrpcCall())
            {
            LocalCall = ThisThread->GetCachedLrpcCall();
            ThisThread->SetCachedLrpcCall(NULL);

            LocalCall->SetAssociation(this);
            }
        else
            {
            FreeCCalls.Reset(cursor) ;

            while ((LocalCall = FreeCCalls.Next(cursor)) != 0)
                {
                FreeCCalls.Delete(LocalCall->FreeCallKey) ;
                break;
                }
            }

        if (LocalCall == 0)
            {
            LocalCall = new LRPC_CCALL(&Status);
            if (LocalCall == 0)
                {
                return(RPC_S_OUT_OF_MEMORY);
                }

            if (Status != RPC_S_OK)
                {
                delete LocalCall ;
                return Status ;
                }
            LocalCall->SetAssociation(this);
            }
        }

    Status = LocalCall->ActivateCall(BindingHandle,
                                Binding,
                                IsBackConnectionNeeded,
                                SecurityContext);
    if (Status != RPC_S_OK)
        {
        goto Cleanup;
        }

    if (IsBackConnectionNeeded)
        {
        if (ActiveCCalls.Insert(ULongToPtr(CallIdCounter), LocalCall) == -1)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            // remove the reference we added to this
            // binding
            Binding->RemoveReference();
            goto Cleanup;
            }

        LocalCall->CallId = CallIdCounter++;

        LogEvent(SU_CCALL, EV_START, LocalCall, this, LocalCall->CallId, 1, 0);
        }

    AddReference();

    *CCall = LocalCall;
    return(RPC_S_OK);

Cleanup:
    if (LocalCall == CachedCCall)
        {
        CachedCCallFlag = 1;
        }
    else
        {
        delete LocalCall ;
        }

    return (Status) ;
}

void
LRPC_CASSOCIATION::PrepareBindPacket(LRPC_MESSAGE *LrpcMessage)
{
    int MessageSize;
    int NumContexts = 0;
    LRPC_CCONTEXT *CContext;
    LRPC_CCONTEXT *DeletedContext;
    DictionaryCursor cursor;
    DWORD OldestUnusedAge = 0;
    LRPC_CCONTEXT *OldestUnusedCContext = NULL;
    DWORD CurrentTime = GetTickCount();

    // Expire old and unused contexts.
    // If we have some space left for expiring additional contexts and
    // the cache is at the max size, we will trim the oldest remaining context.
    // This is done to make sure that when the cache is at the max, even if
    // none of the contexts are old, we will still expire at least one context for
    // each new one we establish.

    SecurityContextDict.Reset(cursor);

    // Proceed while the packet has space left for expiring more contexts.
    while (NumContexts < MAX_LRPC_CONTEXTS)
        {
        // Pick the next unused context.
        CContext = SecurityContextDict.Next(cursor);
        if (CContext
            && CContext->IsUnused())
            {
            // If the security context is old, we expire it.
            if (CContext->IsSecurityContextOld())
                {
                LrpcMessage->Bind.OldSecurityContexts.SecurityContextId[NumContexts]
                    = CContext->SecurityContextId;
                DeletedContext = SecurityContextDict.Delete(CContext->ContextKey);
                ASSERT(DeletedContext == CContext);

                NumContexts++;

                delete CContext;
                }
            // Otherwise, we check if we should force expiration of the oldest context.
            else if (SecurityContextDict.Size() > LRPC_CCONTEXT_CACHE_SIZE_THRESHOLD)
                {
                // Compute the age of the current context taking into account tick count wrapping.
                // Note that since both values are unsigned, we will get a large positive Age if CurrentTime < CContext->GetTimestamp().
                DWORD Age = CurrentTime - CContext->GetTimestamp();
                // If we have the oldest context, remember it.
                if (Age > OldestUnusedAge)
                    {
                    OldestUnusedAge = Age;
                    OldestUnusedCContext = CContext;
                    }
                }
            }
        else
            {
            break;
            }
        }

    // If there is space left to expire more contexts and we were able to find the oldest unused context, delete it.
    if (NumContexts < MAX_LRPC_CONTEXTS
        && OldestUnusedCContext != NULL)
        {
        LrpcMessage->Bind.OldSecurityContexts.SecurityContextId[NumContexts] = OldestUnusedCContext->SecurityContextId;
        DeletedContext = SecurityContextDict.Delete(OldestUnusedCContext->ContextKey);
        ASSERT(DeletedContext == OldestUnusedCContext);

        NumContexts++;

        delete OldestUnusedCContext;
        }

    UpdateLastSecContextTrimmingTimestamp();

    MessageSize = FIELD_OFFSET(LRPC_BIND_MESSAGE, OldSecurityContexts) + 
                  FIELD_OFFSET(OLD_SECURITY_CONTEXTS, SecurityContextId) +
                  NumContexts*sizeof(DWORD);

    LrpcMessage->Bind.OldSecurityContexts.NumContexts = NumContexts;

    LrpcMessage->LpcHeader.u1.s1.DataLength = (CSHORT) (MessageSize - sizeof(PORT_MESSAGE));
    LrpcMessage->LpcHeader.u1.s1.TotalLength = (CSHORT) MessageSize;
}



RPC_STATUS
LRPC_CASSOCIATION::ActuallyDoBinding (
    IN LRPC_BINDING_HANDLE *BindingHandle,
    IN BOOL IsBackConnectionNeeded,
    IN BOOL fAlterContextNeeded,
    IN BOOL fAlterSecurityContextNeeded,
    IN BOOL fDefaultLogonId,
    IN int NumberOfBindings,
    LRPC_BINDING *BindingsForThisInterface[],
    OUT LRPC_BINDING ** Binding,
    OUT LRPC_CCONTEXT **pSecurityContext
    )
/*++

Routine Description:

Arguments:

    RpcInterfaceInformation - Supplies information describing the interface
        to which we wish to bind.

    Binding - Returns an object representing the binding to the interface
        described by the first argument.

Return Value:

--*/
{
    NTSTATUS NtStatus;
    NTSTATUS MyNtStatus;
    RPC_STATUS Status = RPC_S_OK;
    int DictKey ;
    HANDLE ImpersonationToken = 0;
    BOOL fTokenAltered = 0;
    int i;
    LRPC_BIND_EXCHANGE *BindExchange;
    int BindingForNDR20PresentationContext;
    int BindingForNDR64PresentationContext;
    int BindingForNDRTestPresentationContext;
    int ChosenBindingIndex;
    LRPC_BINDING *SelectedBinding;

    LRPC_MESSAGE *LrpcMessage;
    ULONG EffectiveIdentityTracking;

    //
    // To start with, see if we have an LPC port; if we dont, open one
    // up.
    //

    //
    // The AssociationMutex is held when this function is called
    //

    AssociationMutex.VerifyOwned();

    if (IsBackConnectionNeeded)
        {
        Status = InitializeAsyncLrpcIfNecessary() ;
        if (Status == RPC_S_OK)
            {
            Status = CreateBackConnection(BindingHandle) ;
            }

        if (Status != RPC_S_OK)
            {
            RpcpErrorAddRecord(EEInfoGCRuntime, 
                Status,
                EEInfoDLLRPC_CASSOCIATION__ActuallyDoBinding10,
                InqEndpoint());
            return Status ;
            }
        }
    else
        {
        if (LpcClientPort == 0)
            {
            //
            // we now need to bind explicitly
            //
            Status = OpenLpcPort(BindingHandle, FALSE);
            ASSERT(fAlterContextNeeded == TRUE);

            if (Status != RPC_S_OK)
                {
                RpcpErrorAddRecord(EEInfoGCRuntime, 
                    Status,
                    EEInfoDLLRPC_CASSOCIATION__ActuallyDoBinding20,
                    InqEndpoint());
                return Status ;
                }
            }
        }

    LrpcMessage = (LRPC_MESSAGE *)AlignOnNaturalBoundary(
        _alloca(sizeof(LRPC_MESSAGE) + RPCRT_NATURAL_BOUNDARY_ALIGNMENT_MAX_SHIFT));

    SanitizeLpcHeader (&LrpcMessage->LpcHeader);

    if (CacheNeedsTrimming())
        {
        PrepareBindPacket(LrpcMessage);
        }
    else
        {
        LrpcMessage->LpcHeader.u1.s1.DataLength = FIELD_OFFSET(LRPC_BIND_MESSAGE, OldSecurityContexts)
            + sizeof(LrpcMessage->Bind.OldSecurityContexts.NumContexts)
            - sizeof(PORT_MESSAGE);
        LrpcMessage->LpcHeader.u1.s1.TotalLength = FIELD_OFFSET(LRPC_BIND_MESSAGE, OldSecurityContexts)
            + sizeof(LrpcMessage->Bind.OldSecurityContexts.NumContexts);
        LrpcMessage->Bind.OldSecurityContexts.NumContexts = 0;
        }
    BindExchange = &LrpcMessage->Bind.BindExchange;

    // Zero out uninitialized data.
    BindExchange->ConnectType = 0;
    BindExchange->AssocKey = 0;
    BindExchange->RpcStatus = 0;
    BindExchange->SecurityContextId = 0;
    RpcpMemorySet(BindExchange->Cookie, 0, BIND_BACK_COOKIE_SIZE);
    RpcpMemorySet(&BindExchange->szPortName, 0, sizeof(BindExchange->szPortName));

    // Otherwise, just go ahead and send the bind request message to the
    // server, and then wait for the bind response.

    LrpcMessage->LpcHeader.u2.ZeroInit = 0;
    LrpcMessage->Bind.MessageType = LRPC_MSG_BIND;
    LrpcMessage->Bind.Pad[0] = 0;
    LrpcMessage->Bind.Pad[1] = 0;
    LrpcMessage->Bind.Pad[2] = 0;

    if (fAlterContextNeeded)
        {
        SelectedBinding = *Binding = NULL;
        ASSERT(NumberOfBindings > 0);
        // all bindings have the same interface ID. Therefore, it is
        // safe to use the first
        RpcpMemoryCopy(&BindExchange->InterfaceId, 
            BindingsForThisInterface[0]->GetInterfaceId(),
            sizeof(RPC_SYNTAX_IDENTIFIER));

        BindExchange->Flags = NEW_PRESENTATION_CONTEXT_FLAG;
        BindExchange->TransferSyntaxSet = 0;
        BindingForNDR20PresentationContext = BindingForNDR64PresentationContext = -1;

        ASSERT (NumberOfBindings <= MaximumNumberOfTransferSyntaxes);
        for (i = 0; i < NumberOfBindings; i ++)
            {
            if (RpcpMemoryCompare(BindingsForThisInterface[i]->GetTransferSyntaxId(), 
                NDR20TransferSyntax, sizeof(RPC_SYNTAX_IDENTIFIER)) == 0)
                {
                BindExchange->TransferSyntaxSet |= TS_NDR20_FLAG;
                BindExchange->PresentationContext[0]
                    = BindingsForThisInterface[i]->GetOnTheWirePresentationContext();
                BindingForNDR20PresentationContext = i;
                }
            else if (RpcpMemoryCompare(BindingsForThisInterface[i]->GetTransferSyntaxId(), 
                NDR64TransferSyntax, sizeof(RPC_SYNTAX_IDENTIFIER)) == 0)
                {
                BindExchange->TransferSyntaxSet |= TS_NDR64_FLAG;
                BindExchange->PresentationContext[1]
                    = BindingsForThisInterface[i]->GetOnTheWirePresentationContext();
                BindingForNDR64PresentationContext = i;
                }
            else if (RpcpMemoryCompare(BindingsForThisInterface[i]->GetTransferSyntaxId(), 
                NDRTestTransferSyntax, sizeof(RPC_SYNTAX_IDENTIFIER)) == 0)
                {
                BindExchange->TransferSyntaxSet |= TS_NDRTEST_FLAG;
                BindExchange->PresentationContext[2]
                    = BindingsForThisInterface[i]->GetOnTheWirePresentationContext();
                BindingForNDRTestPresentationContext = i;
                }
            else
                {
                ASSERT(!"Unknown transfer syntax\n");
                Status = RPC_S_UNSUPPORTED_TRANS_SYN;
                goto Cleanup;
                }
            }

        }
    else
        {
        RpcpMemorySet(&BindExchange->InterfaceId, 
            0,
            sizeof(RPC_SYNTAX_IDENTIFIER));
        BindExchange->Flags = 0;
        BindExchange->TransferSyntaxSet = 0;
        BindExchange->PresentationContext[0] = 0;
        BindExchange->PresentationContext[1] = 0;
        BindExchange->PresentationContext[2] = 0;
        ASSERT(*Binding != NULL);
        SelectedBinding = *Binding;
        }

    if (fAlterSecurityContextNeeded)
        {
        BindExchange->Flags |= NEW_SECURITY_CONTEXT_FLAG;

        if (fDefaultLogonId)
            BindExchange->Flags |= DEFAULT_LOGONID_FLAG;

        EffectiveIdentityTracking = BindingHandle->GetIdentityTracking();

        if (EffectiveIdentityTracking == RPC_C_QOS_IDENTITY_STATIC)
            {
            if (OpenThreadToken (GetCurrentThread(),
                             TOKEN_IMPERSONATE | TOKEN_QUERY,
                             TRUE,
                             &ImpersonationToken) == FALSE)
                {
                ImpersonationToken = 0;
                }

            MyNtStatus = NtSetInformationThread(NtCurrentThread(),
                                              ThreadImpersonationToken,
                                              &(BindingHandle->StaticTokenHandle),
                                              sizeof(HANDLE));
#if DBG
            if (!NT_SUCCESS(MyNtStatus))
                {
                PrintToDebugger("RPC : NtSetInformationThread : %lx\n", MyNtStatus);
                }
#endif // DBG
            fTokenAltered = 1;
            }
        }

    // We will allow the server to impersonate us on this call.
    // This is fine since for static identity tracking this is when the server
    // obtains the client's token.

    NtStatus = NtRequestWaitReplyPort(LpcClientPort,
                     (PORT_MESSAGE *) LrpcMessage,
                     (PORT_MESSAGE *) LrpcMessage) ;

    if (fTokenAltered)
        {
        MyNtStatus = NtSetInformationThread(NtCurrentThread(),
                                          ThreadImpersonationToken,
                                          &ImpersonationToken,
                                          sizeof(HANDLE));
#if DBG
        if (!NT_SUCCESS(MyNtStatus))
            {
            PrintToDebugger("RPC : NtSetInformationThread : %lx\n", MyNtStatus);
            }
#endif // DBG

        if (ImpersonationToken)
            {
            CloseHandle(ImpersonationToken);
            }
        }

    if (NT_SUCCESS(NtStatus))
        {
        ASSERT(LrpcMessage->Bind.MessageType == LRPC_BIND_ACK);
        if (BindExchange->RpcStatus == RPC_S_OK)
            {
            if (fAlterSecurityContextNeeded &&
                (IsBackConnectionNeeded
                 || EffectiveIdentityTracking == RPC_C_QOS_IDENTITY_STATIC))
                {
                //
                // The security context ID should never be -1 for success bind_ack.
                // Note that this is the case only if we are setting up a new security context.
                // If BindExchange->Flags is not set with NEW_SECURITY_CONTEXT_FLAG, then we
                // may get back a -1 SecurityContextId, but we will not create a security context.
                //
                if (BindExchange->SecurityContextId == -1)
                    {
                    CORRUPTION_ASSERT(BindExchange->SecurityContextId != -1);
                    Status = RPC_S_PROTOCOL_ERROR;
                    goto Cleanup;
                    }

                *pSecurityContext = new LRPC_CCONTEXT(
                                    BindingHandle->InquireAuthInformation(),
                                    BindExchange->SecurityContextId,
                                    this);

                if (*pSecurityContext == 0)
                    {
                    Status = RPC_S_OUT_OF_MEMORY;
                    goto Cleanup;
                    }

                if ((DictKey = SecurityContextDict.Insert(*pSecurityContext)) == -1)
                    {
                    delete *pSecurityContext;
                    *pSecurityContext = NULL;
                    Status = RPC_S_OUT_OF_MEMORY;
                    goto Cleanup;
                    }

                (*pSecurityContext)->AddReference();
                (*pSecurityContext)->ContextKey = DictKey;
                }

            if (fAlterContextNeeded)
                {
                ChosenBindingIndex = -1;

                // which presentation context did the server pick?
                if (BindExchange->TransferSyntaxSet & TS_NDR20_FLAG)
                    {
                    ASSERT(BindingForNDR20PresentationContext != -1);
                    // the server should choose only one transfer syntax
                    ASSERT((BindExchange->TransferSyntaxSet & ~TS_NDR20_FLAG) == 0);
                    ChosenBindingIndex = BindingForNDR20PresentationContext;
                    }
                else if (BindExchange->TransferSyntaxSet & TS_NDR64_FLAG)
                    {
                    ASSERT(BindingForNDR64PresentationContext != -1);
                    // the server should choose only one transfer syntax
                    ASSERT((BindExchange->TransferSyntaxSet & ~TS_NDR64_FLAG) == 0);
                    ChosenBindingIndex = BindingForNDR64PresentationContext;
                    }
                else if (BindExchange->TransferSyntaxSet & TS_NDRTEST_FLAG)
                    {
                    ASSERT(BindingForNDRTestPresentationContext != -1);
                    // the server should choose only one transfer syntax
                    ASSERT((BindExchange->TransferSyntaxSet & ~TS_NDRTEST_FLAG) == 0);
                    ChosenBindingIndex = BindingForNDRTestPresentationContext;
                    }
                else
                    {
                    ASSERT(!"Server supplied invalid response");
                    }

                if (ChosenBindingIndex < 0)
                    {
                    ASSERT(_NOT_COVERED_);
                    BindExchange->RpcStatus = RPC_S_UNSUPPORTED_TRANS_SYN;
                    }
                else
                    {
                    // if we offered the server a choice of bindings and it
                    // exercised this choice, record its preferences
                    if (NumberOfBindings > 1)
                        {
                        BindingsForThisInterface[ChosenBindingIndex]->
                            TransferSyntaxIsServerPreferred();
                        for (i = 0; i < NumberOfBindings; i ++)
                            {
                            if (ChosenBindingIndex != i)
                                {
                                BindingsForThisInterface[i]->TransferSyntaxIsNotServerPreferred();
                                }
                            }
                        }

                    SelectedBinding = BindingsForThisInterface[ChosenBindingIndex];

                    }
                }

            }
        else
            {
            if (BindExchange->Flags & EXTENDED_ERROR_INFO_PRESENT)
                {
                ExtendedErrorInfo *EEInfo;

                // In the [out] bind direction the eeinfo is contained in the
                // Bind.BindExchangeReturn structure.
                // Bind.BindExchange is used for passing the port name in the
                // [in] direction and does not have enough space.
                ASSERT(IsBufferAligned(LrpcMessage->Bind.BindExchangeReturn.Buffer));
                Status = UnpickleEEInfo(LrpcMessage->Bind.BindExchangeReturn.Buffer,
                    LrpcMessage->LpcHeader.u1.s1.DataLength
                        - BIND_NAK_PICKLE_BUFFER_OFFSET
                        + sizeof(PORT_MESSAGE),
                    &EEInfo);
                if (Status == RPC_S_OK)
                    {
                    RpcpSetEEInfo(EEInfo);
                    }

                RpcpErrorAddRecord(EEInfoGCRuntime, 
                    BindExchange->RpcStatus,
                    EEInfoDLLRPC_CASSOCIATION__ActuallyDoBinding30);
                }
            }

        Status = BindExchange->RpcStatus;

        ASSERT (Status != RPC_S_SERVER_UNAVAILABLE
            && Status != RPC_S_ACCESS_DENIED) ;
        }
    else
        {
        Status = RPC_S_SERVER_UNAVAILABLE;

        RpcpErrorAddRecord(EEInfoGCLPC, 
            Status,
            EEInfoDLLRPC_CASSOCIATION__ActuallyDoBinding40,
            NtStatus);
        }

Cleanup:
    *Binding = SelectedBinding;
    return (Status);
}


void
LRPC_CASSOCIATION::ProcessResponse (
   IN LRPC_MESSAGE *LrpcResponse,
   IN BOOL AssocMutexHeld,
   IN OUT LRPC_MESSAGE **LrpcReplyMessage
   )
/*++

Routine Description:
    Process a response on the back connection.
    Two types of responses can show up on the back connection:
    1. Responses from async calls.

Arguments:

 LrpcResponse - Reply message.
 AssocMutexHeld - used to indicate that we are calling this function
                  while holding the AssociationMutex.  
Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/

{
    LRPC_CCALL *CCall ;
    RPC_MESSAGE RpcMessage ;
    THREAD *ThisThread;
    LRPC_CCALL *ExistingCCall;
    ULONG OriginalCallId;

    ThisThread = RpcpGetThreadPointer();
    ASSERT(ThisThread);
    ASSERT(ThisThread->GetDestroyedWithOutstandingLocksFlag() == 0);

    OriginalCallId = LrpcResponse->Rpc.RpcHeader.CallId;
    
    if (!AssocMutexHeld){
        AssociationMutex.Request();
        }

    CCall = ActiveCCalls.Find(ULongToPtr(OriginalCallId)) ;
    if (CCall == 0)
        {
        AssociationMutex.Clear() ;

        if (LrpcResponse->Rpc.RpcHeader.Flags & LRPC_BUFFER_SERVER)
            {
            // There may be a server thread stuck waiting for the reply
            // in which case we should treat this as a synchronous call
            // and make sure the message is not dropped.
            // We do this only if the buffer is server. If it is not,
            // we don't do that, because the LPC response we received
            // was datagram, and we can't send a response to a datagram.
            // Note that this is not necessary either, since the response
            // is from a server, and we don't have any use on the server
            // for a fault to a response (it just gets dropped). If the
            // buffer is server, we still need to do it to free
            // the thread, because it is doing NtRequestWaitReplyPort,
            // and this is blocking.
            SetFaultPacket(LrpcResponse,
                RPC_S_CALL_FAILED_DNE,
                LrpcResponse->Rpc.RpcHeader.Flags | LRPC_SYNC_CLIENT,
                NULL);

            *LrpcReplyMessage = LrpcResponse;
            }

        return ;
        }
    CCall->LockCallFromResponse();
    AssociationMutex.Clear() ;

    CCall->ProcessResponse(LrpcResponse);

    // if this call was destroyed with outstanding locks, don't
    // touch it - just clear the flag
    if (ThisThread->GetDestroyedWithOutstandingLocksFlag())
        {
        ThisThread->ClearDestroyedWithOutstandingLocksFlag();
        }
    else
        {
        AssociationMutex.Request() ;
        // check if somebody has freed the call. If yes, don't do anything - the counter
        // would have been reset
        ExistingCCall = ActiveCCalls.Find(ULongToPtr(OriginalCallId));
        if (ExistingCCall 
            && (ExistingCCall == CCall))
            {
            CCall->UnlockCallFromResponse();
            }
        AssociationMutex.Clear() ;
        }
}


RPC_STATUS
LRPC_CASSOCIATION::OpenLpcPort (
    IN LRPC_BINDING_HANDLE *BindingHandle,
    IN BOOL fBindBack
    )
/*++

Routine Description:

Arguments:

    RpcInterfaceInformation - Supplies information describing the interface
        to which we wish to bind.

    Binding - Returns an object representing the binding to the interface
        described by the first argument.

Return Value:

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete the
        operation.

Notes:

    The global mutex will be held when this routine is called.

--*/
{
    NTSTATUS NtStatus;
    UNICODE_STRING UnicodeString;
    RPC_CHAR * LpcPortName;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    RPC_STATUS Status;
    LRPC_BIND_EXCHANGE BindExchange;
    unsigned long BindExchangeLength = sizeof(LRPC_BIND_EXCHANGE);
    PSID SidToUse;
    int RetryCount;
    BOOL fCachedSid = TRUE;

    //
    // Look at the network options and initialize the security quality
    // of service appropriately.
    //

    SecurityQualityOfService.EffectiveOnly = (unsigned char) BindingHandle->EffectiveOnly;
    SecurityQualityOfService.ContextTrackingMode =
                        SECURITY_DYNAMIC_TRACKING;

    SecurityQualityOfService.ImpersonationLevel =
            MapRpcToNtImp(AssocAuthInfo.ImpersonationType) ;

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);

    //
    // Allocate and initialize the port name.  We need to stick the
    // LRPC_DIRECTORY_NAME on the front of the endpoint.  This is for
    // security reasons (so that anyone can create LRPC endpoints).
    //

    LpcPortName = new RPC_CHAR[
                    RpcpStringLength(DceBinding->InqEndpoint())
                    + RpcpStringLength(LRPC_DIRECTORY_NAME) + 1];
    if (LpcPortName == 0)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    RpcpMemoryCopy(LpcPortName, LRPC_DIRECTORY_NAME,
            RpcpStringLength(LRPC_DIRECTORY_NAME) * sizeof(RPC_CHAR));

    RpcpMemoryCopy(LpcPortName + RpcpStringLength(LRPC_DIRECTORY_NAME),
            DceBinding->InqEndpoint(),
            (RpcpStringLength(DceBinding->InqEndpoint()) + 1)
                * sizeof(RPC_CHAR));

    RtlInitUnicodeString(&UnicodeString, LpcPortName);

    // zero out buffer to prevent data leak
    RpcpMemorySet (&BindExchange, 0, sizeof(BindExchange));

    DWORD Key;
    LPC_KEY *LpcKey = (LPC_KEY *) &Key;

    LpcKey->SeqNumber = SequenceNumber;
    LpcKey->AssocKey = (unsigned short) AssociationDictKey;
    BindExchange.ConnectType = LRPC_CONNECT_REQUEST ;
    BindExchange.AssocKey = Key;

    if (fBindBack)
        {
        BindExchange.Flags = BIND_BACK_FLAG;

        // Initialize a cookie to be sent in the message.
        RpcpMemoryCopy(BindExchange.Cookie, BindBackCookie, BIND_BACK_COOKIE_SIZE);

        // LRPC_BIND_EXCHANGE::szPortName can be at most PORT_NAME_LEN chars.
        // The global lrpc server's port name can be initialized either in
        // LRPC_SERVER::InitializeAsync or in LRPC_ADDRESS::ActuallySetupAddress.
        // In the former case, it is just "MSAsyncRPC_DECIMALPID" and in the latter,
        // we check to make sure the name does not overflow.
        LrpcGetEndpoint((RPC_CHAR *) BindExchange.szPortName) ;
        }
    else
        {
        BindExchange.Flags = 0;
        }

    if ((AssocAuthInfo.Capabilities & RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH)
        && AssocAuthInfo.ServerPrincipalName)
        {
        PSID pSID;

        // if we don't have a SID, we'll have to convert the name to a SID.
        if (AssocAuthInfo.ServerSid == NULL)
            {
            Status = RpcpLookupAccountName (AssocAuthInfo.ServerPrincipalName,
                &fCachedSid,
                &pSID
                );

            if (Status != RPC_S_OK)
                {
                delete [] LpcPortName;
                return Status;
                }
            }
        else
            {
            ASSERT(IsValidSid(AssocAuthInfo.ServerSid));
            pSID = AssocAuthInfo.ServerSid;
            }

        RetryCount = 0;

        do
            {
            Status = NormalizeAccountSid(pSID, &SidToUse, &RetryCount);
            if (Status != RPC_S_OK)
                {
                if (AssocAuthInfo.ServerSid == NULL)
                    {
                    delete [] pSID;
                    }
                delete [] LpcPortName;
                return Status;
                }

            NtStatus = NtSecureConnectPort (
                                            &LpcClientPort,
                                            &UnicodeString,
                                            &SecurityQualityOfService,
                                            NULL,
                                            SidToUse,
                                            NULL,
                                            NULL,
                                            &BindExchange,
                                            &BindExchangeLength);

            // we may attempt retry only if we got the server sid
            // wrong.
            if (NtStatus != STATUS_SERVER_SID_MISMATCH)
                break;
            }
        while (RetryCount != 0);

        if (AssocAuthInfo.ServerSid == NULL)
            {
            delete [] pSID;
            }
        }
    else
        {
        NtStatus = NtConnectPort(
                                 &LpcClientPort,
                                 &UnicodeString,
                                 &SecurityQualityOfService,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &BindExchange,
                                 &BindExchangeLength);
        }

    delete [] LpcPortName;
    if (NT_SUCCESS(NtStatus))
        {
        ASSERT(BindExchangeLength == sizeof(LRPC_BIND_EXCHANGE));

        return(BindExchange.RpcStatus);
        }

    if (NtStatus == STATUS_PORT_CONNECTION_REFUSED)
        {
        if (BindExchange.Flags & SERVER_BIND_EXCH_RESP)
            {
            RpcpErrorAddRecord(EEInfoGCRuntime, 
                BindExchange.RpcStatus,
                EEInfoDLLRPC_CASSOCIATION__OpenLpcPort20,
                NtStatus);
            return(BindExchange.RpcStatus);
            }

        // if the SERVER_BIND_EXCH_RESP flag is not set, the rejection
        // comes from LPC. The only case where this can happen is if
        // the server is not available.
        RpcpErrorAddRecord(EEInfoGCRuntime, 
            RPC_S_SERVER_UNAVAILABLE,
            EEInfoDLLRPC_CASSOCIATION__OpenLpcPort30,
            NtStatus);

        return(RPC_S_SERVER_UNAVAILABLE);
        }

    if (NtStatus == STATUS_NO_MEMORY)
        {
        Status = RPC_S_OUT_OF_MEMORY;
        }
    else if ((NtStatus == STATUS_INSUFFICIENT_RESOURCES)
        || (NtStatus == STATUS_QUOTA_EXCEEDED))
        {
        Status = RPC_S_OUT_OF_RESOURCES;
        }
    else if (NtStatus == STATUS_OBJECT_PATH_INVALID)
        {
        Status = RPC_S_INVALID_ENDPOINT_FORMAT;
        }

    else if (NtStatus == STATUS_ACCESS_DENIED
        || NtStatus == STATUS_SERVER_SID_MISMATCH
        || NtStatus == STATUS_BAD_IMPERSONATION_LEVEL)
        {
        // Invalidate our cache entry for this SPN
        (void) RemoveFromSIDCache(AssocAuthInfo.ServerPrincipalName);
        Status = RPC_S_ACCESS_DENIED;
        }
    else
        {
#if DBG
        if (NtStatus != STATUS_OBJECT_NAME_NOT_FOUND)
            {
            PrintToDebugger("LRPC: NtConnectPort : %lx\n", NtStatus);
            }
#endif // DBG

        ASSERT(NtStatus == STATUS_OBJECT_NAME_NOT_FOUND);

        Status = RPC_S_SERVER_UNAVAILABLE;
        }

    RpcpErrorAddRecord(EEInfoGCRuntime, 
        Status,
        EEInfoDLLRPC_CASSOCIATION__OpenLpcPort40,
        NtStatus);

    return Status;
}


void
LRPC_CASSOCIATION::FreeCCall (
    IN LRPC_CCALL * CCall
    )
/*++

Routine Description:

    This routine will get called to notify this association that a remote
    procedure call on this association has completed.

Arguments:

    CCall - Supplies the remote procedure call which has completed.

--*/
{
    LRPC_CCALL *DeletedCall;
    BOOL fMutexTaken = FALSE;
    ExtendedErrorInfo *LocalEEInfo;
    LRPC_MESSAGE *LocalLrpcMessage;
    THREAD *ThisThread;
    BOOL fCacheToThread;
    BOOL fOutstandingLocks = FALSE;
    BOOL fUnlocked;
    void *Buffer;
    unsigned int BufferLength ;

    if (CCall->CallId != (ULONG) -1)
        {

        // Try to take both resources, but if fail on the second, release
        // the first and retry.  There is a potential deadlock here, since
        // another thread may have the call locked while holding the AssociationMutex,
        // release the mutex, and try to take it again.  This may happen in
        // ProcessResponse()
        while (TRUE)
            {
            AssociationMutex.Request();
            fMutexTaken = TRUE;

            LogEvent(SU_CCALL, EV_STOP, CCall, this, CCall->CallId, 1, 0);

            if (CCall->AsyncStatus == RPC_S_CALL_CANCELLED)
                {
                // if the call was cancelled, there is a race condition
                // where the server may still be sending us a response
                // make sure we wait for any response already in the pipeline
                // to go through
                fOutstandingLocks = CCall->TryWaitForCallToBecomeUnlocked(&fUnlocked);

                if (fUnlocked)
                    break;
                else
                    {
                    AssociationMutex.Clear();
                    fMutexTaken = FALSE;
                    Sleep(10);
                    }
                }
            else
                {
                // this is not a cancel. It is possible that a response
                // is still being processed. We zero out the counter now,
                // and we will remove the element from the dictionary and
                // reset its CallId (we're still inside the mutex). When
                // the thread that processes the response is about to
                // decrease the refcount, it will check whether the call is
                // in the dictionary and whether it has the same call id.
                // If yes, it won't touch the call.
                CCall->ResponseLockCount.SetInteger(0);
                break;
                }
            }

        DeletedCall = ActiveCCalls.Delete(ULongToPtr(CCall->CallId));
        ASSERT((DeletedCall == 0) || (CCall == DeletedCall));

        CCall->CallId = (ULONG) -1;
        }

    LogEvent(SU_CCALL, EV_REMOVED, CCall, this, 0, 1, 2);
    LogEvent(SU_CCALL, EV_REMOVED, CCall, this, 0, 1, 6);

    if (CCall->BufferQueue.Size() != 0)
        {
        if (!fMutexTaken)
            {
            AssociationMutex.Request();
            fMutexTaken = TRUE;
            }

        while ((Buffer = CCall->BufferQueue.TakeOffQueue(&BufferLength)) != 0)
            {
            CCall->ActuallyFreeBuffer(Buffer);
            }
        }


    if (fMutexTaken)
        {
        LocalEEInfo = CCall->EEInfo;
        CCall->EEInfo = NULL;
        }
    else
        {
        LocalEEInfo = 
            (ExtendedErrorInfo *)InterlockedExchangePointer((PVOID *)(&CCall->EEInfo), NULL);
        }

    if (LocalEEInfo != NULL)
        {
        FreeEEInfoChain(LocalEEInfo);
        }

    CCall->Binding->RemoveReference();
    CCall->Binding = NULL;

    if (CCall == CachedCCall)
        {
        CachedCCallFlag = 1 ;
        }
    else
        {
        if (fMutexTaken)
            {
            LocalLrpcMessage = CCall->LrpcMessage;
            CCall->LrpcMessage = 0;
            }
        else
            {
            LocalLrpcMessage = 
                (LRPC_MESSAGE *)InterlockedExchangePointer((PVOID *)(&CCall->LrpcMessage), 0);
            }
        FreeMessage(LocalLrpcMessage);

        ThisThread = RpcpGetThreadPointer();

        ASSERT(ThisThread);

        if (gfServerPlatform && (ThisThread->GetCachedLrpcCall() == NULL))
            {
            CCall->FreeCallKey = -1;
            // set the association to NULL to toast anybody who tries to touch it
            CCall->Association = NULL;
            ThisThread->SetCachedLrpcCall(CCall);
            }
        else if (FreeCCalls.Size() < 64)
            {
            if (!fMutexTaken)
                {
                AssociationMutex.Request();
                fMutexTaken = TRUE;
                }

            if ((CCall->FreeCallKey = FreeCCalls.Insert(CCall)) == -1)
                {
                delete CCall;
                }
            }
        else
            {
            CCall->FreeCallKey = -1;
            delete CCall;
            }
        }

    if (fMutexTaken)
        {
        AssociationMutex.Clear();
        }

    if (fOutstandingLocks)
        {
        ThisThread = RpcpGetThreadPointer();

        ASSERT(ThisThread);

        ThisThread->SetDestroyedWithOutstandingLocksFlag();
        }

    RemoveReference();
}


LRPC_CASSOCIATION *
FindOrCreateLrpcAssociation (
    IN DCE_BINDING * DceBinding,
    IN CLIENT_AUTH_INFO *pClientAuthInfo,
    IN RPC_CLIENT_INTERFACE *InterfaceInfo
    )
/*++

Routine Description:

    This routine finds an existing association supporting the requested
    DCE binding, or creates a new association which supports the
    requested DCE binding.  Ownership of the passed DceBinding passes
    to this routine.

Arguments:

    DceBinding - Supplies binding information; if an association is
                 returned the ownership of the DceBinding is passed
                 to the association.

    pClientAuthInfo - pointer to the client auth info from the binding handle.
        We compare the client auth info of each association against the client
        auth info of the binding handle to determine if there is a match.

    InterfaceInfo - pointer to the interface we are about to make a call on
        while we try to find the association. If present, it also indicates
        we are trying to do shortcut endpoint resolution. If not present,
        we have already resolved the endpoint.

Return Value:

    An association which supports the requested binding will be returned.
    Otherwise, zero will be returned, indicating insufficient memory.

--*/
{
    LRPC_CASSOCIATION * Association;
    RPC_STATUS Status = RPC_S_OK;
    static USHORT SequenceNumber = 1;
    DictionaryCursor cursor;
    BOOL fOnlyEndpointDiffers;
    int Result;
    BOOL Supported;

    // First, we check for an existing association.

    LrpcAssociationDict->Reset(cursor);
    while ((Association = LrpcAssociationDict->Next(cursor)) != 0)
        {
#if defined (RPC_GC_AUDIT)
        DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Comparing association to: %S, %S, %S\n",
            GetCurrentProcessId(), GetCurrentProcessId(), Association->DceBinding->InqRpcProtocolSequence(),
            Association->DceBinding->InqNetworkAddress(), Association->DceBinding->InqEndpoint());
#endif
        Status = Association->IsSupportedAuthInfo(pClientAuthInfo, &Supported);
        if (Status != RPC_S_OK)
            {
            return NULL;
            }

        // if we are doing shortcut endpoint resolution, but the association
        // did not mutually authenticate the server with the endpoint mapper 
        // (endpoint mapper name space partitioning), and the binding
        // handle wants to mutually authenticate the server with the endpoint 
        // mapper, we cannot do shortcut endpoint resolution - we must allow
        // the endpoint resolution.
        if (Supported 
            && InterfaceInfo 
            && (pClientAuthInfo->Capabilities & RPC_C_QOS_CAPABILITIES_LOCAL_MA_HINT)
            && !(Association->GetAuthInfoCapabilities() & RPC_C_QOS_CAPABILITIES_LOCAL_MA_HINT)
            )
            {
            return NULL;
            }

        Result = Association->CompareWithDceBinding(DceBinding, &fOnlyEndpointDiffers);
        if ((Supported)
            &&
            (!Result
                ||
             (
                fOnlyEndpointDiffers
                && InterfaceInfo
                && DceBinding->IsNullEndpoint()
                && Association->DoesBindingForInterfaceExist(InterfaceInfo)
             )
            )
           )
            {
            Association->AddBindingHandleReference();
            if (Association->Linger.fAssociationLingered == TRUE)
                {
#if defined (RPC_GC_AUDIT)
                DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) LRPC lingering association resurrected %X %S %S %S\n",
                    GetCurrentProcessId(), GetCurrentProcessId(), Association,
                    Association->DceBinding->InqRpcProtocolSequence(),
                    Association->DceBinding->InqNetworkAddress(), 
                    Association->DceBinding->InqEndpoint());
#endif
                LrpcLingeredAssociations --;
                ASSERT(LrpcLingeredAssociations >= 0);
                Association->Linger.fAssociationLingered = FALSE;
                }

            if ((pClientAuthInfo->Capabilities & RPC_C_QOS_CAPABILITIES_LOCAL_MA_HINT)
			    && !(Association->GetAuthInfoCapabilities() & RPC_C_QOS_CAPABILITIES_LOCAL_MA_HINT))
                {
                Association->AddLocalMAToCapabilities();
                }

            delete DceBinding;
            return(Association);
            }
        }

    // if asked to do short endpoint resolution, don't create new association
    if (InterfaceInfo)
        return NULL;

#if defined (RPC_GC_AUDIT)
    DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Creating association to: %S, %S, %S\n",
        GetCurrentProcessId(), GetCurrentProcessId(), DceBinding->InqRpcProtocolSequence(),
        DceBinding->InqNetworkAddress(), DceBinding->InqEndpoint());
#endif

    SequenceNumber = (SequenceNumber+1) % (0x7FFF);
    Association = new LRPC_CASSOCIATION(DceBinding,
                                        pClientAuthInfo,                                       
                                        SequenceNumber,
                                        &Status);

    if ((Association != 0) && (Status == RPC_S_OK))
        {
        Association->AssociationDictKey = LrpcAssociationDict->Insert(Association);

        if (Association->AssociationDictKey == -1)
            {
            Association->DceBinding = 0;
            delete Association;
            return(0);
            }

        return(Association);
        }
    else
        {
        if (Association != 0)
            {
            Association->DceBinding = 0;
            delete Association;
            }
        return(0);
        }

    ASSERT(0);
    return(0);
}


void
ShutdownLrpcClient (
    )
/*++

Routine Description:

    This routine will get called when the process which is using this dll
    exits.  We will go through and notify any servers that we are going
    away.

--*/
{
    LRPC_CASSOCIATION * Association;
    DictionaryCursor cursor;

    if (LrpcAssociationDict != 0)
        {
        LrpcAssociationDict->Reset(cursor);
        while ((Association = LrpcAssociationDict->Next(cursor)) != 0)
            {
            Association->RemoveReference() ;
            }
        }
}


void
LRPC_CASSOCIATION::AbortAssociation (
    IN BOOL ServerAborted
    )
/*++

Routine Description:

    This association needs to be aborted because a the server side of the
    lpc port has been closed.

--*/
{
    LRPC_BINDING * Binding;
    LRPC_CCALL *CCall ;
    LRPC_CCONTEXT *SecurityContext;
    DictionaryCursor cursor;

    AssociationMutex.Request();

    LogEvent(SU_CASSOC, EV_ABORT, this, 0, ServerAborted, 1, 0);

    CloseLpcClientPort();

    Bindings.Reset(cursor);
    while ((Binding = Bindings.RemoveNext(cursor)) != 0)
        {
        // RemoveReference will destroy the binding if its 
        // ref count reaches 0
        Binding->RemoveReference();
        }

    SecurityContextDict.Reset(cursor);
    while (SecurityContext = SecurityContextDict.RemoveNext(cursor))
        {
        SecurityContext->Destroy();
        }

    int waitIterations = 8;
    if (ServerAborted)
        {
        ActiveCCalls.Reset(cursor);
        while ((CCall = ActiveCCalls.Next(cursor, TRUE)) != 0)
            {
            CCall->ServerAborted(&waitIterations);
            }
        }

    // nuke the free calls as well, because when we abort the association
    // some information in them will be stale
    FreeCCalls.Reset(cursor);
    while ((CCall = FreeCCalls.Next(cursor)) != 0)
        {
        delete CCall;
        }

    AssociationMutex.Clear();
}

void
LRPC_CASSOCIATION::CloseLpcClientPort (
    )
/*++

Routine Description:

    The LpcClientPort will be closed (and a close message sent to the server).

--*/
{
    NTSTATUS NtStatus;
    HANDLE LpcPortLocal;

    if (LpcClientPort != 0)
        {
        // Another thread might be trying to do a send or a send/receive on this port
        // while the association is being aborted.  We need to make sure the send on
        // the port can't come after the port has been closed.
        // To accomplish this, we set the port to NULL and close a local copy.  The clients
        // may still send on a NULL port, via a small race, but the probability
        // can be reduced by checking for a NULL handle and we will just get an error from LPC.
        // Also, the port sits on the stack for a little bit while we call the 
        // LPC routines, so the race is still there, but its minimal.
        LpcPortLocal = LpcClientPort;
        LpcClientPort = 0;
        NtStatus = NtClose(LpcPortLocal);

#if DBG

        if (!NT_SUCCESS(NtStatus))
            {
            PrintToDebugger("RPC : NtClose : %lx\n", NtStatus);
            }

#endif // DBG

        if (LpcReceivePort)
            {
            // Similarly to the above case, set the port to NULL and close a local copy.
            LpcPortLocal = LpcReceivePort;
            LpcReceivePort = 0;
            NtStatus = NtClose(LpcPortLocal) ;

#if DBG
            if (!NT_SUCCESS(NtStatus))
                {
                PrintToDebugger("RPC : NtClose : %lx\n", NtStatus);
                }

#endif

            ASSERT(NT_SUCCESS(NtStatus));
            }
        BackConnectionCreated = 0;
        }
}


RPC_STATUS
LRPC_CASSOCIATION::IsSupportedAuthInfo(
    IN CLIENT_AUTH_INFO * ClientAuthInfo,
    OUT BOOL *Supported
    )
/*++

Routine Description:

    Check if this association supports the needed auth info.

Arguments:

    ClientAuthInfo - description

    Supported - on output, contains non-zero if the association supports
        this auth info, and 0 otherwise. Undefined on failure

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    PSID Sid;
    RPC_STATUS RpcStatus;

    *Supported = FALSE;

    if (!ClientAuthInfo)
        {
        if (AssocAuthInfo.ImpersonationType == RPC_C_IMP_LEVEL_IMPERSONATE)
            {
            *Supported = TRUE;
            return RPC_S_OK;
            }
        return RPC_S_OK;
        }

    if ((ClientAuthInfo->AuthenticationLevel == RPC_C_AUTHN_LEVEL_NONE
        && AssocAuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE)
        || (AssocAuthInfo.AuthenticationLevel == RPC_C_AUTHN_LEVEL_NONE
        && ClientAuthInfo->AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE))
        {
        return RPC_S_OK;
        }

    ASSERT(ClientAuthInfo->AuthenticationService == RPC_C_AUTHN_WINNT);

    if (ClientAuthInfo->AuthorizationService
                != AssocAuthInfo.AuthorizationService)
        {
        return RPC_S_OK;
        }

#if 0
    if (ClientAuthInfo->IdentityTracking != AssocAuthInfo.IdentityTracking)
        {
        return RPC_S_OK;
        }
#endif

    if (ClientAuthInfo->ImpersonationType != AssocAuthInfo.ImpersonationType)
        {
        return RPC_S_OK;
        }

    if (ClientAuthInfo->Capabilities & RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH)
        {
        // if the SPN and SID are equal, this is supported
        return AssocAuthInfo.CompareSPNAndSID (ClientAuthInfo, Supported);
        }

    *Supported = TRUE;
    return RPC_S_OK;
}


LRPC_CCALL::LRPC_CCALL (
    IN OUT RPC_STATUS  *Status
    ) : CallMutex(Status), 
        SyncEvent(Status, 0),
        ResponseLockCount(0)
/*++

--*/
{
    ObjectType = LRPC_CCALL_TYPE;
    CurrentBindingHandle = 0;
    Association = 0;
    CallAbortedFlag = 0;
    LrpcMessage = 0;
    CachedLrpcMessage = 0;
    FreeCallKey = -1;
    CallId = (ULONG) -1;
    EEInfo = NULL;
}



LRPC_CCALL::~LRPC_CCALL (
    )
/*++

--*/
{
    if (LrpcMessage)
        {
        FreeMessage(LrpcMessage) ;
        }

    if (CachedLrpcMessage)
        {
        FreeMessage(CachedLrpcMessage) ;
        }

    if (CallId != (ULONG) -1)
        {
        // the association mutex is currently held
        Association->ActiveCCalls.Delete(ULongToPtr(CallId));
        }

    if (FreeCallKey != -1)
        {
        Association->FreeCCalls.Delete(FreeCallKey) ;
        }
}


RPC_STATUS
LRPC_CCALL::NegotiateTransferSyntax (
    IN OUT PRPC_MESSAGE Message
    )
{
    // just return the transfer syntax already negotiated in the binding
    Message->TransferSyntax = Binding->GetTransferSyntaxId();

    return RPC_S_OK;
}


RPC_STATUS
LRPC_CCALL::GetBuffer (
    IN OUT PRPC_MESSAGE Message,
    IN UUID *ObjectUuid
    )
/*++

Routine Description:

    We will allocate a buffer which will be used to either send a request
    or receive a response.

    ObjectUuid - Ignored

Arguments:

    Message - Supplies the length of the buffer that is needed.  The buffer
        will be returned.

Return Value:

    RPC_S_OK - A buffer has been successfully allocated.  It will be of at
        least the required length.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate that
        large a buffer.

--*/
{
    RPC_STATUS Status;

    SetObjectUuid(ObjectUuid);

    if (LrpcMessage == 0)
        {
        LrpcMessage = AllocateMessage();

        if (LrpcMessage == 0)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            goto Cleanup;
            }
        }

    if (PARTIAL(Message))
        {
        CurrentBufferLength = (Message->BufferLength < MINIMUM_PARTIAL_BUFFLEN)
            ?   MINIMUM_PARTIAL_BUFFLEN:Message->BufferLength ;

        Message->Buffer = RpcpFarAllocate(CurrentBufferLength);
        if (Message->Buffer == 0)
            {
            CurrentBufferLength = 0 ;
            Status = RPC_S_OUT_OF_MEMORY;
            goto Cleanup;
            }
        }
    else if (Message->BufferLength <= MAXIMUM_MESSAGE_BUFFER)
        {
        CurrentBufferLength = MAXIMUM_MESSAGE_BUFFER ;

        // Uncomment to check for 16 byte alignment on 64 bit
        // ASSERT(IsBufferAligned(LrpcMessage->Rpc.Buffer));

        Message->Buffer = LrpcMessage->Rpc.Buffer;
        LrpcMessage->Rpc.RpcHeader.Flags = LRPC_BUFFER_IMMEDIATE;
        LrpcMessage->LpcHeader.u2.ZeroInit = 0;
        LrpcMessage->LpcHeader.u1.s1.DataLength = (USHORT)
                (Align4(Message->BufferLength) + sizeof(LRPC_RPC_HEADER));

        return(RPC_S_OK);
        }
    else
        {
        CurrentBufferLength = Message->BufferLength ;
        Message->Buffer = RpcpFarAllocate(Message->BufferLength);
        if (Message->Buffer == 0)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            goto Cleanup;
            }
        }

    LrpcMessage->Rpc.RpcHeader.Flags = LRPC_BUFFER_REQUEST;
    LrpcMessage->Rpc.Request.CountDataEntries = 1;
    LrpcMessage->Rpc.Request.DataEntries[0].Base = PtrToMsgPtr(Message->Buffer);
    LrpcMessage->Rpc.Request.DataEntries[0].Size = Message->BufferLength;
    LrpcMessage->LpcHeader.CallbackId = 0;
    LrpcMessage->LpcHeader.u2.ZeroInit = 0;
    LrpcMessage->LpcHeader.u2.s2.DataInfoOffset = sizeof(PORT_MESSAGE)
                 + sizeof(LRPC_RPC_HEADER);
    LrpcMessage->LpcHeader.u1.s1.DataLength = sizeof(LRPC_RPC_HEADER)
                 + sizeof(PORT_DATA_INFORMATION);

    Status = RPC_S_OK;
Cleanup:
    if (Status != RPC_S_OK)
        {
        AbortCCall();
        ASSERT(Status == RPC_S_OUT_OF_MEMORY);
        }
    return(Status);
}


RPC_STATUS
LpcError (
    IN NTSTATUS NtStatus,
    IN BOOL fDNE
    )
{
    if (NtStatus == STATUS_NO_MEMORY)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }
    if (NtStatus == STATUS_INSUFFICIENT_RESOURCES)
        {
        return(RPC_S_OUT_OF_RESOURCES);
        }

    VALIDATE(NtStatus)
        {
        STATUS_INVALID_PORT_HANDLE,
        STATUS_INVALID_HANDLE,
        STATUS_PORT_DISCONNECTED,
        STATUS_LPC_REPLY_LOST
        } END_VALIDATE;

    if ((NtStatus != STATUS_LPC_REPLY_LOST) && fDNE)
        {
        return (RPC_S_CALL_FAILED_DNE) ;
        }

    return (RPC_S_CALL_FAILED);
}


RPC_STATUS
LRPC_CCALL::AsyncSend (
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:

    Send an async request. This request can be either partial or complete.

Arguments:

 Message - contains the request.

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/
{
    RPC_STATUS Status ;
    NTSTATUS NtStatus ;
    BOOL fRetVal ;
    BOOL Shutup ;
    ULONG_PTR fNonCausal;
    ULONG AsyncStateFlags;

    // If it is a small request, we send it here, otherwise, we
    // use the helper function.

    ASSERT(pAsync) ;
    Status = CurrentBindingHandle->InqTransportOption(
                                               RPC_C_OPT_BINDING_NONCAUSAL,
                                               &fNonCausal);
    ASSERT(Status == RPC_S_OK);

    if (fNonCausal == 0)
        {
        LrpcMessage->Rpc.RpcHeader.Flags  |= LRPC_CAUSAL;
        }

    if (LrpcMessage->Rpc.RpcHeader.Flags & LRPC_BUFFER_IMMEDIATE)
        {
        LrpcMessage->LpcHeader.u1.s1.TotalLength = sizeof(PORT_MESSAGE)
                    + LrpcMessage->LpcHeader.u1.s1.DataLength;
        LrpcMessage->Rpc.RpcHeader.MessageType = LRPC_MSG_REQUEST;
        LrpcMessage->Rpc.RpcHeader.Pad = 0;
        LrpcMessage->Rpc.RpcHeader.ProcedureNumber = (unsigned short) Message->ProcNum;
        LrpcMessage->Rpc.RpcHeader.PresentContext = GetOnTheWirePresentationContext();
        if (CurrentSecurityContext)
            {
            LrpcMessage->Rpc.RpcHeader.SecurityContextId = CurrentSecurityContext->SecurityContextId;
            }
        else
            {
            LrpcMessage->Rpc.RpcHeader.SecurityContextId = -1;
            }

        ASSERT(CallId != (ULONG) -1);
        LrpcMessage->Rpc.RpcHeader.CallId = CallId ;

        if (UuidSpecified)
            {
            RpcpMemoryCopy(&(LrpcMessage->Rpc.RpcHeader.ObjectUuid),
                       &ObjectUuid, sizeof(UUID));
            LrpcMessage->Rpc.RpcHeader.Flags  |= LRPC_OBJECT_UUID;
            }
        else
            {
            // zero out the guid to prevent data leak
            RpcpMemorySet(&(LrpcMessage->Rpc.RpcHeader.ObjectUuid),
                       0, sizeof(UUID));
            }

        // Make sure the port has not been closed due to an association abort.
        if (Association->LpcClientPort)
            {
            NtStatus = NtRequestPort(Association->LpcClientPort,
                                    (PORT_MESSAGE *) LrpcMessage) ;
            }
        else
            {
            NtStatus = STATUS_INVALID_PORT_HANDLE;
            }

        if (NT_ERROR(NtStatus))
            {
            FreeCCall() ;
            return LpcError(NtStatus, TRUE) ;
            }

        Status = RPC_S_OK;
       }
    else
        {
        AsyncStateFlags = pAsync->Flags;
        // Take the call mutex if this is an async pipe call, we can assume that 
        // it is async since we are in AsyncSend, we must check if its pipe.
        // We need to take the mutex to avoid a race between setting fSendMoreExpected in AsyncSend and
        // checking it in the thread pool when servicing a LRPC_SERVER_SEND_MORE (ProcessResponse).  Without this
        // we could end up not getting a notification for this send
        if (PARTIAL(Message))
            CallMutex.Request();

        Status = SendRequest(Message, &Shutup) ;

        if ((AsyncStateFlags & RPC_C_NOTIFY_ON_SEND_COMPLETE)
            && (Status == RPC_S_OK || Status == RPC_S_SEND_INCOMPLETE))
            {
            if (Shutup)
                {
                fSendMoreExpected = TRUE;
                }
            else
                {
                fSendMoreExpected = FALSE;
                if (!IssueNotification(RpcSendComplete))
                    {
                    Status = RPC_S_OUT_OF_MEMORY ;
                    }
                }
            }

        if (PARTIAL(Message))
            CallMutex.Clear();
        }

    if (Status == RPC_S_OK)
        {
        CallMutex.Request();
        if (AsyncStatus == RPC_S_CALL_FAILED)
            {
            LogEvent(SU_CCALL, EV_ABORT, this, (PVOID) 44, 44, 1, 0);
            Status = RPC_S_CALL_FAILED;
            CallMutex.Clear();

            FreeCCall();
            }
        else
            {
            fSendComplete = 1;
            CallMutex.Clear();
            }
        }

    return(Status);
}


RPC_STATUS
LRPC_CCALL::AsyncReceive (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned int Size
    )
/*++

Routine Description:

Arguments:

 Message - Contains the request. On return, it will contain the received buffer
  and its length.
 Size - Requested size.

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/
{
    RPC_STATUS Status;
    int Extra = IsExtraMessage(Message);

    Message->DataRepresentation = 0x00 | 0x10 | 0x0000;

    if (!Extra && Message->Buffer)
        {
        ActuallyFreeBuffer((char  *)Message->Buffer);
        Message->Buffer = 0;
        Message->BufferLength = 0;
        }

    CallMutex.Request();

    if (BufferComplete)
        {
        Status = GetCoalescedBuffer(Message, Extra);
        }
    else
        {
        if (PARTIAL(Message))
            {
            if (RcvBufferLength < Size)
                {
                if (NOTIFY(Message))
                    {
                    NeededLength = Size ;
                    }
                Status = RPC_S_ASYNC_CALL_PENDING;
                }
            else
                {
                Status = GetCoalescedBuffer(Message, Extra);
                }
            }
        else
            {
            Status = AsyncStatus;
            ASSERT(Status != RPC_S_OK);
            }
        }

    CallMutex.Clear();

    if (Status == RPC_S_OK
        || Status == RPC_S_ASYNC_CALL_PENDING)
        {
        return Status;
        }

    FreeCCall();

    return Status;
}


RPC_STATUS
LRPC_CCALL::CancelAsyncCall (
    IN BOOL fAbort
    )
/*++
Function Name:CancelAsyncCall

Parameters:
    fAbort - TRUE: the cancel is abortive, ie, the call completes immediately
                FALSE: a cancel PDU is sent to the server, the call doesn't complete
                until the server returns

Description:

Returns:
    RPC_S_OK: The call was successfully cancelled
    others - an error occured during the cancellation process
--*/
{
#if defined(BUILD_WOW6432)
    char LrpcCancelMessageBuffer[sizeof(LRPC_CANCEL_MESSAGE) + 8];
    LRPC_CANCEL_MESSAGE *LrpcCancelMessagePtr = (LRPC_CANCEL_MESSAGE *)AlignPtr8(LrpcCancelMessageBuffer);
#else
    LRPC_CANCEL_MESSAGE LrpcCancelMessageBuffer;
    LRPC_CANCEL_MESSAGE *LrpcCancelMessagePtr = &LrpcCancelMessageBuffer;
#endif
    NTSTATUS NtStatus;

    LogEvent(SU_CCALL, EV_ABORT, this, 0, fAbort, 1, 1);

    //
    // Notify the server that the call has been cancelled
    //
    LrpcCancelMessagePtr->LpcHeader.u1.s1.DataLength = sizeof(LRPC_CANCEL_MESSAGE)
            - sizeof(PORT_MESSAGE);
    LrpcCancelMessagePtr->LpcHeader.u1.s1.TotalLength = sizeof(LRPC_CANCEL_MESSAGE);
    LrpcCancelMessagePtr->LpcHeader.u2.ZeroInit = 0;
    SanitizeLpcHeader (&LrpcCancelMessagePtr->LpcHeader);

    ASSERT(CallId != (ULONG) -1);
    // zero out everything b/n MessageType and CallId
    RPCP_ZERO_OUT_STRUCT_RANGE(LRPC_RPC_HEADER, 
        &LrpcCancelMessagePtr->RpcHeader,
        Pad,
        CallId
        );

    LrpcCancelMessagePtr->RpcHeader.CallId = CallId;
    LrpcCancelMessagePtr->RpcHeader.MessageType = LRPC_MSG_CANCEL;

    // Make sure the port has not been closed due to an association abort.
    if (Association->LpcClientPort)
        {
        NtStatus = NtRequestPort(Association->LpcClientPort,
                                (PORT_MESSAGE *) LrpcCancelMessagePtr) ;
        }
    else
        {
        NtStatus = STATUS_INVALID_PORT_HANDLE;
        }

    // sending the notification to the server is a best effort. We ignore the
    // result

    if (fAbort)
        {
        //
        // If the cancel was abortive, complete the call right away.
        //

        //
        // We indicate completion. When the app calls RpcAsyncCompleteCall
        // we will destroy the call. That is fine, even if the server
        // hasn't replied yet, because if the server sends a reply to
        // a call or an association that is not there, the client code
        // is protected, and will simply free the packet.
        //
        CallFailed(RPC_S_CALL_CANCELLED);
        }

    return RPC_S_OK;
}


void
LRPC_CCALL::ProcessResponse(
    IN LRPC_MESSAGE *LrpcResponse
    )
/*++

Routine Description:

    A buffer has just arrived, process it. If some other buffer is already
    processing buffers, simply queue it and go away. Otherwise, does
    the processing ourselves.

Arguments:

 Message - Details on the arrived message
--*/
{
    RPC_MESSAGE Message ;
    RPC_STATUS Status ;
    BOOL fRetVal = 0;
    BOOL fFault2;
    RPC_STATUS FaultStatus;
    THREAD *ThisThread;
    ExtendedErrorInfo *EEInfo;
    DelayedPipeAckData AckData;

    //
    // So that abort will not issue a notification
    //
    fSendComplete = 0;

    switch (LrpcResponse->Rpc.RpcHeader.MessageType)
        {
        case LRPC_MSG_FAULT:
            if (LrpcResponse->Fault.RpcHeader.Flags & LRPC_EEINFO_PRESENT)
                {
                ThisThread = RpcpGetThreadPointer();
                ASSERT(ThisThread);

                ASSERT(ThisThread->GetEEInfo() == NULL);

                if (LrpcResponse->Fault.LpcHeader.u1.s1.TotalLength > 
                    (sizeof(LRPC_FAULT_MESSAGE) - sizeof(LrpcResponse->Fault.Buffer)))
                    {
                    Status = UnpickleEEInfo(LrpcResponse->Fault.Buffer,
                        LrpcResponse->Fault.LpcHeader.u1.s1.TotalLength 
                            - sizeof(LRPC_FAULT_MESSAGE) 
                            + sizeof(LrpcResponse->Fault.Buffer),
                        &EEInfo);
                    if (Status == RPC_S_OK)
                        {
                        this->EEInfo = EEInfo;
                        }
                    }
                }

            if (pAsync == 0)
                {
                AsyncStatus = LrpcResponse->Fault.RpcStatus ;
                SyncEvent.Raise();
                }
            else
                {
                CallFailed(LrpcResponse->Fault.RpcStatus);
                }

            FreeMessage(LrpcResponse);
            return ;

        case LRPC_CLIENT_SEND_MORE:
            if (pAsync
                && (pAsync->Flags & RPC_C_NOTIFY_ON_SEND_COMPLETE))
                {
                // Take the call mutex if this is an async pipe call, we can assume that 
                // it is async since we are in AsyncSend, we must check if its pipe.
                // We need to take the mutex to avoid a race between setting fSendMoreExpected in AsyncSend and
                // checking it in the thread pool when servicing a LRPC_SERVER_SEND_MORE (ProcessResponse).  Without this
                // we could end up not getting a notification for this send
                CallMutex.Request();
                if (fSendMoreExpected)
                    {
                    CallMutex.Clear();
                    if (!IssueNotification(RpcSendComplete))
                        {
                        CallFailed(RPC_S_OUT_OF_MEMORY);
                        }
                    }
                else
                    {
                    CallMutex.Clear();
                    CORRUPTION_ASSERT(0);
                    CallFailed(RPC_S_PROTOCOL_ERROR);
                    }
                }
            FreeMessage(LrpcResponse);
            return;
        }

    ASSERT((LrpcResponse->Rpc.RpcHeader.MessageType == LRPC_MSG_FAULT2)
        || (LrpcResponse->Rpc.RpcHeader.MessageType == LRPC_MSG_RESPONSE));

    if (LrpcResponse->Rpc.RpcHeader.MessageType == LRPC_MSG_FAULT2)
        {
        fFault2 = TRUE;
        FaultStatus = LrpcResponse->Fault2.RpcStatus;
        }
    else
        fFault2 = FALSE;

    Message.RpcFlags = 0;
    AckData.DelayedAckPipeNeeded = FALSE;

    Status = LrpcMessageToRpcMessage(LrpcResponse,
                        &Message,
                        Association->LpcReceivePort,
                        TRUE,   // IsReplyFromBackConnection
                        &AckData
                        ) ;

    if (fFault2 && (Status == RPC_S_OK))
        {
        ThisThread = RpcpGetThreadPointer();
        ASSERT(ThisThread);

        ASSERT(ThisThread->GetEEInfo() == NULL);
        Status = UnpickleEEInfo((unsigned char *)Message.Buffer,
            Message.BufferLength,
            &EEInfo);
        if (Status == RPC_S_OK)
            {
            this->EEInfo = EEInfo;
            }
        // else
        // fall through the error case below, which will
        // handle the failure properly
        }

    if ((Status != RPC_S_OK) || fFault2)
        {
        // remember to send delayed ack if any
        if (AckData.DelayedAckPipeNeeded)
            {
            (void) SendPipeAck(Association->LpcReceivePort,
                LrpcResponse,
                AckData.CurrentStatus);

            if ((Status != RPC_S_OK) && (Message.Buffer))
                {
                RpcpFarFree(Message.Buffer);
                }

            FreeMessage(LrpcResponse) ;
            }

        if (fFault2)
            {
            AsyncStatus = FaultStatus;
            Status = FaultStatus;
            }
        else
            AsyncStatus = Status ;

        if (pAsync == 0)
            {
            SyncEvent.Raise();
            }
        else
            {
            CallFailed(Status);
            }

        return;
        }

    CallMutex.Request() ;

    // we have taken the mutex - now we can send the ack
    // The reason we need to wait for the mutex to be
    // taken before we send the delayed ack for pipes is
    // that once we send an ack, the server will send more
    // data and these can race with this thread. To be
    // safe, we need to take the mutex.
    if (AckData.DelayedAckPipeNeeded)
        {
        Status = SendPipeAck(Association->LpcReceivePort,
            LrpcResponse,
            AckData.CurrentStatus);

        FreeMessage(LrpcResponse) ;

        if (Status != RPC_S_OK)
            {
            CallMutex.Clear();

            if (Message.Buffer)
                {
                RpcpFarFree(Message.Buffer);
                }

            AsyncStatus = Status ;

            if (pAsync == 0)
                {
                SyncEvent.Raise();
                }
            else
                {
                CallFailed(Status);
                }

            return;
            }
        }

    if (COMPLETE(&Message))
        {
        BufferComplete = 1;
        }

    RcvBufferLength += Message.BufferLength ;
    if (Message.BufferLength)
        {
        if (BufferQueue.PutOnQueue(Message.Buffer,
                                   Message.BufferLength))
            {
            Status = RPC_S_OUT_OF_MEMORY ;
#if DBG
            PrintToDebugger("RPC: PutOnQueue failed\n") ;
#endif
            if (pAsync)
                {
                CallMutex.Clear();
                CallFailed(Status);
                return;
                }
            else
                {
                AsyncStatus = Status;
                }
            }
        }

    if (pAsync == 0)
        {
        CallMutex.Clear() ;

        SyncEvent.Raise();
        return;
        }

    if (BufferComplete)
        {
        AsyncStatus = RPC_S_OK;
        CallMutex.Clear() ;
        IssueNotification();
        }
    else
        {
        if (NeededLength > 0 && RcvBufferLength >= NeededLength)
            {
            CallMutex.Clear() ;
            IssueNotification(RpcReceiveComplete);
            }
        else
            {
            CallMutex.Clear() ;
            }
        }

}


RPC_STATUS
LRPC_CCALL::GetCoalescedBuffer (
    IN PRPC_MESSAGE Message,
    IN BOOL BufferValid
    )
/*++

Routine Description:

    Remove buffers from the queue and coalesce them into a single buffer.

Arguments:

 Message - on return this will contain the coalesced buffer, Message->BufferLength
  gives us the length of the coalesced buffer.
 BufferValid - Tells us if Message->Buffer is valid on entry.

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/
{
    void *NewBuffer, *Buffer ;
    char *Current ;
    unsigned int bufferlength ;
    unsigned int TotalLength ;
    LRPC_SENDMORE_MESSAGE SendMore ;
    NTSTATUS NtStatus ;

    CallMutex.Request() ;

    if (RcvBufferLength == 0)
        {
        if (BufferComplete)
            {
            Message->RpcFlags |= RPC_BUFFER_COMPLETE ;
            }

        if (BufferValid == 0)
            {
            Message->Buffer = 0;
            Message->BufferLength = 0;
            }

        CallMutex.Clear();

        return RPC_S_OK;
        }

    BOOL fFillNewBuffer;

    if (BufferValid)
        {
        TotalLength = RcvBufferLength + Message->BufferLength ;

        NewBuffer = RpcpFarAllocate(TotalLength) ;
        if (NewBuffer == 0)
            {
            CallMutex.Clear() ;
            return RPC_S_OUT_OF_MEMORY;
            }

        RpcpMemoryCopy(NewBuffer, Message->Buffer, Message->BufferLength) ;
        Current = (char *) NewBuffer + Message->BufferLength ;
        fFillNewBuffer = 1;
        }
    else
        {
        TotalLength = RcvBufferLength ;

        if (BufferQueue.Size() == 1)
            {
            Buffer = BufferQueue.TakeOffQueue(&bufferlength);
            ASSERT(Buffer);

            NewBuffer = Buffer;
            ASSERT(TotalLength == bufferlength);

            fFillNewBuffer = 0;
            }
        else
            {
            NewBuffer = RpcpFarAllocate(TotalLength) ;
            if (NewBuffer == 0)
                {
                CallMutex.Clear() ;
                return RPC_S_OUT_OF_MEMORY;
                }
            Current = (char *) NewBuffer;

            fFillNewBuffer = 1;
            }
        }

    if (fFillNewBuffer)
        {
        while ((Buffer = BufferQueue.TakeOffQueue(&bufferlength)) != 0)
            {
            RpcpMemoryCopy(Current, Buffer, bufferlength) ;
            Current += bufferlength ;
            ActuallyFreeBuffer(Buffer);
            }
        }

    if (Message->Buffer)
        {
        ActuallyFreeBuffer(Message->Buffer);
        }

    Message->Buffer = NewBuffer ;
    Message->BufferLength = TotalLength ;

    RcvBufferLength = 0;

    if (BufferComplete)
        {
        Message->RpcFlags |= RPC_BUFFER_COMPLETE ;
        }
    else
        {
        if (Choked)
            {
            CallMutex.Clear() ;

            //
            // send a message to the server
            // to start sending data again
            //
            SendMore.LpcHeader.u1.s1.DataLength =
                sizeof(SendMore) - sizeof(PORT_MESSAGE);
            SendMore.LpcHeader.u1.s1.TotalLength = sizeof(SendMore);
            SendMore.LpcHeader.u2.ZeroInit = 0;
            SendMore.LpcHeader.CallbackId = 0;
            SendMore.LpcHeader.MessageId =  0;
            SanitizeLpcHeader (&SendMore.LpcHeader);

            // zero out everything b/n MessageType and CallId
            RPCP_ZERO_OUT_STRUCT_RANGE(LRPC_RPC_HEADER, 
                &SendMore.RpcHeader,
                Pad,
                CallId
                );

            SendMore.RpcHeader.MessageType = LRPC_SERVER_SEND_MORE;
            SendMore.RpcHeader.CallId = CallId ;

            ASSERT(CallId != (ULONG) -1);

            // Make sure the port has not been closed due to an association abort.
            if (Association->LpcClientPort)
                {
                NtStatus = NtRequestPort(Association->LpcClientPort,
                                        (PORT_MESSAGE *) &SendMore) ;
                }
            else
                {
                NtStatus = STATUS_INVALID_PORT_HANDLE;
                }

            if (!NT_SUCCESS(NtStatus))
                {
                return RPC_S_CALL_FAILED ;
                }

            return RPC_S_OK;
            }
        }

    CallMutex.Clear() ;

    return RPC_S_OK ;
}


void
LRPC_CCALL::ServerAborted (
    IN OUT int *waitIterations
    )
/*++

Routine Description:

    The server has died, we need the call needs to reflect that, and
    cleanup if possible.

--*/

{
    if (pAsync)
        {
        int i;

        for (;*waitIterations && AsyncStatus == RPC_S_ASYNC_CALL_PENDING; (*waitIterations)--)
            {
            Sleep(500);
            }

        LogEvent(SU_CCALL, EV_ABORT, this, (PVOID) 22, 22, 1, 0);
        CallMutex.Request();
        if (AsyncStatus == RPC_S_ASYNC_CALL_PENDING)
            {
            if (fSendComplete == 0)
                {
                AsyncStatus = RPC_S_CALL_FAILED;
                CallMutex.Clear();
                }
            else
                {
                CallMutex.Clear();
                CallFailed(RPC_S_CALL_FAILED);
                }
            }
        else 
            {
            CallMutex.Clear();
            }
        }
}


RPC_STATUS
LRPC_CCALL::SendReceive (
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:


Arguments:

    Message - Supplies the request and returns the response of a remote
        procedure call.

Return Value:

    RPC_S_OK - The remote procedure call completed successful.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to perform the
        remote procedure call.

    RPC_S_OUT_OF_RESOURCES - Insufficient resources are available to complete
        the remote procedure call.

--*/
{
    NTSTATUS NtStatus;
    RPC_STATUS ExceptionCode, Status;
    void * OriginalMessageBuffer;
    LRPC_MESSAGE *SavedLrpcMessage = 0;
    LRPC_MESSAGE *TmpLrpcMessage = 0;
    int ActiveCallSetupFlag = 0;
    void * TempBuffer;
    ExtendedErrorInfo *EEInfo;

    DebugClientCallInfo *ClientCallInfo;
    DebugCallTargetInfo *CallTargetInfo;
    CellTag ClientCallInfoCellTag;
    CellTag CallTargetInfoCellTag;
    THREAD *ThisThread = RpcpGetThreadPointer();
    BOOL fDebugInfoSet = FALSE;

    if (CallAbortedFlag != 0)
        {
        //
        // Don't know if it is safe to free the buffer here
        //
        return(RPC_S_CALL_FAILED_DNE);
        }

    ASSERT(ThisThread);

    // if either client side debugging is enabled or we are
    // calling on a thread that has a scall dispatched
    if ((IsClientSideDebugInfoEnabled() || ((ThisThread->Context) && IsServerSideDebugInfoEnabled())) && (RecursionCount == 0))
        {
        CStackAnsi AnsiString;
        RPC_CHAR *Endpoint;
        int EndpointLength;

        if (!IsClientSideDebugInfoEnabled())
            {
            Status = SetDebugClientCallInformation(&ClientCallInfo, &ClientCallInfoCellTag,
                &CallTargetInfo, &CallTargetInfoCellTag, Message, ThisThread->DebugCell,
                ThisThread->DebugCellTag);
            }
        else
            {
            Status = SetDebugClientCallInformation(&ClientCallInfo, &ClientCallInfoCellTag,
                &CallTargetInfo, &CallTargetInfoCellTag, Message, NULL, NULL);
            }

        if (Status != RPC_S_OK)
            {
            TempBuffer = NULL;
            goto Cleanup;
            }

        ClientCallInfo->CallID = CallId;

        Endpoint = Association->InqEndpoint();
        EndpointLength = RpcpStringLength(Endpoint) + 1;
        *(AnsiString.GetPAnsiString()) = (char *)_alloca(EndpointLength);

        Status = AnsiString.Attach(Endpoint, EndpointLength, EndpointLength * 2);

        // effectively ignore failure in the conversion
        if (Status == RPC_S_OK)
            {
            strncpy(ClientCallInfo->Endpoint, AnsiString, sizeof(ClientCallInfo->Endpoint));
            }

        CallTargetInfo->ProtocolSequence = LRPC_TOWER_ID;
        CallTargetInfo->TargetServer[0] = 0;

        fDebugInfoSet = TRUE;
        }

    // NDR_DREP_ASCII | NDR_DREP_LITTLE_ENDIAN | NDR_DREP_IEEE

    Message->DataRepresentation = 0x00 | 0x10 | 0x0000;

    if (CallStack == 0)
        {
        if (UuidSpecified)
            {
            RpcpMemoryCopy(&(LrpcMessage->Rpc.RpcHeader.ObjectUuid),
                            &ObjectUuid, sizeof(UUID));
            LrpcMessage->Rpc.RpcHeader.Flags  |= LRPC_OBJECT_UUID;
            }

        }
    else
        {
        LrpcMessage->LpcHeader.u2.s2.Type = LPC_REQUEST;
        LrpcMessage->LpcHeader.ClientId = ClientIdToMsgClientId(ClientId);
        LrpcMessage->LpcHeader.MessageId = MessageId;
        LrpcMessage->LpcHeader.CallbackId = CallbackId;
        }

    LrpcMessage->LpcHeader.u1.s1.TotalLength = sizeof(PORT_MESSAGE)
                + LrpcMessage->LpcHeader.u1.s1.DataLength;

    LrpcMessage->Rpc.RpcHeader.MessageType = LRPC_MSG_REQUEST;

    LrpcMessage->Rpc.RpcHeader.ProcedureNumber = (unsigned short) Message->ProcNum;
    LrpcMessage->Rpc.RpcHeader.PresentContext = GetOnTheWirePresentationContext();
    if (CurrentSecurityContext)
        {
        LrpcMessage->Rpc.RpcHeader.SecurityContextId = CurrentSecurityContext->SecurityContextId;

        // Make sure we can't be impersonated on the transport level if
        // static identity tracking is being used.  We may be under different
        // identity now then we were during the bind.  The server is supposed
        // to capture the token during bind and use it later under
        // static idenitity tracking.
        ASSERT(CurrentBindingHandle != NULL);
        if (CurrentBindingHandle->GetIdentityTracking() == RPC_C_QOS_IDENTITY_STATIC)
            {
            LrpcMessage->LpcHeader.u2.s2.Type |= LPC_NO_IMPERSONATE;
            }
        }
    else
        {
        LrpcMessage->Rpc.RpcHeader.SecurityContextId = -1;
        }

    TempBuffer = Message->Buffer;
    LrpcMessage->Rpc.RpcHeader.Flags |= LRPC_SYNC_CLIENT | LRPC_NON_PIPE;
    LrpcMessage->Rpc.RpcHeader.Pad = 0;

    // Make sure the port has not been closed due to an association abort.
    if (Association->LpcClientPort)
        {
        NtStatus = NtRequestWaitReplyPort(Association->LpcClientPort,
                                         (PORT_MESSAGE *) LrpcMessage,
                                         (PORT_MESSAGE *) LrpcMessage);
        }
    else
        {
        NtStatus = STATUS_INVALID_PORT_HANDLE;
        }

    if (NT_ERROR(NtStatus))
        {
        if (NtStatus == STATUS_NO_MEMORY)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            goto Cleanup;
            }
        if (NtStatus == STATUS_INSUFFICIENT_RESOURCES)
            {
            Status = RPC_S_OUT_OF_RESOURCES;
            goto Cleanup;
            }

        VALIDATE(NtStatus)
            {
            STATUS_INVALID_PORT_HANDLE,
            STATUS_INVALID_HANDLE,
            STATUS_PORT_DISCONNECTED,
            STATUS_LPC_REPLY_LOST
            } END_VALIDATE;

        Association->AbortAssociation();

        if ((CallStack == 0)
               && (NtStatus != STATUS_LPC_REPLY_LOST))
            {
            //
            // It's possible that the server stopped and has now restarted.
            // We'll try re-binding and only fail if the new call fails.
            //
            // We can only retry if we are SURE that the server did not
            // execute the request.

            if (RecursionCount > 3)
                {
                // Prevent an infinite loop when GetBuffer returns ok but
                // the SendReceive always fails.
                Status = RPC_S_CALL_FAILED_DNE;
                }
            else
                {
                Status = AutoRetryCall(Message, 
                                       TRUE     // fFromSendReceive
                                       );
                }
            }
        else
            {
            // In a callback and/or couldn't retry.
            Status = RPC_S_CALL_FAILED;
            }

Cleanup:
        if (fDebugInfoSet)
            {
            FreeCell(CallTargetInfo, &CallTargetInfoCellTag);
            FreeCell(ClientCallInfo, &ClientCallInfoCellTag);
            }
        ActuallyFreeBuffer(TempBuffer);
        AbortCCall();
        return Status;
        }

    // The message was sent and we got a reply okay.

    ActuallyFreeBuffer(Message->Buffer);

    for (;;)
        {
        if (LrpcMessage->Rpc.RpcHeader.MessageType == LRPC_MSG_FAULT)
            {
            if (LrpcMessage->Fault.RpcHeader.Flags & LRPC_EEINFO_PRESENT)
                {
                Status = UnpickleEEInfo(LrpcMessage->Fault.Buffer,
                    LrpcMessage->Fault.LpcHeader.u1.s1.TotalLength 
                        - sizeof(LRPC_FAULT_MESSAGE) 
                        + sizeof(LrpcMessage->Fault.Buffer),
                    &EEInfo);
                if (Status == RPC_S_OK)
                    {
                    RpcpSetEEInfoForThread(ThisThread, EEInfo);
                    }
                // else we just fall through and return an error code - 
                // this is best effort, so it's Ok
                }
            Status = LrpcMessage->Fault.RpcStatus;
            break;
            }

        if ((LrpcMessage->Rpc.RpcHeader.MessageType == LRPC_MSG_RESPONSE)
            || (LrpcMessage->Rpc.RpcHeader.MessageType == LRPC_MSG_FAULT2))
            {
            BOOL fFault2;
            RPC_STATUS FaultStatus;

            // remember if the message was fault2
            if (LrpcMessage->Rpc.RpcHeader.MessageType == LRPC_MSG_FAULT2)
                {
                fFault2 = TRUE;
                FaultStatus = LrpcMessage->Fault2.RpcStatus;
                }
            else
                fFault2 = FALSE;

            Status = LrpcMessageToRpcMessage(LrpcMessage,
                                             Message,
                                             Association->LpcClientPort,
                                             FALSE, // IsReplyFromBackConnection
                                             NULL   // StatusIfDelayedAck
                                             );

            if (fFault2)
                {
                if (Status == RPC_S_OK)
                    {
                    Status = UnpickleEEInfo((unsigned char *)Message->Buffer,
                        Message->BufferLength,
                        &EEInfo);
                    if (Status == RPC_S_OK)
                        {
                        RpcpSetEEInfoForThread(ThisThread, EEInfo);
                        }
                    // else
                    // fall through to restoring the original status
                    }

                // the status of the retrieval of
                // the extended error info is irrelevant - we
                // need to restore the original fault code
                Status = FaultStatus;
                }
            break;
            }

        ASSERT(LrpcMessage->Rpc.RpcHeader.MessageType
                        == LRPC_MSG_CALLBACK);

        CallStack += 1;

        Status = RPC_S_OK;
        if ((CallStack == 1)
            && (ActiveCallSetupFlag == 0))
            {
            ClientId = MsgClientIdToClientId(LrpcMessage->LpcHeader.ClientId);
            MessageId = LrpcMessage->LpcHeader.MessageId;
            CallbackId = LrpcMessage->LpcHeader.CallbackId;

            RecursiveCallsKey = CurrentBindingHandle->AddRecursiveCall(this);
            if (RecursiveCallsKey == -1)
                {
                Status = RPC_S_OUT_OF_MEMORY;
                }
            else
                {
                ActiveCallSetupFlag = 1;
                }
            }

        if (SavedLrpcMessage == 0)
            {
            // First callback, we may need to allocated a new LRPC_MESSAGE.
            if (CachedLrpcMessage == 0)
                {
                CachedLrpcMessage = AllocateMessage() ;
                }
            if (CachedLrpcMessage == 0)
                Status = RPC_S_OUT_OF_MEMORY;
            }

        if (Status == RPC_S_OK)
            {
            Status = LrpcMessageToRpcMessage(LrpcMessage,
                                             Message,
                                             Association->LpcClientPort,
                                             FALSE,     // IsReplyFromBackConnection
                                             NULL       // StatusIfDelayedAck
                                             );

            }

        if (Status != RPC_S_OK)
            {
            ActuallyFreeBuffer(Message->Buffer);

            LrpcMessage->Fault.RpcHeader.MessageType = LRPC_MSG_FAULT;
            LrpcMessage->Fault.RpcStatus = LrpcMapRpcStatus(Status);
            LrpcMessage->LpcHeader.u1.s1.DataLength =
                    sizeof(LRPC_FAULT_MESSAGE) - sizeof(PORT_MESSAGE);
            LrpcMessage->LpcHeader.u1.s1.TotalLength =
                    sizeof(LRPC_FAULT_MESSAGE);
            LrpcMessage->LpcHeader.ClientId = ClientIdToMsgClientId(ClientId);
            LrpcMessage->LpcHeader.MessageId = MessageId;
            LrpcMessage->LpcHeader.CallbackId = CallbackId;

            // Make sure the port has not been closed due to an association abort.
            if (Association->LpcClientPort)
                {
                NtStatus = NtReplyWaitReplyPort(Association->LpcClientPort,
                                               (PORT_MESSAGE *) LrpcMessage);
                }
            else
                {
                NtStatus = STATUS_INVALID_PORT_HANDLE;
                }
            }
        else
            {
            PRPC_DISPATCH_TABLE DispatchTableToUse;

            OriginalMessageBuffer = Message->Buffer;
            Message->TransferSyntax = Binding->GetTransferSyntaxId();
            Message->ProcNum = LrpcMessage->Rpc.RpcHeader.ProcedureNumber;

            if (SavedLrpcMessage == 0)
                {
                // First callback
                ASSERT(CachedLrpcMessage != 0);
                SavedLrpcMessage = LrpcMessage;
                LrpcMessage = CachedLrpcMessage;
                CachedLrpcMessage = 0;
                }
            else
                {
                // >First callback, LrpcMessage and SavedLrpcMessages swap roles
                TmpLrpcMessage = SavedLrpcMessage;
                SavedLrpcMessage = LrpcMessage;
                LrpcMessage = TmpLrpcMessage;
                }

            // Check to make sure this procnum can actually receive callbacks and
            // a valid callback is specified.
            // On error - ignore the PDU.
            PRPC_DISPATCH_TABLE DispatchTableCallback = Binding->GetDispatchTable();
            if (DispatchTableCallback &&
                Message->ProcNum < DispatchTableCallback->DispatchTableCount &&
                DispatchTableCallback->DispatchTable[Message->ProcNum] != NULL)
                {
                Status = DispatchCallback(DispatchTableCallback,
                                          Message,
                                          &ExceptionCode);
                }
            else
                {
                CORRUPTION_ASSERT(0);
                Status = RPC_S_PROTOCOL_ERROR;
                }

            if (OriginalMessageBuffer != SavedLrpcMessage->Rpc.Buffer)
                {
                ActuallyFreeBuffer(OriginalMessageBuffer);
                }

            if (Status != RPC_S_OK)
                {
                VALIDATE(Status)
                    {
                    RPC_P_EXCEPTION_OCCURED,
                    RPC_S_PROCNUM_OUT_OF_RANGE
                    } END_VALIDATE;

                if (Status == RPC_P_EXCEPTION_OCCURED)
                    {
                    Status = LrpcMapRpcStatus(ExceptionCode);
                    }

                LrpcMessage->Fault.RpcStatus = Status;
                LrpcMessage->LpcHeader.u1.s1.DataLength =
                        sizeof(LRPC_FAULT_MESSAGE) - sizeof(PORT_MESSAGE);
                LrpcMessage->LpcHeader.u1.s1.TotalLength =
                        sizeof(LRPC_FAULT_MESSAGE);
                LrpcMessage->Fault.RpcHeader.MessageType = LRPC_MSG_FAULT;
                }
            else
                {
                LrpcMessage->Rpc.RpcHeader.MessageType =
                        LRPC_MSG_RESPONSE;

                if (LrpcMessage->Rpc.RpcHeader.Flags & LRPC_BUFFER_REQUEST)
                    {
                    Status = MakeServerCopyResponse();

                    if (Status != RPC_S_OK)
                        {
                        break;
                        }
                    }
                }

            LrpcMessage->LpcHeader.ClientId = ClientIdToMsgClientId(ClientId);
            LrpcMessage->LpcHeader.MessageId = MessageId;
            LrpcMessage->LpcHeader.CallbackId = CallbackId;
            LrpcMessage->LpcHeader.u1.s1.TotalLength =
                LrpcMessage->LpcHeader.u1.s1.DataLength + sizeof(PORT_MESSAGE);

            // Make sure the port has not been closed due to an association abort.
            if (Association->LpcClientPort)
                {
                NtStatus = NtReplyWaitReplyPort(Association->LpcClientPort,
                                               (PORT_MESSAGE *) LrpcMessage);
                }
            else
                {
                NtStatus = STATUS_INVALID_PORT_HANDLE;
                }

            RpcpPurgeEEInfo();

            }
        CallStack -= 1;

        if (NT_ERROR(NtStatus))
            {
            if (NtStatus == STATUS_NO_MEMORY)
                {
                Status = RPC_S_OUT_OF_MEMORY;
                }
            else if (NtStatus == STATUS_INSUFFICIENT_RESOURCES)
                {
                Status = RPC_S_OUT_OF_RESOURCES;
                }
            else
                {
                Association->AbortAssociation();
                VALIDATE(NtStatus)
                    {
                    STATUS_INVALID_PORT_HANDLE,
                    STATUS_INVALID_HANDLE,
                    STATUS_PORT_DISCONNECTED,
                    STATUS_LPC_REPLY_LOST
                    } END_VALIDATE;
                Status = RPC_S_CALL_FAILED;
                }
            break;
            }
        }

    if (SavedLrpcMessage != 0)
        {
        if (CachedLrpcMessage != 0)
            {
            FreeMessage(CachedLrpcMessage) ;
            }

        CachedLrpcMessage = SavedLrpcMessage;
        }

    if (ActiveCallSetupFlag != 0)
        {
        CurrentBindingHandle->RemoveRecursiveCall(RecursiveCallsKey);
        }

    if (Status != RPC_S_OK)
        {
        if (CallStack == 0)
            {
            FreeCCall();
            }
        }

    if (fDebugInfoSet)
        {
        FreeCell(CallTargetInfo, &CallTargetInfoCellTag);
        FreeCell(ClientCallInfo, &ClientCallInfoCellTag);
        }

    return(Status);
}


RPC_STATUS
LRPC_CCALL::SendRequest (
    IN OUT PRPC_MESSAGE Message,
    OUT BOOL *Shutup
   )
/*++

Routine Description:

    Helper function used for sending async requests or pipe requests

Arguments:

    Message - request message

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory
 RPC_S_SEND_INCOMPLETE - we were unable to send the complete request.

--*/

{
    NTSTATUS NtStatus;
    RPC_STATUS ExceptionCode, Status;
    void * OriginalMessageBuffer;
    LRPC_MESSAGE *TmpLrpcMessage = 0;
    void * TempBuffer;
    LRPC_MESSAGE *LrpcReplyMessage ;
    int RemainingLength = 0;

    ASSERT((LrpcMessage->Rpc.RpcHeader.Flags
                & LRPC_BUFFER_IMMEDIATE)  == 0) ;
    *Shutup = 0;

    if (CallAbortedFlag != 0)
        {
        return(RPC_S_CALL_FAILED_DNE);
        }

    if (CallStack > 0)
        {
        return (RPC_S_CALL_FAILED);
        }

    if (PARTIAL(Message))
        {
        if (Message->BufferLength < MINIMUM_PARTIAL_BUFFLEN)
            {
            return (RPC_S_SEND_INCOMPLETE);
            }

        LrpcMessage->Rpc.RpcHeader.Flags |= LRPC_BUFFER_PARTIAL ;
        if (NOT_MULTIPLE_OF_EIGHT(Message->BufferLength))
            {
            RemainingLength = Message->BufferLength & LOW_BITS ;
            Message->BufferLength &= ~LOW_BITS ;
            }
        }

    // NDR_DREP_ASCII | NDR_DREP_LITTLE_ENDIAN | NDR_DREP_IEEE
    Message->DataRepresentation = 0x00 | 0x10 | 0x0000;

    ASSERT(CallId != (ULONG) -1);
    LrpcMessage->Rpc.RpcHeader.CallId = CallId ;

    if (FirstFrag)
        {
        LrpcMessage->Rpc.RpcHeader.MessageType = LRPC_MSG_REQUEST;
        }
    else
        {
        LrpcMessage->Rpc.RpcHeader.MessageType = LRPC_PARTIAL_REQUEST;
        }

    LrpcMessage->LpcHeader.u1.s1.TotalLength =
        sizeof(PORT_MESSAGE) + LrpcMessage->LpcHeader.u1.s1.DataLength;

    LrpcMessage->Rpc.Request.DataEntries[0].Size = Message->BufferLength;
    LrpcMessage->Rpc.RpcHeader.ProcedureNumber = (unsigned short) Message->ProcNum;
    LrpcMessage->Rpc.RpcHeader.PresentContext = GetOnTheWirePresentationContext();
    LrpcMessage->Rpc.RpcHeader.Pad = 0;
    if (CurrentSecurityContext)
        {
        LrpcMessage->Rpc.RpcHeader.SecurityContextId = CurrentSecurityContext->SecurityContextId;
        }
    else
        {
        LrpcMessage->Rpc.RpcHeader.SecurityContextId = -1;
        }

    if (UuidSpecified)
        {
        ASSERT(CallStack == 0) ;
        RpcpMemoryCopy(&(LrpcMessage->Rpc.RpcHeader.ObjectUuid),
               &ObjectUuid, sizeof(UUID));
        LrpcMessage->Rpc.RpcHeader.Flags  |= LRPC_OBJECT_UUID;
        }
    else
        {
        // zero out uninitialized data
        RpcpMemorySet(&(LrpcMessage->Rpc.RpcHeader.ObjectUuid),
               0, sizeof(UUID));
        }

    // Make sure we can't be impersonated on the transport level if
    // static identity tracking is being used.
    ASSERT(CurrentBindingHandle != NULL);
    if (CurrentBindingHandle->GetIdentityTracking() == RPC_C_QOS_IDENTITY_STATIC)
        {
        LrpcMessage->LpcHeader.u2.s2.Type |= LPC_NO_IMPERSONATE;
        }

    if (Association->LpcClientPort)
        {
        NtStatus = NtRequestWaitReplyPort(Association->LpcClientPort,
                                         (PORT_MESSAGE *) LrpcMessage,
                                         (PORT_MESSAGE *) LrpcMessage);
        }
    else
        {
        NtStatus = STATUS_INVALID_PORT_HANDLE;
        }

    if (NT_ERROR(NtStatus))
        {
        TempBuffer = Message->Buffer;

        if (NtStatus == STATUS_NO_MEMORY)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            goto Cleanup;
            }
        if (NtStatus == STATUS_INSUFFICIENT_RESOURCES)
            {
            Status = RPC_S_OUT_OF_RESOURCES;
            goto Cleanup;
            }

        VALIDATE(NtStatus)
            {
            STATUS_INVALID_PORT_HANDLE,
            STATUS_INVALID_HANDLE,
            STATUS_PORT_DISCONNECTED,
            STATUS_LPC_REPLY_LOST
            } END_VALIDATE;

        if (pAsync)
            {
            ASSERT(RecursionCount == 0);

            if (NtStatus != STATUS_LPC_REPLY_LOST)
                {
                Status = RPC_S_CALL_FAILED_DNE;
                }
            else
                {
                Status = RPC_S_CALL_FAILED;
                }

            goto Cleanup;
            }

        Association->AbortAssociation();

        if ((NtStatus != STATUS_LPC_REPLY_LOST) && FirstFrag)
            {
            ASSERT(CallStack == 0) ;

            //
            // It's possible that the server stopped and has now restarted.
            // We'll try re-binding and only fail if the new call fails.
            //
            // We can only retry if we are SURE that the server did not
            // execute the request.

            if (RecursionCount > 3)
                {
                // Prevent an infinite loop when GetBuffer returns ok but
                // the SendReceive always fails.
                Status = RPC_S_CALL_FAILED_DNE;
                }
            else
                {
                Status = AutoRetryCall(Message, 
                                       FALSE     // fFromSendReceive
                                       );
                }
            }
        else
            {
            // In a callback and/or couldn't retry.
            Status = RPC_S_CALL_FAILED;
            }

Cleanup:
        ActuallyFreeBuffer(TempBuffer);
        AbortCCall();
        return Status;
        }
    else
        {
        FirstFrag = 0;
        }

    if (LrpcMessage->Rpc.RpcHeader.MessageType == LRPC_MSG_ACK)
        {
        *Shutup  = LrpcMessage->Ack.Shutup ;

        if (PARTIAL(Message))
            {
            if (LrpcMessage->Ack.RpcStatus == RPC_S_OK)
                {
                if (RemainingLength)
                    {
                    RpcpMemoryMove(Message->Buffer,
                                   (char  *) Message->Buffer + Message->BufferLength,
                                    RemainingLength) ;

                    Message->BufferLength = RemainingLength ;
                    return (RPC_S_SEND_INCOMPLETE) ;
                    }

                return RPC_S_OK;
                }
            }

        ActuallyFreeBuffer(Message->Buffer);
        Message->Buffer = 0;

        return LrpcMessage->Ack.RpcStatus ;
        }

    ActuallyFreeBuffer(Message->Buffer);
    Message->Buffer = 0;

    if (LrpcMessage->Rpc.RpcHeader.MessageType == LRPC_MSG_RESPONSE)
        {
        ASSERT(!PARTIAL(Message)) ;

        CurrentBufferLength = 0;

        Status = LrpcMessageToRpcMessage(LrpcMessage,
                                         Message,
                                         Association->LpcClientPort,
                                         FALSE,     // IsReplyFromBackConnection
                                         NULL       // StatusIfDelayedAck
                                         );

        if (Status == RPC_S_OK
            && COMPLETE(Message))
            {
            BufferComplete = 1;
            }

        Message->RpcFlags = 0;
        // we have no out pipes
        ASSERT(Status != RPC_S_OK || BufferComplete) ;
        }
    else  if (LrpcMessage->Rpc.RpcHeader.MessageType == LRPC_MSG_FAULT)
        {
        CurrentBufferLength = 0;
        Status = LrpcMessage->Fault.RpcStatus;
        }
    else 
        {
        // The server should only return messages of types: LRPC_MSG_ACK,
        // LRPC_MSG_RESPONSE, and LRPC_MSG_FAULT.  All of these have been handled in
        // the above clauses.
        ASSERT(0 && "Invalid message type");
        Status = RPC_S_CALL_FAILED;
        }

    if (Status != RPC_S_OK)
        {
        ASSERT(CallStack == 0) ;
        FreeCCall();
        }

    return Status ;
}


RPC_STATUS 
LRPC_CCALL::AutoRetryCall (
    IN OUT PRPC_MESSAGE Message, 
    BOOL fFromSendReceive
    )
{
    RPC_STATUS Status;
    void *OldBuffer;
    UUID *UuidToUse;
    LRPC_CCALL *NewCall;

    // any failure after this is unrelated
    RpcpPurgeEEInfo();

    OldBuffer = Message->Buffer;
    Message->Handle = (RPC_BINDING_HANDLE) CurrentBindingHandle;

    if (UuidSpecified)
        {
        UuidToUse = &ObjectUuid;
        }
    else
        {
        UuidToUse = 0;
        }

    Status = CurrentBindingHandle->NegotiateTransferSyntax(Message);
    if (Status != RPC_S_OK)
        goto CleanupAndReturn;

    NewCall = ((LRPC_CCALL *)(Message->Handle));
    Status = NewCall->GetBuffer(Message, UuidToUse);
    if (Status != RPC_S_OK)
        goto CleanupAndReturn;

    ASSERT(Message->Buffer != OldBuffer);

    RpcpMemoryCopy(Message->Buffer, OldBuffer,
                   Message->BufferLength);

    // This CCALL should be freed,
    // a new one was allocated in NegotiateTransferSyntax and is now being used.

    ASSERT(NewCall != this);

    NewCall->SetRecursionCount(RecursionCount + 1);

    if (fFromSendReceive)
        Status = NewCall->SendReceive(Message);
    else
        Status = NewCall->Send(Message);

    // the caller has remembered the old buffer and call object,
    // and will clean them up regardless of what we return - our
    // job is simply to allocate a new call and buffer, and stick
    // them in the Message

CleanupAndReturn:
    if (Status == RPC_S_SERVER_UNAVAILABLE)
        {
        // Since we're retrying, if the server has gone missing,
        // it just means that the call failed.

        Status = RPC_S_CALL_FAILED_DNE;
        }

    return(Status);
}

RPC_STATUS
LRPC_CCALL::Send (
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:
    This rountine is used by pipes to send partila data...

Arguments:

    Message - Supplies the request and returns the response of a remote
        procedure call.

Return Value:

    RPC_S_OK - The remote procedure call completed successful.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to perform the
        remote procedure call.

    RPC_S_OUT_OF_RESOURCES - Insufficient resources are available to complete
        the remote procedure call.
--*/
{
    RPC_STATUS Status ;
    BOOL Shutup ;

    Status = SendRequest(Message, &Shutup) ;

    return(Status);
}



RPC_STATUS
LRPC_CCALL::Receive (
    IN PRPC_MESSAGE Message,
    IN unsigned int Size
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/

{
    int size = 0 ;
    int BufferLength ;
    int RequestedLength ;
    RPC_STATUS Status ;
    int ActualBufferLength = 0;
    int Extra = IsExtraMessage(Message) ;

    if (BufferComplete
        && RcvBufferLength == 0)
        {
        Message->RpcFlags |= RPC_BUFFER_COMPLETE ;
        return (RPC_S_OK) ;
        }

    // If you get here, it means that you have out pipe data.

    //
    // allocate a buffer big enough to hold the out data:
    // if you have a partial receive, you can allocate the buffer up
    // front and start receive data.
    //
    if (PARTIAL(Message))
        {
        if (Extra)
            {
            ActualBufferLength = Message->BufferLength ;
            BufferLength = Message->BufferLength+Size ;
            }
        else
            {
            BufferLength = Size ;
            }
        }
    else
        {
        if (Extra)
            {
            ActualBufferLength = Message->BufferLength ;
            BufferLength = Message->BufferLength + MINIMUM_PARTIAL_BUFFLEN ;
            }
        else
            {
            BufferLength = MINIMUM_PARTIAL_BUFFLEN ;
            }
        }

    Status = GetBufferDo(Message, BufferLength, Extra) ;
    if (Status != RPC_S_OK)
        {
        FreeCCall();
        return Status ;
        }
    RequestedLength = Message->BufferLength - ActualBufferLength;

    while (!BufferComplete
           && (!PARTIAL(Message) || (RcvBufferLength < Size)))
        {
        if (SyncEvent.Wait() == WAIT_FAILED)
            {
            return RPC_S_CALL_FAILED;
            }
        }

    return GetCoalescedBuffer(Message, Extra);
}


void
LRPC_CCALL::FreeBuffer (
    IN PRPC_MESSAGE Message
    )
/*++

Routine Description:

    We will free the supplied buffer.

Arguments:

    Message - Supplies the buffer to be freed.

--*/
{
    ActuallyFreeBuffer(Message->Buffer);

    if (CallStack == 0)
        {
        FreeCCall();
        }
}

void
LRPC_CCALL::FreePipeBuffer (
    IN PRPC_MESSAGE Message
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/

{
    RpcpFarFree(Message->Buffer) ;
}

RPC_STATUS
LRPC_CCALL::GetBufferDo (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned long NewSize,
    IN int fDataValid
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/

{
    void *NewBuffer ;
    int SizeToAlloc ;

    if (NewSize < CurrentBufferLength)
        {
        Message->BufferLength = NewSize ;
        }
    else
        {
        SizeToAlloc = (NewSize < MINIMUM_PARTIAL_BUFFLEN) ?
                        MINIMUM_PARTIAL_BUFFLEN:NewSize ;

        NewBuffer = RpcpFarAllocate(SizeToAlloc) ;
        if (NewBuffer == 0)
            {
            RpcpFarFree(Message->Buffer) ;
            CurrentBufferLength = 0;
            Message->BufferLength = 0;
            return RPC_S_OUT_OF_MEMORY ;
            }

        if (fDataValid && Message->BufferLength > 0)
            {
            RpcpMemoryCopy(NewBuffer,
                           Message->Buffer,
                           Message->BufferLength) ;
            }

        RpcpFarFree(Message->Buffer) ;
        Message->Buffer = NewBuffer ;
        Message->BufferLength = NewSize ;
        CurrentBufferLength = SizeToAlloc ;
        }

    return RPC_S_OK ;
}

RPC_STATUS
LRPC_CCALL::ReallocPipeBuffer (
    IN PRPC_MESSAGE Message,
    IN unsigned int NewSize
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/

{
    unsigned int SizeToAlloc ;
    void *TempBuffer ;

    if (LrpcMessage == 0)
        {
        LrpcMessage = AllocateMessage();
        if (LrpcMessage == 0)
            {
            return(RPC_S_OUT_OF_MEMORY);
            }
        }

    if (GetBufferDo(Message, NewSize, 1) != RPC_S_OK)
        return RPC_S_OUT_OF_MEMORY ;

    Message->BufferLength = NewSize ;

    LrpcMessage->Rpc.RpcHeader.Flags = LRPC_BUFFER_REQUEST;
    LrpcMessage->Rpc.Request.CountDataEntries = 1;
    LrpcMessage->Rpc.Request.DataEntries[0].Base = PtrToMsgPtr(Message->Buffer);
    LrpcMessage->Rpc.Request.DataEntries[0].Size = Message->BufferLength;
    LrpcMessage->LpcHeader.CallbackId = 0;
    LrpcMessage->LpcHeader.u2.ZeroInit = 0;
    LrpcMessage->LpcHeader.u2.s2.DataInfoOffset = sizeof(PORT_MESSAGE)
                 + sizeof(LRPC_RPC_HEADER);
    LrpcMessage->LpcHeader.u1.s1.DataLength = sizeof(LRPC_RPC_HEADER)
                 + sizeof(PORT_DATA_INFORMATION);

    return (RPC_S_OK) ;
}


void
LRPC_CCALL::AbortCCall (
    )
/*++

Routine Description:

    This client call has failed, so we need to abort it.  We may called
    while nested in one or more callbacks.

--*/
{
    LRPC_BINDING_HANDLE * BindingHandle;

    CallAbortedFlag = 1;

    if (CallStack == 0)
        {
        ASSERT(CurrentBindingHandle != 0);

        BindingHandle = CurrentBindingHandle;
        CurrentBindingHandle = 0;
        BindingHandle->FreeCCall(this);
        }
}


inline RPC_STATUS
LRPC_CCALL::LrpcMessageToRpcMessage (
    IN LRPC_MESSAGE *LrpcResponse,
    OUT RPC_MESSAGE *Message,
    IN HANDLE LpcPort,
    IN BOOL IsReplyFromBackConnection OPTIONAL,
    OUT DelayedPipeAckData *AckData OPTIONAL
    )
/*++

Routine Description:

    We will convert from an LRPC_MESSAGE representation of a buffer (and
    its length) to an RPC_MESSAGE representation.

Arguments:

    LrpcResponse - the response we received from the server

    RpcMessage - Returns the RPC_MESSAGE representation.

    LpcPort - the association port on which we send data to the server

    IsReplyFromBackConnection - non-zero if the reply is from back connection

    AckData - if non-NULL, and the received data are pipe data, an 
        acknowledgement to a pipe response will be delayed, the current 
        status will be placed here, and it will be indicated the ack was
        delayed. Also, if non-NULL, the caller must set 
        AckData->DelayedAckPipeNeeded to FALSE.
        If NULL, any acknowledgement will be sent immediately.

--*/
{
    NTSTATUS NtStatus;
    SIZE_T NumberOfBytesRead;
#if defined(BUILD_WOW6432)
    char CopyMessageBuffer[sizeof(LRPC_COPY_MESSAGE) + 8];
    LRPC_COPY_MESSAGE *CopyMessagePtr = (LRPC_COPY_MESSAGE *) AlignPtr8(CopyMessageBuffer);
#else
    LRPC_COPY_MESSAGE CopyMessageBuffer;
    LRPC_COPY_MESSAGE *CopyMessagePtr = &CopyMessageBuffer;
#endif
    RPC_STATUS Status = RPC_S_OK;
    RPC_STATUS Status2;
    BOOL fPartialResponse;

    if (ARGUMENT_PRESENT(AckData))
        {
        ASSERT(AckData->DelayedAckPipeNeeded == FALSE);
        }

   if(LrpcResponse->Rpc.RpcHeader.Flags & LRPC_BUFFER_IMMEDIATE)
        {

       if (LrpcResponse->LpcHeader.u1.s1.DataLength < sizeof(LRPC_RPC_HEADER))
            {
            ASSERT(LrpcResponse->LpcHeader.u1.s1.DataLength >= sizeof(LRPC_RPC_HEADER));
            return RPC_S_PROTOCOL_ERROR;
            }

        Message->Buffer = LrpcResponse->Rpc.Buffer;
        Message->BufferLength =
                      (unsigned int) LrpcResponse->LpcHeader.u1.s1.DataLength
                      - sizeof(LRPC_RPC_HEADER);

        if ((LrpcResponse->Rpc.RpcHeader.Flags & LRPC_BUFFER_PARTIAL) == 0)
            {
            Message->RpcFlags |= RPC_BUFFER_COMPLETE ;
            }

        if (IsReplyFromBackConnection)
            {
            LpcReplyMessage = LrpcResponse ;
            }
        }
    else if (LrpcResponse->Rpc.RpcHeader.Flags & LRPC_BUFFER_SERVER)
        {
        if (IsReplyFromBackConnection == 0)
            {
            UINT BufferLength;
            LPC_PVOID ServerBuffer;

            ASSERT(LrpcMessage == LrpcResponse);
            BufferLength = LrpcResponse->Rpc.Server.Length;
            ServerBuffer = LrpcResponse->Rpc.Server.Buffer;
            Message->BufferLength = BufferLength;

            Message->RpcFlags |= RPC_BUFFER_COMPLETE ;
            
            
            CopyMessagePtr->LpcHeader.u2.ZeroInit = 0;
            SanitizeLpcHeader (&CopyMessagePtr->LpcHeader);
            CopyMessagePtr->Server.Buffer = ServerBuffer;
            CopyMessagePtr->Server.Length = BufferLength;
            if (BufferLength >= 0x80000000)
                {
                ASSERT(BufferLength < 0x80000000);
                Message->Buffer = 0;
                CopyMessagePtr->RpcStatus = RPC_S_PROTOCOL_ERROR;
                }
            else {
                Message->Buffer = RpcpFarAllocate(BufferLength) ;
               
                if (Message->Buffer == 0)
                    {
                    CopyMessagePtr->RpcStatus = RPC_S_OUT_OF_MEMORY;
                    }
                else
                    {
                    CopyMessagePtr->RpcStatus = RPC_S_OK;
                    CopyMessagePtr->Request.CountDataEntries = 1;
                    CopyMessagePtr->Request.DataEntries[0].Base = PtrToMsgPtr(Message->Buffer);
                    CopyMessagePtr->Request.DataEntries[0].Size = Message->BufferLength ;
                    CopyMessagePtr->LpcHeader.u2.s2.DataInfoOffset =
                            sizeof(PORT_MESSAGE) + sizeof(LRPC_RPC_HEADER);
                    }
                }
            CopyMessagePtr->LpcHeader.CallbackId = 0;
            CopyMessagePtr->RpcHeader.Flags = LRPC_SYNC_CLIENT ;
            CopyMessagePtr->LpcHeader.u1.s1.DataLength =
                        sizeof(LRPC_COPY_MESSAGE) - sizeof(PORT_MESSAGE);
            CopyMessagePtr->LpcHeader.u1.s1.TotalLength =
                        sizeof(LRPC_COPY_MESSAGE);
            CopyMessagePtr->RpcHeader.MessageType = LRPC_MSG_COPY;
            CopyMessagePtr->RpcHeader.Pad = 0;
            // zero out unused fields
            RPCP_ZERO_OUT_STRUCT_TAIL (LRPC_RPC_HEADER, &CopyMessagePtr->RpcHeader, ProcedureNumber);

            CopyMessagePtr->RpcHeader.PresentContext = 0;
            CopyMessagePtr->IsPartial = 0 ;

            // Make sure we can't be impersonated on the transport level if
            // static identity tracking is being used.
            ASSERT(CurrentBindingHandle != NULL);
            if (CurrentBindingHandle->GetIdentityTracking() == RPC_C_QOS_IDENTITY_STATIC)
                {
                CopyMessagePtr->LpcHeader.u2.s2.Type |= LPC_NO_IMPERSONATE;
                }

            if (Association->LpcClientPort)
                {
                NtStatus = NtRequestWaitReplyPort(Association->LpcClientPort,
                                                 (PORT_MESSAGE *) CopyMessagePtr,
                                                 (PORT_MESSAGE *) CopyMessagePtr);
                }
            else
                {
                NtStatus = STATUS_INVALID_PORT_HANDLE;
                }

            if ((NT_ERROR(NtStatus))
                || (CopyMessagePtr->RpcStatus != RPC_S_OK))
                {
                RpcpFarFree(Message->Buffer);
                return(RPC_S_OUT_OF_MEMORY);
                }
            }
        else
            {
            fPartialResponse = FALSE;

            if (LrpcResponse->Rpc.RpcHeader.Flags & LRPC_BUFFER_PARTIAL)
                {
                fPartialResponse = TRUE;

                CallMutex.Request() ;
                if ((RcvBufferLength >= LRPC_THRESHOLD_SIZE))
                    {
                    Choked = 1;
                    }
                CallMutex.Clear() ;
                }
            else
                {
                Message->RpcFlags |= RPC_BUFFER_COMPLETE ;
                }

            Message->BufferLength = (unsigned int)
                                LrpcResponse->Rpc.Request.DataEntries[0].Size ;

            Message->Buffer = RpcpFarAllocate(
                    Message->BufferLength);

            if (Message->Buffer != NULL)
                {
                NtStatus = NtReadRequestData(LpcPort,
                                            (PORT_MESSAGE*) LrpcResponse,
                                            0,
                                            Message->Buffer,
                                            Message->BufferLength,
                                            &NumberOfBytesRead) ;

                if (NT_ERROR(NtStatus))
                    {
#if DBG
                    PrintToDebugger("LRPC:  NtReadRequestData failed: %x\n", NtStatus) ;
#endif
                    Status = RPC_S_OUT_OF_MEMORY;
                    }
                else
                    {
                    ASSERT(Message->BufferLength == NumberOfBytesRead);
                    }
                }
            else
                {
                Status = RPC_S_OUT_OF_MEMORY;
                }

            if (ARGUMENT_PRESENT(AckData) && fPartialResponse && (Status == RPC_S_OK))
                {
                // if pipe and delayed ack was asked for, and
                // moreover the operation didn't fail
                // just store the relevant data in the caller
                // supplied data structure
                AckData->DelayedAckPipeNeeded = TRUE;
                AckData->CurrentStatus = Status;
                }
            else
                {
                Status2 = SendPipeAck(LpcPort, 
                    LrpcResponse,
                    Status);

                FreeMessage(LrpcResponse) ;

                // if either operation failed, fail the whole function
                // if both operations failed, the first one is considered
                // the original failure and the error code from it is
                // preserved
                if ((Status == RPC_S_OK) && (Status2 != RPC_S_OK))
                    Status = Status2;
                }

            if ((Status != RPC_S_OK) && (Message->Buffer))
                {
                RpcpFarFree(Message->Buffer);
                }
            }
        }
    else
        {
        CORRUPTION_ASSERT((LrpcResponse->Rpc.RpcHeader.Flags & LRPC_BUFFER_IMMEDIATE)
               || (LrpcResponse->Rpc.RpcHeader.Flags & LRPC_BUFFER_SERVER));
        return (RPC_S_PROTOCOL_ERROR);
        }

    return(Status);
}

RPC_STATUS
LRPC_CCALL::SendPipeAck (
    IN HANDLE LpcPort,
    IN LRPC_MESSAGE *LrpcResponse,
    IN RPC_STATUS CurrentStatus
    )
/*++

Routine Description:

    Sends an acknowledgement to the server.

Arguments:

    LpcPort - the port to send the ack to.

    LrpcResponse - the response that we received from the server

    CurrentStatus - the status up to the moment. It will
        be sent to the server.

Return Value:

    The result of the operation. RPC_S_OK for success
        or RPC_S_* for error.

--*/
{
    unsigned char MessageType;
    RPC_STATUS RpcStatus = RPC_S_OK;
    NTSTATUS NtStatus;

    MessageType = LrpcResponse->Rpc.RpcHeader.MessageType ;

    LrpcResponse->Ack.MessageType = LRPC_MSG_ACK ;
    LrpcResponse->Ack.Shutup = (short) Choked ;
    LrpcResponse->Ack.RpcStatus = CurrentStatus;
    LrpcResponse->LpcHeader.u1.s1.DataLength = sizeof(LRPC_ACK_MESSAGE)
               - sizeof(PORT_MESSAGE) ;
    LrpcResponse->LpcHeader.u1.s1.TotalLength =
               sizeof(LRPC_ACK_MESSAGE) ;

    // setup the reply message
    NtStatus = NtReplyPort(LpcPort,
                          (PORT_MESSAGE *) LrpcResponse) ;

    LrpcResponse->Rpc.RpcHeader.MessageType = MessageType ;

    if (NT_ERROR(NtStatus))
        {
#if DBG
        PrintToDebugger("LRPC:  NtReplyPort failed: %x\n", NtStatus) ;
#endif
        RpcStatus = RPC_S_OUT_OF_MEMORY;
        }

    return RpcStatus;
}

BOOL
LRPC_CCALL::TryWaitForCallToBecomeUnlocked (
    BOOL *fUnlocked    
    )
/*++

Routine Description:

    Checks if a call is unlocked. If the lock count
    becomes 0, or if the lock count becomes 1 and this thread
    is the last one with a lock, the call is considered unlocked.
    In this case *fUnlocked is set to TRUE.  Otherwise it is set to FALSE.

Return Value:

    If fUnlocked == TRUE:

        TRUE - the call has 1 outstanding lock count and the 
            LastProcessResponseTID is our TID. This means that we're
            called from ProcessResponse (indirectly - through COM as
            they complete the call on the thread that issues the
            notification). If we return TRUE, we have already taken
            the lock down and the caller should not remove any locks
        FALSE - the call has no outstanding locks

    If fUnlocked == FALSE

        Undefined

--*/
{
    ULONG CurrentThreadId = GetCurrentThreadId();

    if (ResponseLockCount.GetInteger() == 0)
        {
        *fUnlocked = TRUE;
        return FALSE;
        }
    else if ((ResponseLockCount.GetInteger() == 1)
        && (LastProcessResponseTID == CurrentThreadId))
        {
        // If our caller has an outstanding lock and we free the call
        // with the lock held, zero out the count on their behalf. 
        // In our caller we will notify the ultimate caller so that it 
        // doesn't double take away the lock. 
        ResponseLockCount.SetInteger(0);

        // the only outstanding lock is by us in our caller - process
        // response. Indicate to the caller that only our lock is
        // active and it has been taken down.
        *fUnlocked = TRUE;
        return TRUE;
        }

    *fUnlocked = FALSE;
    // The return value is meaningless.  Arbitrarily, return FALSE.
    return FALSE;
}


void
LRPC_CCALL::FreeCCall (
    )
/*++

Routine Description:

    We are done with this client call.  We need to notify the binding
    handle we are done.

--*/
{
    LRPC_BINDING_HANDLE * BindingHandle;
    THREAD *Thread;

    ASSERT(CurrentBindingHandle != 0);

    BindingHandle = CurrentBindingHandle;
    CurrentBindingHandle = 0;
    if (CurrentSecurityContext)
        {
        CurrentSecurityContext->RemoveReference();
        CurrentSecurityContext = 0;
        }

    // if async, and there is EEInfo,
    // transfer the EEInfo from the call to
    // the thread
    if (EEInfo)
        {
        Thread = RpcpGetThreadPointer();
        RpcpPurgeEEInfoFromThreadIfNecessary(Thread);
        Thread->SetEEInfo(EEInfo);
        EEInfo = NULL;
        }
    BindingHandle->FreeCCall(this);
}


void
LRPC_CCALL::ActuallyFreeBuffer (
    IN void * Buffer
    )
/*++

Routine Description:

    Actually free a message buffer.

Arguments:

    Buffer - Supplies the message buffer to be freed.

--*/
{
    if (LpcReplyMessage && (Buffer == LpcReplyMessage->Rpc.Buffer))
        {
        FreeMessage(LpcReplyMessage) ;
        LpcReplyMessage = 0;
        }
    else
        {
        if ((Buffer !=  LrpcMessage->Rpc.Buffer)
            && ((CachedLrpcMessage == 0)
                || (Buffer != CachedLrpcMessage->Rpc.Buffer)))
            {
            RpcpFarFree(Buffer);
            }
        }
}


RPC_STATUS
LRPC_CCALL::MakeServerCopyResponse (
    )
/*++

Routine Description:

    NtReadRequestData only works if the client has made a request.  The client
    wants to send a large buffer back as a response.  We need to make a request
    to the server so that it will copy the data.

Return Value:

    RPC_S_OK - The server successfully copied the data.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete the
        operation.

--*/
{
#if defined(BUILD_WOW6432)
    char PushMessageBuffer[sizeof(LRPC_PUSH_MESSAGE) + 8];
    LRPC_PUSH_MESSAGE *PushMessagePtr = (LRPC_PUSH_MESSAGE *) AlignPtr8(PushMessageBuffer);
#else
    LRPC_PUSH_MESSAGE PushMessageBuffer;
    LRPC_PUSH_MESSAGE *PushMessagePtr = &PushMessageBuffer;
#endif
    NTSTATUS NtStatus;

    SanitizeLpcHeader (&PushMessagePtr->LpcHeader);
    PushMessagePtr->LpcHeader.u1.s1.TotalLength =
             sizeof(LRPC_PUSH_MESSAGE);
    PushMessagePtr->LpcHeader.u1.s1.DataLength =
             sizeof(LRPC_PUSH_MESSAGE) - sizeof(PORT_MESSAGE);
    PushMessagePtr->LpcHeader.ClientId = ClientIdToMsgClientId(ClientId);
    PushMessagePtr->LpcHeader.MessageId = MessageId;
    PushMessagePtr->LpcHeader.CallbackId = CallbackId ;
    PushMessagePtr->LpcHeader.u2.s2.Type = LPC_REQUEST;
    PushMessagePtr->RpcHeader.MessageType = LRPC_MSG_PUSH;
    // initialize unused fields. Zero out from the pad in RpcHeader to
    // the end of the containing LRPC_PUSH_MESSAGE
    RPCP_ZERO_OUT_STRUCT_TAIL (LRPC_PUSH_MESSAGE, PushMessagePtr, RpcHeader.Pad);

    PushMessagePtr->Response.CountDataEntries = 1;
    PushMessagePtr->Response.DataEntries[0] =
            LrpcMessage->Rpc.Request.DataEntries[0];

    PushMessagePtr->LpcHeader.u2.s2.DataInfoOffset = sizeof(PORT_MESSAGE)
            + sizeof(LRPC_RPC_HEADER);

    // Make sure we can't be impersonated on the transport level.
    // A legitimate Lrpc server will never do this.
    PushMessagePtr->LpcHeader.u2.s2.Type |= LPC_NO_IMPERSONATE;

    if (Association->LpcClientPort)
        {
        NtStatus = NtRequestWaitReplyPort(Association->LpcClientPort,
                                         (PORT_MESSAGE *) PushMessagePtr,
                                         (PORT_MESSAGE *) PushMessagePtr);
        }
    else
        {
        NtStatus = STATUS_INVALID_PORT_HANDLE;
        }

    if (NT_ERROR(NtStatus))
        {
        // Assume that when the client tries to send the response it will
        // fail as well, so just claim that everything worked.

#if DBG
        if ((NtStatus != STATUS_NO_MEMORY)
            && (NtStatus != STATUS_INSUFFICIENT_RESOURCES))
            {
            PrintToDebugger("RPC : NtRequestWaitReplyPort : %lx\n", NtStatus);
            ASSERT(0);
            }
#endif // DBG

        return(RPC_S_OK);
        }

    VALIDATE(PushMessagePtr->RpcStatus)
        {
        RPC_S_OK,
        RPC_S_OUT_OF_MEMORY
        } END_VALIDATE;

    return(PushMessagePtr->RpcStatus);
}


BINDING_HANDLE *
LrpcCreateBindingHandle (
    )
/*++

Routine Description:

    We just need to create a new LRPC_BINDING_HANDLE.  This routine is a
    proxy for the new constructor to isolate the other modules.

--*/
{
    LRPC_BINDING_HANDLE * BindingHandle;
    RPC_STATUS Status = RPC_S_OK;

    Status = InitializeLrpcIfNecessary() ;
    if (Status != RPC_S_OK)
        {
        return 0 ;
        }

    BindingHandle = new LRPC_BINDING_HANDLE(&Status);
    if (Status != RPC_S_OK)
        {
        delete BindingHandle;
        return(0);
        }

    return(BindingHandle);
}

void
LRPC_CASSOCIATION::LrpcDeleteLingeringAssociations (
    void
    )
/*++

Routine Description:

    Will attempt to clean up lingering LRPC associations.

Return Value:

--*/
{
    BOOL fMutexTaken;
    LRPC_CASSOCIATION *CurrentAssociation;
    LRPC_CASSOCIATION *NextAssociation;
    LRPC_CASSOCIATION *FirstAssociation;
    DictionaryCursor cursor;
    DWORD CurrentTickCount;
    int Diff;

    // if there are no lrpc associations, return
    if (!GlobalLrpcServer)
        return;

    fMutexTaken = LrpcMutexTryRequest();
    if (!fMutexTaken)
        {
        // we couldn't cleanup anything - restore the flag
        if (!GarbageCollectionRequested)
            GarbageCollectionRequested = TRUE;
        return;
        }

    FirstAssociation = NULL;
    CurrentTickCount = GetTickCount();

    // need to walk the dictionary and clean up all associations with
    // expired timeouts
    LrpcAssociationDict->Reset(cursor);
    while ((CurrentAssociation = LrpcAssociationDict->Next(cursor)) != 0)
        {
        if (CurrentAssociation->Linger.fAssociationLingered)
            {
            // this will work even for wrapped tick count
            Diff = (int)(CurrentTickCount - CurrentAssociation->Linger.Timestamp);
            if (Diff > 0)
                {
#if defined (RPC_GC_AUDIT)
                DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) LRPC association gc'ed %d ms after expire\n",
                    GetCurrentProcessId(), GetCurrentProcessId(), Diff);
#endif
                // enlink the expired associations to a list - we'll clean it up
                // later
                CurrentAssociation->NextAssociation = FirstAssociation;
                FirstAssociation = CurrentAssociation;
                LrpcAssociationDict->Delete(CurrentAssociation->AssociationDictKey);
                // indicate to the other threads (needed once we release the mutex)
                // that this association is being cleaned up and they cannot call
                // Delete on it
                CurrentAssociation->AssociationDictKey = -1;
                LrpcLingeredAssociations --;
                }
            else
                {
                // this item hasn't expired yet - update the first gc time, and
                // raise the GarbageCollectionRequested flag if necessary
                if ((int)(CurrentAssociation->Linger.Timestamp - NextOneTimeCleanup) < 0)
                    {
                    // there is a race between this thread and threads calling
                    // GarbageCollectionNeeded. Those threads may overwrite the
                    // value we're about to write, which can result in delayed
                    // garbage collection for this value - that's ok.
                    NextOneTimeCleanup = CurrentAssociation->Linger.Timestamp;
                    }

                if (!GarbageCollectionRequested)
                    GarbageCollectionRequested = TRUE;
                }
            }
        }

    LrpcMutexClear();

    // destroy the associations at our leasure
    CurrentAssociation = FirstAssociation;
    while (CurrentAssociation != NULL)
        {
        NextAssociation = CurrentAssociation->NextAssociation;
        CurrentAssociation->Delete();
        CurrentAssociation = NextAssociation;
        }
}


int
InitializeRpcProtocolLrpc (
    )
/*++

Routine Description:

    For each process, this routine will be called once.  All initialization
    will be done here.

Return Value:

    Zero will be returned if initialization completes successfully,
    otherwise, non-zero will be returned.

--*/
{
    if (LrpcAssociationDict == 0)
        {
        LrpcAssociationDict = new LRPC_CASSOCIATION_DICT;
        if (LrpcAssociationDict == 0)
            {
            return(1);
            }
        }
    return(0);
}


RPC_STATUS
LrpcMapRpcStatus (
    IN RPC_STATUS Status
    )
/*++

Routine Description:

    Some NTSTATUS codes need to be mapped into RPC_STATUS codes before being
    returned as a fault code.  We take care of doing that mapping in this
    routine.

--*/
{
    switch (Status)
        {
        case STATUS_INTEGER_DIVIDE_BY_ZERO :
            return(RPC_S_ZERO_DIVIDE);

        case STATUS_ACCESS_VIOLATION :
        case STATUS_ILLEGAL_INSTRUCTION :
            return(RPC_S_ADDRESS_ERROR);

        case STATUS_FLOAT_DIVIDE_BY_ZERO :
            return(RPC_S_FP_DIV_ZERO);

        case STATUS_FLOAT_UNDERFLOW :
            return(RPC_S_FP_UNDERFLOW);

        case STATUS_FLOAT_OVERFLOW :
            return(RPC_S_FP_OVERFLOW);
        }

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\hndlsvr.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1990 - 1999
//
//  File:       hndlsvr.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

                      Microsoft OS/2 LAN Manager
                   Copyright(c) Microsoft Corp., 1990

-------------------------------------------------------------------- */
/* --------------------------------------------------------------------

File : hndlsvr.cxx

Description :

This file contains the implementations of the classes defined in hndlsvr.hxx.
These routines are independent of the actual RPC protocol / transport layer.
In addition, these routines are also independent of the specific operating
system in use.

History :

mikemon    ??-??-??    Beginning of recorded history.
mikemon    10-15-90    Changed the shutdown functionality to PauseExecution
                       rather than suspending and resuming a thread.
mikemon    12-28-90    Updated the comments to match reality.
connieh    17-Feb-94   Created RPC_SERVER::RegisterRpcForwardFunction
Kamen Moutafov (KamenM) Dec 99 - Feb 2000 - Support for cell debugging stuff

-------------------------------------------------------------------- */

#include <precomp.hxx>
#include <queue.hxx>
#include <Context.hxx>
#include <SContext.hxx>
#include <hndlsvr.hxx>
#include <svrbind.hxx>
#include <thrdctx.hxx>
#include <rpcobj.hxx>
#include <rpccfg.h>
#include <sdict2.hxx>
#include <dispatch.h>

#include <queue.hxx>
#include <lpcpack.hxx>
#include <lpcsvr.hxx>
extern LRPC_SERVER *GlobalLrpcServer ;

#include <ProtBind.hxx>
#include <osfpcket.hxx>
#include <bitset.hxx>
#include <osfclnt.hxx>
#include <osfsvr.hxx>
#include <dgpkt.hxx>
#include <dgsvr.hxx>
#include <sddl.h>

// 
// The flags below are used with the RPC verifier.
// They allow us to keep track of whether any remotely accessible interfaces
// use weak security.  If they do, we will print warnings.
//

// Set if an interface has been registered that is not secure.
// An interface is considered secure iff it has been registred with a
// RPC_IF_ALLOW_SECURE_ONLY flag or with a security callback.
// All other interfaces are considered unsecure.
BOOL gfUnsecureInterfaceRegistered;

// Set if a protseq has been registred that makes
// the server accessible remotely.
BOOL gfRemoteProtseqRegistered;

RPC_STATUS RPC_ENTRY
DefaultCallbackFn (
    IN RPC_IF_HANDLE InterfaceUuid,
    IN void *Context
    )
/*++
Function Name:DefaultCallbackFn

Parameters:

Description:

Returns:
    RPC_S_OK: Access is allowed
    other failures: Access is denied

--*/
{
    RPC_CALL_ATTRIBUTES CallAttributes;
    RPC_STATUS Status;

    CallAttributes.Version = RPC_CALL_ATTRIBUTES_VERSION;
    CallAttributes.Flags = 0;

    Status = RpcServerInqCallAttributesW(Context, 
        &CallAttributes);

    if (Status != RPC_S_OK)
        return Status;

    if ((CallAttributes.AuthenticationService == RPC_C_AUTHN_NONE)
        || (CallAttributes.AuthenticationLevel == RPC_C_AUTHN_LEVEL_NONE)
        || (CallAttributes.NullSession)
       )
        {
        return RPC_S_ACCESS_DENIED;
        }

    return RPC_S_OK;
}

RPC_INTERFACE::RPC_INTERFACE (
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation,
    IN RPC_SERVER * Server,
    IN unsigned int Flags,
    IN unsigned int MaxCalls,
    IN unsigned int MaxRpcSize,
    IN RPC_IF_CALLBACK_FN PAPI *IfCallbackFn,
    OUT RPC_STATUS *Status
    ) : NullManagerActiveCallCount(0), AutoListenCallCount(0), AutoListenCallNumber(0)
/*++

Routine Description:



    This method will get called to construct an instance of the
    RPC_INTERFACE class.  We have got to make a copy of the rpc interface
    information supplied.  The copy is necessary because we do not delete
    interfaces when they are unregistered.  We just mark them as being
    inactive.  In addition, we need to set the NullManagerFlag
    to zero, since this is used as the flag indicating whether we have
    got a manager for the NULL type UUID.

Arguments:

    RpcInterfaceInformation - Supplies the rpc interface information
        which describes this interface.

    Server - Supplies the rpc server which owns this rpc interface.

--*/
{
    ALLOCATE_THIS(RPC_INTERFACE);
    unsigned int Length;

    PipeInterfaceFlag = 0;
    SequenceNumber = 1;

#if DBG
    Strict = iuschDontKnow;
#endif

    if (RpcInterfaceInformation->Length > sizeof(RPC_SERVER_INTERFACE) )
        {
        Length = sizeof(RPC_SERVER_INTERFACE);
        }
    else
        {
        Length = RpcInterfaceInformation->Length;
        }

    if ((RpcInterfaceInformation->Length > NT351_INTERFACE_SIZE)
        && (RpcInterfaceInformation->Flags & RPC_INTERFACE_HAS_PIPES))
        {
        PipeInterfaceFlag = 1;
        }

    RpcpMemoryCopy(&(this->RpcInterfaceInformation), RpcInterfaceInformation, Length);

    NullManagerFlag = 0;
    ManagerCount = 0;
    this->Server = Server;
    this->Flags = Flags;
    this->MaxCalls = MaxCalls;
    // By specifying a custom RPC size the user can override the gMaxRpcSize
    // call size limit.  This is the only API that overrides the gMaxRpcSize default.
    this->MaxRpcSize = MaxRpcSize;
    fBindingsExported = 0;
    UuidVector = NULL;

    if (Flags & RPC_IF_ALLOW_SECURE_ONLY
        && IfCallbackFn == NULL)
        {
        this->CallbackFn = DefaultCallbackFn;
        }
    else
        {
        this->CallbackFn = IfCallbackFn ;
        }

    if (DoesInterfaceSupportMultipleTransferSyntaxes(RpcInterfaceInformation))
        {
        *Status = NdrServerGetSupportedSyntaxes(RpcInterfaceInformation,
            &NumberOfSupportedTransferSyntaxes,
            &TransferSyntaxesArray, &PreferredTransferSyntax);
        if (*Status != RPC_S_OK)
            return;
        }
    else
        {
        NumberOfSupportedTransferSyntaxes = 0;
        }

    *Status = RPC_S_OK;
}


RPC_STATUS
RPC_INTERFACE::RegisterTypeManager (
    IN RPC_UUID PAPI * ManagerTypeUuid OPTIONAL,
    IN RPC_MGR_EPV PAPI * ManagerEpv OPTIONAL
    )
/*++

Routine Description:

    This method is used to register a type manager with this interface.
    If no type UUID is specified, or it is the NULL type UUID, we
    stick the manager entry point vector right in this instance (assuming
    that there is not already one), otherwise, we put it into the
    dictionary of interface manager objects.

Arguments:

    ManagerTypeUuid - Optionally supplies the type UUID for the manager
        we want to register with this rpc interface.  If no type UUID
        is supplied then the NULL type UUID is assumed.

    ManagerEpv - Supplies then entry point vector for this manager.  This
        vector is used to dispatch from the stub to the application
        code.

Return Values:

    RPC_S_OK - The type manager has been successfully added to this
        rpc interface.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is availabe to add the
        type manager to the rpc interface.

    RPC_S_TYPE_ALREADY_REGISTERED - A manager entry point vector has
        already been registered for the this interface under the
        specified manager type UUID.

--*/
{
    RPC_INTERFACE_MANAGER * InterfaceManager;

    // First we need to check if the null UUID is being specified as
    // the type UUID; either, explicit or implicit by not specifying
    // a type UUID argument.

    RequestGlobalMutex();

    if (   (ARGUMENT_PRESENT(ManagerTypeUuid) == 0)
        || (   (ARGUMENT_PRESENT(ManagerTypeUuid) != 0)
            && (ManagerTypeUuid->IsNullUuid() != 0)))
        {
        if (NullManagerFlag != 0)
            {
            ClearGlobalMutex();
            return(RPC_S_TYPE_ALREADY_REGISTERED);
            }

        NullManagerEpv = ManagerEpv;
        NullManagerFlag = 1;
        ManagerCount += 1;
        ClearGlobalMutex();
        return(RPC_S_OK);
        }

    // If we reach here, a non-NULL type UUID is specified.

    InterfaceManager = FindInterfaceManager(ManagerTypeUuid);

    if (InterfaceManager == 0)
        {
        InterfaceManager = new RPC_INTERFACE_MANAGER(ManagerTypeUuid,
                ManagerEpv);

        if (InterfaceManager == 0)
            {
            ClearGlobalMutex();
            return(RPC_S_OUT_OF_MEMORY);
            }
        if (InterfaceManagerDictionary.Insert(InterfaceManager) == -1)
            {
            ClearGlobalMutex();
            delete InterfaceManager;
            return(RPC_S_OUT_OF_MEMORY);
            }
        ManagerCount += 1;
        ClearGlobalMutex();
        return(RPC_S_OK);
        }

    if (InterfaceManager->ValidManager() == 0)
        {
        InterfaceManager->SetManagerEpv(ManagerEpv);
        ManagerCount += 1;
        ClearGlobalMutex();
        return(RPC_S_OK);
        }

    ClearGlobalMutex();
    return(RPC_S_TYPE_ALREADY_REGISTERED);
}

RPC_INTERFACE_MANAGER *
RPC_INTERFACE::FindInterfaceManager (
    IN RPC_UUID PAPI * ManagerTypeUuid
    )
/*++

Routine Description:

    This method is used to obtain the interface manager corresponding to
    the specified type UUID.  The type UUID must not be the null UUID.

Arguments:

    ManagerTypeUuid - Supplies the type UUID for which we are trying to
        find the interface manager.

Return Value:

    If a interface manager for this type UUID is found, a pointer to it
    will be returned; otherwise, zero will be returned.

--*/
{
    RPC_INTERFACE_MANAGER * InterfaceManager;
    DictionaryCursor cursor;

    InterfaceManagerDictionary.Reset(cursor);
    while ((InterfaceManager = InterfaceManagerDictionary.Next(cursor)) != 0)
        {
        if (InterfaceManager->MatchTypeUuid(ManagerTypeUuid) == 0)
            return(InterfaceManager);
        }
    return(0);
}


RPC_STATUS
RPC_INTERFACE::DispatchToStub (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned int CallbackFlag,
    IN PRPC_DISPATCH_TABLE DispatchTableToUse,
    OUT RPC_STATUS PAPI * ExceptionCode
    )
/*++

Routine Description:

    This method is used to dispatch remote procedure calls to the
    appropriate stub and hence to the appropriate manager entry point.
    This routine is used for calls having a null UUID (implicit or
    explicit).  We go to great pains to insure that we do not grab
    a mutex.

Arguments:

    Message - Supplies the response message and returns the reply
        message.

    CallbackFlag - Supplies a flag indicating whether this is a callback
        or not.  The argument will be zero if this is an original call,
        and non-zero if it is a callback.

    ExceptionCode - Returns the exact exception code if an exception
        occurs.

Return Value:

    RPC_S_OK - This value will be returned if the operation completed
        successfully.

    RPC_S_PROCNUM_OUT_OF_RANGE - If the procedure number for this call is
        too large, this value will be returned.

    RPC_S_UNKNOWN_IF - If this interface does not exist, you will get this
        value back.

    RPC_S_NOT_LISTENING - The rpc server which owns this rpc interface
        is not listening for remote procedure calls right now.

    RPC_S_SERVER_TOO_BUSY - This call will cause there to be too many
        concurrent remote procedure calls for the rpc server which owns
        this interface.

    RPC_P_EXCEPTION_OCCURED - A fault occured, and we need to remote it.  The
        ExceptionCode argument will contain the exception code for the
        fault.

    RPC_S_UNSUPPORTED_TYPE - This interface exists, but does not have a manager
        for the null type.

--*/
{
    RPC_STATUS RpcStatus = RPC_S_OK;

    if ( CallbackFlag == 0 )
        {
        //
        // AutoListen and NullManager call counts.
        //
        // Async calls require 2 counts.  Sync calls require only 1 count.
        // The first count is the same in both sync and async.
        // 
        // For async calls:
        //
        // - The first count is added in: RPC_INTERFACE::DispatchToStub iff CallbackFlag == 0
        // - The second count is added in: SetAsyncHandle iff the execution of the procedure
        // has been successful and pAsync hads been initialized.
        // - The first count is removed in: RPC_INTERFACE::DispatchToStub after returning
        // from DispatchToStubWorker.  At this point the second ref count may or may not have been set
        // depending on whether an exception was raised by NDR and how SetAsyncHandle has executed.
        // - The second count will be removed only if the async handle was set.  We will check
        // this and decrement when freeing the call in FreeSCall/CleanupCall.  For lrpc, the call
        // is always cached and freed via FreeSCall.  For OSF, the call may pass through FreeSCall
        // if it is "really" being freed or through OSF_SCALL::CleanupCall if it will be cached.
        // We need to decrement the counts in all of these cases.
        //
        // The counts are independent of the number of calls since a call can hold 1 or 2 counts.
        //
        if (IsAutoListenInterface())
            {
            // Since this is the dispatch path we need to increment the CallNumber.
            BeginAutoListenCall(TRUE);
            }
        BeginNullManagerCall();

        if ( NullManagerFlag == 0 )
            {
            RpcStatus = RPC_S_UNSUPPORTED_TYPE;

            RpcpErrorAddRecord(EEInfoGCRuntime,
                RpcStatus,
                EEInfoDLDispatchToStub10);

            if ( ManagerCount == 0 )
                {
                RpcStatus = RPC_S_UNKNOWN_IF;
                RpcpErrorAddRecord(EEInfoGCRuntime,
                    RpcStatus,
                    EEInfoDLDispatchToStub20);
                }
            }
        }

    if (RpcStatus != RPC_S_OK)
        {
        // We can only fail here if NullManagerFlag != 0 above.
        ASSERT(RpcStatus == RPC_S_UNSUPPORTED_TYPE || RpcStatus == RPC_S_UNKNOWN_IF);

        ((MESSAGE_OBJECT *) Message->Handle)->FreeBuffer(Message);

        EndNullManagerCall();

        if (IsAutoListenInterface())
            {
            // Decrement the CallNumber since from the user's perspective the call has completed
            // after the exception is raised.
            EndAutoListenCall(TRUE);
            }

        return RpcStatus;
        }

    Message->ManagerEpv = NullManagerEpv;

    RpcStatus = DispatchToStubWorker(Message, CallbackFlag, DispatchTableToUse, ExceptionCode);

    // If either we failed, or this is a sync call and not a callback,
    // decrement the refcount on the interface.
    if (CallbackFlag == 0)
        {
        EndNullManagerCall(); // We always increment this count if the call gets this far.

        if (IsAutoListenInterface())
            {
            // This is the path on which sync calls complete, from the user's perspective.
            // We need to decrement the CallNumber for sync calls.
            // We determine whether the call is sync by looking at fAsync thread flag which is
            // set in SetAsyncHandle.  If the flag is set then pAsync is set also,
            // we will notice this in call cleanup and decrement the call number there.
            EndAutoListenCall(RpcpGetThreadPointer()->IsSyncCall());
            }
        }

    //
    // DispatchToStubWorker freed Message.Buffer if an error occurred.
    //
    return(RpcStatus);
}


RPC_STATUS
RPC_INTERFACE::DispatchToStubWorker (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned int CallbackFlag,
    IN PRPC_DISPATCH_TABLE DispatchTableToUse,
    OUT RPC_STATUS PAPI * ExceptionCode
    )
/*++

Routine Description:

    This method is used to dispatch remote procedure calls to the
    appropriate stub and hence to the appropriate manager entry point.
    It will be used for calls with and without objects specified.
    We go to great pains to insure that we do not grab a mutex.

Arguments:

    Message - Supplies the response message and returns the reply
        message. If this routine returns anything other than RPC_S_OK
        Message->Buffer has already been freed.

    CallbackFlag - Supplies a flag indicating whether this is a callback
        or not.  The argument will be zero if this is an original call,
        and non-zero if it is a callback.

    DispatchTableToUse - a pointer to the dispatch table to use. This is
        used to select b/n stubs for NDR20 and NDR64 transfer syntaxes

    ExceptionCode - Returns the exact exception code if an exception
        occurs.

Return Value:

    RPC_S_OK - This value will be returned if the operation completed
        successfully.

    RPC_S_PROCNUM_OUT_OF_RANGE - If the procedure number for this call is
        too large, this value will be returned.

    RPC_S_NOT_LISTENING - The rpc server which owns this rpc interface
        is not listening for remote procedure calls right now.

    RPC_S_SERVER_TOO_BUSY - This call will cause there to be too many
        concurrent remote procedure calls for the rpc server which owns
        this interface.

    RPC_P_EXCEPTION_OCCURED - A fault occured, and we need to remote it.  The
        ExceptionCode argument will contain the exception code for the
        fault.

--*/
{
    RPC_STATUS RpcStatus = RPC_S_OK;
    void * OldServerContextList;
    unsigned int procnum ;
    THREAD *Self = RpcpGetThreadPointer() ;

    ASSERT(Self);

    if (Flags & RPC_IF_OLE)
        {
        procnum = 0 ;
        }
    else
        {
        procnum = Message->ProcNum ;
        }


    if (CallbackFlag == 0)
        {
        if (IsAutoListenInterface())
            {
            if (AutoListenCallNumber.GetInteger() > (long) MaxCalls)
                {
                RpcStatus = RPC_S_SERVER_TOO_BUSY ;
                RpcpErrorAddRecord(EEInfoGCRuntime,
                    RpcStatus,
                    EEInfoDLDispatchToStubWorker10,
                    (ULONG)AutoListenCallNumber.GetInteger(),
                    (ULONG)MaxCalls);
                }
            }
        else
            {
            if (Server->IsServerListening() == 0)
                {
                RpcStatus = RPC_S_NOT_LISTENING;
                RpcpErrorAddRecord(EEInfoGCRuntime,
                    RpcStatus,
                    EEInfoDLDispatchToStubWorker20);
                }
            else if (Server->fAccountForMaxCalls && Server->CallBeginning() == 0)
                {
                RpcStatus = RPC_S_SERVER_TOO_BUSY;
                RpcpErrorAddRecord(EEInfoGCRuntime,
                    RpcStatus,
                    EEInfoDLDispatchToStubWorker30);
                }
            }
        }

    if (procnum >=
            DispatchTableToUse->DispatchTableCount)
        {
        if (RpcStatus != RPC_S_SERVER_TOO_BUSY)
            {
            EndCall(CallbackFlag) ;
            }
        RpcStatus = RPC_S_PROCNUM_OUT_OF_RANGE;
        RpcpErrorAddRecord(EEInfoGCRuntime,
            RpcStatus,
            EEInfoDLDispatchToStubWorker40);
        }

    if (RpcStatus != RPC_S_OK)
        {
        MO(Message)->FreeBuffer(Message);
        return RpcStatus;
        }

    Server->IncomingCall();

    ((PRPC_RUNTIME_INFO) Message->ReservedForRuntime)->OldBuffer =
            Message->Buffer ;

    Message->RpcInterfaceInformation = &RpcInterfaceInformation;
    SCALL(Message)->DoPreDispatchProcessing(Message, CallbackFlag);

    if ( DispatchToStubInC(DispatchTableToUse->DispatchTable[procnum], Message, ExceptionCode) != 0 )
        {
        LogEvent(SU_EXCEPT, EV_STATUS, LongToPtr(*ExceptionCode),
            DispatchTableToUse->DispatchTable[procnum], (ULONG_PTR)Message, 1, 1);
        RpcStatus = RPC_P_EXCEPTION_OCCURED;
        RpcpErrorAddRecord(EEInfoGCApplication,
            *ExceptionCode,
            EEInfoDLRaiseExc,
            GetInterfaceFirstDWORD(),
            (short)procnum,
            Message->RpcFlags,
            GetCurrentThreadId());
        }

    RPC_MESSAGE OriginalMessage ;
    OriginalMessage.ReservedForRuntime = 0;
    OriginalMessage.Buffer =
        ((PRPC_RUNTIME_INFO) Message->ReservedForRuntime)->OldBuffer;
    Self->ResetYield();

    if (Self->IsSyncCall())
        {
        //
        // Since this is a sync call, we know that it has
        // not been freed yet. So we can safely touch it.
        //
        SCALL(Message)->DoPostDispatchProcessing();

        //
        // The dispatched call was a sync call
        //
        if (RPC_S_OK == RpcStatus)
            {

            //
            // If the stub didn't allocate an output buffer, do so now.
            //
            if (OriginalMessage.Buffer == Message->Buffer)
                {
                Message->RpcFlags = 0;
                Message->BufferLength = 0;
                MO(Message)->GetBuffer(Message, 0);
                }

            //
            // Free the [in] buffer that we saved.
            //
            MO(Message)->FreeBuffer(&OriginalMessage);

            EndCall(CallbackFlag) ;
            }
        else
            {
            ASSERT(RpcStatus == RPC_P_EXCEPTION_OCCURED) ;
            //
            // Free the buffer in the caller's message; this can be either
            // the [in] buffer or the [out] buffer, depending upon which
            // line of the stub caused the error.
            //
            // If the exception occurred after allocating the [out] buffer,
            // also free the [in] buffer.
            //
            if (OriginalMessage.Buffer != Message->Buffer)
                {
                MO(Message)->FreeBuffer(&OriginalMessage);
                }

            if (Message->Buffer)
                {
                MO(Message)->FreeBuffer(Message);
                }

            EndCall(CallbackFlag) ;
            }
        }
    else
        {
        //
        // The dispatched call was an async call
        //
        if (RpcStatus != RPC_S_OK
            && OriginalMessage.Buffer != Message->Buffer)
            {
            //
            // The dispatch buffer will be freed during cleanup
            // of the async call
            //
            MO(Message)->FreeBuffer(Message);
            }
        }



    return(RpcStatus);
}


void
RPC_INTERFACE::EndCall(
    IN unsigned int CallbackFlag,
    BOOL fAsync
    )
{
    if (fAsync)
        {
        EndNullManagerCall();
        }

    if (CallbackFlag == 0)
        {
        if (!(Flags & RPC_IF_AUTOLISTEN) && Server->fAccountForMaxCalls)
            {
            Server->CallEnding();
            }
        }
}


RPC_STATUS
RPC_INTERFACE::DispatchToStubWithObject (
    IN OUT PRPC_MESSAGE Message,
    IN RPC_UUID * ObjectUuid,
    IN unsigned int CallbackFlag,
    IN PRPC_DISPATCH_TABLE DispatchTableToUse,
    OUT RPC_STATUS PAPI * ExceptionCode
    )
/*++

Routine Description:

    This method is used to dispatch remote procedure calls to the
    appropriate stub and hence to the appropriate manager entry point.
    This routine is used for calls which have an associated object.

Arguments:

    Message - Supplies the response message and returns the reply
        message.

    ObjectUuid - Supplies the object uuid to map into the manager entry
        point for this call.

    CallbackFlag - Supplies a flag indicating whether this is a callback
        or not.  The argument will be zero if this is an original call,
        and non-zero if it is a callback.

    ExceptionCode - Returns the exact exception code if an exception
        occurs.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_PROCNUM_OUT_OF_RANGE - If the procedure number for this call is
        too large, this value will be returned.

    RPC_S_UNKNOWN_IF - If the specified manager is no longer
        valid, you will get this value back.

    RPC_S_NOT_LISTENING - The rpc server which owns this rpc interface
        is not listening for remote procedure calls right now.

    RPC_S_SERVER_TOO_BUSY - This call will cause there to be too many
        concurrent remote procedure calls for the rpc server which owns
        this interface.

    RPC_P_EXCEPTION_OCCURED - A fault occured, and we need to remote it.  The
        ExceptionCode argument will contain the exception code for the
        fault.

    RPC_S_UNSUPPORTED_TYPE - There is no type manager for the object's type
        for this interface.

--*/
{
    RPC_UUID TypeUuid;
    RPC_STATUS RpcStatus;
    RPC_INTERFACE_MANAGER * RpcInterfaceManager;

    RpcStatus = ObjectInqType(ObjectUuid, &TypeUuid);
    VALIDATE(RpcStatus)
        {
        RPC_S_OK,
        RPC_S_OBJECT_NOT_FOUND
        } END_VALIDATE;

    if ( RpcStatus == RPC_S_OK )
        {
        RpcInterfaceManager = FindInterfaceManager(&TypeUuid);

        if (   ( RpcInterfaceManager != 0 )
            && (   ( CallbackFlag != 0 )
                || ( RpcInterfaceManager->ValidManager() != 0 ) ) )
            {
            Message->ManagerEpv = RpcInterfaceManager->QueryManagerEpv();

            if ( CallbackFlag == 0 )
                {
                RpcInterfaceManager->CallBeginning();
                }

            RpcStatus = DispatchToStubWorker(Message, CallbackFlag, DispatchTableToUse,
                    ExceptionCode);

            if ( CallbackFlag == 0 )
                {
                RpcInterfaceManager->CallEnding();
                }

            return(RpcStatus);
            }

        if (this != GlobalManagementInterface)
            {
            // There is a type for this object, but no type manager for
            // this interface.

            RpcStatus = RPC_S_UNSUPPORTED_TYPE;

            if ( ManagerCount == 0 )
                {
                RpcStatus = RPC_S_UNKNOWN_IF;
                }

            ((MESSAGE_OBJECT *) Message->Handle)->FreeBuffer(Message);
            return RpcStatus;
            }
        }

    // There has not been a type registered for this object, so we will
    // just go ahead and try and use the NULL type manager.

    return(DispatchToStub(Message, CallbackFlag, DispatchTableToUse, ExceptionCode));
}


BOOL
RPC_INTERFACE::IsObjectSupported (
    IN RPC_UUID * ObjectUuid
    )
/*++

Routine Description:

    Determines whether the manager for the given object UUID is registered.

Arguments:

    ObjectUuid - the client's object UUID

Return Value:

    RPC_S_OK                if it is OK to dispatch
    RPC_S_UNKNOWN_IF        if the interface is not registered
    RPC_S_UNSUPPORTED_TYPE  if this particular object's type is not registered

--*/

{
    RPC_STATUS Status = RPC_S_OK;

    if (ObjectUuid->IsNullUuid() )
        {
        if ( NullManagerFlag == 0 )
            {
            Status = RPC_S_UNSUPPORTED_TYPE;

            if ( ManagerCount == 0 )
                {
                Status = RPC_S_UNKNOWN_IF;
                }
            }
        }
    else
        {
        RPC_UUID TypeUuid;
        Status = ObjectInqType(ObjectUuid, &TypeUuid);
        if ( Status == RPC_S_OK )
            {
            RPC_INTERFACE_MANAGER * RpcInterfaceManager = 0;

            RpcInterfaceManager = FindInterfaceManager(&TypeUuid);
            if (!RpcInterfaceManager ||
                !RpcInterfaceManager->ValidManager())
                {
                Status = RPC_S_UNSUPPORTED_TYPE;

                if ( ManagerCount == 0 )
                    {
                    Status = RPC_S_UNKNOWN_IF;
                    }
                }
            }
        else
            {
            Status = RPC_S_OK;
            if ( NullManagerFlag == 0 )
                {
                Status = RPC_S_UNSUPPORTED_TYPE;

                if ( ManagerCount == 0 )
                    {
                    Status = RPC_S_UNKNOWN_IF;
                    }
                }
            }

        }

    return Status;
}


RPC_STATUS
RPC_INTERFACE::UpdateBindings (
    IN RPC_BINDING_VECTOR *BindingVector
    )
/*++
Function Name:UpdateEpMapperBindings

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    unsigned int Length;
#if !defined(NO_LOCATOR_CODE)
    NS_ENTRY *NsEntry;
#endif
    DictionaryCursor cursor;

    if (fBindingsExported)
        {
        Status = RegisterEntries(&RpcInterfaceInformation,
                    BindingVector,
                    UuidVector,
                    (unsigned char *) Annotation,
                    fReplace);
        if (Status != RPC_S_OK)
            {
            return Status;
            }
        }

#if !defined(NO_LOCATOR_CODE)
    // shortcut the common path and avoid taking and holding
    // unnecessarily the high contention global mutex
    if (NsEntries.Size() == 0)
        return RPC_S_OK;

    RequestGlobalMutex();
    NsEntries.Reset(cursor);
    while ((NsEntry = NsEntries.Next(cursor)) != 0)
        {
        //
        // Actually update the locator bindings
        //
        Status = GlobalRpcServer->NsBindingUnexport(
                                          NsEntry->EntryNameSyntax,
                                          NsEntry->EntryName,
                                          &RpcInterfaceInformation);
        if (Status == RPC_S_OK)
            {
            Status = GlobalRpcServer->NsBindingExport(
                                            NsEntry->EntryNameSyntax,
                                            NsEntry->EntryName,
                                            &RpcInterfaceInformation,
                                            BindingVector);
#if DBG
            if (Status != RPC_S_OK)
                {
                PrintToDebugger("RPC: Bindings were unexported, but could not re-export\n");
                }
#endif
            }
        }
    ClearGlobalMutex();
#endif

    return RPC_S_OK;
}


RPC_STATUS
RPC_INTERFACE::InterfaceExported (
    IN UUID_VECTOR *MyObjectUuidVector,
    IN unsigned char *MyAnnotation,
    IN BOOL MyfReplace
    )
/*++
Function Name:InterfaceExported

Parameters:

Description:
    RpcEpRegister was called on this interface. We need to keep track
    of the parameters, so that if we get a PNP notification, we can update
    the bindings using there params

Returns:
    RPC_S_OK: things went fine
    RPC_S_OUT_OF_MEMORY: ran out of memory
--*/
{
    RequestGlobalMutex();

    if (UuidVector
        && UuidVector != MyObjectUuidVector)
        {
        RpcpFarFree(UuidVector);
        UuidVector = 0;
        }

    if (MyObjectUuidVector)
        {
        if (UuidVector != MyObjectUuidVector)
            {
            int Size = MyObjectUuidVector->Count*(sizeof(UUID)+sizeof(UUID *))
                            +sizeof(unsigned long);
            UUID *Uuids;
            unsigned i;

            UuidVector = (UUID_VECTOR *) RpcpFarAllocate(Size);
            if (UuidVector == 0)
                {
                ClearGlobalMutex();
                return RPC_S_OUT_OF_MEMORY;
                }

            Uuids = (UUID *) ((char *) UuidVector + sizeof(unsigned long)
                        +(sizeof(UUID *) * MyObjectUuidVector->Count));

            UuidVector->Count = MyObjectUuidVector->Count;

            for (i = 0; i < UuidVector->Count; i++)
                {
                Uuids[i] = *(MyObjectUuidVector->Uuid[i]);
                UuidVector->Uuid[i] = &Uuids[i];
                }
            }
        }
    else
        {
        UuidVector = 0;
        }

    if (MyAnnotation)
        {
        strncpy((char *) Annotation, (char *) MyAnnotation, 63);
        Annotation[63]=0;
        }
    else
        {
        Annotation[0] = 0;
        }

    fReplace = MyfReplace;
    fBindingsExported = 1;

    ClearGlobalMutex();

    return RPC_S_OK;
}


#if !defined(NO_LOCATOR_CODE)
NS_ENTRY *
RPC_INTERFACE::FindEntry (
    IN unsigned long EntryNameSyntax,
    IN RPC_CHAR *EntryName
    )
{
    NS_ENTRY *NsEntry;
    DictionaryCursor cursor;

    //
    // This function will always be called with the mutex held
    //
    NsEntries.Reset(cursor);
    while ((NsEntry = NsEntries.Next(cursor)) != 0)
        {
        if (NsEntry->Match(EntryNameSyntax, EntryName))
            {
            return NsEntry;
            }
        }

    return 0;
}


RPC_STATUS
RPC_INTERFACE::NsInterfaceUnexported (
    IN unsigned long EntryNameSyntax,
    IN RPC_CHAR *EntryName
    )
{
    NS_ENTRY *NsEntry;

    RequestGlobalMutex();
    NsEntry = FindEntry(EntryNameSyntax, EntryName);
    if (NsEntry == 0)
        {
        ClearGlobalMutex();

#if DBG
        PrintToDebugger("RPC: No corresponding exported entry\n");
#endif
        return RPC_S_ENTRY_NOT_FOUND;
        }

    NsEntries.Delete(NsEntry->Key);
    ClearGlobalMutex();

    return RPC_S_OK;
}


RPC_STATUS
RPC_INTERFACE::NsInterfaceExported (
    IN unsigned long EntryNameSyntax,
    IN RPC_CHAR *EntryName
    )
{
    RPC_STATUS Status = RPC_S_OK;
    NS_ENTRY *NsEntry;
    int retval;

    RequestGlobalMutex();
    NsEntry = FindEntry(EntryNameSyntax, EntryName);
    ClearGlobalMutex();

    if (NsEntry)
        {
        return RPC_S_OK;
        }

    NsEntry = new NS_ENTRY(
                           EntryNameSyntax,
                           EntryName,
                           &Status);
    if (NsEntry == 0)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    if (Status != RPC_S_OK)
        {
        delete NsEntry;
        return Status;
        }

    RequestGlobalMutex();
    NsEntry->Key = NsEntries.Insert(NsEntry);
    ClearGlobalMutex();

    if (NsEntry->Key == -1)
        {
        delete NsEntry;
        return RPC_S_OUT_OF_MEMORY;
        }

    return RPC_S_OK;
}
#endif

static unsigned int
MatchSyntaxIdentifiers (
    IN PRPC_SYNTAX_IDENTIFIER ServerSyntax,
    IN PRPC_SYNTAX_IDENTIFIER ClientSyntax
    )
/*++

Routine Description:

    This method compares two syntax identifiers (which consist of a
    uuid, a major version number, and a minor version number).  In
    order for the syntax identifiers to match, the uuids must be the
    same, the major version numbers must be the same, and the client
    minor version number must be less than or equal to the server
    minor version number.

Arguments:

    ServerSyntax - Supplies the server syntax identifier.

    ClientSyntax - Supplies the client syntax identifer.

Return Value:

    Zero will be returned if the client syntax identifier matches the
    server syntax identifier; otherwise, non-zero will be returned.

--*/
{
    if (RpcpMemoryCompare(&(ServerSyntax->SyntaxGUID),
            &(ClientSyntax->SyntaxGUID), sizeof(UUID)) != 0)
        return(1);
    if (ServerSyntax->SyntaxVersion.MajorVersion
            != ClientSyntax->SyntaxVersion.MajorVersion)
        return(1);
    if (ServerSyntax->SyntaxVersion.MinorVersion
            < ClientSyntax->SyntaxVersion.MinorVersion)
        return(1);

    return(0);
}


unsigned int
RPC_INTERFACE::MatchInterfaceIdentifier (
    IN PRPC_SYNTAX_IDENTIFIER InterfaceIdentifier
    )
/*++

Routine Description:

    This method compares the supplied interface identifier (which consists
    of the interface uuid and interface version) against that contained
    in this rpc interface.  In order for this rpc interface to match,
    the interface uuids must be the same, the interface major versions
    must be the same, and the supplied interface minor version must be
    less than or equal to the interface minor version contained in this
    rpc interface.

Arguments:

    InterfaceIdentifier - Supplies the interface identifier to compare
        against that contained in this rpc interface.

Return Value:

    Zero will be returned if the supplied interface identifer matches
    (according to the rules described above) the interface identifier
    contained in this rpc interface; otherwise, non-zero will be returned.

--*/
{
    if (ManagerCount == 0)
        return(1);

    return(MatchSyntaxIdentifiers(&(RpcInterfaceInformation.InterfaceId),
            InterfaceIdentifier));
}


unsigned int
RPC_INTERFACE::SelectTransferSyntax (
    IN PRPC_SYNTAX_IDENTIFIER ProposedTransferSyntaxes,
    IN unsigned int NumberOfTransferSyntaxes,
    OUT PRPC_SYNTAX_IDENTIFIER AcceptedTransferSyntax,
    OUT BOOL *fIsInterfaceTransferPreferred,
    OUT int *ProposedTransferSyntaxIndex,
    OUT int *AvailableTransferSyntaxIndex
    )
/*++

Routine Description:

    This method is used to select a transfer syntax from a list of one
    or more transfer syntaxes.  If a transfer syntax is selected, then
    it will be returned in one of the arguments.

Arguments:

    ProposedTransferSyntaxes - Supplies a list of one or more transfer
        syntaxes from which this interface should select one which it
        supports if possible.

    NumberOfTransferSyntaxes - Supplies the number of transfer syntaxes
        in the proposed transfer syntaxes argument.

    AcceptedTransferSyntax - Returns the selected transfer syntax, if
        one is selected.

    fIsInterfaceTransferPreferred - true if the selected transfer syntax
        is preferred by the server

    ProposedTransferSyntaxIndex - the index of the transfer syntax that is
        chosen from the proposed transfer syntaxes array. Zero based.

    AvailableTransferSyntaxIndex - the index of the transfer syntax that is
        chosen from the available transfer syntaxes in the interface. This
        value must be stored in the binding and retrieved when asking for the
        transfer syntax and dispatch table. Zero based.

Return Value:

    Zero will be returned if a transfer syntax is selected; otherwise,
    non-zero will be returned.

--*/
{
    unsigned int ProposedIndex;
    unsigned int AvailableIndex;
    unsigned int NumberOfAvailableSyntaxes;
    BOOL fMultipleTranfserSyntaxesSelected;
    RPC_SYNTAX_IDENTIFIER *CurrentTransferSyntax;
    RPC_SYNTAX_IDENTIFIER *BackupTransferSyntax = NULL;
    int BackupProposedTransferSyntaxIndex;
    int BackupAvailableTransferSyntaxIndex;

    fMultipleTranfserSyntaxesSelected = AreMultipleTransferSyntaxesSupported();
    if (fMultipleTranfserSyntaxesSelected)
        NumberOfAvailableSyntaxes = NumberOfSupportedTransferSyntaxes;
    else
        NumberOfAvailableSyntaxes = 1;

    for (AvailableIndex = 0; AvailableIndex < NumberOfAvailableSyntaxes; AvailableIndex ++)
        {
        if (fMultipleTranfserSyntaxesSelected)
            CurrentTransferSyntax = &(TransferSyntaxesArray[AvailableIndex].TransferSyntax);
        else
            CurrentTransferSyntax = &RpcInterfaceInformation.TransferSyntax;
        for (ProposedIndex = 0; ProposedIndex < NumberOfTransferSyntaxes;
                ProposedIndex++)
            {
            if (MatchSyntaxIdentifiers(CurrentTransferSyntax,
                    &(ProposedTransferSyntaxes[ProposedIndex])) == 0)
                {
                // is this the preferred transfer syntax for the server?
                if (AvailableIndex == PreferredTransferSyntax)
                    {
                    // this is the preferred transfer syntax - just
                    // copy it and return
                    RpcpMemoryCopy(AcceptedTransferSyntax,
                            &(ProposedTransferSyntaxes[ProposedIndex]),
                            sizeof(RPC_SYNTAX_IDENTIFIER));
                    *fIsInterfaceTransferPreferred = TRUE;
                    *ProposedTransferSyntaxIndex = ProposedIndex;
                    *AvailableTransferSyntaxIndex = AvailableIndex;
                    return(0);
                    }
                else
                    {
                    // this is not the preferred syntax - just remeber this
                    // one (if no previous match was found) and continue
                    if (BackupTransferSyntax == NULL)
                        {
                        BackupTransferSyntax = &(ProposedTransferSyntaxes[ProposedIndex]);
                        BackupProposedTransferSyntaxIndex = ProposedIndex;
                        BackupAvailableTransferSyntaxIndex = AvailableIndex;
                        }
                    }
                }
            }
        }

    // if we're here, this means we didn't find the preferred transfer syntax
    // check whether there is a backup syntax
    if (BackupTransferSyntax)
        {
        RpcpMemoryCopy(AcceptedTransferSyntax, BackupTransferSyntax,
                sizeof(RPC_SYNTAX_IDENTIFIER));
        *fIsInterfaceTransferPreferred = FALSE;
        *ProposedTransferSyntaxIndex = BackupProposedTransferSyntaxIndex;
        *AvailableTransferSyntaxIndex = BackupAvailableTransferSyntaxIndex;
        return(0);
        }
    // nada - no transfer syntax matches
    return(1);
}

void RPC_INTERFACE::GetSelectedTransferSyntaxAndDispatchTable(IN int SelectedTransferSyntaxIndex,
    OUT RPC_SYNTAX_IDENTIFIER **SelectedTransferSyntax,
    OUT PRPC_DISPATCH_TABLE *SelectedDispatchTable)
{
    MIDL_SYNTAX_INFO *SelectedSyntaxInfo;

    if (DoesInterfaceSupportMultipleTransferSyntaxes(&RpcInterfaceInformation))
        {
        ASSERT((unsigned int)SelectedTransferSyntaxIndex <= NumberOfSupportedTransferSyntaxes);
        SelectedSyntaxInfo = &TransferSyntaxesArray[SelectedTransferSyntaxIndex];
        *SelectedTransferSyntax = &SelectedSyntaxInfo->TransferSyntax;
        // DCOM has only one dispatch table - they change the dispatch target
        // internally. They will define only the dispatch table in the
        // interface
        if (SelectedSyntaxInfo->DispatchTable)
            *SelectedDispatchTable = SelectedSyntaxInfo->DispatchTable;
        else
            *SelectedDispatchTable = GetDefaultDispatchTable();
        }
    else
        {
        *SelectedTransferSyntax = &RpcInterfaceInformation.TransferSyntax;
        *SelectedDispatchTable = GetDefaultDispatchTable();
        }
}

RPC_STATUS
RPC_INTERFACE::UnregisterManagerEpv (
    IN RPC_UUID PAPI * ManagerTypeUuid, OPTIONAL
    IN unsigned int WaitForCallsToComplete
    )
/*++

Routine Description:

    In this method, we unregister one or all of the manager entry point
    vectors for this interface, depending on what, if anything, is
    specified for the manager type uuid argument.

Arguments:

    ManagerTypeUuid - Optionally supplies the type uuid of the manager
        entry point vector to be removed.  If this argument is not supplied,
        then all manager entry point vectors for this interface will
        be removed.

    WaitForCallsToComplete - Supplies a flag indicating whether or not
        this routine should wait for all calls to complete using the
        interface and manager being unregistered.  A non-zero value
        indicates to wait.

Return Value:

    RPC_S_OK - The manager entry point vector(s) are(were) successfully
        removed from the this interface.

    RPC_S_UNKNOWN_MGR_TYPE - The specified type uuid is not registered
        with this interface.

    RPC_S_UNKNOWN_IF - The specified interface is not registered with
        the rpc server.

--*/
{
    RPC_INTERFACE_MANAGER * InterfaceManager;
    DictionaryCursor cursor;

    RequestGlobalMutex();
    if (ManagerCount == 0)
        {
        ClearGlobalMutex();
        return(RPC_S_UNKNOWN_MGR_TYPE);
        }

    if (ARGUMENT_PRESENT(ManagerTypeUuid) == 0)
        {
        InterfaceManagerDictionary.Reset(cursor);
        while ((InterfaceManager = InterfaceManagerDictionary.Next(cursor)) != 0)
            {
            InterfaceManager->InvalidateManager();
            }

        ManagerCount = 0;
        NullManagerFlag = 0;
        ClearGlobalMutex();

        if ( WaitForCallsToComplete != 0 )
            {
            while ( NullManagerActiveCallCount.GetInteger() > 0 )
                {
                PauseExecution(500L);
                }

            InterfaceManagerDictionary.Reset(cursor);
            while ((InterfaceManager = InterfaceManagerDictionary.Next(cursor)) != 0)
                {
                while ( InterfaceManager->InquireActiveCallCount() > 0 )
                    {
                    PauseExecution(500L);
                    }
                }
            }

        return(RPC_S_OK);
        }

    if (ManagerTypeUuid->IsNullUuid() != 0)
        {
        if (NullManagerFlag == 0)
            {
            ClearGlobalMutex();
            return(RPC_S_UNKNOWN_MGR_TYPE);
            }
        ManagerCount -= 1;
        NullManagerFlag = 0;
        ClearGlobalMutex();

        if ( WaitForCallsToComplete != 0 )
            {
            while ( NullManagerActiveCallCount.GetInteger() > 0 )
                {
                PauseExecution(500L);
                }
            }
        return(RPC_S_OK);
        }

    InterfaceManager = FindInterfaceManager(ManagerTypeUuid);
    if (   (InterfaceManager == 0)
        || (InterfaceManager->ValidManager() == 0))
        {
        ClearGlobalMutex();
        return(RPC_S_UNKNOWN_MGR_TYPE);
        }
    InterfaceManager->InvalidateManager();
    ManagerCount -= 1;
    ClearGlobalMutex();

    if ( WaitForCallsToComplete != 0 )
        {
        while ( InterfaceManager->InquireActiveCallCount() > 0 )
            {
            PauseExecution(500L);
            }
        }

    return(RPC_S_OK);
}


RPC_STATUS
RPC_INTERFACE::InquireManagerEpv (
    IN RPC_UUID PAPI * ManagerTypeUuid, OPTIONAL
    OUT RPC_MGR_EPV PAPI * PAPI * ManagerEpv
    )
/*++

Routine Description:

    This method is used to obtain the manager entry point vector
    with the specified type uuid supported by this interface.

Arguments:

    ManagerTypeUuid - Optionally supplies the type uuid of the manager
        entry point vector we want returned.  If no manager type uuid
        is specified, then the null uuid is assumed.

    ManagerEpv - Returns the manager entry point vector.

Return Value:

    RPC_S_OK - The manager entry point vector has successfully been
        returned.

    RPC_S_UNKNOWN_MGR_TYPE - The specified type uuid is not registered
        with the interface.

    RPC_S_UNKNOWN_IF - The specified interface is not registered with
        the rpc server.

--*/
{
    RPC_INTERFACE_MANAGER * InterfaceManager;

    RequestGlobalMutex();
    if (ManagerCount == 0)
        {
        ClearGlobalMutex();
        return(RPC_S_UNKNOWN_IF);
        }

    if (   (ARGUMENT_PRESENT(ManagerTypeUuid) == 0)
        || (ManagerTypeUuid->IsNullUuid() != 0))
        {
        if (NullManagerFlag == 0)
            {
            ClearGlobalMutex();
            return(RPC_S_UNKNOWN_MGR_TYPE);
            }

        *ManagerEpv = NullManagerEpv;
        ClearGlobalMutex();
        return(RPC_S_OK);
        }

    InterfaceManager = FindInterfaceManager(ManagerTypeUuid);
    if (   (InterfaceManager == 0)
        || (InterfaceManager->ValidManager() == 0))
        {
        ClearGlobalMutex();
        return(RPC_S_UNKNOWN_MGR_TYPE);
        }
    *ManagerEpv = InterfaceManager->QueryManagerEpv();
    ClearGlobalMutex();
    return(RPC_S_OK);
}


RPC_STATUS
RPC_INTERFACE::UpdateRpcInterfaceInformation (
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation,
    IN unsigned int Flags,
    IN unsigned int MaxCalls,
    IN unsigned int MaxRpcSize,
    IN RPC_IF_CALLBACK_FN PAPI *IfCallbackFn
    )
/*++

Routine Description:

    We never delete the interface objects from a server; we just invalidate
    them.   This means that if an interface has been complete unregistered
    (ie. it has no managers), we need to update the interface information
    again.

Arguments:

    RpcInterfaceInformation - Supplies the interface information which this
        interface should be using.

--*/
{
    unsigned int Length;
    RPC_STATUS Status;

    Length = RpcInterfaceInformation->Length;

    ASSERT((Length == sizeof(RPC_SERVER_INTERFACE)) ||
        (Length == NT351_INTERFACE_SIZE));

    // make it stick on free builds as well
    if ((Length != sizeof(RPC_SERVER_INTERFACE)) &&
        (Length != NT351_INTERFACE_SIZE))
        return RPC_S_UNKNOWN_IF;

    if ( ManagerCount == 0 )
        {
        if (DoesInterfaceSupportMultipleTransferSyntaxes(RpcInterfaceInformation))
            {
            Status = NdrServerGetSupportedSyntaxes(RpcInterfaceInformation,
                &NumberOfSupportedTransferSyntaxes,
                &TransferSyntaxesArray, &PreferredTransferSyntax);
            if (Status != RPC_S_OK)
                return Status;
            }
        else
            {
            NumberOfSupportedTransferSyntaxes = 0;
            }

        RpcpMemoryCopy(&(this->RpcInterfaceInformation),
                RpcInterfaceInformation, Length);
        }

    if (Flags & RPC_IF_AUTOLISTEN
        && (this->Flags & RPC_IF_AUTOLISTEN) == 0)
        {
        GlobalRpcServer->IncrementAutoListenInterfaceCount() ;
        }

    this->Flags = Flags ;
    this->MaxCalls = MaxCalls ;
    this->MaxRpcSize = MaxRpcSize;
    SequenceNumber++ ;

    if (Flags & RPC_IF_ALLOW_SECURE_ONLY
        && IfCallbackFn == NULL)
        {
        this->CallbackFn = DefaultCallbackFn;
        }
    else
        {
        this->CallbackFn = IfCallbackFn ;
        }

    return RPC_S_OK;
}


RPC_IF_ID __RPC_FAR *
RPC_INTERFACE::InquireInterfaceId (
    )
/*++

Return Value:

    If this interface is active, its interface id will be returned in a
    newly allocated chunk of memory; otherwise, zero will be returned.

--*/
{
    RPC_IF_ID __RPC_FAR * RpcIfId;

    if ( ManagerCount == 0 )
        {
        return(0);
        }

    RpcIfId = (RPC_IF_ID __RPC_FAR *) RpcpFarAllocate(sizeof(RPC_IF_ID));
    if ( RpcIfId == 0 )
        {
        return(0);
        }

    RpcIfId->Uuid = RpcInterfaceInformation.InterfaceId.SyntaxGUID;
    RpcIfId->VersMajor =
            RpcInterfaceInformation.InterfaceId.SyntaxVersion.MajorVersion;
    RpcIfId->VersMinor =
            RpcInterfaceInformation.InterfaceId.SyntaxVersion.MinorVersion;
    return(RpcIfId);
}


RPC_STATUS
RPC_INTERFACE::CheckSecurityIfNecessary(
    IN void * Context
    )
{

//
// If manager count in non-zero, this interface is still registered
// If it has been registered with a call back function, invoke the callback
// function, else return success....

    RPC_IF_ID RpcIfId;
    RPC_STATUS RpcStatus = RPC_S_OK;

    if (CallbackFn != 0)
        {
        RpcIfId.Uuid = RpcInterfaceInformation.InterfaceId.SyntaxGUID;
        RpcIfId.VersMajor =
            RpcInterfaceInformation.InterfaceId.SyntaxVersion.MajorVersion;
        RpcIfId.VersMinor =
            RpcInterfaceInformation.InterfaceId.SyntaxVersion.MinorVersion;

        BeginAutoListenCall();
        if (ManagerCount == 0)
            {
            EndAutoListenCall();
            return (RPC_S_UNKNOWN_IF);
            }

        RpcTryExcept
           {
           RpcStatus = CallbackFn(&RpcIfId, Context);
           }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
           {
           RpcStatus = RPC_S_ACCESS_DENIED;
           }
        RpcEndExcept

        EndAutoListenCall();
        }

    return(RpcStatus);
}


void
RPC_INTERFACE::WaitForCalls(
    )
/*++

Routine Description:

    Waits for the completion of all the calls on a given interface.

--*/
{
    DictionaryCursor cursor;
    RPC_INTERFACE_MANAGER * InterfaceManager;

    while ( NullManagerActiveCallCount.GetInteger() > 0 )
        {
        PauseExecution(500L);
        }

    InterfaceManagerDictionary.Reset(cursor);
    while ((InterfaceManager = InterfaceManagerDictionary.Next(cursor)) != 0)
        {
        while ( InterfaceManager->InquireActiveCallCount() > 0 )
            {
            PauseExecution(500L);
            }
        }
}


RPC_SERVER::RPC_SERVER (
    IN OUT RPC_STATUS PAPI * RpcStatus
    ) : AvailableCallCount(0),
        ServerMutex(RpcStatus,
                    TRUE   // pre-allocate semaphore
                    ),
        StopListeningEvent(RpcStatus),
        ThreadCacheMutex(RpcStatus,
                         TRUE,  // pre-allocate semaphore
                         100
                         ),
        NumAutoListenInterfaces(0)
/*++

Routine Description:

    This routine will get called to construct an instance of the
    RPC_SERVER class.

--*/
{
    ALLOCATE_THIS(RPC_SERVER);

    ServerListeningFlag = 0;
    ListeningThreadFlag = 0;
    WaitingThreadFlag = 0;
    MinimumCallThreads = 1;
    MaximumConcurrentCalls = 1;
    IncomingRpcCount = 0;
    OutgoingRpcCount = 0;
    ReceivedPacketCount = 0;
    SentPacketCount = 0;
    ThreadCache = 0;
    ListenStatusCode = RPC_S_OK;
    fAccountForMaxCalls = TRUE;

    pRpcForwardFunction = (RPC_FORWARD_FUNCTION *)0;
#if !defined(NO_LOCATOR_CODE)
    pNsBindingExport = 0;
    pNsBindingUnexport = 0;
#endif
}


RPC_INTERFACE *
RPC_SERVER::FindInterface (
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation
    )
/*++

Routine Description:

    This method is used to find the rpc interface registered with this
    server which matches the supplied rpc interface information.

Arguments:

    RpcInterfaceInformation - Supplies the rpc interface information
        identifying the rpc interface we are looking for.

Return Value:

    The rpc interface matching the supplied rpc interface information
    will be returned if it is found; otherwise, zero will be returned.

--*/
{
    RPC_INTERFACE * RpcInterface;
    DictionaryCursor cursor;

    ServerMutex.VerifyOwned();

    RpcInterfaceDictionary.Reset(cursor);
    while ((RpcInterface = RpcInterfaceDictionary.Next(cursor)) != 0)
        {
        if (RpcInterface->MatchRpcInterfaceInformation(
                RpcInterfaceInformation) == 0)
            {
            return(RpcInterface);
            }
        }

    // The management interface is implicitly registered in all servers.

    if (   (GlobalManagementInterface)
        && (GlobalManagementInterface->MatchRpcInterfaceInformation(
                RpcInterfaceInformation) == 0) )
        {
        return(GlobalManagementInterface);
        }

    return(0);
}


int
RPC_SERVER::AddInterface (
    IN RPC_INTERFACE * RpcInterface
    )
/*++

Routine Description:

    This method will be used to add an rpc interface to the set of
    interfaces known about by this server.

Arguments:

    RpcInterface - Supplies the rpc interface to add to the set of
        interfaces.

Return Value:

    Zero will be returned if the interface is successfully added to
    the set; otherwise, non-zero will be returned indicating that
    insufficient memory is available to complete the operation.

--*/
{
    if (RpcInterfaceDictionary.Insert(RpcInterface) == -1)
        {
        return(-1);
        }

    return(0);
}

RPC_STATUS
RPC_SERVER::FindInterfaceTransfer (
    IN PRPC_SYNTAX_IDENTIFIER InterfaceIdentifier,
    IN PRPC_SYNTAX_IDENTIFIER ProposedTransferSyntaxes,
    IN unsigned int NumberOfTransferSyntaxes,
    OUT PRPC_SYNTAX_IDENTIFIER AcceptedTransferSyntax,
    OUT RPC_INTERFACE ** AcceptingRpcInterface,
    OUT BOOL *fInterfaceTransferIsPreferred,
    OUT int *ProposedTransferSyntaxIndex,
    OUT int *AvailableTransferSyntaxIndex
    )
/*++

Routine Description:

    This method is used to determine if a client bind request can be
    accepted or not.  All we have got to do here is hand off to the
    server which owns this address.

Arguments:

    InterfaceIdentifier - Supplies the syntax identifier for the
        interface; this is the interface uuid and version.

    ProposedTransferSyntaxes - Supplies a list of one or more transfer
        syntaxes which the client initiating the binding supports.  The
        server should pick one of these which is supported by the
        interface.

    NumberOfTransferSyntaxes - Supplies the number of transfer syntaxes
        specified in the proposed transfer syntaxes argument.

    AcceptedTransferSyntax - Returns the transfer syntax which the
        server accepted.

    AcceptingRpcInterface - Returns a pointer to the rpc interface found
        which supports the requested interface and one of the requested
        transfer syntaxes.

    fInterfaceTransferIsPreferred - non zero if the interface transfer
        returned is preferred.

    TransferSyntaxIndex - the index of the chosen transfer syntax in the
        ProposedTransferSyntaxesArray

Return Value:

    RPC_S_OK - The requested interface exists and it supports at least
        one of the proposed transfer syntaxes.  We are all set, now we
        can make remote procedure calls.

     RPC_S_UNSUPPORTED_TRANSFER_SYNTAX - The requested interface exists,
        but it does not support any of the proposed transfer syntaxes.

     RPC_S_UNKNOWN_IF - The requested interface is not supported
        by this rpc server.

--*/
{
    RPC_INTERFACE * RpcInterface;
    unsigned int InterfaceFound = 0;
    DictionaryCursor cursor;

    ServerMutex.Request();
    RpcInterfaceDictionary.Reset(cursor);
    while ((RpcInterface = RpcInterfaceDictionary.Next(cursor)) != 0)
        {
        if (RpcInterface->MatchInterfaceIdentifier(InterfaceIdentifier) == 0)
            {
            InterfaceFound = 1;
            if (RpcInterface->SelectTransferSyntax(ProposedTransferSyntaxes,
                    NumberOfTransferSyntaxes, AcceptedTransferSyntax,
                    fInterfaceTransferIsPreferred, ProposedTransferSyntaxIndex,
                    AvailableTransferSyntaxIndex) == 0)
                {
                ServerMutex.Clear();
                *AcceptingRpcInterface = RpcInterface;
                return(RPC_S_OK);
                }
            }
        }

    ServerMutex.Clear();

    // The management interface is implicitly registered in all servers.

    if (   (GlobalManagementInterface)
        && (GlobalManagementInterface->MatchInterfaceIdentifier(
                InterfaceIdentifier) == 0 ) )
        {
        InterfaceFound = 1;
        if (GlobalManagementInterface->SelectTransferSyntax(
                ProposedTransferSyntaxes, NumberOfTransferSyntaxes,
                AcceptedTransferSyntax, fInterfaceTransferIsPreferred,
                ProposedTransferSyntaxIndex, AvailableTransferSyntaxIndex) == 0)
            {
            *AcceptingRpcInterface = GlobalManagementInterface;
            return(RPC_S_OK);
            }
        }

    if (InterfaceFound == 0)
        return(RPC_S_UNKNOWN_IF);

    return(RPC_S_UNSUPPORTED_TRANS_SYN);
}


RPC_INTERFACE *
RPC_SERVER::FindInterface (
    IN PRPC_SYNTAX_IDENTIFIER InterfaceIdentifier
    )
/*++

Routine Description:

    The datagram protocol module will use this routine to find the interface
    with out worrying about the transfer syntax.  Datagram RPC does not support
    more than a single transfer syntax.

Arguments:

    InterfaceIdentifier - Supplies the identifier (UUID and version) of the
        interface we are trying to find.

Return Value:

    If the interface is found it will be returned; otherwise, zero will be
    returned.

--*/
{
    RPC_INTERFACE * RpcInterface;
    DictionaryCursor cursor;

    ServerMutex.Request();
    RpcInterfaceDictionary.Reset(cursor);
    while ( (RpcInterface = RpcInterfaceDictionary.Next(cursor)) != 0)
        {
        if ( RpcInterface->MatchInterfaceIdentifier(InterfaceIdentifier)
                    == 0 )
            {
            ServerMutex.Clear();
            return(RpcInterface);
            }
        }
    ServerMutex.Clear();

    // The management interface is implicitly registered in all servers.

    if (   (GlobalManagementInterface)
        && (GlobalManagementInterface->MatchInterfaceIdentifier(
            InterfaceIdentifier) == 0) )
        {
        return(GlobalManagementInterface);
        }

    return(0);
}


RPC_STATUS
RPC_SERVER::ServerListen (
    IN unsigned int MinimumCallThreads,
    IN unsigned int MaximumConcurrentCalls,
    IN unsigned int DontWait
    )
/*++

Routine Description:

    This method is called to start this rpc server listening for remote
    procedure calls.  We do not return until after StopServerListening
    has been called and all active calls complete, or an error occurs.

Arguments:

    MinimumCallThreads - Supplies the minimum number of call threads
        which should be created to service remote procedure calls.

    MaximumConcurrentCalls - Supplies the maximum concurrent calls this
        rpc server is willing to accept at one time.

    DontWait - Supplies a flag indicating whether or not to wait until
        RpcMgmtStopServerListening has been called and all calls have
        completed.  A non-zero value indicates not to wait.

Return Value:

    RPC_S_OK - Everything worked out in the end.  All active calls
        completed successfully after RPC_SERVER::StopServerListening
        was called.  No errors occured in the transports.

    RPC_S_ALREADY_LISTENING - This rpc server is already listening.

    RPC_S_NO_PROTSEQS_REGISTERED - No protocol sequences have been
        registered with this rpc server.  As a consequence it is
        impossible for this rpc server to receive any remote procedure
        calls, hence, the error code.

    RPC_S_MAX_CALLS_TOO_SMALL - MaximumConcurrentCalls is smaller than
        MinimumCallThreads or MaximumConcurrentCalls is zero.


--*/
{
    RPC_ADDRESS * RpcAddress;
    RPC_STATUS Status;
    DictionaryCursor cursor;

    if (   ( MaximumConcurrentCalls < MinimumCallThreads )
        || ( MaximumConcurrentCalls == 0 ) )
        {
        return(RPC_S_MAX_CALLS_TOO_SMALL);
        }

    if ( MaximumConcurrentCalls > 0x7FFFFFFF )
        {
        MaximumConcurrentCalls = 0x7FFFFFFF;
        }

    ServerMutex.Request();

    if ( ListeningThreadFlag != 0 )
        {
        ServerMutex.Clear();
        return(RPC_S_ALREADY_LISTENING);
        }

    if ( RpcAddressDictionary.Size() == 0
         && RpcDormantAddresses.IsQueueEmpty())
        {
        ServerMutex.Clear();
        return(RPC_S_NO_PROTSEQS_REGISTERED);
        }

    this->MaximumConcurrentCalls = MaximumConcurrentCalls;
    // if we are provided the default number, then we don't really care -
    // play for optimal performance
    if (MaximumConcurrentCalls == RPC_C_LISTEN_MAX_CALLS_DEFAULT)
        fAccountForMaxCalls = FALSE;
    this->MinimumCallThreads = MinimumCallThreads;
    AvailableCallCount.SetInteger( MaximumConcurrentCalls );

    RpcAddressDictionary.Reset(cursor);
    while ( (RpcAddress = RpcAddressDictionary.Next(cursor)) != 0 )
        {
        Status = RpcAddress->ServerStartingToListen(
                                                    MinimumCallThreads,
                                                    MaximumConcurrentCalls);
        if (Status)
            {
            ServerMutex.Clear();
            return(Status);
            }
        }

    StopListeningEvent.Lower();
    ServerListeningFlag = 1;
    ListeningThreadFlag = 1;

    if ( DontWait != 0 )
        {
        ServerMutex.Clear();
        return(RPC_S_OK);
        }

    WaitingThreadFlag = 1;

    ServerMutex.Clear();

    return(WaitForStopServerListening());
}


RPC_STATUS
RPC_SERVER::WaitForStopServerListening (
    )
/*++

Routine Description:

    We wait for StopServerListening to be called and then for all active
    remote procedure calls to complete before returning.

Return Value:

    RPC_S_OK - Everything worked out in the end.  All active calls
        completed successfully after RPC_SERVER::StopServerListening
        was called.  No errors occured in the transports.

--*/
{
    RPC_ADDRESS * RpcAddress;
    DictionaryCursor cursor;
    RPC_INTERFACE * RpcInterface;

    StopListeningEvent.Wait();

    if ( ListenStatusCode != RPC_S_OK )
        {
        ListeningThreadFlag = 0;
        return(ListenStatusCode);
        }

    RpcAddressDictionary.Reset(cursor);
    while ( (RpcAddress = RpcAddressDictionary.Next(cursor)) != 0 )
        {
        RpcAddress->ServerStoppedListening();
        }

    RpcAddressDictionary.Reset(cursor);
    while ( (RpcAddress = RpcAddressDictionary.Next(cursor)) != 0 )
        {
        RpcAddress->WaitForCalls();
        }

    // Wait for calls on all interfaces to complete
    RpcInterfaceDictionary.Reset(cursor);
    while ((RpcInterface = RpcInterfaceDictionary.Next(cursor)) != 0)
        {
        RpcInterface->WaitForCalls();
        }

    ServerMutex.Request();
    WaitingThreadFlag = 0;
    ListeningThreadFlag = 0;
    ServerMutex.Clear();

    return(RPC_S_OK);
}


RPC_STATUS
RPC_SERVER::WaitServerListen (
    )
/*++

Routine Description:

    This routine performs the wait that ServerListen normally performs
    when the DontWait flag is not set.  An application must call this
    routine only after RpcServerListen has been called with the DontWait
    flag set.  We do not return until RpcMgmtStopServerListening is called
    and all active remote procedure calls complete, or a fatal error occurs
    in the runtime.

Return Value:

    RPC_S_OK - Everything worked as expected.  All active remote procedure
        calls have completed.  It is now safe to exit this process.

    RPC_S_ALREADY_LISTENING - Another thread has already called
        WaitServerListen and has not yet returned.

    RPC_S_NOT_LISTENING - ServerListen has not yet been called.


--*/
{
    ServerMutex.Request();
    if ( ListeningThreadFlag == 0 )
        {
        ServerMutex.Clear();
        return(RPC_S_NOT_LISTENING);
        }

    if ( WaitingThreadFlag != 0 )
        {
        ServerMutex.Clear();
        return(RPC_S_ALREADY_LISTENING);
        }

    WaitingThreadFlag = 1;
    ServerMutex.Clear();

    return(WaitForStopServerListening());
}


void
RPC_SERVER::InquireStatistics (
    OUT RPC_STATS_VECTOR * Statistics
    )
/*++

Routine Description:

    This method is used to obtain the statistics for this rpc server.

Arguments:

    Statistics - Returns the statistics for this rpc server.

--*/
{
    Statistics->Stats[RPC_C_STATS_CALLS_IN] = IncomingRpcCount;
    Statistics->Stats[RPC_C_STATS_CALLS_OUT] = OutgoingRpcCount;
    Statistics->Stats[RPC_C_STATS_PKTS_IN] = ReceivedPacketCount;
    Statistics->Stats[RPC_C_STATS_PKTS_OUT] = SentPacketCount;
}


RPC_STATUS
RPC_SERVER::StopServerListening (
    )
/*++

Routine Description:

    This method is called to stop this rpc server from listening for
    more remote procedure calls.  Active calls are allowed to complete
    (including callbacks).  The thread which called ServerListen will
    return when all active calls complete.

Return Value:

    RPC_S_OK - The thread that called ServerListen has successfully been
        notified that it should shutdown.

    RPC_S_NOT_LISTENING - There is no thread currently listening.

--*/
{
    if (ListeningThreadFlag == 0)
        return(RPC_S_NOT_LISTENING);

    ListenStatusCode = RPC_S_OK;
    ServerListeningFlag = 0;
    StopListeningEvent.Raise();
    return(RPC_S_OK);
}


RPC_STATUS
RPC_SERVER::UseRpcProtocolSequence (
    IN RPC_CHAR PAPI * NetworkAddress,
    IN RPC_CHAR PAPI * RpcProtocolSequence,
    IN unsigned int PendingQueueSize,
    IN RPC_CHAR PAPI *Endpoint,
    IN void PAPI * SecurityDescriptor,
    IN unsigned long EndpointFlags,
    IN unsigned long NICFlags,
    IN RPC_CHAR PAPI **pEndpointListenedOn, OPTIONAL
    IN BOOL fUseDuplicateEndpoints OPTIONAL
    )
/*++

Routine Description:

    This method is who does the work of creating new address (they
    are called protocol sequences in the DCE lingo) and adding them to
    this rpc server.

Arguments:

    RpcProtocolSequence - Supplies the rpc protocol sequence we wish
        to add to this rpc server.

    PendingQueueSize - Supplies the size of the queue of pending
        requests which should be created by the transport.  Some transports
        will not be able to make use of this value, while others will.

    Endpoint - Optionally supplies an endpoint to be used for the new
        address.  If an endpoint is not specified, then we will let
        the transport specify the endpoint.

    SecurityDescriptor - Optionally supplies a security descriptor to
        be placed on the rpc protocol sequence (address) we are adding
        to this rpc server.

    pEndpointListenedOn - Optionally allows the return of the endpoint on
        which we choose to listen.  Used when listening on a UDP dynamic
        endpoint on a multi-homed machine with dynamic binding enabled.
        First, we will pick a dynamic endpoint for the loopback address
        and then use it with the other enabled interfaces.

        On success, the returned value will point to the Endpoint member of an
        address object.  Therefore the returned value is read-only and the
        undelrying string is owned by the address.  We will only use the
        pointer to copy the string.

    fUseDuplicateEndpoints - Optionally tells the API to supress
        RPC_S_DUPLICATE_ENDPOINT when an address already exists for
        a given protseq and ep.

Return Value:

    RPC_S_OK - The requested rpc protocol sequence has been added to
        this rpc server.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to add the
        requested rpc protocol sequence to this rpc server.

    RPC_S_PROTSEQ_NOT_SUPPORTED - The specified rpc protocol sequence
        is not supported (but it appears to be valid).

    RPC_S_INVALID_RPC_PROTSEQ - The specified rpc protocol sequence is
        syntactically invalid.

    RPC_S_DUPLICATE_ENDPOINT - The supplied endpoint has already been
        added to this rpc server.

    RPC_S_INVALID_SECURITY_DESC - The supplied security descriptor is
        invalid.

--*/
{
    TRANS_INFO *ServerTransInfo ;
    RPC_STATUS Status;
    RPC_ADDRESS * RpcAddress;
    RPC_ADDRESS * Address;
    unsigned int StaticEndpointFlag;
    int Key;
    DictionaryCursor cursor;
    THREAD *ThisThread;
    BOOL IsEqual;
    FIREWALL_INFO *pCopyOfFirewallTable = NULL;

    ThisThread = ThreadSelf();
    if (ThisThread == NULL)
        return RPC_S_OUT_OF_MEMORY;

    // remove old EEInfo
    RpcpPurgeEEInfo();

    if (IsServerSideDebugInfoEnabled())
        {
        Status = InitializeServerSideCellHeapIfNecessary();
        if (Status != RPC_S_OK)
            return Status;
        }

    // This is a local protseq
    if ( RpcpStringCompare(RpcProtocolSequence,
                RPC_CONST_STRING("ncalrpc")) == 0 )
        {
        RpcAddress = LrpcCreateRpcAddress();
        }

    // This is a remote protseq
    else
        {
        // Check for sound security practices if the RPC verifier is enabled.
        if (gfRPCVerifierEnabledWithBreaks)
            {
            // Check if an unsafe protseq is being used.
            if (IsProtseqUnsafe(RpcProtocolSequence))
                {
                // If the RPC verifier is enabled, issue a warning for the use of
                // an unsecure protocol.
                RPC_VERIFIER_WARNING_MSG("Possible security threat: Server is listening on an unsafe protseq",
                                         RPC_VERIFIER_UNSAFE_PROTOCOL);
                DbgPrint("RPC: Listening on protseq: %S endpoint: %S\n",
                          RpcProtocolSequence,
                          Endpoint);
                RPC_VERIFIER_PRINT_OFFENDING_STACK(2, 4);
                }

            // Print out warnings only the first time insecure interfaces become exposed.
            if (!gfRemoteProtseqRegistered)
                {
                if (gfUnsecureInterfaceRegistered)
                    {
                    RPC_INTERFACE *RpcInterface;

                    RPC_VERIFIER_WARNING_MSG("Possible security threat: Unsecure interface becomes remotely accessible",
                                             RPC_VERIFIER_UNSECURE_IF_REMOTELY_ACCESSIBLE);

                    // Print the endpoint that is being registered.
                    DbgPrint("RPC: Starting to listen on protseq: %S endpoint: %S\n",
                             RpcProtocolSequence,
                             Endpoint);

                    // Print a list of unsecure interfaces registered that are
                    // now being exposed.
                    ServerMutex.Request();
                    RpcInterfaceDictionary.Reset(cursor);
                    while ((RpcInterface = RpcInterfaceDictionary.Next(cursor)) != 0)
                        {
                        // Check if this interface is not secure.
                        if (!RpcInterface->IsSecure() &&
                            !RpcInterface->IsOle() &&
                            !IsInterfaceExempt(&(RpcInterface->InqInterfaceInformation()->InterfaceId.SyntaxGUID),
                                               ALLOW_UNSECURE_REMOTE_ACCESS))
                            {
                            DbgPrint("RPC: Unsecure interface UUID: ");
                            PrintUUID(&(RpcInterface->InqInterfaceInformation()->InterfaceId.SyntaxGUID));
                            DbgPrint("\n");
                            }
                        }
                    ServerMutex.Clear();
                    }

                // Remember that a remote protseq has been registered so that we do
                // not duplicate checks and warnings in the future.
                gfRemoteProtseqRegistered = true;
                }
            }

        // Init the firewall address table so that we can check if selective
        // bindings are being used.
        // DoFirewallInit() is not thread safe we will take the global mutex.
        RequestGlobalMutex();

        if (DoFirewallInit() == FALSE)
            {
            ClearGlobalMutex();
            return RPC_S_OUT_OF_MEMORY;
            }

        // Also, get a copy of pFirewallTable while in the critical section
        // to protect against a race with the PnP table update.
        pCopyOfFirewallTable = GetFirewallTableCopy();
        if (pFirewallTable != NULL &&
            pCopyOfFirewallTable == NULL)
            {
            ClearGlobalMutex();
            return RPC_S_OUT_OF_MEMORY;
            }
        ClearGlobalMutex();

        // Check if selective bindings are enabled but the user requests us to bind
        // to all interfaces.  This is dangerous and can be done by administrator only.
        if (NetworkAddress == NULL &&
            pCopyOfFirewallTable != 0 &&
            NICFlags == RPC_C_BIND_TO_ALL_NICS)
            {
            // If we are running with RPC verifier, warn
            // that selective bindings are being circumvented.
            if (gfRPCVerifierEnabledWithBreaks)
                {
                RPC_VERIFIER_WARNING_MSG("Possible security threat: Server is forced to listen on all interfaces circumventing the firewall",
                                         RPC_VERIFIER_DISABLING_SELECTIVE_BINDING);
                RPC_VERIFIER_PRINT_OFFENDING_STACK(2, 4);
                }

            // Fail if this is not an admin.
            if (IsCurrentUserAdmin() != RPC_S_OK)
                {
                delete pCopyOfFirewallTable;
                return (RPC_S_ACCESS_DENIED);
                }
            }

        if ( RpcpStringNCompare(RPC_CONST_STRING("ncadg_"),
                                RpcProtocolSequence,
                                6) == 0 )
            {
            //
            // If we are using selective binding we will create a DG_ADDRESS
            // to listen on each of the interfaces that are allowed by the
            // firewall table.  To do this we will call this function recursively.
            //
            // We do not implement this functionality for the cluster addresses.
            //

            // We will listen on the interfaces from the firewall address table iff:
            // - the user did not specify a specific interface to listen on (this also
            // takes care of the recursive case)
            // - firewall address table is configured
            // - the user does not explicitly wish to listen on all the interfaces.
            // We are listening on a subset of all interfaces.
            if (NetworkAddress == NULL &&
                pCopyOfFirewallTable != 0 &&
                NICFlags != RPC_C_BIND_TO_ALL_NICS &&
                RpcpStringNCompare(RPC_CONST_STRING("ncadg_cluster"),
                                   RpcProtocolSequence,
                                   13) != 0)
                {
                // Set when we find the loopback address in the firewall address table.
                BOOL bLoopbackAddressProcessed = FALSE;
                // The string representation of the IP address to listen on: xxx.xxx.xxx.xxx\0
                RPC_SCHAR StrAddr[16];
                // The array of 4 uchars contained in a DWORD that represents an IP address:
                // ddccbbaa -> aa.bb.cc.dd
                unsigned char *InAddr;
                // The endpoint on which the loopback interface chose to listen.  We will
                // use it with all the other ones.
                RPC_CHAR *EndpointListenedOn;

                // Listen on the loopback address.
                if ((Status = UseRpcProtocolSequence (RPC_STRING_LITERAL("127.0.0.1"),
                                               RpcProtocolSequence,
                                               PendingQueueSize,
                                               Endpoint,
                                               SecurityDescriptor,
                                               EndpointFlags,
                                               NICFlags,
                                               &EndpointListenedOn)) != RPC_S_OK)
                    {
                    delete pCopyOfFirewallTable;
                    return Status;
                    }

                // EndpointListenedOn should have been initialized and should point to
                // the Endpoint for the RpcAddress created by the preceeding call to
                // UseRpcProtocolSequence.  Thus, we do not own this memory and must
                // _not_ free it.  This is fine, since the following calls to 
                // UseRpcProtocolSequence duplicate Endpoint before partying on it.
                ASSERT(EndpointListenedOn);

                // Walk the list of interfaces that we want to listen on.
                for (unsigned i = 0; i < pCopyOfFirewallTable->NumAddresses; i ++)
                    {
                    // We always want to listen on the loopback address.  Since we
                    // chose to listen on it above, we should skip it here.
                    if (pCopyOfFirewallTable->Entries[i].Address == 0x0100007f)
                        {
                        continue;
                        }

                    // Listen only on the addresses that are enabled for listening
                    // in the selective binding settings.
                    if (pCopyOfFirewallTable->Entries[i].fEnabled)
                        {
                        // Extract the array of address components from the table.
                        InAddr = (unsigned char *) &(pCopyOfFirewallTable->Entries[i].Address);

                        // Compose the string representation of the IP address.
                        swprintf((RPC_SCHAR *)StrAddr, RPC_CONST_SSTRING("%d.%d.%d.%d"),
                                 InAddr[0], InAddr[1], InAddr[2], InAddr[3]);

                        // Call this function recursively to listen on the address.
                        Status = UseRpcProtocolSequence (StrAddr,
                                                         RpcProtocolSequence,
                                                         PendingQueueSize,
                                                         EndpointListenedOn,
                                                         SecurityDescriptor,
                                                         EndpointFlags,
                                                         NICFlags,
                                                         NULL,
                                                         TRUE); // Ignore the error if RPC is already listening on the ep.

                        if (Status != RPC_S_OK)
                            {
                            delete pCopyOfFirewallTable;
                            return Status;
                            }
                        }
                    }

                delete pCopyOfFirewallTable;
                return RPC_S_OK;
                }

            //
            // Just use the osf mapping...it simply calls the
            // protocol-independent ones.
            //

            Status = OsfMapRpcProtocolSequence(1,
                                               RpcProtocolSequence,
                                               &ServerTransInfo);

            if (Status != RPC_S_OK)
                {
                delete pCopyOfFirewallTable;
                return Status;
                }

            RpcAddress = DgCreateRpcAddress(ServerTransInfo);
            }
        else if ( RpcpStringNCompare(
                                RPC_CONST_STRING("ncacn_"),
                                RpcProtocolSequence,
                                6) == 0)
            {
            Status = OsfMapRpcProtocolSequence(1,
                                               RpcProtocolSequence,
                                               &ServerTransInfo);
            if (Status != RPC_S_OK)
                {
                delete pCopyOfFirewallTable;
                return(Status);
                }

            RpcAddress = OsfCreateRpcAddress(ServerTransInfo);
            }
        else
            {
            delete pCopyOfFirewallTable;
            return(RPC_S_PROTSEQ_NOT_SUPPORTED);
            }
        } // else  This is a remote protseq

    delete pCopyOfFirewallTable;

    if (RpcAddress == 0)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    if (ARGUMENT_PRESENT(Endpoint))
        {
        ServerMutex.Request();

        RpcAddressDictionary.Reset(cursor);
        while ((Address = RpcAddressDictionary.Next(cursor)) != 0)
            {
            if ( Address->SameEndpointAndProtocolSequence(
                                                 NetworkAddress,
                                                 RpcProtocolSequence,
                                                 Endpoint) != 0 )
                {
                ServerMutex.Clear();
                delete RpcAddress;

                // Check whether the caller does not mind using an existing address if
                // it matches the protseq and ep specified.
                if (fUseDuplicateEndpoints)
                    {
                    // This only happens with DG selective binding when listening
                    // on non-loopback addresses.  The caller does not ask for pEndpointListenedOn
                    // in this case.
                    ASSERT(!ARGUMENT_PRESENT(pEndpointListenedOn));
                    return RPC_S_OK;
                    }
                else
                    {
                    return(RPC_S_DUPLICATE_ENDPOINT);
                    }
                }
            }
        ServerMutex.Clear();

        Endpoint = DuplicateString(Endpoint);
        if (Endpoint == 0)
            {
            delete RpcAddress;
            return(RPC_S_OUT_OF_MEMORY);
            }

        StaticEndpointFlag = 1;
        }
    else
        {
        //
        // MACBUG:
        // We need to include this for Macintosh/Win95 also...
        //
        ServerMutex.Request() ;
        RpcAddressDictionary.Reset(cursor) ;
        while ((Address = RpcAddressDictionary.Next(cursor)) != 0)
            {
            Status = Address->SameProtocolSequenceAndSD(NetworkAddress,
                RpcProtocolSequence,
                (SECURITY_DESCRIPTOR *)SecurityDescriptor,
                &IsEqual);

            // if we either failed, or succeeded and they are equal,
            // return
            if ((Status != RPC_S_OK) || IsEqual)
                {
                ServerMutex.Clear();

                // Return the endpoint listened on if the caller requested it.
                // We must always return it on sucess.
                if (Status == RPC_S_OK && ARGUMENT_PRESENT(pEndpointListenedOn))
                    {
                    ASSERT(Address->InqEndpoint());
                    *pEndpointListenedOn = Address->InqEndpoint();
                    }

                delete RpcAddress;

                return(Status);
                }
            }
        ServerMutex.Clear();

        StaticEndpointFlag = 0;
        } // else

    if (EndpointFlags & RPC_C_DONT_FAIL)
        {
        RpcAddress->PnpNotify();
        }

    // If Endpoint == NULL, then on return it will contain the
    // dynamic endpoint listened on.  We will own that memory.
    // If Endpoint != NULL, then on return it will be unchanged.
    // We will continue to own that memory.
    Status = RpcAddress->ServerSetupAddress(
                                            NetworkAddress,
                                            &Endpoint,
                                            PendingQueueSize,
                                            SecurityDescriptor,
                                            EndpointFlags,
                                            NICFlags);

    if (Status == RPC_S_OK)
        {
        RPC_CHAR *MyNetworkAddress = NULL;

        // If the caller wants to know what endpoint we used, return it.
        if (ARGUMENT_PRESENT(pEndpointListenedOn))
            {
            // The only case when we should get called with pEndpointListenedOn
            // is when using selective binding with DG and listening on several
            // interfaces.  In this case, NetworkAddress is specified.
            ASSERT(NetworkAddress);
            ASSERT(Endpoint);
            *pEndpointListenedOn = Endpoint;
            }

        RpcProtocolSequence = DuplicateString(RpcProtocolSequence);

        if (RpcProtocolSequence == 0)
            {
            delete Endpoint;
            delete RpcAddress;

            return(RPC_S_OUT_OF_MEMORY);
            }

        if (ARGUMENT_PRESENT(NetworkAddress))
            {
            MyNetworkAddress = DuplicateString(NetworkAddress);
            if (MyNetworkAddress == 0)
                {
                delete Endpoint;
                delete RpcAddress;
                delete RpcProtocolSequence;

                return(RPC_S_OUT_OF_MEMORY);
                }
            }

        Status = RpcAddress->SetEndpointAndStuff(
                                        MyNetworkAddress,
                                        Endpoint,
                                        RpcProtocolSequence,
                                        this,
                                        StaticEndpointFlag,
                                        PendingQueueSize,
                                        SecurityDescriptor,
                                        EndpointFlags,
                                        NICFlags);
        if (Status != RPC_S_OK)
            {
            delete RpcAddress;

            return Status;
            }
        }
    else
        {
        // Mask the failure if RPC_C_DONT_FAIL was specified.
        // We can't mask the failure when using selective bidings and the caller
        // expects us to define pEndpointListenedOn.
        //
        // RPC_C_DONT_FAIL will not work when listening on a UDP dynamic
        // endpoint with selective binding enabled.
        if ((EndpointFlags & RPC_C_DONT_FAIL)
            && !ARGUMENT_PRESENT(pEndpointListenedOn))
            {
            int retval;

            RPC_CHAR *MyNetworkAddress = NULL;

            RpcProtocolSequence = DuplicateString(RpcProtocolSequence);

            if (RpcProtocolSequence == 0)
                {
                delete Endpoint;
                delete RpcAddress;

                return(RPC_S_OUT_OF_MEMORY);
                }

            if (ARGUMENT_PRESENT(NetworkAddress))
                {
                MyNetworkAddress = DuplicateString(NetworkAddress);
                if (MyNetworkAddress == 0)
                    {
                    delete Endpoint;
                    delete RpcAddress;
                    delete RpcProtocolSequence;

                    return(RPC_S_OUT_OF_MEMORY);
                    }
                }

            Status = RpcAddress->SetEndpointAndStuff(
                                            MyNetworkAddress,
                                            Endpoint,
                                            RpcProtocolSequence,
                                            this,
                                            StaticEndpointFlag,
                                            PendingQueueSize,
                                            SecurityDescriptor,
                                            EndpointFlags,
                                            NICFlags);
            if (Status != RPC_S_OK)
                {
                delete Endpoint;
                delete RpcAddress;

                return Status;
                }

            ServerMutex.Request();
            retval = RpcDormantAddresses.PutOnQueue(RpcAddress, 0);
            ServerMutex.Clear();

            if (retval == 1)
                {
                delete Endpoint;
                delete RpcAddress;

                return RPC_S_OUT_OF_MEMORY;
                }

            ServerMutex.Request();
            Status = RpcAddress->ServerStartingToListen(
                                                MinimumCallThreads,
                                                MaximumConcurrentCalls);
            ServerMutex.Clear();

            return(Status);
            }
        else
            {
            ASSERT(Status != RPC_S_OK);

            delete RpcAddress;

            return(Status);
            }
        }

    Key = AddAddress(RpcAddress);
    if (Key == -1)
        {
        delete RpcAddress;

        return(RPC_S_OUT_OF_MEMORY);
        }

    RpcAddress->DictKey = Key;

    ServerMutex.Request();
    Status = RpcAddress->ServerStartingToListen(
                                                MinimumCallThreads,
                                                MaximumConcurrentCalls);
    ServerMutex.Clear();

    if (Status != RPC_S_OK)
        {
        return(Status);
        }

    //
    // Inform the transport that it can start.
    //
    RpcAddress->CompleteListen() ;

    // Verify that pEndpointListenedOn is being returned on success
    // if the caller asked for it.
    if (ARGUMENT_PRESENT(pEndpointListenedOn))
        {
        ASSERT(*pEndpointListenedOn);
        }

    return(RPC_S_OK);
}


int
RPC_SERVER::AddAddress (
    IN RPC_ADDRESS * RpcAddress
    )
/*++

Routine Description:

    This method is used to add an rpc address to the dictionary of
    rpc addresses know about by this rpc server.

Arguments:

    RpcAddress - Supplies the rpc address to be inserted into the
        dictionary of rpc addresses.

Return Value:

    RPC_S_OK - The supplied rpc address has been successfully added
        to the dictionary.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to insert
        the rpc address into the dictionary.

--*/
{
    int Key;
    ServerMutex.Request();
    Key = RpcAddressDictionary.Insert(RpcAddress);
    ServerMutex.Clear();
    return(Key);
}


RPC_STATUS
RPC_SERVER::UnregisterIf (
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation OPTIONAL,
    IN RPC_UUID PAPI * ManagerTypeUuid OPTIONAL,
    IN unsigned int WaitForCallsToComplete
    )
/*++

Routine Description:

    This method does the work of unregistering an interface from this
    rpc server.  We actually do not remove the interface; what we do
    is to one or all of the manager entry point vector depending upon
    the type uuid argument supplied.

Arguments:

    RpcInterfaceInformation - Supplies a description of the interface
        for which we want to unregister one or all manager entry point
        vectors.

    ManagerTypeUuid - Optionally supplies the type uuid of the manager
        entry point vector to be removed.  If this argument is not supplied,
        then all manager entry point vectors for this interface will
        be removed.

    WaitForCallsToComplete - Supplies a flag indicating whether or not
        this routine should wait for all calls to complete using the
        interface and manager being unregistered.  A non-zero value
        indicates to wait.

Return Value:

    RPC_S_OK - The manager entry point vector(s) are(were) successfully
        removed from the specified interface.

    RPC_S_UNKNOWN_MGR_TYPE - The specified type uuid is not registered
        with the interface.

    RPC_S_UNKNOWN_IF - The specified interface is not registered with
        the rpc server.

--*/
{
    RPC_INTERFACE * RpcInterface;
    RPC_STATUS RpcStatus;
    RPC_STATUS Status;
    int i;
    DictionaryCursor cursor;

    UNUSED(WaitForCallsToComplete);

    if (ARGUMENT_PRESENT(RpcInterfaceInformation))
        {
        ServerMutex.Request();
        RpcInterface = FindInterface(RpcInterfaceInformation);
        ServerMutex.Clear();
        if (RpcInterface == 0)
            return(RPC_S_UNKNOWN_IF);

        if (RpcInterface->IsAutoListenInterface())
            {
            GlobalRpcServer->DecrementAutoListenInterfaceCount() ;
            }

        // We need to wait for all auto-listen calls to complete regardless
        // of whether this is autolisten or non-autolisten interface.
        // This is necessary because security callbacks increment the
        // AutoListenCallCount on dispatch to protect interface against being unregistered.
        while ( RpcInterface->InqAutoListenCallCount() )
            {
            RPC_ADDRESS * Address;

            ServerMutex.Request();

            RpcAddressDictionary.Reset(cursor);
            while (0 != (Address = RpcAddressDictionary.Next(cursor)))
                {
                Address->EncourageCallCleanup(RpcInterface);
                }
            ServerMutex.Clear();

            PauseExecution(500);
            }

        return(RpcInterface->UnregisterManagerEpv(ManagerTypeUuid,
                WaitForCallsToComplete));
        }

    Status = RPC_S_UNKNOWN_MGR_TYPE;

    ServerMutex.Request();
    RpcInterfaceDictionary.Reset(cursor);
    while ((RpcInterface = RpcInterfaceDictionary.Next(cursor)) != 0)
        {
        // auto-listen intefaces have to be individually unregistered
        if (RpcInterface->IsAutoListenInterface())
            {
            continue;
            }

        RpcStatus = RpcInterface->UnregisterManagerEpv(ManagerTypeUuid,
                WaitForCallsToComplete);
        if (RpcStatus == RPC_S_OK)
            {
            Status = RPC_S_OK;
            }
        }
    ServerMutex.Clear();

    return(Status);
}


RPC_STATUS
RPC_SERVER::InquireManagerEpv (
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation,
    IN RPC_UUID PAPI * ManagerTypeUuid, OPTIONAL
    OUT RPC_MGR_EPV PAPI * PAPI * ManagerEpv
    )
/*++

Routine Description:

    This method is used to obtain the manager entry point vector for
    an interface supported by this rpc server.  A type uuid argument
    specifies which manager entry point vector is to be obtained.

Arguments:

    RpcInterfaceInformation - Supplies a description of the interface.

    ManagerTypeUuid - Optionally supplies the type uuid of the manager
        entry point vector we want returned.  If no manager type uuid
        is specified, then the null uuid is assumed.

    ManagerEpv - Returns the manager entry point vector.

Return Value:

    RPC_S_OK - The manager entry point vector has successfully been
        returned.

    RPC_S_UNKNOWN_MGR_TYPE - The specified type uuid is not registered
        with the interface.

    RPC_S_UNKNOWN_IF - The specified interface is not registered with
        the rpc server.

--*/
{
    RPC_INTERFACE * RpcInterface;

    ServerMutex.Request();
    RpcInterface = FindInterface(RpcInterfaceInformation);
    ServerMutex.Clear();
    if (RpcInterface == 0)
        return(RPC_S_UNKNOWN_IF);

    return(RpcInterface->InquireManagerEpv(ManagerTypeUuid, ManagerEpv));
}





RPC_STATUS
RPC_SERVER::InquireBindings (
    OUT RPC_BINDING_VECTOR PAPI * PAPI * BindingVector
    )
/*++

Routine Description:

    For each rpc protocol sequence registered with this rpc server
    we want to create a binding handle which can be used to make
    remote procedure calls using the registered rpc protocol sequence.
    We return a vector of these binding handles.

Arguments:

    BindingVector - Returns the vector of binding handles.

Return Value:

    RPC_S_OK - At least one rpc protocol sequence has been registered
        with this rpc server, and the operation completed successfully.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete
        the operation.

    RPC_S_NO_BINDINGS - No rpc protocol sequences have been successfully
        registered with this rpc server.

--*/
{
    RPC_BINDING_VECTOR PAPI * RpcBindingVector;
    unsigned int Index, RpcAddressIndex;
    RPC_ADDRESS * RpcAddress;
    BINDING_HANDLE * BindingHandle;
    int i ;
    RPC_CHAR PAPI * LocalNetworkAddress;
    int count = 0 ;
    DictionaryCursor cursor;

    ServerMutex.Request();
    if (RpcAddressDictionary.Size() == 0
        && RpcDormantAddresses.IsQueueEmpty())
        {
        ServerMutex.Clear();
        return(RPC_S_NO_BINDINGS);
        }


    RpcAddressDictionary.Reset(cursor);
    while ((RpcAddress = RpcAddressDictionary.Next(cursor)) != 0)
        {
        count += RpcAddress->InqNumNetworkAddress();
        }

    RpcBindingVector = (RPC_BINDING_VECTOR PAPI *) RpcpFarAllocate(
            sizeof(RPC_BINDING_VECTOR) + (count -1 )
            * sizeof(RPC_BINDING_HANDLE) );
    if (RpcBindingVector == 0)
        {
        ServerMutex.Clear();
        return(RPC_S_OUT_OF_MEMORY);
        }

    RpcBindingVector->Count = count;
    for (Index = 0; Index < RpcBindingVector->Count; Index++)
        RpcBindingVector->BindingH[Index] = 0;

    Index = 0;
    RpcAddressDictionary.Reset(cursor);
    while ((RpcAddress = RpcAddressDictionary.Next(cursor)) != 0)
        {
        RpcAddressIndex = 0;
        LocalNetworkAddress = RpcAddress->
                               GetListNetworkAddress(RpcAddressIndex) ;

        while(LocalNetworkAddress != NULL)
            {
            BindingHandle = RpcAddress->
                             InquireBinding(LocalNetworkAddress);
            if (BindingHandle == 0)
                {
                ServerMutex.Clear();
                RpcBindingVectorFree(&RpcBindingVector);
                return(RPC_S_OUT_OF_MEMORY);
                }
            RpcBindingVector->BindingH[Index] = BindingHandle;
            Index += 1;
            RpcAddressIndex += 1;
            LocalNetworkAddress = RpcAddress->
                                   GetListNetworkAddress(RpcAddressIndex) ;
            }
        }
    ServerMutex.Clear();

    ASSERT(Index == RpcBindingVector->Count);

    *BindingVector = RpcBindingVector;
    return(RPC_S_OK);
}


RPC_STATUS
RPC_SERVER::RegisterAuthInfoHelper (
    IN RPC_CHAR PAPI * ServerPrincipalName,
    IN unsigned long AuthenticationService,
    IN RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFunction, OPTIONAL
    IN void PAPI * Argument OPTIONAL
    )
{
    RPC_AUTHENTICATION * Service;
    RPC_STATUS RpcStatus;
    RPC_CHAR __RPC_FAR * PrincipalName;
    DictionaryCursor cursor;
    BOOL EmptySPNAllocated = FALSE;

    if (ServerPrincipalName == NULL)
        {
        ServerPrincipalName = new RPC_CHAR[1];
        if (ServerPrincipalName == NULL)
            {
            return (RPC_S_OUT_OF_MEMORY);
            }
        EmptySPNAllocated = TRUE;
        ServerPrincipalName[0] = '\0';
        }

    if ( AuthenticationService == 0 )
        {
        return(RPC_S_UNKNOWN_AUTHN_SERVICE);
        }

    if (AuthenticationService == RPC_C_AUTHN_DEFAULT)
        {
        RpcpGetDefaultSecurityProviderInfo();
        AuthenticationService = DefaultProviderId;
        }

    ServerMutex.Request();
    AuthenticationDictionary.Reset(cursor);
    while ( (Service = AuthenticationDictionary.Next(cursor)) != 0 )
        {
        if ( Service->AuthenticationService == AuthenticationService &&
             0 == RpcpStringCompare(Service->ServerPrincipalName, ServerPrincipalName))
            {
            Service->GetKeyFunction = GetKeyFunction;
            Service->Argument = Argument;
            ServerMutex.Clear();

            if (EmptySPNAllocated)
                delete [] ServerPrincipalName;

            // Flush the server-credentials cache
            RpcStatus = RemoveCredentialsFromCache(AuthenticationService);
            return (RpcStatus);
            }
        }

    RpcStatus = IsAuthenticationServiceSupported(AuthenticationService);
    if ( RpcStatus != RPC_S_OK )
        {
        ServerMutex.Clear();
        if ( (RpcStatus == RPC_S_UNKNOWN_AUTHN_SERVICE) ||
             (RpcStatus == RPC_S_UNKNOWN_AUTHN_LEVEL) )
            {
            return (RPC_S_UNKNOWN_AUTHN_SERVICE);
            }
        else
            {
            return (RPC_S_OUT_OF_MEMORY);
            }
        }

    Service = new RPC_AUTHENTICATION;
    if ( Service == 0 )
        {
        ServerMutex.Clear();
        return(RPC_S_OUT_OF_MEMORY);
        }
    Service->AuthenticationService = AuthenticationService;
    Service->ServerPrincipalName = DuplicateString(ServerPrincipalName);
    Service->GetKeyFunction = GetKeyFunction;
    Service->Argument = Argument;
    if ( Service->ServerPrincipalName == 0 )
        {
        ServerMutex.Clear();
        delete Service;
        return(RPC_S_OUT_OF_MEMORY);
        }
    if ( AuthenticationDictionary.Insert(Service) == -1 )
        {
        ServerMutex.Clear();
        delete Service;
        return(RPC_S_OUT_OF_MEMORY);
        }
    ServerMutex.Clear();
    return(RPC_S_OK);
}


RPC_STATUS
RPC_SERVER::AutoRegisterAuthSvc(
    IN RPC_CHAR * ServerPrincipalName,
    IN unsigned long AuthenticationService
    )
{
    RPC_STATUS Status;
    DictionaryCursor cursor;
    RPC_AUTHENTICATION * Service;

    //
    // Don't need to auto-register the provider if it is already registered
    //
    ServerMutex.Request();
    AuthenticationDictionary.Reset(cursor);
    while ( (Service = AuthenticationDictionary.Next(cursor)) != 0 )
        {
        if ( Service->AuthenticationService == AuthenticationService)
            {
            ServerMutex.Clear();
            return (RPC_S_OK);
            }
        }
    ServerMutex.Clear();

    Status = RegisterAuthInfoHelper(ServerPrincipalName,
                                    AuthenticationService,
                                    NULL,
                                    NULL);
    if (Status == RPC_S_UNKNOWN_AUTHN_SERVICE)
        {
        //
        // Ok to not register provider if it is disabled
        //
        return RPC_S_OK;
        }

    return Status;
}


RPC_STATUS
RPC_SERVER::RegisterAuthInformation (
    IN RPC_CHAR PAPI * ServerPrincipalName,
    IN unsigned long AuthenticationService,
    IN RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFunction, OPTIONAL
    IN void PAPI * Argument OPTIONAL
    )
/*++

Routine Description:

    This method is used to register authentication, authorization, and
    a server principal name to be used for security for this server.  We
    will use this information to authenticate remote procedure calls.

Arguments:

    ServerPrincipalName - Supplies the principal name for the server.

    AuthenticationService - Supplies an authentication service to use when
        the server receives a remote procedure call.

    GetKeyFunction - Optionally supplies a routine to be used when the runtime
        needs an encryption key.

    Argument - Optionally supplies an argument to be passed to the routine used
        to get keys each time it is called.

Return Value:

    RPC_S_OK - The authentication service and server principal name have
        been registered with this RPC server.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete the
        operation.

    RPC_S_UNKNOWN_AUTHN_SERVICE - The specified authentication service is
        not supported.

--*/
{
    RPC_STATUS Status;
    RPC_CHAR *PrincName;

    Status = RegisterAuthInfoHelper(ServerPrincipalName,
                                    AuthenticationService,
                                    GetKeyFunction,
                                    Argument);
    if (Status != RPC_S_OK)
        {
        return Status;
        }

    if (AuthenticationService != RPC_C_AUTHN_GSS_NEGOTIATE)
        {
        return RPC_S_OK;
        }

    Status = AutoRegisterAuthSvc(ServerPrincipalName, RPC_C_AUTHN_WINNT);
    if (Status != RPC_S_OK)
        {
        return Status;
        }

    Status = AutoRegisterAuthSvc(ServerPrincipalName, RPC_C_AUTHN_GSS_KERBEROS);

    return Status;
}


RPC_STATUS
RPC_SERVER::AcquireCredentials (
    IN unsigned long AuthenticationService,
    IN unsigned long AuthenticationLevel,
    OUT SECURITY_CREDENTIALS ** SecurityCredentials
    )
/*++

Routine Description:

    The protocol modules will use this to obtain a set of credentials
    for the specified authentication service, assuming that the server
    supports them.

Arguments:

    AuthenticationService - Supplies the authentication service for which
        we hope to obtain credentials.

    AuthenticationLevel - Supplies the authentication level to be used.

    SecurityCredentials - Returns the security credentials.

Return Value:

    RPC_S_OK - You have been given some security credentials, which you need
         to free using RPC_SERVER::FreeCredentials when you are done with
         them.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete the
        operation.

    RPC_S_UNKNOWN_AUTHN_SERVICE - The specified authentication service is
        not supported by the current configuration.

--*/
{
    RPC_AUTHENTICATION * Service;
    RPC_STATUS RpcStatus = RPC_S_OK;
    DictionaryCursor cursor;

    ServerMutex.Request();
    AuthenticationDictionary.Reset(cursor);
    while ( (Service = AuthenticationDictionary.Next(cursor)) != 0 )
        {
        if ( Service->AuthenticationService == AuthenticationService )
            {
            ServerMutex.Clear();

            RpcStatus = FindServerCredentials(
                            Service->GetKeyFunction,
                            Service->Argument,
                            AuthenticationService,
                            AuthenticationLevel,
                            Service->ServerPrincipalName,
                            SecurityCredentials
                            );

            VALIDATE(RpcStatus)
                {
                RPC_S_OK,
                RPC_S_SEC_PKG_ERROR,
                RPC_S_OUT_OF_MEMORY,
                RPC_S_INVALID_AUTH_IDENTITY,
                ERROR_SHUTDOWN_IN_PROGRESS,
                RPC_S_UNKNOWN_AUTHN_SERVICE
                } END_VALIDATE;
            return(RpcStatus);
            }
        }

    ServerMutex.Clear();
    return(RPC_S_UNKNOWN_AUTHN_SERVICE);
}


void
RPC_SERVER::FreeCredentials (
    IN SECURITY_CREDENTIALS * SecurityCredentials
    )
/*++

Routine Description:

    A protocol module will indicate that it is through using a set of
    security credentials, obtained from RPC_SERVER::AcquireCredentials,
    using this routine.

Arguments:

    SecurityCredentials - Supplies the security credentials to be freed.

--*/
{
    SecurityCredentials->FreeCredentials();
    delete SecurityCredentials;
}


RPC_STATUS
RPC_SERVER::RegisterInterface (
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation,
    IN RPC_UUID PAPI * ManagerTypeUuid,
    IN RPC_MGR_EPV PAPI * ManagerEpv,
    IN unsigned int Flags,
    IN unsigned int MaxCalls,
    IN unsigned int MaxRpcSize,
    IN RPC_IF_CALLBACK_FN PAPI *IfCallbackFn
    )
/*++

Routine Description:

    This routine is used by server application to register a manager
    entry point vector and optionally an interface.  If the interface
    has not been registered, then it will be registered.  If it has
    already been registered, the manager entry point vector will be
    added to it under the specified type uuid.

Arguments:

    RpcInterfaceInformation - Supplies a description of the interface to
        be registered.  We will make a copy of this information.

    ManagerTypeUuid - Optionally supplies the type uuid for the specified
        manager entry point vector.  If no type uuid is supplied, then
        the null uuid will be used as the type uuid.

    ManagerEpv - Optionally supplies a manager entry point vector corresponding
        to the type uuid.  If a manager entry point vector is not supplied,
        then the manager entry point vector in the interface will be
        used.

Return Value:

    RPC_S_OK - The specified rpc interface has been successfully
        registered with the rpc server.  It is now ready to accept
        remote procedure calls.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to register
        the rpc interface with the rpc server.

    RPC_S_TYPE_ALREADY_REGISTERED - A manager entry point vector has
        already been registered for the supplied rpc interface and
        manager type UUID.

--*/
{
    RPC_STATUS RpcStatus;
    RPC_INTERFACE * RpcInterface;
    RPC_ADDRESS *RpcAddress ;
    DictionaryCursor cursor;
    BOOL fInterfaceFound;

    if ( ManagerEpv == 0 )
        {

        ManagerEpv = RpcInterfaceInformation->DefaultManagerEpv;

        if ( (PtrToUlong(ManagerEpv)) == 0xFFFFFFFF)
            {
            // Stub compiled with -no_default_epv.
            return (RPC_S_INVALID_ARG);
            }
        }

    ServerMutex.Request();
    RpcInterface = FindOrCreateInterfaceInternal(RpcInterfaceInformation, Flags, MaxCalls,
        MaxRpcSize, IfCallbackFn, &RpcStatus, &fInterfaceFound);
    if (RpcInterface == NULL)
        {
        ServerMutex.Clear();
        return RpcStatus;
        }

    if (fInterfaceFound)
        {
        // if it was found, update the information
        RpcStatus = RpcInterface->UpdateRpcInterfaceInformation(RpcInterfaceInformation,
                                            Flags, MaxCalls, MaxRpcSize, IfCallbackFn);
        if (RpcStatus != RPC_S_OK)
            {
            ServerMutex.Clear();
            return RpcStatus;
            }
        }

    RpcStatus = RpcInterface->RegisterTypeManager(ManagerTypeUuid, ManagerEpv);

    if (Flags & RPC_IF_AUTOLISTEN)
        {

        RpcAddressDictionary.Reset(cursor);
        while ( (RpcAddress = RpcAddressDictionary.Next(cursor)) != 0 )
            {
            RpcStatus = RpcAddress->ServerStartingToListen(
                                       this->MinimumCallThreads,
                                       MaxCalls);
            if (RpcStatus != RPC_S_OK)
                {
                break;
                }
            }
        }

    ServerMutex.Clear();
    return(RpcStatus);
}


void RPC_SERVER::CreateOrUpdateAddresses (void)
/*++
Function Name: CreateOrUpdateAddresses

Parameters:

Description:
    The runtime just received a notification that a new protocol was loaded. We need
    to create an ADDRESS object, listen on it and update the RPCSS bindings
    appropriately.

Returns:

--*/
{
    RPC_STATUS Status;
    RPC_BINDING_VECTOR *BindingVector = 0;
    RPC_INTERFACE * RpcInterface;
    BOOL fChanged = 0;
    RPC_ADDRESS *Address;
    QUEUE tempQueue;
    BOOL fTempQueueHasContents = FALSE;
    int i;
    DictionaryCursor cursor;

    while (1)
        {
        unsigned int Length;

        ServerMutex.Request();
        Address = (RPC_ADDRESS *) RpcDormantAddresses.TakeOffQueue(&Length);
        ServerMutex.Clear();

        if (Address == 0)
            {
            break;
            }

        ASSERT(Length == 0);

        if (Address->RestartAddress(MinimumCallThreads,
                                    MaximumConcurrentCalls) != RPC_S_OK)
            {
            fTempQueueHasContents = TRUE;
            if (tempQueue.PutOnQueue(Address, 0) != 0)
                {
                // putting on the temporary queue failed - out of memory
                // in this case we'd rather cut the PnP process for now, and we'll
                // go with what we have
                // return the address
                ServerMutex.Request();
                // guaranteed to succeed
                RpcDormantAddresses.PutOnQueue(Address, 0);
                ServerMutex.Clear();
                // break into merging the temp queue with the permanent one
                break;
                }
            }
        else
            {
            fChanged = 1;
            }
        }

    if (fTempQueueHasContents)
        {
        ServerMutex.Request();
        // merge back the queues - this should succeed if we have only added protocols. If we have
        // removed protocols, this will fail, and we'll have a bug. Nothing we can do about it here.
        RpcDormantAddresses.MergeWithQueue(&tempQueue);
        ServerMutex.Clear();
        }

    if (fChanged)
        {

        ServerMutex.Request();

        //
        // Inquire the new bindings, and update them in the endpoint mapper
        //
        Status = InquireBindings(&BindingVector);
        if (Status != RPC_S_OK)
            {
            goto Cleanup;
            }

        RpcInterfaceDictionary.Reset(cursor);

        while ((RpcInterface = RpcInterfaceDictionary.Next(cursor)) != 0)
            {
            if (RpcInterface->NeedToUpdateBindings())
                {
                // we know an interface never gets deleted, only marked as
                // unregistered. Therefore, it is safe to release the mutex
                // and do the slow UpdateBindings outside the mutex
                ServerMutex.Clear();
                if ((Status = RpcInterface->UpdateBindings(BindingVector))
                    != RPC_S_OK)
                    {
                    goto Cleanup;
                    }
                ServerMutex.Request();
                }
            }
        ServerMutex.Clear();

        Status = RpcBindingVectorFree(&BindingVector);
        ASSERT(Status == RPC_S_OK);
        }

    return;

Cleanup:
    if (BindingVector)
        {
        Status = RpcBindingVectorFree(&BindingVector);
        ASSERT(Status == RPC_S_OK);
        }
}

// This is an external routine defined in NDR that can be used to
// determine whether a given interface has been compiled with /robust.
extern RPC_STATUS
CheckForRobust (
    IN RPC_SERVER_INTERFACE * pServerIfInfo
    );

RPC_INTERFACE *
RPC_SERVER::FindOrCreateInterfaceInternal (
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation,
    IN unsigned int Flags,
    IN unsigned int MaxCalls,
    IN unsigned int MaxRpcSize,
    IN RPC_IF_CALLBACK_FN PAPI *IfCallbackFn,
    OUT RPC_STATUS *Status,
    OUT BOOL *fInterfaceFound
    )
/*++
Function Name: FindOrCreateInterfaceInternal

Parameters:
    RpcInterfaceInformation
    Flags
    MaxCalls
    MaxRpcSize
    IfCallbackFn
    Status - meaningless if the return value is not NULL.
    fInterfaceFound - TRUE if the interface was found, FALSE if it was created

Description:
    Find or creates an interface with the appropriate parameters

Returns:

--*/
{
    RPC_INTERFACE * RpcInterface;
    DictionaryCursor cursor;

    ServerMutex.VerifyOwned();

    RpcInterface = FindInterface(RpcInterfaceInformation);
    if ( RpcInterface == 0 )
        {
        RpcInterface = new RPC_INTERFACE(RpcInterfaceInformation,
                                         this, Flags, MaxCalls, MaxRpcSize, IfCallbackFn, Status);
        if ( RpcInterface == 0 )
            {
            *Status = RPC_S_OUT_OF_MEMORY;
            return NULL;
            }
        if ( AddInterface(RpcInterface) != 0 )
            {
            delete RpcInterface;
            *Status = RPC_S_OUT_OF_MEMORY;
            return NULL;
            }
        if (Flags & RPC_IF_AUTOLISTEN)
            {
            GlobalRpcServer->IncrementAutoListenInterfaceCount() ;
            }
        *fInterfaceFound = FALSE;
        }
    else
        {
        *fInterfaceFound = TRUE;
        }

    *Status = RPC_S_OK;

    // If we have created a new interface we may need to do some security checks.
    // When RPC verifier is enabled, check to see if this interface is
    // unsecure and whether the server is remotely accessible.
    // Make sure we only check or warn the first time an IF is registered.
    if (gfRPCVerifierEnabledWithBreaks && (*fInterfaceFound == FALSE))
        {
        UUID *IfUuid = &(RpcInterface->InqInterfaceInformation()->InterfaceId.SyntaxGUID);

        // An interface is unsecure when it is registered without a security callback,
        // allows un-authenticated access, and is not exempt.
        // We do not flag COM interfaces registered with RPC_IF_OLE flag because
        // they do their own things.
        if (!RpcInterface->IsSecure() &&
            !(Flags & RPC_IF_OLE) &&
            !IsInterfaceExempt(IfUuid, ALLOW_UNSECURE_REMOTE_ACCESS)
            )
            {
            gfUnsecureInterfaceRegistered = true;

            // If the server is remotely accessible, print a warning, listing
            // the endpoints on which the server is listening.
            if (gfRemoteProtseqRegistered)
                {
                RPC_ADDRESS *Address;

                RPC_VERIFIER_WARNING_MSG("Possible security threat: Server that is remotely accessible is registering an unsecure interface",
                                         RPC_VERIFIER_UNSECURE_IF_REMOTELY_ACCESSIBLE);

                // Print the unsecure IF that is being registred.
                DbgPrint("RPC: Unsecure interface UUID: ");
                PrintUUID(IfUuid);
                DbgPrint("\n");

                // Print the list of remotely accessible endpoints
                // the server is listening on.
                ServerMutex.Request();
                RpcAddressDictionary.Reset(cursor);
                while ((Address = RpcAddressDictionary.Next(cursor)) != 0)
                    {
                    // Check if the address is a remote one.
                    if (RpcpStringCompare(Address->InqRpcProtocolSequence(),
                                          RPC_CONST_STRING("ncalrpc")) != 0)
                        {
                        DbgPrint("RPC: Listening on protseq: %S endpoint: %S\n",
                                 Address->InqRpcProtocolSequence(),
                                 Address->InqEndpoint());
                        }
                    }
                ServerMutex.Clear();

                RPC_VERIFIER_PRINT_OFFENDING_STACK(2, 4);
                }
            }

        // Do not do /robust check for COM interfaces.
        // It will be done on the NDR level during the proxy registration.
        if (!(Flags & RPC_IF_OLE))
            {
            // Check whether the interface has been compiled with /robust switch.
            // We will call into NDR to perform the check.
            if (CheckForRobust(RpcInterface->InqInterfaceInformation()) != RPC_S_OK)
                {
                RPC_VERIFIER_WARNING_MSG("Possible security threat: Server registers an interface compiled without /robust option",
                                         RPC_VERIFIER_REGISTERING_NONROBUST_IF);

                DbgPrint("RPC: Unsecure interface UUID: ");
                PrintUUID(&(RpcInterface->InqInterfaceInformation()->InterfaceId.SyntaxGUID));
                DbgPrint("\n");

                RPC_VERIFIER_PRINT_OFFENDING_STACK(2, 4);
                }
            }
        }

    return RpcInterface;

}


RPC_INTERFACE *
RPC_SERVER::FindOrCreateInterface (
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation,
    OUT RPC_STATUS *Status
    )
{
    RPC_INTERFACE * RpcInterface;
    BOOL fIgnored;

    ServerMutex.Request();
    RpcInterface = FindOrCreateInterfaceInternal(RpcInterfaceInformation,
        RPC_IF_ALLOW_SECURE_ONLY, 0, gMaxRpcSize, NULL, Status, &fIgnored);
    ServerMutex.Clear();

    return RpcInterface;
}


RPC_STATUS
RPC_SERVER::InterfaceExported (
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation,
    IN UUID_VECTOR *MyObjectUuidVector,
    IN unsigned char *MyAnnotation,
    IN BOOL MyfReplace
    )
/*++
Function Name:InterfaceExported

Parameters:

Description:
    RpcEpRegister was called on this interface. We need to keep track
    of the parameters, so that if we get a PNP notification, we can update
    the bindings using there params

Returns:

--*/
{
    RPC_INTERFACE * RpcInterface;
    RPC_STATUS Status;

    RpcInterface = FindOrCreateInterface (RpcInterfaceInformation, &Status);
    if (RpcInterface == NULL)
        {
        return Status;
        }

    return RpcInterface->InterfaceExported(
                                           MyObjectUuidVector,
                                           MyAnnotation,
                                           MyfReplace);
}

#if !defined(NO_LOCATOR_CODE)

RPC_STATUS
RPC_SERVER::NsInterfaceExported (
    IN unsigned long EntryNameSyntax,
    IN RPC_CHAR *EntryName,
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation,
    IN BOOL fUnexport
    )
{
    RPC_INTERFACE * RpcInterface;
    RPC_STATUS Status;
    HMODULE hLocator;

    if (pNsBindingExport == 0)
        {
        hLocator = LoadLibrary ((const RPC_SCHAR *)RPC_CONST_STRING("rpcns4.dll"));
        if (hLocator == 0)
            {
            return RPC_S_OUT_OF_MEMORY;
            }

        pNsBindingExport = (NS_EXPORT_FUNC) GetProcAddress(hLocator,
                                          "RpcNsBindingExportW");
        if (pNsBindingExport == 0)
            {
            return RPC_S_OUT_OF_MEMORY;
            }

        pNsBindingUnexport = (NS_UNEXPORT_FUNC) GetProcAddress(hLocator,
                                            "RpcNsBindingUnexportW");
        if (pNsBindingUnexport == 0)
            {
            pNsBindingExport = 0;
            return RPC_S_OUT_OF_MEMORY;
            }
        }

    RpcInterface = FindOrCreateInterface (RpcInterfaceInformation, &Status);
    if (RpcInterface == NULL)
        {
        return Status;
        }

    if (fUnexport == 0)
        {
        return RpcInterface->NsInterfaceExported(
                                                 EntryNameSyntax,
                                                 EntryName);
        }
    else
        {
        return RpcInterface->NsInterfaceUnexported(
                                                 EntryNameSyntax,
                                                 EntryName);
        }
}
#endif

RPC_STATUS
RPC_SERVER::EnumerateAndCallEachAddress (
    IN AddressCallbackType actType,
    IN OUT void *Context OPTIONAL
    )
/*++
Function Name:  DestroyContextHandlesForInterface

Parameters:
    actType - the type of callback.
    Context - opaque memory block to be passed to the callback.

Description:
    This function is called when we want to invoke a specific method
    on each address.

Returns:
    RPC_S_OK for success or RPC_S_* for error

--*/
{
    RPC_ADDRESS_DICT AddressDict;
    RPC_ADDRESS_DICT *AddressDictToUse;
    RPC_ADDRESS *CurrentAddress;
    BOOL UsingAddressDictionaryCopy;
    int Result;
    DictionaryCursor cursor;
    DestroyContextHandleCallbackContext *ContextHandleContext;

    // try to copy all entries in the address dictionary to the local
    // dictionary. We will walk the address list from there to avoid
    // holding the server mutex while walking potentially large tree.
    // If we do that, only the page faults will be enough to kill the
    // server. On the other hand, we can't rely that the memory will be
    // there. Therefore, we attempt to copy the dictionary under the
    // mutex, but if this fails, we will retain the mutex and go ahead
    // with the cleanup. The logic behind this is that if we don't have
    // the few bytes to copy the dictionary, probably the server isn't
    // doing anything, and holding the mutex won't hurt it anymore

    ServerMutex.Request();

#if DBG
    if (actType == actDestroyContextHandle)
        {
        RPC_INTERFACE *Interface;

        ContextHandleContext = (DestroyContextHandleCallbackContext *)Context;
        Interface = FindInterface(ContextHandleContext->RpcInterfaceInformation);
        ASSERT(Interface);
        // the interface must use strict context handles
        ASSERT(Interface->DoesInterfaceUseNonStrict() == FALSE);
        }
#endif

    UsingAddressDictionaryCopy = AddressDict.ExpandToSize(RpcAddressDictionary.Size());

    if (UsingAddressDictionaryCopy)
        {
        AddressDictToUse = &AddressDict;

        RpcAddressDictionary.Reset(cursor);
        while ( (CurrentAddress = RpcAddressDictionary.Next(cursor)) != 0 )
            {
            // we never destroy addresses. Therefore, we don't need to mark
            // those addresses as used in any way
            Result = AddressDict.Insert(CurrentAddress);
            // this must succeed as we have reserved enough size
            ASSERT(Result != -1);
            }

        ServerMutex.Clear();
        }
    else
        {
        AddressDictToUse = &RpcAddressDictionary;
        }

    // N.B. We may, or may not have the ServerMutex here - depending on how
    // we were doing with memory
    AddressDictToUse->Reset(cursor);
    while ( (CurrentAddress = AddressDictToUse->Next(cursor)) != 0 )
        {
        switch (actType)
            {
            case actDestroyContextHandle:
                ContextHandleContext = (DestroyContextHandleCallbackContext *)Context;
                CurrentAddress->DestroyContextHandlesForInterface(
                    ContextHandleContext->RpcInterfaceInformation,
                    ContextHandleContext->RundownContextHandles
                    );
                break;

            case actCleanupIdleSContext:
                CurrentAddress->CleanupIdleSContexts();
                break;

            default:
                ASSERT(0);
            }
        }

    if (!UsingAddressDictionaryCopy)
        {
        ServerMutex.Clear();
        }

    return RPC_S_OK;
}


RPC_STATUS
RPC_ENTRY
I_RpcNsInterfaceExported (
    IN unsigned long EntryNameSyntax,
    IN unsigned short *EntryName,
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation
    )
{
#if !defined(NO_LOCATOR_CODE)
    InitializeIfNecessary();

    if (gfRPCVerifierEnabledWithBreaks)
        {
        // Locator is an unsafe feature to use.  We should flag it in the verifier.
        RPC_VERIFIER_WARNING_MSG("Possible security threat: Client is using the locator name service",
                                 RPC_VERIFIER_UNSAFE_FEATURE);
        RPC_VERIFIER_PRINT_OFFENDING_STACK(1, 4);
        }

    return (GlobalRpcServer->NsInterfaceExported(
                                                 EntryNameSyntax,
                                                 EntryName,
                                                 RpcInterfaceInformation, 0));
#else
    return RPC_S_CANNOT_SUPPORT;
#endif
}


RPC_STATUS
RPC_ENTRY
I_RpcNsInterfaceUnexported (
    IN unsigned long EntryNameSyntax,
    IN unsigned short *EntryName,
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation
    )
{
#if !defined(NO_LOCATOR_CODE)
    InitializeIfNecessary();

    if (gfRPCVerifierEnabledWithBreaks)
        {
        // Locator is an unsafe feature to use.  We should flag it in the verifier.
        RPC_VERIFIER_WARNING_MSG("Possible security threat: Client is using the locator name service",
                                 RPC_VERIFIER_UNSAFE_FEATURE);
        RPC_VERIFIER_PRINT_OFFENDING_STACK(1, 4);
        }

    return (GlobalRpcServer->NsInterfaceExported(
                                                 EntryNameSyntax,
                                                 EntryName,
                                                 RpcInterfaceInformation, 1));
#else
    return RPC_S_CANNOT_SUPPORT;
#endif
}


#define MAXIMUM_CACHED_THREAD_TIMEOUT (1000L * 60L * 60L)


void
BaseCachedThreadRoutine (
    IN CACHED_THREAD * CachedThread
    )
/*++

Routine Description:

    Each thread will execute this routine.  When it first gets called, it
    will immediately call the procedure and parameter specified in the
    cached thread object.  After that it will wait on its event and then
    execute the specified routine everytime it gets woken up.  If the wait
    on the event times out, the thread will exit unless it has been protected.

Arguments:

    CachedThread - Supplies the cached thread object to be used by this
        thread.

--*/
{
    RPC_SERVER * RpcServer = CachedThread->OwningRpcServer;
    THREAD *pThread = RpcpGetThreadPointer();
    long WaitTimeout;

    ASSERT(pThread);

    while (pThread->ThreadHandle() == (void *) -1)
        {
        Sleep(1);
        }

    ASSERT(pThread->ThreadHandle());

    CachedThread->SetThread(pThread);

    if (pThread->DebugCell)
        {
        pThread->DebugCell->TID = (unsigned short)GetCurrentThreadId();
        pThread->DebugCell->LastUpdateTime = NtGetTickCount();
        }

    for(;;)
        {
        if (CachedThread->CallProcedure())
            {
#ifdef RPC_OLD_IO_PROTECTION
            // This thread has already timed-out waiting on
            // a transport level cache.  Let it go now...
            ASSERT(pThread->InqProtectCount() == 1);
#endif

            if (pThread->IsIOPending() == FALSE)
                {
                delete CachedThread;
                return;
                }

            // we're a cached IOCP thread - we need to unjoin the IOCP
            UnjoinCompletionPort();
            }

        WaitTimeout = gThreadTimeout;

        // Now we cache this thread.  This consists of clearing the
        // work available flag and inserting the thread cache object into
        // the list thread cache objects.

        CachedThread->WorkAvailableFlag = WorkIsNotAvailable;

        RpcServer->ThreadCacheMutex.Request();
        RpcServer->InsertIntoFreeList(CachedThread);
        RpcServer->ThreadCacheMutex.Clear();

        // Now we loop waiting for work.  We get out of the loop in three
        // ways: (1) a timeout occurs and there is work to do, (2) the
        // event gets kicked because there is work to do, (3) a timeout
        // occurs, there is no work to do, and the thread is not protected.

        for (;;)
            {

            // Ignore spurious signals.
            while(      (CachedThread->WaitForWorkEvent.Wait(WaitTimeout) == 0)
                    &&  (CachedThread->WorkAvailableFlag == WorkIsNotAvailable) )
                ;


            if (CachedThread->WorkAvailableFlag == WorkIsAvailable)
                {
                break;
                }

            // We must take the lock to avoid a race condition where another
            // thread is trying to signal us right now.

            RpcServer->ThreadCacheMutex.Request();

            if (CachedThread->WorkAvailableFlag)
                {
                RpcServer->ThreadCacheMutex.Clear();
                break;
                }

            if (pThread->IsIOPending())
                {
                // If we reach here, there is no work available, and the thread
                // is protected.  We just need to wait again. There is no need to
                // busy wait if the thread is protected and it keeps timing out.

                if (WaitTimeout < MAXIMUM_CACHED_THREAD_TIMEOUT/2)
                    {
                    WaitTimeout = WaitTimeout * 2;
                    }

                // Since this thread can't exit anyway, move it to the front of the
                // free list so it will be reused first.

                RpcServer->RemoveFromFreeList(CachedThread);
                RpcServer->InsertIntoFreeList(CachedThread);

                RpcServer->ThreadCacheMutex.Clear();
                continue;
                }

            // No work available.

#ifdef RPC_OLD_IO_PROTECTION
            ASSERT(pThread->InqProtectCount() == 1);
#endif

            // There is no work available, and this thread is not
            // protected, so we can safely let it commit suicide.

            RpcServer->RemoveFromFreeList(CachedThread);
            RpcServer->ThreadCacheMutex.Clear();

            delete CachedThread;
            return;
            }

        ASSERT(CachedThread->WorkAvailableFlag == WorkIsAvailable);

        }

    NO_RETURN;
}

C_ASSERT(ERROR_MAX_THRDS_REACHED == RPC_S_OUT_OF_THREADS);

RPC_STATUS
RPC_SERVER::CreateThread (
    IN THREAD_PROC Procedure,
    IN void * Parameter
    )
/*++

Routine Description:

    This routine is used to create a new thread which will begin
    executing the specified procedure.  The procedure will be passed
    parameter as the argument.

Arguments:

    Procedure - Supplies the procedure which the new thread should
        begin executing.

    Parameter - Supplies the argument to be passed to the procedure.

Return Value:

    RPC_S_OK - We successfully created a new thread and started it
        executing the supplied procedure.

    RPC_S_OUT_OF_THREADS - We could not create another thread.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate
        the data structures we need to complete this operation.

--*/
{
    THREAD * Thread;
    CACHED_THREAD * CachedThread;
    RPC_STATUS RpcStatus = RPC_S_OK;

    ThreadCacheMutex.Request();

    CachedThread = RemoveHeadFromFreeList();
    if (CachedThread)
        {
        // set all parameters within the mutex to avoid races
        CachedThread->SetWakeUpThreadParams(Procedure, Parameter);

        ThreadCacheMutex.Clear();

        CachedThread->WakeUpThread();
        return(RPC_S_OK);
        }

    ThreadCacheMutex.Clear();

    if (IsServerSideDebugInfoEnabled())
        {
        RpcStatus = InitializeServerSideCellHeapIfNecessary();
        if (RpcStatus != RPC_S_OK)
            return RpcStatus;
        }

    CachedThread = new CACHED_THREAD(Procedure, Parameter, this, &RpcStatus);
    if ( CachedThread == 0 )
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    if ( RpcStatus != RPC_S_OK )
        {
        delete CachedThread;
        return(RpcStatus);
        }

    ASSERT( RpcStatus == RPC_S_OK );

    Thread = new THREAD((THREAD_PROC) BaseCachedThreadRoutine, CachedThread,
            &RpcStatus);

    if (Thread == 0)
        {
        delete CachedThread;
        return(RPC_S_OUT_OF_THREADS);
        }

    if (RpcStatus != RPC_S_OK)
        {
        delete CachedThread;
        delete Thread;
        }

    return(RpcStatus);
}



RPC_STATUS
RPC_SERVER::InquireInterfaceIds (
    OUT RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * InterfaceIdVector
    )
/*++

Routine Description:

    This routine is used to obtain a vector of the interface identifiers of
    the interfaces supported by this server.

Arguments:

    IfIdVector - Returns a vector of the interfaces supported by this server.

Return Value:

    RPC_S_OK - Everything worked out just great.

    RPC_S_NO_INTERFACES - No interfaces have been registered with the runtime.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate
        the interface id vector.

--*/
{
    DictionaryCursor cursor;

    ServerMutex.Request();
    if (RpcInterfaceDictionary.Size() == 0)
        {
        ServerMutex.Clear();
        *InterfaceIdVector = 0;
        return RPC_S_NO_INTERFACES;
        }

    *InterfaceIdVector = (RPC_IF_ID_VECTOR __RPC_FAR *) RpcpFarAllocate(
            sizeof(RPC_IF_ID_VECTOR) + (RpcInterfaceDictionary.Size() - 1)
            * sizeof(RPC_IF_ID __RPC_FAR *));
    if ( *InterfaceIdVector == 0 )
        {
        ServerMutex.Clear();
        return(RPC_S_OUT_OF_MEMORY);
        }

    (*InterfaceIdVector)->Count = 0;
    (*InterfaceIdVector)->IfId[0] = (RPC_IF_ID __RPC_FAR *) RpcpFarAllocate(
            sizeof(RPC_IF_ID));
    RpcInterfaceDictionary.Reset(cursor);

    RPC_INTERFACE * RpcInterface;
    while ((RpcInterface = RpcInterfaceDictionary.Next(cursor)) != 0)
        {
        (*InterfaceIdVector)->IfId[(*InterfaceIdVector)->Count] =
                RpcInterface->InquireInterfaceId();
        if ( (*InterfaceIdVector)->IfId[(*InterfaceIdVector)->Count] != 0 )
            {
            RPC_IF_ID * Interface = (*InterfaceIdVector)->IfId[(*InterfaceIdVector)->Count];
            (*InterfaceIdVector)->Count += 1;
            }
        }
    ServerMutex.Clear();

    if (0 == (*InterfaceIdVector)->Count)
        {
        RpcpFarFree(*InterfaceIdVector);
        *InterfaceIdVector = 0;
        return RPC_S_NO_INTERFACES;
        }

    return(RPC_S_OK);
}


RPC_STATUS
RPC_SERVER::InquirePrincipalName (
    IN unsigned long AuthenticationService,
    OUT RPC_CHAR __RPC_FAR * __RPC_FAR * ServerPrincipalName
    )
/*++

Routine Description:

Arguments:

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete the
        operation.

    RPC_S_UNKNOWN_AUTHN_SERVICE - The specified authentication service is
        not supported.

--*/
{
    RPC_AUTHENTICATION * Service;
    DictionaryCursor cursor;

    ServerMutex.Request();
    AuthenticationDictionary.Reset(cursor);
    while ( (Service = AuthenticationDictionary.Next(cursor)) != 0 )
        {
        if ( Service->AuthenticationService == AuthenticationService )
            {
            ServerMutex.Clear();
            *ServerPrincipalName = DuplicateString(
                    Service->ServerPrincipalName);
            if ( *ServerPrincipalName == 0 )
                {
                return(RPC_S_OUT_OF_MEMORY);
                }
            return(RPC_S_OK);
            }
        }

    ServerMutex.Clear();
    return(RPC_S_UNKNOWN_AUTHN_SERVICE);
}



void
RPC_SERVER::RegisterRpcForwardFunction (
       RPC_FORWARD_FUNCTION * pForwardFunction
       )
/*++

Routine Description:
   Sets the RPC_SERVER pEpmapperForwardFunction. (The pEpmapperForwardFunction
   is the function the runtime can call when it receives a pkt for a
   dynamic endpoint. pEpmapperForwardFunction will return endpoint of
   the server to forward the pkt to).

Arguments:
   pForwardFunction - pointer to the epmapper forward function.

Return Value:
   none

--*/
{

   pRpcForwardFunction = pForwardFunction;

}


RPC_STATUS
RPC_SERVER::UnregisterEndpoint (
    IN RPC_CHAR __RPC_FAR * Protseq,
    IN RPC_CHAR __RPC_FAR * Endpoint
    )
{
    return (RPC_S_CANNOT_SUPPORT);
}


RPC_ADDRESS::RPC_ADDRESS (
    IN OUT RPC_STATUS PAPI * RpcStatus
    ) : AddressMutex(RpcStatus,
                     TRUE  // pre-allocate semaphore
                     )
/*++

Routine Description:

    We just need to initialization some stuff to zero.  That way if we
    later have to delete this address because of an error in initialization
    we can tell what instance variables need to be freed.

--*/
{
    NetworkAddress = 0;
    Endpoint = 0;
    RpcProtocolSequence = 0;
}


RPC_ADDRESS::~RPC_ADDRESS (
    )
/*++

Routine Description:

    This routine will only get called if part way through initialization
    an error occurs.  We just need to free up any memory used by instance
    variables.  Once FireUpManager has been called and succeeds, the
    address will never be destroyed.

--*/
{
    if (Endpoint != 0)
        delete Endpoint;
    if (RpcProtocolSequence != 0)
        delete RpcProtocolSequence;
}



RPC_CHAR *
RPC_ADDRESS::GetListNetworkAddress (
    IN unsigned int Index
    )
/*++

Routine Description:

    A pointer to the network address for this address is returned.

--*/
{
    if (Index >= GetNetworkAddressVector()->Count)
        {
        return (NULL);
        }

    return(GetNetworkAddressVector()->NetworkAddresses[Index]);
}


RPC_STATUS
RPC_ADDRESS::CopyDescriptor (
    IN void *SecurityDescriptor,
    OUT void **OutDescriptor
    )
{
   BOOL b;
   SECURITY_DESCRIPTOR_CONTROL    Control;
   DWORD Revision;
   DWORD BufferLength;

   if ( IsValidSecurityDescriptor(SecurityDescriptor) == FALSE )
       {
       return(RPC_S_INVALID_SECURITY_DESC);
       }

   if (FALSE == GetSecurityDescriptorControl(SecurityDescriptor, &Control, &Revision))
       {
       return(RPC_S_INVALID_SECURITY_DESC);
       }

   if (Control & SE_SELF_RELATIVE)
       {
       //
       // Already self-relative, just copy it.
       //

       BufferLength = GetSecurityDescriptorLength(SecurityDescriptor);

       ASSERT(BufferLength >= sizeof(SECURITY_DESCRIPTOR));

       *OutDescriptor = RpcpFarAllocate(BufferLength);
       if (*OutDescriptor == 0)
           {
           return(RPC_S_OUT_OF_MEMORY);
           }

       memcpy(*OutDescriptor, SecurityDescriptor, BufferLength);

       return(RPC_S_OK);
       }

   //
   // Make self-relative and copy it.
   //
   BufferLength = 0;
   b = MakeSelfRelativeSD(SecurityDescriptor, 0, &BufferLength);
   ASSERT(b == FALSE);
   if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
       {
       return(RPC_S_INVALID_SECURITY_DESC);
       }

   ASSERT(BufferLength >= sizeof(SECURITY_DESCRIPTOR_RELATIVE));

   *OutDescriptor = RpcpFarAllocate(BufferLength);

   if (*OutDescriptor == 0)
       {
       return(RPC_S_OUT_OF_MEMORY);
       }

   b = MakeSelfRelativeSD(SecurityDescriptor,
                          *OutDescriptor,
                          &BufferLength);

   if (b == FALSE)
       {
       ASSERT(GetLastError() != ERROR_INSUFFICIENT_BUFFER);
       delete *OutDescriptor;

       return(RPC_S_OUT_OF_MEMORY);
       }

   return(RPC_S_OK);
}


RPC_STATUS
RPC_ADDRESS::SetEndpointAndStuff (
    IN RPC_CHAR PAPI * NetworkAddress,
    IN RPC_CHAR PAPI * Endpoint,
    IN RPC_CHAR PAPI * RpcProtocolSequence,
    IN RPC_SERVER * Server,
    IN unsigned int StaticEndpointFlag,
    IN unsigned int PendingQueueSize,
    IN void PAPI *SecurityDescriptor,
    IN unsigned long EndpointFlags,
    IN unsigned long NICFlags
    )
/*++

Routine Description:

    We just need to set some instance variables of this rpc address.

Arguments:

    Endpoint - Supplies the endpoint for this rpc address.

    RpcProtocolSequence - Supplies the rpc protocol sequence for this
        rpc address.

    Server - Supplies the rpc server which owns this rpc address.

    StaticEndpointFlag - Supplies a flag which specifies whether this
        address has a static endpoint or a dynamic endpoint.

--*/
{
    RPC_STATUS Status;

    this->NetworkAddress = NetworkAddress;
    this->Endpoint = Endpoint;
    this->RpcProtocolSequence = RpcProtocolSequence;
    this->Server = Server;
    this->StaticEndpointFlag = StaticEndpointFlag;
    this->PendingQueueSize = PendingQueueSize;
    this->EndpointFlags = EndpointFlags;
    this->NICFlags = NICFlags;

    if (SecurityDescriptor)
        {
        Status = CopyDescriptor(SecurityDescriptor,
                                &this->SecurityDescriptor);
        if (Status != RPC_S_OK)
            {
            return Status;
            }
        }
    else
        {
        this->SecurityDescriptor = NULL;
        }

    return RPC_S_OK;
}


RPC_STATUS
RPC_ADDRESS::FindInterfaceTransfer (
    IN PRPC_SYNTAX_IDENTIFIER InterfaceIdentifier,
    IN PRPC_SYNTAX_IDENTIFIER ProposedTransferSyntaxes,
    IN unsigned int NumberOfTransferSyntaxes,
    OUT PRPC_SYNTAX_IDENTIFIER AcceptedTransferSyntax,
    OUT RPC_INTERFACE ** RpcInterface,
    OUT BOOL *fIsInterfaceTransferPreferred,
    OUT int *ProposedTransferSyntaxIndex,
    OUT int *AvailableTransferSyntaxIndex
    )
/*++

Routine Description:

    This method is used to determine if a client bind request can be
    accepted or not.  All we have got to do here is hand off to the
    server which owns this address.

Arguments:

    InterfaceIdentifier - Supplies the syntax identifier for the
        interface; this is the interface uuid and version.

    ProposedTransferSyntaxes - Supplies a list of one or more transfer
        syntaxes which the client initiating the binding supports.  The
        server should pick one of these which is supported by the
        interface.

    NumberOfTransferSyntaxes - Supplies the number of transfer syntaxes
        specified in the proposed transfer syntaxes argument.

    AcceptedTransferSyntax - Returns the transfer syntax which the
        server accepted.

    RpcInterface - Returns a pointer to the rpc interface found which
        supports the requested interface and one of the requested transfer
        syntaxes.

Return Value:

    RPC_S_OK - The requested interface exists and it supports at least
        one of the proposed transfer syntaxes.  We are all set, now we
        can make remote procedure calls.

    RPC_P_UNSUPPORTED_TRANSFER_SYNTAX - The requested interface exists,
        but it does not support any of the proposed transfer syntaxes.

    RPC_P_UNSUPPORTED_INTERFACE - The requested interface is not supported
        by this rpc server.

--*/
{
    return Server->FindInterfaceTransfer(
                                         InterfaceIdentifier,
                                         ProposedTransferSyntaxes,
                                         NumberOfTransferSyntaxes,
                                         AcceptedTransferSyntax,
                                         RpcInterface,
                                         fIsInterfaceTransferPreferred,
                                         ProposedTransferSyntaxIndex,
                                         AvailableTransferSyntaxIndex);
}


BINDING_HANDLE *
RPC_ADDRESS::InquireBinding (
    RPC_CHAR * LocalNetworkAddress
    )
/*++

Routine Description:

    We need to return create and return a binding handle which can
    be used by a client to make remote procedure calls to this rpc
    address.

Return Value:

    A newly created binding handle will be returned, inless an out
    of memory error occurs, in which case zero will be returned.

--*/
{
    RPC_STATUS Status;
    DCE_BINDING * DceBinding;
    BINDING_HANDLE * BindingHandle;
    RPC_CHAR * DynamicEndpoint = 0;
    RPC_CHAR * PAPI * tmpPtr;

    if(LocalNetworkAddress == 0)
        {
        ASSERT(GetNetworkAddressVector()->Count > 0);
        LocalNetworkAddress = GetNetworkAddressVector()->NetworkAddresses[0];
        }

    DceBinding = new DCE_BINDING(
                                 0,
                                 RpcProtocolSequence,
                                 LocalNetworkAddress,
                                 (StaticEndpointFlag != 0 ? Endpoint : 0),
                                 0,
                                 &Status);
    if ((DceBinding == 0)
        || (Status != RPC_S_OK))
        {
        delete DceBinding;
        return(0);
        }

    if (StaticEndpointFlag == 0)
        {
        DynamicEndpoint = DuplicateString(Endpoint);
        if (DynamicEndpoint == 0)
            {
            delete DceBinding;
            return(0);
            }
        }

    BindingHandle = new SVR_BINDING_HANDLE(DceBinding, DynamicEndpoint, &Status);
    if (BindingHandle == 0)
        {
        delete DceBinding;
        }

    return(BindingHandle);
}


RPC_STATUS
RPC_ADDRESS::ServerStartingToListen (
    IN unsigned int MinimumCallThreads,
    IN unsigned int MaximumConcurrentCalls
    )
/*++

Routine Description:

    This method will be called for each address when the server starts
    listening.  In addition, if an address is added while the server is
    listening, then this method will be called.  The purpose of the method
    is to notify the address about the minimum number of call threads
    required; the maximum concurrent calls can safely be ignored, but it
    can be used to set an upper bound on the number of call threads.

Arguments:

    MinimumCallThreads - Supplies a number indicating the minimum number
        of call threads which should be created for this address.

    MaximumConcurrentCalls - Supplies the maximum number of concurrent
        calls which this server will support.

Return Value:

    RPC_S_OK - This routine will always return this value.  Protocol
        support modules may return other values.

--*/
{
    UNUSED(MinimumCallThreads);
    UNUSED(MaximumConcurrentCalls);

    return(RPC_S_OK);
}


void
RPC_ADDRESS::ServerStoppedListening (
    )
/*++

Routine Description:

    This routine will be called to notify an address that the server has
    stopped listening for remote procedure calls.  Each protocol module
    may override this routine; it is safe not too, but not as efficient.
    Note that this routine will be called before all calls using the
    server have been allowed to complete.

--*/
{
}

RPC_STATUS
RPC_ADDRESS::SameProtocolSequenceAndSD (
    IN RPC_CHAR PAPI * NetworkAddress,
    IN RPC_CHAR PAPI * ProtocolSequence,
    IN SECURITY_DESCRIPTOR *SecurityDescriptor OPTIONAL,
    OUT BOOL *IsEqual
    )
/*++

Routine Description:

    This routine is used to determine if the rpc address has the same
    protocol sequence as the protocol sequence
    supplied as the argument.

Arguments:

    NetworkAddress - the server address on which the server listens

    ProtocolSequence - Supplies the protocol sequence to compare against
        the protocol sequence of this address.

    SecurityDescriptor - optional security descriptor to compare against

    IsEqual - on output will contain non-zero if this address and the supplied 
        protocol sequence and security descriptor are the same. Otherwise, zero 
        will be returned in this argument. Undefined on failure.

Return Value:

    Non-zero will be returned if this address and the supplied endpoint and
    protocol sequence are the same, otherwise, zero will be returned.

--*/
{
    RPC_CHAR *SecurityDescriptor1String;
    RPC_CHAR *SecurityDescriptor2String;
    BOOL Res;
    ULONG LastError;

    // assume not equal for now
    *IsEqual = FALSE;

    // figure out the network address first.
    if (NetworkAddress == NULL)
        {
        if (this->NetworkAddress != NULL)
            return RPC_S_OK;
        }
    else
        {
        if (this->NetworkAddress == NULL)
            return RPC_S_OK;

        if (RpcpStringCompare(this->NetworkAddress, NetworkAddress))
            return RPC_S_OK;
        }

    // figure out the protocol sequence. It cannot be empty here
    ASSERT(ProtocolSequence != NULL);
    if (RpcpStringCompare(this->RpcProtocolSequence, ProtocolSequence))
            return RPC_S_OK;

    if (SecurityDescriptor == NULL)
        {
        if (this->SecurityDescriptor != NULL)
            return RPC_S_OK;
        }
    else
        {
        if (this->SecurityDescriptor == NULL)
            return RPC_S_OK;

        // compare the two security descriptors. Convert them to strings for 
        // the sake of comparison
        Res = ConvertSecurityDescriptorToStringSecurityDescriptor (SecurityDescriptor,
            SDDL_REVISION_1,
            OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION,
            &SecurityDescriptor1String,
            NULL        // StringSecurityDescriptorLen
            );

        if (Res == FALSE)
            {
            LastError = GetLastError();
            ASSERT(LastError != ERROR_INVALID_PARAMETER
                && LastError != ERROR_UNKNOWN_REVISION
                && LastError != ERROR_INVALID_ACL
                && LastError != ERROR_NONE_MAPPED );
        
#if DBG
            DbgPrint("%d: Could not convert security descriptor to string: %X\n", GetCurrentProcessId(),
                LastError);
#endif  // DBG
            
            return RPC_S_OUT_OF_MEMORY;
            }

        Res = ConvertSecurityDescriptorToStringSecurityDescriptor (this->SecurityDescriptor,
            SDDL_REVISION_1,
            OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION,
            &SecurityDescriptor2String,
            NULL        // StringSecurityDescriptorLen
            );

        if (Res == FALSE)
            {
            LastError = GetLastError();
            ASSERT(LastError != ERROR_INVALID_PARAMETER
                && LastError != ERROR_UNKNOWN_REVISION
                && LastError != ERROR_INVALID_ACL
                && LastError != ERROR_NONE_MAPPED );

            LocalFree(SecurityDescriptor1String);
            
#if DBG
            DbgPrint("%d: Could not convert security descriptor to string: %X\n", GetCurrentProcessId(),
                LastError);
#endif  // DBG
            
            return RPC_S_OUT_OF_MEMORY;
            }

        // both security descriptors are available as strings. Compare the strings and free them
        if (RpcpStringCompare(SecurityDescriptor1String, SecurityDescriptor2String) == 0)
            *IsEqual = TRUE;

        LocalFree(SecurityDescriptor1String);
        LocalFree(SecurityDescriptor2String);

        return RPC_S_OK;
        }

    // all elements match - return match
    *IsEqual = TRUE;
    return RPC_S_OK;
}


long
RPC_ADDRESS::InqNumberOfActiveCalls (
    )
/*++

Return Value:

    Each protocol module will define this routine.  We will use this
    functionality when the server has stopped listening and is waiting
    for all remote procedure calls to complete.  The number of active calls
    for the address will be returned.

--*/
{
    return(ActiveCallCount);
}


RPC_STATUS
RPC_ADDRESS::RestartAddress (
    IN unsigned int MinThreads,
    IN unsigned int MaxCalls
    )
{
    RPC_STATUS Status;
    int Key;

    Status = ServerSetupAddress(
                                NetworkAddress,
                                &Endpoint,
                                PendingQueueSize,
                                SecurityDescriptor,
                                EndpointFlags,
                                NICFlags);
    if (Status != RPC_S_OK)
        {
        return Status;
        }


    Key = Server->AddAddress(this);
    if (Key == -1)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    Server->ServerMutex.Request();
    Status = ServerStartingToListen(MinThreads, MaxCalls);
    Server->ServerMutex.Clear();


    if (Status != RPC_S_OK)
        {
        return Status;
        }

    CompleteListen();

    return RPC_S_OK;
}

void
RPC_ADDRESS::DestroyContextHandlesForInterface (
    IN RPC_SERVER_INTERFACE PAPI * ,
    IN BOOL
    )
/*++
Function Name:  DestroyContextHandlesForInterface

Parameters:
    RpcInterfaceInformation - the interface for which context handles
        are to be unregistered
    RundownContextHandles - if non-zero, rundown the context handles. If
        FALSE, destroy the runtime portion of the context handle resource,
        but don't call the user rundown routine.

Description:
    Each protocol engine will implement its own version of this routine,
    if it supports the feature. For those who don't, this routine provides
    default no-op behaviour

Returns:

--*/
{
}

void
RPC_ADDRESS::CleanupIdleSContexts (
    void
    )
/*++
Function Name:  CleanupIdleSContexts

Parameters:

Description:
    Each protocol engine will implement its own version of this routine,
    if it supports the feature. For those who don't, this routine provides
    default no-op behaviour

Returns:

--*/
{
}

NETWORK_ADDRESS_VECTOR *
RPC_ADDRESS::GetNetworkAddressVector (
    void
    )
/*++
Function Name:  GetNetworkAddressVector

Parameters:

Description:
    Each protocol engine will implement its own version of this routine
    It will return the vector of network addresses listened-on by this address object.

--*/
{
    ASSERT(0);
    return NULL;
}


/*====================================================================

SCONNECTION

==================================================================== */

RPC_STATUS
SetThreadSecurityContext(
    SECURITY_CONTEXT * Context
    )
/*++

Routine Description:

    RpcImpersonateClient() takes a handle_t, so many threads can impersonate
    the client of a single SCONNECTION.  RPC needs to record which context
    each thread is using.  It is logical to place this in the TLS, but threads
    not created by RPC lack the THREAD structure in their TLS.  This wrapper
    function will store the security context in the TLS if available, or
    place the context in a dictionary if not.

Arguments:

    Context - the security context to associate with this thread

Return Value:

    RPC_S_OK if successful
    RPC_S_OUT_OF_MEMORY if the dictionary insertion failed

--*/

{
    THREAD * ThreadInfo = ThreadSelf();

    if (ThreadInfo)
        {
        ThreadInfo->SecurityContext = Context;
        return RPC_S_OK;
        }

    return RPC_S_OUT_OF_MEMORY;
}

SECURITY_CONTEXT *
QueryThreadSecurityContext(
    )
/*++

Routine Description:

    Fetches the security context associated with this thread for this
    connection.  We check the TLS if available; if nothing is there
    then we scan the connection's dictionary.

Arguments:

    none

Return Value:

    the associated security context, or zero if none is found

--*/
{
    THREAD * ThreadInfo = ThreadSelf();

    if (ThreadInfo)
        {
        if (ThreadInfo->SecurityContext)
            {
            return (SECURITY_CONTEXT *) ThreadInfo->SecurityContext;
            }
        }

    return 0;
}

SECURITY_CONTEXT *
ClearThreadSecurityContext(
    )
/*++

Routine Description:

    Clears the association between this thread and its security context
    for this connection.

Arguments:

    none

Return Value:

    the formerly associated security context, or zero if none was found

--*/
{
    THREAD * ThreadInfo = ThreadSelf();

    if (ThreadInfo)
        {
        SECURITY_CONTEXT * Context =
            (SECURITY_CONTEXT *) ThreadInfo->SecurityContext;

        if (Context)
            {
            ThreadInfo->SecurityContext = 0;
            return Context;
            }
        }

    return 0;
}

typedef union {
    struct {
        USHORT Count;
        USHORT Order;
        } s;
    ULONG Value;
} DTAG, *PDTAG;

USHORT
UpdateTargetResource(
    IN volatile long *Target,
    IN USHORT CurrentOrder
    )
/*++

Routine Description:

    Helper used by AcquireDeadlockProtection.  The logic is as follows:

    If the Target is not owned (Target Count == 0)
        Set the Target Order to CurrentOrder + 1
        Increment the Target Count
    Else (The Target is currently owned)
        If the CurrentOrder is greater than the Target Order
            return 0 (no change to Target)
        Else (The CurrentOrder is not greater than the Target Order)
            Increment the Target Count
            
Arguments:

    Target - Pointer to the tag which is to be updated.

    CurrentOrder - This value is the Order value of the last resource
                   acquired by the caller in the chain of resources.
                   The Target, if unowned (that is Count == 0), will
                   have its Order set to CurrentOrder + 1;
                   
Return Value:

    If the Target is successfully updated, then the return value is the value
    of Target Order.  If a possible deadlock was detected or if an internal field
    has wrapped (the Count or Order), the return value is zero.
   
--*/  
{
    DTAG Update;
    ULONG LocalTag;
    
    do {
        LocalTag = *Target;
        Update.Value = LocalTag;
        if (Update.s.Count == 0){
            // We are the first one to tag him, so he gets our Order
            Update.s.Order = CurrentOrder+1;
            }
        else if (Update.s.Order <= CurrentOrder) {
            // The resource is already taged, and its order is not higher than ours,
            // so deadlock is possible, return 0.
            return 0;
            }        
        
        Update.s.Count++;
        
        if ((Update.s.Order == 0) || (Update.s.Count == 0)){
            // One or both of the values have wrapped, we must fail this opperation.
            return 0;
            }        
    } while(LocalTag != InterlockedCompareExchange(Target, Update.Value, LocalTag));

    return Update.s.Order;
}

BOOL
AcquireDeadlockProtection(
    IN BOOL FirstCall,
    IN volatile long *PrevTarget,
    IN volatile long *Target
    )
/*++

Routine Description:

    One way to prevent deadlock is to follow a lock hierarchy.  The set of resources
    which may be acquired are ordered and anyone who attempts to acquire multiple
    resources must acquire them in order.

    In the case of context handles, the user can impose there own lock hierarchy to
    avoid deadlock among multiple calls with each call possibly using multiple context
    handles.  A malicious user may intentionally break this lock hierarchy, resulting
    in deadlocked server threads.

    This API provides a way to detect if waiting on a particular resource may possibly
    result in deadlock.  Whenever you want to take a lock on the resource, you first
    pass in the tag for the previous resource you have taken and the tag for the resource
    you would like to take.  The tag fields are used to dynamically generate a lock 
    hierarchy based on the order in which locks are actually being acquired.  If its safe
    to wait on the resource, AcquireDeadlockProtection will return TRUE.  Otherwise
    it will return FALSE and you should release all the resources you have taken.

    Most of the logic for this algorithm is in UpdateTargetResource.  
    
                
Arguments:

    FirstCall - TRUE indicates that this is the first call to AcquireDeadlockProtection
                for the set of resources the user is interested in acquiring.  Typically,
                when the user wishes to lock the second resource in the set, they call
                AcquireDeadlockProtection for the first time, with FirstCall set to TRUE.
                
    PrevTarget - Pointer to the tag of the previously locked resource.  

    Target - Pointer to the tag of the resource which the caller would like to
             wait on. This function determines if it is safe to wait on this resource.
                
                   
Return Value:

    If the resource can be acquired without a deadlock occurring, the return
    value is TRUE.
--*/  
{
    USHORT PrevOrder;
    if (FirstCall){
        PrevOrder = UpdateTargetResource(PrevTarget, 0);
        }
    else {
        PrevOrder = ((PDTAG)PrevTarget)->s.Order;
        }

    if (PrevOrder == 0){
        // We must be overflowing one of the internal fields,
        // this means we have not successfully protected
        // this resource and the caller should not lock it.
        return FALSE;
        }
    
    return (BOOL) UpdateTargetResource(Target, PrevOrder);
}

void
ReleaseDeadlockProtection(
    IN volatile long *Target
    )
/*++

Routine Description:

    This function is called before the lock on a resource has been released.  It must
    be called once for every Target which has had AcquireDeadlockProtection succesfully
    called on it.  Also, it must be called on the first Target if any calls to 
    AcquireDeadlockProtection, regardless of success of failure.  
    
Arguments:

    Target - A pointer to the tag of the resource which the caller will be releasing.                              
   
--*/  
{
    DTAG DeadlockUpdate;
    ULONG LocalDeadlockTag;

    do {
        LocalDeadlockTag = *Target;
        DeadlockUpdate.Value = LocalDeadlockTag;
        if (DeadlockUpdate.s.Count == 0){
            // The count is already zero, there is nothing for us to do.
            return;
            }
        DeadlockUpdate.s.Count--;
    } while(LocalDeadlockTag != InterlockedCompareExchange(Target, DeadlockUpdate.Value, LocalDeadlockTag));   
}


RPC_STATUS
SCALL::AddToActiveContextHandles (
    ServerContextHandle *ContextHandle
    )
/*++

Routine Description:

    Adds a context handle to the dictionary of active context handles
    for this call.

    Note:  Context handles are added to a SIMPLE_DICT based collection.
           Currently, the SIMPLE_DICT will be corrupted if you add
           more than MAX_ULONG elements to it (its internal size will wrap).
           This code does not provide any protection against wrapping the
           dictionary.  

    Note:  We make the following assumptions about the behavior of the
           SIMPLE_DICT (ActiveContextHandles) in this routine.

           1) The key of the first item added to the dictionary is always 0.
           2) If items are only Inserted, then the key increases by one for each
              subsequent item.  This means that the item Inserted previously to 
              'Find(key)' would be 'Find(key-1)'.
              
Arguments:

    ContextHandle - the context handle to add to the dictionary

Return Value:

    RPC_S_OK - For anything but OK, the handle will not be present
               in the ActiveContextHandles dictionary.
    RPC_S_OUT_OF_MEMORY 
    RPC_S_XX_CONTEXT_MISMATCH - Indicates the context handle cannot
    be locked because a deadlock may occur.  
--*/
{
    unsigned int Key;
    Key = ActiveContextHandles.Insert(ContextHandle);
    
    if (Key == -1)
        return RPC_S_OUT_OF_MEMORY;

    if ( Key &&
         (((ULONG_PTR)ContextHandle & SCALL::DictionaryEntryIsBuffer) == 0)
        ){
        // We are adding a non-first context handle (not a newly created buffer)
        // to the dictionary, we need to check for deadlock
        
        BOOL SafeToLock = FALSE;

        if (!IsMultiContextHandleCall){
            IsMultiContextHandleCall = TRUE;
            }
        
        ServerContextHandle *PrevHandle = ActiveContextHandles.Find(Key-1);        

        SafeToLock = AcquireDeadlockProtection(
                            (Key == 1),
                            &(PrevHandle->DeadlockTag),
                            &(ContextHandle->DeadlockTag)
                            );
        if (!SafeToLock){
            // This will help catch possible false positives.
            CORRUPTION_ASSERT(0);
            ActiveContextHandles.Delete(Key);
            return RPC_X_SS_CONTEXT_MISMATCH;
            }
        }

    return RPC_S_OK;
}

ServerContextHandle *
SCALL::RemoveFromActiveContextHandles (
    ServerContextHandle *ContextHandle
    )
/*++

Routine Description:

    Removes a context handle from the active context handle
    dictionary. If the context handle is not there, this is
    just a no-op

Arguments:

    ContextHandle - the context handle to remove from the dictionary

Return Value:
    NULL if the context handle is not found. The context handle if it
    is found

--*/
{
    // We should not call RemoveFromActiveContextHandles on a buffer
    ASSERT (((ULONG_PTR)ContextHandle & SCALL::DictionaryEntryIsBuffer) == 0);
    
    ServerContextHandle* RemovedHandle = (ServerContextHandle*) ActiveContextHandles.DeleteItemByBruteForce(ContextHandle);

    if (RemovedHandle && IsMultiContextHandleCall)
        {    
        ReleaseDeadlockProtection(&(RemovedHandle->DeadlockTag));

        if (ActiveContextHandles.Size() == 0){
            IsMultiContextHandleCall = FALSE;
            }
        }

    return RemovedHandle;
}
    
RPC_STATUS
SCALL::ImpersonateClient (
    )
// This routine just returns RPC_CANNOT_SUPPORT indicating that this
// particular connection does not support impersonation.
{

    ASSERT(0 && "improper SCALL member called\n");
    return(RPC_S_CANNOT_SUPPORT);
}

RPC_STATUS
SCALL::RevertToSelf (
    )
// We always return RPC_CANNOT_SUPPORT indicating that the particular
// connection does not support impersonation.
{

    ASSERT(0 && "improper SCALL member called\n");
    return(RPC_S_CANNOT_SUPPORT);
}

void
NDRSContextHandlePostDispatchProcessing (
    IN SCALL *SCall,
    ServerContextHandle *CtxHandle
    );

void
SCALL::DoPostDispatchProcessing (
    void
    )
{
    DictionaryCursor cursor;
    ServerContextHandle *CtxHandle;
    ServerContextHandle *RetrievedCtxHandle;
    unsigned int Key;

    // the list will contain all in-only context
    // handles, as they don't get marshalled. It will also
    // contain the marshalling buffers for the newly
    // created context handles
    if (ActiveContextHandles.Size() > 0)
        {
        // no need to synchronize access to the
        // dictionary - only this call will be
        // touching it
        ActiveContextHandles.Reset(cursor);
        while ((CtxHandle = ActiveContextHandles.NextWithKey(cursor, &Key)) != 0)
            {
            // ignore buffers
            if ((ULONG_PTR)CtxHandle & SCALL::DictionaryEntryIsBuffer)
                {
                RetrievedCtxHandle = ActiveContextHandles.Delete(Key);
                ASSERT(RetrievedCtxHandle == CtxHandle);
                continue;
                }

            // NDRSContextHandlePostDispatchProcessing will remove the context handle
            // from the dictionary - this doesn't interfere with our
            // enumeration
            NDRSContextHandlePostDispatchProcessing(this,
                CtxHandle
                );
            }

        }
}


RPC_STATUS
SCONNECTION::IsClientLocal (
    OUT unsigned int PAPI * ClientLocalFlag
    )
/*++

Routine Description:

    The connection oriented protocol module will override this method;
    all other protocol modules should just use this routine.  We need this
    support so that the security system can tell if a client is local or
    remote.

Arguments:

    ClientLocalFlag - Returns an indication of whether or not the client is
        local (ie. on the same machine as the server).  This field will be
        set to a non-zero value to indicate that the client is local;
        otherwise, the client is remote.

Return Value:

    RPC_S_CANNOT_SUPPORT - This will always be used.

--*/
{
    UNUSED(ClientLocalFlag);

    ASSERT(0 && "improper SCALL member called\n");
    return(RPC_S_CANNOT_SUPPORT);
}

RPC_STATUS
SCALL::CreateAndSaveAuthzContextFromToken (
    IN OUT PAUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContextPlaceholder OPTIONAL,
    IN HANDLE ImpersonationToken,
    IN AUTHZ_RESOURCE_MANAGER_HANDLE AuthzResourceManager,
    IN PLARGE_INTEGER pExpirationTime OPTIONAL,
    IN LUID Identifier,
    IN DWORD Flags,
    IN PVOID DynamicGroupArgs OPTIONAL,
    OUT PAUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext
    )
/*++

Routine Description:

    Creates an Authz context from token. If saving is requested, it
    tries to save it in a thread-safe manner and duplicates it before
    returning. If saving is not requested, the resulting authz context
    is simply returned. In both cases caller owns the returned auth
    context.

Arguments:

    pAuthzClientContextPlaceholder - contains a pointer to an authz placeholder.
        If NULL, out of the ImpersonationToken an authz context will
        be made and will be returned. If non-NULL, it must contain
        NULL. In this case an authz context will be created from the token,
        and it will be stored in the placeholder in a thread safe manner and a
        duplicate will be made and returned in pAuthzClientContext.
    ImpersonationToken - the impersonation token to use.
    AuthzResourceManager - authz parameters (not interpreted)
    pExpirationTime - authz parameters (not interpreted)
    Identifier - authz parameters (not interpreted)
    Flags - authz parameters (not interpreted)
    DynamicGroupArgs - authz parameters (not interpreted)
    pAuthzClientContext - contains the output authz context on success

Return Value:

    Win32 error code. EEInfo has been added.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    BOOL Result;
    AUTHZ_CLIENT_CONTEXT_HANDLE AuthzClientContext;

    Result = AuthzInitializeContextFromTokenFn(
        Flags,
        ImpersonationToken,
        AuthzResourceManager,
        pExpirationTime,
        Identifier,
        DynamicGroupArgs,
        &AuthzClientContext);

    if (!Result)
        {
        Status = GetLastError();

        RpcpErrorAddRecord(EEInfoGCAuthz,
            Status,
            EEInfoDLSCALL__CreateAndSaveAuthzContextFromToken10,
            GetCurrentThreadId(),
            (ULONGLONG)AuthzResourceManager);

        return Status;
        }

    if (pAuthzClientContextPlaceholder)
        {
        if (InterlockedCompareExchangePointer((PVOID *)pAuthzClientContextPlaceholder,
            AuthzClientContext,
            NULL) != NULL)
            {
            // somebody beat us to the punch - free the context we obtained
            AuthzFreeContextFn(AuthzClientContext);
            // use the context that has been provided
            AuthzClientContext = *pAuthzClientContextPlaceholder;
            }

        Status = DuplicateAuthzContext(AuthzClientContext,
            pExpirationTime,
            Identifier,
            Flags,
            DynamicGroupArgs,
            pAuthzClientContext);

        if (Status)
            {
            // EEInfo has already been added
            return Status;
            }
        }
    else
        {
        *pAuthzClientContext = AuthzClientContext;
        }

    return Status;
}

RPC_STATUS
SCALL::DuplicateAuthzContext (
    IN AUTHZ_CLIENT_CONTEXT_HANDLE AuthzClientContext,
    IN PLARGE_INTEGER pExpirationTime OPTIONAL,
    IN LUID Identifier,
    IN DWORD Flags,
    IN PVOID DynamicGroupArgs OPTIONAL,
    OUT PAUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext
    )
/*++

Routine Description:

    Take an Authz context, and make a duplicate of it, using the
    specified parameters. This method is a wrapper for
    AuthzInitializeContextFromContext, mainly adding error handling.

Arguments:

    AuthzClientContext - source authz context
    pExpirationTime - authz parameters (not interpreted)
    Identifier - authz parameters (not interpreted)
    Flags - authz parameters (not interpreted)
    DynamicGroupArgs - authz parameters (not interpreted)
    pAuthzClientContext - target authz context pointer

Return Value:

    Win32 error code.

--*/
{
    RPC_STATUS Status;
    BOOL Result;

    // Copy the authz context. We must do a copy,
    // to avoid lifetime issues b/n our copy
    // and the client copy
    Result = AuthzInitializeContextFromAuthzContextFn(
        Flags,
        AuthzClientContext,
        pExpirationTime,
        Identifier,
        DynamicGroupArgs,
        pAuthzClientContext);

    if (!Result)
        {
        Status = GetLastError();

        RpcpErrorAddRecord(EEInfoGCAuthz,
            Status,
            EEInfoDLSCALL__DuplicateAuthzContext10,
            GetCurrentThreadId(),
            (ULONGLONG)AuthzClientContext);
        }
    else
        Status = RPC_S_OK;

    return Status;
}

/* ====================================================================

ASSOCIATION_HANDLE :

==================================================================== */

static long AssociationIdCount = 0L;

void
DestroyContextCollection (
    IN ContextCollection *CtxCollection
    );

ASSOCIATION_HANDLE::ASSOCIATION_HANDLE (
    void
    )
{
    CtxCollection = NULL;
    AssociationID = InterlockedIncrement(&AssociationIdCount);
}

ASSOCIATION_HANDLE::~ASSOCIATION_HANDLE (
    )
// We finally get to use the rundown routines for somethings.  The association
// is being deleted which is the event that the rundown routines were waiting
// for.
{
    FireRundown();
}

// Returns the context handle collection for this association.
RPC_STATUS
ASSOCIATION_HANDLE::GetAssociationContextCollection (
    ContextCollection **CtxCollectionPlaceholder
    )
/*++
Function Name:  GetAssociationContextCollection

Parameters:
    CtxCollectionPlaceholder - a placeholder where to put the pointer to
        the context collection.

Description:
    The context handle code will call the SCALL to get the collection
    of context handles for this association. The SCALL method will
    simply delegate to this.
    This routine will check if the context handle collection was created
    and if so, it will just return it. If it wasn't created, it will try
    to create it.

Returns:
    RPC_S_OK for success or RPC_S_* for error.

--*/
{
    RPC_STATUS RpcStatus;

    if (CtxCollection)
        {
        *CtxCollectionPlaceholder = CtxCollection;
        return RPC_S_OK;
        }

    RpcStatus = NDRSContextInitializeCollection(&CtxCollection);
    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    *CtxCollectionPlaceholder = CtxCollection;
    return RpcStatus;
}

void
ASSOCIATION_HANDLE::FireRundown (
    void
    )
{
    int nRetries = 20;
    RPC_STATUS status;

    if (CtxCollection)
        {
        // make a best effort to make sure there is another listening thread
        // besides this one. If we repeatedly fail, we fire the rundown
        // anyway - currently few servers use outgoing RPC callbacks into the
        // same process, so we'd rather risk an unlikely deadlock than cause
        // a sure leak
        while (nRetries > 0)
            {
            status = CreateThread();
            if (status == RPC_S_OK)
                break;
            Sleep(10);
            nRetries --;
            }
        DestroyContextCollection(CtxCollection);
        if (status == RPC_S_OK)
            RundownNotificationCompleted();
        }
}

// do nothing in the base case
RPC_STATUS ASSOCIATION_HANDLE::CreateThread(void)
{
    return RPC_S_OK;
}

void ASSOCIATION_HANDLE::RundownNotificationCompleted(void)
{
}

void
ASSOCIATION_HANDLE::DestroyContextHandlesForInterface (
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation,
    IN BOOL RundownContextHandles
    )
/*++
Function Name:  DestroyContextHandlesForInterface

Parameters:
    RpcInterfaceInformation - the interface for which context handles
        are to be unregistered
    RundownContextHandles - if non-zero, rundown the context handles. If
        FALSE, destroy the runtime portion of the context handle resource,
        but don't call the user rundown routine.

Description:
    The association will call into NDR to destroy the specified context
    handles. It will either have a reference on the association, or the
    association mutex. Both ways, we're safe from destruction, and NDR
    will synchronize access to the list internally. The address has made
    a best effort not to hold the association mutex. If memory is low,
    it may end up doing so, however.

Returns:

--*/
{
    ContextCollection *LocalCtxCollection;
    void *pGuard;

    // N.B. An association mutex may be held on entry for this
    // function. The server mutex may be held as well

    LocalCtxCollection = CtxCollection;

    // shortcut the common path
    if (!LocalCtxCollection)
        return;

    pGuard = &RpcInterfaceInformation->InterfaceId;

    // call into NDR to destroy the context handles
    DestroyContextHandlesForGuard(LocalCtxCollection,
        RundownContextHandles,
        pGuard);
}

/* ====================================================================

Routine to initialize the server DLL.

==================================================================== */

int
InitializeServerDLL (
    )
{
    GetMaxRpcSizeAndThreadPoolParameters();

    if (InitializeClientDLL() != 0)
        return(1);

    if (InitializeObjectDictionary() != 0)
        return(1);

    if (InitializeRpcServer() != 0)
        return(1);

    if (InitializeRpcProtocolLrpc() != 0)
        return(1);

    return(0);
}

#if DBG
void
RpcpInterfaceForCallDoesNotUseStrict (
    IN RPC_BINDING_HANDLE BindingHandle
    )
{
    SCALL *SCall;

    if (((MESSAGE_OBJECT *)BindingHandle)->Type(SCALL_TYPE))
        {
        SCall = (SCALL *)BindingHandle;
        SCall->InterfaceForCallDoesNotUseStrict();
        }
}
#endif

RPC_STATUS
InqLocalConnAddress (
    IN SCALL *SCall,
    IN OUT void *Buffer,
    IN OUT unsigned long *BufferSize,
    OUT unsigned long *AddressFormat
    )
/*++

Routine Description:

    This routine is used by a server application to inquire about the local
    address on which a call is made.

Arguments:

    Binding - Supplies a valid server binding. The binding must have been
        verified to be an SCALL by the caller.

    Buffer - The buffer that will receive the output address

    BufferSize - the size of the supplied Buffer on input. On output the
        number of bytes written to the buffer. If the buffer is too small
        to receive all the output data, ERROR_MORE_DATA is returned,
        nothing is written to the buffer, and BufferSize is set to
        the size of the buffer needed to return all the data.

    AddressFormat - a constant indicating the format of the returned address.
        Currently supported are RPC_P_ADDR_FORMAT_TCP_IPV4 and
        RPC_P_ADDR_FORMAT_TCP_IPV6.

Return Values:

    RPC_S_OK - success.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete this
        operation.

    RPC_S_INVALID_BINDING - The supplied client binding is invalid.

    RPC_S_CANNOT_SUPPORT - The local address was inquired for a protocol
        sequence that doesn't support this type of functionality. Currently
        only ncacn_ip_tcp supports it.

    RPC_S_* or Win32 error for other errors
--*/
{
    // is this an osf scall?
    if (!SCall->InvalidHandle(OSF_SCALL_TYPE))
        {
        OSF_SCALL *OsfSCall;

        OsfSCall = (OSF_SCALL *)SCall;

        return OsfSCall->InqLocalConnAddress(
            Buffer,
            BufferSize,
            AddressFormat);
        }
    else if (!SCall->InvalidHandle(DG_SCALL_TYPE))
        {
        // this is a dg call
        DG_SCALL *DgSCall;

        DgSCall = (DG_SCALL *)SCall;

        return DgSCall->InqLocalConnAddress(
            Buffer,
            BufferSize,
            AddressFormat);
        }
    else
        {
        // the others don't support it
        return RPC_S_CANNOT_SUPPORT;
        }
}

BOOL
IsCallbackMessage (
    IN PRPC_MESSAGE Message
    )
/*++

Routine Description:

    Checks whether a given message corresponds to a callback

Arguments:


Return Value:


--*/
{
    MESSAGE_OBJECT *obj = (MESSAGE_OBJECT *)Message->Handle;

    // Check if this is a DG callback or a non-DG callback.
    // If the object is a LPC/OSF_CCALL, then it must be a callback.
    return ( !(obj->InvalidHandle(DG_CALLBACK_TYPE)) ||
             !(obj->InvalidHandle(OSF_CCALL_TYPE)) ||
             !(obj->InvalidHandle(LRPC_CCALL_TYPE)) );
}

BOOL CheckVerificationTrailer (
    IN void *BufferStart,
    IN void *BufferEnd,
    IN void *RpcMessage
    )
/*++

Routine Description:

    Checks the integrity of the verification header.

Arguments:

    BufferStart - current buffer position.

    BufferEnd - end of buffer. Note that BufferStart may already be beyond
        the end of the buffer!!!!

    RpcMessage - the current RPC Message

Return Value:

    Non-zero means check passed. 0 means check failed.

Notes:

    This function is very performance sensitive. It will be executed on
    every unmarshalling operation. It may be called after pipe chunks are
    unmarshalled as well.
--*/
{
    THREAD *Thread;
    SCALL *SCall;
    OSF_SCALL *OsfSCall;
    unsigned char *LocalBufferStart = (unsigned char *)BufferStart;
    unsigned char *LocalBufferEnd = (unsigned char *)BufferEnd;
    
    // if there is not enough stuff at the end, there is no verification trailer.
    // This is the quickest check that will weed out the largest percentage of
    // packets.
    if (LocalBufferStart + sizeof(rpc_sec_verification_trailer) >= LocalBufferEnd)
        return TRUE;

    SCall = (SCALL *)RpcpGetThreadContext();

    if (SCall->InvalidHandle(OSF_SCALL_TYPE))
        return TRUE;

    OsfSCall = (OSF_SCALL *)SCall;

    return OsfSCall->CheckVerificationTrailer(LocalBufferStart, LocalBufferEnd, (RPC_MESSAGE *)RpcMessage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\linklist.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       LinkList.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

File: Linkist.cxx

Description:

    The implementation of the functions that support link list operations. 
    All of these simply relegate to the macro versions


History :

kamenm     Aug 2000    Created

-------------------------------------------------------------------- */
#include <precomp.hxx>


PLIST_ENTRY
RpcpfRemoveHeadList(
    PLIST_ENTRY ListHead
    )
/*++

Routine Description:

    Removes the head of the list.

Arguments:
    ListHead - the head of the list

Return Value:
    The removed entry. If the list is empty,
    ListHead will be returned.

--*/
{
    return RpcpRemoveHeadList(ListHead);
}


PLIST_ENTRY
RpcpfRemoveTailList(
    PLIST_ENTRY ListHead
    )
/*++

Routine Description:

    Removes the tail of the list

Arguments:
    ListHead - the head of the list

Return Value:
    The removed entry. If the list is empty,
    ListHead will be returned.

--*/
{
    return RpcpRemoveTailList(ListHead);
}


VOID
RpcpfRemoveEntryList(
    PLIST_ENTRY Entry
    )
/*++

Routine Description:

    Removes an entry from the list

Arguments:
    Entry - the entry to remove

Return Value:

--*/
{
    ASSERT(Entry->Blink->Flink == Entry);
    ASSERT(Entry->Flink->Blink == Entry);

    RpcpRemoveEntryList(Entry);

#if DBG
    // Catch double-remove of an entry on chk builds.
    Entry->Blink = NULL;
    Entry->Flink = NULL;
#endif
}


VOID
RpcpfInsertTailList(
    PLIST_ENTRY ListHead,
    PLIST_ENTRY Entry
    )
/*++

Routine Description:

    Adds an entry to the tail of the list

Arguments:
    ListHead - the head of the list
    Entry - the entry to add

Return Value:

--*/
{
    RpcpInsertTailList(ListHead,Entry);
}


VOID
RpcpfInsertHeadList(
    PLIST_ENTRY ListHead,
    PLIST_ENTRY Entry
    )
/*++

Routine Description:

    Adds an entry to the head of the list

Arguments:
    ListHead - the head of the list
    Entry - the entry to add

Return Value:

--*/
{
    RpcpInsertHeadList(ListHead,Entry);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\init.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    initnt.cxx

Abstract:

    This module contains the code used to initialize the RPC runtime.  One
    routine gets called when a process attaches to the dll.  Another routine
    gets called the first time an RPC API is called.

Author:

    Michael Montague (mikemon) 03-May-1991

Revision History:
    Kamen Moutafov (KamenM) Dec 99 - Feb 2000 - Support for cell debugging stuff

--*/

#include <precomp.hxx>
#include <hndlsvr.hxx>
#include <thrdctx.hxx>
#include <rpccfg.h>
#include <rc4.h>
#include <randlib.h>
#include <epmap.h>
#include <CellHeap.hxx>
#include <lpcpack.hxx>

#include <dispatch.h>

#include <avrf.h>

int RpcHasBeenInitialized = 0;
RTL_CRITICAL_SECTION GlobalMutex;

RPC_SERVER * GlobalRpcServer = NULL;
BOOL g_fClientSideDebugInfoEnabled = FALSE;
BOOL g_fServerSideDebugInfoEnabled = FALSE;
BOOL g_fSendEEInfo = FALSE;
BOOL g_fIgnoreDelegationFailure = FALSE;
LRPC_SERVER *GlobalLrpcServer = NULL;
HINSTANCE hInstanceDLL ;

EXTERN_C HINSTANCE g_hRpcrt4;

DWORD gPageSize;
DWORD gThreadTimeout;
UINT  gNumberOfProcessors;
DWORD gAllocationGranularity;
BOOL gfServerPlatform;
ULONGLONG gPhysicalMemorySize;  // in megabytes

DWORD gProcessStartTime;

// The local machine's name.
RPC_CHAR *gLocalComputerName;
// The length of the name in TCHAR's including the terminating NULL.
DWORD gLocalComputerNameLength;

UNICODE_STRING *pBaseNameUnicodeString;

//
// RPC Verifier settings
//

BOOL gfAppVerifierEnabled = false;
BOOL gfPagedHeapEnabled = false;
BOOL gfRPCVerifierEnabled = false;
BOOL gfRpcVerifierCorruptionExpected = false;

// The basic rules for the RPC verifier settings are as follows:
//
// - If the app verifier is enabled RPC will do some basic checks.
// gfAppVerifierEnabled == true
// gfRPCVerifierEnabled == false
//
// - If the /rpc switch is enabled for the app verifier the RPC verifier
// will do extensive checks and will query for corruption injection settings.
// gfAppVerifierEnabled == true
// gfRPCVerifierEnabled == true
//
// - If paged heap is enabled the RPC verifier will be enabled and will do
// extensive checks silently.  No breaks will occur, by default.  We will also
// query for the corruption injection settings.
// gfPagedHeapEnabled == true;
// gfRPCVerifierEnabled == true;
// gfAppVerifierEnabled == false;
//
// In the other cases the RPC verifier code is inactive.

// The contents of the RpcVerifierFlags key of the image file options.
DWORD RpcVerifierFlags = 0x00000000;

// RPC verifier flag constants.
//
// These are written to RpcVerifierFlags key in the image file execution options
// in the registry.  We query the flags on RPC initialization and set the global
// variables accordingly.
#define FLAG_FAULT_INJECT_IMPERSONATE_CLIENT    0x00000001
#define FLAG_CORRUPTION_INJECT_SERVER_RECEIVES  0x00000010
#define FLAG_CORRUPTION_INJECT_CLIENT_RECEIVES  0x00000020
#define FLAG_FAULT_INJECT_TRANSPORTS            0x00000100
#define FLAG_PAUSE_INJECT_EXTERNAL_APIS         0x00001000
#define FLAG_SUPRESS_APP_VERIFIER_BREAKS        0x00010000
#define FLAG_BCACHE_MODE_DIRECT                 0x00020000

// The structure will be allocated and initialised with the RPC
// verifier settings whenever the RPC verifier is enabled.
tRpcVerifierSettings *pRpcVerifierSettings = NULL;

//
// By default the non pipe arguments cannot be more than 4 Megs
//
DWORD gMaxRpcSize = 0x400000;
DWORD gProrateStart = 0;
DWORD gProrateMax = 0;
DWORD gProrateFactor = 0;
void *g_rc4SafeCtx = 0;

BOOL gfRpcDisableVerifyOrUnsealAssert = FALSE;

extern "C" {

BOOLEAN
InitializeDLL (
    IN HINSTANCE DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context OPTIONAL
    )
/*++

Routine Description:

    This routine will get called: when a process attaches to this dll, and
    when a process detaches from this dll.

Return Value:

    TRUE - Initialization successfully occurred.

    FALSE - Insufficient memory is available for the process to attach to
        this dll.

--*/
{
    NTSTATUS NtStatus;

    UNUSED(Context);

    switch (Reason)
        {
        case DLL_PROCESS_ATTACH:
            hInstanceDLL = DllHandle ;
            g_hRpcrt4 = DllHandle;

            GlobalMutex.DebugInfo = NULL;
       
            NtStatus = RtlInitializeCriticalSectionAndSpinCount(&GlobalMutex, PREALLOCATE_EVENT_MASK);

            if (NT_SUCCESS(NtStatus) == 0)
                {
                return(FALSE);
                }

            // initialize safe rc4 operations.
            if(!rc4_safe_startup( &g_rc4SafeCtx ))
                {
                (void) RtlDeleteCriticalSection(&GlobalMutex);
                return FALSE;
                }
            break;

        case DLL_PROCESS_DETACH:
            //
            // If shutting down because of a FreeLibrary call, cleanup
            //

            if (Context == NULL) 
                {
                ShutdownLrpcClient();
                }

            if (GlobalMutex.DebugInfo != NULL)
                {
                NtStatus = RtlDeleteCriticalSection(&GlobalMutex);
                ASSERT(NT_SUCCESS(NtStatus));
                }

            if (g_rc4SafeCtx)
                rc4_safe_shutdown( g_rc4SafeCtx ); // free safe rc4 resources.

            break;

        case DLL_THREAD_DETACH:
            THREAD * Thread = RpcpGetThreadPointer();

#ifdef RPC_OLD_IO_PROTECTION
            if (Thread)
                {
                Thread->UnprotectThread();
                }
#else
            delete Thread;
#endif

            break;
        }

    return(TRUE);
}

}    //extern "C" end

#ifdef NO_RECURSIVE_MUTEXES
unsigned int RecursionCount = 0;
#endif // NO_RECURSIVE_MUTEXES

extern int InitializeRpcAllocator(void);
extern RPC_STATUS ReadPolicySettings(void);

const ULONG MEGABYTE = 0x100000;

typedef struct tagBasicSystemInfo
{
    DWORD m_dwPageSize;
    ULONGLONG m_dwPhysicalMemorySize;
    DWORD m_dwNumberOfProcessors;
    ULONG AllocationGranularity;
    BOOL m_fServerPlatform;
} BasicSystemInfo;

BOOL 
GetBasicSystemInfo (
    IN OUT BasicSystemInfo *basicSystemInfo
    )
/*++

Routine Description:

    Gets basic system information. We don't use the Win32 GetSystemInfo, because
    under NT it accesses the image header, which may not be available if the image
    was loaded from the network, and the network failed. Therefore, we need a function
    that accesses just what we need, and nothing else.

Arguments:

    The basic system info structure.

Return Value:

    0 - failure

    non-0 - success.

--*/
{
    //
    // Query system info (for # of processors) and product type
    //

    SYSTEM_BASIC_INFORMATION BasicInfo;
    NTSTATUS Status;
    BOOL b;

    Status = NtQuerySystemInformation(
                            SystemBasicInformation,
                            &BasicInfo,
                            sizeof(BasicInfo),
                            NULL
                            );
    if ( !NT_SUCCESS(Status) )
        {
        DbgPrintEx(DPFLTR_RPCPROXY_ID,
                       DPFLTR_ERROR_LEVEL,
                       "RPCTRANS: NtQuerySystemInformation failed: %x\n",
                       Status);

        return 0;
        }

    basicSystemInfo->m_dwPageSize = BasicInfo.PageSize;
    basicSystemInfo->m_dwNumberOfProcessors = BasicInfo.NumberOfProcessors;
    basicSystemInfo->m_dwPhysicalMemorySize = ((BasicInfo.NumberOfPhysicalPages * (ULONGLONG) basicSystemInfo->m_dwPageSize) / MEGABYTE);
    basicSystemInfo->AllocationGranularity = BasicInfo.AllocationGranularity;

    NT_PRODUCT_TYPE type;
    b = RtlGetNtProductType(&type);
    if (b)
        {
        basicSystemInfo->m_fServerPlatform = (type != NtProductWinNt);
        return 1;
        }
    else
        {
        DbgPrintEx(DPFLTR_RPCPROXY_ID,
                       DPFLTR_ERROR_LEVEL,
                       "RpcGetNtProductType failed, usign default\n");
        return 0;
        }
}

// Used in InitializeRpcVerifier
// The macro requires pBaseNameUnicodeString to be declared in order to function.
#define READ_DWORD_FROM_EXECUTION_OPTIONS(Key, Variable) \
{ \
    LdrQueryImageFileExecutionOptions (pBaseNameUnicodeString, \
                                       Key, \
                                       REG_DWORD, \
                                       &Variable, \
                                       sizeof(Variable), \
                                       NULL); \
}

// This is the global RPC heap where all allocations go to.
// If we are running with read-only RPC page heap then this
// will be a special heap created for us by Avrf rather then
// the process heap.
extern HANDLE hRpcHeap;

void 
InitializeRpcVerifier (
    void
    )
/*++

Routine Description:

    Performs initialization of the RPC verifier.  Sets everything necessary for the basic
    checks and extensive checks.  Queries the image file options for custom
    checks and enbales the selected ones

Arguments:

    None

Return Value:

    None - The only failure paths are registry IOs.  We will just skip some checks on failures.

--*/
{
    HMODULE hDll;
    VERIFIER_QUERY_RUNTIME_FLAGS_FUNCTION VerifierQueryRuntimeFlags;
    VERIFIER_CREATE_RPC_PAGE_HEAP_FUNCTION VerifierCreateRpcPageHeap;
    DWORD dwTmp;

    // Allocate the RPC verifier settings.
    pRpcVerifierSettings = new tRpcVerifierSettings;

    // If we could not allocate them, ignore the failure and return.
    // We chose not to run with the RPC verifier rather then prevent the process
    // from initializing.
    if (pRpcVerifierSettings == NULL)
        {
        return;
        }

    //
    // Set the RPC verifier settings to defaults.
    //

    // Fault injecting ImpersonateClient calls

    pRpcVerifierSettings->fFaultInjectImpersonateClient = false;
    pRpcVerifierSettings->ProbFaultInjectImpersonateClient = 100; // Default is 0.01
    pRpcVerifierSettings->DelayFaultInjectImpersonateClient = 0; // Delay before fault injection starts is 0 sec.

    // Corruption injecting the received data

    pRpcVerifierSettings->fCorruptionInjectServerReceives = false;
    pRpcVerifierSettings->fCorruptionInjectClientReceives = false;

    pRpcVerifierSettings->ProbRpcHeaderCorruption = 100; // Default is 0.01
    pRpcVerifierSettings->ProbDataCorruption = 100; // Default is 0.01
    pRpcVerifierSettings->ProbSecureDataCorruption = 10; // Default is 0.001

    pRpcVerifierSettings->CorruptionPattern = Randomize;
    pRpcVerifierSettings->CorruptionSizeType = RandomSize;
    pRpcVerifierSettings->CorruptionSize = 2;
    pRpcVerifierSettings->CorruptionDistributionType = LocalizedDistribution;

    pRpcVerifierSettings->ProbBufferTruncation = 0;
    pRpcVerifierSettings->MaxBufferTruncationSize = 0x10;

    // Fault injecting calls to transport routines

    pRpcVerifierSettings->fFaultInjectTransports = false;
    pRpcVerifierSettings->ProbFaultInjectTransports = 10; // Default is 0.001

    // Inserting pauses after calls to external APIs

    pRpcVerifierSettings->fPauseInjectExternalAPIs = false;
    pRpcVerifierSettings->ProbPauseInjectExternalAPIs = 100; // Default is 0.01
    pRpcVerifierSettings->PauseInjectExternalAPIsMaxWait = 10; // Default average delay is 10 milliseconds.

    // By default all verifier breaks are active.
    pRpcVerifierSettings->fSupressAppVerifierBreaks = false;

    pRpcVerifierSettings->fReadonlyPagedHeap = false;

    //
    // Enable the basic checks.
    //

    // Catch orphaned critical sections on return from the server managed routines.
    DispatchToStubInC = DispatchToStubInCAvrf;

    //
    // Check if the RPC verifier is enabled.
    //
    
    // When running under the app verifier we query it
    // to see whether the RPC verifier is enabled.
    if (gfAppVerifierEnabled)
        {
        // Try to load the app verifier dll.
        hDll = LoadLibrary(RPC_CONST_SSTRING("verifier.dll"));
        if (hDll != NULL)
            {
            // Try to import the function to query the app verifier flags.
            VerifierQueryRuntimeFlags = (VERIFIER_QUERY_RUNTIME_FLAGS_FUNCTION)GetProcAddress(hDll, "VerifierQueryRuntimeFlags");
            if (VerifierQueryRuntimeFlags != NULL)
                {
                LOGICAL fEnabled = FALSE;
                ULONG   Flags  = 0;

                // Query the app veirfier flags and see if the rpc switch is set.
                NTSTATUS Status = VerifierQueryRuntimeFlags(&fEnabled, &Flags);
                if ((Status == STATUS_SUCCESS) &&
                    (fEnabled) &&
                    (Flags & RTL_VRF_FLG_RPC_CHECKS))
                    {
                    gfRPCVerifierEnabled = true;
                    }
                }

            // Try to import the function to create a read-only paged heap.
            VerifierCreateRpcPageHeap = (VERIFIER_CREATE_RPC_PAGE_HEAP_FUNCTION)GetProcAddress(hDll, "VerifierCreateRpcPageHeap");

            FreeLibrary(hDll);
            }
        }
    // If app verifier is not enabled we must be initializing because of paged heap.
    else
        {
        ASSERT(gfPagedHeapEnabled);

        gfRPCVerifierEnabled = true;

        // When initializing under paged heap - disable verifier breaks.
        pRpcVerifierSettings->fSupressAppVerifierBreaks = true;
        }

    //
    // If the RPC Verifier is enabled load the settings from the image file options.
    //
    if (gfRPCVerifierEnabled)
        {
        DWORD PageHeapFaultProbability = 0;

        //
        // Enable the extensive checks.
        //

        // Use read-only paged heap if the app verifier and the RPC verifier are enabled.
        // The trigger to use the read-only "RPC" paged heap is a reg key or
        // the use of process-wide paged heap.
        if (gfAppVerifierEnabled &&
            gfPagedHeapEnabled)
            {
            // Try to create the read-only RPC heap.
            if (VerifierCreateRpcPageHeap != NULL)
                {
                VERIFIER_DBG_PRINT_0("Creating RPC pahe heap with VerifierCreateRpcPageHeap\n");

                PVOID pRpcPageHeap = VerifierCreateRpcPageHeap (
                    HEAP_GROWABLE
                    | HEAP_TAIL_CHECKING_ENABLED
                    | HEAP_FREE_CHECKING_ENABLED, // Flags
                    NULL, // HeapBase
                    16 * 1024 - 512, // ReserveSize
                    NULL, // CommitSize
                    NULL, // Lock
                    NULL); // PRTL_HEAP_PARAMETERS Parameters

                VERIFIER_DBG_PRINT_1("VerifierCreateRpcPageHeap returned 0x%x\n", pRpcPageHeap);

                if (pRpcPageHeap != NULL)
                    {
                    hRpcHeap = pRpcPageHeap;

                    pRpcVerifierSettings->fReadonlyPagedHeap = true;
                    
                    // Set BCache to direct mode.  Allocations will be done on the heap
                    // and will skip caching.
                    gBCacheMode = BCacheModeDirect;
                    }
                }
            }

        // Extend the RPC log size.
        // At this point the RPC allocator has been initialized and this resulted in the creation
        // of the event log and the addition of some events.  We will just re-allocate for simplicity.
        // There are no threads in the RPC runtime and we are holding the global lock, so there
        // are no races.
        struct RPC_EVENT * TmpRpcEvents;
        TmpRpcEvents = (struct RPC_EVENT *) HeapReAlloc(GetProcessHeap(),
                                                        0,
                                                        RpcEvents,
                                                        2*EventArrayLength*sizeof(RPC_EVENT));
        // If reallocation has failed we will just keep the old log.
        if (TmpRpcEvents != NULL)
            {
            RpcEvents = TmpRpcEvents;
            EventArrayLength *= 2;
            }

        //
        // Query and enable the custom checks.
        //

        // Query the image file execution options for the custom checks and their options.
        READ_DWORD_FROM_EXECUTION_OPTIONS (L"RpcVerifierFlags",
                                           RpcVerifierFlags);
        
        // Set the global flags in accordance with the enabled checks.
        if (RpcVerifierFlags & FLAG_FAULT_INJECT_IMPERSONATE_CLIENT)
            pRpcVerifierSettings->fFaultInjectImpersonateClient = true;
        if (RpcVerifierFlags & FLAG_CORRUPTION_INJECT_SERVER_RECEIVES)
            {
            pRpcVerifierSettings->fCorruptionInjectServerReceives = true;
            // if we are corrupting receives, then corruption asserts
            // are expected
            gfRpcVerifierCorruptionExpected = true;
            }
        if (RpcVerifierFlags & FLAG_CORRUPTION_INJECT_CLIENT_RECEIVES)
            {
            pRpcVerifierSettings->fCorruptionInjectClientReceives = true;
            // if we are corrupting receives, then corruption asserts
            // are expected
            gfRpcVerifierCorruptionExpected = true;
            }
        if (RpcVerifierFlags & FLAG_FAULT_INJECT_TRANSPORTS)
            pRpcVerifierSettings->fFaultInjectTransports = true;
        if (RpcVerifierFlags & FLAG_PAUSE_INJECT_EXTERNAL_APIS)
            pRpcVerifierSettings->fPauseInjectExternalAPIs = true;
        if (RpcVerifierFlags & FLAG_SUPRESS_APP_VERIFIER_BREAKS)
            pRpcVerifierSettings->fSupressAppVerifierBreaks = true;
        if (RpcVerifierFlags & FLAG_BCACHE_MODE_DIRECT)
            gBCacheMode = BCacheModeDirect;

        // Check if we should fault-inject ImpersonateClient calls.

        // If paged heap is enabled with fault injection
        // we should set ImpersonateClient to fail and use the paged heap settings
        READ_DWORD_FROM_EXECUTION_OPTIONS (L"PageHeapFaultProbability",
                                           PageHeapFaultProbability);
        if (PageHeapFaultProbability)
            {
            pRpcVerifierSettings->fFaultInjectImpersonateClient = true;
            pRpcVerifierSettings->ProbFaultInjectImpersonateClient = PageHeapFaultProbability;
            READ_DWORD_FROM_EXECUTION_OPTIONS (L"PageHeapFaultTimeOut",
                                               pRpcVerifierSettings->DelayFaultInjectImpersonateClient);
            }

        // Check to see if explicit setting are given in the registry.
        // We will overwrite the paged heap settings with the explicit ones.
        if (pRpcVerifierSettings->fFaultInjectImpersonateClient)
            {
            READ_DWORD_FROM_EXECUTION_OPTIONS (L"RpcVerifierProbFaultInjectImpersonateClient",
                                               pRpcVerifierSettings->ProbFaultInjectImpersonateClient);
            READ_DWORD_FROM_EXECUTION_OPTIONS (L"RpcVerifierDelayFaultInjectImpersonateClient",
                                               pRpcVerifierSettings->DelayFaultInjectImpersonateClient);
            }

        // Check if we should corruption-inject server receives.
        if (pRpcVerifierSettings->fCorruptionInjectServerReceives)
            {
            // If yes, then whack the server receive IOEventDispatchTable entries to point to
            // Avrf routines for the server receives.
            IOEventDispatchTable[ConnectionServerReceive] = ProcessConnectionServerReceivedEventAvrf;
            IOEventDispatchTable[DatagramServerReceive] = ProcessDatagramServerReceiveEventAvrf;
            IOEventDispatchTable[COMPLEX_T | CONNECTION | RECEIVE | SERVER] = ProcessComplexTReceiveAvrf;
            }


        // Check if we should corruption-inject client receives.
        if (pRpcVerifierSettings->fCorruptionInjectClientReceives)
            {
            // If yes, then whack the client receive IOEventDispatchTable entries to point to
            // Avrf routines for the client receives.
            IOEventDispatchTable[ConnectionClientReceive] = ProcessConnectionClientReceiveEventAvrf;
            IOEventDispatchTable[DatagramClientReceive] = ProcessDatagramClientReceiveEventAvrf;
            IOEventDispatchTable[COMPLEX_T | CONNECTION | RECEIVE | CLIENT] = ProcessComplexTReceiveAvrf;

            // The SyncSendRecv and SyncRecv members of the transport interfaces will
            // be overwritten on transport load:
            //
            // TCP_TransportInterface: WS_SyncRecv->WS_SyncRecv_Avrf
            // NMP_TransportInterface: NMP_SyncSendRecv->NMP_SyncSendRecv_Avrf, CO_SyncRecv->CO_SyncRecv_Avrf
            // UDP_TransportInterface: DG_ReceivePacket->DG_ReceivePacket_Avrf;
            // CDP_TransportInterface: DG_ReceivePacket->DG_ReceivePacket_Avrf;
            //
            // This will allow the corruption of sync client receives.
            }

        // If we are corruption-injecting, read the corruption settings from the registry.
        if (pRpcVerifierSettings->fCorruptionInjectServerReceives ||
            pRpcVerifierSettings->fCorruptionInjectClientReceives) 
            {
            READ_DWORD_FROM_EXECUTION_OPTIONS (L"RpcVerifierProbRpcHeaderCorruption",
                                               pRpcVerifierSettings->ProbRpcHeaderCorruption);

            READ_DWORD_FROM_EXECUTION_OPTIONS (L"RpcVerifierProbDataCorruption",
                                               pRpcVerifierSettings->ProbDataCorruption);

            READ_DWORD_FROM_EXECUTION_OPTIONS (L"RpcVerifierProbSecureDataCorruption",
                                               pRpcVerifierSettings->ProbSecureDataCorruption);

            READ_DWORD_FROM_EXECUTION_OPTIONS (L"RpcVerifierCorruptionPattern",
                                               pRpcVerifierSettings->CorruptionPattern);
            ASSERT(pRpcVerifierSettings->CorruptionPattern == ZeroOut ||
                   pRpcVerifierSettings->CorruptionPattern == Negate ||
                   pRpcVerifierSettings->CorruptionPattern == BitFlip ||
                   pRpcVerifierSettings->CorruptionPattern == IncDec ||
                   pRpcVerifierSettings->CorruptionPattern == Randomize ||
                   pRpcVerifierSettings->CorruptionPattern == AllPatterns);

            READ_DWORD_FROM_EXECUTION_OPTIONS (L"RpcVerifierCorruptionSizeType",
                                               pRpcVerifierSettings->CorruptionSizeType);
            ASSERT (pRpcVerifierSettings->CorruptionDistributionType == FixedSize ||
                    pRpcVerifierSettings->CorruptionDistributionType == RandomSize);

            READ_DWORD_FROM_EXECUTION_OPTIONS (L"RpcVerifierCorruptionSize",
                                               pRpcVerifierSettings->CorruptionSize);

            READ_DWORD_FROM_EXECUTION_OPTIONS (L"RpcVerifierCorruptionDistributionType",
                                               pRpcVerifierSettings->CorruptionDistributionType);
            ASSERT(pRpcVerifierSettings->CorruptionDistributionType == LocalizedDistribution ||
                   pRpcVerifierSettings->CorruptionDistributionType == RandomizedDistribution);

            READ_DWORD_FROM_EXECUTION_OPTIONS (L"RpcVerifierProbBufferTruncation",
                                               pRpcVerifierSettings->ProbBufferTruncation);
            READ_DWORD_FROM_EXECUTION_OPTIONS (L"RpcVerifierMaxBufferTruncationSize",
                                               pRpcVerifierSettings->MaxBufferTruncationSize);
            }
        }
}


RPC_STATUS
PerformRpcInitialization (
    void
    )
/*++

Routine Description:

    This routine will get called the first time that an RPC runtime API is
    called.  There is actually a race condition, which we prevent by grabbing
    a mutex and then performing the initialization.  We only want to
    initialize once.

Return Value:

    RPC_S_OK - This status code indicates that the runtime has been correctly
        initialized and is ready to go.

    RPC_S_OUT_OF_MEMORY - If initialization failed, it is most likely due to
        insufficient memory being available.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
#if DBG
    // Catch cases when this function is called recursively.
    // This can lead to stack overflow in low-memory conditions.
    static BOOL fInPerformRpcInitialization; // Initialized to FALSE.
#endif

    if ( RpcHasBeenInitialized == 0 ) 
        {
        RequestGlobalMutex();
#if DBG
        ASSERT(fInPerformRpcInitialization == FALSE);
        fInPerformRpcInitialization = TRUE;
#endif
        if ( RpcHasBeenInitialized == 0 )
            {
            BasicSystemInfo SystemInfo;
            BOOL b;

            // We need to make sure that from this point on RPC will not be
            // unloaded.  This requires a load library call to "lock" rpcrt4.dll in
            // memory.  If the dll is not locked then it may be unloaded as a dependency with
            // active critical sections, etc.
            if (LoadLibrary(RPC_CONST_SSTRING("rpcrt4.dll")) == 0)
                {
                Status = RPC_S_OUT_OF_MEMORY;
                goto Cleanup;
                }
            b = GetBasicSystemInfo(&SystemInfo);    
            if (!b)
                {
                Status = RPC_S_OUT_OF_MEMORY;
                goto Cleanup;
                }

            gNumberOfProcessors = SystemInfo.m_dwNumberOfProcessors;
            gPageSize = SystemInfo.m_dwPageSize;
            gAllocationGranularity = SystemInfo.AllocationGranularity;
            gfServerPlatform = SystemInfo.m_fServerPlatform;
            gPhysicalMemorySize = SystemInfo.m_dwPhysicalMemorySize;

            gProcessStartTime = GetTickCount();

            //
            // We need to init the RPC allocator before doing any memory allocations.
            //

            // Should be something like 64kb / 4kb.
            ASSERT(gAllocationGranularity % gPageSize == 0);

            if (( InitializeRpcAllocator() != 0)
                || ( InitializeServerDLL() != 0 ))
                {
                Status = RPC_S_OUT_OF_MEMORY;
                goto Cleanup;
                }

            // Allocate space for the computer name.
            gLocalComputerName = new RPC_CHAR[MAX_COMPUTERNAME_LENGTH+1];
            if (gLocalComputerName == NULL)
                {
                Status = RPC_S_OUT_OF_MEMORY;
                goto Cleanup;
                }
            gLocalComputerNameLength = MAX_COMPUTERNAME_LENGTH+1;

            b = GetComputerNameW(gLocalComputerName,
                                 &gLocalComputerNameLength);

            if (b != TRUE)
                {
                DWORD LastError = GetLastError();

                if (LastError == ERROR_NOT_ENOUGH_MEMORY)
                    {
                    Status = RPC_S_OUT_OF_MEMORY;
                    }
                else if ((LastError == ERROR_NOT_ENOUGH_QUOTA)
                         || (LastError == ERROR_NO_SYSTEM_RESOURCES))
                    {
                    Status = RPC_S_OUT_OF_RESOURCES;
                    }
                else if (LastError == ERROR_WRITE_PROTECT)
                    {
                    Status = RPC_S_ACCESS_DENIED;
                    }
                else
                    {
                    ASSERT(0);
                    Status = RPC_S_OUT_OF_MEMORY;
	                }

                goto Cleanup;
                }

            // GetComputerNameW returns in gLocalComputerNameLength the size of
            // the computer name in TCHARs NOT including the terminating NULL.
            // We define this length to include the NULL and need to increment it.
            gLocalComputerNameLength++;

            // 
            // Check for the app verifier settings.
            //

            gfAppVerifierEnabled = (NtCurrentPeb()->NtGlobalFlag & FLG_APPLICATION_VERIFIER) != 0;
            gfPagedHeapEnabled = (NtCurrentPeb()->NtGlobalFlag & FLG_HEAP_PAGE_ALLOCS) != 0;

            // Initialize the image base name to be used when querying the execution options.
            pBaseNameUnicodeString = FastGetImageBaseNameUnicodeString();

            // Initialize the RPC verifier if app verifier is enabled or paged heap is enabled.
            if (gfAppVerifierEnabled
                || gfPagedHeapEnabled)
                {
                // The function does not fail.
                // The worst thing that happens is we don't get some checks.
                InitializeRpcVerifier();
                }

            Status = InitializeEPMapperClient();
            if (Status != RPC_S_OK)
                {
                goto Cleanup;
                }

            Status = ReadPolicySettings();
            if (Status != RPC_S_OK)
                {
                goto Cleanup;
                }
          
            if (gfServerPlatform)
                {
                gThreadTimeout = 90*1000;
                }
            else
                {
                gThreadTimeout = 30*1000;
                }

            Status = InitializeCellHeap();
            if (Status != RPC_S_OK)
                {
                goto Cleanup;
                }

            RpcHasBeenInitialized = 1;
            goto Cleanup;
            }
        else
            {
            goto Cleanup;
            }
        }
    return(RPC_S_OK);

Cleanup:
#if DBG
    ASSERT(fInPerformRpcInitialization == TRUE);
    fInPerformRpcInitialization = FALSE;
#endif
    GlobalMutexVerifyOwned();
    ClearGlobalMutex();
    return Status;
}

#ifdef DBG
long lGlobalMutexCount = 0;
#endif


void
GlobalMutexRequestExternal (
    void
    )
/*++

Routine Description:

    Request the global mutex.

--*/
{
    GlobalMutexRequest();
}


void
GlobalMutexClearExternal (
    void
    )
/*++

Routine Description:

    Clear the global mutex.

--*/
{
    GlobalMutexClear();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\msgapi.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    msgapi.cxx

Abstract:

    The I_RpcSendReceive API used to send and receive messages as part of
    a remote procedure call lives here.  This API is used by both clients
    (to make calls) and by servers (to make callbacks).

Author:

    Michael Montague (mikemon) 07-Nov-1991

Revision History:
    Mazhar Mohammed (mazharm) 09-11-95 added I_RpcReceive, I_RpcSend
    Mazhar Mohammed (mazharm) 03-31-96 added support for async RPC
                                               I_RpcAsyncSend and I_RpcAsyncReceive

Revision History:

--*/

#include <precomp.hxx>

#define    _SND_RECV_CALLED               0x100


RPC_STATUS RPC_ENTRY
I_RpcSendReceive (
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:

    We do all of the protocol module independent work of making a remote
    procedure call; at least the part concerned with sending the request
    and receiving the response.  The majority of the work is done by
    each rpc protocol module.

Arguments:

    Message - Supplies and returns the information required to make
        the remote procedure call.

Return Values:

    RPC_S_OK - The operation completed successfully.

--*/
{
    RPC_STATUS retval;
    THREAD *Thread;

    AssertRpcInitialized();

    ASSERT(!RpcpCheckHeap());

    Thread = ThreadSelf();
    if (!Thread)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    RpcpPurgeEEInfoFromThreadIfNecessary(Thread);

    MESSAGE_OBJECT *MObject = (MESSAGE_OBJECT *) Message->Handle;

    ASSERT( MObject->InvalidHandle(CALL_TYPE) == 0 );

    ASSERT( Message->Buffer != 0 );
    ASSERT( !COMPLETE(Message) );

    retval = MObject->SendReceive(Message);

    ASSERT(!RpcpCheckHeap());

    // Insure that the buffer is aligned on an eight byte boundary.

#ifdef DEBUGRPC

    if ( retval == RPC_S_OK )
        {
        ASSERT( (((ULONG_PTR) Message->Buffer) % 8) == 0);
        // uncomment this to check for 16 byte alignment on 64 bits
        // ASSERT( IsBufferAligned(Message->Buffer) );
        }

#endif // DEBUGRPC

    return(retval);
}


RPC_STATUS RPC_ENTRY
I_RpcSend (
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:
    This API is used in conjunction with pipes. This is used to send the marshalled
    parameters and the marshalled pipe data.

    Client: If the RPC_BUFFER_PARTIAL bit is set in Message->RpcFlags,
    this routine returns as soon as the buffer is sent. If the
    bit is not set, this routine blocks until the first reply fragment arrives.

    Server: The send always treated as a partial send.

Arguments:

    Message - Supplies  the information required to send the request


Return Values:

    RPC_S_OK - The operation completed successfully.
    RPC_S_SEND_INCOMPLETE - The complete data wasn't sent, Message->Buffer
    points to the remaining data and Message->BufferLength indicates the length of the
    remaining data. Any additional data needs to be appended to the
    end of the buffer.

--*/
{
    RPC_STATUS retval;
    THREAD *Thread;
    PVOID MessageBuffer;

    AssertRpcInitialized();

    ASSERT(!RpcpCheckHeap());

    Thread = ThreadSelf();
    if (!Thread)
        {
        HANDLE_TYPE HandleType = ((CALL *) Message->Handle)->Type(CALL_TYPE);

        // ThreadSelf can fail for client calls only, since for server calls
        // the thread object would have already been allocated by the runtime.
        // If Message is partial and async, then NDR will assume that the runtime
        // has already cleaned up.  Therefore, if this is a partial async message
        // then we need to clean up the call object and the buffer to avoid the leak.
        if (PARTIAL(Message) &&
            (HandleType & CCALL_TYPE) &&
            ASYNC(Message))
            {
            ((MESSAGE_OBJECT *)Message->Handle)->FreeBuffer(Message);
            }

        return RPC_S_OUT_OF_MEMORY;
        }

    RpcpPurgeEEInfoFromThreadIfNecessary(Thread);

    MESSAGE_OBJECT *MObject = (MESSAGE_OBJECT *) Message->Handle;

    ASSERT( MObject->InvalidHandle(CALL_TYPE) == 0 );

    MessageBuffer = Message->Buffer;
    ASSERT( MessageBuffer != 0 );

    if (ASYNC(Message))
        {
        retval = MObject->AsyncSend(Message);
        }
    else
        {
        retval = MObject->Send(Message);
        }

    ASSERT(!RpcpCheckHeap());

    // Insure that the buffer is aligned on an eight byte boundary.

#ifdef DEBUGRPC

    if ( retval == RPC_S_OK )
        {
        ASSERT( (((ULONG_PTR) MessageBuffer) % 8) == 0);
        // uncomment this to check for 16 byte alignment on 64 bits
        //ASSERT( IsBufferAligned(MessageBuffer) );
        }

#endif // DEBUGRPC

    return(retval);
}


RPC_STATUS RPC_ENTRY
I_RpcReceive (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned int Size
    )
/*++

Routine Description:
    This routine is used in conjunction with pipes. If the RPC_BUFFER_PARTIAL bit
    is set in Message->RpcFlags, this call blocks until some data is received. Size is
    used as a hint of how much data the caller is requesting. If the partial bit is not set,
    this call blocks until the complete buffer is received.

Arguments:

    Message - Supplies  the information required to make the receive
    Size - used as a hint to indicate the amount of data needed by the caller

Return Values:

    RPC_S_OK - The operation completed successfully.
--*/
{

    RPC_STATUS retval;
    THREAD *Thread;

    AssertRpcInitialized();

    ASSERT(!RpcpCheckHeap());

    Thread = ThreadSelf();
    if (!Thread)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    RpcpPurgeEEInfoFromThreadIfNecessary(Thread);

    MESSAGE_OBJECT *MObject = (MESSAGE_OBJECT *) Message->Handle;

    ASSERT( MObject->InvalidHandle(CALL_TYPE) == 0 );

    //
    // Temp hack
    // Need to get Ryszard to fix
    // the NDR engine to never ask for 0 bytes
    // We can then change this to an ASSERT
    // ASSERT(Size)
    //
    if (Size == 0)
        Size = 1;

    if (ASYNC(Message))
        {
        retval = MObject->AsyncReceive(Message, Size);
        }
    else
        {
        retval = MObject->Receive(Message, Size);
        }

    ASSERT(!RpcpCheckHeap());

    // Insure that the buffer is aligned on an eight byte boundary.

#ifdef DEBUGRPC

    if ( retval == RPC_S_OK )
        {
        ASSERT( (((ULONG_PTR) Message->Buffer) % 8) == 0);
        // uncomment this to check for 16 byte alignment on 64 bits
        // ASSERT( IsBufferAligned(Message->Buffer) );
        }

#endif // DEBUGRPC

    return(retval);
}



RPC_STATUS RPC_ENTRY
I_RpcAsyncSetHandle (
    IN  PRPC_MESSAGE Message,
    IN  PRPC_ASYNC_STATE pAsync
    )
/*++
    This API is called on the client and server side. If this API is called on the
    server, runtime assumes that the call is async
    we will add more params later.
--*/
{
    RPC_STATUS retval;

    AssertRpcInitialized();

    ASSERT(!RpcpCheckHeap());

    MESSAGE_OBJECT *MObject = (MESSAGE_OBJECT *) Message->Handle;

    if (MObject->InvalidHandle(CALL_TYPE))
        {
        ASSERT(0);
        return (RPC_S_INVALID_BINDING);
        }

#if DBG
    if (!MObject->InvalidHandle(CCALL_TYPE))
        {
        // if we end up with invalid pAsync here, this means we were either
        // called by a private test, or COM. Both should know better. The
        // public APIs should pass through NDR and NDR already should have
        // validated the parameters.
        ASSERT((pAsync->Lock == 0) || (pAsync->Lock == 1));
        }
#endif

    retval = MObject->SetAsyncHandle(pAsync);

    if (retval == RPC_S_OK)
         {
         pAsync->RuntimeInfo = (void *) MObject;
         }

    ASSERT(!RpcpCheckHeap());

    return(retval);
}



RPC_STATUS RPC_ENTRY
I_RpcAsyncAbortCall (
    IN PRPC_ASYNC_STATE pAsync,
    IN unsigned long ExceptionCode
    )
/*++

Routine Description:


Arguments:
 pAsync - the async handle being registered

Return Value:
    RPC_S_OK - the call succeeded.
    RPC_S_INVALID_HANDLE - the handle was bad.

--*/

{
    MESSAGE_OBJECT *MObject = (MESSAGE_OBJECT *) pAsync->RuntimeInfo;

    if (!ThreadSelf())
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    if (MObject)
        {
        if (MObject->InvalidHandle(CALL_TYPE))
            {
            ASSERT(0);
            return (RPC_S_INVALID_BINDING);
            }

        return ((CALL *) MObject)->AbortAsyncCall(pAsync, ExceptionCode);
        }

    return RPC_S_INVALID_ASYNC_HANDLE;
}



#ifdef __cplusplus
extern "C" {
#endif

const RPC_CHAR *SecurityString = RPC_CONST_STRING("security=");
const int SecurityStringLength = sizeof("security=") - 1;  // in characters without terminating NULL

const RPC_CHAR *DynamicString = RPC_CONST_STRING("dynamic");
const int DynamicStringLength = sizeof("dynamic") - 1;  // in characters without terminating NULL

const RPC_CHAR *StaticString = RPC_CONST_STRING("static");
const int StaticStringLength = sizeof("static") - 1;  // in characters without terminating NULL

const RPC_CHAR *TrueString = RPC_CONST_STRING("true");
const int TrueStringLength = sizeof("true") - 1;  // in characters without terminating NULL

const RPC_CHAR *FalseString = RPC_CONST_STRING("false");
const int FalseStringLength = sizeof("false") - 1;  // in characters without terminating NULL

const RPC_CHAR *AnonymousString = RPC_CONST_STRING("anonymous");
const int AnonymousStringLength = sizeof("anonymous") - 1;  // in characters without terminating NULL

const RPC_CHAR *IdentificationString = RPC_CONST_STRING("identification");
const int IdentificationStringLength = sizeof("identification") - 1;  // in characters without terminating NULL

const RPC_CHAR *ImpersonationString = RPC_CONST_STRING("impersonation");
const int ImpersonationStringLength = sizeof("impersonation") - 1;  // in characters without terminating NULL

const RPC_CHAR *DelegationString = RPC_CONST_STRING("delegation");
const int DelegationStringLength = sizeof("delegation") - 1;  // in characters without terminating NULL


RPC_STATUS
I_RpcParseSecurity (
    IN RPC_CHAR * NetworkOptions,
    OUT SECURITY_QUALITY_OF_SERVICE * SecurityQualityOfService
    )
/*++

Routine Description:

    Parse a string of security options and build into the binary format
    required by the operating system.  The network options must follow
    the following syntax.  Case is not sensitive.

        security=
            [anonymous|identification|impersonation|delegation]
            [dynamic|static]
            [true|false]

        All three fields must be present.  To specify impersonation
        with dynamic tracking and effective only, use the following
        string for the network options.

        "security=impersonation dynamic true"

Arguments:

    NetworkOptions - Supplies the string containing the network options
        to be parsed.

    SecurityQualityOfService - Returns the binary format of the network
        options.

Return Value:

    RPC_S_OK - The network options have been correctly parsed into binary
        format.

    RPC_S_INVALID_NETWORK_OPTIONS - The network options are invalid and
        cannot be parsed.

--*/
{

    ASSERT(NetworkOptions[0] != 0);

    // We need to parse the security information from the network
    // options, and then stuff it into the object attributes.  To
    // begin with, we check for "security=" at the beginning of
    // the network options.

    if (RpcpStringNCompare(NetworkOptions, SecurityString,
                SecurityStringLength) != 0)
        {
        return(RPC_S_INVALID_NETWORK_OPTIONS);
        }

    NetworkOptions += SecurityStringLength;

    // Ok, now we need to determine if the next field is one of
    // Anonymous, Identification, Impersonation, or Delegation.

    if (RpcpStringNCompare(NetworkOptions, AnonymousString,
                AnonymousStringLength) == 0)
        {
        SecurityQualityOfService->ImpersonationLevel = SecurityAnonymous;
        NetworkOptions += AnonymousStringLength;
        }
    else if (RpcpStringNCompare(NetworkOptions, IdentificationString,
                IdentificationStringLength) == 0)
        {
        SecurityQualityOfService->ImpersonationLevel = SecurityIdentification;
        NetworkOptions += IdentificationStringLength;
        }
    else if (RpcpStringNCompare(NetworkOptions, ImpersonationString,
                ImpersonationStringLength) == 0)
        {
        SecurityQualityOfService->ImpersonationLevel = SecurityImpersonation;
        NetworkOptions += ImpersonationStringLength;
        }
    else if (RpcpStringNCompare(NetworkOptions, DelegationString,
                DelegationStringLength) == 0)
        {
        SecurityQualityOfService->ImpersonationLevel = SecurityDelegation;
        NetworkOptions += DelegationStringLength;
        }
    else
        {
        return(RPC_S_INVALID_NETWORK_OPTIONS);
        }

    if (*NetworkOptions != RPC_CONST_CHAR(' '))
        {
        return(RPC_S_INVALID_NETWORK_OPTIONS);
        }

    NetworkOptions++;

    // Next comes the context tracking field; it must be one of
    // dynamic or static.

    if (RpcpStringNCompare(NetworkOptions, DynamicString,
                DynamicStringLength) == 0)
        {
        SecurityQualityOfService->ContextTrackingMode =
                SECURITY_DYNAMIC_TRACKING;
        NetworkOptions += DynamicStringLength;
        }
    else if (RpcpStringNCompare(NetworkOptions, StaticString,
                StaticStringLength) == 0)
        {
        SecurityQualityOfService->ContextTrackingMode =
                SECURITY_STATIC_TRACKING;
        NetworkOptions += StaticStringLength;
        }
    else
        {
        return(RPC_S_INVALID_NETWORK_OPTIONS);
        }

    if (*NetworkOptions != RPC_CONST_CHAR(' '))
        {
        return(RPC_S_INVALID_NETWORK_OPTIONS);
        }

    NetworkOptions++;

    // Finally, comes the effective only flag.  This must be one of
    // true or false.

    if (RpcpStringNCompare(NetworkOptions, TrueString,
                TrueStringLength) == 0)
        {
        SecurityQualityOfService->EffectiveOnly = TRUE;
        NetworkOptions += TrueStringLength;
        }
    else if (RpcpStringNCompare(NetworkOptions, FalseString,
                FalseStringLength) == 0)
        {
        SecurityQualityOfService->EffectiveOnly = FALSE;
        NetworkOptions += FalseStringLength;
        }
    else
        {
        return(RPC_S_INVALID_NETWORK_OPTIONS);
        }

    if (*NetworkOptions != 0)
        {
        return(RPC_S_INVALID_NETWORK_OPTIONS);
        }

    SecurityQualityOfService->Length = sizeof(SECURITY_QUALITY_OF_SERVICE);

    return(RPC_S_OK);
}

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\memory.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1999

Module Name:

    memory.cxx

Abstract:

    This file contains the new and delete routines for memory management in
    the RPC runtime.  Rather than using the memory management provided by the
    C++ system we'll use the system allocator.

Revision History:

    mikemon    ??-??-??    Beginning of time (at least for this file).
    mikemon    12-31-90    Upgraded the comments.
    mariogo    04-24-96    Rewrite to unify platforms, behavior and performance.

--*/

#include <precomp.hxx>

#include <ntlsa.h>      // definitions for LSA allocation routines

HANDLE hRpcHeap = 0;
unsigned int DebugFlags = 0;
#define RPC_FAIL_ALLOCATIONS 0x00000001
#define  NO_HEAP_SLOWDOWN


PLSA_ALLOCATE_PRIVATE_HEAP LsaAlloc = NULL;
PLSA_FREE_PRIVATE_HEAP LsaFree = NULL;

inline void *AllocWrapper(size_t size)
{
    void *pobj;

    if( !LsaAlloc )
        {
        pobj = HeapAlloc(hRpcHeap, 0, size);
        }
    else 
        {
        pobj = LsaAlloc( size );
        }
    LogEvent(SU_HEAP, EV_CREATE, pobj, hRpcHeap, size, TRUE, 3);

    return pobj;
}

inline void FreeWrapper(void *pobj)
{
    LogEvent(SU_HEAP, EV_DELETE, pobj, hRpcHeap, 0, TRUE, 3);

    if( !LsaFree )
        {
        HeapFree(hRpcHeap, 0, pobj);
        } 
    else 
        {
        LsaFree( pobj );
        }
}

int fHeapInitialized = 0;
int fBufferCacheInitialized = 0;

BOOL fMaybeLsa = FALSE;

#ifndef DEBUGRPC

void *
__cdecl
operator new (
    IN size_t size
    )
{
    return(AllocWrapper(size));
}

void
__cdecl
operator delete (
    IN void * obj
    )
{
    FreeWrapper(obj);
}

int InitializeRpcAllocator(void)
{
    HMODULE hLsa;

    if (0 == fHeapInitialized)
        {
        if (RpcpStringCompare(FastGetImageBaseName(), L"lsass.exe") == 0)
            {
            fMaybeLsa = TRUE;
            if (gfServerPlatform)
                {
                // if this looks like lsa on a server box
                hLsa = GetModuleHandle(L"lsasrv.dll");
                if (hLsa)
                    {

                    //
                    // use LSA for FRE build (per KamenM request).
                    //
                    LsaAlloc = (PLSA_ALLOCATE_PRIVATE_HEAP)GetProcAddress(hLsa, "LsaIAllocateHeap");
                    LsaFree = (PLSA_FREE_PRIVATE_HEAP)GetProcAddress(hLsa, "LsaIFreeHeap");

                    if( LsaAlloc == NULL || LsaFree == NULL )
                        {
                        LsaAlloc = NULL;
                        LsaFree = NULL;
                        }
                    }
                }
            }

        if (hRpcHeap == 0)
            hRpcHeap = RtlProcessHeap();

        fHeapInitialized = 1;
        }

    if (0 == fBufferCacheInitialized)
        {
        RPC_STATUS status = RPC_S_OK;
        gBufferCache = new BCACHE(status);

        if (   0 == gBufferCache
            || status != RPC_S_OK )
            {
            return(RPC_S_OUT_OF_MEMORY);
            }
        fBufferCacheInitialized = TRUE;
        }

    return(RPC_S_OK);
}

int
RpcpCheckHeap (
    void
    )
// Allow some checked compenents to be linked into a free memory.cxx.
{
    return 0;
}


#else // ******************** DEBUG ********************

#ifdef NO_HEAP_SLOWDOWN
int fMemoryCheck = 0;
#else
int fMemoryCheck = 1;
#endif

CRITICAL_SECTION RpcHeapLock;

int InitializeRpcAllocator(void)
/*++

Routine Description:

    Called during RPC initialization. This function must can by one
    thread at a time.  Sets the heap handle for debugging.

    Maybe called more then once if this (or a later step) of RPC
    initialization fails.

--*/
{
    if (0 == fHeapInitialized)
        {
        if (RpcpStringCompare(FastGetImageBaseName(), L"lsass.exe") == 0)
            {
            fMaybeLsa = TRUE;
            }

        if (0 == hRpcHeap)
            {
            hRpcHeap = RtlCreateHeap(  HEAP_GROWABLE
                                     | HEAP_TAIL_CHECKING_ENABLED
                                     | HEAP_FREE_CHECKING_ENABLED
                                     | HEAP_CLASS_1,
                                     0,
                                     16 * 1024 - 512,
                                     0,
                                     0,
                                     0
                                     );
            }

        if (hRpcHeap)
            {
            if (0 == RtlInitializeCriticalSectionAndSpinCount(&RpcHeapLock, PREALLOCATE_EVENT_MASK))
                {
                fHeapInitialized = 1;
                }
            }

        if (0 == fHeapInitialized )
            {
            return(RPC_S_OUT_OF_MEMORY);
            }
        }

    if (0 == fBufferCacheInitialized)
        {
        RPC_STATUS status = RPC_S_OK;
        gBufferCache = new BCACHE(status);

        if (   0 == gBufferCache
            || status != RPC_S_OK )
            {
            delete gBufferCache;
            return(RPC_S_OUT_OF_MEMORY);
            }
        fBufferCacheInitialized = TRUE;
        }


    return(RPC_S_OK);
}

#define RPC_GUARD 0xA1

typedef struct _RPC_MEMORY_BLOCK
{
    // First,forward and backward links to other RPC heap allocations.
    // These are first allow easy debugging with the dl command
    struct _RPC_MEMORY_BLOCK *next;
    struct _RPC_MEMORY_BLOCK *previous;

    // Specifies the size of the block of memory in bytes.
    unsigned long size;

    // Thread id of allocator
    unsigned long tid;

    void *          AllocStackTrace[4];

    // (Pad to make header 0 mod 8) 0 when allocated, 0xF0F0F0F0 when freed.
    unsigned long free;

    // Reserve an extra 4 bytes as the front guard of each block.
    unsigned char frontguard[4];

    // Data will appear here.  Note that the header must be 0 mod 8.

    // Reserve an extra 4 bytes as the rear guard of each block.
    unsigned char rearguard[4];

} RPC_MEMORY_BLOCK;

//
// Compile-time test to ensure that RPC_MEMORY_BLOCK.rearguard is aligned on
// natural boundary.
//

#if defined(_WIN64)
C_ASSERT( (FIELD_OFFSET( RPC_MEMORY_BLOCK, rearguard ) % 16) == 0 );
#else
C_ASSERT( (FIELD_OFFSET( RPC_MEMORY_BLOCK, rearguard ) % 8) == 0 );
#endif

RPC_MEMORY_BLOCK * AllocatedBlocks = 0;
unsigned long BlockCount = 0;

int
CheckMemoryBlock (
    RPC_MEMORY_BLOCK * block
    )
{
    if (   block->frontguard[0] != RPC_GUARD
        || block->frontguard[1] != RPC_GUARD
        || block->frontguard[2] != RPC_GUARD
        || block->frontguard[3] != RPC_GUARD )
        {
        PrintToDebugger("RPC : BAD BLOCK (front) @ %p\n", block);
        ASSERT(0);
        return(1);
        }

    if (   block->rearguard[block->size]   != RPC_GUARD
        || block->rearguard[block->size+1] != RPC_GUARD
        || block->rearguard[block->size+2] != RPC_GUARD
        || block->rearguard[block->size+3] != RPC_GUARD )
        {
        PrintToDebugger("RPC : BAD BLOCK (rear) @ %p (%p)\n",block, &block->rearguard[block->size]);
        ASSERT(0);
        return(1);
        }

    ASSERT(block->free == 0);

    if ( block->next != 0)
       {
       ASSERT(block->next->previous == block);
       }

    if ( block->previous != 0)
       {
       ASSERT(block->previous->next == block);
       }

    return(0);
}

int
RpcValidateHeapList(
    void
    )
// Called with RpcHeapLock held.
{
    RPC_MEMORY_BLOCK * block;
    unsigned Blocks = 0;

    // Under stress this check causes performance to drop too much.
    // Compile with -DNO_HEAP_SLOWDOWN or ed the flag in memory
    // to speed things up.

    if (fMemoryCheck == 0)
        {
        return(0);
        }

    block = AllocatedBlocks;

    while (block != 0)
        {
        if (CheckMemoryBlock(block))
            {
            return(1);
            }
        block = block->next;
        Blocks++;
        }

    ASSERT(Blocks == BlockCount);

    return(0);
}

int
RpcpCheckHeap (
    void
    )
// Returns 0 if the heap appears to be okay.
{
    if (fMemoryCheck == 0)
        {
        return(0);
        }

    EnterCriticalSection(&RpcHeapLock);

    int ret = RpcValidateHeapList();

    LeaveCriticalSection(&RpcHeapLock);

    return(ret);
}

void * __cdecl
operator new(
    size_t size
    )
{
    RPC_MEMORY_BLOCK * block;

    EnterCriticalSection(&RpcHeapLock);

    ASSERT( ("You allocated a negative amount",
            size < (size + sizeof(RPC_MEMORY_BLOCK))) );

    RpcValidateHeapList();
    if (DebugFlags & RPC_FAIL_ALLOCATIONS)
        {
        if ((GetTickCount() % 13) == 0)
            {
            LeaveCriticalSection(&RpcHeapLock);

            PrintToDebugger("RPC: Purposely failed an allocation\n") ;
            return 0;
            }
        }

    block = (RPC_MEMORY_BLOCK *)AllocWrapper(size + sizeof(RPC_MEMORY_BLOCK));

    if ( block == 0 )
        {
        LeaveCriticalSection(&RpcHeapLock);
        return(0);
        }

    block->size = size;
    block->tid = GetCurrentThreadId();
    block->free = 0;

    if (AllocatedBlocks != 0)
        AllocatedBlocks->previous = block;

    block->next = AllocatedBlocks;
    block->previous = 0;
    AllocatedBlocks = block;
    BlockCount++;

    block->frontguard[0] = RPC_GUARD;
    block->frontguard[1] = RPC_GUARD;
    block->frontguard[2] = RPC_GUARD;
    block->frontguard[3] = RPC_GUARD;

    #if i386
    ULONG ignore;

    RtlCaptureStackBackTrace(
                             2,
                             4,
                             (void **) &block->AllocStackTrace,
                             &ignore);
    #endif


    block->rearguard[size]   = RPC_GUARD;
    block->rearguard[size+1] = RPC_GUARD;
    block->rearguard[size+2] = RPC_GUARD;
    block->rearguard[size+3] = RPC_GUARD;

    LeaveCriticalSection(&RpcHeapLock);

    return(&(block->rearguard[0]));
}

void __cdecl
operator delete (
    IN void * obj
    )
{
    RPC_MEMORY_BLOCK * block;

    if (obj == 0)
        return;

    EnterCriticalSection(&RpcHeapLock);

    block = (RPC_MEMORY_BLOCK *) (((unsigned char *) obj)
                    - FIELD_OFFSET(RPC_MEMORY_BLOCK, rearguard));

    // Validate block being freed.

    CheckMemoryBlock(block);

    if (block->next != 0)
        {
        CheckMemoryBlock(block->next);
        }

    if (block->previous != 0)
        {
        CheckMemoryBlock(block->previous);
        }

    // Remove the block from the list

    if (block == AllocatedBlocks)
        AllocatedBlocks = block->next;

    if (block->next != 0)
        block->next->previous = block->previous;

    if (block->previous != 0)
        block->previous->next = block->next;

    // Mark this block as free
    block->free = 0xF0F0F0F0;

    // Validate other RPC allocations.
    BlockCount-- ;
    RpcValidateHeapList();

    LeaveCriticalSection(&RpcHeapLock);

    FreeWrapper(block);
}

#endif // DEBUGRPC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\mutex.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1990 - 1999
//
//  File:       mutex.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

                      Microsoft OS/2 LAN Manager
                   Copyright(c) Microsoft Corp., 1990

-------------------------------------------------------------------- */
/* --------------------------------------------------------------------

File: mutex.cxx

Description:

This file contains the system independent mutex class for NT.

History:

mikemon    ??-??-??    The beginning.
mikemon    12-31-90    Upgraded the comments.

-------------------------------------------------------------------- */

#include <precomp.hxx>


void
MUTEX::CommonConstructor (
    OUT RPC_STATUS PAPI * RpcStatus,
    IN DWORD dwSpinCount
    )
/*++

Routine Description:

    We construct a mutex in this routine; the only interesting part is that
    we need to be able to return a success or failure status.

Arguments:

    RpcStatus - Returns either RPC_S_OK or RPC_S_OUT_OF_MEMORY.

--*/
{
    CriticalSection.DebugInfo = 0;

    if ( *RpcStatus == RPC_S_OK )
        {
        if ( NT_SUCCESS(RtlInitializeCriticalSectionAndSpinCount(&CriticalSection, dwSpinCount)) )
            {
            *RpcStatus = RPC_S_OK;
            }
        else
            {
            *RpcStatus = RPC_S_OUT_OF_MEMORY;
            }
        }

#ifdef NO_RECURSIVE_MUTEXES
    RecursionCount = 0;
#endif // NO_RECURSIVE_MUTEXES
}


void MUTEX::Free(void)
{
    NTSTATUS NtStatus;

    if ( IsSuccessfullyInitialized() )
        {
        NtStatus = RtlDeleteCriticalSection(&CriticalSection);
        ASSERT(NT_SUCCESS(NtStatus));
        }
}

#ifdef DEBUGRPC

void
MUTEX::EnumOwnedCriticalSections()
{
    CRITICAL_SECTION_DEBUG * DebugInfo;

    return;

    HANDLE MyThreadId = ULongToPtr(GetCurrentThreadId());
    DWORD  Count      = NtCurrentTeb()->CountOfOwnedCriticalSections;

//    if (!Count)
//        {
//        DbgPrint("thread %x: taking %x\n", &CriticalSection);
//        return;
//        }

    DbgPrint("thread %x owns the following %d critical section(s):\n",
             MyThreadId, Count
             );

    DebugInfo = CriticalSection.DebugInfo;

    BOOL Found = FALSE;

    for (;;)
        {
        DebugInfo = CONTAINING_RECORD( DebugInfo->ProcessLocksList.Flink,
                                       RTL_CRITICAL_SECTION_DEBUG,
                                       ProcessLocksList
                                       );

        if (!DebugInfo->ProcessLocksList.Flink)
            {
//            DbgPrint("null forward link\n");
            break;
            }

        if (DebugInfo->ProcessLocksList.Flink == &CriticalSection.DebugInfo->ProcessLocksList)
            {
//            DbgPrint("circular list complete\n");
            break;
            }

//        DbgPrint("mutex %x owner %x\n",
//                 DebugInfo->CriticalSection,
//                 DebugInfo->CriticalSection
//                 ? DebugInfo->CriticalSection->OwningThread
//                 : 0
//                 );

        if (DebugInfo->CriticalSection &&
            DebugInfo->CriticalSection->OwningThread == MyThreadId)
            {
            DbgPrint("    %x\n", DebugInfo->CriticalSection);
            Found = TRUE;
            }
        }

    if (Found)
        {
        DbgPrint("and is taking %x\n", &CriticalSection);
        DbgBreakPoint();
        }
}

#endif  // DEBUG


void
MUTEX3::Request()
{
    if (guard.Increment() > 0)
        {
        if (owner == GetCurrentThreadId())
            {
            guard.Decrement();

            ASSERT(guard.GetInteger() >= 0);

            recursion++;
            return;
            }

        event.Wait();

        ASSERT(guard.GetInteger() >= 0);
        }

    ASSERT(owner == 0);
    ASSERT(recursion == 0);

    owner = GetCurrentThreadId();
    recursion = 1;
    return;
}


void 
MUTEX3::Clear()
{
    ASSERT(owner == GetCurrentThreadId());
    ASSERT(recursion > 0);

    if ( --recursion > 0)
        {
        return;
        }

    owner = 0;

    if (guard.Decrement() >= 0)
        {
        event.Raise();
        }
}

BOOL
MUTEX3::TryRequest()
{
    if (guard.CompareExchange(0, -1) == -1)
        {
        // Lock wasn't owned, now we own it.
        owner = GetCurrentThreadId();
        recursion = 1;
        return TRUE;
        }

    if (owner == GetCurrentThreadId())
        {
        // We can aquire it recursivly, just increment the count
        recursion++;
        return TRUE;
        }

    // Owned by another thread

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\miscnt.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    miscnt.cxx

Abstract:

    This file contains NT specific implementations of miscellaneous
    routines.

Author:

    Michael Montague (mikemon) 25-Nov-1991

Revision History:

    Kamen Moutafov (KamenM) Dec 99 - Feb 2000 - Support for cell debugging stuff
    Kamen Moutafov      (KamenM)    Mar-2000    Support for extended error info
--*/

#include <precomp.hxx>
#include <rpccfg.h>
#include <CharConv.hxx>

static const char *RPC_REGISTRY_PROTOCOLS =
    "Software\\Microsoft\\Rpc\\ClientProtocols";

static const char *RPC_REGISTRY_PROTOCOL_IDS =
    "Software\\Microsoft\\Rpc\\AdditionalProtocols";

static const RPC_CHAR *RPC_REGISTRY_DEFAULT_SECURITY_DLL =
    L"System\\CurrentControlSet\\Control\\SecurityProviders";

// N.B. This value must agree with the key specified in the system.adm file
static const RPC_CHAR *RPC_POLICY_SETTINGS = 
    L"Software\\Policies\\Microsoft\\Windows NT\\Rpc";

static const RPC_CHAR *RPC_REGISTRY_IMAGE_FILE_EXEC =
    L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\";

static const RPC_CHAR *RPC_REGISTRY_THREAD_THROTTLE =
    L"\\RpcThreadPoolThrottle";

const int IMAGE_FILE_EXEC_LENGTH = 75;
const int THREAD_THROTTLE_LENGTH = 24;

#define MAX_ENDPOINT_LENGTH 128
#define MAX_ID_LENGTH 6
#define MAX_DLL_NAME 128

typedef struct
{
    const RPC_CHAR * RpcProtocolSequence;
    const RPC_CHAR * TransportInterfaceDll;
    unsigned long TransportId;
} RPC_PROTOCOL_SEQUENCE_MAP;

static const RPC_PROTOCOL_SEQUENCE_MAP RpcProtocolSequenceMap[] =
{
    {
    RPC_CONST_STRING("ncacn_np"),
    RPC_CONST_STRING("rpcrt4.dll"),
    NMP_TOWER_ID
    },

    {
    RPC_CONST_STRING("ncacn_ip_tcp"),
    RPC_CONST_STRING("rpcrt4.dll"),
    TCP_TOWER_ID
    },

#ifdef SPX_ON
    {
    RPC_CONST_STRING("ncacn_spx"),
    RPC_CONST_STRING("rpcrt4.dll"),
    SPX_TOWER_ID
    },
#endif

    {
    RPC_CONST_STRING("ncadg_ip_udp"),
    RPC_CONST_STRING("rpcrt4.dll"),
    UDP_TOWER_ID
    },

#ifdef IPX_ON
    {
    RPC_CONST_STRING("ncadg_ipx"),
    RPC_CONST_STRING("rpcrt4.dll"),
    IPX_TOWER_ID
    },
#endif

#ifdef NETBIOS_ON
    {
    RPC_CONST_STRING("ncacn_nb_tcp"),
    RPC_CONST_STRING("rpcrt4.dll"),
    NB_TOWER_ID
    },

    {
    RPC_CONST_STRING("ncacn_nb_ipx"),
    RPC_CONST_STRING("rpcrt4.dll"),
    NB_TOWER_ID
    },

    {
    RPC_CONST_STRING("ncacn_nb_nb"),
    RPC_CONST_STRING("rpcrt4.dll"),
    NB_TOWER_ID
    },
#endif

#ifdef APPLETALK_ON
    {
    RPC_CONST_STRING("ncacn_at_dsp"),
    RPC_CONST_STRING("rpcrt4.dll"),
    DSP_TOWER_ID
    },
#endif

    {
    RPC_CONST_STRING("ncacn_http"),
    RPC_CONST_STRING("rpcrt4.dll"),
    HTTP_TOWER_ID
    },

    {
    RPC_CONST_STRING("ncadg_cluster"),
    RPC_CONST_STRING("rpcrt4.dll"),
    CDP_TOWER_ID
    },

#ifdef NCADG_MQ_ON
    {
    RPC_CONST_STRING("ncadg_mq"),
    RPC_CONST_STRING("rpcrt4.dll"),
    MQ_TOWER_ID
    },
#endif

#ifdef BANYAN_ON
    {
    RPC_CONST_STRING("ncacn_vns_spp"),
    RPC_CONST_STRING("rpcrt4.dll"),
    SPP_TOWER_ID
    },
#endif

    {
    RPC_CONST_STRING("ncalrpc"),
    0,
    0
    },
};

const int RpcProtseqMapLength = (sizeof(RpcProtocolSequenceMap)
                                / sizeof(RPC_PROTOCOL_SEQUENCE_MAP));

static const RPC_PROTOCOL_SEQUENCE_MAP RpcUseAllProtseqMap[] =
{
    {
    RPC_CONST_STRING("ncacn_np"),
    RPC_CONST_STRING("rpcrt4.dll"),
    NMP_TOWER_ID
    },

    {
    RPC_CONST_STRING("ncalrpc"),
    0,
    0
    },
};

const int RpcUseAllProtseqMapLength = (sizeof(RpcUseAllProtseqMap)
                                / sizeof(RPC_PROTOCOL_SEQUENCE_MAP));


typedef struct
{
    unsigned char * RpcProtocolSequence;
    unsigned char * RpcSsEndpoint;
    unsigned long    TransportId;
} RPC_PROTOCOL_INFO;


RPC_PROTOCOL_INFO * AdditionalProtocols = 0;
unsigned long TotalAdditionalProtocols = 0;

static const char *RPC_REGISTRY_SECURITY_PROVIDERS =
                "Software\\Microsoft\\Rpc\\SecurityService";
static const char *RPC_MISC_SETTINGS =
                "Software\\Microsoft\\Rpc";

BOOL  DefaultProviderRead = FALSE;
DWORD DefaultAuthLevel  = RPC_C_AUTHN_LEVEL_CONNECT;
DWORD DefaultProviderId = RPC_C_AUTHN_WINNT;

RPC_CHAR *DefaultSecurityDLL = L"secur32.dll";
BOOL DefaultSecurityDLLRead = FALSE;

void
GetMaxRpcSizeAndThreadPoolParameters (
    void
    )
{
    HKEY RegistryKey;

    DWORD Result;
    DWORD RegStatus;
    DWORD Type;
    DWORD DwordSize = sizeof(DWORD);
    RPC_CHAR KeyName[MAX_PATH + IMAGE_FILE_EXEC_LENGTH + THREAD_THROTTLE_LENGTH];
    const RPC_CHAR * ModuleName;
    int ModuleLength;
    RPC_CHAR *CurrentPos;

    //
    // Get the default Rpc size.
    //
    RegStatus = RegOpenKeyExA(
                    HKEY_LOCAL_MACHINE,
                    (LPSTR) RPC_MISC_SETTINGS,
                    0L, KEY_READ,                      //Reserved
                    &RegistryKey
                    );

    if ( RegStatus != ERROR_SUCCESS )
        {
        return;
        }

    RegStatus = RegQueryValueExA(
                    RegistryKey,
                    "MaxRpcSize",
                    0,
                    &Type,
                    (LPBYTE) &Result,
                    &DwordSize
                    );

    if (RegStatus == ERROR_SUCCESS
        && Type == REG_DWORD)
        {
        gMaxRpcSize = Result;
        }

    RegCloseKey(RegistryKey);
    
    //
    // Find out the .EXE name.
    //
    ModuleName = FastGetImageBaseName();
    ModuleLength = RpcpStringLength(ModuleName);

    CurrentPos = KeyName;
    RpcpMemoryCopy(CurrentPos, 
        RPC_REGISTRY_IMAGE_FILE_EXEC, 
        IMAGE_FILE_EXEC_LENGTH * 2);

    CurrentPos += IMAGE_FILE_EXEC_LENGTH - 1;
    RpcpMemoryCopy(CurrentPos, 
        ModuleName, 
        ModuleLength * 2);

    CurrentPos += ModuleLength;
    RpcpMemoryCopy(CurrentPos, 
        RPC_REGISTRY_THREAD_THROTTLE, 
        THREAD_THROTTLE_LENGTH * 2);

    RegStatus = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    KeyName,
                    0L, KEY_READ,                      //Reserved
                    &RegistryKey
                    );

    if ( RegStatus != ERROR_SUCCESS )
        {
        return;
        }

    DwordSize = sizeof(DWORD);

    RegStatus = RegQueryValueExA(
                    RegistryKey,
                    "ProrateMax",
                    0,
                    &Type,
                    (LPBYTE) &Result,
                    &DwordSize
                    );

    if (RegStatus == ERROR_SUCCESS
        && Type == REG_DWORD)
        {
        gProrateMax = Result;
        }

    DwordSize = sizeof(DWORD);

    RegStatus = RegQueryValueExA(
                    RegistryKey,
                    "ProrateFactor",
                    0,
                    &Type,
                    (LPBYTE) &Result,
                    &DwordSize
                    );

    if (RegStatus == ERROR_SUCCESS
        && Type == REG_DWORD)
        {
        gProrateFactor = Result;
        }

    DwordSize = sizeof(DWORD);

    RegStatus = RegQueryValueExA(
                    RegistryKey,
                    "ProrateStart",
                    0,
                    &Type,
                    (LPBYTE) &Result,
                    &DwordSize
                    );

    if (RegStatus == ERROR_SUCCESS
        && Type == REG_DWORD)
        {
        gProrateStart = Result;
        }

    RegCloseKey(RegistryKey);

    // if any of these values are invalid, turn it off
    if ((gProrateFactor == 0) || (gProrateMax == 0))
        gProrateStart = 0;
}


BOOL
GetDefaultLevel()
{
    HKEY RegistryKey;

    DWORD Result;
    DWORD RegStatus;
    DWORD Type;
    DWORD DwordSize = sizeof(DWORD);

    //
    // Get the default provider level.
    //
    RegStatus = RegOpenKeyExA(
                    HKEY_LOCAL_MACHINE,
                    (LPSTR) RPC_REGISTRY_SECURITY_PROVIDERS,
                    0L, KEY_READ,                      //Reserved
                    &RegistryKey
                    );

    if ( RegStatus != ERROR_SUCCESS )
        {
        return FALSE;
        }

    RegStatus = RegQueryValueExA(
                    RegistryKey,
                    "DefaultAuthLevel",
                    0,
                    &Type,
                    (LPBYTE) &Result,
                    &DwordSize
                    );

    if (RegStatus == ERROR_CANTOPEN ||
        RegStatus == ERROR_CANTREAD )
        {
        RegCloseKey(RegistryKey);
        return TRUE;
        }

    if ( RegStatus != ERROR_SUCCESS )
        {
        RegCloseKey(RegistryKey);
        return FALSE;
        }

    if ( Type != REG_DWORD )
        {
        RegCloseKey(RegistryKey);
        return TRUE;
        }

    if (Result >= RPC_C_AUTHN_LEVEL_CONNECT     &&
        Result <= RPC_C_AUTHN_LEVEL_PKT_PRIVACY )
        {
        DefaultAuthLevel = Result;
        }

    RegCloseKey(RegistryKey);
    return TRUE;
}


void
RpcpGetDefaultSecurityProviderInfo()
{
    if (DefaultProviderRead)
        {
        return;
        }

    if (GetDefaultLevel())
        {
        DefaultProviderRead = TRUE;
        }
}

RPC_STATUS
GetDefaultSecurityDll (
    IN RPC_CHAR *DllName,
    IN ULONG DllNameLength
    )
{
    HKEY RegistryKey;
    DWORD RegStatus;
    RPC_CHAR *DuplicateDllName;
    DWORD Type;

    if (DefaultSecurityDLLRead == FALSE)
        {
        RegStatus = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    RPC_REGISTRY_DEFAULT_SECURITY_DLL,
                    0L, KEY_READ,                      //Reserved
                    &RegistryKey
                    );

        if ( RegStatus != ERROR_SUCCESS )
            {
            if (RegStatus == ERROR_FILE_NOT_FOUND)
                {
                DefaultSecurityDLLRead = TRUE;
                return RPC_S_OK;
                }

            return(RPC_S_UNKNOWN_AUTHN_SERVICE);
            }


        RegStatus = RegQueryValueEx(
                    RegistryKey,
                    L"ClientDll",
                    0,
                    &Type,
                    (unsigned char *)DllName,
                    &DllNameLength
                    );

        if ( RegStatus != ERROR_SUCCESS )
            {
            RegCloseKey(RegistryKey);
            if (RegStatus == ERROR_FILE_NOT_FOUND)
                {
                DefaultSecurityDLLRead = TRUE;
                return RPC_S_OK;
                }

            return(RPC_S_UNKNOWN_AUTHN_SERVICE);
            }

        if (Type != REG_SZ)
            {
            RegCloseKey(RegistryKey);
            return(RPC_S_UNKNOWN_AUTHN_SERVICE);
            }

        DuplicateDllName = DuplicateString(DllName);

        RegCloseKey(RegistryKey);

        if (DuplicateDllName)
            {
            DefaultSecurityDLL = DuplicateDllName;
            DefaultSecurityDLLRead = TRUE;
            }
        else
            {
            return RPC_S_OUT_OF_MEMORY;
            }

        }

    return RPC_S_OK;
}

RPC_STATUS
RpcGetSecurityProviderInfo(
    IN unsigned long AuthnId,
    OUT RPC_CHAR **Dll,
    OUT unsigned long PAPI * Count
    )
{

    DWORD RegStatus, Ignore, NumberOfValues, MaximumValueLength;
    unsigned long DllNameLength = MAX_DLL_NAME+1;
    DWORD ClassLength = 64, Type;
    RPC_CHAR DllName[MAX_DLL_NAME+1];
    FILETIME LastWriteTime;
    HKEY RegistryKey;
    unsigned char ClassName[64];
    RPC_STATUS Status = RPC_S_OK;
    char AuthnIdZ[8];
    RPC_CHAR unicodeAuthnIdZ[8];
    RPC_CHAR *pAuthnIdZ;
    RPC_CHAR *ActualDllName;

    RpcItoa(AuthnId, AuthnIdZ, 10);

    RegStatus = RegOpenKeyExA(
                    HKEY_LOCAL_MACHINE,
                    (LPSTR) RPC_REGISTRY_SECURITY_PROVIDERS,
                    0L, KEY_READ,                      //Reserved
                    &RegistryKey
                    );

    if ( RegStatus != ERROR_SUCCESS )
        {
        return(RPC_S_UNKNOWN_AUTHN_SERVICE);
        }

    RegStatus = RegQueryInfoKeyA(
                    RegistryKey,
                    (LPSTR) ClassName,
                    &ClassLength,
                    0,                                //Reserved
                    &Ignore,
                    &Ignore,
                    &Ignore,
                    &NumberOfValues,
                    &Ignore,
                    &MaximumValueLength,
                    &Ignore,
                    &LastWriteTime
                    );

    if ( (RegStatus != ERROR_SUCCESS) || (NumberOfValues < 2) )
        {
        RegStatus = RegCloseKey(RegistryKey);
        ASSERT( RegStatus == ERROR_SUCCESS );
        return(RPC_S_UNKNOWN_AUTHN_SERVICE);
        }

    *Count = NumberOfValues - 2;    //Gross

    SimpleAnsiToUnicode(AuthnIdZ, unicodeAuthnIdZ);
    pAuthnIdZ = unicodeAuthnIdZ;

    RegStatus = RegQueryValueEx(
                    RegistryKey,
                    (const RPC_SCHAR *)pAuthnIdZ,
                    0,
                    &Type,
                    (unsigned char *)DllName,
                    &DllNameLength
                    );

    RegCloseKey(RegistryKey);

    if (RegStatus != ERROR_SUCCESS)
        {
        RegStatus = GetDefaultSecurityDll(
            DllName, 
            DllNameLength);

        if (RegStatus == RPC_S_OK)
            ActualDllName = DefaultSecurityDLL;
        }
    else
        {
        ActualDllName = DllName;
        }

    if (RegStatus == ERROR_SUCCESS)
        {
        *Dll = DuplicateString(ActualDllName);
        if (*Dll == 0)
            {
            RegStatus = RPC_S_OUT_OF_MEMORY;
            }
        }
    else
        {
        RegStatus = RPC_S_UNKNOWN_AUTHN_SERVICE;
        }

    return(RegStatus);
}

DWORD * FourLeggedPackages = 0;
DWORD NullPackageList[] = { 0 };



BOOL
ReadPackageLegInfo()
/*++

Routine Description:

    NT 4.0 and previous versions allowed only two or three legs to set up the
    security context.  Two were represented on the wire as BIND then BIND_ACK;
    three added an AUTH3 packet.  When Jeff added 4- and 6-leg support, he
    made the sequence BIND, BIND-ACK, ALTER-CXT, ALTER-CXT-RESPONSE.  Sadly,
    it turns out to be impossible for RPC to tell whether a given package wants
    three or four legs, so the client would have to guess whether to send
    an AUTH3 or an ALTER-CXT to an NT 4 server. To solve this we are adding a
    registry value that lists all the providers that need more than three legs.

    The format, in regdmp.exe form, is

        \Registry\Machine\Software\Microsoft\Rpc
            Four-legged packages = REG_MULTI_SZ "16" "18" ""

    This function opens the registry and converts this data into an in-memory
    array of DWORD package IDs.

    Not all packages are in this list; see GetPackageLegCount() for details.

Return Values:

    TRUE = the registry data was read, or the value does not exist.
           Calling this function again will have no effect.

    FALSE = there was a problem reading the data in the registry.
            You can call the fn later and it will try again.

--*/
{
    DWORD Size = 0;
    DWORD RegStatus;
    DWORD Type;
    HKEY RegistryKey;
    wchar_t * Strings;

    if (FourLeggedPackages)
        {
        return TRUE;
        }

    SecurityCritSect->VerifyOwned();

    // open key;
    RegStatus = RegOpenKeyExA(
                    HKEY_LOCAL_MACHINE,
                    (LPSTR) RPC_REGISTRY_SECURITY_PROVIDERS,
                    0L, KEY_READ,                      //Reserved
                    &RegistryKey
                    );

    if ( RegStatus != ERROR_SUCCESS )
        {
        return FALSE;
        }

    // get size of strings

    RegStatus = RegQueryValueExW(
                    RegistryKey,
                    L"Four-legged packages",
                    0,
                    &Type,
                    0,
                    &Size
                    );

    if (RegStatus == ERROR_FILE_NOT_FOUND )
        {
        RegCloseKey(RegistryKey);

        FourLeggedPackages = NullPackageList;
        return TRUE;
        }

    if ( RegStatus != ERROR_SUCCESS )
        {
        RegCloseKey(RegistryKey);
        return FALSE;
        }

    //
    // Place an upper bound on the size to avoid hacker attacks.
    //
    if ( Type != REG_MULTI_SZ || Size > 4000)
        {
        RegCloseKey(RegistryKey);
        FourLeggedPackages = NullPackageList;
        return TRUE;
        }

    // get string data.

    Strings = (wchar_t *) _alloca( Size );

    RegStatus = RegQueryValueExW(
                    RegistryKey,
                    L"Four-legged packages",
                    0,
                    &Type,
                    (unsigned char *) Strings,
                    &Size
                    );

    RegCloseKey(RegistryKey);

    if (RegStatus == ERROR_CANTOPEN ||
        RegStatus == ERROR_CANTREAD )
        {
        FourLeggedPackages = NullPackageList;
        return TRUE;
        }

    if ( RegStatus != ERROR_SUCCESS )
        {
        return FALSE;
        }

    if ( Type != REG_MULTI_SZ )
        {
        FourLeggedPackages = NullPackageList;
        return TRUE;
        }

    // count strings; the buffer is terminated by an empty string that will be counted.

    int Count = 0;
    wchar_t * p;
    for (p=Strings; p < Strings + Size; ++p)
        {
        if (*p == '\0')
            {
            ++Count;
            }
        }

    // allocate memory.

    DWORD * LegData = new DWORD[Count];
    if (!LegData)
        {
        return FALSE;
        }

    // transfer data
    int i;
    wchar_t * new_p;
    for (i=0, p=Strings; p < Strings + Size; ++i, p = new_p+1)
        {
        LegData[i] = wcstoul(p, &new_p, 10);
        if (*new_p != '\0')
            {
            // The string is badly formatted. Eliminate it.
            --i;
            new_p += wcslen(new_p);
            }
        }

    if (FourLeggedPackages && FourLeggedPackages != NullPackageList)
        {
        delete FourLeggedPackages;
        }

    FourLeggedPackages = LegData;

    return TRUE;
}


RPC_STATUS
LoadAdditionalTransportInfo(
    )
{

    DWORD RegStatus, Index, Ignore, NumberOfValues, MaximumValueLength;
    DWORD ClassLength = 64, ProtseqLength, IgnoreLength;
    BYTE Protseq[MAX_PROTSEQ_LENGTH+1];
    BYTE MaxValueData[MAX_ENDPOINT_LENGTH+MAX_ID_LENGTH+2+8];
    FILETIME LastWriteTime;
    HKEY RegistryKey;
    unsigned char ClassName[64];
    char * Value;
    RPC_PROTOCOL_INFO * AdditionalProtocolsInfo;
    RPC_STATUS Status = RPC_S_OK;
    unsigned long Length, TransportId;

    RegStatus = RegOpenKeyExA(
                    HKEY_LOCAL_MACHINE,
                    (LPSTR) RPC_REGISTRY_PROTOCOL_IDS,
                    0L, KEY_READ,                      //Reserved
                    &RegistryKey
                    );

    if ( RegStatus != ERROR_SUCCESS )
        {
        return(RPC_S_INVALID_RPC_PROTSEQ);
        }

    RegStatus = RegQueryInfoKeyA(
                    RegistryKey,
                    (LPSTR) ClassName,
                    &ClassLength,
                    0,                                //Reserved
                    &Ignore,
                    &Ignore,
                    &Ignore,
                    &NumberOfValues,
                    &Ignore,
                    &MaximumValueLength,
                    &Ignore,
                    &LastWriteTime
                    );

    if ( (RegStatus != ERROR_SUCCESS) || (NumberOfValues == 0) )
        {
        RegStatus = RegCloseKey(RegistryKey);
        ASSERT( RegStatus == ERROR_SUCCESS );
        return(RPC_S_INVALID_RPC_PROTSEQ);
        }

    //Allocate a table for additional transports mapping

    AdditionalProtocolsInfo = (RPC_PROTOCOL_INFO *) new unsigned char [
                                  sizeof(RPC_PROTOCOL_INFO) *  NumberOfValues];
    if (AdditionalProtocolsInfo == 0)
       {
       Status = RPC_S_OUT_OF_MEMORY;
       goto Cleanup;
       }

    AdditionalProtocols = AdditionalProtocolsInfo;
    TotalAdditionalProtocols = NumberOfValues;

    for (Index = 0; Index < NumberOfValues; Index++)
        {

        ProtseqLength = MAX_PROTSEQ_LENGTH;
        IgnoreLength = MAX_ENDPOINT_LENGTH + MAX_ID_LENGTH;
        RegStatus = RegEnumValueA(
                         RegistryKey,
                         Index,
                         (LPSTR) &Protseq,
                         &ProtseqLength,
                         0,
                         &Ignore,
                         (LPBYTE) MaxValueData,
                         &IgnoreLength
                         );

        if (RegStatus == ERROR_SUCCESS)
           {
           //Add this to our table..
           AdditionalProtocolsInfo->RpcProtocolSequence =
                               new unsigned char[ProtseqLength+1];
           Value = (char  * )&MaxValueData;
           AdditionalProtocolsInfo->RpcSsEndpoint =
                      new unsigned char[Length = (strlen(Value) + 1)];


           if (AdditionalProtocolsInfo->RpcProtocolSequence == 0
               || AdditionalProtocolsInfo->RpcSsEndpoint == 0)
              {
              Status = RPC_S_OUT_OF_MEMORY;
              goto Cleanup;
              }

           RpcpMemoryCopy(
                  AdditionalProtocolsInfo->RpcProtocolSequence,
                  Protseq,
                  ProtseqLength+1
                  );

           RpcpMemoryCopy(
                  AdditionalProtocolsInfo->RpcSsEndpoint,
                  Value,
                  Length
                  );
           Value = Value + Length;

           for (TransportId = 0;
                (*Value > '0') && (*Value <= '9') && (TransportId <= 255);
                Value++)
               {
               TransportId = TransportId * 10 + (*Value - '0');
               }
           AdditionalProtocolsInfo->TransportId = TransportId;

           AdditionalProtocolsInfo++;
           }

        }

Cleanup:
    RegStatus = RegCloseKey(RegistryKey);

    if (Status != RPC_S_OK)
       {
       if (AdditionalProtocols != 0)
          {
          AdditionalProtocolsInfo = AdditionalProtocols;
          for (Index = 0; Index < NumberOfValues; Index++)
              {
              if (AdditionalProtocolsInfo->RpcProtocolSequence != 0)
                  delete AdditionalProtocolsInfo->RpcProtocolSequence;
              if (AdditionalProtocolsInfo->RpcSsEndpoint != 0)
                  delete AdditionalProtocolsInfo->RpcSsEndpoint;
              AdditionalProtocolsInfo++;
              }

          delete AdditionalProtocols;
          AdditionalProtocols = 0;
          TotalAdditionalProtocols = 0;
          }
       }

    return(Status);
}


RPC_STATUS
RpcGetAdditionalTransportInfo(
    IN unsigned long TransportId,
    OUT unsigned char PAPI * PAPI * ProtocolSequence
    )
{
   unsigned long i;
   RPC_PROTOCOL_INFO * ProtocolInfo;

   RequestGlobalMutex();

   if (AdditionalProtocols == 0)
      {
      LoadAdditionalTransportInfo();
      }

   ClearGlobalMutex();

   for (i = 0, ProtocolInfo = AdditionalProtocols ;
        i < TotalAdditionalProtocols;
        i++)
       {
       if (ProtocolInfo->TransportId == TransportId)
          {
          *ProtocolSequence = ProtocolInfo->RpcProtocolSequence;
          return (RPC_S_OK);
          }
       ProtocolInfo ++;
       }

   return(RPC_S_INVALID_RPC_PROTSEQ);

}



RPC_CHAR *
LocalMapRpcProtocolSequence (
    IN RPC_CHAR PAPI * RpcProtocolSequence
    )
/*++

Routine Description:

    We need to check the supplied protocol sequence (and module) to see
    if we can map them into a transport interface dll without having to
    use the registry.

Arguments:

    ServerSideFlag - Supplies a flag indicating whether this protocol
        sequence is to be mapped for a client or a server; a non-zero
        value indicates that it is being mapped for a server.

    RpcProtocolSequence - Supplies the protocol sequence which we need to
        map into a transport interface dll.

Return Value:

    If we successfully map the protocol sequence, then a pointer to a static
    string containing the transport interface dll (name) will be returned;
    the caller must duplicate the string.  Otherwise, zero will be returned.

--*/
{
    unsigned int Index;

    for (Index = 0; Index < RpcProtseqMapLength; Index++)
        {
        if ( RpcpStringCompare(RpcProtocolSequence,
                    RpcProtocolSequenceMap[Index].RpcProtocolSequence) == 0 )
            {
            return((RPC_CHAR *)(RpcProtocolSequenceMap[Index].TransportInterfaceDll));
            }
        }

    return(0);
}

RPC_STATUS
RpcGetWellKnownTransportInfo(
    IN unsigned long TransportId,
    OUT RPC_CHAR **PSeq
    )
{
    unsigned int Index;

    for (Index = 0; Index < RpcProtseqMapLength; Index++)
        {
        if (TransportId == RpcProtocolSequenceMap[Index].TransportId)
            {
            *PSeq = (RPC_CHAR *)RpcProtocolSequenceMap[Index].RpcProtocolSequence;
            return RPC_S_OK;
            }
        }

    return(RPC_S_PROTSEQ_NOT_SUPPORTED);
}


RPC_STATUS
RpcConfigMapRpcProtocolSequence (
    IN unsigned int ServerSideFlag,
    IN RPC_CHAR PAPI * RpcProtocolSequence,
    OUT RPC_CHAR * PAPI * TransportInterfaceDll
    )
/*++

Routine Description:

    This routine is used by the rpc protocol modules to map from an
    rpc protocol sequence to the name of a transport interface dll.

Arguments:

    ServerSideFlag - Supplies a flag indicating whether this protocol
        sequence is to be mapped for a client or a server; a non-zero
        value indicates that it is being mapped for a server.

    RpcProtocolSequence - Supplies the rpc protocol sequence to map.

    TransportInterfaceDll - Returns the transport support dll which
        supports the requested rpc protocol sequence.  This will be a
        newly allocated string which the caller must free.

Return Value:

    RPC_S_OK - Everything worked out fine.

    RPC_S_PROTSEQ_NOT_SUPPORTED - The requested rpc protocol sequence
        does not have a mapping to a transport interface dll for this
        rpc protocol module.

    RPC_S_OUT_OF_MEMORY - We ran out of memory trying to map the rpc
        protocol sequence.

--*/
{
    RPC_CHAR * TempString;
    HKEY RegistryKey;
    DWORD Type;
    long RegStatus;
    unsigned char * KeyString;
    unsigned long Length;

    TempString = LocalMapRpcProtocolSequence(RpcProtocolSequence);
    if ( TempString != 0 )
        {
        *TransportInterfaceDll = new RPC_CHAR[RpcpStringLength(TempString) + 1];
        if ( *TransportInterfaceDll == 0 )
            {
            return(RPC_S_OUT_OF_MEMORY);
            }
        memcpy(*TransportInterfaceDll, TempString,
                (RpcpStringLength(TempString) + 1) * sizeof(RPC_CHAR));
        return(RPC_S_OK);
        }

    KeyString = (unsigned char *) RPC_REGISTRY_PROTOCOLS;

    RegStatus = RegOpenKeyExA(HKEY_LOCAL_MACHINE, (LPSTR) KeyString, 0L,
            KEY_READ, &RegistryKey);
    if ( RegStatus != ERROR_SUCCESS )
        {
        return(RPC_S_PROTSEQ_NOT_SUPPORTED);
        }

    *TransportInterfaceDll = new RPC_CHAR[MAX_DLLNAME_LENGTH + 1];
    if ( *TransportInterfaceDll == 0 )
        {
        RegStatus = RegCloseKey(RegistryKey);
        ASSERT( RegStatus == ERROR_SUCCESS );

        return(RPC_S_OUT_OF_MEMORY);
        }

    Length = (MAX_DLLNAME_LENGTH + 1) * sizeof(RPC_CHAR);
    RegStatus = RegQueryValueEx(RegistryKey, (const RPC_SCHAR *)RpcProtocolSequence,
            0, &Type, (LPBYTE) *TransportInterfaceDll, &Length);

    if ( RegStatus == ERROR_SUCCESS )
        {
        RegStatus = RegCloseKey(RegistryKey);
        ASSERT( RegStatus == ERROR_SUCCESS );

        return(RPC_S_OK);
        }

    RegStatus = RegCloseKey(RegistryKey);
    ASSERT( RegStatus == ERROR_SUCCESS );

    delete *TransportInterfaceDll;

    return(RPC_S_PROTSEQ_NOT_SUPPORTED);
}


RPC_STATUS
RpcConfigInquireProtocolSequencesFromKey (
    OUT RPC_PROTSEQ_VECTOR PAPI * PAPI * ProtseqVector,
    unsigned char *RegistryKeyName
    )
/*++

Routine Description:

    This routine is used to obtain a list of the rpc protocol sequences
    supported by the system using a given registry key as a reference
    point.

Arguments:

    ProtseqVector - Returns a vector of supported rpc protocol sequences
        for this rpc protocol module.
    RegistryKeyName - the path of the registry key, starting from
        HKLM (the HKLM itself should not be supplied)

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_NO_PROTSEQS - The current system configuration does not
        support any rpc protocol sequences.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to inquire
        the rpc protocol sequences supported by the specified rpc
        protocol sequence.

--*/
{
    DWORD RegStatus, Index, Ignore, MaximumValueLength;
    DWORD ClassLength = 64, ProtseqLength, IgnoreLength;
    BYTE IgnoreData[MAX_DLLNAME_LENGTH];
    FILETIME LastWriteTime;
    HKEY RegistryKey = 0;
    unsigned char ClassName[64];
    DWORD NumberOfValues = 0;

    RegStatus = RegOpenKeyExA(HKEY_LOCAL_MACHINE,
            (LPSTR) RegistryKeyName, 0L, KEY_READ, &RegistryKey);

    if ( RegStatus != ERROR_SUCCESS )
        {
        return(RPC_S_NO_PROTSEQS);
        }

    RegStatus = RegQueryInfoKeyA(RegistryKey, (LPSTR) ClassName, &ClassLength,
            0, &Ignore, &Ignore, &Ignore, &NumberOfValues,
            &Ignore, &MaximumValueLength, &Ignore, &LastWriteTime);

    ASSERT( RegStatus == ERROR_SUCCESS );

    if ( RegStatus != ERROR_SUCCESS )
        {
        RegStatus = RegCloseKey(RegistryKey);
        ASSERT( RegStatus == ERROR_SUCCESS );
        return(RPC_S_NO_PROTSEQS);
        }

    NumberOfValues += RpcUseAllProtseqMapLength;

    *ProtseqVector = (RPC_PROTSEQ_VECTOR *) new unsigned char[
            sizeof(RPC_PROTSEQ_VECTOR) + (NumberOfValues - 1)
                    * sizeof(RPC_CHAR *)];

    if ( *ProtseqVector == 0 )
        {
        RegStatus = RegCloseKey(RegistryKey);
        ASSERT( RegStatus == ERROR_SUCCESS );
        return(RPC_S_OUT_OF_MEMORY);
        }

    (*ProtseqVector)->Count = (unsigned int) NumberOfValues;

    for (Index = 0; Index < NumberOfValues; Index++)
        {
        (*ProtseqVector)->Protseq[Index] = 0;
        }

    for (Index = 0; Index < RpcUseAllProtseqMapLength; Index++)
        {
        (*ProtseqVector)->Protseq[Index] = new RPC_CHAR[MAX_PROTSEQ_LENGTH];
        if ( (*ProtseqVector)->Protseq[Index] == 0 )
            {
            RegStatus = RegCloseKey(RegistryKey);
            ASSERT( RegStatus == ERROR_SUCCESS );

            RpcProtseqVectorFree(ProtseqVector);

            return(RPC_S_OUT_OF_MEMORY);
            }

        RpcpStringCopy((*ProtseqVector)->Protseq[Index],
                       RpcUseAllProtseqMap[Index].RpcProtocolSequence);

        }

    unsigned VectorIndex = Index;

    for (Index = 0; VectorIndex < NumberOfValues; Index++, VectorIndex++)
        {
        (*ProtseqVector)->Protseq[VectorIndex] = new RPC_CHAR[MAX_PROTSEQ_LENGTH];
        if ( (*ProtseqVector)->Protseq[VectorIndex] == 0 )
            {
            RegStatus = RegCloseKey(RegistryKey);
            ASSERT( RegStatus == ERROR_SUCCESS );

            RpcProtseqVectorFree(ProtseqVector);

            return(RPC_S_OUT_OF_MEMORY);
            }

        ProtseqLength = MAX_PROTSEQ_LENGTH;
        IgnoreLength = MAX_DLLNAME_LENGTH;
        RegStatus = RegEnumValue(RegistryKey, Index,
                (RPC_SCHAR *)(*ProtseqVector)->Protseq[VectorIndex], &ProtseqLength,
                0, &Ignore, (LPBYTE) IgnoreData, &IgnoreLength);

        ASSERT( RegStatus == ERROR_SUCCESS );

        if (RpcpStringCompare((RPC_SCHAR *)(*ProtseqVector)->Protseq[VectorIndex], RPC_T("ncacn_np")) == 0)
            {
            // ignore this named pipe value - we have to have it in the registry for
            // compatibility purposes with VB, but we don't really use it
            NumberOfValues --;
            (*ProtseqVector)->Count --;
            delete (*ProtseqVector)->Protseq[VectorIndex];
            VectorIndex --;
            }
        }

    RegStatus = RegCloseKey(RegistryKey);
    ASSERT( RegStatus == ERROR_SUCCESS );

    return(RPC_S_OK);
}

RPC_STATUS RpcConfigInquireStaticProtocolSequences(RPC_PROTSEQ_VECTOR **ProtseqVector)
/*++

Routine Description:

    Returns a protseq vector that contains all the protseqs in the static RpcProtocolSequenceMap
        map.

Arguments:

    ProtseqVector - Returns a vector of supported rpc protocol sequences.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to construct the vector.

--*/
{
    int nNumberOfValues = sizeof(RpcProtocolSequenceMap) / sizeof(RpcProtocolSequenceMap[0]);
    int i;

    *ProtseqVector = (RPC_PROTSEQ_VECTOR *) new unsigned char[
            sizeof(RPC_PROTSEQ_VECTOR) + (nNumberOfValues - 1)
                    * sizeof(RPC_CHAR *)];

    if ( *ProtseqVector == 0 )
        return(RPC_S_OUT_OF_MEMORY);

    (*ProtseqVector)->Count = (unsigned int) nNumberOfValues;

    for (i = 0; i < nNumberOfValues; i ++)
        {
        (*ProtseqVector)->Protseq[i] = NULL;
        }

    for (i = 0; i < nNumberOfValues; i ++)
        {
        (*ProtseqVector)->Protseq[i] = new RPC_CHAR[MAX_PROTSEQ_LENGTH];
        if ( (*ProtseqVector)->Protseq[i] == 0 )
            {

            RpcProtseqVectorFree(ProtseqVector);

            return(RPC_S_OUT_OF_MEMORY);
            }

        RpcpStringCopy((*ProtseqVector)->Protseq[i],
                       RpcProtocolSequenceMap[i].RpcProtocolSequence);

        }

    return RPC_S_OK;
}

int MarkDuplicateEntries(IN RPC_PROTSEQ_VECTOR *ProtseqVector1,
                         IN int nVector1CurrentPos,
                         IN RPC_PROTSEQ_VECTOR *ProtseqVector2 OPTIONAL,
                         IN OUT UCHAR *pfDuplicates1,
                         IN OUT UCHAR *pfDuplicates2)

/*++

Routine Description:

    This routine is tightly coupled with RpcConfigInquireProtocolSequences.
    If the current element is already marked as duplicate by previous
    run of this function, we directly return 1. If not,
    it checks whether the current element is duplicate of any element
    starting with the nVetcor1StartingPos from the first vector, and
    going through the whole second vector if it is there, and marking
    all duplicates of the current element as such. Then 0 is returned.
    If the second vector is NULL, the pfDuplicates2 must be NULL also. This
    means that there is one vector only, and its data are passed in
    in RpcProtseqVector1 and in pfDuplicates1.

Arguments:

    RpcProtseqVector1 - the first vector
    nVector1CurrentPos - the current position from the first vector
    RpcProtseqVector2 - the second vector. This argument may be null
    pfDuplicates1 - the array of duplicate flags for the first vector
    pfDuplicates2 - the array of duplicate flags for the second vector. If
        second vector is NULL, must be NULL also.

Return Value:

    1 - the current element is a duplicate of an element that we
        encountered in a previous run of this function.
    0 - the current element is unique in both vectors

--*/
{
    int i;
    RPC_CHAR *pszCurrentElement;

    ASSERT(nVector1CurrentPos < (int)ProtseqVector1->Count);

    if (pfDuplicates1[nVector1CurrentPos])
        return 1;

    pszCurrentElement = ProtseqVector1->Protseq[nVector1CurrentPos];

    for (i = nVector1CurrentPos + 1; i < (int)ProtseqVector1->Count; i ++)
        {
        if (RpcpStringCompare(pszCurrentElement,
            ProtseqVector1->Protseq[i]) == 0)
            {
            pfDuplicates1[i] = TRUE;
            }
        }

    if (ProtseqVector2)
        {
        ASSERT(pfDuplicates2 != NULL);

        for (i = 0; i < (int)ProtseqVector2->Count; i ++)
            {
            if (RpcpStringCompare(pszCurrentElement,
                ProtseqVector2->Protseq[i]) == 0)
                {
                pfDuplicates2[i] = TRUE;
                }
            }
        }
    else
        {
        ASSERT(pfDuplicates2 == NULL);
        }

    return 0;
}

RPC_STATUS
MergeProtseqVectors (IN OUT RPC_PROTSEQ_VECTOR *ProtseqVector1,
                     IN OUT RPC_PROTSEQ_VECTOR *ProtseqVector2 OPTIONAL,
                     OUT RPC_PROTSEQ_VECTOR **ProtseqVector
                     )

/*++

Routine Description:

    This routine takes two protseq vectors, and in the OUT argument ProtseqVector
        returns the resulting vector, which is a union of the two IN
        vectors. Successful or not, the input vectors will be freed on exit.

Arguments:

    ProtseqVector1 - the first vector
    ProtseqVector2 - the second vector. This argument may be null in which case the
        output vector is simply the first vector.
    ProtseqVector - the resulting union vector. If the return value from the function
        is not RPC_S_OK, the out parameter is undefined and should not be used by caller.

Return Value:

    RPC_S_OK - success. The ProtseqVector argument contains the resulting vector.
    error code - the cause of the error.

--*/
{
    unsigned char *pfDuplicate1;
    unsigned char *pfDuplicate2;
    int i, j;
    int nDuplicateElements;
    int nCurrentElement;
    int nUniqueElements;

    // compare basically each with each
    // construct arrays in which we will mark each duplicate element
    // if it is such
    pfDuplicate1 = (unsigned char *)alloca(ProtseqVector1->Count);
    if (ProtseqVector2)
        pfDuplicate2 = (unsigned char *)alloca(ProtseqVector2->Count);
    else
        pfDuplicate2 = NULL;

    // all elements are presumed to be unique unless proven otherwise
    memset(pfDuplicate1, 0, ProtseqVector1->Count);
    if (ProtseqVector2)
        memset(pfDuplicate2, 0, ProtseqVector2->Count);

    nDuplicateElements = 0;

    // do compare each with each
    // test the first vector for uniqueness
    for (i = 0; i < (int)ProtseqVector1->Count; i ++)
        {
        nDuplicateElements += MarkDuplicateEntries(ProtseqVector1, i,
            ProtseqVector2, pfDuplicate1, pfDuplicate2);
        }

    if (ProtseqVector2)
        {
        // test the second vector for uniqueness
        for (i = 0; i < (int)ProtseqVector2->Count; i ++)
            {
            nDuplicateElements += MarkDuplicateEntries(ProtseqVector2, i,
                NULL, pfDuplicate2, NULL);
            }
        }

    // here we must move the unique elements to a new vector
    // first, calculate the length of the new vector
    nUniqueElements = ProtseqVector1->Count - nDuplicateElements;
    if (ProtseqVector2)
        nUniqueElements += ProtseqVector2->Count;

    // second, alloc the new vector
    *ProtseqVector = (RPC_PROTSEQ_VECTOR *) new unsigned char[
            sizeof(RPC_PROTSEQ_VECTOR) +
            (nUniqueElements - 1) * sizeof(RPC_CHAR *)];
    if (*ProtseqVector == NULL)
        {
        RpcProtseqVectorFree(&ProtseqVector1);
        if (ProtseqVector2)
            RpcProtseqVectorFree(&ProtseqVector2);
        return RPC_S_OUT_OF_MEMORY;
        }

    // set the count of the union vector
    (*ProtseqVector)->Count = nUniqueElements;

    nCurrentElement = 0;    // counts the current element in the union
                            // vector
    for (i = 0; i < (int)ProtseqVector1->Count; i ++)
        {
        if (!pfDuplicate1[i])
            {
            (*ProtseqVector)->Protseq[nCurrentElement] =
                ProtseqVector1->Protseq[i];
            nCurrentElement ++;
            // save the string from deletion
            ProtseqVector1->Protseq[i] = NULL;
            }
        }

    if (ProtseqVector2)
        {
        for (i = 0; i < (int)ProtseqVector2->Count; i ++)
            {
            if (!pfDuplicate2[i])
                {
                (*ProtseqVector)->Protseq[nCurrentElement] =
                    ProtseqVector2->Protseq[i];
                nCurrentElement ++;
                // save the string from deletion
                ProtseqVector2->Protseq[i] = NULL;
                }
            }
        }

    // we don't need the original vectors anymore - delete them
    RpcProtseqVectorFree(&ProtseqVector1);
    if (ProtseqVector2)
        RpcProtseqVectorFree(&ProtseqVector2);

    return RPC_S_OK;
}


RPC_STATUS
RpcConfigInquireProtocolSequences (
    IN BOOL fGetAllProtseqs,
    OUT RPC_PROTSEQ_VECTOR PAPI * PAPI * ProtseqVector1
    )
/*++

Routine Description:

    This routine is used to obtain a list of the rpc protocol sequences
    supported by the system.

Arguments:

    fGetAllProtseqs - if TRUE, all protseqs known will be returned. If FALSE,
        only the protseqs currently installed will be returned.
    ProtseqVector - Returns a vector of supported rpc protocol sequences
        for this rpc protocol module.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_NO_PROTSEQS - The current system configuration does not
        support any rpc protocol sequences.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to inquire
        the rpc protocol sequences supported by rpc.

--*/
{
    RPC_STATUS RpcStatus1;
    RPC_STATUS RpcStatus2;
    RPC_PROTSEQ_VECTOR *ProtseqVector2 = NULL;
    RPC_PROTSEQ_VECTOR *ProtseqVector;

    if (fGetAllProtseqs)
        {
        RpcStatus2 = RpcConfigInquireStaticProtocolSequences(&ProtseqVector2);
        if (RpcStatus2 != RPC_S_OK)
            return RpcStatus2;
        }

    // under NT, failure to query the registry vector is fatal. Under Win98, querying
    // this registry vector is optional, and if we fail, we have to continue gathering the
    // vector from other sources.
    RpcStatus1 = RpcConfigInquireProtocolSequencesFromKey(
        ProtseqVector1, (unsigned char *)RPC_REGISTRY_PROTOCOLS);

    if (RpcStatus1 != RPC_S_OK)
        {
        RpcProtseqVectorFree(&ProtseqVector2);
        return RpcStatus1;
        }

    if (fGetAllProtseqs)
        {
        // Merge the static vector and the one from the registry
        RpcStatus1 = MergeProtseqVectors(*ProtseqVector1, ProtseqVector2, &ProtseqVector);
        if (RpcStatus1 != RPC_S_OK)
            {
            return RpcStatus1;
            }

        *ProtseqVector1 = ProtseqVector;
        }

    return RpcStatus1;
}

// N.B. This enumration must agree with the values
// in system.adm
typedef enum tagStateInformationPolicyValues
{
    sipvNone,
    sipvAuto1,
    sipvAuto2,
    sipvServer,
    sipvFull
} StateInformationPolicyValues;

// N.B. This enumration must agree with the values
// in system.adm
typedef enum tagEEInfoPolicyValues
{
    eeipvOff,
    eeipvOnWithExceptions,
    eeipvOffWithExceptions,
    eeipvOn
} EEInfoPolicyValues;

void 
SetAutoPolicySettings(
    StateInformationPolicyValues PolicyValue
    )
/*++

Routine Description:

    This routine sets the state information maintenance to the appropriate
    level of Auto, depending on machine capacity.

Arguments:

    PolicyValue - sipvAuto1 or sipvAuto2

Return Value:

    RPC_S_OK - The operation completed successfully.

    other RPC_S_* - error

--*/
{
    NT_PRODUCT_TYPE ProductType;
    BOOL fNeedServer;
    ULONG_PTR MinMemoryNeeded;
    MEMORYSTATUSEX MemoryStatus;
    BOOL fResult;

    ASSERT((PolicyValue == sipvAuto1) || (PolicyValue == sipvAuto2));

    // client side debug info is FALSE by default - no need to
    // set it explicitly

    // see what we have
    // RtlGetNtProductType always returns valid ProductType
    // It may be incorrect during GUI mode setup, but it will
    // be valid
    (VOID) RtlGetNtProductType(&ProductType);

    MemoryStatus.dwLength = sizeof(MemoryStatus);
    fResult = GlobalMemoryStatusEx(&MemoryStatus);
    ASSERT(fResult);

    // see what we have been asked for
    if (PolicyValue == sipvAuto1)
        {
        fNeedServer = FALSE;
        MinMemoryNeeded = 64 * 1024 * 1024;     // 64MB of RAM
        }
    else 
        {
        ASSERT (PolicyValue == sipvAuto2);
        fNeedServer = TRUE;
        MinMemoryNeeded = 127 * 1024 * 1024;    // 127MB of RAM
        }

    // if we need server, but this is workstation, no state info
    if (fNeedServer && (ProductType == NtProductWinNt))
        {
        g_fServerSideDebugInfoEnabled = FALSE;
        return;
        }

    // if we have less physical memory than the one we need,
    // no state info
    if (MemoryStatus.ullTotalPhys < (ULONGLONG) MinMemoryNeeded)
        {
        g_fServerSideDebugInfoEnabled = FALSE;
        return;
        }

    g_fServerSideDebugInfoEnabled = TRUE;
}

typedef enum tagExceptionListParserState
{
    elpsOutsideOfQuotes,
    elpsInsideQuotes,
    elpsReadingWhitespace,
    elpsReadingCharacter
} ExceptionListParserState;

BOOL
DoesThisProcessCmdLineStartWithThisString (
    IN LPWSTR CmdLine,
    IN LPWSTR CmdLineStart
    )
/*++

Routine Description:

    Checks if the process name starts with the string given
    in CmdLineStart

Arguments:

    CmdLine - the process command line with path name stripped
    CmdLineStart - the patter to match against

Return Value:

    non-zero - there is a match
    FALSE - there is no match

--*/
{
    int CmdLineLength = RpcpStringLength(CmdLine);
    int CmdLineStartLength = RpcpStringLength(CmdLineStart);

    if (CmdLineLength >= CmdLineStartLength)
        {
        if (RpcpStringNCompare(CmdLine, CmdLineStart, CmdLineStartLength) == 0)
            return TRUE;
        }
    return FALSE;    
}

typedef enum tagExceptionListCharacterTypes
{
    elctQuotes,
    elctCharacter,
    elctWhitespace
} ExceptionListCharacterTypes;

inline ExceptionListCharacterTypes
GetCharacterType (
    RPC_CHAR Character
    )
{
    if (Character == '"')
        return elctQuotes;
    if (Character == ' ')
        return elctWhitespace;
    return elctCharacter;
}

RPC_STATUS
IsThisProcessAnException (
    IN HKEY RegistryKey,
    BOOL *fThisProcessIsException
    )
/*++

Routine Description:

    Checks whether the current process is in the exceptions list as
    specified in the ExtErrorInfoExceptions registry key

Arguments:

    RegistryKey - an open key to RPC_POLICY_SETTINGS
    fThisProcessIsException - on output non-zero if this process is
        an exception and FALSE otherwise

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    DWORD RegStatus;
    RPC_CHAR *Buffer = NULL;
    DWORD Type;
    DWORD Size = 0;
    int Retries = 5;
    int State;
    RPC_CHAR *CurrentPos;
    RPC_CHAR *CurrentString;
    RPC_CHAR *CommandLine;
    RPC_CHAR *LastBackslash;
    BOOL fIsSubstring;

    *fThisProcessIsException = FALSE;

    while (Retries > 0)
        {
        RegStatus = RegQueryValueExW(
                        RegistryKey,
                        L"ExtErrorInfoExceptions",
                        0,
                        &Type,
                        (LPBYTE) Buffer,
                        &Size
                        );

        if ( (RegStatus != ERROR_SUCCESS) && (RegStatus != ERROR_MORE_DATA) )
            {
            if (RegStatus == ERROR_FILE_NOT_FOUND)
                RegStatus = RPC_S_OK;
            else
                RegStatus = RPC_S_OUT_OF_MEMORY;

            goto CleanupAndReturn;
            }
        else
            {
            if ((Buffer == NULL) || (RegStatus == ERROR_MORE_DATA))
                {
                if (Buffer)
                    delete Buffer;

                Buffer = new RPC_CHAR[Size];
                if (Buffer == NULL)
                    {
                    RegStatus = RPC_S_OUT_OF_MEMORY;
                    goto CleanupAndReturn;
                    }

                continue;
                }

            if (Type != REG_SZ)
                {
                RegStatus = RPC_S_INTERNAL_ERROR;
                goto CleanupAndReturn;
                }

            ASSERT(RegStatus == RPC_S_OK);

            CommandLine = GetCommandLine();
            LastBackslash = wcsrchr(CommandLine, '\\');
            if (LastBackslash != NULL)
                CommandLine = LastBackslash + 1;

            // here, Buffer contains the exception string
            // The format of the exception string is:
            // "cmd_line_start" "cmd_line_start" ...
            // If there is only one cmd_line_start, it doesn't have to be in double quotes
            State = elpsOutsideOfQuotes;
            CurrentPos = Buffer;
            CurrentString = NULL;
            while (*CurrentPos != 0)
                {
                switch (State)
                    {
                    case elpsOutsideOfQuotes:
                        switch (GetCharacterType(*CurrentPos))
                            {
                            case elctQuotes:
                                CurrentString = CurrentPos;
                                State = elpsInsideQuotes;
                                break;

                            case elctCharacter:
                                CurrentString = CurrentPos;
                                State = elpsReadingCharacter;
                                break;

                            case elctWhitespace:
                                State = elpsReadingWhitespace;
                                break;

                            default:
                                ASSERT(0);
                            }
                        break;

                    case elpsReadingCharacter:
                        switch (GetCharacterType(*CurrentPos))
                            {
                            case elctQuotes:
                                *CurrentPos = 0;
                                fIsSubstring = DoesThisProcessCmdLineStartWithThisString(
                                    CommandLine, CurrentString);
                                if (fIsSubstring)
                                    {
                                    *fThisProcessIsException = TRUE;
                                    goto CleanupAndReturn;
                                    }
                                CurrentString = CurrentPos + 1;
                                State = elpsReadingCharacter;
                                break;

                            case elctWhitespace:
                                *CurrentPos = 0;
                                fIsSubstring = DoesThisProcessCmdLineStartWithThisString(
                                    CommandLine, CurrentString);
                                if (fIsSubstring)
                                    {
                                    *fThisProcessIsException = TRUE;
                                    goto CleanupAndReturn;
                                    }
                                State = elpsReadingCharacter;
                                break;

                            // default:
                                // can be elpsReadingCharacter
                            }
                        break;

                    case elpsReadingWhitespace:
                        switch (GetCharacterType(*CurrentPos))
                            {
                            case elctQuotes:
                                CurrentString = CurrentPos + 1;
                                State = elpsInsideQuotes;
                                break;

                            case elctCharacter:
                                CurrentString = CurrentPos;
                                State = elpsReadingCharacter;
                                break;

                            // default:
                                // can be elctWhitespace
                            }
                        break;

                    case elpsInsideQuotes:
                        switch (GetCharacterType(*CurrentPos))
                            {
                            case elctQuotes:
                                *CurrentPos = 0;
                                fIsSubstring = DoesThisProcessCmdLineStartWithThisString(
                                    CommandLine, CurrentString);
                                if (fIsSubstring)
                                    {
                                    *fThisProcessIsException = TRUE;
                                    goto CleanupAndReturn;
                                    }
                                State = elpsOutsideOfQuotes;
                                break;

                            //default:
                                // can be elctCharacter or elctWhitespace
                            }
                        break;

                    default:
                        ASSERT(0);
                    }
                CurrentPos ++;
                }

                if (CurrentString)
                    {
                    fIsSubstring = DoesThisProcessCmdLineStartWithThisString(
                        CommandLine, CurrentString);
                    if (fIsSubstring)
                        {
                        *fThisProcessIsException = TRUE;
                        goto CleanupAndReturn;
                        }
                    }
                break;
            }

            Retries --;
        }

CleanupAndReturn:
    if (Buffer)
        delete [] Buffer;
    if (Retries == 0)
        RegStatus = RPC_S_INTERNAL_ERROR;
    return RegStatus;
}

RPC_STATUS ReadPolicySettings(void)
/*++

Routine Description:

    Reads the policy settings for RPC and sets the appropriate global
    variables.

Arguments:

    void

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    HKEY RegistryKey;
    DWORD RegStatus;
    DWORD Result;
    DWORD Type;
    DWORD DwordSize = sizeof(DWORD);
    BOOL ThisProcessIsException;

    RegStatus = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    (LPWSTR) RPC_POLICY_SETTINGS,
                    0L,                       //Reserved
                    KEY_READ,
                    &RegistryKey
                    );

    if ( RegStatus != ERROR_SUCCESS )
        {
        if (RegStatus == ERROR_FILE_NOT_FOUND)
            {
            SetAutoPolicySettings(sipvAuto2);
            return RPC_S_OK;
            }
        return RPC_S_OUT_OF_MEMORY;
        }

    RegStatus = RegQueryValueExW(
                    RegistryKey,
                    L"StateInformation",
                    0,
                    &Type,
                    (LPBYTE) &Result,
                    &DwordSize
                    );

    if ( RegStatus != ERROR_SUCCESS )
        {
        if (RegStatus == ERROR_FILE_NOT_FOUND)
            {
            SetAutoPolicySettings(sipvAuto2);
            RegStatus = RPC_S_OK;
            }
        else
            {
            RegStatus = RPC_S_OUT_OF_MEMORY;
            goto CleanupAndReturn;
            }
        }
    else
        {

        if (Type != REG_DWORD)
            {
            RegStatus = RPC_S_INTERNAL_ERROR;
            goto CleanupAndReturn;
            }

        ASSERT(RegStatus == RPC_S_OK);

        switch (Result)
            {
            case sipvNone:
                // nothing to do - the client/server DebugInfoEnabled values
                // are off by default
                break;

            case sipvAuto1:
            case sipvAuto2:
                SetAutoPolicySettings((StateInformationPolicyValues)Result);
                break;

            case sipvServer:
                g_fServerSideDebugInfoEnabled = TRUE;
                break;

            case sipvFull:
                g_fServerSideDebugInfoEnabled = TRUE;
                g_fClientSideDebugInfoEnabled = TRUE;
                break;

            default:
                RegStatus = RPC_S_INTERNAL_ERROR;
                goto CleanupAndReturn;
            }

        }

    RegStatus = RegQueryValueExW(
                    RegistryKey,
                    L"ExtErrorInformation",
                    0,
                    &Type,
                    (LPBYTE) &Result,
                    &DwordSize
                    );

    if ( RegStatus != ERROR_SUCCESS )
        {
        if (RegStatus == ERROR_FILE_NOT_FOUND)
            {
            RegStatus = RPC_S_OK;
            }
        else
            {
            RegStatus = RPC_S_OUT_OF_MEMORY;
            goto CleanupAndReturn;
            }
        }
    else
        {

        if (Type != REG_DWORD)
            {
            RegStatus = RPC_S_INTERNAL_ERROR;
            goto CleanupAndReturn;
            }

        ASSERT(RegStatus == RPC_S_OK);

        switch (Result)
            {
            case eeipvOff:
                // nothing to do - the g_fSendEEInfo is already false
                break;

            case eeipvOnWithExceptions:
                RegStatus = IsThisProcessAnException(RegistryKey,
                    &ThisProcessIsException);
                if ((RegStatus != RPC_S_OK) || (ThisProcessIsException == FALSE))
                    g_fSendEEInfo = TRUE;
                break;

            case eeipvOffWithExceptions:
                RegStatus = IsThisProcessAnException(RegistryKey,
                    &ThisProcessIsException);
                if ((RegStatus == RPC_S_OK) && (ThisProcessIsException == TRUE))
                    g_fSendEEInfo = TRUE;
                break;

            case eeipvOn:
                g_fSendEEInfo = TRUE;
                break;

            default:
                RegStatus = RPC_S_INTERNAL_ERROR;
                goto CleanupAndReturn;
            }
        }

    RegStatus = RegQueryValueExW(
                    RegistryKey,
                    L"IgnoreDelegationFailure",
                    0,
                    &Type,
                    (LPBYTE) &Result,
                    &DwordSize
                    );

    if ( RegStatus != ERROR_SUCCESS )
        {
        if (RegStatus == ERROR_FILE_NOT_FOUND)
            {
            RegStatus = RPC_S_OK;
            }
        else
            {
            RegStatus = RPC_S_OUT_OF_MEMORY;
            goto CleanupAndReturn;
            }
        }
    else
        {
        if (Type != REG_DWORD)
            {
            RegStatus = RPC_S_INTERNAL_ERROR;
            goto CleanupAndReturn;
            }

        ASSERT(RegStatus == RPC_S_OK);

        if (Result != 0)
            g_fIgnoreDelegationFailure = TRUE;
        }

CleanupAndReturn:
    RegCloseKey(RegistryKey);
    return RegStatus;
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcSystemFunction001 (
    IN SystemFunction001Commands FunctionCode,
    IN void *InData,
    OUT void *OutData
    )
/*++

Routine Description:

    Test hook.

Arguments:

    FunctionCode - which test function to perform

    InData - input data from the test function

    OutData - output data from the test function

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    THREAD *Thread;
    RPC_STATUS RpcStatus;

    InitializeIfNecessary();

    Thread = ThreadSelf();
    if (!Thread)
        return RPC_S_OUT_OF_MEMORY;

    RpcpPurgeEEInfoFromThreadIfNecessary(Thread);

    switch (FunctionCode)
        {
        case sf001cHttpSetInChannelTarget:
        case sf001cHttpSetOutChannelTarget:
            RpcStatus = HTTP2TestHook (FunctionCode,
                InData,
                OutData
                );
            break;

        case sf001cIgnoreCorruptionAsserts:
            gfRpcVerifierCorruptionExpected = TRUE;
            break;

        default:
            RpcStatus = RPC_S_CANNOT_SUPPORT;
        }

    return RpcStatus;
}

#ifdef WINNT35_UUIDS

unsigned long
SomeLongValue (
    )
/*++

Routine Description:

    This routine, SomeShortValue, AnotherShortValue, and SomeCharacterValue
    are used to generate the fields of a GUID if we can not determine
    the network address from the network card (so we can generate a
    UUID).  These routines must generate some pseudo random values
    based on the current time and/or the time since boot as well as the
    current process and thread.

    For the long value, we will use the current thread identifier and
    current process identifier bitwise exclusive ored together.

    For the two short values, we use the low part of the time field
    (which is long, which we split into two values).

    Finally, for the character value, we use a constant.

Return Value:

    An unsigned long value will be returned.

--*/
{
    TEB * CurrentTeb;

    CurrentTeb = NtCurrentTeb();
    return(((unsigned long) CurrentTeb->ClientId.UniqueThread)
            ^ ((unsigned long) CurrentTeb->ClientId.UniqueProcess));
}


unsigned short
SomeShortValue (
    )
/*++

See SomeLongValue.

--*/
{
    LARGE_INTEGER SystemTime;

    for (;;)
        {
        NtQuerySystemTime(&SystemTime);
        if (ThreadSelf()->TimeLow != SystemTime.LowPart)
            break;
        PauseExecution(1L);
        }
    ThreadSelf()->TimeLow = SystemTime.LowPart;
    return((unsigned short) SystemTime.LowPart);
}


unsigned short
AnotherShortValue (
    )
/*++

See SomeLongValue.

--*/
{
    return((unsigned short) (ThreadSelf()->TimeLow >> 16));
}


unsigned char
SomeCharacterValue (
    )
/*++

See SomeLongValue.

--*/
{
    return(0x69);
}

#endif WINNT35_UUIDS



typedef struct {
    RPC_STATUS RpcStatus;
    long NtStatus;
    } STATUS_MAPPING;

static const STATUS_MAPPING StatusMap[] =
    {
    { RPC_S_OK, STATUS_SUCCESS },
    { RPC_S_INVALID_STRING_BINDING, RPC_NT_INVALID_STRING_BINDING },
    { RPC_S_WRONG_KIND_OF_BINDING, RPC_NT_WRONG_KIND_OF_BINDING },
    { RPC_S_INVALID_BINDING, RPC_NT_INVALID_BINDING },
    { RPC_S_PROTSEQ_NOT_SUPPORTED, RPC_NT_PROTSEQ_NOT_SUPPORTED },
    { RPC_S_INVALID_RPC_PROTSEQ, RPC_NT_INVALID_RPC_PROTSEQ },
    { RPC_S_INVALID_STRING_UUID, RPC_NT_INVALID_STRING_UUID },
    { RPC_S_INVALID_ENDPOINT_FORMAT, RPC_NT_INVALID_ENDPOINT_FORMAT },
    { RPC_S_INVALID_NET_ADDR, RPC_NT_INVALID_NET_ADDR },
    { RPC_S_NO_ENDPOINT_FOUND, RPC_NT_NO_ENDPOINT_FOUND },
    { RPC_S_INVALID_TIMEOUT, RPC_NT_INVALID_TIMEOUT },
    { RPC_S_OBJECT_NOT_FOUND, RPC_NT_OBJECT_NOT_FOUND },
    { RPC_S_ALREADY_REGISTERED, RPC_NT_ALREADY_REGISTERED },
    { RPC_S_TYPE_ALREADY_REGISTERED, RPC_NT_TYPE_ALREADY_REGISTERED },
    { RPC_S_ALREADY_LISTENING, RPC_NT_ALREADY_LISTENING },
    { RPC_S_NO_PROTSEQS_REGISTERED, RPC_NT_NO_PROTSEQS_REGISTERED },
    { RPC_S_NOT_LISTENING, RPC_NT_NOT_LISTENING },
    { RPC_S_UNKNOWN_MGR_TYPE, RPC_NT_UNKNOWN_MGR_TYPE },
    { RPC_S_UNKNOWN_IF, RPC_NT_UNKNOWN_IF },
    { RPC_S_NO_BINDINGS, RPC_NT_NO_BINDINGS },
    { RPC_S_NO_MORE_BINDINGS, RPC_NT_NO_MORE_BINDINGS },
    { RPC_S_NO_PROTSEQS, RPC_NT_NO_PROTSEQS },
    { RPC_S_CANT_CREATE_ENDPOINT, RPC_NT_CANT_CREATE_ENDPOINT },
    { RPC_S_OUT_OF_RESOURCES, RPC_NT_OUT_OF_RESOURCES },
    { RPC_S_SERVER_UNAVAILABLE, RPC_NT_SERVER_UNAVAILABLE },
    { RPC_S_SERVER_TOO_BUSY, RPC_NT_SERVER_TOO_BUSY },
    { RPC_S_INVALID_NETWORK_OPTIONS, RPC_NT_INVALID_NETWORK_OPTIONS },
    { RPC_S_NO_CALL_ACTIVE, RPC_NT_NO_CALL_ACTIVE },
    { RPC_S_CALL_FAILED, RPC_NT_CALL_FAILED },
    { RPC_S_CALL_CANCELLED, RPC_NT_CALL_CANCELLED },
    { RPC_S_CALL_FAILED_DNE, RPC_NT_CALL_FAILED_DNE },
    { RPC_S_PROTOCOL_ERROR, RPC_NT_PROTOCOL_ERROR },
    { RPC_S_UNSUPPORTED_TRANS_SYN, RPC_NT_UNSUPPORTED_TRANS_SYN },
    { RPC_S_SERVER_OUT_OF_MEMORY, STATUS_INSUFF_SERVER_RESOURCES },
    { RPC_S_UNSUPPORTED_TYPE, RPC_NT_UNSUPPORTED_TYPE },
    { RPC_S_INVALID_TAG, RPC_NT_INVALID_TAG },
    { RPC_S_INVALID_BOUND, RPC_NT_INVALID_BOUND },
    { RPC_S_NO_ENTRY_NAME, RPC_NT_NO_ENTRY_NAME },
    { RPC_S_INVALID_NAME_SYNTAX, RPC_NT_INVALID_NAME_SYNTAX },
    { RPC_S_UNSUPPORTED_NAME_SYNTAX, RPC_NT_UNSUPPORTED_NAME_SYNTAX },
    { RPC_S_UUID_NO_ADDRESS, RPC_NT_UUID_NO_ADDRESS },
    { RPC_S_DUPLICATE_ENDPOINT, RPC_NT_DUPLICATE_ENDPOINT },
    { RPC_S_UNKNOWN_AUTHN_TYPE, RPC_NT_UNKNOWN_AUTHN_TYPE },
    { RPC_S_MAX_CALLS_TOO_SMALL, RPC_NT_MAX_CALLS_TOO_SMALL },
    { RPC_S_STRING_TOO_LONG, RPC_NT_STRING_TOO_LONG },
    { RPC_S_PROTSEQ_NOT_FOUND, RPC_NT_PROTSEQ_NOT_FOUND },
    { RPC_S_PROCNUM_OUT_OF_RANGE, RPC_NT_PROCNUM_OUT_OF_RANGE },
    { RPC_S_BINDING_HAS_NO_AUTH, RPC_NT_BINDING_HAS_NO_AUTH },
    { RPC_S_UNKNOWN_AUTHN_SERVICE, RPC_NT_UNKNOWN_AUTHN_SERVICE },
    { RPC_S_UNKNOWN_AUTHN_LEVEL, RPC_NT_UNKNOWN_AUTHN_LEVEL },
    { RPC_S_INVALID_AUTH_IDENTITY, RPC_NT_INVALID_AUTH_IDENTITY },
    { RPC_S_UNKNOWN_AUTHZ_SERVICE, RPC_NT_UNKNOWN_AUTHZ_SERVICE },
    { EPT_S_INVALID_ENTRY, EPT_NT_INVALID_ENTRY },
    { EPT_S_CANT_PERFORM_OP, EPT_NT_CANT_PERFORM_OP },
    { EPT_S_NOT_REGISTERED, EPT_NT_NOT_REGISTERED },
    { RPC_S_NOTHING_TO_EXPORT, RPC_NT_NOTHING_TO_EXPORT },
    { RPC_S_INCOMPLETE_NAME, RPC_NT_INCOMPLETE_NAME },
    { RPC_S_INVALID_VERS_OPTION, RPC_NT_INVALID_VERS_OPTION },
    { RPC_S_NO_MORE_MEMBERS, RPC_NT_NO_MORE_MEMBERS },
    { RPC_S_NOT_ALL_OBJS_UNEXPORTED, RPC_NT_NOT_ALL_OBJS_UNEXPORTED },
    { RPC_S_INTERFACE_NOT_FOUND, RPC_NT_INTERFACE_NOT_FOUND },
    { RPC_S_ENTRY_ALREADY_EXISTS, RPC_NT_ENTRY_ALREADY_EXISTS },
    { RPC_S_ENTRY_NOT_FOUND, RPC_NT_ENTRY_NOT_FOUND },
    { RPC_S_NAME_SERVICE_UNAVAILABLE, RPC_NT_NAME_SERVICE_UNAVAILABLE },
    { RPC_S_INVALID_NAF_ID, RPC_NT_INVALID_NAF_ID },
    { RPC_S_CANNOT_SUPPORT, RPC_NT_CANNOT_SUPPORT },
    { RPC_S_NO_CONTEXT_AVAILABLE, RPC_NT_NO_CONTEXT_AVAILABLE },
    { RPC_S_INTERNAL_ERROR, RPC_NT_INTERNAL_ERROR },
    { RPC_S_ZERO_DIVIDE, RPC_NT_ZERO_DIVIDE },
    { RPC_S_ADDRESS_ERROR, RPC_NT_ADDRESS_ERROR },
    { RPC_S_FP_DIV_ZERO, RPC_NT_FP_DIV_ZERO },
    { RPC_S_FP_UNDERFLOW, RPC_NT_FP_UNDERFLOW },
    { RPC_S_FP_OVERFLOW, RPC_NT_FP_OVERFLOW },
    { RPC_X_NO_MORE_ENTRIES, RPC_NT_NO_MORE_ENTRIES },
    { RPC_X_SS_CHAR_TRANS_OPEN_FAIL, RPC_NT_SS_CHAR_TRANS_OPEN_FAIL },
    { RPC_X_SS_CHAR_TRANS_SHORT_FILE, RPC_NT_SS_CHAR_TRANS_SHORT_FILE },
    { RPC_X_SS_IN_NULL_CONTEXT, RPC_NT_SS_IN_NULL_CONTEXT },
    { RPC_X_SS_CONTEXT_MISMATCH, RPC_NT_SS_CONTEXT_MISMATCH },
    { RPC_X_SS_CONTEXT_DAMAGED, RPC_NT_SS_CONTEXT_DAMAGED },
    { RPC_X_SS_HANDLES_MISMATCH, RPC_NT_SS_HANDLES_MISMATCH },
    { RPC_X_SS_CANNOT_GET_CALL_HANDLE, RPC_NT_SS_CANNOT_GET_CALL_HANDLE },
    { RPC_X_NULL_REF_POINTER, RPC_NT_NULL_REF_POINTER },
    { RPC_X_ENUM_VALUE_OUT_OF_RANGE, RPC_NT_ENUM_VALUE_OUT_OF_RANGE },
    { RPC_X_BYTE_COUNT_TOO_SMALL, RPC_NT_BYTE_COUNT_TOO_SMALL },
    { RPC_X_BAD_STUB_DATA, RPC_NT_BAD_STUB_DATA },
    { ERROR_INVALID_PARAMETER, STATUS_INVALID_PARAMETER },
    { ERROR_OUTOFMEMORY, STATUS_NO_MEMORY },
    { ERROR_MAX_THRDS_REACHED, STATUS_NO_MEMORY },
    { ERROR_INSUFFICIENT_BUFFER, STATUS_BUFFER_TOO_SMALL },
    { ERROR_INVALID_SECURITY_DESCR, STATUS_INVALID_SECURITY_DESCR },
    { ERROR_ACCESS_DENIED, STATUS_ACCESS_DENIED },
    { ERROR_NOACCESS, STATUS_ACCESS_VIOLATION },
    { RPC_S_CALL_IN_PROGRESS, RPC_NT_CALL_IN_PROGRESS },
    { RPC_S_GROUP_MEMBER_NOT_FOUND, RPC_NT_GROUP_MEMBER_NOT_FOUND },
    { EPT_S_CANT_CREATE, EPT_NT_CANT_CREATE },
    { RPC_S_INVALID_OBJECT, RPC_NT_INVALID_OBJECT },
    { RPC_S_INVALID_ASYNC_HANDLE, RPC_NT_INVALID_ASYNC_HANDLE },
    { RPC_S_INVALID_ASYNC_CALL, RPC_NT_INVALID_ASYNC_CALL },
    { RPC_X_PIPE_CLOSED, RPC_NT_PIPE_CLOSED },
    { RPC_X_PIPE_EMPTY, RPC_NT_PIPE_EMPTY },
    { RPC_X_PIPE_DISCIPLINE_ERROR, RPC_NT_PIPE_DISCIPLINE_ERROR },
    { ERROR_PASSWORD_MUST_CHANGE, STATUS_PASSWORD_MUST_CHANGE },
    { ERROR_PASSWORD_EXPIRED, STATUS_PASSWORD_EXPIRED },
    { ERROR_ACCOUNT_DISABLED, STATUS_ACCOUNT_DISABLED },
    { ERROR_INVALID_LOGON_HOURS, STATUS_INVALID_LOGON_HOURS },
    { ERROR_ACCOUNT_LOCKED_OUT, STATUS_ACCOUNT_LOCKED_OUT },
    { ERROR_WRONG_PASSWORD, STATUS_WRONG_PASSWORD }
    };

long RPC_ENTRY
I_RpcMapWin32Status (
    IN RPC_STATUS Status
    )
/*++

Routine Description:

    This routine maps a WIN32 RPC status code into an NT RPC status code.

Arguments:

    Status - Supplies the WIN32 RPC status code to be mapped.

Return Value:

    The NT RPC status code corresponding to the WIN32 RPC status code
    will be returned.

--*/
{
    register int i;
    for(i = 0; i < sizeof(StatusMap)/sizeof(STATUS_MAPPING); i++)
        {
        if (StatusMap[i].RpcStatus == Status)
            {
            return(StatusMap[i].NtStatus);
            }
        }
    
    // no mapping in first pass. We cannot map is sensibly. If it is
    // already a failure, just pass it along. Else map it to generic
    // failure to prevent the case where Win32 error passes off as
    // success NtStatus
    if (!NT_SUCCESS(Status))
        return Status;

#if DBG
    DbgPrintEx(DPFLTR_RPCPROXY_ID,
                   DPFLTR_WARNING_LEVEL,
                   "RPCRT4: Cannot map error from %d from Win32 to NtStatus\n",
                   Status);
#endif  // DBG

    return(STATUS_UNSUCCESSFUL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\lpcsvr.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    lpcsvr.cxx

Abstract:

    Implementation of the RPC on LPC protocol engine for the server.

Revision History:
    Mazhar Mohammed: Code fork from spcsvr.cxx, 08/02/95
    05-06-96: Merged WMSG and LRPC into a single protocol
    Mazhar Mohammed  Added Pipes Support
    Mazhar Mohammed  Added support for Async RPC 08-14-96
    Mazhar Mohammed  No more WMSG 9/22/97
    Kamen Moutafov      (kamenm)    Jan-2000    Support for multiple transfer syntaxes
    Kamen Moutafov (KamenM) Dec 99 - Feb 2000 - Support for cell debugging stuff
    Kamen Moutafov      (KamenM)    Mar-2000    Support for extended error info
--*/

#include <precomp.hxx>
#include <queue.hxx>
#include <hndlsvr.hxx>
#include <lpcpack.hxx>
#include <lpcsvr.hxx>
#include <ProtBind.hxx>
#include <lpcclnt.hxx>
#include <CharConv.hxx>


inline BOOL
RecvLotsaCallsWrapper(
      LRPC_ADDRESS  * Address
      )
{
  Address->ReceiveLotsaCalls();
  return(FALSE);
}

inline RPC_STATUS
InitializeLrpcIfNecessary(
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

--*/

{
    int nIndex ;
    RPC_STATUS Status ;

    if (GlobalLrpcServer == 0)
        {
        if ((Status = InitializeLrpcServer()) != RPC_S_OK)
            {
            return Status ;
            }
        }

    return (RPC_S_OK) ;
}


LRPC_SERVER::LRPC_SERVER(
    IN OUT RPC_STATUS  *Status
    ) : ServerMutex(Status,
                    TRUE    // pre-allocate semaphore
                    )
{
    Address = NULL ;
    EndpointInitialized = 0 ;
}


RPC_STATUS
LRPC_SERVER::InitializeAsync (
    )
{
    RPC_CHAR Endpoint[20];
    RPC_STATUS Status = RPC_S_OK ;

    if (EndpointInitialized == 0)
        {
        swprintf(Endpoint, RPC_CONST_STRING("MSAsyncRPC_%d"),
                        GetCurrentProcessId()) ;

        Status = RpcServerUseProtseqEpW (
            RPC_STRING_LITERAL("ncalrpc"), 100, Endpoint, NULL) ;
        if (Status != RPC_S_OK)
            {
            return Status ;
            }

        Status = GlobalRpcServer->ServerListen(1, 100, 1) ;

        if (Status == RPC_S_OK)
            {
            Status = SetEndpoint(Endpoint) ;
            }
        }

    return Status ;
}


RPC_STATUS
InitializeLrpcServer (
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/

{
    RPC_STATUS Status = RPC_S_OK ;

    GlobalMutexRequest() ;

    if (GlobalLrpcServer == 0)
        {
        GlobalLrpcServer = new LRPC_SERVER(&Status) ;

        if (GlobalLrpcServer == 0)
            {
#if DBG
            PrintToDebugger("LRPC: LRPC_SERVER initialization failed\n") ;
#endif

            GlobalMutexClear() ;

            return (RPC_S_OUT_OF_MEMORY) ;
            }

        if (Status != RPC_S_OK)
            {
            GlobalMutexClear() ;

            delete GlobalLrpcServer ;
            GlobalLrpcServer = 0 ;

            return Status ;
            }
        }

    GlobalMutexClear() ;

    return (RPC_S_OK) ;
}

void
SetCommonFaultFields (
    IN LRPC_MESSAGE *LrpcMessage,
    IN RPC_STATUS Status,
    IN int Flags,
    IN int AdditionalLength
    )
{
    // zero out unused fields
    LrpcMessage->Fault.RpcHeader.Pad = 0;
    LrpcMessage->Fault.RpcHeader.PresentContext = 0;
    LrpcMessage->Fault.RpcHeader.ProcedureNumber = 0;
    LrpcMessage->Fault.RpcHeader.SecurityContextId = 0;
    RpcpMemorySet(&LrpcMessage->Fault.RpcHeader.ObjectUuid, 0, sizeof(UUID));
    LrpcMessage->Fault.Padding1 = 0;

    LrpcMessage->Fault.RpcHeader.MessageType = LRPC_MSG_FAULT;
    LrpcMessage->Fault.RpcStatus = Status;
    LrpcMessage->LpcHeader.u1.s1.DataLength =
        sizeof(LRPC_FAULT_MESSAGE) - sizeof(PORT_MESSAGE) 
        - sizeof(LrpcMessage->Fault.Buffer) + (CSHORT)AdditionalLength;
    LrpcMessage->LpcHeader.u1.s1.TotalLength =
        sizeof(LRPC_FAULT_MESSAGE) - sizeof(LrpcMessage->Fault.Buffer) 
        + (CSHORT)AdditionalLength;

    if ((Flags & LRPC_SYNC_CLIENT) == 0)
        {
        SanitizeLpcHeader(&LrpcMessage->LpcHeader);
        LrpcMessage->LpcHeader.u2.ZeroInit = 0;
        LrpcMessage->LpcHeader.CallbackId = 0 ;
        LrpcMessage->LpcHeader.MessageId = 0 ;
        LrpcMessage->LpcHeader.u2.s2.DataInfoOffset = 0;
        }
}

void
SetCommonFault2Fields (
    IN LRPC_MESSAGE *LrpcMessage,
    IN RPC_STATUS Status,
    IN unsigned int Length,
    IN void *Buffer
    )
{
    // zero out unused fields
    LrpcMessage->Fault.RpcHeader.Pad = 0;
    LrpcMessage->Fault.RpcHeader.PresentContext = 0;
    LrpcMessage->Fault.RpcHeader.ProcedureNumber = 0;
    LrpcMessage->Fault.RpcHeader.SecurityContextId = 0;
    RpcpMemorySet(&LrpcMessage->Fault.RpcHeader.ObjectUuid, 0, sizeof(UUID));

    LrpcMessage->Fault2.RpcHeader.MessageType = LRPC_MSG_FAULT2;
    LrpcMessage->Fault2.RpcStatus = Status;
    LrpcMessage->LpcHeader.u1.s1.DataLength =
        sizeof(LRPC_FAULT2_MESSAGE) - sizeof(PORT_MESSAGE);
    LrpcMessage->LpcHeader.u1.s1.TotalLength =
        sizeof(LRPC_FAULT2_MESSAGE);
    // the Server/DataEntries must have been set in GetBuffer - no
    // need to reset them here
    LrpcMessage->Fault2.RpcHeader.Flags |= LRPC_EEINFO_PRESENT;
}

void
TrimIfNecessaryAndSetImmediateBuffer (
    IN LRPC_MESSAGE *LrpcMessage,
    IN RPC_STATUS Status,
    IN int Flags,
    IN size_t EstimatedEEInfoSize,
    IN BOOL fTrimEEInfo,
    IN ExtendedErrorInfo *CurrentEEInfo
    )
{
    size_t NeededLength;
    RPC_STATUS RpcStatus;

    if (fTrimEEInfo)
        {
        ASSERT(MAXIMUM_FAULT_MESSAGE >= MinimumTransportEEInfoLength);
        TrimEEInfoToLength (MAXIMUM_FAULT_MESSAGE, &NeededLength);

        if (NeededLength == 0)
            {
            SetCommonFaultFields(LrpcMessage, Status, Flags, 0);
            return;
            }

        ASSERT(NeededLength <= MAXIMUM_FAULT_MESSAGE);
        EstimatedEEInfoSize = NeededLength;
        // fall through to the next if - it will succeed
        // as we know the length is trimmed.
        }
    else
        {
        ASSERT(EstimatedEEInfoSize <= MAXIMUM_FAULT_MESSAGE);
        }

    RpcStatus = PickleEEInfo(CurrentEEInfo, 
        LrpcMessage->Fault.Buffer, 
        MAXIMUM_FAULT_MESSAGE);
    if (RpcStatus != RPC_S_OK)
        {
        SetCommonFaultFields(LrpcMessage, Status, Flags, 0);
        return;
        }

    SetCommonFaultFields(LrpcMessage, Status, Flags, EstimatedEEInfoSize);
    LrpcMessage->Fault.RpcHeader.Flags |= LRPC_EEINFO_PRESENT;
}


void
SetFaultPacket (
    IN LRPC_MESSAGE *LrpcMessage,
    IN RPC_STATUS Status,
    IN int Flags,
    IN LRPC_SCALL *CurrentCall OPTIONAL
    )
/*++

Routine Description:

    Initialize a fault packet

Arguments:

    LrpcMessage - Fault message
    Status - Fault status
    Flags - Flags from the request message

--*/

{
    THREAD *Thread;
    ExtendedErrorInfo *CurrentEEInfo;
    size_t EstimatedEEInfoSize;
    RPC_STATUS RpcStatus;
    RPC_MESSAGE RpcMessage;

    // we will see whether there is extended error information here
    // and try to send it. If we run in out-of-memory, or there is
    // no EEInfo, send plain old fault.
    Thread = ThreadSelf();
    if (Thread && g_fSendEEInfo)
        {
        CurrentEEInfo = Thread->GetEEInfo();
        if (CurrentEEInfo)
            {
            // if this function runs in out-of-memory, it will
            // return 0.
            EstimatedEEInfoSize = EstimateSizeOfEEInfo();
            if (EstimatedEEInfoSize == 0)
                {
                SetCommonFaultFields(LrpcMessage, Status, Flags, 0);
                return;
                }

            // if there is no current call, we cannot send arbitrary length
            // data, so we must trim the EEInfo
            if (CurrentCall == NULL)
                {
                TrimIfNecessaryAndSetImmediateBuffer(LrpcMessage,
                    Status,
                    Flags,
                    EstimatedEEInfoSize,
                    TRUE,
                    CurrentEEInfo);
                return;
                }

            if (EstimatedEEInfoSize <= MAXIMUM_FAULT_MESSAGE)
                {
                TrimIfNecessaryAndSetImmediateBuffer(LrpcMessage,
                    Status,
                    Flags,
                    EstimatedEEInfoSize,
                    FALSE,
                    CurrentEEInfo);
                return;
                }

            ASSERT(CurrentCall != NULL);

            // here, the estimated EEInfo size is larger that the available
            // space in the fault packet. We have a call, so we must try
            // sending a fault2 packet.
            RpcMessage.Handle = CurrentCall;
            RpcMessage.RpcFlags = CurrentCall->RpcMessage.RpcFlags;
            // increase the buffer lenght in case we fall in the window
            // b/n MAXIMUM_MESSAGE_BUFFER and the EstimatedEEInfoSize. If we
            // do, GetBuffer will return us an immediate buffer, and this is
            // not something we want
            RpcMessage.BufferLength = max(EstimatedEEInfoSize, MAXIMUM_MESSAGE_BUFFER + 4);
            RpcStatus = CurrentCall->LRPC_SCALL::GetBuffer(&RpcMessage, NULL);
            if (RpcStatus != RPC_S_OK)
                {
                // can't send the full data - trim and send
                TrimIfNecessaryAndSetImmediateBuffer(LrpcMessage,
                    Status,
                    Flags,
                    EstimatedEEInfoSize,
                    TRUE,
                    CurrentEEInfo);
                return;
                }

            ASSERT(CurrentCall->LrpcReplyMessage->Rpc.RpcHeader.Flags != LRPC_BUFFER_IMMEDIATE);
            // on success, GetBuffer has allocated a buffer in RpcMessage.Buffer
            // and has setup CurrentCall->LrpcReplyMessage for sending to
            // the client.
            // Fill in the EEInfo
            RpcStatus = PickleEEInfo(CurrentEEInfo, 
                (unsigned char *)RpcMessage.Buffer, 
                EstimatedEEInfoSize);
            if (RpcStatus != RPC_S_OK)
                {
                if (!CurrentCall->IsClientAsync())
                    CurrentCall->Association->Buffers.DeleteItemByBruteForce(RpcMessage.Buffer);
                RpcpFarFree(RpcMessage.Buffer);

                // can't send the full data - trim and send
                TrimIfNecessaryAndSetImmediateBuffer(LrpcMessage,
                    Status,
                    Flags,
                    EstimatedEEInfoSize,
                    TRUE,
                    CurrentEEInfo);
                return;
                }

            // Send to the client
            if (CurrentCall->IsClientAsync())
                {
                if (!CurrentCall->IsSyncCall())
                    {
                    ASSERT(CurrentCall->LrpcAsyncReplyMessage == CurrentCall->LrpcReplyMessage);
                    }
                SetCommonFault2Fields(CurrentCall->LrpcReplyMessage,
                    Status,
                    RpcMessage.BufferLength,
                    RpcMessage.Buffer);
                }
            else
                {
                // send the data for sync client
                // set fault2 fields

                SetCommonFault2Fields(CurrentCall->LrpcReplyMessage,
                    Status,
                    RpcMessage.BufferLength,
                    RpcMessage.Buffer);

                // our caller will do the sending
                }
            return;
            }
        }

    SetCommonFaultFields(LrpcMessage, Status, Flags, 0);
}

// This is a compile-time verification of the alignment assert:
// IsBufferAligned(LrpcMessage->Bind.BindExchangeReturn.Buffer)
C_ASSERT((FIELD_OFFSET(LRPC_BIND_MESSAGE, BindExchangeReturn)+
          FIELD_OFFSET(LRPC_BIND_EXCHANGE_RETURN, Buffer)) % RPCRT_NATURAL_BOUNDARY == 0);

void
SetBindAckFault (
    IN LRPC_MESSAGE *LrpcMessage,
    IN RPC_STATUS Status
    )
/*++

Routine Description:

    Initialize a fault bind ack packet (bind_nak). It will add extended
    error info if there is some, and sending of eeinfo is enabled.

Arguments:

    LrpcMessage - Bind message
    Status - Fault status

--*/
{
    size_t NeededLength;
    ExtendedErrorInfo *EEInfo;

    ASSERT(IsBufferAligned(LrpcMessage->Bind.BindExchangeReturn.Buffer));

    ASSERT(MAX_BIND_NAK >= MinimumTransportEEInfoLength);

    LrpcMessage->Bind.BindExchange.RpcStatus = Status;

    if (g_fSendEEInfo)
        {
        EEInfo = RpcpGetEEInfo();
        if (EEInfo)
            {
            TrimEEInfoToLength (MAX_BIND_NAK, &NeededLength);

            if (NeededLength != 0)
                {
                Status = PickleEEInfo(EEInfo, 
                    LrpcMessage->Bind.BindExchangeReturn.Buffer, 
                    MAX_BIND_NAK);
                if (Status == RPC_S_OK)
                    {
                    LrpcMessage->Bind.BindExchange.Flags |= EXTENDED_ERROR_INFO_PRESENT;
                    LrpcMessage->LpcHeader.u1.s1.DataLength = (CSHORT)NeededLength + 
                        BIND_NAK_PICKLE_BUFFER_OFFSET
                        - sizeof(PORT_MESSAGE);
                    }
                }
            }
        }

    if (!(LrpcMessage->Bind.BindExchange.Flags & EXTENDED_ERROR_INFO_PRESENT))
        {
        LrpcMessage->LpcHeader.u1.s1.DataLength = sizeof(LRPC_BIND_MESSAGE)
                - sizeof(PORT_MESSAGE);
        }
}


LRPC_ADDRESS::LRPC_ADDRESS (
    OUT RPC_STATUS * Status
    ) : RPC_ADDRESS(Status),
    ThreadsDoingLongWait(0)
/*++

--*/
{
    ObjectType = LRPC_ADDRESS_TYPE;
    LpcAddressPort = 0;
    CallThreadCount = 0;
    ActiveCallCount = 0;
    ServerListeningFlag = 0;
    AssociationCount = 0;
    fServerThreadsStarted = 0;
    SequenceNumber = 1;
    fTickleMessageAvailable = FALSE;
    TickleMessage = NULL;

    if (IsServerSideDebugInfoEnabled())
        {
        DebugCell = (DebugEndpointInfo *)AllocateCell(&DebugCellTag);
        if (DebugCell == NULL)
            {
            *Status = RPC_S_OUT_OF_MEMORY;
            }
        else
            {
            DebugCell->TypeHeader = 0;
            DebugCell->Type = dctEndpointInfo;
            DebugCell->ProtseqType = (UCHAR)LRPC_TOWER_ID;
            DebugCell->Status = desAllocated;
            memset(DebugCell->EndpointName, 0, sizeof(DebugCell->EndpointName));
            }
        }
    else
        DebugCell = NULL;

}


RPC_STATUS
LRPC_ADDRESS::ServerStartingToListen (
    IN unsigned int MinimumCallThreads,
    IN unsigned int MaximumConcurrentCalls
    )
/*++

Routine Description:

    This routine gets called when RpcServerListen is called by the application.
    We need to create the threads we need to receive remote procedure calls.

Arguments:

    MinimumCallThreads - Supplies the minimum number of threads which we
        must create.

    MaximumConcurrentCalls - Unused.

Return Value:

    RPC_S_OK - Ok, this address is all ready to start listening for remote
        procedure calls.

    RPC_S_OUT_OF_THREADS - We could not create enough threads so that we
        have at least the minimum number of call threads required (as
        specified by the MinimumCallThreads argument).

--*/
{
    RPC_STATUS Status;

    UNUSED(MaximumConcurrentCalls);

    if (fServerThreadsStarted == 0)
        {
        Status = InitializeServerSideCellHeapIfNecessary();
        if (Status != RPC_S_OK)
            return Status;

        this->MinimumCallThreads = MinimumCallThreads;
        AddressMutex.Request();
        if (CallThreadCount < this->MinimumCallThreads)
            {
            Status = Server->CreateThread((THREAD_PROC)&RecvLotsaCallsWrapper,
                                          this);

            if (Status != RPC_S_OK)
                {
                AddressMutex.Clear();
                VALIDATE(Status)
                    {
                    RPC_S_OUT_OF_THREADS,
                    RPC_S_OUT_OF_MEMORY
                    } END_VALIDATE;
                
                return(Status);
                }
            CallThreadCount += 1;
            }
        AddressMutex.Clear();
        fServerThreadsStarted = 1;
        }

    ServerListeningFlag = 1;
    return(RPC_S_OK);
}


void
LRPC_ADDRESS::ServerStoppedListening (
    )
/*++

Routine Description:

    We just need to indicate that the server is no longer listening, and
    set the minimum call thread count to one.

--*/
{
    ServerListeningFlag = 0;
    MinimumCallThreads = 1;
}

#ifdef DEBUGRPC

// Hard coded world (aka EveryOne) SID
const SID World = { 1, 1, { 0, 0, 0, 0, 0, 1}, 0};

// Hard coded anonymous SID
const SID AnonymousLogonSid = { 1, 1, SECURITY_NT_AUTHORITY, SECURITY_ANONYMOUS_LOGON_RID};

SECURITY_DESCRIPTOR *DefaultPortSD = NULL;

RPC_STATUS
CreateAndGetDefaultPortSDIfNecessary (
    OUT SECURITY_DESCRIPTOR **PortSD
    )
/*++
Function Name: CreateAndGetDefaultPortSDIfNecessary

Parameters:
    PortSD - receives the default port SD on success.
        Undefined on failure

Description:
    If the default port SD is not created, creates it,
    and returns it. If it is already created, it simply
    returns it. The function is thread-safe.

Returns:
    RPC_S_OK or other codes for error.

--*/
{
    DWORD DaclSize;
    PACL Dacl;
    ULONG LengthOfDacl;
    SECURITY_DESCRIPTOR *LocalDefaultSD;    // we work on a local copy to make 
                                            // this thread safe

    if (DefaultPortSD)
        {
        *PortSD = DefaultPortSD;
        return RPC_S_OK;
        }

    LocalDefaultSD = new SECURITY_DESCRIPTOR;

    if (   LocalDefaultSD == 0
        || !InitializeSecurityDescriptor(LocalDefaultSD,
                                       SECURITY_DESCRIPTOR_REVISION) )
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    ASSERT(GetSidLengthRequired(SID_MAX_SUB_AUTHORITIES) <= 0x44);

    DaclSize = 2 * sizeof(ACCESS_ALLOWED_ACE) + sizeof(World) + sizeof(AnonymousLogonSid) + 0x44;
    LengthOfDacl = DaclSize + sizeof(ACL);
    Dacl = (ACL *) new char[LengthOfDacl];

    if (NULL == Dacl)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    ASSERT(IsValidSid((PVOID)&World));
    ASSERT(IsValidSid((PVOID)&AnonymousLogonSid));

    InitializeAcl(Dacl, LengthOfDacl, ACL_REVISION);

    if (!AddAccessAllowedAce(Dacl, ACL_REVISION,
                             PORT_ALL_ACCESS,
                             (PVOID)&World))
        {
        // this should never fail unless we messed up the
        // parameters or there is a version mismatch
        ASSERT(0);
        delete [] Dacl;
        delete LocalDefaultSD;
        return(RPC_S_OUT_OF_RESOURCES);
        }
    if (!AddAccessAllowedAce(Dacl, ACL_REVISION,
                             PORT_ALL_ACCESS,
                             (PVOID)&AnonymousLogonSid ))
        {
        // this should never fail unless we messed up the
        // parameters or there is a version mismatch
        ASSERT(0);
        delete [] Dacl;
        delete LocalDefaultSD;
        return(RPC_S_OUT_OF_RESOURCES);
        }

    if (!SetSecurityDescriptorDacl(LocalDefaultSD, TRUE, Dacl, FALSE))
        {
        delete [] Dacl;
        delete LocalDefaultSD;
        return(RPC_S_OUT_OF_RESOURCES);
        }

    if (InterlockedCompareExchangePointer((PVOID *)&DefaultPortSD,
        LocalDefaultSD,
        NULL) != NULL)
        {
        // somebody beat us to the punch - free our local copy
        delete [] Dacl;
        delete LocalDefaultSD;
        }

    *PortSD = DefaultPortSD;

    return RPC_S_OK;
}
#endif


RPC_STATUS
LRPC_ADDRESS::ActuallySetupAddress (
    IN RPC_CHAR  * Endpoint,
    IN void  * SecurityDescriptor OPTIONAL
    )
/*++
Function Name:ActuallySetupAddress

Parameters:

Description:

Returns:

--*/
{
    NTSTATUS NtStatus;
    RPC_CHAR * LpcPortName;
    unsigned int LpcPortNameLen;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    RPC_STATUS Status;
#ifdef DEBUGRPC
    BOOL Result;
    BOOL DaclPresent;
    PACL Dacl;
    BOOL Ignored;
#endif

    //
    // Allocate and initialize the port name.  We need to stick the
    // LRPC_DIRECTORY_NAME on the front of the endpoint.  This is for
    // security reasons (so that anyone can create LRPC endpoints).
    //
    // Also note that the port name can be at most PORT_NAME_LEN bytes since
    // it may have to end up in LRPC_BIND_EXCHANGE::szPortName.
    //

    LpcPortNameLen = RpcpStringLength(Endpoint) + RpcpStringLength(LRPC_DIRECTORY_NAME) + 1;
    if (LpcPortNameLen > PORT_NAME_LEN/sizeof(RPC_CHAR))
        {
        return(RPC_S_STRING_TOO_LONG);
        }

    LpcPortName = new RPC_CHAR[LpcPortNameLen];
    if (LpcPortName == 0)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    RpcpMemoryCopy(
                   LpcPortName,
                   LRPC_DIRECTORY_NAME,
                   RpcpStringLength(LRPC_DIRECTORY_NAME) *sizeof(RPC_CHAR));

    RpcpMemoryCopy(
                   LpcPortName + RpcpStringLength(LRPC_DIRECTORY_NAME),
                   Endpoint,
                   (RpcpStringLength(Endpoint) + 1) *sizeof(RPC_CHAR));

    RtlInitUnicodeString(&UnicodeString, LpcPortName);

#ifdef DEBUGRPC
    // in checked builds we check the security descriptor for NULL Dacl,
    // and if present, we replace it with a default "allow everyone"
    // Dacl. This was requested by ChrisW (12/14/2000) from the Security 
    // Team so that they can get LPC ports out of the picture, and then 
    // ASSERT on NULL Dacls for other objects
    if (SecurityDescriptor)
        {
        Result = GetSecurityDescriptorDacl(SecurityDescriptor,
            &DaclPresent,
            &Dacl,
            &Ignored  // lpbDaclDefaulted
            );

        if (!Result)
            {
            // invalid security descriptor is the only reason this could fail
            delete [] LpcPortName;
            return RPC_S_INVALID_ENDPOINT_FORMAT;
            }

        if (DaclPresent && (Dacl == NULL))
            {
            Status = CreateAndGetDefaultPortSDIfNecessary((SECURITY_DESCRIPTOR **)&SecurityDescriptor);
            if (Status != RPC_S_OK)
                {
                delete [] LpcPortName;
                return Status;
                }

            // We were able to grab a default port SD - just let it through
            }
        // else 
        //    {
        //    the security descriptor supplied by caller has non NULL Dacl - let
        //    it through
        //    }
        }
#endif

    InitializeObjectAttributes(
                            &ObjectAttributes,
                            &UnicodeString,
                            OBJ_CASE_INSENSITIVE,
                            0,
                            SecurityDescriptor);

    NtStatus = NtCreatePort(
                            &LpcAddressPort,
                            &ObjectAttributes,
                            sizeof(LRPC_BIND_EXCHANGE),
                            PORT_MAXIMUM_MESSAGE_LENGTH,
                            0);

    delete [] LpcPortName;
    if (NT_SUCCESS(NtStatus))
        {
        Status = LrpcSetEndpoint(Endpoint);
        return(Status);
        }

    if (NtStatus == STATUS_NO_MEMORY)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }
    if ((NtStatus == STATUS_INSUFFICIENT_RESOURCES)
        || (NtStatus == STATUS_QUOTA_EXCEEDED))
        {
        return(RPC_S_OUT_OF_RESOURCES);
        }
    if ((NtStatus == STATUS_OBJECT_PATH_INVALID)
        || (NtStatus == STATUS_OBJECT_PATH_NOT_FOUND)
        || (NtStatus == STATUS_OBJECT_NAME_INVALID)
        || (NtStatus == STATUS_OBJECT_TYPE_MISMATCH)
        || (NtStatus == STATUS_INVALID_OWNER))
        {
        return(RPC_S_INVALID_ENDPOINT_FORMAT);
        }

#if DBG
        if (NtStatus != STATUS_OBJECT_NAME_COLLISION)
        {
        PrintToDebugger("RPC : NtCreatePort : %lx\n", NtStatus);
        }
#endif // DBG

    ASSERT(NtStatus == STATUS_OBJECT_NAME_COLLISION);

    // This error code may be returned if someone has put a SD
    // on the LPC port.  We should return a reasonable error on free build
    // and assert on checked builds to catch this practice.
    if (NtStatus == STATUS_PRIVILEGE_NOT_HELD)
        {
        return(RPC_S_ACCESS_DENIED);
        }

    return(RPC_S_DUPLICATE_ENDPOINT);
}


extern RPC_CHAR  *
ULongToHexString (
    IN RPC_CHAR  * String,
    IN unsigned long Number
    );


RPC_STATUS
LRPC_ADDRESS::ServerSetupAddress (
    IN RPC_CHAR * NetworkAddress,
    IN RPC_CHAR  *  *Endpoint,
    IN unsigned int PendingQueueSize,
    IN void  * SecurityDescriptor, OPTIONAL
    IN unsigned long EndpointFlags,
    IN unsigned long NICFlags
    )
/*++

Routine Description:

    We need to setup the connection port and get ready to receive remote
    procedure calls.  We will use the name of this machine as the network
    address.

Arguments:

    Endpoint - Supplies the endpoint to be used will this address.

    NetworkAddress - Returns the network address for this server.  The
        ownership of the buffer allocated to contain the network address
        passes to the caller.

    SecurityDescriptor - Optionally supplies a security descriptor to
        be placed on this address.

    PendingQueueSize - Unused.

    RpcProtocolSequence - Unused.

Return Value:

    RPC_S_OK - We successfully setup this address.

    RPC_S_INVALID_SECURITY_DESC - The supplied security descriptor is
        invalid.

    RPC_S_CANT_CREATE_ENDPOINT - The endpoint format is correct, but
        the endpoint can not be created.

    RPC_S_INVALID_ENDPOINT_FORMAT - The endpoint is not a valid
        endpoint for this particular transport interface.

    RPC_S_OUT_OF_RESOURCES - Insufficient resources are available to
        setup the address.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to setup
        the address.

--*/
{
    RPC_CHAR * String;
    RPC_STATUS Status ;
    RPC_CHAR DynamicEndpoint[64];
    static unsigned int DynamicEndpointCount = 0;
    ULONG EndpointLength;

    UNUSED(PendingQueueSize);

    if (*Endpoint)
        {
        // the maximum allowed length in bytes is the
        // string length in bytes (string length * sizeof(RPC_CHAR)) + the NULL 
        // terminator
        EndpointLength = (RpcpStringLength(*Endpoint) + 1) * sizeof(RPC_CHAR);
        if (EndpointLength > PORT_NAME_LEN)
            {
            RpcpErrorAddRecord(EEInfoGCRuntime, 
                RPC_S_INVALID_ENDPOINT_FORMAT,
                EEInfoDLLRPC_ADDRESS__ServerSetupAddress10,
                *Endpoint,
                EndpointLength,
                PORT_NAME_LEN);
            return RPC_S_INVALID_ENDPOINT_FORMAT;
            }
        }

    Status = InitializeLrpcIfNecessary() ;

    if (Status != RPC_S_OK)
        {
        return Status ;
        }

    ASSERT(GlobalLrpcServer != 0) ;

    pNetworkAddressVector = (NETWORK_ADDRESS_VECTOR *)
        new char[ sizeof(NETWORK_ADDRESS_VECTOR) + sizeof(RPC_CHAR *) + sizeof(RPC_CHAR) * (MAX_COMPUTERNAME_LENGTH + 1)];

    if (pNetworkAddressVector == NULL)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    (pNetworkAddressVector)->Count = 1;
    (pNetworkAddressVector)->NetworkAddresses[0] = (RPC_CHAR *)
        (((char *) pNetworkAddressVector) + sizeof(NETWORK_ADDRESS_VECTOR) + sizeof(RPC_CHAR *));

    RpcpStringCopy((pNetworkAddressVector)->NetworkAddresses[0], gLocalComputerName);

    if (*Endpoint)
        {
        Status = ActuallySetupAddress(*Endpoint, SecurityDescriptor);
        }
    else
        {
        for (;;)
            {
            String = DynamicEndpoint;

            *String++ = RPC_CONST_CHAR('L');
            *String++ = RPC_CONST_CHAR('R');
            *String++ = RPC_CONST_CHAR('P');
            *String++ = RPC_CONST_CHAR('C');

            String = ULongToHexString(String,
                       PtrToUlong(NtCurrentTeb()->ClientId.UniqueProcess));
            DynamicEndpointCount += 1;
            *String++ = RPC_CONST_CHAR('.');
            String = ULongToHexString(String, DynamicEndpointCount);
            *String = 0;

            Status = ActuallySetupAddress(DynamicEndpoint, SecurityDescriptor);

            if (Status != RPC_S_DUPLICATE_ENDPOINT)
                {
                break;
                }
            }

        if (Status == RPC_S_OK)
            {
            *Endpoint = DuplicateString(DynamicEndpoint);
            if (*Endpoint == 0)
                {
                Status = RPC_S_OUT_OF_MEMORY;
                }
            else
                {
                return(RPC_S_OK);
                }
            }
        }

    if (Status != RPC_S_OK)
        {
        delete pNetworkAddressVector;
        pNetworkAddressVector = NULL;
        }

    return Status;
}

RPC_STATUS
LRPC_ADDRESS::CompleteListen (
    )
/*++
Function Name:CompleteListen

Parameters:

Description:

Returns:

--*/
{
    LRPC_ADDRESS *LocalAddress;

    if (DebugCell)
        {
        CStackAnsi AnsiEndpoint;
        int i;
        RPC_STATUS RpcStatus;

        i = RpcpStringLength(InqEndpoint()) + 1;
        *(AnsiEndpoint.GetPAnsiString()) = (char *)_alloca(i);

        RpcStatus = AnsiEndpoint.Attach(InqEndpoint(), i, i * 2);

        // note that effectively we ignore the result. That's ok - we don't
        // want servers to be unable to start because of code page issues
        // in the debug path. If this fails and we ignore it, the worse
        // that can happen is to have empty endpoint in the debug cell 
        // - not a big deal.
        if (RpcStatus == RPC_S_OK)
            {
            strncpy(DebugCell->EndpointName, AnsiEndpoint, sizeof(DebugCell->EndpointName));
            }
        
        DebugCell->Status = desActive;
        }

    do
        {
        AddressChain = LrpcAddressList;
        }
    while (InterlockedCompareExchangePointer((PVOID *)&LrpcAddressList, this, LrpcAddressList) != AddressChain);

    return(RPC_S_OK);
}



inline LRPC_SASSOCIATION *
LRPC_ADDRESS::ReferenceAssociation (
    IN unsigned long AssociationKey
    )
/*++

Routine Description:

    Given an assocation key, we need to map it into an association.  The
    association may already have been deleted, in which case, we need to
    return zero.

Arguments:

    AssociationKey - Supplies the key to be used to map into an association.

Return Value:

    If the association still exists, it will be returned; otherwise, zero
    will be returned.

--*/
{
    LRPC_SASSOCIATION * Association;
    LPC_KEY *LpcKey = (LPC_KEY *) &AssociationKey;
    USHORT MySequenceNumber;

    ASSERT(SERVERKEY(AssociationKey));

    MySequenceNumber = LpcKey->SeqNumber & ~SERVER_KEY_MASK;

    AddressMutex.Request();
    Association = AssociationDictionary.Find(LpcKey->AssocKey);
    if (Association == 0
        || Association->SequenceNumber != MySequenceNumber)
        {
        AddressMutex.Clear();
        return(0);
        }
    Association->AssociationReferenceCount++;

    LogEvent(SU_SASSOC, EV_INC, Association, 0,
             Association->AssociationReferenceCount, 1, 1);
    AddressMutex.Clear();

    return(Association);
}


inline LRPC_CASSOCIATION *
LRPC_ADDRESS::ReferenceClientAssoc (
    IN unsigned long AssociationKey
    )
/*++

Routine Description:

    Given an assocation key, we need to map it into an association.  The
    association may already have been deleted, in which case, we need to
    return zero.

Arguments:

    AssociationKey - Supplies the key to be used to map into an association.

Return Value:

    If the association still exists, it will be returned; otherwise, zero
    will be returned.

--*/
{
    LRPC_CASSOCIATION * Association;
    LPC_KEY *LpcKey = (LPC_KEY *) &AssociationKey;

    LrpcMutexRequest();
    Association = LrpcAssociationDict->Find(LpcKey->AssocKey);
    if (Association == 0
        || Association->SequenceNumber != LpcKey->SeqNumber)
        {
        LrpcMutexClear();
        return(0);
        }

    Association->AddReference();
    LrpcMutexClear();

    return(Association);
}

#if defined(_WIN64)
#define BAD_HANDLE_CONST  ((HANDLE)0xbaaaaaadbaaaaaad)
#else
#define BAD_HANDLE_CONST  (ULongToHandle(0xbaaaaaad))
#endif


inline void
LRPC_ADDRESS::DereferenceAssociation (
    IN LRPC_SASSOCIATION * Association
    )
/*++

Routine Description:

    We are done using this address, so the reference count can be decremented.
    If no one is referencing this association, then we can go ahead and
    delete it.

Arguments:

    Association - Supplies the association whose reference count should be
        decremented.

--*/
{
    NTSTATUS NtStatus;

    AddressMutex.Request();

    Association->AssociationReferenceCount -= 1;

    ASSERT(Association->AssociationReferenceCount >= 0);

    LogEvent(SU_SASSOC, EV_DEC, Association, 0,
             Association->AssociationReferenceCount, 1, 1);

    if (Association->AssociationReferenceCount <= 0)
        {
        AssociationDictionary.Delete(Association->DictionaryKey);
        AssociationCount--;
        AddressMutex.Clear();

        if (Association->LpcServerPort)
            {
            NtStatus = NtClose(Association->LpcServerPort);
            Association->LpcServerPort = BAD_HANDLE_CONST;
            LogEvent(SU_SASSOC, EV_STOP, Association, Association->LpcServerPort,
                     Association->AssociationReferenceCount, 1, 1);

#if DBG
            if (!NT_SUCCESS(NtStatus))
                {
                PrintToDebugger("RPC : NtClose : %lx\n", NtStatus);
                                ASSERT(0) ;
                }
#endif // DBG
            }

        if (Association->LpcReplyPort)
            {
            NtStatus = NtClose(Association->LpcReplyPort);

#if DBG
            if (!NT_SUCCESS(NtStatus))
                {
                PrintToDebugger("RPC : NtClose : %lx\n", NtStatus);
                                ASSERT(0) ;
                }
#endif // DBG

            }

        delete Association;
        }
    else
        {
        AddressMutex.Clear();
        }
}

BOOL
LRPC_ADDRESS::DealWithLRPCRequest (
    IN LRPC_MESSAGE * LrpcMessage,
    IN LRPC_MESSAGE * LrpcReply,
    IN LRPC_SASSOCIATION *Association,
    OUT LRPC_MESSAGE **LrpcResponse
    )
/*++

Routine Description:

    Deal with a new LRPC request.

Arguments:

 LrpcMessage - request message
 LrpcReply - the reply is placed here
 Association - the association on which the request arrived

Return Value:

  FALSE if the thread should stay, or !FALSE if the thread should go
--*/

{
    int retval ;
    LRPC_SCALL *SCall;
    NTSTATUS NtStatus ;
    RPC_STATUS Status;
    LRPC_SCALL *NewSCall ;
    int Flags = LrpcMessage->Rpc.RpcHeader.Flags ;

    if (ServerListeningFlag == 0
        && GlobalRpcServer->InqNumAutoListenInterfaces() == 0)
        {
        *LrpcResponse = LrpcMessage ;
        RpcpErrorAddRecord(EEInfoGCRuntime, 
            RPC_S_SERVER_TOO_BUSY, 
            EEInfoDLDealWithLRPCRequest10,
            (ULONG)ServerListeningFlag, 
            (ULONG)GlobalRpcServer->InqNumAutoListenInterfaces());
        SetFaultPacket(*LrpcResponse,
                              RPC_S_SERVER_TOO_BUSY, Flags, NULL);
        return 0;
        }

    Status = Association->AllocateSCall(LrpcMessage,
                                       LrpcReply,
                                       Flags, 
                                       &SCall) ;
    if (Status != RPC_S_OK)
        {
        *LrpcResponse = LrpcMessage ;
        RpcpErrorAddRecord(EEInfoGCRuntime, 
            Status, 
            EEInfoDLDealWithLRPCRequest20);
        SetFaultPacket(*LrpcResponse, Status, Flags, NULL);
        return 0 ;
        }

    ASSERT(SCall);

    Status = SCall->LrpcMessageToRpcMessage(LrpcMessage,
                                            &(SCall->RpcMessage));

    if (Status != RPC_S_OK)
        {
#if DBG
        PrintToDebugger("LRPC: LrpcMessageToRpcMessage failed: %d\n",
                                                       Status) ;
#endif

        *LrpcResponse = LrpcMessage ;
        SetFaultPacket(*LrpcResponse, Status, Flags, NULL);

        Association->FreeSCall (SCall) ;
        return 0;
        }

    AddressMutex.Request();

    if (SCall->Flags & LRPC_CAUSAL)
        {
        retval = Association->MaybeQueueSCall(SCall) ;
        switch (retval)
            {
            case 0:
                break;

            case 1:
                AddressMutex.Clear();
                *LrpcResponse = NULL ;
                return 0;

            case -1:
                AddressMutex.Clear();
                *LrpcResponse = LrpcMessage ;

                RpcpErrorAddRecord(EEInfoGCRuntime, 
                    RPC_S_OUT_OF_MEMORY, 
                    EEInfoDLDealWithLRPCRequest30);
                SetFaultPacket(*LrpcResponse, LRPC_MSG_FAULT, Flags, NULL);

                Association->FreeSCall (SCall) ;
                return 0;
            }
        }

    ActiveCallCount += 1;

    if (ActiveCallCount >= CallThreadCount)
        {
        Status = Server->CreateThread(
                         (THREAD_PROC)&RecvLotsaCallsWrapper,
                         this);

        if (Status == RPC_S_OK)
            {
            CallThreadCount += 1;
            }
        else
            {
            // If the above SCall is causal and creating the thread has failed
            // then the call has been put into the dictionary and needs
            // to be removed.  It will be the only scall for the key.
            if (SCall->Flags & LRPC_CAUSAL)
                Association->ClientThreadDict.Delete(MsgClientIdToClientId(SCall->LrpcRequestMessage->Rpc.LpcHeader.ClientId).UniqueThread) ;

            ActiveCallCount -= 1;
            ASSERT((int)ActiveCallCount >= 0);
            AddressMutex.Clear();
            *LrpcResponse = LrpcMessage ;
            RpcpErrorAddRecord(EEInfoGCRuntime, 
                Status, 
                EEInfoDLDealWithLRPCRequest40);
            SetFaultPacket(*LrpcResponse,
                          RPC_S_SERVER_TOO_BUSY, Flags, NULL);

            Association->FreeSCall(SCall) ;
            return 0;
            }
        }
    AddressMutex.Clear();

    while (1)
        {
        LrpcReply->Rpc.RpcHeader.Flags = 0;

        SCall->DealWithRequestMessage();

        if ((SCall->Flags & LRPC_CAUSAL) == 0)
            {
            break;
            }

        NewSCall = Association->GetNextSCall(SCall) ;
        if (NewSCall)
            {
            SCall->SendReply();

            SCall = NewSCall ;
            while (SCall->Deleted)
                {
                NewSCall = Association->GetNextSCall(SCall) ;

                // GetNextSCall will touch SCall->LrpcRequestMessage so it should
                // be freed after the call.
                FreeMessage(SCall->LrpcRequestMessage) ;

                AddressMutex.Request();

                //
                // N.B. If a causally ordered call fails
                // in DealWithRequestMessage, this is fine, because
                // in SendReply, if we send back a fault,
                // we will mark all calls in the SCallDict with Deleted,
                // and in this loop, we will skip them.
                //
                if (NewSCall == 0)
                    {
                    if (fKeepThread())
                        {
                        retval = 0;
                        }
                    else
                        {
                        CallThreadCount -= 1;
                        retval = 1;
                        }
                    ActiveCallCount -= 1;
                    ASSERT((int)ActiveCallCount >= 0);
                    AddressMutex.Clear();

                    Association->FreeSCall(SCall) ;
                    DereferenceAssociation(Association) ;

                    *LrpcResponse = NULL ;

                    return retval;
                    }

                AddressMutex.Clear();

                Association->FreeSCall(SCall) ;
                DereferenceAssociation(Association) ;

                SCall = NewSCall ;
                }

            RpcpPurgeEEInfo();
            }
        else
            {
            break;
            }

        // Make sure that the LrpcReplyMessage is always pointing to the
        // one located on this thread's stack.  It is possible that we
        // will pick up a queued scall that was put into the queue on
        // another thread.  In this case, the LrpcReplyMessage may point to
        // that thread's stack - a recepie for disaster.
        // Note that LrpcReply is located on the stack for the current thread.
        LrpcReply->Rpc.RpcHeader.CallId = SCall->CallId ;
        SCall->LrpcReplyMessage = LrpcReply;

        }

    AddressMutex.Request();
    if (fKeepThread())
        {
        if (SCall->IsSyncCall() && SCall->IsClientAsync() == 0)
            {
            ActiveCallCount -= 1;
            ASSERT((int)ActiveCallCount >= 0);
            AddressMutex.Clear();

            *LrpcResponse = SCall->InitMsg();

            Association->FreeSCall(SCall) ;
            }
        else
            {
            AddressMutex.Clear();

            *LrpcResponse = NULL;

            SCall->SendReply();

            AddressMutex.Request();
            ActiveCallCount -= 1;
            ASSERT((int)ActiveCallCount >= 0);
            AddressMutex.Clear();
            }

        return 0 ;
        }

    //
    // This thread is extraneous, reply and return this
    // thread to the system.
    //
    ActiveCallCount -= 1;
    ASSERT((int)ActiveCallCount >= 0);
    CallThreadCount -= 1;
    AddressMutex.Clear();

    SCall->SendReply();

    return 1 ;
}

#define LRPC_LISTEN_TIMEOUT  5*60*1000

inline void
FormatTimeOut(
    OUT PLARGE_INTEGER TimeOut,
    IN DWORD Milliseconds
    )
{
    ASSERT(Milliseconds != -1);

    TimeOut->QuadPart = UInt32x32To64( Milliseconds, 10000 );
    TimeOut->QuadPart *= -1;
}

RPC_STATUS
LRPC_ADDRESS::BeginLongCall(
    void
    )
{
    RPC_STATUS Status = RPC_S_OK;

    AddressMutex.Request();

    if (ActiveCallCount + 1 >= CallThreadCount)
        {
        AddressMutex.Clear();

        Status = Server->CreateThread(
                         (THREAD_PROC)&RecvLotsaCallsWrapper,
                         this);

        AddressMutex.Request();

        // N.B. We increase the active call count
        // regrdless of Status. This is OK, because
        // if we return failure, the caller of this function
        // is responsible to decrease it
        ActiveCallCount ++;

        if (Status == RPC_S_OK)
            {
            CallThreadCount += 1;
            }
        }
    else
        {
        ActiveCallCount ++;
        }
    AddressMutex.Clear();
    return Status;
}

void LRPC_ADDRESS::HandleInvalidAssociationReference (
    IN LRPC_MESSAGE *RequestMessage,
    IN OUT LRPC_MESSAGE **ReplyMessage,
    IN ULONG AssociationKey
    )
{
    ASSERT(RequestMessage != NULL);
    ASSERT(ReplyMessage != NULL);

    // we handle only binds, requests and copies
    if ((RequestMessage->Bind.MessageType != LRPC_MSG_REQUEST)
        && (RequestMessage->Bind.MessageType != LRPC_MSG_BIND)
        && (RequestMessage->Bind.MessageType != LRPC_MSG_COPY))
        {
        *ReplyMessage = NULL;
        return;
        }

    RpcpErrorAddRecord(EEInfoGCRuntime, 
        RPC_S_CALL_FAILED_DNE,
        EEInfoDLLRPC_ADDRESS__HandleInvalidAssociationReference10,
        AssociationKey);

    if (RequestMessage->Bind.MessageType == LRPC_MSG_BIND)
        {
        SetBindAckFault(RequestMessage, RPC_S_CALL_FAILED_DNE);

        // if this is bind, patch up the fields a bit, as SetFaultPacket
        // does not set everything right for the bind case
        RequestMessage->Bind.MessageType = LRPC_BIND_ACK;
        }
    else
        {
        SetFaultPacket(RequestMessage, 
            RPC_S_CALL_FAILED_DNE, 
            RequestMessage->Rpc.RpcHeader.Flags, 
            NULL);
        }

    *ReplyMessage = RequestMessage;
}

BOOL
LRPC_ADDRESS::EndLongCall(
    void
    )
{
    AddressMutex.Request();
    ActiveCallCount -= 1;

    int SpareThreads = CallThreadCount -
        (ActiveCallCount + MinimumCallThreads);

    if (SpareThreads > 0)
        {
        ASSERT(CallThreadCount > ActiveCallCount);

        AddressMutex.Clear();

        return TRUE;
        }

    AddressMutex.Clear();

    return FALSE;
}

#define GC_TIMER_CHECK_INTERVAL (256)

#define GC_TIME_INTERVAL LRPC_LISTEN_TIMEOUT

ULONG LastGCTime = 0;


void
LRPC_ADDRESS::ReceiveLotsaCalls (
    )
/*++

Routine Description:

    Here is where we receive remote procedure calls to this address.  One
    more threads will be executing this routine at once.

--*/
{
    NTSTATUS NtStatus;
    LRPC_SASSOCIATION * Association;
    LRPC_CASSOCIATION *CAssociation;
    unsigned long AssociationKey;
    LRPC_MESSAGE * Reply;
    LRPC_MESSAGE * LrpcMessage = 0;
    LRPC_MESSAGE * LrpcReplyMessage = 0;
    int AssociationType = 0;
    int Flags = 0;
    BOOL PartialFlag  ;
    BOOL fStatus ;
    RPC_STATUS Status;

    // The key for the association for which we had just processed an LPC message.
    // If we get an error while replying for the message on this association, then
    // it will be torn down.
    // This value will remain valid only while we are
    // replying to the message on that association.  After that, we may handle an invalid
    // association reference, etc. making the key no longer valid.  After a reply message is sent,
    // the ReplyKey will be invalidated so that we don't tear up wrong associations on error.
    unsigned long ReplyKey = -1;
  

    LARGE_INTEGER LongTimeout;
    LARGE_INTEGER ShortTimeout;
    PLARGE_INTEGER pliTimeout = &ShortTimeout;
    ULONG_PTR Key;
    THREAD *ThisThread;
    DebugThreadInfo *DebugCell;

    // The number of LRPC calls that have been processed since the last GC
    // has been done.  We will check the timer to see if garbage collection
    // needs to be done once every GC_TIMER_CHECK_INTERVAL calls.
    // Then, if more then GC_TIME_INTERVAL milliseconds have passed since 
    // the last GC, we will GC.
    ULONG NumProcessedLrpcCalls = 0;

    FormatTimeOut(&ShortTimeout, gThreadTimeout);
    FormatTimeOut(&LongTimeout, LRPC_LISTEN_TIMEOUT);
    pliTimeout = &ShortTimeout;

    Reply = (LRPC_MESSAGE *)AlignOnNaturalBoundary(
        _alloca(sizeof(LRPC_MESSAGE) + RPCRT_NATURAL_BOUNDARY_ALIGNMENT_MAX_SHIFT));

    ThisThread = RpcpGetThreadPointer();
    ASSERT(ThisThread);

    DebugCell = ThisThread->DebugCell;

    if (DebugCell)
        {
        if (this->DebugCell)
            {
            GetDebugCellIDFromDebugCell(
                (DebugCellUnion *)this->DebugCell, 
                &this->DebugCellTag, 
                &ThisThread->DebugCell->Endpoint);
            }
        }

    // We need to check if GC is needed.  This is necessary because
    // this thread may have been recycled before it had a chance to execute
    // GC_TIMER_CHECK_INTERVAL calls.  If this keeps repeating we will never
    // get to GC.
    if (NtGetTickCount() - LastGCTime >= GC_TIME_INTERVAL)
        {
        LastGCTime = NtGetTickCount();
        PerformGarbageCollection();
        }

    for (;;)
        {
        if (LrpcMessage == 0)
            {
            while ((LrpcMessage = AllocateMessage()) == 0)
                {
                Sleep(100) ;
                }
            }

        ASSERT(LrpcReplyMessage == 0
            || LrpcReplyMessage->Rpc.RpcHeader.MessageType <= MAX_LRPC_MSG);

        if (DebugCell)
            {
            DebugCell->Status = dtsIdle;
            DebugCell->LastUpdateTime = NtGetTickCount();
            }

        RpcpPurgeEEInfoFromThreadIfNecessary(ThisThread);

#if DBG
        if (LrpcReplyMessage)
            {
            LogEvent(SU_SASSOC, EV_PKT_OUT, this, UlongToHandle(LrpcReplyMessage->LpcHeader.MessageId), 
                (HandleToULong(LrpcReplyMessage->LpcHeader.ClientId.UniqueProcess)<<16 | \
                 (HandleToULong(LrpcReplyMessage->LpcHeader.ClientId.UniqueThread))), 0, 0);
            }
#endif  // DBG

        NtStatus = NtReplyWaitReceivePortEx(LpcAddressPort,
                                         (PVOID *) &Key,
                                         (PORT_MESSAGE *) LrpcReplyMessage,
                                         (PORT_MESSAGE *) LrpcMessage,
                                         pliTimeout);

        AssociationKey = (ULONG) Key; // need this for 64bit

        if (NtStatus != STATUS_TIMEOUT
            && NT_SUCCESS(NtStatus))
            {
            // We have sucessfully sent a reply, forget the ReplyKey since we may now deal with
            // another association.
            ReplyKey = -1;

            if (pliTimeout != &ShortTimeout)
                {
#if defined (RPC_GC_AUDIT)
                DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) LPC Thread %X: coming back from long wait\n",
                    GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId());
#endif
                ASSERT((pliTimeout == NULL) || (pliTimeout == &LongTimeout));
                ThreadsDoingLongWait.Decrement();
                pliTimeout = &ShortTimeout;
                }

            if (DebugCell)
                {
                DebugCell->Status = dtsProcessing;
                DebugCell->LastUpdateTime = NtGetTickCount();
                }

#if 0
            if (LrpcMessage->LpcHeader.u2.s2.Type == LPC_CONNECTION_REQUEST)
                LogEvent(SU_PACKET, EV_PKT_IN, (void *) LrpcMessage->LpcHeader.u2.ZeroInit, 
                    (void *)LrpcMessage->Connect.BindExchange.ConnectType, AssociationKey);
            else
                LogEvent(SU_PACKET, EV_PKT_IN, (void *) LrpcMessage->LpcHeader.u2.ZeroInit, 
                    0, AssociationKey);
#endif


#if defined RPC_LRPC_CORRUPTION

            unsigned int BufferLength = PORT_MAXIMUM_MESSAGE_LENGTH

            if (gfRPCVerifierEnabled)
                {
                CorruptionInject(ServerReceive,
                                 &BufferLength,
                                 (void **)&LrpcMessag);
                }

#endif // RPC_LRPC_CORRUPTION

            if (LrpcMessage->LpcHeader.u2.s2.Type == LPC_DATAGRAM
                || LrpcMessage->LpcHeader.u2.s2.Type == LPC_REQUEST)
                {
                if (!SERVERKEY(AssociationKey))
                    {
                    VALIDATE(LrpcMessage->Bind.MessageType)
                        {
                        LRPC_MSG_FAULT,
                        LRPC_MSG_FAULT2,
                        LRPC_MSG_RESPONSE,
                        LRPC_CLIENT_SEND_MORE
                        } END_VALIDATE;

                    //
                    // response or fault on the back connection.
                    // we are using async rpc or pipes
                    //
                    
                    CAssociation = ReferenceClientAssoc(AssociationKey);
                    if (CAssociation)
                        {
 
                        LrpcReplyMessage = 0;

                        //
                        // In order to avoid a possible deadlock, we must not wait on the AssociationMutex
                        // if we cannot create a thread to take our place.
                        // The deadlock scenario is: CAssociation is aborted due to a client failure 
                        // with some active calls.  The client makes a new call which leads to the client reconnecting 
                        // to the server and asking for a bind back (which holding the AssociationMutex).
                        // The server, before binding back, sends a reply to one of the active calls.
                        // This gets dispatched to here, but BeginLongCall fails.  The request ends up waiting
                        // on the AssociationMutex while the server's bind back gets queued behind it
                        // with no worker threads to service it and we are deadlocked.
                        //
                        while(1){
                            
                            Status = BeginLongCall();
                            if (Status == RPC_S_OK)
                                {
                                CAssociation->ProcessResponse(LrpcMessage, FALSE, &LrpcReplyMessage);
                                break;
                                }
                            else if (CAssociation->AssociationMutex.TryRequest() == TRUE)
                                {
                                //
                                // We failed to create a worker thread to take our place, but we took the association
                                // mutex, so we can process the response without fear of deadlock
                                //
                                CAssociation->ProcessResponse(LrpcMessage, TRUE, &LrpcReplyMessage);
                                break;
                                }
                            else
                                {
                                //
                                // We couldn't create a thread and we also could not get the mutex, we need
                                // to retry.
                                //
                                Sleep(200);
                                EndLongCall();
                                }
                            }

                        //
                        // the receive thread needs to allocate a new message
                        //
                        LrpcMessage = 0 ;

                        CAssociation->RemoveReference() ;

                        EndLongCall();
                        
                        }
                    else
                        {
                        HandleInvalidAssociationReference(LrpcMessage,
                            &LrpcReplyMessage,
                            AssociationKey);
                        }

                    continue;
                    }

                Association = ReferenceAssociation(AssociationKey);
                if (Association == 0)
                    {
                    HandleInvalidAssociationReference(LrpcMessage,
                        &LrpcReplyMessage,
                        AssociationKey);
                    continue;
                    }

                // Since we had sucessfully found an association for this Key, remember it
                // for  sending reply.
                ReplyKey = AssociationKey;

                Flags = LrpcMessage->Rpc.RpcHeader.Flags ;
                PartialFlag = FALSE ;

                // If we had processed enough calls, check if enough time
                // has passed to GC, and GC if necessary.
                if (NumProcessedLrpcCalls++ > GC_TIMER_CHECK_INTERVAL)
                    {
                    NumProcessedLrpcCalls = 0;
                    if (NtGetTickCount() - LastGCTime >= GC_TIME_INTERVAL)
                        {
                        LastGCTime = NtGetTickCount();
                        PerformGarbageCollection();
                        }
                    }

                if (LrpcMessage->Bind.MessageType == LRPC_MSG_REQUEST)
                    {
                    //
                    // Optimize the common case
                    //
                    fStatus = DealWithLRPCRequest (
                                        LrpcMessage,
                                        Reply,
                                        Association,
                                        &LrpcReplyMessage) ;

                    if (fStatus)
                        {
                        // this is the first of two exits from the loop
                        // (the second is below)
                        if (DebugCell)
                            {
                            DebugCell->Status = dtsAllocated;
                            DebugCell->LastUpdateTime = NtGetTickCount();
                            }

                        return;
                        }

                    if (LrpcReplyMessage == 0)
                        {
                        LrpcMessage = 0;
                        }
                    else
                        {
                        DereferenceAssociation(Association);
                        }
                    }
                else
                    {
                    switch (LrpcMessage->Bind.MessageType)
                        {
                        case LRPC_PARTIAL_REQUEST:
                        case LRPC_SERVER_SEND_MORE:
                        case LRPC_MSG_CANCEL:
                            LrpcReplyMessage = Association->
                                DealWithPartialRequest(&LrpcMessage) ;
                            break;

                        case LRPC_MSG_COPY:
                            LrpcReplyMessage = Association->DealWithCopyMessage(
                                (LRPC_COPY_MESSAGE *)LrpcMessage);
                            break;

                        case LRPC_MSG_BIND :
                            Association->DealWithBindMessage(LrpcMessage);

                            LrpcReplyMessage = 0 ;
                            break;


                        case LRPC_MSG_BIND_BACK:
                            BeginLongCall();

                            LrpcReplyMessage = Association->
                                DealWithBindBackMessage(LrpcMessage);

                            EndLongCall();
                            break;

                        default:
#if DBG
                            PrintToDebugger("RPC : Bad Message Type (%d) - %d\n",
                                        LrpcMessage->Bind.MessageType,
                                        LrpcMessage->LpcHeader.u2.s2.Type);
#endif // DBG

                            CORRUPTION_ASSERT(0) ;
                            LrpcReplyMessage = 0 ;
                            Association->Delete();
                            break;
                        }
                    DereferenceAssociation(Association);
                    }
                }
            else
                {
                switch (LrpcMessage->LpcHeader.u2.s2.Type)
                    {
                    case LPC_CONNECTION_REQUEST:
                        if (LrpcMessage->Connect.BindExchange.ConnectType
                            == LRPC_CONNECT_REQUEST)
                            {
                            BeginLongCall();

                            DealWithNewClient(LrpcMessage) ;

                            EndLongCall();
                            }
                        else if (LrpcMessage->Connect.BindExchange.ConnectType
                                 == LRPC_CONNECT_RESPONSE)
                            {
                            DealWithConnectResponse(LrpcMessage) ;
                            }
                        else if (LrpcMessage->Connect.BindExchange.ConnectType
                                 == LRPC_CONNECT_TICKLE)
                            {
                            HANDLE Ignore;

                            // always reject - this just has the purpose of tickling
                            // a thread on a long wait
                            NtStatus = NtAcceptConnectPort(&Ignore,
                                                           NULL,
                                                           (PORT_MESSAGE *) LrpcMessage,
                                                           FALSE,
                                                           NULL,
                                                           NULL);
#if defined (RPC_GC_AUDIT)
                            DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) LPC Thread %X: tickled\n",
                                GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId());
#endif
                            }
                        else
                            {
                            CORRUPTION_ASSERT(0) ;
                            }
                        LrpcReplyMessage = 0;
                        break;

                    case LPC_CLIENT_DIED:
                        LrpcReplyMessage = 0;
                        break;

                    case LPC_PORT_CLOSED:
                        if (SERVERKEY(AssociationKey))
                            {
                            Association = ReferenceAssociation(AssociationKey);
                            if (Association == 0)
                                {
                                LrpcReplyMessage = 0;
                                continue;
                                }
                            
                            BeginLongCall();

                            Association->Delete();
                            DereferenceAssociation(Association);

                            LrpcReplyMessage = 0;

                            EndLongCall();
                            }
                        else
                            {
                            CAssociation = ReferenceClientAssoc(AssociationKey);
                            if (CAssociation)
                                {
                                BeginLongCall();
                                CAssociation->AbortAssociation(1) ;
                                CAssociation->RemoveReference() ;
                                EndLongCall();
                                }

                            LrpcReplyMessage = 0;
                            }
                        continue;

                    default:
                        LrpcReplyMessage = 0 ;
                        CORRUPTION_ASSERT(0);
                    } // switch
                } // else
            } // if
        else
            {
            switch (NtStatus)
                {
                case STATUS_NO_MEMORY:
                case STATUS_INSUFFICIENT_RESOURCES:
                    PauseExecution(500L);
                    break;

                //
                // This error is returned after the reply has been sent successfully, so do not send
                // the reply again.
                case STATUS_UNSUCCESSFUL:                    
                    LrpcReplyMessage = 0;
                    break;
                    
                case STATUS_TIMEOUT:
#if defined (RPC_GC_AUDIT)
                    DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) LPC Thread %X: timed out - gc\n",
                        GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId());
#endif

                    // We have sucessfully sent a reply.
                    ReplyKey = -1;

                    PerformGarbageCollection();

                    if (pliTimeout == &ShortTimeout)
                        {
                        // be conservative and presume we will
                        // be doing long wait. If later we find out
                        // we won't, we'll reverse that. Also, this must
                        // be done nefore we check for 
                        // GarbageCollectedRequested - this allows other
                        // threads to safely count the number of threads
                        // on short wait without taking a mutex
                        ThreadsDoingLongWait.Increment();

                        LrpcReplyMessage = 0;
                        // if there is garbage collection
                        // requested, don't switch to long
                        // wait
                        if (GarbageCollectionRequested)
                            {
#if defined (RPC_GC_AUDIT)
                            DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) LPC Thread %X: gc requested - can't do long wait\n",
                                GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId());
#endif
                            ThreadsDoingLongWait.Decrement();
                            }
                        else
                            {
#if defined (RPC_GC_AUDIT)
                            DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) LPC Thread %X: going to long wait\n",
                                GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId());
#endif
                            // there is no garbage collection requested
                            // switch to longer wait (but not infinite yet)
                            pliTimeout = &LongTimeout;
                            }
                        }
                    else if (pliTimeout == &LongTimeout)
                        {
                        // if this is a long wait, and we're a spare
                        // thread, we can go
                        AddressMutex.Request();
                        if (CallThreadCount - ActiveCallCount > 1)
                            {
                            CallThreadCount -= 1;
                            ASSERT(CallThreadCount > ActiveCallCount);
                            AddressMutex.Clear();

                            // decrease the counter of threads doing long
                            // listen after we decrease the CallThreadCount
                            // This allows other threads to use the number
                            // of threads doing short wait without taking
                            // a mutex
                            ThreadsDoingLongWait.Decrement();

                            FreeMessage(LrpcMessage);

                            // N.B. This is the second exit from the loop (see above)
                            if (DebugCell)
                                {
                                DebugCell->Status = dtsAllocated;
                                DebugCell->LastUpdateTime = NtGetTickCount();
                                }

                            return;
                            }
                         else
                            {
                            //
                            // We are assuming that if the call has timed out, the reply has
                            // been sent
                            //
                            LrpcReplyMessage = 0;
                            pliTimeout = NULL;
#if defined (RPC_GC_AUDIT)
                            DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) LPC Thread %X: going to infinite wait\n",
                                GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId());
#endif
                            }
                        AddressMutex.Clear();
                        }
                    else
                        {
                        ASSERT(!"We cannot get a timeout on wait with infinite timeout");
                        }

                    if (DebugCell)
                        {
                        RelocateCellIfPossible((void **) &DebugCell, &ThisThread->DebugCellTag);
                        ThisThread->DebugCell = DebugCell;
                        }
                    break;

                default:


                    if (LrpcReplyMessage)
                        {
                        LogEvent(SU_SASSOC, EV_ABORT, this, UlongToHandle(NtStatus), ((HandleToULong(((PORT_MESSAGE*)LrpcReplyMessage)->ClientId.UniqueProcess))<<16 | \
                                                      (HandleToULong(((PORT_MESSAGE*)LrpcReplyMessage)->ClientId.UniqueThread))), 1, 0);
                        LrpcReplyMessage = 0;
                        if (ReplyKey != -1)
                            {
                            Association = ReferenceAssociation(ReplyKey);
                            if (Association == 0)
                                {
                                continue;
                                }
                            }
                        else
                            continue;
                        

                        BeginLongCall();

                        Association->Delete();
                        DereferenceAssociation(Association);
                        
                        EndLongCall();
                        }
                    break;
                } // switch
            } // else
        } // for
}

#define DEFAULT_PORT_DIR      "\\RPC Control\\"
#define DEFAULT_PORT_NAME   "ARPC Port1"
#define DEFAULT_REPLY_NAME  "ARPC Reply Port"


void
LRPC_ADDRESS::DealWithNewClient (
    IN LRPC_MESSAGE * ConnectionRequest
    )
/*++

Routine Description:

    A new client has connected with our address port.  We need to take
    care of the new client and send a response.

Arguments:

    ConnectionRequest - Supplies information need by LPC to abort the
        connect request.  Includes the bind request from the client.
        This contains the information about which interface the client
        wants to bind with.  and which we use to send the status code
        back in.


--*/
{
    LRPC_SASSOCIATION * Association;
    NTSTATUS NtStatus;
    RPC_STATUS Status = RPC_S_OK;
    DWORD Key, tmpKey;
    LPC_KEY *LpcKey = (LPC_KEY *) &Key;


    Association = new LRPC_SASSOCIATION(this,
                                 &Status);
    if (Association == 0)
        {
        RejectNewClient(ConnectionRequest, RPC_S_OUT_OF_MEMORY);
        return;
        }

    if (Status != RPC_S_OK)
        {
        delete Association ;
        RejectNewClient(ConnectionRequest, RPC_S_OUT_OF_MEMORY);
        return ;
        }

    AddressMutex.Request();

    // Insert the association.  The dictionary can fit
    // 2^32 associations, but since our DictionaryKey is only
    // 16 bits, we must treat the dictionary as full if the key
    // returned is greater than 0xFFFF
    tmpKey = AssociationDictionary.Insert(Association);
    if (tmpKey > 0xFFFF)
        {
        AssociationDictionary.Delete(tmpKey);
        tmpKey = -1;
        }

    Association->DictionaryKey = (USHORT) tmpKey;
    AssociationCount++;
    
    SequenceNumber = (SequenceNumber+1) % (0x7FFF);
    Association->SequenceNumber = SequenceNumber;
    AddressMutex.Clear();

    if (Association->DictionaryKey == -1)
        {
        AddressMutex.Request();
        AssociationCount-- ;
        AddressMutex.Clear();

        delete Association ;
        RejectNewClient(ConnectionRequest, RPC_S_OUT_OF_MEMORY);
        return;
        }

    if (ConnectionRequest->Connect.BindExchange.Flags & BIND_BACK_FLAG)
        {
        ConnectionRequest->Connect.BindExchange.szPortName[PORT_NAME_LEN-1] = NULL;

        Status = Association->BindBack(
            (RPC_CHAR *)ConnectionRequest->Connect.BindExchange.szPortName,
            ConnectionRequest->Connect.BindExchange.AssocKey,
            ConnectionRequest->Connect.BindExchange.Cookie);
        if (Status != RPC_S_OK)
            {
            RejectNewClient(ConnectionRequest, RPC_S_OUT_OF_MEMORY);
            Association->Delete() ;
            return;
            }
        }

    ConnectionRequest->Connect.BindExchange.RpcStatus = RPC_S_OK;

    ASSERT(sizeof(unsigned long) <= sizeof(PVOID));
    ASSERT((Association->SequenceNumber & SERVER_KEY_MASK) == 0);
  
    LpcKey->SeqNumber = Association->SequenceNumber | SERVER_KEY_MASK;
    LpcKey->AssocKey = Association->DictionaryKey;

    // After the call to NtAcceptConnectPort, the client will become unblocked
    // the association will be in the dictionary and will have refcount 1.  If the client quits
    // or closes port the association will be deleted.  Then NtCompleteConnectPort
    // may touch invalid memory or operate on a bad handle.  To prevent that we
    // need to hold an extra count between the two calls.
    //
    // Since this thread is the only one playing with the association up to now,
    // there is no need for a lock.
    Association->AssociationReferenceCount++;

    NtStatus = NtAcceptConnectPort(&(Association->LpcServerPort),
                                   ULongToPtr(Key),
                                   (PORT_MESSAGE *) ConnectionRequest,
                                   TRUE,
                                   NULL,
                                   NULL);

    if (NT_ERROR(NtStatus))
        {
        Association->Delete();

        // We just have to dereference the association to remove the extra
        // count added above.  This should cause its deletion.
        DereferenceAssociation(Association);

#if DBG
        PrintToDebugger("RPC : NtAcceptConnectPort : %lx\n", NtStatus);
#endif // DBG

        return;
        }

    NtStatus = NtCompleteConnectPort(Association->LpcServerPort);
	 
    if (NT_ERROR(NtStatus))
        {
#if DBG
        PrintToDebugger("RPC : NtCompleteConnectPort : %lx\n", NtStatus);
#endif // DBG

        // If Association->Delete() has already been called on a different
        // theread due to a closed client port, this call will be ignored...
        Association->Delete();

        // and the final reference will be removed here causing a deletion.
        DereferenceAssociation(Association);

        return;
        }

        // Remove the extra-reference.
        DereferenceAssociation(Association);
}


void
LRPC_ADDRESS::DealWithConnectResponse (
    IN LRPC_MESSAGE * ConnectResponse
    )
/*++

Routine Description:

   Just received a connect response from the remove server,
   need to handle that.

Arguments:

    ConnectionRequest -
      Needed to get the pAssoc
--*/
{
   NTSTATUS NtStatus;
   HANDLE temp ;
   LRPC_CASSOCIATION * Association ;
   DWORD Key;

   Key = ConnectResponse->Connect.BindExchange.AssocKey;

   Association = ReferenceClientAssoc(Key);
   if (Association == 0)
       {
       RejectNewClient(ConnectResponse, RPC_S_PROTOCOL_ERROR);
       return;
       }

    //
    // Verify that the response is expected and is from the server
    // who knows our Cookie.
    //

    if (Association->BindBackCookie == NULL)
        {
        // This is an "unsolicited" response.
        CORRUPTION_ASSERT(0 && "Unexpected connect response");
        RejectNewClient(ConnectResponse, RPC_S_PROTOCOL_ERROR);
        return;
        }

    if (RpcpMemoryCompare(ConnectResponse->Connect.BindExchange.Cookie,
                          Association->BindBackCookie,
                          BIND_BACK_COOKIE_SIZE) != 0)
        {
        // The server replied with an incorrect bind back cookie.
        CORRUPTION_ASSERT(0 && "Incorrect bind back cookie");
        RejectNewClient(ConnectResponse, RPC_S_PROTOCOL_ERROR);
        return;        
        }

   NtStatus = NtAcceptConnectPort(&temp,
                                 ULongToPtr(Key),
                                 (PPORT_MESSAGE) ConnectResponse,
                                 TRUE,
                                 NULL,
                                 NULL);

   if (NT_SUCCESS(NtStatus))
       {
       Association->SetReceivePort(temp) ;

       NtStatus = NtCompleteConnectPort(temp);

       if (!NT_SUCCESS(NtStatus))
          {
#if DBG
          PrintToDebugger("LRPC: NtCompleteConnectPort(1) failed: %lx\n",
                          NtStatus) ;
#endif

          Association->Delete();
          }
       }
   else
      {
#if DBG
      PrintToDebugger("LRPC: NtAcceptConnectionPort(1) failed: %lx\n",
                      NtStatus) ;
#endif

      Association->Delete();
      }

    //
    // Remove the reference we added above
    //
    Association->RemoveReference() ;
}


void
LRPC_ADDRESS::RejectNewClient (
    IN LRPC_MESSAGE * ConnectionRequest,
    IN RPC_STATUS Status
    )
/*++

Routine Description:

    A new client has connected with our address port.  We need to reject
    the client.

Arguments:

    ConnectionRequest - Supplies information need by LPC to abort the
        connect request.  Includes the bind request from the client,
        which we use to send the status code back in.


    Status - Supplies the reason the client is being rejected.

--*/
{
    NTSTATUS NtStatus;
    HANDLE Ignore;

    ASSERT(Status != RPC_S_OK);

    ConnectionRequest->Connect.BindExchange.RpcStatus = Status;
    ConnectionRequest->Connect.BindExchange.Flags |= SERVER_BIND_EXCH_RESP;
    NtStatus = NtAcceptConnectPort(&Ignore,
                                   NULL,
                                   (PORT_MESSAGE *) ConnectionRequest,
                                   FALSE,
                                   NULL,
                                   NULL);
#if DBG
    if (!NT_SUCCESS(NtStatus))
        {
        PrintToDebugger("RPC : NtAcceptConnectPort : %lx\n", NtStatus);

        // if the client thread dies for whatever reason, NtAcceptConnectPort
        // can return STATUS_REPLY_MESSAGE_MISMATCH
        VALIDATE(NtStatus)
            {
            STATUS_INVALID_CID,
            STATUS_REPLY_MESSAGE_MISMATCH
            } END_VALIDATE;
        }
#endif // DBG
}

void
LRPC_ADDRESS::EnumerateAndCallEachAssociation (
    IN AssociationCallbackType asctType,
    IN OUT void *Context OPTIONAL
    )
/*++
Function Name:  EnumerateAndCallEachAssociation

Parameters:
    asctType - type of callback to make
    Context - opaque memory block specific for the callback
        type.

Description:
    Common infrastructure for calling into each association

Returns:

--*/
{
    LRPC_SASSOCIATION *CurrentAssociation;
    BOOL CopyOfDictionaryUsed;
    LRPC_SASSOCIATION_DICT AssocDictCopy;
    LRPC_SASSOCIATION_DICT *AssocDictToUse;
    BOOL Res;
    DictionaryCursor cursor;
    DestroyContextHandleCallbackContext *CallbackContext;

    AddressMutex.Request();

    CopyOfDictionaryUsed = AssocDictCopy.ExpandToSize(AssociationDictionary.Size());
    if (CopyOfDictionaryUsed)
        {
        AssociationDictionary.Reset(cursor);
        while ( (CurrentAssociation = AssociationDictionary.Next(cursor)) != 0 )
            {
            Res = AssocDictCopy.Insert(CurrentAssociation);
            ASSERT(Res != -1);
            // artifically add a count to keep it alive
            // while we destroy the contexts
            CurrentAssociation->AssociationReferenceCount++;
            }

        AddressMutex.Clear();

        AssocDictToUse = &AssocDictCopy;
        }
    else
        {
        AssocDictToUse = &AssociationDictionary;
        }

    AssocDictToUse->Reset(cursor);
    while ( (CurrentAssociation = AssocDictToUse->Next(cursor)) != 0 )
        {
        switch (asctType)
            {
            case asctDestroyContextHandle:
                CallbackContext = (DestroyContextHandleCallbackContext *)Context;

                // call into the association to destroy the context handles
                CurrentAssociation->DestroyContextHandlesForInterface(
                    CallbackContext->RpcInterfaceInformation,
                    CallbackContext->RundownContextHandles);
                break;

            case asctCleanupIdleSContext:
                CurrentAssociation->CleanupIdleSContexts();
                break;

            default:
                ASSERT(0);
            }
        }

    if (CopyOfDictionaryUsed)
        {
        while ( (CurrentAssociation = AssocDictCopy.Next(cursor)) != 0 )
            {
            // remove the extra refcounts
            DereferenceAssociation(CurrentAssociation);
            }
        }
    else
        {
        AddressMutex.Clear();
        }    
}

void
LRPC_ADDRESS::DestroyContextHandlesForInterface (
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation,
    IN BOOL RundownContextHandles
    )
/*++
Function Name:  DestroyContextHandlesForInterface

Parameters:
    RpcInterfaceInformation - the interface for which context handles
        are to be unregistered
    RundownContextHandles - if non-zero, rundown the context handles. If
        FALSE, destroy the runtime portion of the context handle resource,
        but don't call the user rundown routine.

Description:
    The implementation for context handle destruction for the local RPC 
    (LRPC). Using the callback infrastructure it will walk the list of 
    associations, and for each one it will ask the association to 
    destroy the context handles for that interface.

Returns:

--*/
{
    DestroyContextHandleCallbackContext CallbackContext;

    CallbackContext.RpcInterfaceInformation = RpcInterfaceInformation;
    CallbackContext.RundownContextHandles = RundownContextHandles;

    EnumerateAndCallEachAssociation(asctDestroyContextHandle,
        &CallbackContext);
}

void
LRPC_ADDRESS::CleanupIdleSContexts (
    void
    )
/*++
Function Name:  CleanupIdleSContexts

Parameters:

Description:
    The implementation for idle SContext cleanup for the local RPC 
    (LRPC). Using the callback infrastructure it will walk the list of 
    associations, and for each one it will ask the association to 
    destroy the idle scontexts


Returns:

--*/
{
    LogEvent(SU_GC, EV_PRUNE, this, 0, 0, 0, 0);

    EnumerateAndCallEachAssociation(asctCleanupIdleSContext,
        NULL);
}

BOOL 
LRPC_ADDRESS::PrepareForLoopbackTickling (
    void
    )
{
    RPC_CHAR * LpcPortName;
    int DirectoryNameLength;
    int EndpointLength;

    LrpcMutexVerifyOwned();

    DirectoryNameLength = RpcpStringLength(LRPC_DIRECTORY_NAME);
    EndpointLength = RpcpStringLength(InqEndpoint());

    LpcPortName = new RPC_CHAR[
                    EndpointLength
                    + DirectoryNameLength + 1];
    if (LpcPortName == 0)
        {
        return FALSE;
        }

    TickleMessage = new LRPC_BIND_EXCHANGE;
    if (TickleMessage == NULL)
        {
        delete [] LpcPortName;
        return FALSE;
        }

    RpcpMemoryCopy(LpcPortName, LRPC_DIRECTORY_NAME,
            DirectoryNameLength * sizeof(RPC_CHAR));

    RpcpMemoryCopy(LpcPortName + DirectoryNameLength,
            InqEndpoint(), 
            (EndpointLength + 1) * sizeof(RPC_CHAR));

    RtlInitUnicodeString(&ThisAddressLoopbackString, LpcPortName);

    return TRUE;
}

BOOL
LRPC_ADDRESS::LoopbackTickle (
    void
    )
{
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    HANDLE LoopbackPort;
    ULONG TickleMessageLength = sizeof(LRPC_BIND_EXCHANGE);
    NTSTATUS NtStatus;

    ASSERT (IsPreparedForLoopbackTickling());

    SecurityQualityOfService.EffectiveOnly = FALSE;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.ImpersonationLevel = SecurityAnonymous;
    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);

    TickleMessage->ConnectType = LRPC_CONNECT_TICKLE ;
//    TickleMessage->AssocKey = Key;
    TickleMessage->Flags = 0;

    NtStatus = NtConnectPort(
                             &LoopbackPort,
                             &ThisAddressLoopbackString,
                             &SecurityQualityOfService,
                             NULL,
                             NULL,
                             NULL,
                             TickleMessage,
                             &TickleMessageLength);

    if (NtStatus == STATUS_PORT_CONNECTION_REFUSED)
        return TRUE;
    else
        {
        ASSERT(NtStatus != RPC_S_OK);
        return FALSE;
        }
}


LRPC_SASSOCIATION::LRPC_SASSOCIATION (
    IN LRPC_ADDRESS * Address,
    IN RPC_STATUS *Status
    ) : AssociationMutex(Status),
    BindingsCollectionLock (0)
/*++

--*/
{
    ObjectType = LRPC_SASSOCIATION_TYPE;
    LpcServerPort = 0;
    LpcReplyPort = 0 ;
    this->Address = Address;
    AssociationReferenceCount = 1;
    Aborted = 0 ;
    Deleted = -1;

    if (*Status == RPC_S_OK)
        {
        // Create an SCALL object.
        // If the app verifier is enabled, we will create an object which 
        // supports the verifier checks.
        if (gfRPCVerifierEnabled)
            {
            CachedSCall = new LRPC_SCALL_AVRF(Status);
            }
        else
            {
            CachedSCall = new LRPC_SCALL(Status);
            }

        if (CachedSCall == 0)
            {
            *Status = RPC_S_OUT_OF_MEMORY;
            }
        }
    else
        {
        CachedSCall = NULL;
        }

    CachedSCallAvailable = 0;
    fFirstCall = 0;
}


LRPC_SASSOCIATION::~LRPC_SASSOCIATION (
    )
/*++

Routine Description:

    We will call this routine when the client has notified us that this port
    has closed, and there are no calls outstanding on it.

--*/
{
    PVOID Buffer;
    LRPC_SBINDING * Binding;
    LRPC_SCALL *SCall ;
    unsigned int Length ;
    LRPC_SCONTEXT *SContext;
    DictionaryCursor cursor;

    while (SCall = (LRPC_SCALL *) FreeSCallQueue.TakeOffQueue(&Length))
        {
        delete SCall;
        }


    Bindings.Reset(cursor);
    while ((Binding = Bindings.Next(cursor)) != 0)
        {
        delete Binding;
        }

    if (CachedSCall)
        {
        delete CachedSCall;
        }

    SContextDict.Reset(cursor);
    while ((SContext = SContextDict.Next(cursor)) != 0)
        {
        delete SContext;
        }
}

RPC_STATUS
LRPC_SASSOCIATION::AllocateSCall (
    IN LRPC_MESSAGE * LrpcMessage,
    IN LRPC_MESSAGE * LrpcReplyMessage,
    IN unsigned int Flags,
    IN LRPC_SCALL **SCall
    )
/*++

Routine Description:

    Allocate an SCall

Arguments:

    LrpcMessage - Request message
    LrpcReplyMessage - Reply message
    Flags - Request flags

Return Value:
    Pointer to the SCall

--*/

{
    unsigned int Length ;
    RPC_STATUS Status ;
    LRPC_SCALL *NewSCall;

    *SCall = NULL;

    if (InterlockedIncrement(&CachedSCallAvailable) == 1)
        {
        NewSCall = CachedSCall;
        }
    else
        {
        AssociationMutex.Request() ;
        NewSCall = (LRPC_SCALL *) FreeSCallQueue.TakeOffQueue(&Length) ;
        AssociationMutex.Clear() ;

        if (NewSCall == 0)
            {
            // Create an SCALL object.
            // If the app verifier is enabled, we will create an object which 
            // supports the verifier checks.
            if (gfRPCVerifierEnabled)
                {
                NewSCall = new LRPC_SCALL_AVRF(&Status) ;
                }
            else
                {
                NewSCall = new LRPC_SCALL(&Status) ;
                }

            if (NewSCall == 0)
                {
                return RPC_S_OUT_OF_MEMORY;
                }
            if (Status != RPC_S_OK)
                {
                delete NewSCall;
                return Status;
                }
            }
        }

    Status = NewSCall->ActivateCall(this,
                           LrpcMessage,
                           LrpcReplyMessage,
                           Flags) ;
    

    if ((Flags & LRPC_BUFFER_PARTIAL)
        || NewSCall->IsClientAsync())
        {
        Status = NewSCall->SetupCall() ;
        if (Status != RPC_S_OK)
            {
            if (NewSCall != CachedSCall)
                {
                delete NewSCall ;
                }

            return RPC_S_OUT_OF_MEMORY ;
            }
        }

    LogEvent(SU_SCALL, EV_CREATE, NewSCall, 0, Flags, 1);
    
    *SCall = NewSCall;
    
    return RPC_S_OK;
}

void
LRPC_SASSOCIATION::FreeSCall (
    IN LRPC_SCALL *SCall
    )
/*++

Routine Description:

 Free the SCall

Arguments:

 SCall - Pointer to the SCall object

--*/

{
    ASSERT(SCall->pAsync != (PRPC_ASYNC_STATE) -1);

    if (SCall->pAsync)
        {
        SCall->DoPostDispatchProcessing();

        if (SCall->SBinding)
            {
            RPC_INTERFACE *CallInterface = SCall->SBinding->RpcInterface;

            CallInterface->EndCall(0, 1);
            if (CallInterface->IsAutoListenInterface())
                {
                // This is the path where async calls complete.
                // We need to decrement CallNumber.
                CallInterface->EndAutoListenCall(TRUE);
                }
            }
        }

    if (SCall->ReceiveEvent)
        {
        AssociationMutex.Request() ;
        SCallDict.Delete(ULongToPtr(SCall->CallId));
        AssociationMutex.Clear() ;
        }

    LogEvent(SU_SCALL, EV_DELETE, SCall, SCall->pAsync, SCall->Flags, 1);

    SCall->pAsync = (PRPC_ASYNC_STATE) -1;
    if (SCall->SContext)
        {
        SCall->SContext->RemoveReference();
        }

    if (SCall->ClientPrincipalName != NULL)
        {
        delete SCall->ClientPrincipalName;
        SCall->ClientPrincipalName = NULL;
        }

    SCall->DeactivateCall();
    if (SCall == CachedSCall)
        {
        CachedSCallAvailable = 0;
        }
    else
        {
        AssociationMutex.Request() ;
        SCall->pAsync = (PRPC_ASYNC_STATE) -1;
        if (FreeSCallQueue.PutOnQueue(SCall, 0))
            delete SCall ;
        AssociationMutex.Clear() ;
        }

}

int
LRPC_SASSOCIATION::MaybeQueueSCall (
    IN LRPC_SCALL *SCall
    )
/*++

Routine Description:

 if the thread is currently executing a call, the call
 is queued up, otherwise it is signalled to be dispatched.

Arguments:

  SCall - the SCall to be dispatched.

Return Value:

 0: dispatch the call
 1: don't dispatch the call
-1: error
--*/

{
    LRPC_SCALL *FirstSCall ;
    int Status ;

    AssociationMutex.Request() ;

    FirstSCall = ClientThreadDict.Find(
        MsgClientIdToClientId(SCall->LrpcRequestMessage->Rpc.LpcHeader.ClientId).UniqueThread) ;

    if (FirstSCall == 0)
        {
        Status = ClientThreadDict.Insert(
            MsgClientIdToClientId(SCall->LrpcRequestMessage->Rpc.LpcHeader.ClientId).UniqueThread,
            SCall) ;

        SCall->LastSCall = SCall ;

        AssociationMutex.Clear() ;

        VALIDATE(Status)
            {
            0,
            -1
            } END_VALIDATE;

        return Status ;
        }


    ASSERT(FirstSCall->LastSCall);

    FirstSCall->LastSCall->NextSCall = SCall ;
    FirstSCall->LastSCall = SCall ;

    AssociationMutex.Clear() ;

    return 1 ;
}

LRPC_SCALL *
LRPC_SASSOCIATION::GetNextSCall (
    IN LRPC_SCALL *SCall
    )
/*++

Routine Description:

 description

Arguments:

 SCall - description

Return Value:
--*/

{
    LRPC_SCALL *NextSCall ;

    ASSERT(SCall) ;

    AssociationMutex.Request() ;
    NextSCall = SCall->NextSCall ;
    if (NextSCall != 0)
        {
        ASSERT(SCall->LastSCall);

        NextSCall->LastSCall = SCall->LastSCall ;
        ClientThreadDict.Update (
            MsgClientIdToClientId(SCall->LrpcRequestMessage->Rpc.LpcHeader.ClientId).UniqueThread,
            NextSCall) ;
        }
    else
        {
        ClientThreadDict.Delete (
            MsgClientIdToClientId(SCall->LrpcRequestMessage->Rpc.LpcHeader.ClientId).UniqueThread) ;
        }
    AssociationMutex.Clear() ;

    return NextSCall ;
}

void
LRPC_SASSOCIATION::Delete(
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/

{
    LRPC_SCALL *SCall ;
    DictionaryCursor cursor;

    if (InterlockedIncrement(&Deleted) == 0)
        {
        AssociationMutex.Request() ;
        SCallDict.Reset(cursor) ;
        while ((SCall = SCallDict.Next(cursor)) != 0)
            {
            SCall->Deleted = 1;
            if (SCall->ReceiveEvent)
                {
                SCall->ReceiveEvent->Raise();
                }
            }
        AssociationMutex.Clear() ;

        LogEvent(SU_SASSOC, EV_DELETE,
                 this, 0, AssociationReferenceCount, 1, 1);

        Address->DereferenceAssociation(this);
        }
}


RPC_STATUS
LRPC_SASSOCIATION::BindBack (
    IN RPC_CHAR *Endpoint,
    IN DWORD AssocKey,
    IN BYTE *Cookie
    )
/*++

Routine Description:

    Create a back connection to the client.

Arguments:

 LrpcThread - LrpcThread to connect to.
 pAssoc - Pointer to client association.

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/

{
    NTSTATUS NtStatus;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    RPC_CHAR * LpcPortName ;
    UNICODE_STRING unicodePortName;
    LRPC_BIND_EXCHANGE BindExchange;
    unsigned long BindExchangeLength = sizeof(LRPC_BIND_EXCHANGE);

    LpcPortName = new RPC_CHAR[RpcpStringLength(Endpoint)
                            + RpcpStringLength(LRPC_DIRECTORY_NAME) + 1];

    if (LpcPortName == 0)
        {
#if DBG
        PrintToDebugger("LRPC: Out of memory in DealWithNewClient\n") ;
#endif
        return RPC_S_OUT_OF_MEMORY ;
        }

    RpcpMemoryCopy(LpcPortName,
            LRPC_DIRECTORY_NAME,
            RpcpStringLength(LRPC_DIRECTORY_NAME) * sizeof(RPC_CHAR));

    RpcpMemoryCopy(LpcPortName + RpcpStringLength(LRPC_DIRECTORY_NAME),
            Endpoint,
            (RpcpStringLength(Endpoint) + 1) * sizeof(RPC_CHAR));

    RtlInitUnicodeString(&unicodePortName, LpcPortName);

    // QOS values used for the bind-back.
    SecurityQualityOfService.EffectiveOnly = TRUE;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_STATIC_TRACKING;

    // This prevents the client from impersonating us.
    SecurityQualityOfService.ImpersonationLevel = SecurityAnonymous;

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);

    BindExchange.ConnectType = LRPC_CONNECT_RESPONSE ;
    BindExchange.AssocKey = AssocKey ;
    RpcpMemoryCopy(BindExchange.Cookie, Cookie, sizeof(BindExchange.Cookie));

    NtStatus = NtConnectPort(&LpcReplyPort,
                             &unicodePortName,
                             &SecurityQualityOfService,
                             0,
                             0,
                             0,
                             &BindExchange,
                             &BindExchangeLength);

    delete [] LpcPortName ;

    if (!NT_SUCCESS(NtStatus))
        {
#if DBG
        PrintToDebugger("LRPC: NtConnectPort : %lx\n", NtStatus);
#endif // DBG

        return RPC_S_OUT_OF_MEMORY ;
        }

    return RPC_S_OK ;
}


LRPC_MESSAGE *
LRPC_SASSOCIATION::DealWithBindBackMessage (
    IN LRPC_MESSAGE *BindBackMessage
    )
/*++

Routine Description:

 Used in conjuction with  Async RPC. This function
 creates a back connection to the client so that two asynchronous
 flow of data can occur.

Arguments:

 BindBackMessage - The message receive from the client

Return Value:
    reply message.

--*/

{
    RPC_STATUS Status ;

    BindBackMessage->BindBack.szPortName[PORT_NAME_LEN-1] = NULL;

    Status = BindBack((RPC_CHAR *) BindBackMessage->BindBack.szPortName,
                      BindBackMessage->BindBack.AssocKey,
                      BindBackMessage->BindBack.Cookie);

    BindBackMessage->Ack.MessageType = LRPC_MSG_ACK ;
    BindBackMessage->Ack.RpcStatus = Status ;
    BindBackMessage->LpcHeader.u1.s1.DataLength =
        sizeof(LRPC_BIND_MESSAGE) - sizeof(PORT_MESSAGE);
    BindBackMessage->LpcHeader.u1.s1.TotalLength =
        sizeof(LRPC_BIND_MESSAGE);

    if (Status != RPC_S_OK)
        {
        Delete() ;
        }

    return BindBackMessage ;
}


RPC_STATUS
LRPC_SASSOCIATION::AddBinding (
    IN OUT LRPC_BIND_EXCHANGE * BindExchange
    )
/*++

Routine Description:

    We will attempt to add a new binding to this association.

Arguments:

    BindExchange - Supplies a description of the interface to which the
        client wish to bind.

Return Value:

--*/
{
    RPC_STATUS Status;
    RPC_SYNTAX_IDENTIFIER TransferSyntax;
    RPC_INTERFACE * RpcInterface;
    LRPC_SBINDING * Binding;
    BOOL fIgnored;
    int DictKey;
    RPC_SYNTAX_IDENTIFIER ProposedSyntaxes[MaximumNumberOfTransferSyntaxes];
    int PresentationContexts[MaximumNumberOfTransferSyntaxes];
    int TransferSyntaxFlagSettings[MaximumNumberOfTransferSyntaxes];
    int NextProposedSyntax;
    int ChosenProposedTransferSyntax;
    int ChosenAvailableTransferSyntax;
    long OldLockValue;

    NextProposedSyntax = 0;
    if (BindExchange->TransferSyntaxSet & TS_NDR20_FLAG)
        {
        RpcpMemoryCopy(&ProposedSyntaxes[NextProposedSyntax],
            NDR20TransferSyntax, sizeof(RPC_SYNTAX_IDENTIFIER));
        PresentationContexts[NextProposedSyntax] = (int)BindExchange->PresentationContext[0];
        TransferSyntaxFlagSettings[NextProposedSyntax] = TS_NDR20_FLAG;
        NextProposedSyntax ++;
        }

    if (BindExchange->TransferSyntaxSet & TS_NDR64_FLAG)
        {
        RpcpMemoryCopy(&ProposedSyntaxes[NextProposedSyntax],
            NDR64TransferSyntax, sizeof(RPC_SYNTAX_IDENTIFIER));
        PresentationContexts[NextProposedSyntax] = (int)BindExchange->PresentationContext[1];
        TransferSyntaxFlagSettings[NextProposedSyntax] = TS_NDR64_FLAG;
        NextProposedSyntax ++;
        }

    if (BindExchange->TransferSyntaxSet & TS_NDRTEST_FLAG)
        {
        RpcpMemoryCopy(&ProposedSyntaxes[NextProposedSyntax],
            NDRTestTransferSyntax, sizeof(RPC_SYNTAX_IDENTIFIER));
        PresentationContexts[NextProposedSyntax] = (int)BindExchange->PresentationContext[2];
        TransferSyntaxFlagSettings[NextProposedSyntax] = TS_NDRTEST_FLAG;
        NextProposedSyntax ++;
        }

    if (NextProposedSyntax == 0)
        {
        // no syntaxes proposed - protocol error
        CORRUPTION_ASSERT(0);
        return RPC_S_PROTOCOL_ERROR;
        }

    CORRUPTION_ASSERT(NextProposedSyntax <= MaximumNumberOfTransferSyntaxes);

    Status = Address->FindInterfaceTransfer(&(BindExchange->InterfaceId),
                                            ProposedSyntaxes,
                                            NextProposedSyntax,
                                            &TransferSyntax,
                                            &RpcInterface,
                                            &fIgnored,
                                            &ChosenProposedTransferSyntax,
                                            &ChosenAvailableTransferSyntax);
    if (Status != RPC_S_OK)
        {
        return(Status);
        }

    ASSERT (ChosenProposedTransferSyntax < NextProposedSyntax);

    Binding = new LRPC_SBINDING(RpcInterface,
                                ChosenAvailableTransferSyntax);
    if (Binding == 0)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }
    Binding->SetPresentationContext(PresentationContexts[ChosenProposedTransferSyntax]);

    // busy wait until the readers and other writers in the bindings collection go away
    while (BindingsCollectionLock.CompareExchange(-1, 0) != 0)
        {
        Sleep (2);
        }

    DictKey = (unsigned char) Bindings.Insert(Binding);

    // release the lock
    BindingsCollectionLock.Exchange (0);

    if (DictKey == -1)
        {
        delete Binding;
        return(RPC_S_OUT_OF_MEMORY);
        }

    BindExchange->TransferSyntaxSet = TransferSyntaxFlagSettings[ChosenProposedTransferSyntax];
    return(RPC_S_OK);
}


RPC_STATUS
LRPC_SASSOCIATION::SaveToken (
    IN LRPC_MESSAGE *LrpcMessage,
    OUT HANDLE *pTokenHandle,
    IN BOOL fRestoreToken
    )
/*++

Routine Description:

    Impersonate the client and save away the token.

Arguments:

 LrpcMessage - request message

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/

{
    NTSTATUS NtStatus ;
    HANDLE ImpersonationToken = 0;
    RPC_STATUS Status;

    if (fRestoreToken)
        {
        //
        // Save away the old token
        //
        if (OpenThreadToken (GetCurrentThread(),
                         TOKEN_IMPERSONATE | TOKEN_QUERY,
                         TRUE,
                         &ImpersonationToken) == FALSE)
            {
            ImpersonationToken = 0;
#if DBG
            if (GetLastError() != ERROR_NO_TOKEN)
                {
                PrintToDebugger("LRPC: First OpenThreadToken failed %d\n", GetLastError());
                }
#endif
            }
        }

    NtStatus = NtImpersonateClientOfPort(LpcServerPort,
                                        (PORT_MESSAGE *) LrpcMessage);

    if (NT_ERROR(NtStatus))
        {
#if DBG
        PrintToDebugger("LRPC: NtImpersonateClientOfPort failed: 0x%lX\n",
                        NtStatus) ;
#endif

        if (ImpersonationToken)
            {
            CloseHandle(ImpersonationToken);
            }

        return RPC_S_INVALID_AUTH_IDENTITY ;
        }

    Status = RPC_S_OK;

    if (OpenThreadToken (GetCurrentThread(),
                         TOKEN_IMPERSONATE | TOKEN_QUERY,
                         TRUE,
                         pTokenHandle) == FALSE)
        {
        *pTokenHandle = 0;

        Status = GetLastError();

        if (Status != ERROR_CANT_OPEN_ANONYMOUS)
            {
#if DBG
            PrintToDebugger("LRPC: Second OpenThreadToken failed : %lx\n", Status) ;
#endif
            switch(Status)
                {
                case ERROR_NO_TOKEN:
                    Status = RPC_S_ACCESS_DENIED;
                    break;

                case ERROR_NOT_ENOUGH_MEMORY:
                case ERROR_NOT_ENOUGH_QUOTA:
                case ERROR_NO_SYSTEM_RESOURCES:
                    Status = RPC_S_OUT_OF_MEMORY;
                    break;

                default:
                    ASSERT(0);
                }
            }
        }

    if (fRestoreToken)
        {
        //
        // Restore the token
        //
        NtStatus = NtSetInformationThread(NtCurrentThread(),
                                          ThreadImpersonationToken,
                                          &ImpersonationToken,
                                          sizeof(HANDLE));

#if DBG
        if (!NT_SUCCESS(NtStatus))
            {
            PrintToDebugger("RPC : NtSetInformationThread : %lx\n", NtStatus);
            }
#endif // DBG

        if (ImpersonationToken)
            {
            CloseHandle(ImpersonationToken);
            }

        }

    return Status;
}


RPC_STATUS
LRPC_SASSOCIATION::GetClientName (
    IN LRPC_SCALL *SCall,
    IN OUT ULONG *ClientPrincipalNameBufferLength OPTIONAL,   // in bytes
    OUT RPC_CHAR **ClientPrincipalName
    )
/*++

Routine Description:

    Gets the client name for the given scall

Arguments:

    SCall - the SCall for which to get the client name
    ClientPrincipalNameBufferLength - if present, *ClientPrincipalName must
        point to a caller supplied buffer, which if big enough,
        will be filled with the client principal name. If not present,
        *ClientPrincipalName must be NULL.
    ClientPrincipalName - see ClientPrincipalNameBufferLength

Return Value:

    RPC_S_OK for success, or RPC_S_* / Win32 error code for error.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    BOOL Result;
    unsigned long Size;
    HANDLE TokenHandle = 0;
    LRPC_SCONTEXT *SContext = 0;
    TOKEN_STATISTICS TokenStatisticsInformation;
    DictionaryCursor cursor;
    BOOL fAnonymous;
    BOOL fMutexHeld = FALSE;
    BOOL fAssociationSContextUsed = FALSE;
    RPC_CHAR *CurrentUserName;
    ULONG CurrentUserNameLength;

    if (SCall->SContext == NULL)
        {
        // take the lock opportunistically
        AssociationMutex.Request();

        fMutexHeld = TRUE;

        if (SCall->SContext == NULL)
            {
            Status = SaveToken(
                               SCall->LrpcRequestMessage,
                               &TokenHandle, 1);
            if ((Status != RPC_S_OK) && (Status != ERROR_CANT_OPEN_ANONYMOUS))
                {
                goto Cleanup;
                }

            if (Status == RPC_S_OK)
                {
                Result = GetTokenInformation(
                                             TokenHandle,
                                             TokenStatistics,
                                             &TokenStatisticsInformation,
                                             sizeof(TokenStatisticsInformation),
                                             &Size
                                             );
                if (Result != TRUE)
                    {
                    Status = RPC_S_INVALID_AUTH_IDENTITY;
                    goto Cleanup;
                    }

                fAnonymous = FALSE;
                }
            else
                {
                ASSERT(Status == ERROR_CANT_OPEN_ANONYMOUS);
                fAnonymous = TRUE;
                TokenHandle = 0;
                }

            SContextDict.Reset(cursor);
            while ((SContext = SContextDict.Next(cursor)) != 0)
                {
                // if either input and found are anonymous, or the modified
                // ids match, we have found it
                if ((fAnonymous && SContext->GetAnonymousFlag())
                    ||
                    FastCompareLUIDAligned(&SContext->ClientLuid,
                        &TokenStatisticsInformation.ModifiedId))
                    {
                    break;
                    }
                }

            if (SContext == 0)
                {
                SContext = new LRPC_SCONTEXT(NULL,
                            fAnonymous ? NULL : ((LUID *) &TokenStatisticsInformation.ModifiedId),
                            this,
                            FALSE,   // fDefaultLogonId
                            fAnonymous
                            );
                if (SContext == 0)
                    {
                    Status = RPC_S_OUT_OF_MEMORY;
                    goto Cleanup;
                    }

                if (SContextDict.Insert(SContext) == -1)
                    {
                    delete SContext;
                    Status = RPC_S_OUT_OF_MEMORY;
                    goto Cleanup;
                    }

                // mark the context as server side only
                SContext->SetServerSideOnlyFlag();

                // record that we have used this recently to prevent it from being
                // garbage collected
                SContext->UpdateLastAccessTime();

                EnableIdleLrpcSContextsCleanup();

                // tell the garbage collector that we have something to be
                // collected
                GarbageCollectionNeeded(FALSE,  // fOneTimeCleanup
                    LRPC_SCONTEXT::CONTEXT_IDLE_TIMEOUT);
                }
            else
                {
                // record that we have used this recently to prevent it from being
                // garbage collected
                SContext->UpdateLastAccessTime();
                }

            // we have taken or created the current SContext in the association
            // we need to prevent the garbage collection thread from destroying
            // it underneath us. We add one refcount for the purpose and record
            // this
            SContext->AddReference();

            fAssociationSContextUsed = TRUE;
            }
        else
            {
            SContext = SCall->SContext;

            // record that we have used this recently to prevent it from being
            // garbage collected
            SContext->UpdateLastAccessTime();
            }
        AssociationMutex.Clear() ;
        fMutexHeld = FALSE;
        }
    else
        {
        SContext = SCall->SContext;

        // record that we have used this recently to prevent it from being
        // garbage collected
        SContext->UpdateLastAccessTime();
        }

    ASSERT(SContext);

    // if we go through the path where the token is retrieved from
    // the SContext, passing NULL TokenHandle to get user name is Ok
    // as it will retrieve the token from the SContext
    Status = SContext->GetUserName(ClientPrincipalNameBufferLength, ClientPrincipalName, TokenHandle);

    // If ARGUMENT_PRESENT(ClientPrincipalNameBufferLength), Status may be
    // ERROR_MORE_DATA, which is a success error code.

    if (fAssociationSContextUsed)
        {
        if ((Status == RPC_S_OK) 
            && (!ARGUMENT_PRESENT(ClientPrincipalNameBufferLength)))
            {
            // we weren't supplied a user buffer. Copy the principal
            // name to a call variable to avoid the garbage collector
            // collecting this under the feet of our caller. Then
            // we can release the refcount
            if (SCall->ClientPrincipalName == NULL)
                {
                CurrentUserNameLength = (RpcpStringLength(*ClientPrincipalName) + 1) * sizeof(RPC_CHAR);
                // CurrentUserNameLength is in bytes. Allocate chars for it and cast it back
                CurrentUserName = (RPC_CHAR *) new char [CurrentUserNameLength];
                if (CurrentUserName != NULL)
                    {
                    RpcpMemoryCopy(CurrentUserName,
                        *ClientPrincipalName,
                        CurrentUserNameLength);
                    SCall->ClientPrincipalName = CurrentUserName;
                    *ClientPrincipalName = CurrentUserName;
                    }
                else
                    {
                    Status = RPC_S_OUT_OF_MEMORY;
                    // fall through in cleanup path
                    }
                }
            else
                {
                *ClientPrincipalName = SCall->ClientPrincipalName;
                }
            }

        // succeeded or not, drop the refcount
        SContext->RemoveReference();
        }

    if (Status != RPC_S_OK)
        {
        // N.B. failure of this function doesn't mean we have
        // to delete a newly created scontext. scontexts without
        // names are perfectly valid, and since we know the only
        // missing part from this scontext is the name, we can
        // leave it alone, return failure, and attempt to get the 
        // name next time
        goto Cleanup;
        }

Cleanup:

    if (fMutexHeld)
        {
        AssociationMutex.Clear() ;
        }

    if (TokenHandle)
        {
        CloseHandle(TokenHandle);
        }

    return Status;
}

#if defined(_WIN64)
C_ASSERT((FIELD_OFFSET(TOKEN_STATISTICS, ModifiedId) % 8) == 0);
C_ASSERT((FIELD_OFFSET(LRPC_SCONTEXT, ClientLuid) % 8) == 0);
#endif


void
LRPC_SASSOCIATION::DealWithBindMessage (
    IN LRPC_MESSAGE * LrpcMessage
    )
/*++

Routine Description:

    LRPC_ADDRESS::ReceiveLotsaCalls will call this routine when the client
    sends a bind message.  We need to process the bind message, and send
    a response to the client.

Arguments:

    LrpcMessage - Supplies the bind message.  We will also use this to send
        the response.

Return Value:

    The reply message to be sent to the client will be returned.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    NTSTATUS NtStatus ;
    HANDLE ImpersonationToken = 0;
    HANDLE TokenHandle;
    unsigned long Size;
    BOOL Result;
    LRPC_SCONTEXT *SContext;
    ULONG SecurityContextId = -1;
    DictionaryCursor cursor;
    BOOL fBindDefaultLogonId;
    BOOL fAnonymous;
    ULONG TotalMessageLength;

    TotalMessageLength = LrpcMessage->Bind.LpcHeader.u1.s1.TotalLength;
    if (TotalMessageLength < sizeof(LRPC_BIND_MESSAGE))
        {
        RpcpMemorySet((char *)LrpcMessage + TotalMessageLength,
            0,
            sizeof(LRPC_BIND_MESSAGE) - TotalMessageLength
            );
        }

    if (LrpcMessage->Bind.BindExchange.Flags & NEW_SECURITY_CONTEXT_FLAG)
        {
        TOKEN_STATISTICS TokenStatisticsInformation;

        //
        // If SaveToken succeeds, as a side-effect, it will
        // fill in the SecurityContextId field of the BindExchange
        //
        Status = SaveToken(
                           LrpcMessage,
                           &TokenHandle) ;

        if ((Status != RPC_S_OK) && (Status != ERROR_CANT_OPEN_ANONYMOUS))
            {
            RpcpErrorAddRecord(EEInfoGCRuntime, 
                Status, 
                EEInfoDLDealWithBindMessage10);
            goto Cleanup;
            }
        else if (TokenHandle || (Status == ERROR_CANT_OPEN_ANONYMOUS))
            {
            if (TokenHandle)
                {
                Result = GetTokenInformation(
                                         TokenHandle,
                                         TokenStatistics,
                                         &TokenStatisticsInformation,
                                         sizeof(TokenStatisticsInformation),
                                         &Size
                                         );
                if (Result != TRUE)
                    {
                    RpcpErrorAddRecord(EEInfoGCRuntime,
                        RPC_S_INVALID_AUTH_IDENTITY, 
                        EEInfoDLDealWithBindMessage20,
                        GetLastError());
                    CloseHandle(TokenHandle);
                    Status = RPC_S_INVALID_AUTH_IDENTITY;
                    goto Cleanup;
                    }

                fAnonymous = FALSE;
                }
            else
                {
                fAnonymous = TRUE;
                Status = RPC_S_OK;
                }

            AssociationMutex.Request();

            unsigned int Key = 0;
            fBindDefaultLogonId = 
                (LrpcMessage->Bind.BindExchange.Flags & DEFAULT_LOGONID_FLAG) 
                ? TRUE : FALSE;
            SContextDict.Reset(cursor);
            while ((SContext = SContextDict.NextWithKey(cursor, &Key)) != 0)
                {
                if ((fAnonymous && SContext->GetAnonymousFlag())
                    ||
                    (FastCompareLUIDAligned(&SContext->ClientLuid,
                      &TokenStatisticsInformation.ModifiedId)
                        &&
                    (SContext->GetDefaultLogonIdFlag() == fBindDefaultLogonId)))
                    {
                    SecurityContextId = Key;
                    SContext->ClearServerSideOnlyFlag();
                    break;
                    }
                }

            if (SContext == 0)
                {
                if (fAnonymous)
                    {
                    SContext = new LRPC_SCONTEXT(TokenHandle,
                             (LUID *) NULL,
                             this,
                             0,
                             fAnonymous);
                    }
                else
                    {
                    SContext = new LRPC_SCONTEXT(TokenHandle,
                             (LUID *) &TokenStatisticsInformation.ModifiedId,
                             this,
                             fBindDefaultLogonId,
                             0      // fAnonymousToken
                             );
                    }

                if (SContext == 0)
                    {
                    RpcpErrorAddRecord(EEInfoGCRuntime,
                        RPC_S_OUT_OF_MEMORY, 
                        EEInfoDLDealWithBindMessage30,
                        sizeof(LRPC_SCONTEXT));
                    CloseHandle(TokenHandle);
                    Status = RPC_S_OUT_OF_MEMORY;
                    AssociationMutex.Clear();

                    goto Cleanup;
                    }

                if ((SecurityContextId = SContextDict.Insert(SContext)) == -1)
                    {
                    RpcpErrorAddRecord(EEInfoGCRuntime,
                        RPC_S_OUT_OF_MEMORY, 
                        EEInfoDLDealWithBindMessage40);
                    delete SContext;
                    Status = RPC_S_OUT_OF_MEMORY;
                    AssociationMutex.Clear();

                    goto Cleanup;
                    }

                }
            else if (SContext->hToken == NULL)
                {
                // if the context had no token, add one. This can happen
                // if previous callers for this modified id just queried
                // the user name. In this case, we won't cache the token
                SContext->hToken = TokenHandle;
                }
            else
                {
                CloseHandle(TokenHandle);
                }

            AssociationMutex.Clear();
            }
        else
            {
            ASSERT(0);
            }

Cleanup:

        //
        // Revert
        //
        NtStatus = NtSetInformationThread(NtCurrentThread(),
                                          ThreadImpersonationToken,
                                          &ImpersonationToken,
                                          sizeof(HANDLE));

#if DBG
        if (!NT_SUCCESS(NtStatus))
            {
            PrintToDebugger("RPC : NtSetInformationThread : %lx\n", NtStatus);
            }
#endif // DBG
        }

    if (Status == RPC_S_OK
        && LrpcMessage->Bind.BindExchange.Flags & NEW_PRESENTATION_CONTEXT_FLAG)
        {
        Status = AddBinding(&(LrpcMessage->Bind.BindExchange));
        if (Status != RPC_S_OK)
            {
            RpcpErrorAddRecord(EEInfoGCRuntime,
                Status, 
                EEInfoDLDealWithBindMessage50);
            }
        }

    LrpcMessage->Bind.BindExchange.RpcStatus = Status ;

    if (LrpcMessage->Bind.OldSecurityContexts.NumContexts > 0)
        {
        DWORD i;
        LRPC_SCONTEXT *SContext;
        DWORD NumContexts = LrpcMessage->Bind.OldSecurityContexts.NumContexts;
        DWORD CalculatedSize = ((NumContexts-1) * sizeof(DWORD))+sizeof(LRPC_BIND_MESSAGE);

        if (NumContexts > MAX_LRPC_CONTEXTS
            || CalculatedSize > (DWORD) LrpcMessage->LpcHeader.u1.s1.TotalLength)
            {
            //
            // Bogus request
            //
            LrpcMessage->Bind.BindExchange.RpcStatus = RPC_S_PROTOCOL_ERROR;
            RpcpErrorAddRecord(EEInfoGCRuntime,
                RPC_S_PROTOCOL_ERROR, 
                EEInfoDLDealWithBindMessage60,
                NumContexts,
                CalculatedSize,
                (DWORD) LrpcMessage->LpcHeader.u1.s1.TotalLength);
            goto Reply;
            }
        
        AssociationMutex.Request();
        for (i = 0; i < NumContexts; i++)
            {
            SContext = SContextDict.Delete(
                LrpcMessage->Bind.OldSecurityContexts.SecurityContextId[i]);
            if (SContext)
                {
                SContext->Destroy();
                }
            else
                {
                CORRUPTION_ASSERT(0);
                }
            }
        AssociationMutex.Clear();
        }

Reply:
    // if failure, check out of EEInfo
    if ((LrpcMessage->Bind.BindExchange.RpcStatus != RPC_S_OK) && (g_fSendEEInfo))
        {
        SetBindAckFault(LrpcMessage, 
            LrpcMessage->Bind.BindExchange.RpcStatus);
        }

    LrpcMessage->Bind.MessageType = LRPC_BIND_ACK;

    //
    // We will never send back a bind-ack with success for a new security context
    // binding exhange.
    //
    // If we could not insert the SContext into SContextDict, SecurityContextId is -1.
    // This is fine since we will be sending back a bind-ack with failure.
    //
    ASSERT(!(LrpcMessage->Bind.BindExchange.Flags & NEW_SECURITY_CONTEXT_FLAG) ||
           SecurityContextId != -1 ||
           LrpcMessage->Bind.BindExchange.RpcStatus != RPC_S_OK);
    LrpcMessage->Bind.BindExchange.SecurityContextId = SecurityContextId;
    if (!(LrpcMessage->Bind.BindExchange.Flags & EXTENDED_ERROR_INFO_PRESENT))
        {
        LrpcMessage->LpcHeader.u1.s1.DataLength = sizeof(LRPC_BIND_MESSAGE)
                - sizeof(PORT_MESSAGE);
        }

    ReplyMessage(LrpcMessage);
}

RPC_STATUS LRPC_SASSOCIATION::CreateThread(void)
{
    RPC_STATUS status;
    status = Address->BeginLongCall();
    if (status != RPC_S_OK)
        {
        Address->EndLongCall();
        }
    return status;
}

void LRPC_SASSOCIATION::RundownNotificationCompleted(void)
{
    Address->EndLongCall();
}

RPC_STATUS
LRPC_SBINDING::CheckSecurity (
    SCALL * Context
    )
{
    LRPC_SCONTEXT *SContext;

    // This is verified by the caller.
    ASSERT(RpcInterface->IsSecurityCallbackReqd());

    ASSERT(Context->InvalidHandle(LRPC_SCALL_TYPE) == 0); 
    SContext = ((LRPC_SCALL *)Context)->SContext;

    // Because we use FastCopyLUIDAligned to copy into LRPC_SBINDING::ClientLuid
    // it has to be aligned.  It is enough to be aligned in the structure.
    C_ASSERT(FIELD_OFFSET(LRPC_SBINDING, ClientLuid) % RPCRT_DEFAULT_STRUCT_ALIGNMENT == 0);

    //
    // We may be able to skip a security callback.
    //
    // We skip the callback iff:
    // - the binding has executed a security callback for the interface and
    // the SequenceNumber and the SContext->ClientLuid have not changed since.
    //
    // Thus, the only way to skip a security callback for a given binding is to have
    // executed it previously.
    // We will always execute security callbacks if no RPC security is used.  This
    // is necessary so that the user code may have a chance to impersonate and
    // do their own checks since each call may be under a different identity.
    //
    // We will only compare initialized ClientLuid since it will be compared iff
    // SequenceNumber has been initialized and the SequenceNumber is initialized after
    // ClientLuid is.
    //
    if ( SContext
         && RpcInterface->SequenceNumber == SequenceNumber 
         && FastCompareLUID(&(SContext->ClientLuid), &ClientLuid) )
        {
        return (RPC_S_OK);
        }

    RPC_STATUS Status = RpcInterface->CheckSecurityIfNecessary(Context);

    NukeStaleEEInfoIfNecessary(Status);

    Context->RevertToSelf();

    if (Status == RPC_S_OK)
        {
        if (SContext)
            {
            FastCopyLUIDAligned(&ClientLuid, &(SContext->ClientLuid));
            SequenceNumber = RpcInterface->SequenceNumber;
            }
        return (RPC_S_OK);
        }
    else
        {
        SequenceNumber = 0;
        RpcpErrorAddRecord(EEInfoGCApplication, 
            RPC_S_ACCESS_DENIED, 
            EEInfoDLCheckSecurity10,
            Status);
        return (RPC_S_ACCESS_DENIED);
        }
}


void
LRPC_SCALL::DealWithRequestMessage (
    )
/*++

Routine Description:

    We will process the original request message in this routine, dispatch
    the remote procedure call to the stub, and then send the response
    message.

Arguments:

    RpcMessage - Contains the request buffer

Return Value:

    none

--*/
{
    RPC_STATUS Status, ExceptionCode;
    int Flags = LrpcRequestMessage->Rpc.RpcHeader.Flags ;
    LRPC_SBINDING *LrpcBinding ;
    THREAD *ThisThread;
    DebugThreadInfo *ThreadDebugCell;
    DebugCallInfo *CallDebugCell;
    ULONG TickCount;
    PRPC_DISPATCH_TABLE DispatchTableToUse;

    RuntimeInfo.Length = sizeof(RPC_RUNTIME_INFO) ;

    ClientId = MsgClientIdToClientId(LrpcRequestMessage->LpcHeader.ClientId);
    MessageId = LrpcRequestMessage->LpcHeader.MessageId;
    CallbackId = LrpcRequestMessage->LpcHeader.CallbackId;

    LrpcBinding = LookupBinding(
        LrpcRequestMessage->Rpc.RpcHeader.PresentContext);
    if (LrpcBinding == 0)
        {
        COPYMSG(LrpcReplyMessage, LrpcRequestMessage) ;
        FreeBuffer(&RpcMessage);
        RpcpErrorAddRecord(EEInfoGCRuntime, 
            RPC_S_UNKNOWN_IF, 
            EEInfoDLDealWithRequestMessage10,
            LrpcRequestMessage->Rpc.RpcHeader.PresentContext);
        SetFaultPacket(LrpcReplyMessage, RPC_S_UNKNOWN_IF, Flags, NULL);
        return;
        }

    SBinding = LrpcBinding;

    LrpcBinding->GetSelectedTransferSyntaxAndDispatchTable(&RpcMessage.TransferSyntax,
        &DispatchTableToUse);
    RpcMessage.ProcNum = LrpcRequestMessage->Rpc.RpcHeader.ProcedureNumber;
    RpcMessage.Handle = this;
    RpcMessage.ReservedForRuntime = &RuntimeInfo ;

    // NDR_DREP_ASCII | NDR_DREP_LITTLE_ENDIAN | NDR_DREP_IEEE

    RpcMessage.DataRepresentation = 0x00 | 0x10 | 0x0000;

    if ((LrpcRequestMessage->Rpc.RpcHeader.Flags & LRPC_OBJECT_UUID))
        {
        ObjectUuidFlag = 1;
        RpcpMemoryCopy(&ObjectUuid,
            &(LrpcRequestMessage->Rpc.RpcHeader.ObjectUuid), sizeof(UUID));
        }

    ThisThread = RpcpGetThreadPointer();

    ASSERT(ThisThread);

    RpcpSetThreadContextWithThread(ThisThread, this);

    ThreadDebugCell = ThisThread->DebugCell;

    //
    // Check IF Level Security
    //
    if (LrpcBinding->RpcInterface->IsSecurityCallbackReqd() != 0)
        {
        Status = LrpcBinding->CheckSecurity(this);
        if (Status != RPC_S_OK)
            {
            COPYMSG(LrpcReplyMessage, LrpcRequestMessage) ;

            FreeBuffer(&RpcMessage);

            // the error record (if any) was already added
            // by CheckSecurity
            SetFaultPacket(LrpcReplyMessage,
                           RPC_S_ACCESS_DENIED,
                           Flags,
                           NULL) ;

            RpcpSetThreadContextWithThread(ThisThread, 0) ;
            return;
            }
        }

    if (ThreadDebugCell)
        {
        TickCount = NtGetTickCount();

        ThreadDebugCell->Status = dtsDispatched;
        ThreadDebugCell->LastUpdateTime = TickCount;

        CallDebugCell = DebugCell;
        CallDebugCell->InterfaceUUIDStart = LrpcBinding->RpcInterface->GetInterfaceFirstDWORD();
        CallDebugCell->CallID = CallId;
        CallDebugCell->LastUpdateTime = TickCount;
        // shoehorn the PID and TID into shorts - most of the time
        // it doesn't actually truncate important information
        CallDebugCell->PID = (USHORT)ClientId.UniqueProcess;
        CallDebugCell->TID = (USHORT)ClientId.UniqueThread;
        CallDebugCell->ProcNum = (unsigned short)RpcMessage.ProcNum;
        CallDebugCell->Status = csDispatched;
        GetDebugCellIDFromDebugCell((DebugCellUnion *)ThreadDebugCell, 
            &ThisThread->DebugCellTag, &CallDebugCell->ServicingTID);
        if (LrpcBinding->RpcInterface->IsPipeInterface())
            CallDebugCell->CallFlags |= DBGCELL_PIPE_CALL;
        }

    //
    // The rest of the response headers are set in ::GetBuffer.
    // We have to set MessageType before dispatch since as soon as we dispatch an async
    // call, AbortAsyncCall may get called on another thread, and will use LrpcReplyMessage
    // to send back a fault.
    //
    LrpcReplyMessage->Rpc.RpcHeader.MessageType = LRPC_MSG_RESPONSE;

    if (ObjectUuidFlag != 0)
        {
        Status = LrpcBinding->RpcInterface->DispatchToStubWithObject(
                                        &RpcMessage,
                                        &ObjectUuid,
                                        0,
                                        DispatchTableToUse,
                                        &ExceptionCode);
        }
    else
        {
        Status = LrpcBinding->RpcInterface->DispatchToStub(
                                        &RpcMessage,
                                        0,
                                        DispatchTableToUse,
                                        &ExceptionCode);
        }

    RpcpSetThreadContextWithThread(ThisThread, 0);

    LRPC_SCALL::RevertToSelf();

    if (ThreadDebugCell)
        {
        ThreadDebugCell->Status = dtsProcessing;
        ThreadDebugCell->LastUpdateTime = NtGetTickCount();
        }

    if (Status != RPC_S_OK)
        {
        if (Status == RPC_P_EXCEPTION_OCCURED)
            {
            SetFaultPacket(LrpcReplyMessage,
                           LrpcMapRpcStatus(ExceptionCode),
                           Flags,
                           this) ;
            }
        else
            {
            VALIDATE(Status)
                {
                RPC_S_PROCNUM_OUT_OF_RANGE,
                RPC_S_UNKNOWN_IF,
                RPC_S_NOT_LISTENING,
                RPC_S_SERVER_TOO_BUSY,
                RPC_S_UNSUPPORTED_TYPE
                } END_VALIDATE;

            if (Status == RPC_S_NOT_LISTENING)
                {
                RpcpErrorAddRecord(EEInfoGCRuntime, 
                    Status, 
                    EEInfoDLDealWithRequestMessage20);
                Status = RPC_S_SERVER_TOO_BUSY;
                }

            RpcpErrorAddRecord(EEInfoGCRuntime, 
                Status, 
                EEInfoDLDealWithRequestMessage30);
            SetFaultPacket(LrpcReplyMessage,
                           LrpcMapRpcStatus(Status),
                           Flags,
                           this);
            }

        if (IsSyncCall())
            {
            INITMSG(LrpcReplyMessage,
                    ClientId,
                    CallbackId,
                    MessageId) ;
            }
        else
            {
            if (Flags & LRPC_NON_PIPE)
                {
                INITMSG(LrpcReplyMessage,
                    ClientId,
                    CallbackId,
                    MessageId) ;

                Association->ReplyMessage(LrpcReplyMessage);
                }
            else
                {
                if ((LrpcReplyMessage->Rpc.RpcHeader.MessageType != LRPC_MSG_FAULT2)
                    || (!IsClientAsync()))
                    {
                    SendDGReply(LrpcReplyMessage);
                    }
                }
            RemoveReference();
            }
        }
}


void
LRPC_SCALL::SendReply (
    )
{
    RPC_STATUS Status;
    BOOL Shutup ;
    LRPC_SASSOCIATION *LocalAssociation;

    if (IsSyncCall())
        {
        if (IsClientAsync())
            {
            if (LrpcReplyMessage->Fault.RpcHeader.MessageType == LRPC_MSG_FAULT)
                {
                // Guard against attackers or broken clients that may induce a reply
                // before the reply port has been allocated.
                CORRUPTION_ASSERT(Association->LpcReplyPort);
                if (Association->LpcReplyPort)
                    {
                    SendDGReply(LrpcReplyMessage);
                    }
                else
                    {
                    Status = RPC_S_PROTOCOL_ERROR;
                    Association->Delete();
                    }
                }
            else
                {
                RpcMessage.RpcFlags = 0;
                Status = SendRequest(&RpcMessage, &Shutup) ;
                if (Status != RPC_S_OK)
                    {
#if DBG
                    PrintToDebugger("RPC: SendRequest failed: %d\n", Status);
#endif
                    if (Status != RPC_S_CALL_FAILED_DNE){
                        Association->Delete();
                        }
                    }
                }

            }
        else
            {
            INITMSG(LrpcReplyMessage,
                ClientId,
                CallbackId,
                MessageId) ;

            Association->ReplyMessage(LrpcReplyMessage);
            }

        FreeMessage(LrpcRequestMessage) ;

        LocalAssociation = Association;
        Association->FreeSCall(this) ;

        // don't touch the this pointer after FreeSCall - it may be freed
        LocalAssociation->Address->DereferenceAssociation(LocalAssociation);
        }
    else
        {
        if ((LrpcReplyMessage->Rpc.RpcHeader.MessageType != LRPC_MSG_FAULT2)
            || (!IsClientAsync()))
            {
            RemoveReference();
            }
        else
            {
            BOOL Shutup;
            RpcMessage.RpcFlags = 0;
            Status = SendRequest(&RpcMessage, &Shutup) ;
            if (Status != RPC_S_OK)
                {
#if DBG
                PrintToDebugger("RPC: SendRequest failed: %d\n", Status);
#endif
                if (Status != RPC_S_CALL_FAILED_DNE){
                    Association->Delete();
                    }
                }
            }
        }
}


LRPC_MESSAGE *
LRPC_SASSOCIATION::DealWithCopyMessage (
    IN LRPC_COPY_MESSAGE * LrpcMessage
    )
/*++

Routine Description:

    We will process a copy message in this routine; this means that we need
    to copy a buffer of data from the server into the client's address
    space.

Arguments:

    LrpcMessage - Supplies the copy message which was received from
        the client.

Return Value:

    The reply message to be sent to the client will be returned.

--*/
{
    NTSTATUS NtStatus;
    SIZE_T NumberOfBytesWritten;
    PVOID Buffer;

    ASSERT(LrpcMessage->IsPartial == 0);

    AssociationMutex.Request() ;

    // We need this only to prevent an attack
    // Also, the pointer is to a server address.  It is ok to just cast it
    // to the server's pointer type and it won't hurt anything in the case
    // of 32/64 bit LRPC.
    Buffer = Buffers.DeleteItemByBruteForce(MsgPtrToPtr(LrpcMessage->Server.Buffer));
    AssociationMutex.Clear() ;

   if (LrpcMessage->RpcStatus == RPC_S_OK)
       {
       if (Buffer == 0)
           {
           LrpcMessage->RpcStatus = RPC_S_PROTOCOL_ERROR;
           }
       else
           {
           NtStatus = NtWriteRequestData(LpcServerPort,
                                         (PORT_MESSAGE *) LrpcMessage,
                                         0,
                                         (PVOID) Buffer,
                                         LrpcMessage->Server.Length,
                                         &NumberOfBytesWritten);

           if (NT_ERROR(NtStatus))
               {
               LrpcMessage->RpcStatus = RPC_S_OUT_OF_MEMORY;
               }
           else
               {
               ASSERT(LrpcMessage->Server.Length == NumberOfBytesWritten);
               LrpcMessage->RpcStatus = RPC_S_OK;
               }
           }
       }

    LrpcMessage->LpcHeader.u1.s1.DataLength = sizeof(LRPC_COPY_MESSAGE)
                                            - sizeof(PORT_MESSAGE);
    LrpcMessage->LpcHeader.u1.s1.TotalLength = sizeof(LRPC_COPY_MESSAGE);

    if (Buffer != 0)
        {
        RpcpFarFree(Buffer);
        }

    return((LRPC_MESSAGE *) LrpcMessage);
}


LRPC_MESSAGE *
LRPC_SASSOCIATION::DealWithPartialRequest (
    IN LRPC_MESSAGE **LrpcMessage
    )
/*++

Routine Description:

    Deal with more data on  a dispatched call. This
    only happens when you have pipes. Pipe data on
    async calls is handled differently from sync calls.

Arguments:

 LrpcMessage - the LRPC message. For pipe data, we always
    take the slow path (ie: NtReadRequestData).

Return Value:

  NULL: if the request was processed.
  not NULL: if there was a problem. the return value contains the
  reply message.
--*/

{
    LRPC_SCALL *SCall ;
    RPC_STATUS Status ;

    AssociationMutex.Request() ;
    SCall = SCallDict.Find(ULongToPtr((*LrpcMessage)->Rpc.RpcHeader.CallId));
    AssociationMutex.Clear() ;

    // we have to wait until the server either calls
    // Receive or calls Register. If it Calls Receive,
    // we know that it is synchronous. If it calls
    // Register, we know that it is async.

    if (SCall)
        {
        Status = SCall->ProcessResponse(LrpcMessage) ;
        }
    else
        {
#if DBG
        PrintToDebugger("LRPC: No call corresponding the the pipe request\n");
#endif
        Status = RPC_S_OUT_OF_MEMORY ;
        }

    if (Status != RPC_S_OK)
        {
        SetFaultPacket(*LrpcMessage,
                       Status,
                       LRPC_SYNC_CLIENT,
                       NULL) ;
        return *LrpcMessage ;
        }

    return NULL ;
}

void
LRPC_SASSOCIATION::CleanupIdleSContexts (
    void
    )
/*++

Routine Description:

    Walks the list of SContexts, finds the ones
    that are idle and server side only, and cleans
    them up.

Arguments:

Return Value:

--*/
{
    LRPC_SCONTEXT *SContext;
    DictionaryCursor cursor;

    SContextDict.Reset(cursor);

    AssociationMutex.Request();
    while ((SContext = SContextDict.Next(cursor)) != 0)
        {
        if (SContext->GetServerSideOnlyFlag())
            {
            if (SContext->IsIdle())
                {
                SContext = (LRPC_SCONTEXT *)SContextDict.DeleteItemByBruteForce(SContext);
                ASSERT(SContext);

                SContext->Destroy();
                }
            }
        }

    AssociationMutex.Clear();
}


RPC_STATUS
LRPC_SCALL::SetupCall(
    )
/*++

Routine Description:

    Helper function that does the setup needed to use the
    call in conjuction with Pipes or Async RPC.

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/

{
    RPC_STATUS Status = RPC_S_OK ;

    //
    // Stuff from ActivateCall
    //
    RcvBufferLength = 0;
    CallId = LrpcRequestMessage->Rpc.RpcHeader.CallId ;
    ReceiveComplete = 0;
    AsyncReply = 0;
    CachedAPCInfoAvailable = 1;
    Choked = 0;
    fSendMoreExpected = FALSE;
    AsyncStatus = RPC_S_OK ;
    NeededLength = 0;
    NotificationIssued = -1;

    if (ReceiveEvent == 0)
        {
        ReceiveEvent = new EVENT(&Status, 0);
        if (ReceiveEvent == 0 || Status)
            {
            delete ReceiveEvent;
            ReceiveEvent = 0;
            return RPC_S_OUT_OF_MEMORY ;
            }

        CallMutex = new MUTEX(&Status) ;
        if (CallMutex == 0 || Status)
            {
            Association->SCallDict.Delete(ULongToPtr(CallId));
            goto Cleanup;
            }
        }
    else
        {
        ReceiveEvent->Lower();
        }

    Association->AssociationMutex.Request() ;
    if (Association->SCallDict.Insert(ULongToPtr(CallId), this) == -1)
        {
        Association->AssociationMutex.Clear() ;
        goto Cleanup;
        }
    Association->AssociationMutex.Clear() ;

    LrpcReplyMessage->Rpc.RpcHeader.CallId = CallId ;

    return (RPC_S_OK) ;

Cleanup:
    delete CallMutex ;
    delete ReceiveEvent;

    CallMutex = 0;
    ReceiveEvent = 0;

    return RPC_S_OUT_OF_MEMORY ;
}

RPC_STATUS
LRPC_SCALL::NegotiateTransferSyntax (
    IN OUT PRPC_MESSAGE Message
    )
{
    // this can happen in the callback case only.
    // Just return the already negotiated transfer syntax
    PRPC_DISPATCH_TABLE Ignored;

    SBinding->GetSelectedTransferSyntaxAndDispatchTable(&Message->TransferSyntax,
        &Ignored);

    return RPC_S_OK;
}


RPC_STATUS
LRPC_SCALL::GetBuffer (
    IN OUT PRPC_MESSAGE Message,
    IN UUID *
    )
/*++

Routine Description:

    We will allocate a buffer which will be used to either send a request
    or receive a response.

Arguments:

    Message - Supplies the length of the buffer that is needed.  The buffer
        will be returned.

Return Value:

    RPC_S_OK - A buffer has been successfully allocated.  It will be of at
        least the required length.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate that
        large a buffer.

--*/
{
    int BufferKey ;

    ASSERT(LrpcReplyMessage != 0) ;

    if (PARTIAL(Message))
        {
        CurrentBufferLength =
            (Message->BufferLength < MINIMUM_PARTIAL_BUFFLEN)
            ? MINIMUM_PARTIAL_BUFFLEN:Message->BufferLength ;

        Message->Buffer = RpcpFarAllocate(CurrentBufferLength) ;
        if (Message->Buffer == 0)
            {
            CurrentBufferLength = 0;
            return (RPC_S_OUT_OF_MEMORY) ;
            }
        }
    else if (Message->BufferLength <= MAXIMUM_MESSAGE_BUFFER)
        {
        ASSERT(((ULONG_PTR) LrpcReplyMessage->Rpc.Buffer) % 8 == 0);
        // uncomment this to check for 16 byte alignment on 64 bits
        // ASSERT(IsBufferAligned(LrpcReplyMessage->Rpc.Buffer));
        Message->Buffer = LrpcReplyMessage->Rpc.Buffer;
        LrpcReplyMessage->LpcHeader.u2.ZeroInit = 0;
        LrpcReplyMessage->Rpc.RpcHeader.Flags = LRPC_BUFFER_IMMEDIATE;
        LrpcReplyMessage->LpcHeader.u1.s1.DataLength = (USHORT)
                (Align4(Message->BufferLength) + sizeof(LRPC_RPC_HEADER));

        return (RPC_S_OK) ;
        }
    else
        {
        Message->Buffer = RpcpFarAllocate(Message->BufferLength);
        if (Message->Buffer == 0)
            {
            return(RPC_S_OUT_OF_MEMORY);
            }
        }

    LrpcReplyMessage->Rpc.RpcHeader.Flags = LRPC_BUFFER_SERVER;
    LrpcReplyMessage->LpcHeader.u2.ZeroInit = 0;

    if (PARTIAL(Message) || IsClientAsync())
        {
        LrpcReplyMessage->Rpc.Request.CountDataEntries = 1;
        LrpcReplyMessage->LpcHeader.MessageId =  0;
        LrpcReplyMessage->LpcHeader.CallbackId = 0;
        LrpcReplyMessage->LpcHeader.u2.s2.DataInfoOffset =
            sizeof(PORT_MESSAGE) + sizeof(LRPC_RPC_HEADER);
        LrpcReplyMessage->LpcHeader.u1.s1.DataLength =
            sizeof(LRPC_RPC_HEADER) + sizeof(PORT_DATA_INFORMATION);
        LrpcReplyMessage->Rpc.Request.DataEntries[0].Base = PtrToMsgPtr(Message->Buffer);
        LrpcReplyMessage->Rpc.Request.DataEntries[0].Size = Message->BufferLength;
        }
    else
        {
        Association->AssociationMutex.Request() ;
        BufferKey = Association->Buffers.Insert((LRPC_CLIENT_BUFFER *) Message->Buffer) ;
        Association->AssociationMutex.Clear() ;

        if (BufferKey == -1)
            {
            RpcpFarFree(Message->Buffer) ;
            return RPC_S_OUT_OF_MEMORY ;
            }

        LrpcReplyMessage->LpcHeader.u1.s1.DataLength =
            sizeof(LRPC_RPC_HEADER) + sizeof(LRPC_SERVER_BUFFER) ;

        ASSERT(Message->BufferLength < 0x80000000);

        LrpcReplyMessage->Rpc.Server.Length = Message->BufferLength ;
        LrpcReplyMessage->Rpc.Server.Buffer = PtrToMsgPtr(Message->Buffer) ;
        }

    return(RPC_S_OK);
}



void
LRPC_SCALL::FreeBuffer (
    IN PRPC_MESSAGE Message
    )
/*++

Routine Description:

    We will free the supplied buffer.

Arguments:

    Message - Supplies the buffer to be freed.

--*/
{
    ASSERT(LrpcReplyMessage != NULL) ;

    if (!(Message->Buffer == LrpcRequestMessage->Rpc.Buffer
        || Message->Buffer == LrpcReplyMessage->Rpc.Buffer))
        {
        if (!PARTIAL(Message) && !IsClientAsync())
            {
            Association->AssociationMutex.Request() ;
            Association->Buffers.DeleteItemByBruteForce((LRPC_CLIENT_BUFFER *) Message->Buffer);
            Association->AssociationMutex.Clear() ;
            }

        RpcpFarFree(Message->Buffer);
        }
}

void
LRPC_SCALL::FreePipeBuffer (
    IN PRPC_MESSAGE Message
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/

{
    RpcpFarFree(Message->Buffer) ;
}

RPC_STATUS
LRPC_SCALL::ReallocPipeBuffer (
    IN PRPC_MESSAGE Message,
    IN unsigned int NewSize
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/

{
    int BufferKey;
    PVOID Buffer ;
    void *NewBuffer ;
    BOOL BufferChanged = FALSE ;

    if (NewSize > CurrentBufferLength)
        {
        NewBuffer = RpcpFarAllocate(NewSize) ;
        if (NewBuffer == 0)
            {
            RpcpFarFree(Message->Buffer) ;

            return (RPC_S_OUT_OF_MEMORY) ;
            }

        if (CurrentBufferLength > 0)
            {
            RpcpMemoryCopy(NewBuffer, Message->Buffer, Message->BufferLength) ;
            FreePipeBuffer(Message) ;
            }
        Message->Buffer = NewBuffer ;
        CurrentBufferLength = NewSize ;
        BufferChanged = TRUE ;
        }

    Message->BufferLength = NewSize ;

    LrpcReplyMessage->Rpc.RpcHeader.Flags = LRPC_BUFFER_SERVER;

    ASSERT(Message->BufferLength < 0x80000000);

    LrpcReplyMessage->Rpc.Request.DataEntries[0].Base = PtrToMsgPtr(Message->Buffer);
    LrpcReplyMessage->Rpc.Request.DataEntries[0].Size = Message->BufferLength;


    return (RPC_S_OK) ;
}


RPC_STATUS
LRPC_SCALL::AbortAsyncCall (
    IN PRPC_ASYNC_STATE pAsync,
    IN unsigned long ExceptionCode
    )
{
    NTSTATUS NtStatus;
    RPC_STATUS Status = RPC_S_OK;

    NukeStaleEEInfoIfNecessary(ExceptionCode);

    RpcpErrorAddRecord(EEInfoGCApplication, 
        ExceptionCode, 
        EEInfoDLAbortCall, 
        SBinding->GetInterfaceFirstDWORD(),
        (short)RpcMessage.ProcNum,
        RpcMessage.RpcFlags);

    SetFaultPacket(LrpcReplyMessage, ExceptionCode, Flags, this);

    if (IsClientAsync())
        {
        if (LrpcReplyMessage->Rpc.RpcHeader.MessageType != LRPC_MSG_FAULT2)
            {
            NtStatus = SendDGReply(LrpcReplyMessage) ;
            }
        else
            {
            BOOL Ignored;
            RpcMessage.RpcFlags = 0;
            RpcMessage.Buffer = NULL;
            Status = SendRequest(&RpcMessage, 
                &Ignored        // shutup parameter - it is not relevant for us
                );
            if (Status != RPC_S_OK)
                {
#if DBG
                PrintToDebugger("RPC: SendRequest failed: %d\n", Status);
#endif
                if (Status != RPC_S_CALL_FAILED_DNE){
                    Association->Delete();
                    }
                }
            }
            // This is the only path that does not call an API returning NtStatus.
            // We need to initialize it.
            NtStatus = ERROR_SUCCESS;
        }
    else
        {
        INITMSG(LrpcReplyMessage,
                ClientId,
                CallbackId,
                MessageId);

        NtStatus = Association->ReplyMessage(LrpcReplyMessage);
        }

    if (NT_ERROR(NtStatus))
        {
        Status = RPC_S_CALL_FAILED ;
        }

    RemoveReference();

    return Status ;
}


RPC_STATUS
LRPC_SCALL::Receive (
    IN PRPC_MESSAGE Message,
    IN unsigned int Size
    )
/*++

Routine Description:
    Receive routine used by pipes

Arguments:

   Message - contains to buffer to receive in
   pSize - pointer to a size value that contains the minimum amount of
              data that needs to be received.


Return Value:

    RPC_S_OK - We have successfully converted the message.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to do the
        conversion.

--*/
{
    int RequestedSize;
    unsigned long Extra = IsExtraMessage(Message) ;

    Message->DataRepresentation = 0x00 | 0x10 | 0x0000;

    if (!Extra && Message->Buffer)
        {
        ASSERT(LrpcRequestMessage->Rpc.RpcHeader.Flags & LRPC_BUFFER_REQUEST);

        RpcpFarFree(Message->Buffer);
        Message->Buffer = 0;
        Message->BufferLength = 0;
        }

    // A broken or malicious client may make us think that he is doing a regular sync call
    // and then induce a pipe send or an async send.  We should break on a checked build unless
    // corruption injection is enabled.  On free builds we should return a failure.
    CORRUPTION_ASSERT(ReceiveEvent);
    if (ReceiveEvent == 0)
        {
        // Also, keep in mind that GetCoalescedBuffer may be expected to allocate Message->Buffer.
        Message->Buffer = 0;
        Message->BufferLength = 0;
        ((PRPC_RUNTIME_INFO) Message->ReservedForRuntime)->OldBuffer = 0;
        return RPC_S_PROTOCOL_ERROR;
        }

    //
    // It is ok for us to find out that the buffer is complete
    // before SavedBuffer is set,
    // we need to take the CallMutex in GetCoalescedBuffer
    //
    while (!BufferComplete && (!PARTIAL(Message) || RcvBufferLength < Size))
        {
        if (ReceiveEvent->Wait() == WAIT_FAILED)
            {
            return RPC_S_CALL_FAILED;
            }

        if (AsyncStatus != RPC_S_OK)
            {
            return AsyncStatus;
            }
        }

   return GetCoalescedBuffer(Message, Extra) ;
}


RPC_STATUS
LRPC_SCALL::Send (
    IN OUT PRPC_MESSAGE Message
    )
{
    BOOL Shutup ;

    Message->RpcFlags |= RPC_BUFFER_PARTIAL;

    return SendRequest(Message, &Shutup) ;
}


RPC_STATUS
LRPC_SCALL::SendRequest (
    IN OUT PRPC_MESSAGE Message,
    OUT BOOL *Shutup
    )
/*++

Routine Description:

    Sends a message on the LpcReplyPort (back connection).
    The message is sent either using RequestWaitReply or just Request.
    If we wait for a reply, it can either be LRPC_MSG_ACK or 
    LRPC_MSG_FAULT.  In the case of a fault, the error code sent
    with the fault is returned to the caller of this function.

Arguments:

 arg1 - description

Return Value:

    RPC_S_OK - Function succeeded
    RPC_S_*  - Low memory, a misbehaving client or an invalid LpcReplyPort have
               prevented us from either sending the message or receiving the response.
               Its also possible that a client has sent us a fault packet.
    
    NOTE: Currently RPC_S_CALL_FAILED_DNE will be returned by this method 
    only in the event that we are sending a message to a client which no
    longer exists (for instance, if it the call has been canceled).  In this
    case the client will send back a fault with RPC_S_CALL_FAILED_DNE.  It
    is not necessary to delete the association in this case.

--*/

{
    RPC_STATUS Status;
    NTSTATUS NtStatus ;
    int RemainingLength = 0;
    LRPC_MESSAGE ReplyMessage ;

    *Shutup = 0;

    if (PARTIAL(Message))
        {
        if (Message->BufferLength < MINIMUM_PARTIAL_BUFFLEN)
            {
            return (RPC_S_SEND_INCOMPLETE) ;
            }

        if (NOT_MULTIPLE_OF_EIGHT(Message->BufferLength))
            {
            RemainingLength = Message->BufferLength & LOW_BITS ;
            Message->BufferLength &= ~LOW_BITS ;
            }

        LrpcReplyMessage->Rpc.RpcHeader.Flags |= LRPC_BUFFER_PARTIAL ;
        }

    if (FirstSend)
        {
        // this code will get executed only in
        // the non async case
        FirstSend = 0;

        if (ReceiveEvent == 0)
            {
            Status = SetupCall() ;
            if (Status != RPC_S_OK)
                {
                if (PARTIAL(Message)
                    && LrpcReplyMessage->Rpc.RpcHeader.Flags & LRPC_BUFFER_SERVER)
                    {
                    RpcpFarFree(Message->Buffer);
                    }
                return Status ;
                }
            }
        }

    if (LrpcReplyMessage->Rpc.RpcHeader.Flags & LRPC_BUFFER_SERVER)
        {
        ASSERT((Message->Buffer == NULL)
            || (PtrToMsgPtr(Message->Buffer) == LrpcReplyMessage->Rpc.Request.DataEntries[0].Base));

        LrpcReplyMessage->LpcHeader.u1.s1.TotalLength =
            LrpcReplyMessage->LpcHeader.u1.s1.DataLength
            + sizeof(PORT_MESSAGE);
        if (LrpcReplyMessage->Rpc.RpcHeader.Flags & LRPC_EEINFO_PRESENT)
            {
            LrpcReplyMessage->Rpc.RpcHeader.MessageType = LRPC_MSG_FAULT2;
            // for FAULT2, the length has already been set
            }
        else
            {
            LrpcReplyMessage->Rpc.RpcHeader.MessageType = LRPC_MSG_RESPONSE;
            LrpcReplyMessage->Rpc.Request.DataEntries[0].Size =
                Message->BufferLength ;
            }
        LrpcReplyMessage->Rpc.RpcHeader.CallId = CallId;
        LrpcReplyMessage->Rpc.RpcHeader.Pad = 0;

        // Make sure we can't be impersonated on the transport level.
        // A legitimate Lrpc client will never do this.
        LrpcReplyMessage->LpcHeader.u2.s2.Type |= LPC_NO_IMPERSONATE;

        NtStatus = NtRequestWaitReplyPort(Association->LpcReplyPort,
                                     (PORT_MESSAGE *) LrpcReplyMessage,
                                     (PORT_MESSAGE *) &ReplyMessage) ;

        if (NT_ERROR(NtStatus))
            {
            if (Message->Buffer)
                {
                RpcpFarFree(Message->Buffer);
                }
            return RPC_S_CALL_FAILED ;
            }
        else
            {
            ASSERT((ReplyMessage.Rpc.RpcHeader.MessageType == LRPC_MSG_ACK)
                   ||
                   (ReplyMessage.Rpc.RpcHeader.MessageType == LRPC_MSG_FAULT));

            if (!PARTIAL(Message) && 
                (LrpcReplyMessage->Rpc.RpcHeader.MessageType != LRPC_MSG_FAULT2) && 
                (LrpcReplyMessage->Rpc.RpcHeader.MessageType != LRPC_MSG_FAULT))
                {
                if (Message->Buffer)
                    {
                    RpcpFarFree(Message->Buffer);
                    }
                }

            if (ReplyMessage.Rpc.RpcHeader.MessageType == LRPC_MSG_ACK)
                {
                *Shutup = ReplyMessage.Ack.Shutup;
                }
            else
                {
                Status = ReplyMessage.Fault.RpcStatus;
                return Status;
                }
            }
        }
    else
        {
        ASSERT(!PARTIAL(Message)) ;

        LrpcReplyMessage->Rpc.RpcHeader.MessageType = LRPC_MSG_RESPONSE;
        
        // If we are dealing with a broken or an attacking client
        // LpcReplyPort may not have been allocated.
        CORRUPTION_ASSERT(Association->LpcReplyPort);
        if (Association->LpcReplyPort)
            {
            NtStatus = SendDGReply(LrpcReplyMessage);

            if (NT_ERROR(NtStatus))
                {
                return RPC_S_CALL_FAILED;
                }
            }
        else
            {
            return RPC_S_PROTOCOL_ERROR;
            }

        }

    if (RemainingLength)
        {
        ASSERT(PARTIAL(Message)) ;
        RpcpMemoryMove(Message->Buffer,
                      (char  *) Message->Buffer + Message->BufferLength,
                      RemainingLength) ;

        Message->BufferLength = RemainingLength ;
        return (RPC_S_SEND_INCOMPLETE) ;
        }

    return RPC_S_OK ;
}

inline RPC_STATUS
LRPC_SCALL::GetBufferDo(
    IN OUT PRPC_MESSAGE Message,
    IN unsigned long NewSize,
    IN BOOL fDataValid
    )
/*++

Routine Description:

 description

Arguments:

 arg1 - description

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/

{
    void *NewBuffer ;

    if (NewSize < CurrentBufferLength)
        {
        Message->BufferLength = NewSize ;
        }
    else
        {
        NewBuffer = RpcpFarAllocate(NewSize) ;
        if (NewBuffer == 0)
            {
            RpcpFarFree(Message->Buffer) ;

            Message->BufferLength = 0;
            return RPC_S_OUT_OF_MEMORY ;
            }

        if (fDataValid && Message->BufferLength > 0)
            {
            RpcpMemoryCopy(NewBuffer,
                           Message->Buffer,
                           Message->BufferLength) ;
            }

        if (EXTRA(Message))
            {
            ASSERT(Message->ReservedForRuntime) ;
            ((PRPC_RUNTIME_INFO)Message->ReservedForRuntime)->OldBuffer =
                    NewBuffer;
            }

        RpcpFarFree(Message->Buffer) ;
        Message->Buffer = NewBuffer ;
        Message->BufferLength = NewSize ;
        }

    return RPC_S_OK ;
}


RPC_STATUS
LRPC_SCALL::SendReceive (
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:


Arguments:

    Message - Supplies the request and returns the response of a remote
        procedure call.

Return Value:

    RPC_S_OK - The remote procedure call completed successful.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to perform the
        remote procedure call.

    RPC_S_OUT_OF_RESOURCES - Insufficient resources are available to complete
        the remote procedure call.

--*/
{
    NTSTATUS NtStatus;
    RPC_STATUS ExceptionCode, Status;
    LRPC_MESSAGE *LrpcSavedMessage;
    SIZE_T NumberOfBytesRead;
    RPC_MESSAGE RpcMessage ;
    RPC_RUNTIME_INFO RuntimeInfo ;
    PRPC_DISPATCH_TABLE DispatchTableToUse;


    // The LrpcMessage must be saved, it is in use by the stub.  The current
    // LrpcReplyMessage can be used for the callback request message and reply.
    //
    // We must:
    // Save the current LrpcRequestMessage
    // Make the current LrpcReplyMessage the LrpcRequestMessage
    // Allocate a new LrpcReplyMessage.

    LrpcSavedMessage = LrpcRequestMessage;
    LrpcRequestMessage = LrpcReplyMessage;
    LrpcReplyMessage = 0;  // Only needed if we receive a recursive request.

    Association->Address->Server->OutgoingCallback();

    // NDR_DREP_ASCII | NDR_DREP_LITTLE_ENDIAN | NDR_DREP_IEEE
    Message->DataRepresentation = 0x00 | 0x10 | 0x0000;

    LrpcRequestMessage->LpcHeader.u1.s1.TotalLength = sizeof(PORT_MESSAGE)
            + LrpcRequestMessage->LpcHeader.u1.s1.DataLength;
    LrpcRequestMessage->LpcHeader.u2.s2.Type = LPC_REQUEST;
    INITMSG(LrpcRequestMessage, ClientId, CallbackId, MessageId);
    LrpcRequestMessage->Rpc.RpcHeader.MessageType = LRPC_MSG_CALLBACK;
    LrpcRequestMessage->Rpc.RpcHeader.ProcedureNumber = (unsigned short) Message->ProcNum;
    LrpcRequestMessage->Rpc.RpcHeader.PresentContext =
            SBinding->GetOnTheWirePresentationContext();

    LrpcRequestMessage->Rpc.RpcHeader.Pad = 0;

    // Make sure we can't be impersonated on the transport level.
    // A legitimate Lrpc client will never do this.
    LrpcRequestMessage->LpcHeader.u2.s2.Type |= LPC_NO_IMPERSONATE;

    NtStatus = NtRequestWaitReplyPort(Association->LpcServerPort,
                                      (PORT_MESSAGE *) LrpcRequestMessage,
                                      (PORT_MESSAGE *) LrpcRequestMessage);

    if (NT_ERROR(NtStatus))
        {
        LrpcReplyMessage = LrpcRequestMessage;
        LrpcRequestMessage = LrpcSavedMessage;

        if (NtStatus == STATUS_NO_MEMORY)
            {
            return(RPC_S_OUT_OF_MEMORY);
            }
        if (NtStatus == STATUS_INSUFFICIENT_RESOURCES)
            {
            return(RPC_S_OUT_OF_RESOURCES);
            }
#if DBG
        if ((NtStatus != STATUS_INVALID_PORT_HANDLE)
            && (NtStatus != STATUS_INVALID_HANDLE)
            && (NtStatus != STATUS_INVALID_CID)
            && (NtStatus != STATUS_PORT_DISCONNECTED)
            && (NtStatus != STATUS_LPC_REPLY_LOST))
            {
            PrintToDebugger("RPC : NtRequestWaitReplyPort : %lx\n",
                           NtStatus);

            ASSERT(0) ;
            }
#endif // DBG

        return(RPC_S_CALL_FAILED);
        }

    for (;;)
        {
        if (LrpcRequestMessage->Rpc.RpcHeader.MessageType
            == LRPC_MSG_FAULT)
            {
            Status = LrpcRequestMessage->Fault.RpcStatus;
            break;
            }

        if (LrpcRequestMessage->Rpc.RpcHeader.MessageType
            == LRPC_MSG_RESPONSE)
            {
            if (LrpcRequestMessage->Rpc.RpcHeader.Flags & LRPC_BUFFER_REQUEST)
                {
                LrpcRequestMessage->LpcHeader.ClientId = LrpcSavedMessage->Rpc.LpcHeader.ClientId;
                LrpcRequestMessage->LpcHeader.CallbackId = LrpcRequestMessage->Rpc.LpcHeader.CallbackId + 1;
                LrpcSavedMessage->LpcHeader.MessageId = LrpcSavedMessage->Rpc.LpcHeader.MessageId;
                }
            Status = LrpcMessageToRpcMessage(LrpcRequestMessage, Message);
            break;
            }

        if (LrpcRequestMessage->Rpc.RpcHeader.MessageType
            == LRPC_MSG_PUSH)
            {
            ASSERT(PushedResponse == 0);
            PushedResponse = RpcpFarAllocate(
                    (unsigned int)
                    LrpcRequestMessage->Push.Response.DataEntries[0].Size);
            if (PushedResponse == 0)
                {
                LrpcRequestMessage->Push.RpcStatus = RPC_S_OUT_OF_MEMORY;
                }
            else
                {
                NtStatus = NtReadRequestData(
                    Association->LpcServerPort,
                    (PORT_MESSAGE *) LrpcRequestMessage,
                    0,
                    PushedResponse,
                    LrpcRequestMessage->Push.Response.DataEntries[0].Size,
                    &NumberOfBytesRead);

                if (NT_ERROR(NtStatus))
                    {
                    RpcpFarFree(PushedResponse);
                    PushedResponse = 0;
                    LrpcRequestMessage->Push.RpcStatus = RPC_S_OUT_OF_MEMORY;
                    }
                else
                    {
                    ASSERT(LrpcRequestMessage->Push.Response.DataEntries[0].Size
                                == NumberOfBytesRead);
                    LrpcRequestMessage->Push.RpcStatus = RPC_S_OK;
                    }
                }


            INITMSG(LrpcRequestMessage,
                    ClientId,
                    CallbackId,
                    MessageId) ;

            NtStatus = NtReplyWaitReplyPort(Association->LpcServerPort,
                                          (PORT_MESSAGE *) LrpcRequestMessage);

            if (PushedResponse)
                {
                RpcpFarFree(PushedResponse);
                PushedResponse = 0;
                }
            }
        else
            {
            VALIDATE(LrpcRequestMessage->Rpc.RpcHeader.MessageType)
                {
                LRPC_MSG_REQUEST
                } END_VALIDATE;

            Status = LrpcMessageToRpcMessage(LrpcRequestMessage,
                                                                  Message);
            if (Status != RPC_S_OK)
                {
                LrpcRequestMessage->Fault.RpcHeader.MessageType =
                        LRPC_MSG_FAULT;
                LrpcRequestMessage->Fault.RpcStatus = LrpcMapRpcStatus(Status);
                LrpcRequestMessage->LpcHeader.u1.s1.DataLength =
                        sizeof(LRPC_FAULT_MESSAGE) - sizeof(PORT_MESSAGE);
                LrpcRequestMessage->LpcHeader.u1.s1.TotalLength =
                        sizeof(LRPC_FAULT_MESSAGE);

                INITMSG(LrpcRequestMessage,
                        ClientId,
                        CallbackId,
                        MessageId) ;

                NtStatus = NtReplyWaitReplyPort(Association->LpcServerPort,
                                        (PORT_MESSAGE *) LrpcRequestMessage);
                }
            else
                {

                LrpcReplyMessage = new LRPC_MESSAGE;

                if (LrpcReplyMessage != 0)
                    {
                    SBinding->GetSelectedTransferSyntaxAndDispatchTable(&Message->TransferSyntax,
                        &DispatchTableToUse);
                    Message->ProcNum =
                        LrpcRequestMessage->Rpc.RpcHeader.ProcedureNumber;

                    RuntimeInfo.Length = sizeof(RPC_RUNTIME_INFO) ;
                    RpcMessage = *Message ;
                    RpcMessage.ReservedForRuntime = &RuntimeInfo ;

                    if (ObjectUuidFlag != 0)
                        {
                        Status = SBinding->RpcInterface->
                                   DispatchToStubWithObject(
                                        &RpcMessage,
                                        &ObjectUuid,
                                        1,
                                        DispatchTableToUse,
                                        &ExceptionCode);
                        }
                    else
                        {
                        Status = SBinding->RpcInterface->
                                    DispatchToStub(
                                        &RpcMessage,
                                        1,
                                        DispatchTableToUse,
                                        &ExceptionCode);
                        }

                     *Message = RpcMessage ;

                    // Because we must send the reply and recieve the
                    // reply into the same message, we just copy the
                    // response into the LrpcRequestMessage

                    RpcpMemoryCopy(LrpcRequestMessage,
                                   LrpcReplyMessage,
                                   sizeof(LRPC_MESSAGE));
                    delete LrpcReplyMessage;
                    LrpcReplyMessage = 0;

                    }
                else
                    Status = RPC_S_OUT_OF_MEMORY;

                if (Status != RPC_S_OK)
                    {
                    VALIDATE(Status)
                        {
                        RPC_S_OUT_OF_MEMORY,
                        RPC_P_EXCEPTION_OCCURED,
                        RPC_S_PROCNUM_OUT_OF_RANGE
                        } END_VALIDATE;

                    if (Status == RPC_P_EXCEPTION_OCCURED)
                        {
                        Status = LrpcMapRpcStatus(ExceptionCode);
                        }

                    LrpcRequestMessage->Fault.RpcStatus = Status;
                    LrpcRequestMessage->LpcHeader.u1.s1.DataLength =
                            sizeof(LRPC_FAULT_MESSAGE) - sizeof(PORT_MESSAGE);
                    LrpcRequestMessage->LpcHeader.u1.s1.TotalLength =
                            sizeof(LRPC_FAULT_MESSAGE);
                    LrpcRequestMessage->Fault.RpcHeader.MessageType =
                            LRPC_MSG_FAULT;
                    }
                else
                    {
                    LrpcRequestMessage->LpcHeader.u1.s1.TotalLength =
                        sizeof(PORT_MESSAGE)
                        + LrpcRequestMessage->LpcHeader.u1.s1.DataLength;
                    LrpcRequestMessage->Rpc.RpcHeader.MessageType =
                        LRPC_MSG_RESPONSE;
                    }

                INITMSG(LrpcRequestMessage,
                        ClientId,
                        CallbackId,
                        MessageId) ;

                NtStatus = NtReplyWaitReplyPort(Association->LpcServerPort,
                                          (PORT_MESSAGE *) LrpcRequestMessage);
                }
            }

        if (NT_ERROR(NtStatus))
            {
            if (NtStatus == STATUS_NO_MEMORY)
                {
                Status = RPC_S_OUT_OF_MEMORY;
                }
            else if (NtStatus == STATUS_INSUFFICIENT_RESOURCES)
                {
                Status = RPC_S_OUT_OF_RESOURCES;
                }
            else
                {
                VALIDATE(NtStatus)
                    {
                    STATUS_INVALID_PORT_HANDLE,
                    STATUS_INVALID_HANDLE,
                    STATUS_INVALID_CID,
                    STATUS_PORT_DISCONNECTED,
                    STATUS_LPC_REPLY_LOST
                    } END_VALIDATE;

                Status = RPC_S_CALL_FAILED;
                }
            break;
            }
        }


    if (Status == RPC_S_OK)
        {
        Message->Handle = (RPC_BINDING_HANDLE) this;
        }

    ASSERT(LrpcReplyMessage == 0);
    LrpcReplyMessage = LrpcRequestMessage;
    LrpcRequestMessage = LrpcSavedMessage;

    return(Status);
}


void
LRPC_SCALL::FreeObject (
    )
{
    LRPC_SASSOCIATION *MyAssociation;

    ASSERT(pAsync) ;
    ASSERT(DispatchBuffer) ;

    if (DispatchBuffer != LrpcRequestMessage->Rpc.Buffer)
        {
        RpcpFarFree(DispatchBuffer);
        }

    FreeMessage(LrpcRequestMessage) ;

    MyAssociation = Association;

    MyAssociation->FreeSCall(this) ;
    MyAssociation->Address->DereferenceAssociation(MyAssociation);

    // Warning: The SCALL could have been nuked at this point.
    // DO NOT touch the SCALL after this
}


RPC_STATUS
LRPC_SCALL::AsyncSend (
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:

    Send an async reply. This request can either be partial or complete.
    If it is a complete request, we cleanup the SCall.

Arguments:

 Message - contains the request

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_SEND_INCOMPLETE - some data still needs to be sent.
                    Message->Buffer pointes to the remaining data, and
                    Message->BufferLength is the length of the remaining data.
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    NTSTATUS NtStatus ;
    BOOL fRetVal ;
    BOOL Shutup ;

    ASSERT(ReceiveEvent) ;

    if (AsyncStatus != RPC_S_OK)
        {
        if (PARTIAL(Message))
            {
            Status = AsyncStatus;
            }

        goto Cleanup;
        }

    FirstSend = 0;

    if (Flags & LRPC_NON_PIPE)
        {
        LrpcReplyMessage->Rpc.RpcHeader.MessageType = LRPC_MSG_RESPONSE;

        ASSERT(!IsClientAsync()) ;
        NtStatus = Association->ReplyMessage(LrpcReplyMessage);

        if (!NT_SUCCESS(NtStatus))
            {
            Status = RPC_S_OUT_OF_MEMORY ;
            }
        }
    else
        {
        // Take the call mutex if this is an async pipe call, we can assume that 
        // it is async since we are in AsyncSend, we must check if its pipe.
        // We need to take the mutex to avoid a race between setting fSendMoreExpected in AsyncSend and
        // checking it in the thread pool when servicing a LRPC_SERVER_SEND_MORE (ProcessResponse).  Without this
        // we could end up not getting a notification for this send
        if (PARTIAL(Message))
            CallMutex->Request();

        Status = SendRequest(Message, &Shutup) ;
        }

    if (PARTIAL(Message))
        {
        ASSERT(!(Flags & LRPC_NON_PIPE));
        if (Status == RPC_S_OK
            || Status == RPC_S_SEND_INCOMPLETE)
            {
            if (pAsync->Flags & RPC_C_NOTIFY_ON_SEND_COMPLETE)
                {
                if (Shutup)
                    {
                    fSendMoreExpected = TRUE;
                    }
                else
                    {
                    // The client should not become un choked.  We could check here that we are not
                    // transitioning from a Shutup to a non-shutup (choked to unchoked on the client).  
                    // Instead, we will set fSendMoreExpected to false so that we can remove this assumption
                    // without permiting any attack scenarios.
                    fSendMoreExpected = FALSE;
                    if (!IssueNotification(RpcSendComplete))
                        {
                        Status = RPC_S_OUT_OF_MEMORY ;
                        }
                    }
                }
            CallMutex->Clear();         
            return Status;
            }
        CallMutex->Clear();         
        }
    else
        {
        //
        // Non partial async sends will always succeed
        // if they fail, we will hide the error
        //
        Status = RPC_S_OK;
        }

Cleanup:
    //
    // on the server, the stub never calls FreeBuffer
    //
    RemoveReference();

    return Status;
}


RPC_STATUS
LRPC_SCALL::AsyncReceive (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned int Size
    )
/*++

Routine Description:

    On the server, this routine is only called when the stub needs
    more data to unmarshall the non pipe parameters, or when it needs
    pipe data.

Arguments:

 Message - contains information about the request
 Size - needed size

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/
{
    RPC_STATUS Status ;
    int Extra = IsExtraMessage(Message);

    ASSERT(ReceiveEvent) ;

    if (PARTIAL(Message) == 0)
        {
        return Receive(Message, Size);
        }

    if (Extra)
        {
        Status = Receive(Message, Size);
        //
        // don't need to check the status. If Receive failed, we are
        //  never going to access dispatch buffer anyway
        //
        DispatchBuffer = Message->Buffer ;

        return Status;
        }

    CallMutex->Request();

    Message->DataRepresentation = 0x00 | 0x10 | 0x0000;

    if (BufferComplete == 0
        && RcvBufferLength < Size)
        {
        if (NOTIFY(Message))
            {
            NeededLength = Size ;
            }
        CallMutex->Clear() ;

        return RPC_S_ASYNC_CALL_PENDING;
        }
    else
        {
        Status = GetCoalescedBuffer(Message, 0);
        }
    CallMutex->Clear();

    return Status ;
}


RPC_STATUS
LRPC_SCALL::SetAsyncHandle (
    IN PRPC_ASYNC_STATE pAsync
    )
/*++

Routine Description:

    Set the async handle corresponding this SCALL. This call is made
    by the stubs.

Arguments:

 pAsync - The async handle to association with this SCall

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/
{
    RPC_STATUS Status ;
    THREAD *Thread = RpcpGetThreadPointer();

    ASSERT(Thread);
    ASSERT(pAsync);

    Thread->fAsync = TRUE;

    if (DebugCell)
        {
        ASSERT(IsServerSideDebugInfoEnabled());
        DebugCell->CallFlags |= DBGCELL_ASYNC_CALL;
        }

    if (ReceiveEvent == 0)
        {
        Status = SetupCall();
        if (Status != RPC_S_OK)
            {
            return Status;
            }
        }

    if (LrpcAsyncReplyMessage == 0)
        {
        LrpcAsyncReplyMessage = AllocateMessage() ;
        if (LrpcAsyncReplyMessage == 0)
            {
            return RPC_S_OUT_OF_MEMORY ;
            }
        }

    LrpcReplyMessage = LrpcAsyncReplyMessage;
    // transfer/set the parts that the rest of the code expects to be set
    LrpcReplyMessage->Rpc.RpcHeader.CallId = CallId ;
    LrpcReplyMessage->Rpc.RpcHeader.MessageType = LRPC_MSG_RESPONSE;

    INITMSG(LrpcReplyMessage,
        ClientId,
        CallbackId,
        MessageId) ;

    this->pAsync = pAsync;

    if (SBinding->RpcInterface->IsAutoListenInterface())
        {
        SBinding->RpcInterface->BeginAutoListenCall() ;
        }

    SBinding->RpcInterface->BeginNullManagerCall();

    return RPC_S_OK ;
}


RPC_STATUS
LRPC_SCALL::ProcessResponse (
    IN LRPC_MESSAGE **LrpcMessage
    )
/*++

Routine Description:

    A buffer has just arrived, process it. If some other buffer is already
    processing buffers, simply queue it and go away. Otherwise, does
    the processing ourselves.

Arguments:

 Message - Details on the arrived message
--*/
{
    RPC_MESSAGE Message ;
    RPC_STATUS Status ;

    switch ((*LrpcMessage)->Rpc.RpcHeader.MessageType)
        {
        case LRPC_SERVER_SEND_MORE:
            if (pAsync && (pAsync->Flags & RPC_C_NOTIFY_ON_SEND_COMPLETE))
                {
                // Take the call mutex if this is an async pipe call, we can assume that 
                // it is async since we are in AsyncSend, we must check if its pipe.
                // We need to take the mutex to avoid a race between setting fSendMoreExpected in AsyncSend and
                // checking it in the thread pool when servicing a LRPC_SERVER_SEND_MORE (ProcessResponse).  Without this
                // we could end up not getting a notification for this send
                CallMutex->Request();
                if (fSendMoreExpected)
                    {
                    fSendMoreExpected = FALSE;
                    CallMutex->Clear();

                    if (!IssueNotification(RpcSendComplete))
                        {
                        AsyncStatus = RPC_S_OUT_OF_MEMORY ;

    #if DBG
                        PrintToDebugger("RPC: IssueNotification failed\n") ;
    #endif
                        //
                        // We are pretty much hosed here, but we'll try to
                        // queue notification anyway.
                        //
                        IssueNotification() ;
                        return RPC_S_OUT_OF_MEMORY ;
                        }
                    }
                else
                    {
                    CallMutex->Clear();
                    CORRUPTION_ASSERT(0);
                    return RPC_S_PROTOCOL_ERROR;
                    }
                }
            return RPC_S_OK ;

        case LRPC_MSG_CANCEL:
            InterlockedExchange(&CancelPending, 1);
            return RPC_S_OK;

        default:
            break;
        }

    CallMutex->Request() ;
    ASSERT(BufferComplete == 0);

    Message.RpcFlags = 0;
    Status = LrpcMessageToRpcMessage(
                                     *LrpcMessage,
                                     &Message) ;
    if (Status != RPC_S_OK)
        {
#if DBG
        PrintToDebugger("RPC: LrpcMessageToRpcMessage failed: %x\n", Status) ;
#endif

        AsyncStatus = Status ;
        IssueNotification() ;
        return Status ;
        }


    if (COMPLETE(&Message))
        {
        ASSERT(BufferComplete == 0);
        BufferComplete = 1;
        }

    if (Message.BufferLength)
        {
        RcvBufferLength += Message.BufferLength ;
        if (BufferQueue.PutOnQueue(Message.Buffer,
                                   Message.BufferLength))
          {
          AsyncStatus = Status = RPC_S_OUT_OF_MEMORY ;

#if DBG
          PrintToDebugger("RPC: PutOnQueue failed\n") ;
#endif
          }
        }
    else
        {
        // Zero BufferLength - this is the end of the IN pipe
        FreeBuffer(&Message);
        }

    if (IsSyncCall())
        {
        CallMutex->Clear() ;

        ReceiveEvent->Raise();
        }
    else
        {
        if (Status == RPC_S_OK
            && NeededLength > 0
            && RcvBufferLength >= NeededLength)
          {
          IssueNotification(RpcReceiveComplete);
          }
        CallMutex->Clear() ;
        }

    return Status ;
}


RPC_STATUS
LRPC_SCALL::GetCoalescedBuffer (
    IN PRPC_MESSAGE Message,
    IN BOOL BufferValid
    )
/*++

Routine Description:

    Remove buffers from the queue and coalesce them into a single buffer.

Arguments:

    Message - on return this will contain the coalesced buffer, Message->BufferLength
        gives us the length of the coalesced buffer.
    BufferValid - Tells us if Message->Buffer is valid on entry.

Return Value:

    RPC_S_OK - Function succeeded
    RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/
{
    void *NewBuffer, *Buffer ;
    char *Current ;
    unsigned int bufferlength ;
    unsigned int TotalLength ;
    LRPC_SENDMORE_MESSAGE SendMore ;
    NTSTATUS NtStatus ;

    CallMutex->Request() ;

    ASSERT(RcvBufferLength);

    if (BufferValid)
        {
        TotalLength = RcvBufferLength + Message->BufferLength ;
        }
    else
        {
        TotalLength = RcvBufferLength ;
        }

    NewBuffer = RpcpFarAllocate(TotalLength) ;
    if (NewBuffer == 0)
        {
        CallMutex->Clear() ;
        return RPC_S_OUT_OF_MEMORY;
        }

    if (BufferValid)
        {
        RpcpMemoryCopy(NewBuffer, Message->Buffer, Message->BufferLength) ;
        Current = (char *) NewBuffer + Message->BufferLength ;
        }
    else
        {
        Current = (char *) NewBuffer;
        }

    while ((Buffer = BufferQueue.TakeOffQueue(&bufferlength)) != 0)
        {
        RpcpMemoryCopy(Current, Buffer, bufferlength) ;
        Current += bufferlength ;
        RpcpFarFree(Buffer);
        }

    if (BufferValid && Message->Buffer)
        {
        RpcpFarFree(Message->Buffer);

        //
        // Update the dispatch buffer
        //
        ASSERT(Message->ReservedForRuntime) ;
        ((PRPC_RUNTIME_INFO)Message->ReservedForRuntime)->OldBuffer = NewBuffer;

        if (Message->Buffer == DispatchBuffer)
            DispatchBuffer = NewBuffer;
        }

    Message->Buffer = NewBuffer ;
    Message->BufferLength = TotalLength ;

    RcvBufferLength = 0;

    if (BufferComplete)
        {
        Message->RpcFlags |= RPC_BUFFER_COMPLETE ;
        }
    else
        {
        if (Choked)
            {
            CallMutex->Clear() ;

            //
            // send a message to the client
            // to start sending data again
            //
            SendMore.LpcHeader.u1.s1.DataLength =
                sizeof(SendMore) - sizeof(PORT_MESSAGE);
            SendMore.LpcHeader.u2.ZeroInit = 0;
            SanitizeLpcHeader (&SendMore.LpcHeader);

            // zero out everything b/n MessageType and CallId
            RPCP_ZERO_OUT_STRUCT_RANGE(LRPC_RPC_HEADER, 
                &SendMore.RpcHeader,
                Pad,
                CallId
                );

            SendMore.RpcHeader.MessageType = LRPC_CLIENT_SEND_MORE;
            SendMore.RpcHeader.CallId = CallId ;

            NtStatus = SendDGReply((LRPC_MESSAGE *)&SendMore) ;

            if (!NT_SUCCESS(NtStatus))
                {
                return RPC_S_CALL_FAILED ;
                }

            return RPC_S_OK;
            }
        }

    CallMutex->Clear() ;

    return RPC_S_OK ;
}


RPC_STATUS
LRPC_SCALL::ImpersonateClient (
    )
/*++

Routine Description:

    We will impersonate the client which made the remote procedure call.

--*/
{
    NTSTATUS NtStatus;
    RPC_STATUS Status;
    HANDLE hToken;
    DWORD LastError;

    Status = SetThreadSecurityContext((SECURITY_CONTEXT *) MAXUINT_PTR);
    if (RPC_S_OK != Status)
        {
        return Status;
        }

    if (SContext)
        {
        if (SContext->GetAnonymousFlag())
            {
            NtStatus = NtImpersonateAnonymousToken(NtCurrentThread());
            if (!NT_SUCCESS(NtStatus))
                {
                RpcpErrorAddRecord(EEInfoGCRuntime, 
                    RPC_S_ACCESS_DENIED,
                    EEInfoDLLRPC_SCALL__ImpersonateClient10,
                    (ULONG)NtStatus,
                    (ULONG)GetCurrentThreadId());

                ClearThreadSecurityContext();

                return RPC_S_ACCESS_DENIED;
                }
            }
        else if (SetThreadToken(NULL, SContext->hToken) == FALSE)
            {
            LastError = GetLastError();

            ClearThreadSecurityContext();
            
            if (LastError == ERROR_OUTOFMEMORY)
                {
                return (RPC_S_OUT_OF_MEMORY) ;
                }

            return RPC_S_ACCESS_DENIED;
            }
        }
    else
        {
        NtStatus = NtImpersonateClientOfPort(Association->LpcServerPort,
                                      (PORT_MESSAGE *) LrpcRequestMessage);

        if ((NtStatus == STATUS_INVALID_CID)
            || (NtStatus == STATUS_PORT_DISCONNECTED)
            || (NtStatus == STATUS_REPLY_MESSAGE_MISMATCH))
            {
            ClearThreadSecurityContext();
            return RPC_S_NO_CONTEXT_AVAILABLE;
            }

        if (!NT_SUCCESS(NtStatus))
            {
#if DBG
            PrintToDebugger("RPC : NtImpersonateClientOfPort : %lx\n",NtStatus);
#endif // DBG
            return RPC_S_ACCESS_DENIED;
            }
        }

    return(RPC_S_OK);
}


RPC_STATUS
LRPC_SCALL::RevertToSelf (
    )
/*++

Routine Description:

    This reverts a server thread back to itself after impersonating a client.
    We just check to see if the server thread is impersonating; this optimizes
    the common case.

--*/
{
    HANDLE ImpersonationToken = 0;
    NTSTATUS NtStatus;

    if (ClearThreadSecurityContext())
        {
        NtStatus = NtSetInformationThread(
                                          NtCurrentThread(),
                                          ThreadImpersonationToken,
                                          &ImpersonationToken,
                                          sizeof(HANDLE));
#if DBG
        if (!NT_SUCCESS(NtStatus))
            {
            PrintToDebugger("RPC : NtSetInformationThread : %lx\n", NtStatus);
            }
#endif // DBG

        if (!NT_SUCCESS(NtStatus))
            {
            if (NtStatus == STATUS_NO_MEMORY)
                {
                return RPC_S_OUT_OF_MEMORY;
                }
            return RPC_S_ACCESS_DENIED;
            }
        }

    return(RPC_S_OK);
}

RPC_STATUS
LRPC_SCALL::GetAuthorizationContext (
    IN BOOL ImpersonateOnReturn,
    IN AUTHZ_RESOURCE_MANAGER_HANDLE AuthzResourceManager,
    IN PLARGE_INTEGER pExpirationTime OPTIONAL,
    IN LUID Identifier,
    IN DWORD Flags,
    IN PVOID DynamicGroupArgs OPTIONAL,
    OUT PAUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext
    )
/*++

Routine Description:

    Gets an authorization context for the client that can be used
    with Authz functions. The resulting context is owned by the caller
    and must be freed by it.

Arguments:

    ImpersonateOnReturn - if TRUE, when we return, we should be impersonating.
    AuthzResourceManager - the resource manager to use (passed to Authz)
    pExpirationTime - the expiration time to use (passed to Authz)
    Identifier - the LUID (passed to Authz)
    Flags - Flags (passed to Authz)
    DynamicGroupArgs - parameter required by Authz (passed to Authz)
    pAuthzClientContext - the authorization context, returned on success. 
    Undefined on failure.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    RPC_STATUS RevertStatus;
    BOOL fNeedToRevert = FALSE;
    HANDLE ImpersonationToken;
    BOOL Result;
    BOOL fImpersonating = FALSE;
    PAUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContextPlaceholder;

    ASSERT (AuthzResourceManager != NULL);

    if (ImpersonateOnReturn 
        || (SContext == NULL) 
        || (SContext->AuthzClientContext == NULL))
        {
        Status = LRPC_SCALL::ImpersonateClient();
        if (Status != RPC_S_OK)
            {
            RpcpErrorAddRecord(EEInfoGCRuntime, 
                Status, 
                EEInfoDLLRPC_SCALL__GetAuthorizationContext10,
                (ULONG)ImpersonateOnReturn,
                (ULONGLONG)SContext);

            return Status;
            }

        fImpersonating = TRUE;
        if (!ImpersonateOnReturn)
            {
            fNeedToRevert = TRUE;
            }
        }

    if (SContext && SContext->AuthzClientContext)
        {
        Status = DuplicateAuthzContext(SContext->AuthzClientContext,
            pExpirationTime, 
            Identifier,
            Flags,
            DynamicGroupArgs,
            pAuthzClientContext);
        }
    else
        {
        // either we don't have an scontext, or its 
        // AuthzClientContext is not set yet.
        // Get the token from the thread
        Result = OpenThreadToken(GetCurrentThread(),
            TOKEN_QUERY,
            TRUE,
            &ImpersonationToken);

        if (Result)
            {
            if (SContext)
                pAuthzClientContextPlaceholder = &SContext->AuthzClientContext;
            else
                pAuthzClientContextPlaceholder = NULL;

            Status = CreateAndSaveAuthzContextFromToken(pAuthzClientContextPlaceholder,
                ImpersonationToken,
                AuthzResourceManager,
                pExpirationTime,
                Identifier,
                Flags,
                DynamicGroupArgs,
                pAuthzClientContext);

            CloseHandle(ImpersonationToken);
            }
        else
            {
            Status = GetLastError();
            if (Status == ERROR_CANT_OPEN_ANONYMOUS)
                {
                Result = AuthzInitializeContextFromSidFn(
                    AUTHZ_SKIP_TOKEN_GROUPS,
                    (PSID)&AnonymousSid,
                    AuthzResourceManager,
                    pExpirationTime,
                    Identifier,
                    DynamicGroupArgs,
                    pAuthzClientContext);

                if (Result)
                    {
                    if (SContext)
                        {
                        if (InterlockedCompareExchangePointer((PVOID *)&SContext->AuthzClientContext,
                                pAuthzClientContext,
                                NULL) != NULL)
                            {
                            // somebody beat us to the punch - free the context we obtained
                            AuthzFreeContextFn(*pAuthzClientContext);
                            *pAuthzClientContext = SContext->AuthzClientContext;
                            }
                        }
                    // else
                    // the authz context is already loaded in pAuthzClientContext
                    Status = RPC_S_OK;
                    }
                else
                    {
                    Status = GetLastError();

                    RpcpErrorAddRecord(EEInfoGCAuthz, 
                        Status, 
                        EEInfoDLLRPC_SCALL__GetAuthorizationContext30,
                        GetCurrentThreadId(),
                        (ULONGLONG)AuthzResourceManager);
                    }

                }
            else
                {
                RpcpErrorAddRecord(EEInfoGCRuntime,
                    Status, 
                    EEInfoDLLRPC_SCALL__GetAuthorizationContext20,
                    GetCurrentThreadId());
                }
            }

        }

    // if caller didn't ask us to impersonate and we are,
    // or we if he did ask us, but we failed somewhere,
    // revert to self
    if (fNeedToRevert || (Status && fImpersonating))
        {
        RevertStatus = LRPC_SCALL::RevertToSelf();
        ASSERT(RevertStatus == RPC_S_OK);
        }

    return Status;
}


RPC_STATUS
LRPC_SCALL::IsClientLocal (
    OUT unsigned int * ClientLocalFlag
    )
/*++

Routine Description:

    A client using LRPC will always be local.

Arguments:

    ClientLocalFlag - Returns a flag which will always be set to a non-zero
        value indicating that the client is local.

--*/
{
    UNUSED(this);

    *ClientLocalFlag = 1;
    return(RPC_S_OK);
}

void 
LRPC_SCALL::IsClientDisconnected (
    OUT BOOL *ClientIsDisconnected
    )
/*++

Routine Description:

    Checks whether the client for the given call has disconnected.

Arguments:

    ClientIsDisconnected - on output it will contain non-zero if the client is
        disconnected. If the client is still connected, it will contain 0.

Return Value:

Note:

    If called on async RPC calls, it is the obligation of the caller to make sure that
        the call is not completed while this API is in progress.

--*/
{
    *ClientIsDisconnected = Association->IsDeleted();
}


RPC_STATUS
LRPC_SCALL::ConvertToServerBinding (
    OUT RPC_BINDING_HANDLE __RPC_FAR * ServerBinding
    )
/*++

Routine Description:

    If possible, convert this call into a server binding, meaning a
    binding handle pointing back to the client.

Arguments:

    ServerBinding - Returns the server binding.

Return Value:

    RPC_S_OK - The server binding has successfully been created.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate
        a new binding handle.

--*/
{
    RPC_STATUS Status;
    RPC_CHAR UuidString[37];
    RPC_CHAR * StringBinding;

    if (ObjectUuidFlag != 0)
        {
        ObjectUuid.ConvertToString(UuidString);
        UuidString[36] = '\0';
        }

    Status = RpcStringBindingComposeW(
                                      (ObjectUuidFlag != 0 ? UuidString : 0),
                                      RPC_STRING_LITERAL("ncalrpc"),
                                      gLocalComputerName,
                                      0,
                                      0,
                                      &StringBinding);
    if (Status != RPC_S_OK)
        {
        return(Status);
        }

    Status = RpcBindingFromStringBindingW(
                                          StringBinding,
                                          ServerBinding);

    RpcStringFreeW(&StringBinding);
    return(Status);
}


void
LRPC_SCALL::InquireObjectUuid (
    OUT RPC_UUID * ObjectUuid
    )
/*++

Routine Description:

    This routine copies the object uuid from the call into the supplied
    ObjectUuid argument.

Arguments:

    ObjectUuid - Returns a copy of the object uuid passed by the client
        in the remote procedure call.

--*/
{
    if (ObjectUuidFlag == 0)
        {
        ObjectUuid->SetToNullUuid();
        }
    else
        {
        ObjectUuid->CopyUuid(&(this->ObjectUuid));
        }
}


RPC_STATUS
LRPC_SCALL::ToStringBinding (
    OUT RPC_CHAR ** StringBinding
    )
/*++

Routine Description:

    We need to convert this call into a string binding.  We will ask the
    address for a binding handle which we can then convert into a string
    binding.

Arguments:

    StringBinding - Returns the string binding for this call.

Return Value:


--*/
{
    RPC_STATUS Status;
    BINDING_HANDLE * BindingHandle
            = Association->Address->InquireBinding();

    if (BindingHandle == 0)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    Status = BindingHandle->ToStringBinding(StringBinding);
    BindingHandle->BindingFree();
    return(Status);
}


RPC_STATUS
LRPC_SCALL::GetAssociationContextCollection (
    OUT ContextCollection **CtxCollection
    )
{
    return Association->GetAssociationContextCollection(CtxCollection);
}


inline RPC_STATUS
LRPC_SCALL::LrpcMessageToRpcMessage (
    IN LRPC_MESSAGE  *  LrpcMessage,
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:

    We will convert from an LRPC_MESSAGE representation of a buffer (and
    its length) to an RPC_MESSAGE representation.

Arguments:

    RpcMessage - Returns the RPC_MESSAGE representation.

Return Value:

    RPC_S_OK - We have successfully converted the message.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to do the
        conversion.

--*/
{
    NTSTATUS NtStatus;
    SIZE_T NumberOfBytesRead;
    unsigned char MessageType = LrpcMessage->Rpc.RpcHeader.MessageType;
    RPC_STATUS Status = RPC_S_OK ;
    LRPC_MESSAGE ReplyMessage ;

    if(LrpcMessage->Rpc.RpcHeader.Flags & LRPC_BUFFER_IMMEDIATE)
        {
        Message->Buffer = LrpcMessage->Rpc.Buffer;
        if (LrpcMessage->LpcHeader.u1.s1.DataLength
                          < sizeof(LRPC_RPC_HEADER))
            {
        CORRUPTION_ASSERT(LrpcMessage->LpcHeader.u1.s1.DataLength
                          >= sizeof(LRPC_RPC_HEADER));
            return (RPC_S_PROTOCOL_ERROR);
            }
        Message->BufferLength =
                (unsigned int) LrpcMessage->LpcHeader.u1.s1.DataLength
                                            - sizeof(LRPC_RPC_HEADER);
        Message->RpcFlags |= RPC_BUFFER_COMPLETE ;
        }
    else if (LrpcMessage->Rpc.RpcHeader.Flags & LRPC_BUFFER_REQUEST)
        {
        Message->BufferLength = LrpcMessage->Rpc.Request.DataEntries[0].Size;

        if (LrpcMessage->Rpc.RpcHeader.Flags & LRPC_BUFFER_PARTIAL)
            {
            CallMutex->Request() ;

            //
            // If the user ever specifies a Size > LRPC_THRESHOLD_SIZE
            // our performance will be bad.
            //
            if (RcvBufferLength >= LRPC_THRESHOLD_SIZE)
                {
                Choked = 1;
                }
            CallMutex->Clear() ;
            }
        else
            {
            Message->RpcFlags |= RPC_BUFFER_COMPLETE ;
            }

        if (Message->BufferLength >= 0x80000000)
            {
            ASSERT( Message->BufferLength < 0x80000000);
            Message->Buffer = 0;
            Status = RPC_S_PROTOCOL_ERROR;
            }
        else 
            {
            Message->Buffer = RpcpFarAllocate(Message->BufferLength) ;
            if (Message->Buffer == 0)
                {
                Status = RPC_S_OUT_OF_MEMORY ;
                }
            }

        if (Message->Buffer == 0)
            {
            RpcpErrorAddRecord(EEInfoGCRuntime, 
                Status, 
                EEInfoDLLrpcMessageToRpcMessage10, 
                Message->BufferLength);
            }
        else
            {
            NtStatus = NtReadRequestData(Association->LpcServerPort,
                                         (PORT_MESSAGE *) LrpcMessage,
                                         0,
                                         Message->Buffer,
                                         Message->BufferLength,
                                         &NumberOfBytesRead) ;

            if (NT_ERROR(NtStatus))
                {
                RpcpFarFree(Message->Buffer) ;
                Message->Buffer = 0;

                Status = RPC_S_OUT_OF_MEMORY ;
                RpcpErrorAddRecord(EEInfoGCRuntime, 
                    Status, 
                    EEInfoDLLrpcMessageToRpcMessage20, 
                    NtStatus);
                }
            else
                {
                ASSERT(Message->BufferLength == NumberOfBytesRead) ;
                }
            }

        if (IsClientAsync())
            {
            SanitizeLpcHeader(&ReplyMessage.Ack.LpcHeader);
            COPYMSG((&ReplyMessage), LrpcMessage) ;
            ReplyMessage.Ack.MessageType = LRPC_MSG_ACK ;
            ReplyMessage.Ack.Pad = 0;
            ReplyMessage.Ack.RpcStatus = Status;
            ReplyMessage.Ack.Shutup = (short) Choked ;
            ReplyMessage.Ack.ValidDataSize = 0;
            ReplyMessage.Ack.Flags = 0;
            ReplyMessage.LpcHeader.u1.s1.DataLength =
                    sizeof(LRPC_ACK_MESSAGE) - sizeof(PORT_MESSAGE) ;

           NtStatus = Association->ReplyMessage(&ReplyMessage);

           if (NT_ERROR(NtStatus))
                {
                RpcpFarFree(Message->Buffer);
                RpcpErrorAddRecord(EEInfoGCRuntime, 
                    RPC_S_OUT_OF_MEMORY, 
                    EEInfoDLLrpcMessageToRpcMessage30, 
                    NtStatus);
                return(RPC_S_OUT_OF_MEMORY);
                }
            }
      }
  else
      {
      CORRUPTION_ASSERT((LrpcMessage->Rpc.RpcHeader.Flags & LRPC_BUFFER_IMMEDIATE)
                        || (LrpcMessage->Rpc.RpcHeader.Flags & LRPC_BUFFER_REQUEST));
      return (RPC_S_PROTOCOL_ERROR);
      }

    return(Status);
}



RPC_STATUS
LRPC_SCALL::InquireAuthClient (
    OUT RPC_AUTHZ_HANDLE  * Privileges,
    OUT RPC_CHAR  *  * ServerPrincipalName, OPTIONAL
    OUT unsigned long  * AuthenticationLevel,
    OUT unsigned long  * AuthenticationService,
    OUT unsigned long  * AuthorizationService,
    IN  unsigned long    Flags
    )
/*++

Routine Description:

    Each protocol module must define this routine: it is used to obtain
    the authentication and authorization information about a client making
    the remote procedure call represented by this.

Arguments:

    Privileges - Returns a the privileges of the client.

    ServerPrincipalName - Returns the server principal name which the client
        specified.

    AuthenticationLevel - Returns the authentication level requested by
        the client.

    AuthenticationService - Returns the authentication service requested by
        the client.

    AuthorizationService - Returns the authorization service requested by
        the client.

Return Value:

    RPC_S_OK or RPC_S_* / Win32 error

--*/
{
    RPC_STATUS Status;

    if(ARGUMENT_PRESENT(Privileges))
        {
        *(RPC_CHAR **)Privileges = NULL;
        Status = Association->GetClientName(this, 
            NULL,       // ClientPrincipalNameBufferLength
            (RPC_CHAR **) Privileges);
        if (Status != RPC_S_OK)
            {
            return Status;
            }
        }

    if (ARGUMENT_PRESENT(ServerPrincipalName))
       {
       *ServerPrincipalName = NULL;
       }

    if(ARGUMENT_PRESENT(AuthenticationLevel))
       {
       *AuthenticationLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY ;
       }

    if(ARGUMENT_PRESENT(AuthenticationService))
        {
        *AuthenticationService = RPC_C_AUTHN_WINNT ;
        }

    if(ARGUMENT_PRESENT(AuthorizationService))
        {
        *AuthorizationService =   RPC_C_AUTHZ_NONE  ;
        }

    return(RPC_S_OK);
}

RPC_STATUS
LRPC_SCALL::InquireCallAttributes (
    IN OUT void *RpcCallAttributes
    )
/*++

Routine Description:

    Inquire the security context attributes for the LRPC client

Arguments:
    RpcCallAttributes - a pointer to 
        RPC_CALL_ATTRIBUTES_V1_W structure. The Version
        member must be initialized.

Return Value:

    RPC_S_OK or RPC_S_* / Win32 error. EEInfo will be returned.

--*/
{
    RPC_CALL_ATTRIBUTES_V1 *CallAttributes;
    RPC_STATUS Status = RPC_S_OK;

    CallAttributes = 
        (RPC_CALL_ATTRIBUTES_V1 *)RpcCallAttributes;

    CallAttributes->AuthenticationLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
    CallAttributes->AuthenticationService = RPC_C_AUTHN_WINNT;
    CallAttributes->NullSession = FALSE;

    if (CallAttributes->Flags & RPC_QUERY_CLIENT_PRINCIPAL_NAME)
        {
        Status = Association->GetClientName(this, 
            &CallAttributes->ClientPrincipalNameBufferLength,
            &CallAttributes->ClientPrincipalName);

        if ((Status != RPC_S_OK) && (Status != ERROR_MORE_DATA))
            {
            return Status;
            }
        }

    if (CallAttributes->Flags & RPC_QUERY_SERVER_PRINCIPAL_NAME)
        {
        CallAttributes->ServerPrincipalNameBufferLength = 0;
        }

    return Status;
}

LRPC_SBINDING *
LRPC_SCALL::LookupBinding (
   IN unsigned short PresentContextId
   )
/*++
Function Name:LookupBinding

Parameters:

Description:

Returns:

--*/
{
    LRPC_SBINDING *CurBinding;
    DictionaryCursor cursor;
    long OldLockValue, NewLockValue;

    Association->Bindings.Reset(cursor);

    // lock out addition of new elements to make sure we are getting a consistent view
    while (TRUE)
        {
        OldLockValue = Association->BindingsCollectionLock.GetInteger();
        NewLockValue = OldLockValue + 1;
        if ((OldLockValue >= 0)
            && (Association->BindingsCollectionLock.CompareExchange(NewLockValue, OldLockValue) == OldLockValue))
            {
            break;
            }
        Sleep (2);
        }

    while ((CurBinding = Association->Bindings.Next(cursor)))
        {
        if (CurBinding->GetPresentationContext() == PresentContextId)
            {
            ASSERT (Association->BindingsCollectionLock.GetInteger() > 0);
            Association->BindingsCollectionLock.Decrement ();
            return CurBinding;
            }
        }

    ASSERT (Association->BindingsCollectionLock.GetInteger() > 0);
    Association->BindingsCollectionLock.Decrement ();
    return NULL;
}



RPC_STATUS
LRPC_SCALL_AVRF::ImpersonateClient (
    )
/*++

Routine Description:

    Overwrites the default ImpersonateClient routine for LPC_SCALL to
    provide fault injection.

Arguments:

    None

Return Value:

    RPC_S_OK or RPC_S_* on failure

--*/
{
    // If we are running with RPC veirfier and fault injection is enabled
    // for RpcImpersonateClient, see if we should fail it.
    if (pRpcVerifierSettings->fFaultInjectImpersonateClient)
        {
        // See if enough time has passed to start the fault injection.
        if (!pRpcVerifierSettings->DelayFaultInjectImpersonateClient ||
            GetTickCount() - gProcessStartTime > pRpcVerifierSettings->DelayFaultInjectImpersonateClient*1000)
            {
            if (RndBool(pRpcVerifierSettings->ProbFaultInjectImpersonateClient))
                {
                return RPC_S_OUT_OF_MEMORY;
                }
            }
        }

    return LRPC_SCALL::ImpersonateClient();
}

LRPC_SCONTEXT::LRPC_SCONTEXT (
    IN HANDLE MyToken,
    IN LUID *UserLuid,
    IN LRPC_SASSOCIATION *MyAssociation,
    IN BOOL fDefaultLogonId,
    IN BOOL fAnonymousToken
    )
{
    hToken = MyToken;
    ClientName = NULL;
    RefCount = 1;
    ClearDeletedFlag();
    Association = MyAssociation;
    AuthzClientContext = NULL;
    if (fAnonymousToken)
        SetAnonymousFlag();
    else
        ClearAnonymousFlag();
    if (fAnonymousToken)
        {
        ASSERT(fDefaultLogonId == FALSE);
        ASSERT(UserLuid == NULL);
        }
    else
        {
        ASSERT(fAnonymousToken == FALSE);
        if (fDefaultLogonId)
            SetDefaultLogonIdFlag();
        else
            ClearDefaultLogonIdFlag();
        FastCopyLUID(&ClientLuid, UserLuid);
        }
}

LRPC_SCONTEXT::~LRPC_SCONTEXT (
    void
    )
{
    if (hToken)
        {
        CloseHandle(hToken);
        }
    RpcpFarFree(ClientName);

    if (AuthzClientContext)
        {
        AuthzFreeContextFn(AuthzClientContext);
        AuthzClientContext = NULL;
        }

    if (GetServerSideOnlyFlag())
        {
        // if this is server side only context, remove us
        // from the garbage collection count
        InterlockedDecrement(&PeriodicGarbageCollectItems);
        }
}

RPC_STATUS
LRPC_SCONTEXT::GetUserName (
    IN OUT ULONG *ClientPrincipalNameBufferLength OPTIONAL,
    OUT RPC_CHAR **UserName,
    IN HANDLE hUserToken OPTIONAL
    )
/*++

Routine Description:

    Gets the user name for the given context.

Arguments:

    ClientPrincipalNameBufferLength - if present, *UserName must
        point to a caller supplied buffer, which if big enough,
        will be filled with the client principal name. If not present,
        *UserName must be NULL.
    UserName - see ClientPrincipalNameBufferLength
    hUserToken - if present, the user name for the given token will
        be retrieved instead of the user name for the token inside
        the LRPC_SCONTEXT

Return Value:

    RPC_S_OK for success, or RPC_S_* / Win32 error code for error.

--*/
{
    TOKEN_USER *pUser;
    RPC_STATUS Status;
    RPC_CHAR *ClientPrincipalName;
    ULONG ClientPrincipalNameLength;    // in bytes, including NULL terminator

    if (ClientName == 0)
        {
        if (GetAnonymousFlag() == 0)
            {
            if (hUserToken == NULL)
                {
                ASSERT(hToken != NULL);
                hUserToken = hToken;
                }

            pUser = GetSID(hUserToken);
            if (pUser == 0)
                {
                return RPC_S_OUT_OF_MEMORY;
                }

            Status = LookupUser((SID *)pUser->User.Sid, &ClientPrincipalName);
            delete pUser;
            }
        else
            {
            Status = LookupUser((SID *)&AnonymousSid, &ClientPrincipalName);
            }

        if (Status != RPC_S_OK)
            {
            return Status;
            }

        if (InterlockedCompareExchangePointer((PVOID *)&ClientName, ClientPrincipalName, NULL) != NULL)
            {
            // somebody beat us to the punch. Free the allocated string
            delete ClientPrincipalName;
            }
        }

    // at this stage, ClientName must contain the client principal name
    ASSERT(ClientName);

    // See where our caller wants us to put it
    if (ARGUMENT_PRESENT(ClientPrincipalNameBufferLength))
        {
        // in the future, we may think of caching the length to avoid
        // computing it every time
        ClientPrincipalNameLength = (RpcpStringLength(ClientName) + 1) * sizeof(RPC_CHAR);

        // if there is enough space in the data, copy it to user buffer
        if (ClientPrincipalNameLength <= *ClientPrincipalNameBufferLength)
            {
            RpcpMemoryCopy(*UserName,
                ClientName,
                ClientPrincipalNameLength);
            Status = RPC_S_OK;
            }
        else
            {
            Status = ERROR_MORE_DATA;
            }

        *ClientPrincipalNameBufferLength = ClientPrincipalNameLength;

        return Status;
        }
    else
        {
        ASSERT(*UserName == NULL);
        *UserName = ClientName;
        }

    return RPC_S_OK;
}

TOKEN_USER *
LRPC_SCONTEXT::GetSID (
    IN HANDLE hToken
    )
{
    char *Buf = NULL;
    ULONG Bufflen = 64 ;
    ULONG Length;

    Buf = new char[Bufflen];
    if (Buf == 0)
        {
        return NULL;
        }

    while (1)
        {
        if (GetTokenInformation(hToken,
                            TokenUser, Buf, Bufflen,
                            &Length) == FALSE)
            {
            if (Length > Bufflen)
                {
                Bufflen = Length ;
                delete [] Buf;

                Buf = new char[Bufflen];
                if (Buf == 0)
                    {
                    return NULL;
                    }
                continue;
                }
            else
                {
#if DBG
                PrintToDebugger("LRPC: GetTokenInformation failed\n") ;
#endif
                return NULL;
                }
            }
        break;
        }

    return (TOKEN_USER *) Buf;
}

RPC_STATUS
LRPC_SCONTEXT::LookupUser (
    IN SID *pSid,
    OUT RPC_CHAR **ReturnedUserName
    )
{
    RPC_CHAR *FullName = NULL, *UserName = NULL;
    unsigned long DomainNameLength = DOMAIN_NAME_LEN ;
    unsigned long UserNameLength = USER_NAME_LEN;
    unsigned long OldDomainNameLength, OldUserNameLength;
    SID_NAME_USE Name ;
    RPC_STATUS Status = RPC_S_OK ;

    UserName = new RPC_CHAR[UserNameLength];
    if (UserName == 0)
        {
        Status = RPC_S_OUT_OF_MEMORY ;
        goto Cleanup ;
        }

    // Allocate space for the whole name: "domain\user"
    FullName = new RPC_CHAR [DomainNameLength+1+UserNameLength];
    if (FullName == 0)
        {
        Status = RPC_S_OUT_OF_MEMORY ;
        goto Cleanup ;
        }

    OldDomainNameLength = DomainNameLength ;
    OldUserNameLength = UserNameLength ;

    while (1)
        {
        // For optimization we will try to retrieve the domain name directly into the
        // beginning of the full name.
        if (LookupAccountSidW(NULL, pSid,
                              UserName, &UserNameLength,
                              FullName, &DomainNameLength, &Name) == FALSE)
            {
            // Check if the buffers specified were insufficient.
            // If the function fails because the buffer is too small,
            // DomainName/UserName receives the required buffer size,
            // including the terminating null character.
            if ((UserNameLength > OldUserNameLength) || (DomainNameLength > OldDomainNameLength))
                {
                if (UserNameLength > OldUserNameLength)
                    {
                    OldUserNameLength = UserNameLength ;
                    delete [] UserName;

                    UserName = new RPC_CHAR[UserNameLength];
                    if (UserName == 0)
                        {
                        Status = RPC_S_OUT_OF_MEMORY ;
                        goto Cleanup ;
                        }
                    }

                if (DomainNameLength > OldDomainNameLength)
                    {
                    OldDomainNameLength = DomainNameLength;
                    delete [] FullName;

                    FullName = new RPC_CHAR [DomainNameLength+1+UserNameLength];
                    if (FullName == 0)
                        {
                        Status = RPC_S_OUT_OF_MEMORY ;
                        goto Cleanup ;
                        }
                    }
                continue;
                }
            else
                {
#if DBG
                PrintToDebugger("LRPC: LookupAccountSid failed\n");
#endif
                Status = RPC_S_UNKNOWN_PRINCIPAL;
                goto Cleanup ;
                }
            }
        break;
        }

    RpcpStringConcatenate(FullName, RPC_CONST_STRING("\\")) ;
    RpcpStringConcatenate(FullName, UserName) ;

    delete [] UserName;
    *ReturnedUserName = FullName ;
    ASSERT(Status == RPC_S_OK);

Cleanup:
    if (Status)
        {
        if (UserName) 
            delete [] UserName;
        if (FullName) 
            delete [] FullName;

        return Status ;
        }

    return RPC_S_OK;
}

LRPC_ADDRESS *LrpcAddressList = NULL;


RPC_ADDRESS *
LrpcCreateRpcAddress (
    )
/*++

Routine Description:

    We just to create a new LRPC_ADDRESS.  This routine is a proxy for the
    new constructor to isolate the other modules.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    RPC_ADDRESS * RpcAddress;

    RpcAddress = new LRPC_ADDRESS(&Status);

    if (Status != RPC_S_OK)
        {
        delete RpcAddress;
        return(0);
        }
    return(RpcAddress);
}

/*
 This private API was requested by KumarP from the LSA group on 04/05/2000.
 Here's his justification:

 I am adding a new auditing feature to LSA that will allow any local process 
 to make an rpc call to LSA and generate an arbitrary audit. To be able to 
 make this call, the clients will first issue one call to get an audit-context 
 handle from LSA. LSA will maintain a list of handles till the client 
 explicitly closes the audit-context. 

 The reason I would like to have this API is to track which processes have 
 opened audit-contexts. This will help in situations where there is a 
 rogue/mal-functioning process that opens up a large number of audit-contexts. 
 In this case, I should be able to break LSA into debugger and dump the context 
 list and know which process has opened which handles. This may optionally 
 allow me to prevent certain processes from calling this API (though currently 
 there is no such requirement).

 */
RPC_STATUS
RPC_ENTRY
I_RpcBindingInqLocalClientPID (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned long *Pid
    )
{
    LRPC_SCALL * Call;
    HANDLE LocalPid;

    InitializeIfNecessary();

    if (Binding == NULL)
        {
        Call = (LRPC_SCALL *) RpcpGetThreadContext();
        if (Call == NULL)
            return RPC_S_NO_CALL_ACTIVE;
        }
    else
        {
        Call = (LRPC_SCALL *) Binding;
        }

    if (Call->InvalidHandle(LRPC_SCALL_TYPE))
        return(RPC_S_INVALID_BINDING);

    LocalPid = Call->InqLocalClientPID();

    *Pid = HandleToUlong(LocalPid);

    return RPC_S_OK;
}

const SID AnonymousSid = { 1, 1, SECURITY_NT_AUTHORITY, SECURITY_ANONYMOUS_LOGON_RID};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\osfsvr.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    osfsvr.cxx

Abstract:

    This file contains the server side implementation of the OSF connection
    oriented RPC protocol engine.

Author:

    Michael Montague (mikemon) 17-Jul-1990

Revision History:
    Mazhar Mohammed (mazharm) 2/1/97 major rehaul to support async
    - Added support for Async RPC, Pipes
    - Changed it to operate as a state machine
    - Changed class structure
    - Got rid of the TRANS classes

    Kamen Moutafov      (kamenm)    Jan-2000    Support for multiple transfer syntaxes
    Kamen Moutafov (KamenM) Dec 99 - Feb 2000 - Support for cell debugging stuff
    Kamen Moutafov      (KamenM)    Mar-2000    Support for extended error info
--*/

#include <precomp.hxx>
#include <wincrypt.h>
#include <rpcssl.h>
#include <thrdctx.hxx>
#include <hndlsvr.hxx>
#include <osfpcket.hxx>
#include <osfsvr.hxx>
#include <sdict2.hxx>
#include <rpccfg.h>
#include <schnlsp.h>     // for UNISP_RPC_ID
#include <charconv.hxx>

extern long GroupIdCounter;

// explicit placement new operator
inline
PVOID __cdecl
operator new(
        size_t size,
        PVOID pPlacement
        )
{
        return pPlacement;
}


OSF_ADDRESS::OSF_ADDRESS (
    IN TRANS_INFO  * RpcTransInfo,
    IN OUT RPC_STATUS  * Status
    ) : RPC_ADDRESS(Status)
/*++

Routine Description:

--*/
{
    RPC_CONNECTION_TRANSPORT *RpcServerInfo =
        (RPC_CONNECTION_TRANSPORT *) RpcTransInfo->InqTransInfo();
    int i;
    RPC_STATUS OriginalFailureStatus;

    ObjectType = OSF_ADDRESS_TYPE;
    ActiveCallCount = 0;
    ServerListeningFlag = 0;
    ServerInfo = RpcServerInfo;
    TransInfo = RpcTransInfo;
    SetupAddressOccurred = 0;
    if (IsServerSideDebugInfoEnabled())
        {
        DebugCell = (DebugEndpointInfo *)AllocateCell(&DebugCellTag);
        if (DebugCell == NULL)
            {
            *Status = RPC_S_OUT_OF_MEMORY;
            }
        else
            {
            DebugCell->TypeHeader = 0;
            DebugCell->Type = dctEndpointInfo;
            DebugCell->ProtseqType = (UCHAR)RpcServerInfo->TransId;
            DebugCell->Status = desAllocated;
            memset(DebugCell->EndpointName, 0, sizeof(DebugCell->EndpointName));
            }
        }
    else
        DebugCell = NULL;

#if defined(_WIN64)
    ASSERT((MutexAllocationSize % 8) == 0);
#else
    ASSERT((MutexAllocationSize % 4) == 0);
#endif

    OriginalFailureStatus = RPC_S_OK;
    for (i = 0; i < NumberOfAssociationsDictionaries; i ++)
        {
        // explicit placement
        new (GetAssociationBucketMutex(i)) MUTEX (Status,
                                                  TRUE      // pre-allocate semaphores
                                                  );

        // if there is a failure, remember it, so that subsequent successes
        // don't overwrite the failure
        if ((*Status != RPC_S_OK) && (OriginalFailureStatus == RPC_S_OK))
            {
            OriginalFailureStatus = *Status;
            }

        // don't check the status - the constructors will
        // check it. Also, we need to invoke all constructors
        // to give them a chance to initialize enough of the
        // object so that it can be destroyed properly
        }

    if (OriginalFailureStatus != RPC_S_OK)
        *Status = OriginalFailureStatus;
}


RPC_STATUS
OSF_ADDRESS::ServerSetupAddress (
    IN RPC_CHAR * NetworkAddress,
    IN RPC_CHAR  *  *Endpoint,
    IN unsigned int PendingQueueSize,
    IN void  * SecurityDescriptor, OPTIONAL
    IN unsigned long EndpointFlags,
    IN unsigned long NICFlags
    )
/*++

Routine Description:

    At this point, we need to setup the loadable transport interface.
    We also need to obtain the network address for this server.  After
    allocating a buffer to hold the network address, we will call
    the loadable transport interface to let it do its thing.

Arguments:

    NetworkAddress - Returns the network address for this server.  The
        ownership of the buffer allocated to contain the network address
        passes to the caller.

    Endpoint - Supplies the endpoint to be used will this address.

    PendingQueueSize - Supplies the size of the queue of pending
        requests which should be created by the transport.  Some transports
        will not be able to make use of this value, while others will.

    SecurityDescriptor - Optionally supplies a security descriptor to
        be placed on this address.  Whether or not this is suppored depends
        on the particular combination of transport interface and operating
        system.

    EndpointFlags - Flags that control dynamic port allocation for IP protseqs.

    NICFlags - Flags that control network (IP) address binding for IP protseqs.

Return Value:

    RPC_S_OK - We successfully setup this address.

    RPC_S_INVALID_SECURITY_DESC - The supplied security descriptor is
        invalid.

    RPC_S_CANT_CREATE_ENDPOINT - The endpoint format is correct, but
        the endpoint can not be created.

    RPC_S_INVALID_ENDPOINT_FORMAT - The endpoint is not a valid
        endpoint for this particular transport interface.

    RPC_S_OUT_OF_RESOURCES - Insufficient resources are available to
        setup the address.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to setup
        the address.

--*/
{

    RPC_STATUS Status;

    Status = ServerInfo->Listen(InqRpcTransportAddress(),
                                            NetworkAddress,
                                            Endpoint,
                                            PendingQueueSize,
                                            SecurityDescriptor,
                                            EndpointFlags,
                                            NICFlags);

    if ( Status == RPC_S_OK )
        {
        SetupAddressOccurred = 1;
        }

    VALIDATE(Status)
        {
        RPC_S_OK,
        RPC_S_INVALID_SECURITY_DESC,
        RPC_S_INVALID_ARG,
        RPC_S_CANT_CREATE_ENDPOINT,
        RPC_S_INVALID_ENDPOINT_FORMAT,
        RPC_S_OUT_OF_RESOURCES,
        RPC_S_PROTSEQ_NOT_SUPPORTED,
        RPC_S_DUPLICATE_ENDPOINT,
        RPC_S_OUT_OF_MEMORY,
        RPC_S_SERVER_UNAVAILABLE
        }
    CORRUPTION_VALIDATE
        {
        RPC_S_PROTOCOL_ERROR,
        RPC_S_INVALID_BOUND
        } CORRUPTION_END_VALIDATE;

    return(Status);
}

#ifndef NO_PLUG_AND_PLAY

void
OSF_ADDRESS::PnpNotify (
    )
{
    ServerInfo->PnpNotify();
}
#endif


RPC_STATUS
OSF_ADDRESS::CompleteListen (
    )
/*++
Function Name:CompleteListen

Parameters:

Description:

Returns:

--*/
{
    if (ServerInfo->CompleteListen != 0)
        {
        ServerInfo->CompleteListen(InqRpcTransportAddress());
        }

    if (DebugCell)
        {
        CStackAnsi AnsiEndpoint;
        int i;
        RPC_STATUS RpcStatus;

        i = RpcpStringLength(InqEndpoint()) + 1;
        *(AnsiEndpoint.GetPAnsiString()) = (char *)_alloca(i);

        RpcStatus = AnsiEndpoint.Attach(InqEndpoint(), i, i * 2);

        // note that effectively ignore the result. That's ok - we don't
        // want servers to be unable to start because of code page issues
        // in the debug path. If this fails and we ignore it, the worse
        // that can happen is to have empty endpoint in the debug cell
        // - not a big deal.
        if (RpcStatus == RPC_S_OK)
            {
            strncpy(DebugCell->EndpointName, AnsiEndpoint, sizeof(DebugCell->EndpointName));
            }

        DebugCell->Status = desActive;
        }
    return(RPC_S_OK);
}


RPC_STATUS
OSF_ADDRESS::ServerStartingToListen (
    IN unsigned int MinimumCallThreads,
    IN unsigned int MaximumConcurrentCalls
    )
/*++

Routine Description:


Arguments:

    MinimumCallThreads - Supplies the minimum number of threads to have
        available to receive remote procedure calls.

    MaximumConcurrentCalls - Unused.

Return Value:

    RPC_S_OK - Ok, this address is all ready to start listening for
        remote procedure calls.

    RPC_S_OUT_OF_THREADS - We could not create enough threads so that we
        have least the minimum number of call threads required (as
        specified by the MinimumCallThreads argument).

--*/
{
    RPC_STATUS Status;

    UNUSED(MaximumConcurrentCalls);
    UNUSED(MinimumCallThreads);

    Status = TransInfo->StartServerIfNecessary();
    if (Status == RPC_S_OK)
        {
        ServerListeningFlag = 1;
        }

    return Status;
}



OSF_ADDRESS::~OSF_ADDRESS (
    )
/*++

Routine Description:

    We need to clean up the address after it has been partially
    initialized.  This routine will only be called before FireUpManager
    is called, but it may have been called before or after one of
    SetupAddressWithEndpoint or SetupAddressUnknownEndpoint is called.
    We will keep track of whether or not SetupAddress* occurred
    successfully; if so, we need to call AbortSetupAddress to give the
    loadable transport module a chance to clean things up.

--*/
{
    int i;
    if (SetupAddressOccurred != 0)
        ServerInfo->AbortListen(InqRpcTransportAddress());

    for (i = 0; i < NumberOfAssociationsDictionaries; i ++)
        {
        GetAssociationBucketMutex(i)->Free();
        }

    if (DebugCell != NULL)
        {
        FreeCell(DebugCell, &DebugCellTag);
        }
}


OSF_SCONNECTION *
OSF_ADDRESS::NewConnection (
   )
/*++

Routine Description:

    We will create a new connection which belongs to this address.

Arguments:

    ConnectionKey - Supplies the connection key specified for this
        connection by the loadable transport.

Return Value:

    The new connection will be returned unless insufficient memory
    is available, in which case, zero will be returned.

--*/
{
    OSF_SCONNECTION * SConnection;
    RPC_STATUS Status = RPC_S_OK;

    SConnection = new (ServerInfo->ServerConnectionSize)
                                    OSF_SCONNECTION (
                                           this,
                                           ServerInfo,
                                           &Status);

    if ( Status != RPC_S_OK )
        {
        //
        // Server serverinfo to 0, so it doesn't call close
        //
        SConnection->ServerInfo = 0;

        delete SConnection;
        SConnection = 0;
        }

    if ( SConnection == 0 )
        {
        return(0);
        }

    //
    // Add a reference for the receive that is going to be posted by the
    // transport
    //
    SConnection->AddReference(); // CONN++

    return(SConnection);
}

unsigned int
OSF_ADDRESS::TransSecondarySize (
    )
{
    unsigned int Length = RpcpStringLength(InqEndpoint()) + 1;

    // Will be converted to ANSI in the wire, no need to multiply by
    // sizeof(RPC_CHAR).

    return(Length);
}

RPC_STATUS
OSF_ADDRESS::TransSecondary (
    IN unsigned char * Address,
    IN unsigned int AddressLength
    )
{
    RPC_STATUS Status;
    unsigned char *AnsiAddress;

    AnsiAddress = UnicodeToAnsiString(InqEndpoint(),&Status);

    if (Status != RPC_S_OK)
        {
        ASSERT(Status == RPC_S_OUT_OF_MEMORY);
        ASSERT(AnsiAddress == 0);
        return Status;
        }

    RpcpMemoryCopy(Address,AnsiAddress,AddressLength);

    delete AnsiAddress;

    return (RPC_S_OK);
}


void
OSF_ADDRESS::ServerStoppedListening (
    )
/*++

Routine Description:

    We just need to indicate that the server is no longer listening, and
    set the minimum call threads to one.

--*/
{
    ServerListeningFlag = 0;
}

OSF_ASSOCIATION *
OSF_ADDRESS::RemoveAssociation (
    IN int Key,
    IN OSF_ASSOCIATION *pAssociation
    )
{
    int HashBucketNumber;
    OSF_ASSOCIATION *pAssociationRemoved;

    AddressMutex.VerifyNotOwned();

    HashBucketNumber = GetHashBucketForAssociation(pAssociation->AssocGroupId());
    // verify the the bucket is locked
    GetAssociationBucketMutex(HashBucketNumber)->VerifyOwned();

    pAssociationRemoved = Associations[HashBucketNumber].Delete(Key);

    return pAssociationRemoved;
}

int
OSF_ADDRESS::AddAssociation (
    IN OSF_ASSOCIATION * TheAssociation
    )
{
    int HashBucketNumber;
    int Key;

    HashBucketNumber = GetHashBucketForAssociation(TheAssociation->AssocGroupId());

    AddressMutex.VerifyNotOwned();

    // lock the bucket
    GetAssociationBucketMutex(HashBucketNumber)->Request();
    Key = Associations[HashBucketNumber].Insert(TheAssociation);
    // unlock the bucket
    GetAssociationBucketMutex(HashBucketNumber)->Clear();
    return Key;
}

OSF_ASSOCIATION *
OSF_ADDRESS::FindAssociation (
    IN unsigned long AssociationGroupId,
    IN RPC_CLIENT_PROCESS_IDENTIFIER * ClientProcess
    )
    // The AddressMutex has already been requested.
{
    DictionaryCursor cursor;
    OSF_ASSOCIATION * Association;
    OSF_ASSOCIATION_DICT *pAssocDict;
    int HashBucketNumber;

    // get the hashed bucket
    HashBucketNumber = GetHashBucketForAssociation(AssociationGroupId);
    pAssocDict = &Associations[HashBucketNumber];

    AddressMutex.VerifyNotOwned();

    // lock the bucket
    GetAssociationBucketMutex(HashBucketNumber)->Request();
    // lookup the association in the bucket
    pAssocDict->Reset(cursor);
    while ( (Association = pAssocDict->Next(cursor)) != 0 )
        {
        if ( Association->IsMyAssocGroupId(AssociationGroupId,
                    ClientProcess) != 0 )
            {
            Association->AddConnection();
            GetAssociationBucketMutex(HashBucketNumber)->Clear();
            return(Association);
            }
        }

    // unlock the bucket
    GetAssociationBucketMutex(HashBucketNumber)->Clear();
    return(0);
}

void
OSF_ADDRESS::DestroyContextHandlesForInterface (
    IN RPC_SERVER_INTERFACE PAPI * RpcInterfaceInformation,
    IN BOOL RundownContextHandles
    )
/*++
Function Name:  DestroyContextHandlesForInterface

Parameters:
    RpcInterfaceInformation - the interface for which context handles
        are to be unregistered
    RundownContextHandles - if non-zero, rundown the context handles. If
        FALSE, destroy the runtime portion of the context handle resource,
        but don't call the user rundown routine.

Description:
    The implementation fo context handle destruction for the connection 
    oriented protocols. It will walk the list of associations, and for
    each one it will ask the association to destroy the context handles
    for that interface

Returns:

--*/
{
    int i;
    MUTEX *CurrentBucketMutex;
    DictionaryCursor cursor;
    OSF_ASSOCIATION_DICT *CurrentAssocDict;
    OSF_ASSOCIATION *CurrentAssociation;
    BOOL CopyOfDictionaryUsed;
    OSF_ASSOCIATION_DICT AssocDictCopy;
    OSF_ASSOCIATION_DICT *AssocDictToUse;
    BOOL Res;

    // N.B. We may or we may not own the ServerMutex here - be prepared
    // for both occasions. The first implication is not to call functions
    // that take the server mutex.

    for (i = 0; i < NumberOfAssociationsDictionaries; i ++)
        {
        CurrentBucketMutex = GetAssociationBucketMutex(i);

        CurrentBucketMutex->Request();

        CurrentAssocDict = &Associations[i];
        CopyOfDictionaryUsed = AssocDictCopy.ExpandToSize(CurrentAssocDict->Size());
        if (CopyOfDictionaryUsed)
            {
            CurrentAssocDict->Reset(cursor);
            while ( (CurrentAssociation = CurrentAssocDict->Next(cursor)) != 0 )
                {
                Res = AssocDictCopy.Insert(CurrentAssociation);
                ASSERT(Res != -1);
                // artifically add a connection count to keep it alive
                // while we destroy the contexts
                CurrentAssociation->AddConnection();
                }
            CurrentBucketMutex->Clear();
            AssocDictToUse = &AssocDictCopy;
            }
        else
            {
            AssocDictToUse = CurrentAssocDict;
            }

        AssocDictToUse->Reset(cursor);
        while ( (CurrentAssociation = AssocDictToUse->Next(cursor)) != 0 )
            {
            // call into the association to destroy the context handles
            CurrentAssociation->DestroyContextHandlesForInterface(
                RpcInterfaceInformation,
                RundownContextHandles);
            }

        if (CopyOfDictionaryUsed)
            {
            while ( (CurrentAssociation = AssocDictCopy.Next(cursor)) != 0 )
                {
                // remove the extra refcounts
                CurrentAssociation->RemoveConnection();
                }
            AssocDictCopy.DeleteAll();
            }
        else
            {
            CurrentBucketMutex->Clear();
            }
        }
}

OSF_SBINDING::OSF_SBINDING ( // Constructor.
    IN RPC_INTERFACE * TheInterface,
    IN int PContext,
    IN int SelectedTransferSyntaxIndex
    )
{
    PresentContext = PContext;
    Interface = TheInterface;
    SequenceNumber = 0;
    CurrentSecId = -1;
    this->SelectedTransferSyntaxIndex = SelectedTransferSyntaxIndex;
}

inline RPC_STATUS
OSF_SBINDING::CheckSecurity(
       SCALL * Call,
       unsigned long AuthId
       )
{
    OSF_SCALL *OsfSCall = (OSF_SCALL *) Call;

    ASSERT(Call->InvalidHandle(OSF_SCALL_TYPE) == 0); 

    // This is verified by the caller.
    ASSERT (Interface->IsSecurityCallbackReqd());

    //
    // We may be able to skip a security callback.
    //
    // We skip the callback iff:
    // - the binding has executed a security callback for the interface and
    // the SequenceNumber and the AuthId have not changed since.
    // - RPC security is being used.
    //
    // Thus, the only way to skip a security callback for a given binding is to have
    // executed it previously since Interface->SequenceNumber starts at 1 and
    // OSF_SBINDING::SequenceNumber starts at 0 and the only assignment to 
    // OSF_SBINDING::SequenceNumber is below.  Because bindings can't migrate
    // among connections, this means that a given connection has executed a given
    // security callback.
    //
    if ( OsfSCall->IsSecure()
         && SequenceNumber == Interface->SequenceNumber
         && AuthId == CurrentSecId )
        {
        return (RPC_S_OK);
        }

    RPC_STATUS Status = Interface->CheckSecurityIfNecessary(Call);

    Call->RevertToSelf();

    if (Status == RPC_S_OK)
        {
        // In order to skip security callbacks in the future we need to init SequenceNumber
        // and CurrentSecId.  We will only do this if RPC security is used.
        if (OsfSCall->IsSecure())
            {
            CurrentSecId = AuthId;
            SequenceNumber = Interface->SequenceNumber;
            }
        return (RPC_S_OK);
        }
    else
        {
        SequenceNumber = 0;
        }

    return (RPC_S_ACCESS_DENIED);
}


OSF_SCALL::OSF_SCALL (
    IN OSF_SCONNECTION *Connection,
    IN OUT RPC_STATUS *Status
    ) : CallMutex(Status), SyncEvent(Status, 0)
{
    ObjectType = OSF_SCALL_TYPE;
    Thread = 0;
    CallOrphaned = 0;
    CancelPending = 0;
    SavedHeader = 0;
    SavedHeaderSize = 0;

    this->Connection = Connection;
    SendContext = (char *) this+sizeof(OSF_SCALL);
    SetReferenceCount(0);

    if (IsServerSideDebugInfoEnabled())
        {
        if (*Status != RPC_S_OK)
            {
            DebugCell = NULL;
            return;
            }

        DebugCell = (DebugCallInfo *)AllocateCell(&CellTag);
        if (DebugCell == NULL)
            *Status = RPC_S_OUT_OF_MEMORY;
        else
            {
            memset(DebugCell, 0, sizeof(DebugCallInfo));
            DebugCell->Type = dctCallInfo;
            DebugCell->Status = (BYTE)csAllocated;
            GetDebugCellIDFromDebugCell((DebugCellUnion *)Connection->DebugCell,
                &Connection->DebugCellTag, &DebugCell->Connection);
            DebugCell->LastUpdateTime = NtGetTickCount();
            // if this is the call for the connection,
            // it will be NULL. If this is a subsequent
            // call on the connection, the CachedSCall would
            // have been set already.
            if (Connection->CachedSCall == NULL)
                DebugCell->CallFlags = DBGCELL_CACHED_CALL;
            }
        }
    else
        DebugCell = NULL;

    //
    // we don't need to initialize ObjectUuidSpecified, ActualBufferLength,
    // FirstFrag and Alertcount
    //
}


OSF_SCALL::~OSF_SCALL (
    )
{
    if (SavedHeader != 0)
       {
       ASSERT(SavedHeaderSize != 0) ;
       RpcpFarFree(SavedHeader);
       }

    if (DebugCell != NULL)
        {
        FreeCell(DebugCell, &CellTag);
        }
}


void
OSF_SCALL::InquireObjectUuid (
    OUT RPC_UUID  * ObjectUuid
    )
/*++

Routine Description:

    This routine copies the object uuid from the server connection into
    the supplied ObjectUuid argument.

Arguments:

    ObjectUuid - Returns a copy of the object uuid in the server connection.

--*/
{
    if (ObjectUuidSpecified == 0)
        ObjectUuid->SetToNullUuid();
    else
        ObjectUuid->CopyUuid(&(this->ObjectUuid));
}


void
OSF_SCALL::SendFault (
    IN RPC_STATUS Status,
    IN int DidNotExecute
    )
{
    p_context_id_t p_cont = 0;

    if (CurrentBinding)
        p_cont = (p_context_id_t)CurrentBinding->GetPresentationContext();

    Connection->SendFault(Status, DidNotExecute, CallId, p_cont);
}



RPC_STATUS
OSF_SCALL::SendReceive (
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:

Arguments:

    Message - Supplies the request to send to the server and returns the
        response received from the server.

Return Value:

    RPC_S_OK - We successfully sent a remote procedure call request to the
        server and received back a response.

--*/
{
    RPC_STATUS Status, ExceptionCode;
    unsigned int RemoteFaultOccured = 0;
    RPC_MESSAGE RpcMessage ;
    RPC_RUNTIME_INFO RuntimeInfo ;
    PRPC_DISPATCH_TABLE DispatchTableToUse;

    if (CurrentState == CallAborted)
        {
        return RPC_S_CALL_FAILED;
        }

    CallStack += 1;
    Address->Server->OutgoingCallback();
    FirstFrag = 1;

    SyncEvent.Lower();

    Status = SendRequestOrResponse(Message, rpc_request);
    if (Status != RPC_S_OK)
        {
        CallStack -= 1;
        return Status;
        }

    for (;TRUE;)
        {
        if (CurrentState == CallAborted)
            {
            Status = RPC_S_CALL_FAILED;
            break;
            }
        //
        // In the callback case, when the receive event is kicked,
        // we have either received a fault or we have received a complete
        // response/request
        //
        SyncEvent.Wait();

        switch (CurrentState)
            {
            case ReceivedCallback:
                //
                // Just received a new callback,
                // need to dispatch it
                //

                RuntimeInfo.Length = sizeof(RPC_RUNTIME_INFO) ;

                RpcMessage.Handle = (RPC_BINDING_HANDLE) this;
                RpcMessage.Buffer = DispatchBuffer ;
                RpcMessage.BufferLength = DispatchBufferOffset;
                RpcMessage.RpcFlags = RPC_BUFFER_COMPLETE;
                RpcMessage.DataRepresentation = Connection->DataRep;
                RpcMessage.ReservedForRuntime = &RuntimeInfo ;
                CurrentBinding->GetSelectedTransferSyntaxAndDispatchTable(
                    &RpcMessage.TransferSyntax, &DispatchTableToUse);
                RpcMessage.ProcNum = ProcNum;


                //
                // Dispatch the callback
                //
                if ( ObjectUuidSpecified != 0 )
                    {
                    Status = CurrentBinding->GetInterface()
                                  ->DispatchToStubWithObject(
                                           &RpcMessage,
                                           &ObjectUuid,
                                           1,
                                           DispatchTableToUse,
                                           &ExceptionCode);
                    }
                else
                    {
                    Status = CurrentBinding->GetInterface()
                                ->DispatchToStub(
                                           &RpcMessage,
                                           1,
                                           DispatchTableToUse,
                                           &ExceptionCode);
                    }

                //
                // Send the reponse
                //
                if ( Status != RPC_S_OK )
                    {

                    VALIDATE(Status)
                        {
                        RPC_P_EXCEPTION_OCCURED,
                        RPC_S_PROCNUM_OUT_OF_RANGE
                        } END_VALIDATE;

                    if ( Status == RPC_S_PROCNUM_OUT_OF_RANGE )
                        {
                        SendFault(RPC_S_PROCNUM_OUT_OF_RANGE, 1);
                        }
                    else
                        {
                        SendFault(ExceptionCode, 0);
                        Status = ExceptionCode;
                        }

                    continue;
                    }

                FirstFrag = 1;
                Status = SendRequestOrResponse(&RpcMessage, rpc_response);
                if ( Status == RPC_S_CALL_FAILED_DNE )
                    {
                    Status = RPC_S_CALL_FAILED;
                    }

                //
                // if the client went away, it is wise to simple go away
                //
                if (Status != RPC_S_OK)
                    {
                    break;
                    }

                //
                // Go back to waiting for our original reply
                //
                continue;

            case ReceivedCallbackReply:
                //
                // Received a reply to our callback
                // need to return to the caller with the reply
                //
                Message->Buffer = DispatchBuffer;
                Message->BufferLength = DispatchBufferOffset;
                Message->DataRepresentation = Connection->DataRep;
                Status = RPC_S_OK;
                break;

            case ReceivedFault:
                //
                // Received a fault, fail the call / propagate status
                // code
                //
                Status = AsyncStatus;
                break;

            case CallAborted:
                //
                // Call aborted, possibly because
                //
                Status = RPC_S_CALL_FAILED;
                break;

            default:
                //
                // Something bad happened, go back to looking
                ASSERT(0);
            }
        break;
        }

    //
    // We need this so the response to the original call can be sent
    // correctly.
    //
    FirstFrag = 1;

    CallStack -= 1;

    if ( Status == RPC_S_OK )
        {
        Message->Handle = (RPC_BINDING_HANDLE) this;
        }

    return(Status);
}

RPC_STATUS
OSF_SCALL::NegotiateTransferSyntax (
    IN OUT PRPC_MESSAGE Message
    )
{
    // this can happen in the callback case only.
    // Just return the already negotiated transfer syntax
    PRPC_DISPATCH_TABLE Ignored;

    CurrentBinding->GetSelectedTransferSyntaxAndDispatchTable(&Message->TransferSyntax,
        &Ignored);

    return RPC_S_OK;
}


RPC_STATUS
OSF_SCALL::GetBuffer (
    IN OUT PRPC_MESSAGE Message,
    IN UUID *ObjectUuid
    )
{
    ULONG BufferLengthToAllocate;

    Message->Handle = (RPC_BINDING_HANDLE) this;

    if (Message->RpcFlags & RPC_BUFFER_PARTIAL &&
        Message->BufferLength < Connection->MaxFrag)
        {
        ActualBufferLength = Connection->MaxFrag ;
        }
    else
        {
        ActualBufferLength = Message->BufferLength ;
        }

    // In addition to saving space for the request (or response) header,
    // we want to save space for security information if necessary.
    BufferLengthToAllocate = ActualBufferLength
                + sizeof(rpcconn_request)
                + (2* Connection->AdditionalSpaceForSecurity);

    if (TransGetBuffer(&Message->Buffer, BufferLengthToAllocate))
        {
        ActualBufferLength = 0 ;
        RpcpErrorAddRecord(EEInfoGCRuntime, 
            RPC_S_OUT_OF_MEMORY, 
            EEInfoDLOSF_SCALL__GetBuffer10,
            BufferLengthToAllocate);
        return(RPC_S_OUT_OF_MEMORY);
        }

    Message->Buffer = (unsigned char *) Message->Buffer
            + sizeof(rpcconn_request);

    return(RPC_S_OK);
}


RPC_STATUS
OSF_SCALL::GetBufferDo (
    OUT void ** ppBuffer,
    IN unsigned int culRequiredLength,
    IN BOOL fDataValid,
    IN unsigned int DataLength,
    IN unsigned long Extra
    )
{
    void *NewBuffer;

    if (TransGetBuffer(&NewBuffer,
                       culRequiredLength + sizeof(rpcconn_request)))
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    if (fDataValid)
        {
        ASSERT(DataLength < culRequiredLength);

        NewBuffer = (unsigned char *) NewBuffer + sizeof(rpcconn_request);

        RpcpMemoryCopy(NewBuffer, *ppBuffer, DataLength);

        TransFreeBuffer((unsigned char *) *ppBuffer-sizeof(rpcconn_request));
        *ppBuffer = NewBuffer;
        }
    else
        {
        *ppBuffer = (unsigned char *) NewBuffer + sizeof(rpcconn_request);
        }

    return(RPC_S_OK);
}


void
OSF_SCALL::FreeBufferDo (
    IN void *pBuffer
    )
{
#if DBG
    if (pBuffer == DispatchBuffer)
        {
        LogEvent(SU_SCALL, EV_DELETE, this, pBuffer, 1, 1);
        }
#endif
    TransFreeBuffer((unsigned char *) pBuffer - sizeof(rpcconn_request));
}


void
OSF_SCALL::FreeBuffer (
    IN PRPC_MESSAGE Message
    )
{
    TransFreeBuffer((unsigned char *) Message->Buffer
            - sizeof(rpcconn_request));
    ActualBufferLength = 0;
}


void
OSF_SCALL::FreePipeBuffer (
    IN PRPC_MESSAGE Message
    )
{
    TransFreeBuffer((unsigned char *) Message->Buffer
            - sizeof(rpcconn_request));
}


RPC_STATUS
OSF_SCALL::ReallocPipeBuffer (
    IN PRPC_MESSAGE Message,
    IN unsigned int NewSize
    )
{
    void *TempBuffer ;
    RPC_STATUS Status ;
    unsigned int SizeToAlloc ;

    if (NewSize > ActualBufferLength)
        {
        SizeToAlloc = (NewSize > Connection->MaxFrag) ?
                        NewSize:Connection->MaxFrag ;

        Status = TransGetBuffer(&TempBuffer,
                SizeToAlloc + sizeof(rpcconn_request) + sizeof(UUID)
                + (2* Connection->AdditionalSpaceForSecurity) );
        if ( Status != RPC_S_OK )
            {
            ASSERT( Status == RPC_S_OUT_OF_MEMORY );
            return(RPC_S_OUT_OF_MEMORY);
            }

        if (ActualBufferLength > 0)
            {
            RpcpMemoryCopy((char  *) TempBuffer+sizeof(rpcconn_request),
                                        Message->Buffer, Message->BufferLength) ;
            OSF_SCALL::FreePipeBuffer(Message) ;
            }

        Message->Buffer = (char  *) TempBuffer + sizeof(rpcconn_request);
        ActualBufferLength = SizeToAlloc ;
        }

    Message->BufferLength = NewSize ;

    return (RPC_S_OK) ;
}


RPC_STATUS
OSF_SCALL::TransGetBuffer (
    OUT void  *  * Buffer,
    IN unsigned int BufferLength
    )
/*++

Routine Description:

    We need a buffer to receive data into or to put data into to be sent.
    This should be really simple, but we need to make sure that buffer we
    return is aligned on an 8 byte boundary.  The stubs make this requirement.

Arguments:

    Buffer - Returns a pointer to the buffer.

    BufferLength - Supplies the required length of the buffer in bytes.

Return Value:

    RPC_S_OK - We successfully allocated a buffer of at least the required
        size.

    RPC_S_OUT_OF_MEMORY - There is insufficient memory available to allocate
        the required buffer.

--*/
{
    void *Memory;

    //
    // The NT memory allocator returns memory which is aligned by at least
    // 8, so we dont need to worry about aligning it.
    //
    Memory = CoAllocateBuffer(BufferLength);
    if ( Memory == 0 )
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    ASSERT( IsBufferAligned(Memory) );

    *Buffer = Memory;

    return(RPC_S_OK);
}


void
OSF_SCALL::TransFreeBuffer (
    IN void  * Buffer
    )
/*++

Routine Description:

    We need to free a buffer which was allocated via TransGetBuffer.  The
    only tricky part is remembering to remove the padding before actually
    freeing the memory.

--*/
{
    CoFreeBuffer(Buffer);
}


BOOL
OSF_SCALL::BeginRpcCall (
    IN rpcconn_common * Packet,
    IN unsigned int PacketLength
    )
/*++

Routine Description:

Arguments:

    Packet - Supplies the packet we received from the connection.  Ownership
        of this buffer passes to this routine.

    PacketLength - Supplies the length of the packet in bytes.

Return Value:

    A non-zero return value indicates that the connection should not
    be placed in the receive any state; instead, the thread should just
    forget about the connection and go back to waiting for more new
    procedure calls.

--*/
{
    RPC_STATUS Status;
    unsigned long SizeofHeaderToSave = 0;
    int retval ;
    BOOL fReceivePosted;
    unsigned int HeaderSize = sizeof(rpcconn_request);
    THREAD *ThisThread;
    unsigned long AuthId;

    // We need to init the call object before we start partying on it.
    // For example, CurrentBinding has to be set in case we will be sending a fault.
    ActivateCall();

    // We shoud not receive a request before security negotiation is complete.
    // Guard against the scenario where we received the first leg but not
    // the third one.
    if (Connection->AuthContinueNeeded)
        {
        ASSERT(Connection->AdditionalSpaceForSecurity == 0);
        CORRUPTION_ASSERT(0);
        Status = RPC_S_PROTOCOL_ERROR;
        goto Cleanup;
        }

    //
    // Save the unbyteswapped header for the security related stuff
    // Especially if SECURITY is on. For Request/Resonse we save just
    // the greater of rpc_req or rpc_resp. We havent byteswapped anything..
    // but if auth_length is 0, byteswapping is irrelevant..
    //
    if (Packet->auth_length != 0)
       {
       if ((Packet->PTYPE == rpc_request) || (Packet->PTYPE == rpc_response))
            {
            SizeofHeaderToSave = sizeof(rpcconn_request);
            if ( (Packet->pfc_flags & PFC_OBJECT_UUID) != 0 )
               {
               SizeofHeaderToSave += sizeof(UUID);
               }
            }

       if (SavedHeaderSize < SizeofHeaderToSave)
          {
          if (SavedHeader != 0)
             {
             ASSERT(SavedHeaderSize != 0);
             RpcpFarFree(SavedHeader);
             }

          SavedHeader = RpcpFarAllocate(SizeofHeaderToSave);
          if (SavedHeader == 0)
             {
             Status = RPC_S_PROTOCOL_ERROR;
             goto Cleanup;
             }

          SavedHeaderSize = SizeofHeaderToSave;
          RpcpMemoryCopy(SavedHeader, Packet, SizeofHeaderToSave);
          }
        else if (SizeofHeaderToSave != 0)
          {
          RpcpMemoryCopy(SavedHeader, Packet, SizeofHeaderToSave);
          }
       }

    if (Packet->pfc_flags & PFC_PENDING_CANCEL)
        {
        // Cancels are only allowed if there is actually an active call
        // on the thread.
        // There is still a window between beginning to queue an APC and
        // the execution of the APC during which the call may go away and another may
        // come in its place, but this window is diminished.
        if (RpcpGetThreadContext() == NULL)
            {
            Status = RPC_S_NO_CALL_ACTIVE;
            goto Cleanup;
            }

        RpcCancelThread(GetCurrentThread());
        }

    Status = ValidatePacket(Packet, PacketLength);

    CallId = Packet->call_id;

    if (Status != RPC_S_OK)
        {
        ASSERT(Status == RPC_S_PROTOCOL_ERROR);
        CORRUPTION_ASSERT(0);

        //
        // It is not the first packet, so we need to send a fault instead,
        // and then we will blow the connection away.
        //
        goto Cleanup;
        }

    //
    // We need to figure out about security: do we need to put authentication
    // information into each packet, and if so, how much space should we
    // reserve.  When we allocated the buffer (see OSF_SCALL::GetBuffer)
    // we saved space for security information.  We did so we could just
    // stick the authentication information into there without having to
    // copy anything
    //

    if (Connection->AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE)
        {
        ASSERT(Connection->AdditionalSpaceForSecurity >=
               MAXIMUM_SECURITY_BLOCK_SIZE);

        MaxSecuritySize = Connection->AdditionalSpaceForSecurity
                                    - MAXIMUM_SECURITY_BLOCK_SIZE;

        if (MaxSecuritySize == sizeof(sec_trailer))
           {
           MaxSecuritySize = 0;
           }
        else
           {
           //
           // We need to arrange things so that the length of the stub data
           // is a multiple of MAXIMUM_SECURITY_BLOCK_SIZE:
           // this is a requirement of the security package.
           //
           MaximumFragmentLength -= ((MaximumFragmentLength - HeaderSize
                - MaxSecuritySize) % MAXIMUM_SECURITY_BLOCK_SIZE);
           }
        }


    ASSERT(Packet->PTYPE == rpc_request);

    CurrentBinding = Connection->LookupBinding(
                                         ((rpcconn_request *) Packet)->p_cont_id);
    if (CurrentBinding)
        {
        RPC_INTERFACE *CurrentInterface = CurrentBinding->GetInterface();

        ASSERT(CurrentState == NewRequest);

        //
        // Check the security callback on this connection
        // - If IF does not require a security callback, just dispatch
        // - If IF requires a callback and current call is insecure - send a fault
        //         and fail the call
        // - If IF requires a callback, have the binding confirm that for this id
        //         we did callback once before
        // - If we never did callback.. ever, SBinding->CheckSecurity will force
        //         a security callback
        if (CurrentInterface->IsSecurityCallbackReqd() != 0)
            {
            if (!CurrentInterface->IsAllowingUnsecureCallbacks()
                && Connection->CurrentSecurityContext == 0)
                {
                Status = RPC_S_ACCESS_DENIED;
                goto Cleanup;
                }

            if (Connection->CurrentSecurityContext != 0)
                {
                Status = Connection->CurrentSecurityContext->CheckForFailedThirdLeg();
                if (Status != RPC_S_OK)
                    {
                    goto Cleanup;
                    }

                ASSERT(Connection->CurrentSecurityContext->FullyConstructed() );

                AuthId = Connection->CurrentSecurityContext->AuthContextId;
                }
            else
                {
                // This value will be ignored in CurrentBinding->CheckSecurity if
                // Call->Connection->CurrentSecurityContext == 0.
                AuthId = 0;
                }

            ThisThread = RpcpGetThreadPointer();

            // set the current context for this thread so that the app
            // can use the security callback. We'll whack it afterwards
            // as the actual call may not get dispatched on this thread
            RpcpSetThreadContextWithThread(ThisThread, this);

            Status = CurrentBinding->CheckSecurity(this, AuthId);

            RpcpSetThreadContextWithThread(ThisThread, 0);

            if (Status != RPC_S_OK)
                {
                fSecurityFailure = 1;

                if (Packet->pfc_flags & PFC_LAST_FRAG)
                    {
                    Status = RPC_S_ACCESS_DENIED;
                    Connection->CleanupPac();
                    goto Cleanup;
                    }

                SendFault(RPC_S_ACCESS_DENIED, 1);

                Connection->TransFreeBuffer(Packet);
                return 0;
                }
            }

        if (CurrentInterface->IsPipeInterface())
            {
            fPipeCall = 1;
            if (DebugCell)
                {
                DebugCell->CallFlags |= DBGCELL_PIPE_CALL;
                }
            }

        fReceivePosted = ProcessReceivedPDU(Packet, PacketLength, 1);

        return fReceivePosted;
        }
    else
        {
        //
        // We did not find a binding, which indicates the client tried
        // to make a remote procedure call on an unknown interface.
        //
        Status = RPC_S_UNKNOWN_IF;
        }

Cleanup:
    Connection->TransFreeBuffer(Packet);

    //
    // No one else can come in until we post the next receive,
    // so it is ok to send the fault before making the call
    // available
    //
    SendFault(Status,1);

    if (Status != RPC_S_UNKNOWN_IF)
        {
        Connection->fDontFlush = (CurrentState == NewRequest);

        //
        // We are going to kill the connection, do't post another receive
        //
        fReceivePosted = 1;

        Connection->OSF_SCONNECTION::Delete();
        }
    else
        {
        fReceivePosted = 0;
        }

    //
    // If the call has not been dispatched yet, DispatchBuffer needs to be freed
    //
    ASSERT(fCallDispatched == 0);
    ASSERT(DispatchBuffer == 0);

    if (Connection->fExclusive)
        {
        DeactivateCall();
        Connection->CachedSCallAvailable = 1;
        }

    //
    // Remove the reply reference for this call
    //
    OSF_SCALL::RemoveReference();  // CALL--

    //
    // Remove the dispatch reference for this call
    //
    OSF_SCALL::RemoveReference();  // CALL--

    return fReceivePosted;
}

#define SC_CLEANUP(_status, _dne)  {Status = _status; fDNE = _dne; goto Cleanup;}


BOOL
OSF_SCALL::ProcessReceivedPDU (
    IN rpcconn_common * Packet,
    IN unsigned int PacketLength,
    IN BOOL fDispatch
    )
/*++
Function Name:ProcessReceivedPDU

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    rpcconn_request *Request = (rpcconn_request *) Packet;
    int FragmentLength = (int) PacketLength;
    unsigned char PTYPE, Flags;
    unsigned short OpNum;
    unsigned long Drep;
    int MyCallStack = CallStack;
    BOOL fDNE = 0;
    BOOL fReceivePosted = 0;
    BOOL fCallCleanedUp = FALSE;

    if (fSecurityFailure)
        {

        if (Packet->pfc_flags & PFC_LAST_FRAG)
            {
            Connection->TransFreeBuffer(Packet);
            goto Cleanup2;
            }

        Connection->TransFreeBuffer(Packet);

        return 0;
        }

    switch (Packet->PTYPE)
        {
        case rpc_request :
        case rpc_response:
            if (!fDispatch)
                {
                //
                // This must be a request or response
                // save the maximum of req/resonse size [i.e. sizeof request]
                // also, we are not saving the first frag. here .. hence
                // the approp. memory is already set aside
                //

                // SavedHeader may not be kept unless AuthLevel is above connect.
                // This is the case because MS sec providers will not use the token
                // with RPC_C_AUTHN_LEVEL_CONNECT and we will have nothing to save.
                CORRUPTION_ASSERT((Connection->AuthInfo.AuthenticationLevel == RPC_C_AUTHN_LEVEL_NONE)
                                  || (Connection->AuthInfo.AuthenticationLevel == RPC_C_AUTHN_LEVEL_CONNECT)
                                  || (SavedHeaderSize >= sizeof(rpcconn_request)));

                if (Connection->AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE)
                    {
                    // If there is a SavedHeader - populate it.
                    if (SavedHeader != NULL)
                        {
                        // If the packet has an Object UUID, make sure the saved header
                        // had one also.  If we do not, the first fragment may come without the flag
                        // and a subsequent one with the flag.  EatAuthInfoFromPacket will get confused
                        // on the second fragment thinking that the saved header contains the UUID when
                        // it does not and the buffer size will be calculated incorrectly.
                        if (Packet->pfc_flags & PFC_OBJECT_UUID)
                            {
                            if (!(((rpcconn_common *)SavedHeader)->pfc_flags & PFC_OBJECT_UUID))
                                {
                                CORRUPTION_ASSERT(0);
                                SC_CLEANUP(RPC_S_PROTOCOL_ERROR, 1);
                                }
                            ASSERT(SavedHeaderSize == sizeof(rpcconn_request) + sizeof(UUID));
                            }
                        
                        RpcpMemoryCopy(SavedHeader, Packet, sizeof(rpcconn_request));
                        }
                    else if (Connection->AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_CONNECT)
                        {
                        CORRUPTION_ASSERT(0);
                        SC_CLEANUP(RPC_S_PROTOCOL_ERROR, 1);
                        }
                    }

                Status = ValidatePacket(Packet, PacketLength);

                if (Status != RPC_S_OK )
                    {
                    CORRUPTION_ASSERT(0);
                    ASSERT(Status == RPC_S_PROTOCOL_ERROR );
                    SC_CLEANUP(Status, 1);
                    }
                }

            if (Packet->call_id != CallId)
                {
                CORRUPTION_ASSERT(0);
                SC_CLEANUP(RPC_S_PROTOCOL_ERROR, 0);
                }

            Flags = Request->common.pfc_flags;
            Drep = *((unsigned long  *) Request->common.drep);
            OpNum = Request->opnum;
            PTYPE=Request->common.PTYPE;

            Status = Connection->EatAuthInfoFromPacket(
                                Request,
                                &FragmentLength,
                                &SavedHeader,
                                &SavedHeaderSize);
            if (Status != RPC_S_OK )
                {
                VALIDATE(Status)
                    {
                    RPC_S_PROTOCOL_ERROR,
                    ERROR_SHUTDOWN_IN_PROGRESS,
                    RPC_S_ACCESS_DENIED,
                    ERROR_PASSWORD_MUST_CHANGE,
                    ERROR_PASSWORD_EXPIRED,
                    ERROR_ACCOUNT_DISABLED,
                    ERROR_INVALID_LOGON_HOURS
                    } END_VALIDATE;

                fSecurityFailure = 1;

                if (Packet->pfc_flags & PFC_LAST_FRAG
                    || (Status == RPC_S_PROTOCOL_ERROR))
                    {
                    SC_CLEANUP(Status, 0);
                    }

                SendFault(RPC_S_ACCESS_DENIED, 1);

                Connection->TransFreeBuffer(Packet);
                return 0;
                }

            //
            // Ok, if the packet contains an object uuid, we need to shift
            // the stub data so that the packet does not contain an object
            // uuid.
            //
            if ((Flags & PFC_OBJECT_UUID) != 0)
                {
                if (CallStack != 0 )
                    {
                    //
                    // There can not be an object uuid in the message.
                    // This is an error.
                    //
                    CORRUPTION_ASSERT(0);
                    SC_CLEANUP(RPC_S_PROTOCOL_ERROR, 0);
                    }

                //
                // First save away the object UUID so that we can get it later.
                //
                ObjectUuidSpecified = 1;
                RpcpMemoryCopy(&ObjectUuid, Request + 1, sizeof(UUID));
                if (DataConvertEndian(((unsigned char *) &Drep)) != 0 )
                    {
                    ByteSwapUuid(&ObjectUuid);
                    }


                //
                // Now shift the stub data so that the packet is as if there is
                // no object UUID in the packet.
                //
                RpcpMemoryCopy(Request + 1,
                               ((unsigned char  *) (Request + 1))
                               + sizeof(UUID), FragmentLength);
                }


            //
            // Received the first fragment of a call.
            //
            if (Flags & PFC_FIRST_FRAG)
                {
                //
                // Optimize for the single PDU RPC case
                //
                if ((Flags & PFC_LAST_FRAG) != 0)
                    {
                    CurrentState = CallCompleted;
                    DispatchBuffer = (void  *) (Request+1);
                    DispatchBufferOffset = FragmentLength;

                    //
                    // Buffers will be freed by callee
                    //
                    ASSERT(Status == RPC_S_OK);
                    return DispatchRPCCall (PTYPE, OpNum);
                    }

                if (Request->alloc_hint)
                    {
                    // We will compare AllocHint against the interface's MaxRpcSize
                    // before we are about to allocate memory.  The default bound is
                    // gMaxRpcSize so even if the user hasn't specified a max size we
                    // are safe with taking this off the wire.
                    AllocHint = Request->alloc_hint;
                    }
                else
                    {
                    // FragmentLength can be at most MAX_USHORT since it comes from the
                    // frag_length field which is unsigned short - we don't have to worry.
                    AllocHint = FragmentLength;
                    }

                // Check the expected call size. Note that we check it on first frag
                // only. If they decrease it, we don't care. We will recheck
                // it in all paths below if caller icnreases it.
                if (CurrentBinding->GetInterface()->CallSizeLimitReached(AllocHint))
                    {
                    fSecurityFailure = 1;

                    SendFault(RPC_S_ACCESS_DENIED, 1);

                    Connection->TransFreeBuffer(Packet);
                    return 0;
                    }

                DispatchBufferOffset = 0;

                Status = GetBufferDo(&DispatchBuffer, AllocHint);
                if (Status != RPC_S_OK)
                    {
                    SC_CLEANUP(RPC_S_OUT_OF_MEMORY, 0);
                    }
                }
            //
            // Received an intermediate fragment of a call.
            //
            else
                {
                if (DispatchBuffer == 0)
                    {
                    //
                    // Looks like it is the first fragment on the call, and it doesn't have
                    // the first-frag bit set
                    //
                    CORRUPTION_ASSERT(0);
                    SC_CLEANUP(RPC_S_PROTOCOL_ERROR, 0);
                    }
                }

            if (fPipeCall == 0 || CallStack)
                {
                //
                // Non-pipe case
                //
                if (DispatchBufferOffset+FragmentLength > AllocHint)
                    {
                    // If we re-allocate the buffer for an active callback we
                    // will free the dispatch buffer from under a dispatched call.
                    // Prohibit it for the lack of better ideas.
                    if (CallStack)
                        {
                        CORRUPTION_ASSERT(0 && "Re-allocating the dispatch buffer in a callback.");
                        SC_CLEANUP(RPC_S_PROTOCOL_ERROR, 0);
                        }

                    AllocHint = DispatchBufferOffset + FragmentLength;

                    if (CurrentBinding->GetInterface()->
                        CallSizeLimitReached(AllocHint))
                        {
                        fSecurityFailure = 1;

                        if (Packet->pfc_flags & PFC_LAST_FRAG)
                            {
                            SC_CLEANUP(RPC_S_ACCESS_DENIED, 0);
                            }

                        SendFault(RPC_S_ACCESS_DENIED, 1);

                        Connection->TransFreeBuffer(Packet);
                        return 0;
                        }

                    Status = GetBufferDo(
                                         &DispatchBuffer,
                                         AllocHint,
                                         1,
                                         DispatchBufferOffset);
                    if (Status != RPC_S_OK)
                        {
                        SC_CLEANUP(RPC_S_OUT_OF_MEMORY, 0);
                        }
                    }

                //
                // Copy current buffer into the dispatch buffer
                //
                RpcpMemoryCopy(
                               (char *) DispatchBuffer+DispatchBufferOffset,
                               Request+1,
                               FragmentLength);
                DispatchBufferOffset += FragmentLength;
                Connection->TransFreeBuffer(Packet);

                if (Flags & PFC_LAST_FRAG)
                    {
                    CurrentState = CallCompleted;

                    //
                    // Buffers will be freed by callee
                    //
                    ASSERT(Status == RPC_S_OK);

                    return DispatchRPCCall (PTYPE, OpNum);
                    }
                }
            else
                {
                //
                // Pipe call
                //
                if (PTYPE != rpc_request)
                    {
                    CORRUPTION_ASSERT(0);
                    SC_CLEANUP(RPC_S_PROTOCOL_ERROR, 0);
                    }

                //
                // If it is a pipe call, we need to dispatch as soon as we get
                // at least alloc hint bytes. If it is not a pipe call, we wait until
                // we get the last fragment.
                //
                if (!fCallDispatched)
                    {
                    if (DispatchBufferOffset+FragmentLength > AllocHint)
                        {
                        AllocHint = DispatchBufferOffset + FragmentLength;

                        if (CurrentBinding->GetInterface()->
                            CallSizeLimitReached(AllocHint))
                            {
                            fSecurityFailure = 1;

                            if (Packet->pfc_flags & PFC_LAST_FRAG)
                                {
                                SC_CLEANUP(RPC_S_ACCESS_DENIED, 0);
                                }

                            SendFault(RPC_S_ACCESS_DENIED, 1);

                            Connection->TransFreeBuffer(Packet);
                            return 0;
                            }

                        Status = GetBufferDo(
                                         &DispatchBuffer,
                                         AllocHint,
                                         1,
                                         DispatchBufferOffset);
                        if (Status != RPC_S_OK)
                            {
                            SC_CLEANUP(Status, 0);
                            }
                        }
                    //
                    // Copy the buffer in
                    //
                    RpcpMemoryCopy(
                               (char *) DispatchBuffer+DispatchBufferOffset,
                               Request+1,
                               FragmentLength);

                    DispatchBufferOffset += FragmentLength;

                    Connection->TransFreeBuffer(Packet);

                    ASSERT(Status == RPC_S_OK);

                    if (DispatchBufferOffset == AllocHint)
                        {
                        ASSERT(fSecurityFailure == 0);

                        if (Flags & PFC_LAST_FRAG)
                            {
                            CurrentState = CallCompleted;
                            }
                        else
                            {
                            //
                            // Buffers will be freed by callee
                            //
                            DispatchFlags = 0;
                            }

                        return DispatchRPCCall (PTYPE, OpNum);
                        }
                    }
                else
                    {
                    //
                    // Once a pipe call is dispatched, we don't care about how
                    // big it gets. The manager routine has the option to abandon
                    // the call whenever it wants.
                    //
                    CallMutex.Request();

                    if ((Connection->fExclusive)
                        && (Connection->CachedSCallAvailable))
                        {
                        CallMutex.Clear();
                        ASSERT (Connection->CachedSCall == this);
                        Connection->TransFreeBuffer(Packet);
                        return 0;
                        }
                    //
                    // A pipe call is already in progress. We simply need to queue
                    // the buffer into the buffer queue. It get picked up later.
                    //
                    LogEvent(SU_SCALL, EV_BUFFER_IN, Request, this, 0, 1, 0);
                    if (BufferQueue.PutOnQueue(Request+1, FragmentLength))
                        {
                        CallMutex.Clear();
                        SC_CLEANUP(RPC_S_OUT_OF_MEMORY, 0);
                        }
                    RcvBufferLength += FragmentLength;

                    if ((Flags & PFC_LAST_FRAG) != 0)
                        {
                        CurrentState = CallCompleted;
                        }

                    if (pAsync == 0)
                        {
                        if (BufferQueue.Size() >= 4
                            && Connection->fExclusive
                            && CurrentState != CallCompleted)
                            {
                            fPeerChoked = 1;
                            fReceivePosted = 1;
                            }

                        CallMutex.Clear();
                        SyncEvent.Raise();
                        }
                    else
                        {
                        // Issue receive-complete notification if we have enough data
                        // to satisfy the NeededLength requirement.
                        // If this is the last receive, issue notification no matter what,
                        // since we need to wake up the sleeping receive thread.
                        if (NeededLength > 0 &&
                            ((RcvBufferLength >= NeededLength) || (CurrentState == CallCompleted)))
                            {
                            // Disarm the notificaiton.
                            NeededLength = 0;
                    
                            IssueNotification(RpcReceiveComplete);
                            }
                        else
                            {
                            //
                            // Cannot do this for non-exclusive connections because
                            // other calls will get blocked
                            //
                            if (BufferQueue.Size() >= 4
                                && Connection->fExclusive
                                && CurrentState != CallCompleted)
                                {
                                fPeerChoked = 1;
                                fReceivePosted = 1;
                                }
                            }
                        CallMutex.Clear();
                        }

                    //
                    // We received pipe data
                    // there's nothing to cleanup
                    //
                    return fReceivePosted;
                    }
                }

            return 0;

        case rpc_fault:
            Status = ((rpcconn_fault  *)Packet)->status;

            if ((Status == 0) &&
                (Packet->frag_length >= FaultSizeWithoutEEInfo + 4))
                {
                //
                // DCE 1.0.x style fault status:
                // Zero status and stub data contains the fault.
                //
                Status = *(unsigned long  *) ((unsigned char *)Packet + FaultSizeWithoutEEInfo);
                }

            if (DataConvertEndian(Packet->drep) != 0)
                {
                Status = RpcpByteSwapLong(Status);
                }

            if (Status == 0)
                {
                Status = RPC_S_CALL_FAILED;
                }

            AsyncStatus = MapFromNcaStatusCode(Status);
            CurrentState = ReceivedFault;

            SyncEvent.Raise();

            Connection->TransFreeBuffer(Packet);
            return 0;

        case rpc_cancel:
        case rpc_orphaned:
            CancelPending = 1;

            Connection->TransFreeBuffer(Packet);
            return 0;

        default :
            //
            // We should never reach here
            //
            CORRUPTION_ASSERT(0);
            SC_CLEANUP(RPC_S_PROTOCOL_ERROR, 0);
            break;
        }


Cleanup:
    //
    // If we reach here it means that the call failed
    // Every call to ProcessReceivedPDU has a reference on the call,
    // the call is alive here
    //
    ASSERT(Status != RPC_S_OK);

    Connection->TransFreeBuffer(Packet);
    if ((MyCallStack == 0) && (fCallDispatched == 0))
        {
        CleanupCallAndSendFault(Status, 0);
        fCallCleanedUp = TRUE;
        }
    else
        {
        SendFault(Status, 0);
        }

Cleanup2:

    //
    // There is a chance that this error happened due to a bogus packet
    // We need to make sure that we don't something bad in that case
    //
    if (MyCallStack == 0)
        {
        if (fCallDispatched == 0)
            {
            if (fCallCleanedUp == FALSE)
                CleanupCall();

            //
            // We cannot continue to use this connection
            //
            Connection->fDontFlush = (CurrentState == NewRequest);
            Connection->OSF_SCONNECTION::Delete();

            //
            // Remove the reference held by the dispatch
            // thread
            //
            OSF_SCALL::RemoveReference(); // CALL--

            //
            // We just finished sending the reply (the fault)
            // remove the reply reference
            //
            OSF_SCALL::RemoveReference(); // CALL--
            }
        else
            {
            //
            // The call will go away when the dispatch completes
            //
            Connection->OSF_SCONNECTION::Delete();
            }

        return 1;
        }

    return 0;
}


RPC_STATUS
OSF_SCALL::Receive (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned int Size
    )
/*++
Function Name:Receive

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    BOOL fForceExtra = FALSE;

    if (!EXTRA(Message) && Message->Buffer)
        {
        ASSERT(Message->Buffer != DispatchBuffer);

        FreeBufferDo((char  *)Message->Buffer);
        Message->Buffer = 0;
        Message->BufferLength = 0;
        }

    if (fSecurityFailure)
        {
        return RPC_S_ACCESS_DENIED;
        }

    Message->DataRepresentation = Connection->DataRep;

    while (TRUE)
        {
        switch (CurrentState)
            {
            case CallCompleted:
                //
                // When the last frag is received on this call, the call state
                // transitions to the Complete state. The call states are valid
                // only when using Async and Pipes
                //
                Status = GetCoalescedBuffer(Message, fForceExtra);
                break;

            case CallCancelled:
                Status = RPC_S_CALL_CANCELLED;
                break;

            case CallAborted:
                ASSERT(AsyncStatus != RPC_S_OK);
                Status = AsyncStatus;
                break;

            default:
                if (RcvBufferLength > Connection->MaxFrag)
                    {
                    Status = GetCoalescedBuffer(Message, fForceExtra);

                    if (Status != RPC_S_OK)
                        {
                        break;
                        }

                    if (PARTIAL(Message) && Message->BufferLength >= Size)
                        {
                        break;
                        }

                    fForceExtra = TRUE;
                    }
                else
                    {
                    //
                    // the call is not yet complete, wait for it.
                    //
                    SyncEvent.Wait();
                    }
                continue;
            }
        break;
        }

    return Status;
}



RPC_STATUS
OSF_SCALL::AsyncReceive (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned int Size
    )
/*++
Function Name:AsyncReceive

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status ;
    int Extra = IsExtraMessage(Message);

    ASSERT(EXTRA(Message) == 0 && PARTIAL(Message));

    if (Message->Buffer)
        {
        ASSERT(Message->Buffer != DispatchBuffer);

        FreeBufferDo((char  *)Message->Buffer);
        Message->Buffer = 0;
        }

    if (fSecurityFailure)
        {
        return RPC_S_ACCESS_DENIED;
        }

    switch (CurrentState)
        {
        case CallCompleted:
            Status = GetCoalescedBuffer(Message, FALSE);
            Message->DataRepresentation = Connection->DataRep;
            break;

        case CallCancelled:
            Status = RPC_S_CALL_CANCELLED;
            break;

        case CallAborted:
            Status = AsyncStatus;
            break;

        default:
            CallMutex.Request();
            if (RcvBufferLength < Size)
                {
                if (NOTIFY(Message))
                    {
                    NeededLength = Size ;
                    }
                CallMutex.Clear() ;

                return RPC_S_ASYNC_CALL_PENDING;
                }
            else
                {
                Status = GetCoalescedBuffer(Message, FALSE);
                Message->DataRepresentation = Connection->DataRep;
                }
            CallMutex.Clear();
            break;
        }

    return Status ;
}

RPC_STATUS
OSF_SCALL::SetAsyncHandle (
    IN PRPC_ASYNC_STATE pAsync
    )
/*++
Function Name:SetAsyncHandle

Parameters:

Description:

Returns:

--*/
{
    RPC_INTERFACE *CurrentInterface;

    this->pAsync = pAsync;
    Thread->fAsync = TRUE;

    fAsyncPipeCall = DoesAsyncCallHavePipe((char *)pAsync);

    // if we are unmarshalling, we must have a binding
    ASSERT(CurrentBinding != NULL);

    // make sure this is called on the dispatch thread
    ASSERT(Thread->Context == this);

    CurrentInterface = CurrentBinding->GetInterface();

    ASSERT(CurrentInterface);

    // add one extra refcount on the interface for the dispatch thread.
    // We will remove it in DispatchHelper. The extra refcount is a solution
    // for a race that occurs in some COM scenarios when the call is async,
    // as we remove the refcount on the interface in CleanupCall for async calls
    // on exclusive connections. The extra refcount ensures the call still holds
    // a refcount on the interface until the manager routine returns to the
    // dispatching thread
    CurrentInterface->BeginNullManagerCall();

    if (CurrentInterface->IsAutoListenInterface())
        {
        CurrentInterface->BeginAutoListenCall();
        }

    if (DebugCell)
        {
        DebugCell->CallFlags |= DBGCELL_ASYNC_CALL;
        }

    return RPC_S_OK;
}

RPC_STATUS
OSF_SCALL::AbortAsyncCall (
    IN PRPC_ASYNC_STATE pAsync,
    IN unsigned long ExceptionCode
    )
/*++
Function Name:AbortAsyncCall

Parameters:

Description:

Returns:

--*/
{
    ASSERT(CurrentBinding);

    CleanupCallAndSendFault(ExceptionCode, 0);

    //
    // The call was aborted asynchronously
    // Remove the reference held for the reply.
    //
    RemoveReference(); // CALL--

    return RPC_S_OK;
}


RPC_STATUS
OSF_SCALL::GetCoalescedBuffer (
    IN PRPC_MESSAGE Message,
    BOOL fForceExtra
    )
/*++
Function Name:GetCoalescedBuffer

Parameters:
    Message - the message structure that will receive the params

Description:
    This routine will coalesce the buffers in the buffer queue into a single
    buffer and return it in the Message structure. If the RPC_BUFFER_EXTRA
    flag is set, the data is appended to the existing buffer in Message->Buffer.

Returns:
    RPC_S_OK - the function was successful in doing its job
    RPC_S_OUT_OF_MEMORY - ran out of memory.
--*/
{
    char *Current;
    UINT bufferlength;
    UINT TotalLength;
    RPC_STATUS Status;
    void *NewBuffer, *Buffer;
    int Extra = IsExtraMessage(Message);
    BOOL fExtendedExtra = Extra | fForceExtra;
    BOOL fSubmitReceive = 0;

    CallMutex.Request();
    if (RcvBufferLength == 0)
        {
        CallMutex.Clear();
        return RPC_S_OK;
        }

    if (fExtendedExtra)
        {
        TotalLength = RcvBufferLength + Message->BufferLength;
        }
    else
        {
        TotalLength = RcvBufferLength;
        }

    Status = TransGetBuffer (&NewBuffer,
                             TotalLength+sizeof(rpcconn_request));
    if (Status != RPC_S_OK)
        {
        CallMutex.Clear();
        return RPC_S_OUT_OF_MEMORY;
        }

    NewBuffer = (char *) NewBuffer+sizeof(rpcconn_request);

    if (fExtendedExtra && Message->Buffer)
        {

        RpcpMemoryCopy(NewBuffer, Message->Buffer, Message->BufferLength);
        Current = (char *) NewBuffer + Message->BufferLength;

        Connection->TransFreeBuffer((char *) Message->Buffer-sizeof(rpcconn_request));

        if (Extra)
            {
            //
            // Update the dispatch buffer, but only for the true EXTRA flag, not
            // for the forced extra
            //
            ASSERT(Message->ReservedForRuntime) ;
            ((PRPC_RUNTIME_INFO)Message->ReservedForRuntime)->OldBuffer = NewBuffer;

            if ((CallStack == 0) && (Message->Buffer == DispatchBuffer))
                DispatchBuffer = NewBuffer;
            }
        }
    else
        {
        Current = (char *) NewBuffer;
        }

    while ((Buffer = BufferQueue.TakeOffQueue(&bufferlength)) != 0)
        {
        RpcpMemoryCopy(Current, Buffer, bufferlength);
        Current += bufferlength;

        Connection->TransFreeBuffer((char *) Buffer-sizeof(rpcconn_request));
        }

    Message->Buffer = NewBuffer;
    Message->BufferLength = TotalLength;

    RcvBufferLength = 0;

    if (CurrentState == CallCompleted)
        {
        Message->RpcFlags |= RPC_BUFFER_COMPLETE;
        }

    if (fPeerChoked)
        {
        fSubmitReceive = 1;
        fPeerChoked = 0;
        }
    CallMutex.Clear();

    if (fSubmitReceive)
        {
        Connection->TransAsyncReceive();
        }

    return RPC_S_OK;
}


void
OSF_SCALL::DispatchHelper ()
{
    THREAD *MyThread;
    RPC_STATUS Status, ExceptionCode;
    DebugCallInfo *Cell;
    DebugThreadInfo *ThreadCell;
    ULONG TickCount;
    PRPC_DISPATCH_TABLE DispatchTableToUse;
    RPC_INTERFACE *CurrentInterface;

    CurrentInterface = CurrentBinding->GetInterface();
    //
    // We have a new RPC call. We need to dispatch it.
    //
    FirstCallRuntimeInfo.Length = sizeof(RPC_RUNTIME_INFO) ;

    FirstCallRpcMessage.Handle = (RPC_BINDING_HANDLE) this;
    FirstCallRpcMessage.Buffer = DispatchBuffer;
    FirstCallRpcMessage.BufferLength = DispatchBufferOffset;
    FirstCallRpcMessage.RpcFlags = DispatchFlags ;
    FirstCallRpcMessage.DataRepresentation = Connection->DataRep;
    FirstCallRpcMessage.ReservedForRuntime = &FirstCallRuntimeInfo ;
    CurrentBinding->GetSelectedTransferSyntaxAndDispatchTable(&FirstCallRpcMessage.TransferSyntax,
        &DispatchTableToUse);
    FirstCallRpcMessage.ProcNum = ProcNum;

    MyThread = (THREAD *) RpcpGetThreadPointer();
    ASSERT(MyThread);

    RpcpSetThreadContextWithThread(MyThread, this);

    Thread = MyThread;

    ThreadCell = Thread->DebugCell;

    if (ThreadCell)
        {
        TickCount = NtGetTickCount();
        Cell = DebugCell;
        Cell->CallID = CallId;
        Cell->ProcNum = (unsigned short)ProcNum;
        Cell->Status = csDispatched;
        Cell->LastUpdateTime = TickCount;
        Cell->InterfaceUUIDStart = CurrentInterface->GetInterfaceFirstDWORD();
        ThreadCell->Status = dtsDispatched;
        ThreadCell->LastUpdateTime = TickCount;
        GetDebugCellIDFromDebugCell((DebugCellUnion *)ThreadCell, &MyThread->DebugCellTag, &Cell->ServicingTID);
        }

    //
    // Actually dispatch the RPC call
    //
    if ( ObjectUuidSpecified != 0 )
        {
        Status = CurrentInterface->DispatchToStubWithObject(
                                    &FirstCallRpcMessage,
                                    &ObjectUuid,
                                    0,
                                    DispatchTableToUse,
                                    &ExceptionCode);
        }
    else
        {
        Status = CurrentInterface->DispatchToStub(
                                    &FirstCallRpcMessage,
                                    0,
                                    DispatchTableToUse,
                                    &ExceptionCode);
        }

    //
    // We need to insure that the server thread stops impersonating
    // the client at the end of the call, so we go ahead and call
    // RevertToSelf, and dont worry about the return value.
    //

    OSF_SCALL::RevertToSelf();

    if (ThreadCell)
        {
        ThreadCell->Status = dtsProcessing;
        ThreadCell->LastUpdateTime = NtGetTickCount();
        }

   if(Status != RPC_S_OK)
       {
       //Thread = 0;

       VALIDATE(Status)
           {
           RPC_S_PROCNUM_OUT_OF_RANGE,
           RPC_S_UNKNOWN_IF,
           RPC_S_NOT_LISTENING,
           RPC_S_SERVER_TOO_BUSY,
           RPC_S_UNSUPPORTED_TYPE,
           RPC_P_EXCEPTION_OCCURED
           } END_VALIDATE;

       BOOL fDNE = 1;

       if( Status == RPC_P_EXCEPTION_OCCURED )
           {
           fDNE=0;
           Status = ExceptionCode;
           }
       else if ( Status == RPC_S_NOT_LISTENING )
           {
           Status = RPC_S_SERVER_TOO_BUSY;
           }

       while (CurrentBufferLength)
           {
           #if DBG
           PrintToDebugger("RPC: Waiting for the async send....\n");
           #endif
           Sleep(200);
           }

       //
       // There may be another thread still sending data on this call
       // This will be taken care of in CleanupCall
       //
       CleanupCallAndSendFault(Status, fDNE);

       // It is tempting to think that since an exception was 
       // raised, there will be no reply. However, in the pipe
       // case we may make a bunch of sends, and still get
       // an exception in the end. If there were no sends,
       // remove the reply reference for the call
       if (FirstSend)
           {
           OSF_SCALL::RemoveReference(); // CALL--
           }

       goto Cleanup;
       }

    if (MyThread->IsSyncCall())
        {
        ASSERT( FirstCallRpcMessage.Buffer != 0 );

        if ( CallOrphaned )
            {
            CallOrphaned = 0;
            Thread = 0;

            //
            // clear cancel if thread didn\'t notice it.
            //
            TestCancel();
            goto Cleanup;
            }

        FirstCallRpcMessage.RpcFlags = 0;
        OSF_SCALL::Send(&FirstCallRpcMessage);
        }

Cleanup:
    RpcpSetThreadContextWithThread(MyThread, 0);
}


BOOL
OSF_SCALL::DispatchRPCCall (
    IN unsigned char PTYPE,
    IN unsigned short OpNum
    )
/*++

Routine Description:
    Dispatch an new RPC call, or wake up thread that will dispatch a callback.

Arguments:

    Packet - Supplies the packet we received from the connection.  Ownership
        of this buffer passes to this routine.

    PacketLength - Supplies the length of the packet in bytes.

Return Value:

    A non-zero return value indicates that the connection should not
    be placed in the receive any state; instead, the thread should just
    forget about the connection and go back to waiting for more new
    procedure calls.

--*/
{
    RPC_STATUS Status;
    BOOL fNeedToSendFault;
    OSF_SCONNECTION *LocalConnection;

    if (CallStack > 0)
        {
        //
        // This is a callback request/response. We just need to signal the Event
        // and have it pick up the call
        //
        if (PTYPE == rpc_request)
            {
            CurrentState = ReceivedCallback;
            ProcNum = OpNum;
            }
        else
            {
            CurrentState = ReceivedCallbackReply;
            }

        SyncEvent.Raise();
        return 0;
        }

    ProcNum = OpNum;
    fCallDispatched = 1;

    if (Connection->fExclusive == 0 && Connection->MaybeQueueThisCall(this))
        {
        //
        // We don't get to dispatch right now, looks like another call is
        // currently dispatched. When the current call is done, it will do the
        // right thing
        //

        return 0;
        }

    fNeedToSendFault = FALSE;

    //
    // Looks like we are really going to dispatch a call
    // kick off another thread to go and pick up more requests
    //
    Status = Address->CreateThread();
    if (Status == RPC_S_OK)
        {
        //
        // Post another receive
        //
        Status = Connection->TransAsyncReceive();
        }
    else
        {
        Status = RPC_S_OUT_OF_MEMORY;
        fNeedToSendFault = TRUE;
        }

    if (Status != RPC_S_OK)
        {
        FreeBufferDo(DispatchBuffer);

        if (fNeedToSendFault)
            CleanupCallAndSendFault(Status, 0);
        else
            CleanupCall();

        if (Connection->fExclusive == 0)
            {
            //
            // By the time we get here, calls may have piled up
            //
            Connection->AbortQueuedCalls();
            }

        //
        // We cannot continue to use this connection
        //
        Connection->fDontFlush = (CurrentState == NewRequest);
        Connection->Delete();

        //
        // Remove the reply reference
        //
        RemoveReference(); // CALL--

        //
        // Remove the dispatch reference
        //
        RemoveReference(); // CALL--

        return 1;
        }

    // the call may have been cleaned up after this (though not
    // destroyed) - save the connection in a local variable
    LocalConnection = Connection;

    //
    // Dispatch the current call
    //
    DispatchHelper();

    if (LocalConnection->fExclusive == 0)
        {
        LocalConnection->DispatchQueuedCalls();
        }

    //
    // Remove the dispatch reference
    //
    RemoveReference();  // CALL--

    return 1;
}


RPC_STATUS
OSF_SCALL::SendNextFragment (
    void
    )
/*++
Function Name:SendNextFragment

Description:
    Send the next response fragment

Returns:

--*/
{
    RPC_STATUS Status;
    RPC_STATUS RpcStatus2;
    rpcconn_common  * pFragment;
    BOOL LastFragmentFlag;
    ULONG PacketLength;
    ULONG MaxDataLength = MaximumFragmentLength
        - sizeof(rpcconn_response) - MaxSecuritySize;
    unsigned char *ReservedForSecurity = (unsigned char *) CurrentBuffer
        + CurrentOffset + CurrentBufferLength
        + Connection->AdditionalSpaceForSecurity;

    pFragment = (rpcconn_common *)
                ((char *) CurrentBuffer+CurrentOffset-sizeof(rpcconn_response));

    if (CurrentBuffer == LastBuffer
        && CurrentBufferLength <= MaxDataLength)
        {
        LastFragmentFlag = 1;
        PacketLength = CurrentBufferLength;
        }
    else
        {
        //
        // Each outstanding send needs to hold a reference
        // on the call. Since the call holds a reference
        // on the connection. The connection will also be alive
        //
        AddReference(); // CALL++

        LastFragmentFlag = 0;
        PacketLength = MaxDataLength;
        }

    ConstructPacket(pFragment, rpc_response,
                    PacketLength+sizeof(rpcconn_response)+MaxSecuritySize);

    if (FirstSend)
        {
        FirstSend = 0;
        pFragment->pfc_flags |= PFC_FIRST_FRAG;
        }

    ((rpcconn_response  *) pFragment)->alloc_hint = CurrentBufferLength;
    ((rpcconn_response  *) pFragment)->p_cont_id = (unsigned char) CurrentBinding->GetPresentationContext();
    ((rpcconn_response  *) pFragment)->alert_count = (unsigned char) 0;
    ((rpcconn_response  *) pFragment)->reserved = 0;
    pFragment->call_id = CallId;

    LogEvent(SU_SCALL, EV_BUFFER_OUT, this, pFragment, LastFragmentFlag, 1);

    if (LastFragmentFlag)
        {
        char *BufferToFree = (char *) CurrentBuffer-sizeof(rpcconn_response);
        int MyMaxFrag = MaximumFragmentLength;
        int MyMaxSec = MaxSecuritySize;

        CurrentBufferLength = 0;

        CleanupCall();

        if (Connection->IsHttpTransport())
            {
            RpcStatus2 = Connection->SetLastBufferToFree (BufferToFree);
            VALIDATE(RpcStatus2)
                {
                RPC_S_OK,
                RPC_S_CANNOT_SUPPORT
                } END_VALIDATE;

            // if the transport does not support SetLastBufferToFree, it will
            // return RPC_S_CANNOT_SUPPORT. In this case we retain ownership of
            // the buffer.
            }

        //
        // The call should still be alive at this point because the caller
        // of this function has not release the send reference
        //
        Status = Connection->SendFragment(
                         pFragment,
                         LastFragmentFlag,
                         sizeof(rpcconn_response),
                         MyMaxSec,
                         PacketLength,
                         MyMaxFrag,
                         ReservedForSecurity);

        //
        // Last send always succeeds
        //
        Status = RPC_S_OK;

        if ((Connection->IsHttpTransport() == FALSE) || (RpcStatus2 != RPC_S_OK))
            Connection->TransFreeBuffer(BufferToFree);
        }
    else
        {
        Status = Connection->SendFragment(
                         pFragment,
                         LastFragmentFlag,
                         sizeof(rpcconn_response),
                         MaxSecuritySize,
                         PacketLength,
                         MaximumFragmentLength,
                         ReservedForSecurity,
                         TRUE,
                         SendContext) ;

        if (Status != RPC_S_OK)
            {
            CurrentBufferLength = 0;

            //
            // Remove the reference for the outstanding send
            //
            OSF_SCALL::RemoveReference(); // CALL--
            }
        }


    return Status;
}



RPC_STATUS
OSF_SCALL::Send (
    IN OUT PRPC_MESSAGE Message
    )
/*++
Routine Description:
    

Arguments:
    Message - Supplies the buffer containing the response to be sent
--*/
{
    void *NewBuffer;
    int RemainingLength = 0;
    RPC_STATUS Status = RPC_S_OK;
    RPC_STATUS StatusToReturn = RPC_S_OK;
    ULONG MaxDataLength = MaximumFragmentLength
                            - sizeof(rpcconn_response) - MaxSecuritySize;
    BOOL fOutstandingSend = 0;
    BOOL fBufferSent = 0;

    ASSERT(LastBuffer == 0);

    if (PARTIAL(Message))
        {
        if (Message->BufferLength < MaxDataLength)
            {
            return RPC_S_SEND_INCOMPLETE;
            }

        // Check if the message contains more data then can be sent.
        RemainingLength = Message->BufferLength % MaxDataLength;

        // If there is extra data that will not be sent now, allocate
        // and fill NewBuffer with it.
        if (RemainingLength)
            {
            Status = GetBufferDo(&NewBuffer, RemainingLength);
            if (Status != RPC_S_OK)
                {
                ASSERT(Status == RPC_S_OUT_OF_MEMORY);
                FreeBufferDo(Message->Buffer);

                return Status;
                }

            Message->BufferLength -= RemainingLength;
            RpcpMemoryCopy(NewBuffer,
                           (char *) Message->Buffer+Message->BufferLength,
                           RemainingLength);
            // Now NewBuffer contains the excess data that has not been sent.
            }
        }
    else
        {
        LastBuffer = Message->Buffer;
        }


    while (1)
        {
        CallMutex.Request();
        if (CurrentBuffer == 0)
            {
            //
            // If CurrentBuffer == 0, it means that the call is idle
            //
            CurrentOffset = 0;
            CurrentBuffer = Message->Buffer;
            CurrentBufferLength = Message->BufferLength;
            fBufferSent = TRUE;

            // Check if we have a NewBuffer left over from a message greater then MaxDataLength.
            if ((CurrentBuffer != LastBuffer)
                || (CurrentBufferLength > MaxDataLength))
                {
                UpdateBuffersAfterNonLastSend(
                    NewBuffer,
                    RemainingLength,
                    Message);
                fOutstandingSend = TRUE;
                }

            CallMutex.Clear();

            Status = SendNextFragment();

            if (Status && fOutstandingSend)
                {
                // if we failed on a non last send, there will be 
                // nobody else to drive the call - we need to 
                // return the unsent buffer to Message->Buffer,
                // so that it can be freed below.
                Message->Buffer = CurrentBuffer;
                CleanupCall();
                }

            // N.B. Do not touch any call members after
            // this point if the call succeeded - you may affect 
            // the next call.
            // This is because once we send, we may get swapped out
            // and other threads could drive the call to
            // completion (i.e. send all fragments and cleanup
            // the call on the last fragment). From then on,
            // it may be another call we're writing on.

            if (fOutstandingSend && RemainingLength && (Status == RPC_S_OK))
                StatusToReturn = RPC_S_SEND_INCOMPLETE;
            }
        else
            {
            if ((AsyncStatus == RPC_S_OK) && (pAsync == 0) && (BufferQueue.Size() >= 4))
                {
                fChoked = 1;
                CallMutex.Clear();

                SyncEvent.Wait();
                // if the call already failed, bail out
                if (AsyncStatus != RPC_S_OK)
                    {
                    Status = AsyncStatus;
                    fOutstandingSend = TRUE;
                    break;
                    }
                continue;
                }
            else if (AsyncStatus != RPC_S_OK)
                {
                CallMutex.Clear();
                Status = AsyncStatus;
                fOutstandingSend = TRUE;
                break;
                }

            //
            // Since CurrentBuffer != 0, the call is busy sending the reply
            //

            if (BufferQueue.PutOnQueue(Message->Buffer, Message->BufferLength))
                {
                Status = RPC_S_OUT_OF_MEMORY;
                }
            else
                {
                UpdateBuffersAfterNonLastSend(
                    NewBuffer,
                    RemainingLength,
                    Message);

                if (RemainingLength)
                    StatusToReturn = RPC_S_SEND_INCOMPLETE;
                }
            CallMutex.Clear();
            }
        break;
        }

    if (Status)
        {
        if (RemainingLength)
            {
            FreeBufferDo(NewBuffer);
            }

        if (fOutstandingSend)
            {
            FreeBufferDo(Message->Buffer);
            }
        }
    else
        {
        if (StatusToReturn != RPC_S_OK)
            Status = StatusToReturn;
        }

    if (fBufferSent)
        {
        //
        // Remove the reference for the call (if failure)
        // or for the outstanding send (if success)
        //
        RemoveReference(); // CALL--
        }

    return Status;
}



RPC_STATUS
OSF_SCALL::AsyncSend (
    IN OUT PRPC_MESSAGE Message
    )
/*++
Function Name:AsyncSend
Parameters:
    Message - Supplies the buffer containing the response to be sent

Description:
    It isn't neccassary for us to send the reply using async IO. For the first
    cut, we will send the request synchronously. This will save us a whole lot
    of headache.

Returns:

--*/
{
    RPC_STATUS Status;
    ULONG OldBufferLength = Message->BufferLength;

    ASSERT(FirstSend == 0 || BufferQueue.IsQueueEmpty());

    if (FirstSend)
        {
        fNotifyOnSendComplete = (pAsync->Flags & RPC_C_NOTIFY_ON_SEND_COMPLETE);
        }

    if (AsyncStatus != RPC_S_OK)
        {
        Status = AsyncStatus;

        CleanupCall();

        //
        // Remove the reply reference
        //
        RemoveReference(); // CALL--

        return Status;
        }

    Status = Send(Message);

    if (Status == RPC_S_SEND_INCOMPLETE)
        {
        if (Message->BufferLength == OldBufferLength
            && (pAsync->Flags & RPC_C_NOTIFY_ON_SEND_COMPLETE))
            {
            CallMutex.Request() ;
            if (!IssueNotification(RpcSendComplete))
                {
                Status = RPC_S_OUT_OF_MEMORY ;
                }
            CallMutex.Clear() ;
            }
        }

    //
    // In the failure case, the reference has already been removed
    // by the server
    //

    return Status;
}


RPC_STATUS
OSF_SCALL::SendRequestOrResponse (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned char PacketType
    )
/*++

Routine Description:

    This routine is used to send to synchoronous sends, as in callbacks
    and callback response.

Arguments:

    Message - Supplies the buffer containing the request or response to be
        sent, and returns the first fragment received from the server.

    PacketType - Supplies the packet type; this must be rpc_request or
        rpc_response.

Return Value:

    RPC_S_OK - We successfully sent the request and received a fragment from
        the server.

    RPC_S_CALL_FAILED_DNE - The connection failed part way through sending
        the request or response.

    RPC_S_CALL_FAILED - The connection failed after sending the request or
        response, and the receive failed.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to perform the
        operation.

    RPC_S_OUT_OF_RESOURCES - Insufficient resources are available to perform
        the operation.

--*/
{
    RPC_STATUS Status;
    RPC_MESSAGE SendBuffer;
    rpcconn_common  * pFragment;
    ULONG LastFragmentFlag = 0;
    ULONG LengthLeft = Message->BufferLength;
    ULONG HeaderSize = sizeof(rpcconn_request);
    ULONG MaxDataLength = MaximumFragmentLength - HeaderSize - MaxSecuritySize;
    unsigned char *ReservedForSecurity = (unsigned char *) Message->Buffer
        + Message->BufferLength + Connection->AdditionalSpaceForSecurity;

    ASSERT(!PARTIAL(Message));
    ASSERT( sizeof(rpcconn_response) == sizeof(rpcconn_request));

    VALIDATE(PacketType)
        {
        rpc_request,
        rpc_response
        } END_VALIDATE;

    SendBuffer.Buffer = Message->Buffer;
    pFragment = (rpcconn_common  *) ((char  *) Message->Buffer - HeaderSize);

    for (;;)
        {
        //
        // Check to see if the remaining data will fit into a single
        // fragment; if so, set the last fragment flag.
        //
        if ( LengthLeft <= MaxDataLength )
            {
            LastFragmentFlag = 1;
            }

        ConstructPacket(pFragment, PacketType, (LastFragmentFlag != 0 ?
               LengthLeft+HeaderSize+MaxSecuritySize : MaximumFragmentLength));

        if ((LengthLeft == Message->BufferLength))
            {
            if (FirstFrag)
                {
                FirstFrag = 0;
                pFragment->pfc_flags |= PFC_FIRST_FRAG;

                if (TestCancel())
                    {
                    pFragment->pfc_flags |= PFC_PENDING_CANCEL;
                    }
                }
            }

        if (PacketType == rpc_request)
            {
            ((rpcconn_request  *) pFragment)->alloc_hint = LengthLeft;
            ((rpcconn_request  *) pFragment)->p_cont_id = (unsigned short) CurrentBinding->GetPresentationContext();
            ((rpcconn_request  *) pFragment)->opnum = (unsigned short) Message->ProcNum;
            }
        else
            {
            ((rpcconn_response  *) pFragment)->alloc_hint = LengthLeft;
            ((rpcconn_response  *) pFragment)->p_cont_id = (unsigned short) CurrentBinding->GetPresentationContext();
            ((rpcconn_response  *) pFragment)->alert_count = (unsigned char) 0;
            ((rpcconn_response  *) pFragment)->reserved = 0;
            }

        pFragment->call_id = CallId;

        Status = Connection->SendFragment(
                                 pFragment,
                                 LastFragmentFlag,
                                 HeaderSize,
                                 MaxSecuritySize,
                                 LengthLeft,
                                 MaximumFragmentLength,
                                 ReservedForSecurity) ;

        if (Status != RPC_S_OK || LastFragmentFlag)
            {
            FreeBuffer(&SendBuffer);
            return (Status) ;
            }

        pFragment = (rpcconn_common  *)
            (((unsigned char  *) pFragment) + MaxDataLength);

        LengthLeft -= MaxDataLength;
        }

    ASSERT(0);
}


void
OSF_SCALL::ProcessSendComplete (
    IN RPC_STATUS EventStatus,
    IN BUFFER Buffer
    )
/*++
Function Name:ProcessSendComplete

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    int MaxDataLength = MaximumFragmentLength
        - sizeof(rpcconn_response) - MaxSecuritySize;
    unsigned int MyCurrentBufferLength;

    LogEvent(SU_SCALL, EV_NOTIFY, this, Buffer, EventStatus, 1);

    ASSERT(Buffer);
    ASSERT((char *) Buffer-CurrentOffset
           +sizeof(rpcconn_request) == CurrentBuffer);
    ASSERT((((rpcconn_common *) Buffer)->pfc_flags & PFC_LAST_FRAG) == 0);

    if (EventStatus != RPC_S_OK)
        {
        Status = RPC_S_CALL_FAILED;
        goto Abort;
        }

    MyCurrentBufferLength = CurrentBufferLength - MaxDataLength;
    CurrentOffset += MaxDataLength;

    CallMutex.Request();
    if (MyCurrentBufferLength == 0)
        {
        Connection->TransFreeBuffer(
                                    (char *) CurrentBuffer-sizeof(rpcconn_response));

        CurrentBuffer = BufferQueue.TakeOffQueue(&MyCurrentBufferLength);
        if (CurrentBuffer == 0)
            {
            //
            // As soon as send-complete notification is issued, a thread may
            // be released to do another AsyncSend.  If by that time
            // AsyncStatus != RPC_S_OK it will try to clean up the call.
            // Thus, after IssueNotification, the send reference may be removed.
            // We should keep an extra ref to guard against this.
            //
            AddReference();

            if (pAsync && (pAsync->Flags & RPC_C_NOTIFY_ON_SEND_COMPLETE))
                {
                if (!IssueNotification(RpcSendComplete))
                    {
                    AsyncStatus = RPC_S_OUT_OF_MEMORY;
                    }
                }
            CurrentBufferLength = 0;
            CallMutex.Clear();

            RemoveReference();

            return;
            }

        CurrentOffset = 0;

        if (fChoked == 1 && pAsync == 0 && BufferQueue.Size() <=1)
            {
            fChoked = 0;
            SyncEvent.Raise();
            }
        }
    else
        {
        //
        // We know that there is more to send in the current buffer
        // We need to restore the part of the buffer which we overwrote
        // with authentication information.
        //
        ASSERT(CurrentBuffer);
        unsigned char *ReservedForSecurity = (unsigned char *) CurrentBuffer
                + CurrentOffset + MyCurrentBufferLength
                + Connection->AdditionalSpaceForSecurity;

        if  ((Connection->AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE)
             && (MaxSecuritySize != 0))
            {
            RpcpMemoryCopy((char *) Buffer+MaximumFragmentLength-MaxSecuritySize,
                       ReservedForSecurity, MaxSecuritySize);
            }
        }

    // MyCurrentBufferLength may be 0 if the last buffer to be
    // queued had 0 length.  This may happen in async pipe scenarios.

    CurrentBufferLength = MyCurrentBufferLength;
    CallMutex.Clear();

    ASSERT(CurrentBuffer);

    Status = Address->CreateThread();
	if (Status != RPC_S_OK)
        {
        goto Abort;
        }

    Status = SendNextFragment();

    if (Status != RPC_S_OK)
        {
        goto Abort;
        }

    //
    // Remove reference held by the outstanding send
    // or the call reference in the case of the last call
    //
    RemoveReference(); // CALL--

    return;

Abort:
    ASSERT(CurrentBuffer);
    ASSERT(Status != RPC_S_OK);


    Connection->TransFreeBuffer(
                (char *) CurrentBuffer-sizeof(rpcconn_response));

    //
    // We cannot remove the reference here, if we do
    // we'll cause the other thread to puke
    //
    AsyncStatus = Status;

    BUFFER MyBuffer;
    unsigned int ignore;

    CallMutex.Request();
    while (MyBuffer = BufferQueue.TakeOffQueue(&ignore))
       {
       Connection->TransFreeBuffer((char *) MyBuffer-sizeof(rpcconn_response));
       }
    // wake up the thread that was flow controlled, if any
    if (fChoked == 1 && pAsync == 0)
        {
        fChoked = 0;
        SyncEvent.Raise();
        }
    CallMutex.Clear();

    CurrentBufferLength = 0;

    // For async pipes, if the async send fails we need to wake up
    // a thread waiting for the send-complete notification and keep
    // the reference.  During the next call to push we will deliver the failure
    // to the user and free the call.
    // If the call has already been aborted or completed and notification level is none,
    // pAsync may be gone and we can't query it.  Therefore we need to capture the
    // pAsync->Flags and use the captured value here.
    if (fAsyncPipeCall && fNotifyOnSendComplete)
        {
        if (!IssueNotification(RpcSendComplete))
            {
            AsyncStatus = RPC_S_OUT_OF_MEMORY;
            }
        }
    else
        {
        //
        // Remove the reply reference
        //
        RemoveReference(); // CALL--
        }
}


RPC_STATUS
OSF_SCALL::ImpersonateClient (
    )
/*++
Function Name:ImpersonateClient

Parameters:

Description:

 This is relatively easy: we check to see if there is RPC protocol level
 security, if there is not, we let the transport try and impersonate
 the client, and if there is, we let the GSSAPI deal with it.

Returns:

--*/
{
    return Connection->ImpersonateClient();
}


RPC_STATUS
OSF_SCALL::RevertToSelf (
    )
/*++
Function Name:RevertToSelf

Parameters:

Description:

  As with ImpersonateClient, this is relatively easy.  We just check
  to see if we should let the RPC protocol level security deal with
  it or the transport.

Returns:

--*/
{
    return Connection->RevertToSelf();
}

RPC_STATUS
OSF_SCALL::GetAuthorizationContext (
    IN BOOL ImpersonateOnReturn,
    IN AUTHZ_RESOURCE_MANAGER_HANDLE AuthzResourceManager,
    IN PLARGE_INTEGER pExpirationTime OPTIONAL,
    IN LUID Identifier,
    IN DWORD Flags,
    IN PVOID DynamicGroupArgs OPTIONAL,
    OUT PAUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContext
    )
/*++

Routine Description:

    Gets an authorization context for the client that can be used
    with Authz functions. The resulting context is owned by the caller
    and must be freed by it.

Arguments:

    ImpersonateOnReturn - if TRUE, when we return, we should be impersonating.
    AuthzResourceManager - the resource manager to use (passed to Authz)
    pExpirationTime - the expiration time to use (passed to Authz)
    Identifier - the LUID (passed to Authz)
    Flags - Flags (passed to Authz)
    DynamicGroupArgs - parameter required by Authz (passed to Authz)
    pAuthzClientContext - the authorization context, returned on success. 
    Undefined on failure.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    RPC_STATUS RevertStatus;
    HANDLE ImpersonationToken;
    BOOL Result;
    PAUTHZ_CLIENT_CONTEXT_HANDLE pAuthzClientContextPlaceholder;
    SECURITY_CONTEXT *SecurityContext = Connection->CurrentSecurityContext;
    SECURITY_STATUS SecurityStatus;
    BOOL fNeedToCloseToken;
    AUTHZ_CLIENT_CONTEXT_HANDLE AuthzContext;

    ASSERT (AuthzResourceManager != NULL);

    if (!SecurityContext)
        {
        return RPC_S_NO_CONTEXT_AVAILABLE;
        }

    AuthzContext = SecurityContext->GetAuthzContext();

    if (ImpersonateOnReturn)
        {
        Status = OSF_SCALL::ImpersonateClient();

        if (Status != RPC_S_OK)
            {
            RpcpErrorAddRecord(EEInfoGCRuntime, 
                Status, 
                EEInfoDLOSF_SCALL__GetAuthorizationContext10,
                (ULONGLONG)this,
                (ULONGLONG)0);

            return Status;
            }
        }

    if (AuthzContext)
        {
        Status = DuplicateAuthzContext(AuthzContext,
            pExpirationTime, 
            Identifier,
            Flags,
            DynamicGroupArgs,
            pAuthzClientContext);

        if ((Status != RPC_S_OK) && ImpersonateOnReturn)
            {
            RevertStatus = OSF_SCALL::RevertToSelf();
            ASSERT(RevertStatus == RPC_S_OK);
            }

        // EEInfo, if any, has already been added
        return Status;
        }

    // if there was Authz context created, we would have
    // returned by now. If we are here, this means there
    // is none. Create it.
    Status = SecurityContext->GetAccessToken(&ImpersonationToken, 
        &fNeedToCloseToken);

    if (Status)
        {
        if (ImpersonateOnReturn)
            {
            RevertStatus = OSF_SCALL::RevertToSelf();
            ASSERT(RevertStatus == RPC_S_OK);
            }
        return Status;
        }

    Status = CreateAndSaveAuthzContextFromToken(SecurityContext->GetAuthzContextAddress(),
        ImpersonationToken,
        AuthzResourceManager,
        pExpirationTime,
        Identifier,
        Flags,
        DynamicGroupArgs,
        pAuthzClientContext);

    if (fNeedToCloseToken)
        {
        CloseHandle(ImpersonationToken);
        }

    if (Status)
        {
        if (ImpersonateOnReturn)
            {
            RevertStatus = OSF_SCALL::RevertToSelf();
            ASSERT(RevertStatus == RPC_S_OK);
            }

        return Status;
        }

    return RPC_S_OK;
}

RPC_STATUS
OSF_SCALL::GetAssociationContextCollection (
    OUT ContextCollection **CtxCollection
    )
/*++
Function Name:  GetAssociationContextCollection

Parameters:
    CtxCollection - a placeholder where to put the pointer to 
        the context collection.

Description:
    The context handle code will call the SCALL to get the collection
    of context handles for this association. The SCALL method will
    simply delegate to the association.

Returns:
    RPC_S_OK for success or RPC_S_* for error.

--*/
{
    return Connection->GetAssociationContextCollection(CtxCollection);
}

void 
OSF_SCALL::CleanupCallAndSendFault (
    IN RPC_STATUS Status,
    IN int DidNotExecute
    )
/*++
Function Name:CleanupCallAndSendFault

Parameters: Status - the error code for the fault

Description:

  A syntactic sugar function that saves all relevant call members in a local
  variable, cleans up the call, and then sends the fault directly on the
  connection. Designed to prevent the case where we send the fault to the client
  and the next request comes in before we have made this call available - this
  confuses the server.

Returns:

--*/
{
    p_context_id_t p_cont = 0;
    OSF_SCONNECTION *pLocalConnection;
    unsigned long LocalCallId = CallId;

    if (CurrentBinding)
        p_cont = (p_context_id_t)CurrentBinding->GetPresentationContext();

    pLocalConnection = Connection;

    // make the call available before we send the fault
    CleanupCall();
    pLocalConnection->SendFault(Status, DidNotExecute, LocalCallId, p_cont);
}


RPC_STATUS
OSF_SCALL::ConvertToServerBinding (
    OUT RPC_BINDING_HANDLE __RPC_FAR * ServerBinding
    )
/*++

Routine Description:

    If possible, convert this connection into a server binding, meaning a
    binding handle pointing back to the client.

Arguments:

    ServerBinding - Returns the server binding.

Return Value:

    RPC_S_OK - The server binding has successfully been created.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate
        a new binding handle.

    RPC_S_CANNOT_SUPPORT - This will be returned if the transport does
        not support query the network address of the client.

--*/
{
    RPC_CHAR * NetworkAddress;
    RPC_STATUS Status;
    RPC_CHAR * StringBinding;

    Status = Connection->TransQueryClientNetworkAddress(
                                                                &NetworkAddress);
    if ( Status != RPC_S_OK )
        {
        return(Status);
        }

    Status = RpcStringBindingCompose(0,
                        Address->InqRpcProtocolSequence(),
                        NetworkAddress,
                        0,
                        0,
                        &StringBinding);
    delete NetworkAddress;
    if ( Status != RPC_S_OK )
        {
        return(Status);
        }

    Status = RpcBindingFromStringBinding(StringBinding, ServerBinding);

    if ( ObjectUuidSpecified != 0 && RPC_S_OK == Status)
        {
        Status = RpcBindingSetObject(*ServerBinding, (UUID *) &ObjectUuid);
        }
    RpcStringFree(&StringBinding);

    return(Status);
}



OSF_SCONNECTION::OSF_SCONNECTION (
    IN OSF_ADDRESS * TheAddress,
    IN RPC_CONNECTION_TRANSPORT * ServerInfo,
    IN OUT RPC_STATUS  * Status
    ) : ConnMutex(Status)
{
    ObjectType = OSF_SCONNECTION_TYPE;
    MaxFrag = 512;
    Association = 0;
    AuthContextId = 0;
    SavedHeader = 0;
    SavedHeaderSize = 0;
    CurrentSecurityContext = 0;
    RpcSecurityBeingUsed = 0;
    SecurityContextAltered = 0;
    AdditionalSpaceForSecurity = 0;

    DceSecurityInfo.SendSequenceNumber = 0;
    DceSecurityInfo.ReceiveSequenceNumber = 0;
    AuthContinueNeeded = 0;
    CurrentCallId=-1;
    CachedSCallAvailable = 1;
    this->ServerInfo = ServerInfo;
    ConnectionClosedFlag = 0;
    Address = TheAddress;
    TransConnection = (char *) this+sizeof(OSF_SCONNECTION);
    fKeepalivesTurnedOn = FALSE;

    if (IsServerSideDebugInfoEnabled())
        {
        // zero out the CachedSCall - this is a signal that
        // the OSF_SCALL constructor will use to tell
        // it is the cached call
        CachedSCall = NULL;
        DebugCell = (DebugConnectionInfo *) AllocateCell(&DebugCellTag);
        if (DebugCell != 0)
            {
            memset(DebugCell, 0, sizeof(*DebugCell));
            DebugCell->Type = dctConnectionInfo;
            TheAddress->GetDebugCellIDForThisObject(&DebugCell->Endpoint);
            }
        else
            *Status = RPC_S_OUT_OF_MEMORY;
        }
    else
        DebugCell = NULL;

    // Create an SCALL object.
    // If the app verifier is enabled, we will create an object which 
    // supports the verifier checks.
    if (gfRPCVerifierEnabled)
        {
        CachedSCall = new (ServerInfo->SendContextSize) OSF_SCALL_AVRF(this, Status);
        }
    else
        {
        CachedSCall = new (ServerInfo->SendContextSize) OSF_SCALL(this, Status);
        }

    if (CachedSCall == 0)
        {
        *Status = RPC_S_OUT_OF_MEMORY;
        }
    fExclusive = 0;
    fDontFlush = 0;
    fFirstCall = 0;
    fCurrentlyDispatched = 0;
}

OSF_SCONNECTION::~OSF_SCONNECTION (
    )
{
    OSF_SBINDING * SBinding;
    SECURITY_CONTEXT * SecurityContext;
    DictionaryCursor cursor;

    if (CachedSCall)
        {
        delete CachedSCall;
        }

    ASSERT( AuthInfo.PacHandle == 0 );
    if ( CurrentSecurityContext && AuthInfo.PacHandle )
       {
       CurrentSecurityContext->DeletePac( AuthInfo.PacHandle );
       }

    SecurityContextDict.Reset(cursor);
    while ( (SecurityContext = SecurityContextDict.Next(cursor)) != 0 )
        delete SecurityContext;

    Bindings.Reset(cursor);
    while (SBinding = Bindings.Next(cursor))
        delete SBinding;

    if (Association)
        Association->RemoveConnection();

    if (SavedHeader)
        {
        RpcpFarFree(SavedHeader);
        }

    if (ServerInfo)
        {
        //
        // ServerInfo will be set to 0 when create on the SCONNECTION fails
        // look at NewConnection
        //
        ServerInfo->Close(TransConnection, fDontFlush);
        }

    if (DebugCell)
        {
        FreeCell(DebugCell, &DebugCellTag);
        }
}


RPC_STATUS
OSF_SCONNECTION::TransSend (
    IN void * Buffer,
    IN unsigned int BufferLength
    )
/*++

--*/
{
    RPC_STATUS Status;

    {
    rpcconn_common * pkt = (rpcconn_common *) Buffer;
    LogEvent(SU_SCONN, EV_PKT_OUT, this, 0, (pkt->PTYPE << 16) | pkt->frag_length);
    }

    if (ConnectionClosedFlag != 0)
        return(RPC_P_CONNECTION_CLOSED);

    if (DebugCell)
        {
        DebugCell->LastSendTime = NtGetTickCount();
        DebugCell->LastTransmitFragmentSize = (USHORT) BufferLength;
        }

    DceSecurityInfo.SendSequenceNumber += 1;

    Status = ServerInfo->SyncSend(
                                 TransConnection,
                                 BufferLength,
                                 Buffer,
                                 TRUE, 
                                 TRUE,
                                 INFINITE);   // Timeout

    VALIDATE(Status)
        {
        RPC_S_OK,
        RPC_S_OUT_OF_MEMORY,
        RPC_S_OUT_OF_RESOURCES,
        RPC_P_SEND_FAILED
        } END_VALIDATE;

    if ( Status == RPC_S_OK )
        {
        GlobalRpcServer->PacketSent();
        }

    if ( Status == RPC_P_SEND_FAILED )
        {
        ConnectionClosedFlag = 1;
        }

    return(Status);
}


RPC_STATUS
OSF_SCONNECTION::TransAsyncSend (
    IN void * Buffer,
    IN unsigned int BufferLength,
    IN void *SendContext
    )
/*++
Function Name:TransAsyncSend

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;

    {
    rpcconn_common * pkt = (rpcconn_common *) Buffer;
    LogEvent(SU_SCONN, EV_PKT_OUT, this, 0, (pkt->PTYPE << 16) | pkt->frag_length);
    }

    if ( ConnectionClosedFlag != 0 )
        {
        return(RPC_P_CONNECTION_CLOSED);
        }

    if (DebugCell)
        {
        DebugCell->LastSendTime = NtGetTickCount();
        DebugCell->LastTransmitFragmentSize = (USHORT) BufferLength;
        }

    DceSecurityInfo.SendSequenceNumber += 1;

    Status = ServerInfo->Send(TransConnection,
                              BufferLength,
                              (BUFFER) Buffer,
                              SendContext);

    if (Status == RPC_S_OK)
        {
        GlobalRpcServer->PacketSent();
        }

    if ( Status == RPC_P_SEND_FAILED )
        {
        ConnectionClosedFlag = 1;
        }

    VALIDATE(Status)
        {
        RPC_S_OK,
        RPC_S_OUT_OF_MEMORY,
        RPC_S_OUT_OF_RESOURCES,
        RPC_P_SEND_FAILED
        } END_VALIDATE;

    return(Status);
}


RPC_STATUS
OSF_SCONNECTION::TransAsyncReceive (
    )
/*++
Function Name:TransAsyncReceive

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;

    //
    // Each outstanding receive will hold a reference
    // on the connection
    //
    AddReference(); // CONN++

    if (ConnectionClosedFlag != 0)
        {
        AbortConnection();
        return(RPC_P_CONNECTION_CLOSED);
        }

    Status = ServerInfo->Recv(TransConnection);

    if (Status != RPC_S_OK)
        {
        VALIDATE(Status)
            {
            RPC_P_RECEIVE_FAILED,
            RPC_P_CONNECTION_SHUTDOWN,
            RPC_P_CONNECTION_CLOSED
            }
        CORRUPTION_VALIDATE
            {
            RPC_S_PROTOCOL_ERROR
            } CORRUPTION_END_VALIDATE;

        if (fExclusive && !CachedSCallAvailable)
            CachedSCall->WakeUpPipeThreadIfNecessary(RPC_S_CALL_FAILED);

        ConnectionClosedFlag = 1;
        AbortConnection();
        }

    return Status;
 }


unsigned int
OSF_SCONNECTION::TransMaximumSend (
    )
/*++

--*/
{
    return(ServerInfo->MaximumFragmentSize);
}


RPC_STATUS
OSF_SCONNECTION::TransImpersonateClient (
    )
/*++
Function Name:TransImpersonateClient

Parameters:

Description:

   If the transport module supports impersonation it will provide the
   sImpersonateClient entry point, in which case we call it.  If an
   error occurs (indicated by sImpersonateClient returning non-zero),
   then no context is available.  NOTE: this is the correct error code
   for NT; it may not be the right one (or only one) for other transports
   which support impersonation.

Returns:

--*/
{
    RPC_STATUS Status;

    if ( ServerInfo->ImpersonateClient == 0 )
        {
        return(RPC_S_CANNOT_SUPPORT);
        }

    Status = ServerInfo->ImpersonateClient(TransConnection);

    VALIDATE(Status)
        {
        RPC_S_OK,
        RPC_S_NO_CONTEXT_AVAILABLE
        } END_VALIDATE;

    return(Status);
}


void
OSF_SCONNECTION::TransRevertToSelf (
    )
/*++

--*/
// As with TransImpersonateClient, if the transport module supports
// impersonation, then sRevertToSelf will be non-zero.  We do not have
// to worry about errors.
//
// For revert to self to work in NT, the transport module needs to know
// the handle of the calling thread when it was originally created.  None
// of the other operating systems we support at this point have
// impersonation built into the transports.
{
    RPC_STATUS Status;

    if ( ServerInfo->RevertToSelf != 0 )
        {
        Status = ServerInfo->RevertToSelf(TransConnection);
        ASSERT( Status == RPC_S_OK );
        }
}


void
OSF_SCONNECTION::TransQueryClientProcess (
    OUT RPC_CLIENT_PROCESS_IDENTIFIER * ClientProcess
    )
/*++

Routine Description:

    We need to obtain the client process identifier for the client process
    at the other end of this connection.  This is necessary so that we can
    determine whether or not a connection should belong to a given
    association.  We need to do this so that context handles (which hang off
    of associations) are secure.

Arguments:

    ClientProcess - Returns the client process identifier for the client
        process at the other end of this connection.

--*/
{
    RPC_STATUS Status;

    if ( ServerInfo->QueryClientId == 0 )
        {
        ClientProcess->ZeroOut();
        }
    else
        {
        Status = ServerInfo->QueryClientId(TransConnection,
                                                   ClientProcess);
        ASSERT( Status == RPC_S_OK );
        }
}

void
OSF_SCONNECTION::TransQueryClientIpAddress (
    IN OUT RPC_CLIENT_IP_ADDRESS *ClientIpAddress
    )
/*++

Routine Description:

    Obtain the ip address of the client as precisely as the transport
    allows. If the transport does not support such functionality,
    put in a default empty ip address.

Arguments:

    ClientIpAddress - Returns the ip address of the client at the other 
        end of this connection.

--*/
{
    RPC_STATUS Status;

    if ( ServerInfo->QueryClientIpAddress == 0 )
        {
        ClientIpAddress->ZeroOut();
        }
    else
        {
        Status = ServerInfo->QueryClientIpAddress(TransConnection,
                                                   ClientIpAddress);
        ASSERT( Status == RPC_S_OK );
        }
}


RPC_STATUS
OSF_SCONNECTION::TransQueryClientNetworkAddress (
    OUT RPC_CHAR ** NetworkAddress
    )
/*++

Routine Description:

    This routine is used to query the network address of the client at the
    other end of this connection.

Arguments:

    NetworkAddress - Returns the client's network address.

Return Value:

    RPC_S_OK - The client's network address has successfully been obtained.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete the
        operation.

    RPC_S_CANNOT_SUPPORT - This particular transport implementation does
        not support this operation.

--*/
{
    RPC_STATUS Status;

    if (   ( ServerInfo->TransInterfaceVersion < 2 )
        || ( ServerInfo->QueryClientAddress == 0 ) )
        {
        return(RPC_S_CANNOT_SUPPORT);
        }

    Status = ServerInfo->QueryClientAddress(TransConnection,
                                               NetworkAddress);

    return(Status);
}


void
OSF_SCONNECTION::AbortConnection (
    )
/*++

Routine Description:
--*/
{
    DictionaryCursor cursor;

    //
    // When AbortConnection is called,
    // there should be no pending IO
    //

    //
    // Delete the object, ie: remove the object reference
    //
    Delete();

    //
    // If there are calls stuck in callbacks, wake them up
    //
    if (fExclusive)
        {
        ConnMutex.Request();
        if (CachedSCallAvailable == 0)
            {
            CachedSCall->DeactivateCall();
            CachedSCallAvailable = 1;
            ConnMutex.Clear();

            CachedSCall->AbortCall();
            }
        else
            {
            ConnMutex.Clear();
            }
        }
    else
        {
        ConnMutex.Request();
        OSF_SCALL *NextCall;

        CallDict.Reset(cursor);
        while ((NextCall = CallDict.Next(cursor)) != 0)
            {
            NextCall->AbortCall();
            }
        ConnMutex.Clear();
        }

    //
    // Remove the reference held by the pending receive
    //
    RemoveReference(); // CONN--
}


void
OSF_SCONNECTION::FreeObject (
    )
{
    RemoveFromAssociation();

    delete this;
}


void
OSF_SCONNECTION::FreeSCall (
    IN OSF_SCALL *SCall,
    IN BOOL fRemove
    )
/*++
Function Name:FreeSCall

Parameters:

Description:

Returns:

--*/
{
    ASSERT(SCall->BufferQueue.IsQueueEmpty());

    if (fExclusive == 0)
        {
        if (fRemove)
            {
            OSF_SCALL *Call;

            ConnMutex.Request();
            Call = CallDict.Delete(ULongToPtr(SCall->CallId));
            ConnMutex.Clear();

            ASSERT(Call == 0 || Call == SCall);
            }

        // CurrentBinding is initialized in OSF_SCALL::BeginRpcCall
        // by a call to OSF_CCONNECTION::LookupBinding.  That call may
        // not succeed if we do not find the binding in the dictionary,
        // or we may fail before initialization.
        if (SCall->CurrentBinding != NULL)
            {
            RPC_INTERFACE *CallInterface;

            CallInterface = SCall->CurrentBinding->GetInterface();
    
            if (SCall->pAsync)
                {
                CallInterface->EndCall(0, 1);
                if (CallInterface->IsAutoListenInterface())
                    {
                    // This is the path where async calls complete.
                    // We need to decrement CallNumber.
                    CallInterface->EndAutoListenCall(TRUE);
                    }
                }
            }

        SCall->DeactivateCall();
        if (SCall == CachedSCall)
            {
            CachedSCallAvailable = 1;
            }
        else
            {
            delete SCall;
            }

        }

    //
    // Remove the reference held by the call
    //
    RemoveReference(); // CONN--
}


RPC_STATUS
OSF_SCONNECTION::TransGetBuffer (
    OUT void * * Buffer,
    IN unsigned int BufferLength
    )
{
    int  * Memory;

    //
    // Our memory allocator returns memory which is aligned by at least
    // 8, so we dont need to worry about aligning it.
    //
    Memory = (int  *) CoAllocateBuffer(BufferLength);
    if ( Memory == 0 )
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    ASSERT( IsBufferAligned(Memory) );

    *Buffer = Memory;

    return(RPC_S_OK);
}

void
OSF_SCONNECTION::TransFreeBuffer ( // Free a buffer.
    IN void  * Buffer
    )
{
    CoFreeBuffer(Buffer);
}


void
OSF_SCONNECTION::ProcessReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN BUFFER Buffer,
    IN UINT BufferLength
    )
/*++
Function Name:ProcessReceiveComplete

Parameters:

Description:

Returns:

--*/
{
    rpcconn_common *Packet = (rpcconn_common *) Buffer;
    rpcconn_auth3  * AuthThirdLegPacket;
    sec_trailer  * NewSecurityTrailer;
    OSF_SCALL *SCall = 0;
    RPC_STATUS Status;
    SECURITY_BUFFER_DESCRIPTOR InputBufferDescriptor;
    SECURITY_BUFFER InputBuffers[4];
    BOOL fReceivePosted = 0;
    BOOL fDNE = 0;

    if (EventStatus)
        {
        LogEvent(SU_SCONN, EV_PKT_IN, this, LongToPtr(EventStatus));
        }
    else
        {
        if (Packet->PTYPE == rpc_request)
            {
            LogEvent(SU_SCONN, EV_PKT_IN, this, 0,
                (((rpcconn_request *)Packet)->opnum << 24) | (Packet->PTYPE << 16) | Packet->frag_length);
            }
        else
            {
            LogEvent(SU_SCONN, EV_PKT_IN, this, 0, (Packet->PTYPE << 16) | Packet->frag_length);
            }
        }

    if (DebugCell)
        {
        DebugCell->LastReceiveTime = NtGetTickCount();
        DebugCell->LastTransmitFragmentSize = (USHORT)BufferLength;
        }

    if (EventStatus != RPC_S_OK)
        {
        VALIDATE(EventStatus)
            {
            RPC_P_CONNECTION_CLOSED,
            RPC_P_RECEIVE_FAILED,
            RPC_P_CONNECTION_SHUTDOWN
            } END_VALIDATE;
        ConnectionClosedFlag = 1;

        if (fExclusive && !CachedSCallAvailable)
            CachedSCall->WakeUpPipeThreadIfNecessary(RPC_S_CALL_FAILED);

        TransFreeBuffer(Buffer);

        AbortConnection();
        return;
        }

    ASSERT(EventStatus == 0);
    ASSERT(Buffer);

    GlobalRpcServer->PacketReceived();

    //
    // Check and make sure that if this is the first packet on this
    // connection that it is a bind packet.
    //
    if ((Association == 0) && (Packet->PTYPE != rpc_bind))
        {
        SendBindNak(protocol_version_not_supported, Packet->call_id);
        TransFreeBuffer(Packet);
        AbortConnection();
        return;
        }

    //
    // A non bind or alter-context packet can't exceed MaxFrag bytes.
    // A bind packet will include the token and can get arbitrarily large.
    //
    if (Packet->PTYPE != rpc_bind &&
        Packet->PTYPE != rpc_alter_context &&
        ((DataConvertEndian(Packet->drep) == 0 && Packet->frag_length > TransMaximumSend()) ||
         (DataConvertEndian(Packet->drep) != 0 && RpcpByteSwapShort(Packet->frag_length) > TransMaximumSend())
        )
       )
        {
        CORRUPTION_ASSERT(0 && "Packet->frag_length exceeds TransMaximumSend()");
        SC_CLEANUP(RPC_S_PROTOCOL_ERROR, 0);
        }

    switch (Packet->PTYPE)
        {
        case rpc_request:
            if (fExclusive)
                {
                if (Packet->pfc_flags & PFC_FIRST_FRAG
                    && CachedSCallAvailable)
                    {
                    //
                    // New call is about to be started
                    // Add a reference on the connection
                    //
                    AddReference(); // CONN++

                    CachedSCallAvailable = 0;
                    fReceivePosted = CachedSCall->BeginRpcCall(Packet, BufferLength);
                    }
                // If we are not starting a new call, make sure that the call
                // for this connection is active.
                else if (CachedSCallAvailable == false)
                    {
                    fReceivePosted = CachedSCall->ProcessReceivedPDU(Packet, BufferLength);
                    }
                //
                // Looks like we have received a request without the PFC_FIRST_FRAG, but
                // the call for this connection has been deleted and cached.  The call can't
                // be expecting this packet.
                // The only scenario in which this is expected is when a call has failed and sent
                // back a failure packet but the client has not seen it yet and continues sending.
                // In this case we can ignore the packet.
                //
                else
                    {
                    TransFreeBuffer(Packet);
                    fReceivePosted = 0;
                    goto End;
                    }
                }
            else
                {
                if ((long) Packet->call_id <= (long) CurrentCallId)
                    {
                    //
                    // If it is a non-first fragment, or if it is a callback
                    //
                    SCall = FindCall(Packet->call_id);
                    if (SCall == 0)
                        {
                        if ((long) Packet->call_id < (long) CurrentCallId
                            || (Packet->pfc_flags & PFC_FIRST_FRAG) == 0)
                            {
                            //
                            // Can't find the call. This could be because the pipe call
                            // raised an exception and the call is now complete.
                            //
                            TransFreeBuffer(Packet);
                            fReceivePosted = 0;
                            goto End;
                            }
                        //
                        // If the client is Win95, it will use the same call_id
                        // for subsequent calls on the same connection
                        //
                        }
                    }

                if (SCall == 0)
                    {
                    CurrentCallId = Packet->call_id;

                    //
                    // A new call is about to be started, create one
                    //
                    if (InterlockedCompareExchange(
                        (LPLONG) &CachedSCallAvailable, 0, 1))
                        {
                        SCall = CachedSCall;
                        }
                    else
                        {
                        Status = RPC_S_OK;

                        // Create an SCALL object.
                        // If the app verifier is enabled, we will create an object which 
                        // supports the verifier checks.
                        if (gfRPCVerifierEnabled)
                            {
                            SCall = new (ServerInfo->SendContextSize) OSF_SCALL_AVRF(this, &Status);
                            }
                        else
                            {
                            SCall = new (ServerInfo->SendContextSize) OSF_SCALL(this, &Status);
                            }

                        if (SCall == 0 || Status != RPC_S_OK)
                            {
                            SendFault(RPC_S_OUT_OF_MEMORY, 1, Packet->call_id);

                            if (SCall != 0)
                                {
                                delete SCall;
                                }

                            TransFreeBuffer(Packet);
                            break;
                            }
                        }

                    //
                    // New call is about to be started
                    // Add a reference on the connection
                    //
                    AddReference(); // CONN++

                    int DictKey;

                    ASSERT(SCall);
                    ConnMutex.Request();
                    // A new SCall/call_id will be inserted into the CallDict iff:
                    // Packet->call_id <= CurrentCallId and FindCall does not find a call OR
                    // Packet->call_id > CurrentCallId
                    // In both of these cases there is no way that an existing call can be overwritten.
                    DictKey = CallDict.Insert(ULongToPtr(Packet->call_id), SCall);
                    ConnMutex.Clear();

                    if (DictKey == -1)
                        {
                        SendFault(RPC_S_OUT_OF_MEMORY, 1, Packet->call_id);
                        FreeSCall(SCall);
                        TransFreeBuffer(Packet);
                        break;
                        }

                    ASSERT(SCall);
                    //
                    // We need this reference to prevent the call from going
                    // away from under us when the client goes away
                    //
                    SCall->AddReference();  // CALL++
                    fReceivePosted = SCall->BeginRpcCall(Packet, BufferLength);
                    SCall->OSF_SCALL::RemoveReference();  // CALL--
                    }
                else
                    {
                    ASSERT(SCall);

                    //
                    // The packet will be freed by the callee
                    //
                    fReceivePosted = SCall->ProcessReceivedPDU(Packet, BufferLength);

                    //
                    // Remove the reference added by the lookup
                    //
                    SCall->OSF_SCALL::RemoveReference(); // CALL--
                    }
                }

            break;

        case rpc_bind:
        case rpc_alter_context:
            //
            // Save the unbyteswapped header for the security related stuff
            // Especially if SECURITY is on.
            // For Bind and AlterContext we save entire packet [we can do better though]
            //
            if (Packet->auth_length != 0)
                {
                if (SavedHeaderSize < BufferLength)
                    {
                    if (SavedHeader != 0)
                        {
                        ASSERT(SavedHeaderSize != 0);
                        RpcpFarFree(SavedHeader);
                        }

                    SavedHeader = RpcpFarAllocate(BufferLength);
                    if (SavedHeader == 0)
                        {
                        if ( Association == 0 )
                            {
                            SendBindNak(
                                        protocol_version_not_supported,
                                        Packet->call_id);
                            TransFreeBuffer(Packet);
                            AbortConnection();
                            return;
                            }

                        SC_CLEANUP(RPC_S_OUT_OF_MEMORY, 1);
                        }
                    SavedHeaderSize = BufferLength;
                    RpcpMemoryCopy(SavedHeader, Packet, BufferLength);
                    }
                else
                    {
                    RpcpMemoryCopy(SavedHeader, Packet, BufferLength);
                    }
                }

            //
            // These things can take quite a while and could cause deadlocks
            // if we dont have any listening threads
            //
            Address->CreateThread();

            Status = ValidatePacket(Packet, BufferLength);
            if (Status != RPC_S_OK)
                {
                ASSERT( Status == RPC_S_PROTOCOL_ERROR );

                //
                // If this the first packet on the connection, it should be an
                // rpc_bind packet, and we want to send a rpc_bind_nak packet
                // rather than a fault.  We can tell that this is the first packet
                // because the association is zero.
                //

                if ( Association == 0 )
                    {
                    SendBindNak(protocol_version_not_supported,
                                Packet->call_id);
                    TransFreeBuffer(Packet);

                    AbortConnection();
                    return;
                    }

                //
                // It is not the first packet, so we need to send a fault instead,
                // and then we will blow the connection away.
                //

                SC_CLEANUP(RPC_S_PROTOCOL_ERROR, 1);
                }

            if (Packet->PTYPE == rpc_bind)
                {
                if (Association != 0)
                    {
                    SendBindNak(reason_not_specified_reject,
                                Packet->call_id);

                    TransFreeBuffer(Packet);
                    AbortConnection();
                    return;
                    }

                //
                // The packet will be freed by the callee
                //
                if (AssociationRequested(
                    (rpcconn_bind *) Packet, BufferLength) != 0)
                    {
                    AbortConnection();
                    return;
                    }
                }
            else
                {
                // Packet->PTYPE == rpc_alter_context per the case.
                if (Association == 0)
                    {
                    SendFault(RPC_S_PROTOCOL_ERROR, 1, Packet->call_id);
                    }

                //
                // The packet will be freed by the callee
                //
                if (AlterContextRequested(
                   (rpcconn_alter_context *) Packet,
                   BufferLength) != 0 )
                    {
                    AbortConnection();
                    return;
                    }
                }
            break;

        case rpc_auth_3:
            //
            // This means that the client sent us back a third leg
            // AuthInfo.Authentication packet.
            //
            CORRUPTION_ASSERT(AuthContinueNeeded != 0);

            // Save the unbyteswapped header
            CORRUPTION_ASSERT(AuthInfo.AuthenticationLevel
                   != RPC_C_AUTHN_LEVEL_NONE);

            AuthThirdLegPacket = (rpcconn_auth3  *) Buffer;

            if (AuthContinueNeeded == 0)
                {
                CORRUPTION_ASSERT(0);
                SC_CLEANUP(RPC_S_PROTOCOL_ERROR, 1);
                }

            // Since we have just received the third leg auth packet, we
            // are not expecting one any longer.
            AuthContinueNeeded = 0;

            if (SavedHeaderSize < BufferLength)
              {
              if (SavedHeader != 0)
                 {
                 ASSERT(SavedHeaderSize != 0);
                 RpcpFarFree(SavedHeader);
                 }

              SavedHeader = RpcpFarAllocate(BufferLength);
              if (SavedHeader == 0)
                 {
                 SC_CLEANUP(RPC_S_OUT_OF_MEMORY, 1);
                 }
              SavedHeaderSize = BufferLength;
              RpcpMemoryCopy(SavedHeader, AuthThirdLegPacket,
                                          BufferLength);
              }
            else
              {
              RpcpMemoryCopy(SavedHeader, AuthThirdLegPacket,
                                          BufferLength);
              }

            //
            // These things can take quite a while and could cause deadlocks
            // if we dont have any listening threads
            //
            Address->CreateThread();

            Status = ValidatePacket(
                                    (rpcconn_common  *) AuthThirdLegPacket,
                                    BufferLength);
            if ( Status != RPC_S_OK )
                {
                SC_CLEANUP(RPC_S_OUT_OF_MEMORY, 1);
                }

            if ( AuthThirdLegPacket->common.PTYPE != rpc_auth_3 )
                {
                SC_CLEANUP(RPC_S_OUT_OF_MEMORY, 1);
                }

            NewSecurityTrailer = (sec_trailer  *)
                    (((unsigned char  *) AuthThirdLegPacket)
                    + AuthThirdLegPacket->common.frag_length - sizeof(sec_trailer)
                    - AuthThirdLegPacket->common.auth_length);

            if (   (NewSecurityTrailer->auth_type != AuthInfo.AuthenticationService)
                || (NewSecurityTrailer->auth_level != AuthInfo.AuthenticationLevel) )
                {
                SC_CLEANUP(RPC_S_OUT_OF_MEMORY, 1);
                }

            InputBufferDescriptor.ulVersion = 0;
            InputBufferDescriptor.cBuffers = 4;
            InputBufferDescriptor.pBuffers = InputBuffers;

            InputBuffers[0].cbBuffer = sizeof(rpcconn_auth3);
            InputBuffers[0].BufferType =
                SECBUFFER_DATA | SECBUFFER_READONLY;
            InputBuffers[0].pvBuffer = SavedHeader;

            InputBuffers[1].cbBuffer =
                AuthThirdLegPacket->common.frag_length
                - sizeof(rpcconn_auth3)
                - AuthThirdLegPacket->common.auth_length;
            InputBuffers[1].BufferType =
                SECBUFFER_DATA | SECBUFFER_READONLY;
            InputBuffers[1].pvBuffer =
                (char  *) SavedHeader + sizeof(rpcconn_auth3);

            InputBuffers[2].cbBuffer = AuthThirdLegPacket->common.auth_length;
            InputBuffers[2].BufferType = SECBUFFER_TOKEN;
            InputBuffers[2].pvBuffer = NewSecurityTrailer + 1;

            InputBuffers[3].cbBuffer = sizeof(DCE_INIT_SECURITY_INFO);
            InputBuffers[3].BufferType =
                SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
            InputBuffers[3].pvBuffer = &InitSecurityInfo;

            Status = AcceptThirdLeg(
                                *((unsigned long  *)
                                  AuthThirdLegPacket->common.drep),
                                &InputBufferDescriptor, 0);

           LogEvent(SU_SCONN, EV_SEC_ACCEPT3, this, LongToPtr(Status), 0);

            if ( Status != RPC_S_OK )
                {
                SC_CLEANUP(RPC_S_OUT_OF_MEMORY, 1);
                }
            TransFreeBuffer(AuthThirdLegPacket);

            DceSecurityInfo.ReceiveSequenceNumber += 1;

            //
            // We need to figure out how much space to reserve for security
            // information at the end of request and response packets.
            // In addition to saving space for the signature or header,
            // we need space to pad the packet to a multiple of the maximum
            // security block size as well as for the security trailer.
            //
            ASSERT(AdditionalSpaceForSecurity == 0);
            AdditionalSpaceForSecurity = CalculateAdditionalSpaceForSecurity (
                AuthInfo.AuthenticationLevel,
                AuthInfo.AuthenticationService
                );
            break;

        case rpc_response:
        case rpc_cancel :
        case rpc_orphaned :
        case rpc_fault :

            if (fExclusive)
                {
                // Check if there is an active call.
                if (!CachedSCallAvailable)
                    {
                    // Response and fault are only valid for callbacks.
                    if (Packet->PTYPE == rpc_response
                        || Packet->PTYPE == rpc_fault)
                        {
                        if (CachedSCall->CallStack == 0)
                            {
                            CORRUPTION_ASSERT(0 && "Unexpected packet type");
                            SC_CLEANUP(RPC_S_PROTOCOL_ERROR, 0);                    
                            }
                        }

                    //
                    // The packet will be freed by the callee
                    //
                    fReceivePosted = CachedSCall->ProcessReceivedPDU(
                                                                     Packet, BufferLength);
                    }
                else
                    {
                    TransFreeBuffer(Packet);
                    fReceivePosted = 0;
                    goto End;
                    }
                }
            else
                {
                SCall = FindCall(Packet->call_id);
                if (SCall == 0)
                    {
                    if (Packet->PTYPE == rpc_cancel
                        || Packet->PTYPE == rpc_orphaned)
                        {
                        //
                        // Too late, looks like the call is complete
                        //
                        TransFreeBuffer(Packet);
                        }
                    else
                        {
#if DBG
                        PrintToDebugger(
                                        "RPC: Conn: 0x%lXNo SCall corresponding to the CallId: %d\n",
                                        this, Packet->call_id);
                        CORRUPTION_ASSERT(0);
#endif
                        SC_CLEANUP(RPC_S_PROTOCOL_ERROR, 0);
                        }
                    break;
                    }

                // Response and fault are only valid for callbacks.
                if (Packet->PTYPE == rpc_response
                    || Packet->PTYPE == rpc_fault)
                    {
                    if (SCall->CallStack == 0)
                        {
                        CORRUPTION_ASSERT(0 && "Unexpected packet type");
                        SC_CLEANUP(RPC_S_PROTOCOL_ERROR, 0);                    
                        }
                    }

                //
                // The packet will be freed by the callee
                //
                fReceivePosted = SCall->ProcessReceivedPDU(Packet, BufferLength);

                //
                // Remove the reference added by the lookup
                //
                SCall->OSF_SCALL::RemoveReference(); // CALL--
                }


            break;

        default:
            CORRUPTION_ASSERT(0);
            SC_CLEANUP(RPC_S_PROTOCOL_ERROR, 0);
        }

End:
    //
    // Submit the receive for the next packet
    //
    if (!fReceivePosted)
        {
        TransAsyncReceive();
        }

    //
    // Remove the reference held by the pending receive
    //
    OSF_SCONNECTION::RemoveReference(); // CONN--
    return;

Cleanup:
    SendFault(Status, fDNE, Packet->call_id);
    TransFreeBuffer(Packet);

    AbortConnection();
}


RPC_STATUS
OSF_SCONNECTION::ImpersonateClient (
    )
/*++
Function Name:ImpersonateClient

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;

    if ( !RpcSecurityBeingUsed )
        {
        Status = SetThreadSecurityContext(
                              (SECURITY_CONTEXT *) MAXUINT_PTR);
        if (RPC_S_OK != Status)
            {
            return Status;
            }

        return TransImpersonateClient();
        }

    SECURITY_CONTEXT * SecurityContext = CurrentSecurityContext;

    if (!SecurityContext)
        {
        ASSERT(SecurityContextAltered);
        return RPC_S_NO_CONTEXT_AVAILABLE;
        }

    Status = SetThreadSecurityContext(
                             SecurityContext);
    if (RPC_S_OK != Status)
        {
        return Status;
        }

    Status = SecurityContext->ImpersonateClient();
    if (RPC_S_OK != Status)
        {
        ClearThreadSecurityContext();
        }

    return Status;
}



RPC_STATUS
OSF_SCONNECTION::RevertToSelf (
    )
/*++
Function Name:RevertToSelf

Parameters:

Description:

Returns:

--*/
{
    SECURITY_CONTEXT * SecurityContext =
        ClearThreadSecurityContext();

    if (!RpcSecurityBeingUsed)
        {
        if (SecurityContext)
            {
            ASSERT(SecurityContext == (SECURITY_CONTEXT *) MAXUINT_PTR);
            TransRevertToSelf();
            }
        return RPC_S_OK;
        }

    if (SecurityContext)
        {
        SecurityContext->RevertToSelf();
        }

    return(RPC_S_OK);
}


C_ASSERT(FaultSizeWithoutEEInfo == FIELD_OFFSET(rpcconn_fault, reserved2) + sizeof(long));

void
OSF_SCONNECTION::SendFault (
    IN RPC_STATUS Status,
    IN int DidNotExecute,
    IN unsigned long CallId,
    IN p_context_id_t p_cont_id
    )
/*++
Function Name:SendFault

Parameters:

Description:

Returns:

--*/
{
    rpcconn_fault *Fault;
    size_t FaultSize;
    BOOL fEEInfoPresent = FALSE;

    if (g_fSendEEInfo)
        {
        fEEInfoPresent = PickleEEInfoIntoPacket(FaultSizeWithoutEEInfo,
            (PVOID *)&Fault,
            &FaultSize);
        }

    if (fEEInfoPresent)
        {
        Fault->reserved = FaultEEInfoPresent;
        Fault->alloc_hint = FaultSize;
        }
    else
        {
        FaultSize = FaultSizeWithoutEEInfo;
        Fault = (rpcconn_fault *)_alloca(FaultSize);
        RpcpMemorySet(Fault, 0, FaultSize);
        Fault->alloc_hint = FaultSize;
        }

    ConstructPacket((rpcconn_common *)Fault, rpc_fault, FaultSize);

    if (DidNotExecute != 0)
        {
        DidNotExecute = PFC_DID_NOT_EXECUTE;
        }

    if (Status == ERROR_SHUTDOWN_IN_PROGRESS)
        {
        if (DidNotExecute)
            {
            Status = RPC_S_SERVER_UNAVAILABLE;
            }
        else
            {
            Status = ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
        }
        }

    Fault->common.pfc_flags |= PFC_FIRST_FRAG | PFC_LAST_FRAG | DidNotExecute;
    Fault->status = MapToNcaStatusCode(Status);
    Fault->common.call_id = CallId;
    Fault->p_cont_id = p_cont_id;

    TransSend(Fault, FaultSize);

    if (fEEInfoPresent)
        delete Fault;
}

BOOL
OSF_SCONNECTION::PickleEEInfoIntoPacket (
    IN size_t PickleStartOffset,
    OUT PVOID *Packet,
    OUT size_t *PacketSize)
/*++
Function Name: PickeEEInfoIntoPacket

Parameters:
    PickleStartOffset - the offset in bytes where the pickling starts
    Packet - the allocated packet will be placed here on success.
    PacketSize - the size of the packet if success is returned. If
        failure is returned, this parameter is undefined

Description:
    Checks for EEInfo on the thread, trims the EEInfo to MaxFrag,
        allocates the packet, zeroes it out, and pickles the EEInfo
        starting from PickleStartOffset.

Returns:
    TRUE if EEInfo was pickled. FALSE if not.

--*/
{
    unsigned char *CurrentPacket;
    BOOL fEEInfoPresent = FALSE;
    ExtendedErrorInfo *EEInfo;
    RPC_STATUS RpcStatus;
    size_t CurrentPacketSize;

    EEInfo = RpcpGetEEInfo();
    if (EEInfo)
        {
        ASSERT(MaxFrag > 0);
        AddComputerNameToChain(EEInfo);
        TrimEEInfoToLength (MaxFrag, &CurrentPacketSize);
        if (CurrentPacketSize != 0)
            {
            CurrentPacketSize += PickleStartOffset;
            CurrentPacket = new unsigned char[CurrentPacketSize];

            if (CurrentPacket)
                {
                ASSERT(IsBufferAligned(CurrentPacket + PickleStartOffset));

                RpcpMemorySet(CurrentPacket, 0, CurrentPacketSize);

                RpcStatus = PickleEEInfo(EEInfo, 
                    CurrentPacket + PickleStartOffset, 
                    CurrentPacketSize - PickleStartOffset);

                if (RpcStatus == RPC_S_OK)
                    {
                    fEEInfoPresent = TRUE;
                    *Packet = CurrentPacket;
                    *PacketSize = CurrentPacketSize;
                    }
                else
                    {
                    delete [] CurrentPacket;
                    }
                }
            }
        }

    return fEEInfoPresent;
}


RPC_STATUS
OSF_SCONNECTION::SendFragment(
    IN OUT rpcconn_common  *pFragment,
    IN unsigned int LastFragmentFlag,
    IN unsigned int HeaderSize,
    IN unsigned int MaxSecuritySize,
    IN unsigned int DataLength,
    IN unsigned int MaximumFragmentLength,
    IN unsigned char  *MyReservedForSec,
    IN BOOL fAsync,
    IN void *SendContext
    )
/*++
Function Name:SendFragment

Parameters:

Description:

Returns:

--*/
{
    sec_trailer  * SecurityTrailer;
    unsigned int SecurityLength;
    unsigned int AuthPadLength;
    SECURITY_BUFFER_DESCRIPTOR BufferDescriptor;
    SECURITY_BUFFER SecurityBuffers[5];
    DCE_MSG_SECURITY_INFO MsgSecurityInfo;
    RPC_STATUS Status;
    unsigned long AuthLevel;
    ULONG ReadOnlyFlag;
    long AuthLengthChange;

    AuthLevel = AuthInfo.AuthenticationLevel;
    if (   ((AuthLevel != RPC_C_AUTHN_LEVEL_NONE)
           && (AuthLevel != RPC_C_AUTHN_LEVEL_CONNECT))
        || ((AuthLevel == RPC_C_AUTHN_LEVEL_CONNECT)
           &&(MaxSecuritySize != 0))  )
        {
        if ( LastFragmentFlag == 0 )
            {
            SecurityTrailer = (sec_trailer  *)
                    (((unsigned char  *) pFragment)
                    + MaximumFragmentLength - MaxSecuritySize);

            // It is not the last fragment, so we need to save away the
            // part of the buffer which could get overwritten with
            // authentication information.  We can not use memcpy,
            // because the source and destination regions may overlap.

            RpcpMemoryMove(MyReservedForSec, SecurityTrailer,
                    MaxSecuritySize);
            AuthPadLength = 0;
            }
        else
            {
            ASSERT( MAXIMUM_SECURITY_BLOCK_SIZE == 16 );
            AuthPadLength = Pad16(HeaderSize+DataLength+sizeof(sec_trailer));
            // Zero-out un-initialized pad.
            if (AuthPadLength != 0)
                {
                RpcpMemorySet(((unsigned char  *) pFragment) + DataLength + HeaderSize, 0, AuthPadLength);
                }
            DataLength += AuthPadLength;
            ASSERT( ((DataLength + HeaderSize+sizeof(sec_trailer))
                       % MAXIMUM_SECURITY_BLOCK_SIZE) == 0 );
            SecurityTrailer = (sec_trailer  *)
                    (((unsigned char  *) pFragment) + DataLength
                    + HeaderSize);
            pFragment->pfc_flags |= PFC_LAST_FRAG;
            }

        if (GetClientSupportsHeaderSigningFlag())
            ReadOnlyFlag = SECBUFFER_READONLY_WITH_CHECKSUM;
        else
            ReadOnlyFlag = SECBUFFER_READONLY;

        SecurityTrailer->auth_type = (unsigned char) AuthInfo.AuthenticationService;
        SecurityTrailer->auth_level = (unsigned char) AuthLevel;
        SecurityTrailer->auth_pad_length = (unsigned char) AuthPadLength;
        SecurityTrailer->auth_reserved = 0;
        SecurityTrailer->auth_context_id = AuthContextId;

        BufferDescriptor.ulVersion = 0;
        BufferDescriptor.cBuffers = 5;
        BufferDescriptor.pBuffers = SecurityBuffers;

        SecurityBuffers[0].cbBuffer = HeaderSize;
        SecurityBuffers[0].BufferType = SECBUFFER_DATA | ReadOnlyFlag;
        SecurityBuffers[0].pvBuffer = ((unsigned char  *) pFragment);

        SecurityBuffers[1].cbBuffer = (LastFragmentFlag != 0 ?
                DataLength
                : (MaximumFragmentLength - HeaderSize
                  - MaxSecuritySize ));
        SecurityBuffers[1].BufferType = SECBUFFER_DATA;
        SecurityBuffers[1].pvBuffer = ((unsigned char  *) pFragment)
                + HeaderSize;

        SecurityBuffers[2].cbBuffer = sizeof(sec_trailer);
        SecurityBuffers[2].BufferType = SECBUFFER_DATA | ReadOnlyFlag;
        SecurityBuffers[2].pvBuffer = SecurityTrailer;

        SecurityBuffers[3].cbBuffer = MaxSecuritySize - sizeof(sec_trailer);
        SecurityBuffers[3].BufferType = SECBUFFER_TOKEN;
        SecurityBuffers[3].pvBuffer = SecurityTrailer + 1;

        SecurityBuffers[4].cbBuffer = sizeof(DCE_MSG_SECURITY_INFO);
        SecurityBuffers[4].BufferType = SECBUFFER_PKG_PARAMS
                | SECBUFFER_READONLY;

        SecurityBuffers[4].pvBuffer = &MsgSecurityInfo;

        MsgSecurityInfo.SendSequenceNumber =
                DceSecurityInfo.SendSequenceNumber;
        MsgSecurityInfo.ReceiveSequenceNumber =
                DceSecurityInfo.ReceiveSequenceNumber;
        MsgSecurityInfo.PacketType = pFragment->PTYPE;

        pFragment->auth_length =  (unsigned short) SecurityBuffers[3].cbBuffer;
        SecurityLength = MaxSecuritySize;

        if ( LastFragmentFlag != 0 )
            {
            pFragment->frag_length = HeaderSize + DataLength + SecurityLength;
            }
        else
            {
            pFragment->frag_length += SecurityLength - MaxSecuritySize;
            }

        Status = CurrentSecurityContext->SignOrSeal(
                MsgSecurityInfo.SendSequenceNumber,
                AuthLevel != RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                &BufferDescriptor);

        AuthLengthChange = pFragment->auth_length - SecurityBuffers[3].cbBuffer;
        ASSERT( AuthLengthChange >= 0);

        // if the token ended up shorter than the buffer we supplied,
        // sanitize the rest of the token buffer to avoid leaking
        // process data on the wire.
        if (AuthLengthChange > 0)
            {
            RpcpMemorySet(((unsigned char *)(SecurityBuffers[3].pvBuffer)) + SecurityBuffers[3].cbBuffer,
                0,
                AuthLengthChange
                );
            }

        if (Status != RPC_S_OK)
            {
            if ( LastFragmentFlag == 0 )
                {
                RpcpMemoryCopy(SecurityTrailer, MyReservedForSec,
                                      MaxSecuritySize);
                }

            if (Status == ERROR_SHUTDOWN_IN_PROGRESS)
                {
                return Status;
                }

            if ( (Status == SEC_E_CONTEXT_EXPIRED)
               || (Status == SEC_E_QOP_NOT_SUPPORTED) )
                  {
                  return (RPC_S_SEC_PKG_ERROR);
                  }
            return (RPC_S_ACCESS_DENIED);
            }
        }
    else
        {
        SecurityLength = 0;
        }

    ASSERT(pFragment->frag_length <= MaxFrag);

    if ( LastFragmentFlag != 0 )
        {
        pFragment->pfc_flags |= PFC_LAST_FRAG;

        ASSERT(pFragment->frag_length == DataLength+HeaderSize+SecurityLength);

        if (fAsync)
            {
            Status = TransAsyncSend(
                                    pFragment,
                                    pFragment->frag_length,
                                    SendContext);

            }
        else
            {
            Status = TransSend(
                           pFragment,
                           pFragment->frag_length);
            }

        if (Status != RPC_S_OK)
            {
            if ((Status == RPC_P_CONNECTION_CLOSED)
                || (Status == RPC_P_SEND_FAILED))
                {
                return(RPC_S_CALL_FAILED_DNE);
                }
            if ( Status == RPC_P_RECEIVE_FAILED)
                {
                return(RPC_S_CALL_FAILED);
                }

            VALIDATE(Status)
                {
                RPC_S_OUT_OF_MEMORY,
                RPC_S_OUT_OF_RESOURCES
                } END_VALIDATE;
            return(Status);
            }

        return(RPC_S_OK);
        }


    ASSERT(pFragment->frag_length == MaximumFragmentLength
           - MaxSecuritySize + SecurityLength);


    if (fAsync)
        {
        Status = TransAsyncSend (
                                 pFragment,
                                 pFragment->frag_length,
                                 SendContext);

        }
    else
        {
        Status = TransSend(
                             pFragment,
                             pFragment->frag_length);

        //
        // We need to restore the part of the buffer which we overwrote
        // with authentication information.
        //
        if ((AuthLevel != RPC_C_AUTHN_LEVEL_NONE)
             &&(MaxSecuritySize != 0))
             {
             RpcpMemoryCopy(SecurityTrailer,
                            MyReservedForSec, MaxSecuritySize);
             }
        }

    if ( Status != RPC_S_OK )
        {
        if (   (Status == RPC_P_CONNECTION_CLOSED)
            || (Status == RPC_P_SEND_FAILED))
            {
            return(RPC_S_CALL_FAILED_DNE);
            }

        VALIDATE(Status)
            {
            RPC_S_OUT_OF_MEMORY,
            RPC_S_OUT_OF_RESOURCES
            } END_VALIDATE;

        return(Status);
        }

    return Status ;
}

RPC_STATUS
OSF_SCONNECTION::GetServerPrincipalName (
    IN unsigned long Flags,
    OUT RPC_CHAR **ServerPrincipalName OPTIONAL
    )
/*++

Routine Description:

    Obtains the server principal name.

Arguments:

    ServerPrincipalName - Returns the server principal name which the client
        specified.

Return Value:

    RPC_S_OK or RPC_S_* / Win32 error

--*/
{
    RPC_STATUS Status;
    SECURITY_CONTEXT * SecurityContext;

    SecurityContext = CurrentSecurityContext;

    if ( ARGUMENT_PRESENT(ServerPrincipalName) )
        {
        if (AuthInfo.AuthenticationService == RPC_C_AUTHN_GSS_SCHANNEL)
            {
            if (AuthInfo.PacHandle == 0)
                {
                Status = SecurityContext->GetDceInfo(
                                                     &AuthInfo.PacHandle,
                                                     &AuthInfo.AuthorizationService
                                                     );
                if (Status != RPC_S_OK)
                    {
                    return Status;
                    }
                }

            Status = RpcCertGeneratePrincipalName( (PCCERT_CONTEXT) AuthInfo.PacHandle,
                                                    Flags,
                                                    ServerPrincipalName
                                                    );
            return Status;

            }
        else
            {
            Status = Address->Server->InquirePrincipalName(
                    SecurityContext->AuthenticationService, ServerPrincipalName);

            VALIDATE(Status)
                {
                RPC_S_OK,
                RPC_S_OUT_OF_MEMORY
                } END_VALIDATE;
            return(Status);
            }
        }

    return RPC_S_OK;
}

UINT
OSF_SCONNECTION::CalculateAdditionalSpaceForSecurity (
    IN ULONG AuthenticationLevel,
    IN ULONG AuthenticationService
    )
/*++

Routine Description:

    Calculates how much additional space for security needs to be set
    aside.

Arguments:

    AuthenticationLevel - the authentication level for the connection. This
        parameter will be checked for validity.

    AuthenticationService - the authentication service for the connection. This
        parameter is not checked for vailidity.

Return Value:

    The additional space we need to set aside for security.

--*/
{
    UINT NewAdditionalSpaceForSecurity;

    switch (AuthenticationLevel)
        {
        case RPC_C_AUTHN_LEVEL_NONE:
            NewAdditionalSpaceForSecurity = 0;
            break;

        case RPC_C_AUTHN_LEVEL_CONNECT:
            ASSERT(CurrentSecurityContext);

            NewAdditionalSpaceForSecurity = MAXIMUM_SECURITY_BLOCK_SIZE
                + sizeof(sec_trailer);

            // we know the MS providers will not put anything meaningful in the token
            // for connect level security. Therefore we can skip both allocating space and 
            // putting anything in the token for them.
            if (AuthenticationService != RPC_C_AUTHN_WINNT
                && AuthenticationService != RPC_C_AUTHN_GSS_KERBEROS
                && AuthenticationService != RPC_C_AUTHN_GSS_NEGOTIATE
                && AuthenticationService != RPC_C_AUTHN_GSS_SCHANNEL )
                {
                NewAdditionalSpaceForSecurity += CurrentSecurityContext->MaximumSignatureLength();
                }
            break;

        case RPC_C_AUTHN_LEVEL_CALL:
        case RPC_C_AUTHN_LEVEL_PKT:
        case RPC_C_AUTHN_LEVEL_PKT_INTEGRITY:
            ASSERT(CurrentSecurityContext);

            NewAdditionalSpaceForSecurity = MAXIMUM_SECURITY_BLOCK_SIZE
                + CurrentSecurityContext->MaximumSignatureLength()
                + sizeof(sec_trailer);
            break;

        case RPC_C_AUTHN_LEVEL_PKT_PRIVACY:
            ASSERT(CurrentSecurityContext);

            NewAdditionalSpaceForSecurity = MAXIMUM_SECURITY_BLOCK_SIZE
                + CurrentSecurityContext->MaximumHeaderLength()
                + sizeof(sec_trailer);
            break;

        default:
            ASSERT(!"Unknown Security Level\n");
            NewAdditionalSpaceForSecurity = 0;
        }

    return NewAdditionalSpaceForSecurity;
}

RPC_STATUS 
OSF_SCONNECTION::EnsureSecur32DllLoaded (
    void
    )
/*++

Routine Description:

    Ensures that the secur32 dll is loaded and ready in Secur32Dll
    and that SecpSetIPAddressFnPtr is initialized.

Arguments:

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    RPC_STATUS RpcStatus;

    if (SecpSetIPAddressFnPtr != NULL)
        return RPC_S_OK;

    GlobalMutexRequest();
    if (SecpSetIPAddressFnPtr != NULL)
        {
        GlobalMutexClear();
        return RPC_S_OK;
        }

    RpcStatus = RPC_S_OK;

    // it is possible that this is loaded from a previous attempt
    ASSERT (Secur32Dll == NULL);

    Secur32Dll = new DLL (L"secur32.dll",
        &RpcStatus);

    if (Secur32Dll == NULL)
        RpcStatus = RPC_S_OUT_OF_MEMORY;
    else if (RpcStatus != RPC_S_OK)
        {
        delete Secur32Dll;
        Secur32Dll = NULL;
        // fall through with the RpcStatus
        }
    else
        {
        SecpSetIPAddressFnPtr = (SecpSetIPAddressFn) Secur32Dll->GetEntryPoint("SecpSetIPAddress");
        // we know GetEntryPoint can't fail if security exports this function. The
        // only way it can fail is if security doesn't export this function,
        // which can only be due to major config issue
        ASSERT(SecpSetIPAddressFnPtr != NULL);
        if (SecpSetIPAddressFnPtr == NULL)
            {
            delete Secur32Dll;
            Secur32Dll = NULL;
            RpcStatus = RPC_S_INTERNAL_ERROR;
            }
        // fall through with the RpcStatus
        }

    GlobalMutexClear();

    return RpcStatus;
}


RPC_STATUS
OSF_SCONNECTION::InquireAuthClient (
    OUT RPC_AUTHZ_HANDLE  * Privileges,
    OUT RPC_CHAR  *  * ServerPrincipalName, OPTIONAL
    OUT unsigned long  * AuthenticationLevel,
    OUT unsigned long  * AuthenticationService,
    OUT unsigned long  * AuthorizationService,
    IN  unsigned long Flags
    )
/*++

Routine Description:

    Each protocol module must define this routine: it is used to obtain
    the authentication and authorization information about a client making
    the remote procedure call represented by this.

Arguments:

    Privileges - Returns a the privileges of the client.

    ServerPrincipalName - Returns the server principal name which the client
        specified.

    AuthenticationLevel - Returns the authentication level requested by
        the client.

    AuthenticationService - Returns the authentication service requested by
        the client.

    AuthorizationService - Returns the authorization service requested by
        the client.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_BINDING_HAS_NO_AUTH - The remote procedure call represented by
        this binding is not authenticated.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to inquire the
        server principal name.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    SECURITY_CONTEXT * SecurityContext;

    SecurityContext = CurrentSecurityContext;
    if ( !SecurityContext )
        {
        return(RPC_S_BINDING_HAS_NO_AUTH);
        }

    if (AuthenticationLevel)
        {
        *AuthenticationLevel = SecurityContext->AuthenticationLevel;
        }

    if (AuthenticationService)
        {
        *AuthenticationService = SecurityContext->AuthenticationService;
        }

    if (Privileges || AuthorizationService)
        {
        if (AuthInfo.PacHandle == 0)
            {
            Status = SecurityContext->GetDceInfo(&AuthInfo.PacHandle,
                                                 &AuthInfo.AuthorizationService);
            }

        if ( Privileges )
            {
            *Privileges = AuthInfo.PacHandle;
            }
        if ( AuthorizationService )
            {
            *AuthorizationService = AuthInfo.AuthorizationService;
            }

        if (Status != RPC_S_OK)
            {
            return Status;
            }
        }

    Status = GetServerPrincipalName(Flags, ServerPrincipalName);

    return(Status);
}

RPC_STATUS
OSF_SCONNECTION::InquireCallAttributes (
    IN OUT void *RpcCallAttributes
    )
/*++

Routine Description:

    Inquire the security context attributes for the OSF client

Arguments:

    RpcCallAttributes - a pointer to 
        RPC_CALL_ATTRIBUTES_V1_W structure. The Version
        member must be initialized.

Return Value:

    RPC_S_OK or RPC_S_* / Win32 error. EEInfo will be returned.

--*/
{
    RPC_CALL_ATTRIBUTES_V1 *CallAttributes;
    RPC_STATUS Status;
    SECURITY_CONTEXT * SecurityContext;
    RPC_CHAR *ServerPrincipalName = NULL;
    ULONG ServerPrincipalNameLength;    // in bytes, including terminating NULL

    SecurityContext = CurrentSecurityContext;
    if ( !SecurityContext )
        {
        return(RPC_S_BINDING_HAS_NO_AUTH);
        }

    CallAttributes = 
        (RPC_CALL_ATTRIBUTES_V1 *)RpcCallAttributes;

    CallAttributes->AuthenticationLevel = SecurityContext->AuthenticationLevel;
    CallAttributes->AuthenticationService = SecurityContext->AuthenticationService;
    CallAttributes->NullSession = SecurityContext->ContextAttributes & ASC_RET_NULL_SESSION;

    if (CallAttributes->Flags & RPC_QUERY_CLIENT_PRINCIPAL_NAME)
        {
        CallAttributes->ClientPrincipalNameBufferLength = 0;
        }

    if (CallAttributes->Flags & RPC_QUERY_SERVER_PRINCIPAL_NAME)
        {
        Status = GetServerPrincipalName(CallAttributes->Flags,
            &ServerPrincipalName);

        if (Status != RPC_S_OK)
            return Status;

        if (ServerPrincipalName)
            {
            ServerPrincipalNameLength = (RpcpStringLength(ServerPrincipalName) + 1) * sizeof(RPC_CHAR);
            // now, see whether the user supplied memory is big enough
            if (CallAttributes->ServerPrincipalNameBufferLength < ServerPrincipalNameLength)
                {
                Status = ERROR_MORE_DATA;
                }
            else
                {
                // a buffer is specified, and it is large enough
                RpcpMemoryCopy(CallAttributes->ServerPrincipalName,
                    ServerPrincipalName,
                    ServerPrincipalNameLength);
                Status = RPC_S_OK;
                }

            // in both cases store the resulting length
            CallAttributes->ServerPrincipalNameBufferLength = ServerPrincipalNameLength;

            RpcStringFree(&ServerPrincipalName);
            }
        else
            {
            CallAttributes->ServerPrincipalNameBufferLength = 0;
            }
        return Status;
        }
    else
        {
        return RPC_S_OK;
        }
}

OSF_SBINDING *
OSF_SCONNECTION::LookupBinding (
   IN p_context_id_t PresentContextId
   )
/*++
Function Name:LookupBinding

Parameters:

Description:

Returns:

--*/
{
    OSF_SBINDING *CurBinding;
    DictionaryCursor cursor;

    Bindings.Reset(cursor);
    while ((CurBinding = Bindings.Next(cursor)))
        {
        if (CurBinding->GetPresentationContext() == PresentContextId)
            {
            return CurBinding;
            }
        }

    return NULL;
}

RPC_STATUS
OSF_SCONNECTION::GetAssociationContextCollection (
    OUT ContextCollection **CtxCollection
    )
{
    return Association->GetAssociationContextCollection(CtxCollection);
}


RPC_STATUS
OSF_SCONNECTION::IsClientLocal (
    OUT unsigned int  * ClientLocalFlag
    )
/*++

Routine Description:

    We just need to inquire the client process identifier for this
    connection; if the first part is zero, then the client is local.

Arguments:

    ClientLocalFlag - Returns an indication of whether or not the client is
        local (ie. on the same machine as the server).  This field will be
        set to a non-zero value to indicate that the client is local;
        otherwise, the client is remote.

Return Value:

    RPC_S_OK - This will always be used.

--*/
{
    RPC_CLIENT_PROCESS_IDENTIFIER ClientProcess;
    int i;

    TransQueryClientProcess(&ClientProcess);

    if ( ClientProcess.IsLocal() == FALSE )
        {
        if (ClientProcess.IsNull())
            return RPC_S_CANNOT_SUPPORT;

        *ClientLocalFlag = 0;
        }
    else
        {
        *ClientLocalFlag = 1;
        }

    return(RPC_S_OK);
}

int
OSF_SCONNECTION::SendBindNak (
    IN p_reject_reason_t reject_reason,
    IN unsigned long CallId
    )
{
    rpcconn_bind_nak *BindNak;
    size_t BindNakSize;
    BOOL fEEInfoPresent = FALSE;
    int RetVal;

    if (g_fSendEEInfo)
        {
        fEEInfoPresent = PickleEEInfoIntoPacket(BindNakSizeWithoutEEInfo,
            (PVOID *) &BindNak,
            &BindNakSize);
        }

    if (fEEInfoPresent == FALSE)
        {
        BindNakSize = BindNakSizeWithoutEEInfoAndSignature;
        BindNak = (rpcconn_bind_nak *)_alloca(BindNakSize);
        RpcpMemorySet(BindNak, 0, BindNakSize);
        }
    else
        {
        RpcpMemoryCopy (&BindNak->Signature, 
            BindNakEEInfoSignature,
            sizeof (UUID));
        }

    ConstructPacket((rpcconn_common *) BindNak, rpc_bind_nak, BindNakSize);
    BindNak->provider_reject_reason = reject_reason;
    BindNak->versions.n_protocols = 1;
    BindNak->versions.p_protocols[0].major = OSF_RPC_V20_VERS;
    BindNak->versions.p_protocols[0].minor = 0;
    BindNak->common.call_id = CallId;
    BindNak->common.pfc_flags = PFC_FIRST_FRAG | PFC_LAST_FRAG ;

    if (TransSend(BindNak,BindNakSize))
        {
        RetVal = -1;
        }
    else
        {
        RetVal = 0;
        }

    if (fEEInfoPresent)
        {
        delete BindNak;
        }

    return RetVal;
}

typedef struct tagSelectedInterfaceAndTransferSyntaxInfo
{
    RPC_INTERFACE *Interface;
    int SelectedAvailableTransferSyntaxIndex;
} SelectedInterfaceAndTransferSyntaxInfo;

int
OSF_SCONNECTION::ProcessPContextList (
    IN OSF_ADDRESS * Address,
    IN p_cont_list_t *PContextList,
    IN OUT unsigned int * PContextListLength,
    OUT p_result_list_t *ResultList
    )
/*++

Routine Description:

Arguments:

    Address - Supplies the address which owns this connection.  We need
        this information so that we can try to find the interface (and
        transfer syntax) the client requested.

    PContextList - Supplies a pointer to the presentation context list
        which the client passed in the rpc_bind packet.  It has not yet
        had data conversion performed on it.

    PContextListLength - Supplies the maximum possible length of the
        presentation context list, and returns its actual length.  The
        lengths are in bytes as usual.

    ResultList - Returns the result list corresponding to the presentation
        context list.

Return Value:

    A non-zero value will be returned if we are unable to process the
    presentation context list.  The caller should send an rpc_bind_nak
    packet to the client, and then close the connection.

--*/
{
    p_cont_elem_t *PContextElem;
    unsigned int PContextListIndex;
    unsigned int TransferSyntaxIndex;
    SelectedInterfaceAndTransferSyntaxInfo *SelectionInfo;
    OSF_SBINDING * SBinding;
    RPC_STATUS Status;
    BOOL fInterfaceTransferIsPreferred;
    p_result_t *PResultElem;
    int PreferredPContextIndex;
    BOOL fRejectCurrentContext;
    BOOL fPContextAlreadyAccepted;
    unsigned int NumberOfPContextElements;
    int fIgnored;

    if (*PContextListLength < sizeof(p_cont_list_t))
        {
        return(1);
        }

    NumberOfPContextElements = (unsigned int) PContextList->n_context_elem;

    // make sure the client doesn't offer a gaziliion pcontexts
    if (NumberOfPContextElements > MAX_N_CONTEXT_ELEM)
        {
        ASSERT(NumberOfPContextElements < MAX_N_CONTEXT_ELEM);
        return 1;
        }

    //
    // The function is called on a bind and when an alter context is received.
    // There is a bound on the number of times the client can alter context.  The
    // bound is num_interfaces * MaximumNumberOfTransferSyntaxes(2)
    // * MAX_NUM_INTERFACE_VERSIONS(20) * MAX_NUM_IDENTICAL_ALTER_CONTEXTS (100)
    // We should check to make sure the number of alter contexts on this connection does
    // not exceed this.  The number of alter contexts received is just the size of the dict.
    //
    if (Bindings.Size() >
        GlobalRpcServer->InquireInterfaceCount()
        * MaximumNumberOfTransferSyntaxes
        * MAX_NUM_INTERFACE_VERSIONS
        * MAX_NUM_IDENTICAL_ALTER_CONTEXTS)
        {
        ASSERT(Bindings.Size() <=
               GlobalRpcServer->InquireInterfaceCount()
               * MaximumNumberOfTransferSyntaxes
               * MAX_NUM_INTERFACE_VERSIONS
               * MAX_NUM_IDENTICAL_ALTER_CONTEXTS);
        return 1;
        }

    SelectionInfo = (SelectedInterfaceAndTransferSyntaxInfo *)
        _alloca(sizeof(SelectedInterfaceAndTransferSyntaxInfo) * NumberOfPContextElements);

    *PContextListLength -= (sizeof(p_cont_list_t) - sizeof(p_cont_elem_t));
    ResultList->n_results = PContextList->n_context_elem;
    ResultList->reserved = 0;
    ResultList->reserved2 = 0;

    ASSERT(NumberOfPContextElements > 0);
    // We do not need to bother with un-initialized fields since we always return
    // at least 1 element.

    PreferredPContextIndex = -1;

    for (PContextListIndex = 0, PContextElem = PContextList->p_cont_elem;
         PContextListIndex < NumberOfPContextElements;
         PContextListIndex ++)
        {
        if (*PContextListLength < sizeof(p_cont_elem_t))
            {
            return(1);
            }

        if (*PContextListLength < (sizeof(p_cont_elem_t) + sizeof(p_syntax_id_t)
                * (PContextElem->n_transfer_syn - 1)))
            {
            return(1);
            }

        *PContextListLength -= (sizeof(p_cont_elem_t) + sizeof(p_syntax_id_t)
                * (PContextElem->n_transfer_syn - 1));

        if ( DataConvertEndian(((unsigned char *) &DataRep)) != 0 )
            {
            PContextElem->p_cont_id = RpcpByteSwapShort(PContextElem->p_cont_id);
            ByteSwapSyntaxId(&PContextElem->abstract_syntax);
            for ( TransferSyntaxIndex = 0;
                    TransferSyntaxIndex < PContextElem->n_transfer_syn;
                    TransferSyntaxIndex++ )
                {
                ByteSwapSyntaxId(&(PContextElem->transfer_syntaxes[
                        TransferSyntaxIndex]));
                }
            }

        Status = Address->FindInterfaceTransfer(
                (PRPC_SYNTAX_IDENTIFIER)
                &PContextElem->abstract_syntax.if_uuid,
                (PRPC_SYNTAX_IDENTIFIER) PContextElem->transfer_syntaxes,
                PContextElem->n_transfer_syn,
                (PRPC_SYNTAX_IDENTIFIER)
                &(ResultList->p_results[PContextListIndex].transfer_syntax),
                &SelectionInfo[PContextListIndex].Interface,
                &fInterfaceTransferIsPreferred,
                &fIgnored,
                &SelectionInfo[PContextListIndex].SelectedAvailableTransferSyntaxIndex);

        if (Status == RPC_S_OK)
            {
            ResultList->p_results[PContextListIndex].result = acceptance;
            ResultList->p_results[PContextListIndex].reason = 0;

            if (fInterfaceTransferIsPreferred)
                {
                // only one pcontext can be preferred. If not, there is
                // error in the stubs
                ASSERT(PreferredPContextIndex == -1);
                PreferredPContextIndex = PContextListIndex;
                }

            // for all accepted we will make a second pass once we know
            // which transfer syntax will be selected
            }
        else
            {
            ResultList->p_results[PContextListIndex].result =
                            provider_rejection;
            if (Status == RPC_S_UNSUPPORTED_TRANS_SYN)
                {
                ResultList->p_results[PContextListIndex].reason =
                                proposed_transfer_syntaxes_not_supported;
                }
            else
                {
                ASSERT(Status == RPC_S_UNKNOWN_IF);
                ResultList->p_results[PContextListIndex].reason =
                                abstract_syntax_not_supported;
                }

            memset(&(ResultList->p_results[PContextListIndex].
                    transfer_syntax.if_uuid.Data1),0,sizeof(GUID));
            ResultList->p_results[PContextListIndex].
                            transfer_syntax.if_version = 0;
            }

        PContextElem = (p_cont_elem_t *) ((unsigned char *)PContextElem + sizeof(p_cont_elem_t)
            + sizeof(p_syntax_id_t) * (PContextElem->n_transfer_syn - 1));
        }

    fPContextAlreadyAccepted = FALSE;
    for (PContextListIndex = 0, PResultElem = ResultList->p_results,
        PContextElem = PContextList->p_cont_elem;
        PContextListIndex < NumberOfPContextElements;
        PContextListIndex ++, PResultElem = &(ResultList->p_results[PContextListIndex]))
        {
        fRejectCurrentContext = TRUE;

        // if there is a preferred context ...
        if (PreferredPContextIndex >= 0)
            {
            // ... and this is the one, don't reject it
            if ((unsigned int)PreferredPContextIndex == PContextListIndex)
                {
                ASSERT(PResultElem->result == acceptance);
                fRejectCurrentContext = FALSE;
                }
            else
                {
                // else nothing - this is not the preferred one, and the
                // default action is reject it
                }
            }
        else if (PResultElem->result == acceptance)
            {
            // if we haven't already accepted one, accept the current
            if (!fPContextAlreadyAccepted)
                {
                fRejectCurrentContext = FALSE;
                fPContextAlreadyAccepted = TRUE;
                }
            else
                {
                // else nothing - we have already accepted one and
                // we will reject this one
                }
            }

        if (!fRejectCurrentContext)
            {
            SBinding = new OSF_SBINDING(SelectionInfo[PContextListIndex].Interface,
                    PContextElem->p_cont_id,
                    SelectionInfo[PContextListIndex].SelectedAvailableTransferSyntaxIndex);

            if (   (SBinding == 0)
                || (Bindings.Insert(SBinding) == -1))
                {
                if (SBinding != 0)
                    delete SBinding;

                PResultElem->result = provider_rejection;
                PResultElem->reason = local_limit_exceeded;
                memset(&(PResultElem->transfer_syntax.if_uuid.Data1), 0, sizeof(p_syntax_id_t));
                }
            }
        else if (PResultElem->result == acceptance)
            {
            // apparently we have already accepted somebody, and this is not the
            // lucky one
            PResultElem->result = provider_rejection;
            PResultElem->reason = proposed_transfer_syntaxes_not_supported;
            memset(&(PResultElem->transfer_syntax.if_uuid.Data1), 0, sizeof(p_syntax_id_t));
            }
        else
            {
            // nothing - we have to reject the current one, and it has already
            // been rejected
            }

        PContextElem = (p_cont_elem_t *) ((unsigned char *)PContextElem + sizeof(p_cont_elem_t)
            + sizeof(p_syntax_id_t) * (PContextElem->n_transfer_syn - 1));
        }

    return(0);
}

unsigned short // Return the minimum of the three arguments.
MinOf (
    IN unsigned short Arg1,
    IN unsigned short Arg2,
    IN unsigned short Arg3
    )
{
    unsigned short Min = 0xFFFF;

    if (Arg1 < Min)
        Min = Arg1;
    if (Arg2 < Min)
        Min = Arg2;
    if (Arg3 < Min)
        Min = Arg3;
    return(Min);
}

int
OSF_SCONNECTION::AssociationRequested (
    IN rpcconn_bind * BindPacket,
    IN unsigned int BindPacketLength
    )
/*++

Routine Description:

Arguments:

    Address - Supplies the address which owns this connection.

    BindPacket - Supplies the buffer containing the rpc_bind packet
        received from the client.

    BindPacketLength - Supplies the length of the buffer in bytes.

Return Value:

    A non-zero return value indicates that the connection needs to
    be deleted by the caller.

--*/
{
    p_cont_list_t * PContextList;
    unsigned int SecondaryAddressLength;
    unsigned int BindAckLength, TokenLength = 0, NewSecurityTrailerOffset;
    rpcconn_bind_ack * BindAck;
    RPC_STATUS Status;
    sec_trailer  * SecurityTrailer,  * NewSecurityTrailer;
    SECURITY_CREDENTIALS * SecurityCredentials = 0;
    RPC_CLIENT_PROCESS_IDENTIFIER ClientProcess;
    unsigned int CompleteNeeded = 0;
    SECURITY_BUFFER_DESCRIPTOR InputBufferDescriptor;
    SECURITY_BUFFER_DESCRIPTOR OutputBufferDescriptor;
    SECURITY_BUFFER InputBuffers[4];
    SECURITY_BUFFER OutputBuffers[4];
    unsigned long CallId = BindPacket->common.call_id;
    ULONG CalculatedSize;

    PContextList = (p_cont_list_t *) (BindPacket + 1);

    CalculatedSize = sizeof(rpcconn_bind)+sizeof(p_cont_list_t)
                        + (PContextList->n_context_elem-1)*sizeof(p_cont_elem_t);

    // Sanity-check the bind packet.
    if ( BindPacketLength < CalculatedSize
         || PContextList->n_context_elem < 1 )
        {
        TransFreeBuffer(BindPacket);
        SendBindNak(reason_not_specified_reject, CallId);
        return(1);
        }

    DataRep = * (unsigned long  *) BindPacket->common.drep;

    if ( DataConvertEndian(BindPacket->common.drep) != 0 )
        {
        BindPacket->max_xmit_frag = RpcpByteSwapShort(BindPacket->max_xmit_frag);
        BindPacket->max_recv_frag = RpcpByteSwapShort(BindPacket->max_recv_frag);
        BindPacket->assoc_group_id = RpcpByteSwapLong(BindPacket->assoc_group_id);
        }

    ASSERT(TransMaximumSend() % 8 == 0);

    MaxFrag = MinOf(BindPacket->max_xmit_frag,
                    BindPacket->max_recv_frag,
                    (unsigned short) TransMaximumSend()) & 0xFFFFFFF8;

    if ( MaxFrag < MUST_RECV_FRAG_SIZE )
        MaxFrag = MUST_RECV_FRAG_SIZE;

    ASSERT(MaxFrag % 8 == 0);

    // Now we need to check to see if we should be performing authentication
    // at the rpc protocol level.  This will be the case if there is
    // authentication information in the packet.

    if ( BindPacket->common.auth_length != 0 )
        {
        // Ok, we have got authentication information in the packet.  We
        // will save away the information, and then check it.

        SecurityTrailer = (sec_trailer  *)
                (((unsigned char  *) BindPacket) + BindPacketLength
                - BindPacket->common.auth_length - sizeof(sec_trailer));


        AuthInfo.AuthenticationLevel = SecurityTrailer->auth_level;

        //Hack for OSF Clients
        //If Level is CALL .. bump it ip to CONNECT
        if (AuthInfo.AuthenticationLevel == RPC_C_AUTHN_LEVEL_CALL)
           {
           AuthInfo.AuthenticationLevel = RPC_C_AUTHN_LEVEL_PKT;
           }
        if (   (AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_CONNECT)
            && (AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_PKT)
            && (AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
            && (AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_PKT_PRIVACY) )
            {
            TransFreeBuffer(BindPacket);
            SendBindNak(reason_not_specified_reject, CallId);
            return(1);
            }
        AuthInfo.AuthenticationService = SecurityTrailer->auth_type;
        AuthContextId = SecurityTrailer->auth_context_id;

        if ( DataConvertEndian(BindPacket->common.drep) != 0 )
            {
            AuthContextId = RpcpByteSwapLong(AuthContextId);
            }

        RPC_STATUS Status = RPC_S_OK;
        CurrentSecurityContext = new SECURITY_CONTEXT(
                                             &AuthInfo,
                                             AuthContextId,
                                             FALSE,
                                             &Status
                                             );

        if ( (CurrentSecurityContext == 0)
           || RPC_S_OK != Status)
            {
            if (CurrentSecurityContext != 0)
                {
                delete CurrentSecurityContext;
                }
            TransFreeBuffer(BindPacket);
            SendBindNak(local_limit_exceeded_reject, CallId);
            return(1);
            }
        if (SecurityContextDict.Insert(CurrentSecurityContext) == -1)
            {
            delete CurrentSecurityContext;
            TransFreeBuffer(BindPacket);
            SendBindNak(local_limit_exceeded_reject, CallId);
            return(1);
            }

        CallTestHook( TH_RPC_SECURITY_SERVER_CONTEXT_CREATED, CurrentSecurityContext, this );

        RpcSecurityBeingUsed = 1;
        Status = Address->Server->AcquireCredentials(
                AuthInfo.AuthenticationService, AuthInfo.AuthenticationLevel,
                &SecurityCredentials);
        if ( Status == RPC_S_OUT_OF_MEMORY )
            {
            TransFreeBuffer(BindPacket);
            SendBindNak(local_limit_exceeded_reject, CallId);
            return(1);
            }
        if ( Status != RPC_S_OK )
            {
            TransFreeBuffer(BindPacket);
            RpcpErrorAddRecord(EEInfoGCRuntime,
                Status,
                EEInfoDLAssociationRequested30,
                AuthInfo.AuthenticationService,
                AuthInfo.AuthenticationLevel);
            SendBindNak(authentication_type_not_recognized, CallId);
            return(1);
            }
        ASSERT( SecurityCredentials != 0 );
        }

    // Calculate the size of the rpc_bind_ack packet.
    // sizeof(rpcconn_bind_ack) = 26, so we may need to add 2 bytes to get it aligned
    // on a 4-byte bound.
    SecondaryAddressLength = Address->TransSecondarySize();
    BindAckLength = sizeof(rpcconn_bind_ack) + SecondaryAddressLength
                    + Pad4(SecondaryAddressLength + 2) + sizeof(p_result_list_t)
                    + sizeof(p_result_t) * (PContextList->n_context_elem - 1);

    // BindAckLength should be 4-byte aligned:
    // (mod 4) BindAckLength = 2 + x - (x+2) + 0 + 0 * y = 2 + x - x - 2 = 0
    ASSERT(Pad4(BindAckLength) == 0);

    // We need to save some space for authentication information if
    // necessary.  This includes space for the token, the security trailer,
    // and alignment if necessary.
    if ( SecurityCredentials != 0 )
        {
        NewSecurityTrailerOffset = BindAckLength;
        BindAckLength += SecurityCredentials->MaximumTokenLength()
                         + sizeof(sec_trailer);
        }

    // BindAckLength may exceed MaxFrag negotiated if the token is
    // large enough.

    // Allocate the rpc_bind_ack packet.  If that fails, send a rpc_bind_nak
    // to the client indicating that the server is out of resources;
    // whoever called AssociationRequested will take care of cleaning up
    // the connection.

    Status = TransGetBuffer((void **) &BindAck, BindAckLength);
    if ( Status != RPC_S_OK )
        {
        ASSERT( Status == RPC_S_OUT_OF_MEMORY );

        if ( SecurityCredentials != 0 )
            {
            SecurityCredentials->DereferenceCredentials();
            }
        TransFreeBuffer(BindPacket);
        SendBindNak(local_limit_exceeded_reject, CallId);
        return(1);
        }

    // Finally we get to do something about that authentication that the
    // client sent us.

    if ( SecurityCredentials != 0 )
        {
        NewSecurityTrailer = (sec_trailer  *)
                (((unsigned char  *) BindAck) + NewSecurityTrailerOffset);

        InitSecurityInfo.DceSecurityInfo = DceSecurityInfo;
        InitSecurityInfo.PacketType = BindPacket->common.PTYPE;
        InputBufferDescriptor.ulVersion = 0;
        InputBufferDescriptor.cBuffers = 4;
        InputBufferDescriptor.pBuffers = InputBuffers;

        InputBuffers[0].cbBuffer = sizeof(rpcconn_bind);
        InputBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        InputBuffers[0].pvBuffer = SavedHeader;

        InputBuffers[1].cbBuffer = BindPacket->common.frag_length
                - sizeof(rpcconn_bind) - BindPacket->common.auth_length;
        InputBuffers[1].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        InputBuffers[1].pvBuffer = (char *) SavedHeader +
                                            sizeof(rpcconn_bind);

        InputBuffers[2].cbBuffer = BindPacket->common.auth_length;
        InputBuffers[2].BufferType = SECBUFFER_TOKEN;
        InputBuffers[2].pvBuffer = SecurityTrailer + 1;
        InputBuffers[3].cbBuffer = sizeof(DCE_INIT_SECURITY_INFO);
        InputBuffers[3].BufferType = SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
        InputBuffers[3].pvBuffer = &InitSecurityInfo;

        OutputBufferDescriptor.ulVersion = 0;
        OutputBufferDescriptor.cBuffers = 4;
        OutputBufferDescriptor.pBuffers = OutputBuffers;

        OutputBuffers[0].cbBuffer = sizeof(rpcconn_bind_ack)
                - sizeof(unsigned short);
        OutputBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        OutputBuffers[0].pvBuffer = BindAck;
        OutputBuffers[1].cbBuffer = BindAckLength
                - SecurityCredentials->MaximumTokenLength()
                - (sizeof(rpcconn_bind_ack) - sizeof(unsigned short));
        OutputBuffers[1].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        OutputBuffers[1].pvBuffer = ((unsigned char *) BindAck)
            + sizeof(rpcconn_bind_ack) - sizeof(unsigned short);
        OutputBuffers[2].cbBuffer = SecurityCredentials->MaximumTokenLength();
        OutputBuffers[2].BufferType = SECBUFFER_TOKEN;
        OutputBuffers[2].pvBuffer = NewSecurityTrailer + 1;
        OutputBuffers[3].cbBuffer = sizeof(DCE_INIT_SECURITY_INFO);
        OutputBuffers[3].BufferType = SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
        OutputBuffers[3].pvBuffer = &InitSecurityInfo;

        Status = AcceptFirstTime(
                               SecurityCredentials,
                               &InputBufferDescriptor,
                               &OutputBufferDescriptor,
                               SecurityTrailer->auth_level,
                               *((unsigned long  *) BindPacket->common.drep),
                               0);

        LogEvent(SU_SCONN, EV_SEC_ACCEPT1, this, LongToPtr(Status), OutputBuffers[2].cbBuffer);

#if 0
        if (Status == SEC_E_BUFFER_TOO_SMALL)
            {
            unsigned long NewTokenLength = OutputBuffers[2].cbBuffer;

            TransFreeBuffer( BindAck );

            BindAckLength = sizeof(rpcconn_bind_ack) + SecondaryAddressLength
                            + Pad4(SecondaryAddressLength + 2) + sizeof(p_result_list_t)
                            + sizeof(p_result_t) * (PContextList->n_context_elem - 1);

            // BindAckLength should be 4-byte aligned.
            ASSERT(Pad4(BindAckLength) == 0);

            NewSecurityTrailerOffset = BindAckLength;
            BindAckLength += NewTokenLength
                             + sizeof(sec_trailer);

            // BindAckLength may exceed MaxFrag negotiated if the token
            // is large enough.

            Status = TransGetBuffer((void **) &BindAck, BindAckLength);
            if ( Status != RPC_S_OK )
                {
                ASSERT( Status == RPC_S_OUT_OF_MEMORY );

                SecurityCredentials->DereferenceCredentials();

                TransFreeBuffer(BindPacket);
                SendBindNak(local_limit_exceeded_reject, CallId);
                return(1);
                }

            NewSecurityTrailer = (sec_trailer  *)
                    (((unsigned char  *) BindAck) + NewSecurityTrailerOffset);

            OutputBufferDescriptor.ulVersion = 0;
            OutputBufferDescriptor.cBuffers = 4;
            OutputBufferDescriptor.pBuffers = OutputBuffers;

            OutputBuffers[0].cbBuffer = sizeof(rpcconn_bind_ack)
                    - sizeof(unsigned short);
            OutputBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
            OutputBuffers[0].pvBuffer = BindAck;
            OutputBuffers[1].cbBuffer = BindAckLength
                    - NewTokenLength
                    - (sizeof(rpcconn_bind_ack) - sizeof(unsigned short));
            OutputBuffers[1].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
            OutputBuffers[1].pvBuffer = ((unsigned char *) BindAck)
                + sizeof(rpcconn_bind_ack) - sizeof(unsigned short);
            OutputBuffers[2].cbBuffer = NewTokenLength;
            OutputBuffers[2].BufferType = SECBUFFER_TOKEN;
            OutputBuffers[2].pvBuffer = NewSecurityTrailer + 1;
            OutputBuffers[3].cbBuffer = sizeof(DCE_INIT_SECURITY_INFO);
            OutputBuffers[3].BufferType = SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
            OutputBuffers[3].pvBuffer = &InitSecurityInfo;

            Status = AcceptFirstTime(
                                   SecurityCredentials,
                                   &InputBufferDescriptor,
                                   &OutputBufferDescriptor,
                                   SecurityTrailer->auth_level,
                                   *((unsigned long  *) BindPacket->common.drep),
                                   0);

            LogEvent(SU_SCONN, EV_SEC_ACCEPT1, this, (void *) Status, OutputBuffers[2].cbBuffer);

            }
#endif

        TokenLength = (unsigned int) OutputBuffers[2].cbBuffer;

        if (   ( Status == RPC_P_CONTINUE_NEEDED )
            || ( Status == RPC_S_OK )
            || ( Status == RPC_P_COMPLETE_NEEDED )
            || ( Status == RPC_P_COMPLETE_AND_CONTINUE ) )
            {
            if ( Status == RPC_P_CONTINUE_NEEDED )
                {
                AuthContinueNeeded = 1;
                }
            else if ( Status == RPC_P_COMPLETE_AND_CONTINUE )
                {
                AuthContinueNeeded = 1;
                CompleteNeeded = 1;
                }
            else if ( Status == RPC_P_COMPLETE_NEEDED )
                {
                CompleteNeeded = 1;
                }

            BindAckLength = BindAckLength + TokenLength
                    - SecurityCredentials->MaximumTokenLength();

            NewSecurityTrailer->auth_type = SecurityTrailer->auth_type;
            NewSecurityTrailer->auth_level = SecurityTrailer->auth_level;
            NewSecurityTrailer->auth_pad_length = 0;
            NewSecurityTrailer->auth_reserved = 0;
            NewSecurityTrailer->auth_context_id = AuthContextId;

            SecurityCredentials->DereferenceCredentials();
            }
        else
            {
            VALIDATE(Status)
                {
                RPC_S_OUT_OF_MEMORY,
                RPC_S_ACCESS_DENIED,
                ERROR_SHUTDOWN_IN_PROGRESS,
                RPC_S_UNKNOWN_AUTHN_SERVICE
                } END_VALIDATE;

            TransFreeBuffer(BindPacket);
            TransFreeBuffer(BindAck);
            SecurityCredentials->DereferenceCredentials();

            if (Status == RPC_S_OUT_OF_MEMORY)
                {
                SendBindNak(local_limit_exceeded_reject, CallId);
                }
            else
            if (Status == RPC_S_UNKNOWN_AUTHN_SERVICE ||
                Status == ERROR_SHUTDOWN_IN_PROGRESS )
                {
                SendBindNak(authentication_type_not_recognized, CallId);
                }
            else
                {
                SendBindNak(invalid_checksum, CallId);
                }
            return(1);
            }
        }


    TransQueryClientProcess(&ClientProcess);

    if ( BindPacket->assoc_group_id != 0 )
        {
        // This means this is a connection on an existing association.

        Association = Address->FindAssociation(
                (int) BindPacket->assoc_group_id, &ClientProcess);

        if ( Association == 0 )
            {
            RpcpErrorAddRecord (EEInfoGCRuntime,
                RPC_S_ENTRY_NOT_FOUND,
                EEInfoDLAssociationRequested10,
                BindPacket->assoc_group_id,
                ClientProcess.GetDebugULongLong1(),
                ClientProcess.GetDebugULongLong2());

            TransFreeBuffer(BindPacket);
            TransFreeBuffer(BindAck);
            SendBindNak(reason_not_specified_reject, CallId);
            return(1);
            }
        }
    if ( Association == 0 )
        {
        Association = new OSF_ASSOCIATION(Address, &ClientProcess, &Status);
        if ( (Association == 0) || (Status != RPC_S_OK) )
            {
            if (Association != 0)
                {
                delete Association;
                Association = NULL;
                }
            TransFreeBuffer(BindPacket);
            TransFreeBuffer(BindAck);
            RpcpErrorAddRecord (EEInfoGCRuntime,
                Status,
                EEInfoDLAssociationRequested20,
                sizeof(OSF_ASSOCIATION));
            SendBindNak(local_limit_exceeded_reject, CallId);
            return(1);
            }
        }

    BindPacketLength -= sizeof(rpcconn_bind);
    if ( ProcessPContextList(Address, PContextList, &BindPacketLength,
            (p_result_list_t *) (((unsigned char *) BindAck) + sizeof(rpcconn_bind_ack)
            + SecondaryAddressLength + Pad4(SecondaryAddressLength + 2))) != 0 )
        {
        TransFreeBuffer(BindPacket);
        TransFreeBuffer(BindAck);
        SendBindNak(reason_not_specified_reject, CallId);
        return(1);
        }

    // Fill in the header of the rpc_bind_ack packet.

    ConstructPacket((rpcconn_common *) BindAck, rpc_bind_ack, BindAckLength);

    BindAck->max_xmit_frag = BindAck->max_recv_frag = MaxFrag;
    BindAck->assoc_group_id = Association->AssocGroupId();
    BindAck->sec_addr_length = (unsigned short) SecondaryAddressLength;
    BindAck->common.call_id = CallId;

    if (PFC_CONC_MPX & BindPacket->common.pfc_flags)
        {
        ((rpcconn_common  *) BindAck)->pfc_flags |=
            (PFC_FIRST_FRAG | PFC_LAST_FRAG | PFC_CONC_MPX) ;
        }
    else
        {
        fExclusive = 1;
        ((rpcconn_common  *) BindAck)->pfc_flags |=
            (PFC_FIRST_FRAG | PFC_LAST_FRAG) ;
        }

    // if caller supports header signing, tell it that we also support it.
    if (BindPacket->common.pfc_flags & PFC_SUPPORT_HEADER_SIGN)
        {
        ((rpcconn_common  *) BindAck)->pfc_flags |= PFC_SUPPORT_HEADER_SIGN;
        SetClientSupportsHeaderSigningFlag();
        }

    DceSecurityInfo.ReceiveSequenceNumber += 1;

    if ( SecondaryAddressLength != 0 )
        {
        Status = Address->TransSecondary((unsigned char *) (BindAck + 1),
                                 SecondaryAddressLength);
        if (Status != RPC_S_OK)
            {
            ASSERT(Status == RPC_S_OUT_OF_MEMORY);
            TransFreeBuffer(BindPacket);
            TransFreeBuffer(BindAck);
            SendBindNak(reason_not_specified_reject, CallId);
            return(1);
            }
        }

    // The result list has already been filled in by ProcessPContextList.
    // All that is left to do, is fill in the authentication information.

    BindAck->common.auth_length = (unsigned short) TokenLength;

    // Send the rpc_bind_ack packet back to the client.

    TransFreeBuffer(BindPacket);

    if ( CompleteNeeded != 0 )
        {
        Status = CurrentSecurityContext->CompleteSecurityToken(
                                              &OutputBufferDescriptor);
        if (Status != RPC_S_OK)
            {
            TransFreeBuffer(BindAck);
            SendBindNak(invalid_checksum, CallId);
            return(1);
            }
        }

    //
    // We may need to do third leg AuthInfo.Authentication.
    // we will do that when we receive the third leg packet
    //
    if ( AuthContinueNeeded == 0 )
        {
        //
        // We need to figure out how much space to reserve for security
        // information at the end of request and response packets.
        // In addition to saving space for the signature or header,
        // we need space to pad the packet to a multiple of the maximum
        // security block size as well as for the security trailer.
        //

        //
        // In the case where we need a third leg, this information will be obtained
        // after we process the third leg packet.
        //
        ASSERT(AdditionalSpaceForSecurity == 0);

        AdditionalSpaceForSecurity = CalculateAdditionalSpaceForSecurity (
            AuthInfo.AuthenticationLevel,
            AuthInfo.AuthenticationService
            );
        }

    //
    // Sending the bind ack should be the last thing we do
    // in this function. The action will continue in the processing
    // of the third leg.
    //
    Status = TransSend(BindAck, BindAckLength);
    TransFreeBuffer(BindAck);
    if ( Status != RPC_S_OK )
        {
        return(1);
        }

    if (DebugCell)
        {
        DWORD LocalFlags = 0;

        if (AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE)
            {
            LocalFlags = AuthInfo.AuthenticationLevel << 1;
            switch (AuthInfo.AuthenticationService)
                {
                case RPC_C_AUTHN_WINNT:
                    LocalFlags |= DBGCELL_AUTH_SVC_NTLM;
                    break;

                case RPC_C_AUTHN_GSS_KERBEROS:
                case RPC_C_AUTHN_GSS_NEGOTIATE:
                    LocalFlags |= DBGCELL_AUTH_SVC_KERB;
                    break;

                default:
                    ASSERT(AuthInfo.AuthenticationService);
                    LocalFlags |= DBGCELL_AUTH_SVC_OTHER;
                }
            }

        if (fExclusive)
            LocalFlags |= 1;

        DebugCell->ConnectionID[0] = ULongToPtr(ClientProcess.GetDebugULong1());
        DebugCell->ConnectionID[1] = ULongToPtr(ClientProcess.GetDebugULong2());

        DebugCell->Flags = (unsigned char)LocalFlags;
        }

    return(0);
}


int
OSF_SCONNECTION::AlterContextRequested (
    IN rpcconn_alter_context * AlterContext,
    IN unsigned int AlterContextLength
    )
/*++

Routine Description:

Arguments:

    AlterContext - Supplies the buffer containing the rpc_alter_context
        packet received from the client.

    AlterContextLength - Supplies the length of the buffer in bytes.

Return Value:

    A non-zero return value indicates that the connection needs to
    be deleted by the caller.

--*/
{
    p_cont_list_t *PContextList;
    rpcconn_alter_context_resp * AlterContextResp = 0;
    unsigned int AlterContextRespLength = 0;
    unsigned int TokenLength = 0;
    unsigned int CompleteNeeded = 0;
    RPC_STATUS Status;
    sec_trailer  * SecurityTrailer,  * NewSecurityTrailer;
    SECURITY_BUFFER_DESCRIPTOR InputBufferDescriptor;
    SECURITY_BUFFER_DESCRIPTOR OutputBufferDescriptor;
    SECURITY_BUFFER InputBuffers[4];
    SECURITY_BUFFER OutputBuffers[4];
    DCE_INIT_SECURITY_INFO InitSecurityInfo;
    SECURITY_CREDENTIALS * SecurityCredentials = 0;
    unsigned long SecureAlterContext = 0;
    unsigned long NewContextRequired = 0;
    CLIENT_AUTH_INFO NewClientInfo;
    unsigned NewId;
    SECURITY_CONTEXT * SecId;
    unsigned long CallId = AlterContext->common.call_id;
    ULONG CalculatedSize;

    //
    // The packet has already been validate by whoever called this method.
    // Data conversion of the common part of the header was performed at
    // that time as well.  We do not use the max_xmit_frag, max_recv_frag,
    // or assoc_group_id fields of the packet, so we will not bother to
    // data convert them.
    //

    // make sure PContextList is there
    if ( AlterContextLength <
        sizeof(rpcconn_alter_context) + sizeof(p_cont_list_t))
        {
        SendFault(RPC_S_ACCESS_DENIED, 1, CallId);
        TransFreeBuffer(AlterContext);
        return(1);
        }

    PContextList = (p_cont_list_t *) (AlterContext + 1);

    CalculatedSize = sizeof(rpcconn_alter_context)+sizeof(p_cont_list_t)
                        + (PContextList->n_context_elem-1)*sizeof(p_cont_elem_t);

    // Sanity-check the packet.
    if ( AlterContextLength < CalculatedSize
         || PContextList->n_context_elem < 1 )
        {
        SendFault(RPC_S_ACCESS_DENIED, 1, CallId);
        TransFreeBuffer(AlterContext);
        return(1);
        }

    DataRep = * (unsigned long  *) AlterContext->common.drep;

    if ( AlterContext->common.auth_length != 0 )
        {
        //
        // We are dealing with a secure alter context
        // it may be adding a presentation context
        // or a new security context
        //
        SecureAlterContext = 1;
        SecurityTrailer = (sec_trailer  *)
                (((unsigned char  *) AlterContext) + AlterContextLength -
                AlterContext->common.auth_length - sizeof(sec_trailer));

        NewId = SecurityTrailer->auth_context_id;
        NewClientInfo.AuthenticationLevel = SecurityTrailer->auth_level;
        NewClientInfo.AuthenticationService = SecurityTrailer->auth_type;
        if (DataConvertEndian(((unsigned char *)&DataRep)) != 0)
            {
            NewId = RpcpByteSwapLong(NewId);
            }

        if (NewClientInfo.AuthenticationLevel ==  RPC_C_AUTHN_LEVEL_CALL)
           {
           NewClientInfo.AuthenticationLevel = RPC_C_AUTHN_LEVEL_PKT;
           }
        //
        // Check to see if a new context is being added..
        //
        SecId = FindSecurityContext(NewId,
                                    NewClientInfo.AuthenticationLevel,
                                    NewClientInfo.AuthenticationService
                                    );

        if (SecId == 0)
            {
            RPC_STATUS Status = RPC_S_OK;

            SecId = new SECURITY_CONTEXT(&NewClientInfo, NewId, FALSE, &Status);
            
            if ( (SecId == 0)
               || RPC_S_OK != Status)
                {
                if (SecId != 0)
                    {
                    delete SecId;
                    }
                SendFault(RPC_S_OUT_OF_MEMORY, 1, CallId);
                TransFreeBuffer(AlterContext);
                return (1);
                }
            if (SecurityContextDict.Insert(SecId) == -1)
                {
                delete SecId;
                SendFault(RPC_S_OUT_OF_MEMORY, 1, CallId);
                TransFreeBuffer(AlterContext);
                return (1);
                }

            NewContextRequired = 1;

            //
            // If previously no secure rpc had taken place
            // set original sec. context
            // else, mark this connection to indicate
            // security context is altered ..
            //
            if (RpcSecurityBeingUsed)
                {
                SecurityContextAltered = 1;
                }
            }

        AuthInfo = NewClientInfo;
        AuthInfo.ReferenceCredentials();

        AuthContextId = NewId;
        CurrentSecurityContext = SecId;
        RpcSecurityBeingUsed = 1;

        if (   (AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_CONNECT)
            && (AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_PKT)
            && (AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
            && (AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_PKT_PRIVACY) )
            {
            SendFault(RPC_S_ACCESS_DENIED, 1, CallId);
            TransFreeBuffer(AlterContext);
            return(1);
            }

        Status = Address->Server->AcquireCredentials(
                AuthInfo.AuthenticationService,
                AuthInfo.AuthenticationLevel,
                &SecurityCredentials
                );

        if ( Status == RPC_S_OUT_OF_MEMORY ||
             Status == ERROR_SHUTDOWN_IN_PROGRESS)
            {
            SendFault(Status, 1, CallId);
            TransFreeBuffer(AlterContext);
            return(1);
            }
        if ( Status != RPC_S_OK )
            {
            if (SecurityCredentials != 0)
                {
                SecurityCredentials->DereferenceCredentials();
                }
            SendFault(RPC_S_ACCESS_DENIED, 1, CallId);
            TransFreeBuffer(AlterContext);

            return(1);
            }
        ASSERT( SecurityCredentials != 0 );

        } //if secure alter context


    AlterContextRespLength =
        sizeof(rpcconn_alter_context_resp) + sizeof(p_result_list_t)
        + sizeof(p_result_t) * (PContextList->n_context_elem - 1);

    // The packet length should be 4-byte aligned:
    // AlterContextRespLength = 0x1c + 0x1c + 0x18 * x = 0 (mod 4)
    ASSERT(Pad4(AlterContextRespLength) == 0);

    if (SecureAlterContext != 0)
       {
       ASSERT(SecurityCredentials != 0);
       AlterContextRespLength += SecurityCredentials->MaximumTokenLength() +
                                 sizeof(sec_trailer);
       }

    Status = TransGetBuffer((void **) &AlterContextResp,
            AlterContextRespLength);
    if ( Status != RPC_S_OK )
        {
        ASSERT( Status == RPC_S_OUT_OF_MEMORY );
        if (SecurityCredentials != 0)
            {
            SecurityCredentials->DereferenceCredentials();
            }
        SendFault(RPC_S_OUT_OF_MEMORY, 1, CallId);
        TransFreeBuffer(AlterContext);
        return(1);
        }

    AlterContextLength -= sizeof(rpcconn_alter_context);
    if ( ProcessPContextList(Address, PContextList, &AlterContextLength,
            (p_result_list_t *) (AlterContextResp + 1)) != 0 )
        {
        TransFreeBuffer(AlterContext);
        TransFreeBuffer(AlterContextResp);
        if (SecurityCredentials != 0)
           {
           SecurityCredentials->DereferenceCredentials();
           }
        SendFault(RPC_S_PROTOCOL_ERROR, 1, CallId);
        return(1);
        }

    if ( SecureAlterContext != 0 )
        {
        ASSERT(SecurityCredentials != 0);
        NewSecurityTrailer = (sec_trailer  *)
                (((unsigned char  *) AlterContextResp) +
                              AlterContextRespLength -
                              SecurityCredentials->MaximumTokenLength() -
                              sizeof(sec_trailer));

        InitSecurityInfo.DceSecurityInfo = DceSecurityInfo;
        InitSecurityInfo.PacketType = AlterContext->common.PTYPE;
        InputBufferDescriptor.ulVersion = 0;
        InputBufferDescriptor.cBuffers = 4;
        InputBufferDescriptor.pBuffers = InputBuffers;

        InputBuffers[0].cbBuffer = sizeof(rpcconn_alter_context);
        InputBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        InputBuffers[0].pvBuffer = SavedHeader;

        InputBuffers[1].cbBuffer = AlterContext->common.frag_length -
                                   sizeof(rpcconn_alter_context) -
                                   AlterContext->common.auth_length;
        InputBuffers[1].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        InputBuffers[1].pvBuffer = (char  *) SavedHeader +
                                          sizeof(rpcconn_alter_context);

        InputBuffers[2].cbBuffer = AlterContext->common.auth_length;
        InputBuffers[2].BufferType = SECBUFFER_TOKEN;
        InputBuffers[2].pvBuffer = SecurityTrailer + 1;
        InputBuffers[3].cbBuffer = sizeof(DCE_INIT_SECURITY_INFO);
        InputBuffers[3].BufferType = SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
        InputBuffers[3].pvBuffer = &InitSecurityInfo;

        OutputBufferDescriptor.ulVersion = 0;
        OutputBufferDescriptor.cBuffers = 4;
        OutputBufferDescriptor.pBuffers = OutputBuffers;
        OutputBuffers[0].cbBuffer = sizeof(rpcconn_alter_context_resp);
        OutputBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        OutputBuffers[0].pvBuffer = AlterContextResp;
        OutputBuffers[1].cbBuffer = AlterContextRespLength
                - SecurityCredentials->MaximumTokenLength()
                - sizeof(rpcconn_alter_context_resp);
        OutputBuffers[1].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        OutputBuffers[1].pvBuffer = ((unsigned char *) AlterContextResp)
            + sizeof(rpcconn_alter_context_resp);
        OutputBuffers[2].cbBuffer = SecurityCredentials->MaximumTokenLength();
        OutputBuffers[2].BufferType = SECBUFFER_TOKEN;
        OutputBuffers[2].pvBuffer = NewSecurityTrailer + 1;
        OutputBuffers[3].cbBuffer = sizeof(DCE_INIT_SECURITY_INFO);
        OutputBuffers[3].BufferType = SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
        OutputBuffers[3].pvBuffer = &InitSecurityInfo;

        if ( NewContextRequired != 0 )
            {
            Status = AcceptFirstTime(
                               SecurityCredentials,
                               &InputBufferDescriptor,
                               &OutputBufferDescriptor,
                               SecurityTrailer->auth_level,
                               *((unsigned long *) AlterContext->common.drep),
                               NewContextRequired
                               );

           LogEvent(SU_SCONN, EV_SEC_ACCEPT1, this, LongToPtr(Status), OutputBuffers[2].cbBuffer);
            //
            // Since we have (potentially) a new security context we
            // need to figure out
            // additional security related information at this stage..
            //

            if ( Status == RPC_S_OK                    ||
                 Status == RPC_P_COMPLETE_NEEDED       ||
                 Status == RPC_P_CONTINUE_NEEDED       ||
                 Status == RPC_P_COMPLETE_AND_CONTINUE )
                {
                ASSERT(SecurityTrailer->auth_level != RPC_C_AUTHN_LEVEL_NONE);

                AdditionalSpaceForSecurity = CalculateAdditionalSpaceForSecurity (
                    SecurityTrailer->auth_level,
                    SecurityTrailer->auth_type
                    );
                }
            }
        else
            {
            // We can't be sure that the third leg packet is expected.
            // It is possible that the client will alter-context and existing
            // context rather then add a new one.  In that case, AcceptThirdLeg
            // will not be preceeded by AcceptFirstTime and AuthContinueNeeded == 0.

            // Since we have just received the third leg auth packet, we
            // are not expecting one any longer.
            AuthContinueNeeded = 0;

            Status = AcceptThirdLeg(
                         *((unsigned long  *) AlterContext->common.drep),
                         &InputBufferDescriptor,
                         &OutputBufferDescriptor
                         );

            LogEvent(SU_SCONN, EV_SEC_ACCEPT3, this, LongToPtr(Status), OutputBuffers[2].cbBuffer);
            }
        TokenLength = (unsigned int) OutputBuffers[2].cbBuffer;

        if (   ( Status == RPC_P_CONTINUE_NEEDED )
            || ( Status == RPC_S_OK )
            || ( Status == RPC_P_COMPLETE_NEEDED )
            || ( Status == RPC_P_COMPLETE_AND_CONTINUE ) )
            {
            if ( Status == RPC_P_CONTINUE_NEEDED )
                {
                AuthContinueNeeded = 1;
                }
            else if ( Status == RPC_P_COMPLETE_AND_CONTINUE )
                {
                AuthContinueNeeded = 1;
                CompleteNeeded = 1;
                }
            else if ( Status == RPC_P_COMPLETE_NEEDED )
                {
                CompleteNeeded = 1;
                }

            if ( Status == RPC_S_OK              ||
                 Status == RPC_P_COMPLETE_NEEDED )
                {
                ASSERT(SecurityTrailer->auth_level != RPC_C_AUTHN_LEVEL_NONE);

                AdditionalSpaceForSecurity = CalculateAdditionalSpaceForSecurity (
                    SecurityTrailer->auth_level,
                    SecurityTrailer->auth_type
                    );
                }

            AlterContextRespLength = AlterContextRespLength +
                                    TokenLength -
                                    SecurityCredentials->MaximumTokenLength();

            NewSecurityTrailer->auth_type = SecurityTrailer->auth_type;
            NewSecurityTrailer->auth_level = SecurityTrailer->auth_level;
            NewSecurityTrailer->auth_pad_length = 0;
            NewSecurityTrailer->auth_reserved = 0;
            NewSecurityTrailer->auth_context_id = AuthContextId;

            SecurityCredentials->DereferenceCredentials();
            SecurityCredentials = 0;

            Status = RPC_S_OK;
            }

        if (Status)
            {
            TransFreeBuffer(AlterContext);
            TransFreeBuffer(AlterContextResp);

            SecurityCredentials->DereferenceCredentials();

            SendFault(RPC_S_ACCESS_DENIED, 1, CallId);
            return(1);
            }
        }

    DceSecurityInfo.ReceiveSequenceNumber++;
    ConstructPacket((rpcconn_common *) AlterContextResp,
                    rpc_alter_context_resp, AlterContextRespLength);

    TransFreeBuffer(AlterContext);
    if ( Association == 0 )
        {
        TransFreeBuffer(AlterContextResp);
        SendFault(RPC_S_PROTOCOL_ERROR, 1, CallId);
        return(1);
        }

    AlterContextResp->assoc_group_id = Association->AssocGroupId();
    AlterContextResp->sec_addr_length = 0;
    AlterContextResp->max_xmit_frag = AlterContextResp->max_recv_frag = MaxFrag;
    AlterContextResp->common.call_id = CallId;
    AlterContextResp->common.pfc_flags = PFC_FIRST_FRAG | PFC_LAST_FRAG;

    AlterContextResp->common.auth_length = (unsigned short) TokenLength;
    if (CompleteNeeded != 0)
       {
       CurrentSecurityContext->CompleteSecurityToken(&OutputBufferDescriptor);
       }

    Status= TransSend(AlterContextResp, AlterContextRespLength);
    TransFreeBuffer(AlterContextResp);
    if ( Status != RPC_S_OK )
        {
        return(1);
        }

    return(0);
}


RPC_STATUS
OSF_SCONNECTION::EatAuthInfoFromPacket (
    IN rpcconn_request  * Request,
    IN OUT int  * RequestLength,
    IN OUT void  *  *SavedHeader,
    IN OUT unsigned long *SavedHeaderSize
    )
/*++

Routine Description:

    If there is authentication information in the packet, this routine
    will check it, and perform security as necessary.  This may include
    calls to the security support package.

Arguments:

    Request - Supplies the packet which may contain authentication
        information.

    RequestLength - Supplies the length of the packet in bytes, and
        returns the length of the packet without authentication
        information.

Return Value:

    RPC_S_OK - Everything went just fine.

    RPC_S_ACCESS_DENIED - A security failure of some sort occured.

    RPC_S_PROTOCOL_ERROR - This will occur if no authentication information
        is in the packet, and some was expected, or visa versa.

--*/
{
    sec_trailer  * SecurityTrailer;
    RPC_STATUS Status;
    SECURITY_BUFFER_DESCRIPTOR BufferDescriptor;
    SECURITY_BUFFER SecurityBuffers[5];
    DCE_MSG_SECURITY_INFO MsgSecurityInfo;
    unsigned long Id, Level, Service;
    SECURITY_CONTEXT * SecId;
    unsigned int HeaderSize = sizeof(rpcconn_request);
    unsigned long DataRep = * (unsigned long  *) Request->common.drep;
    ULONG ReadOnlyFlag;

    if ( (Request->common.pfc_flags & PFC_OBJECT_UUID) != 0 )
        {
        HeaderSize += sizeof(UUID);
        }

    if ( Request->common.auth_length != 0 )
        {
        SecurityTrailer = (sec_trailer  *) (((unsigned char  *)
                Request) + Request->common.frag_length
                - Request->common.auth_length - sizeof(sec_trailer));

        if (!IsBufferAlignedOnStructBoundary(SecurityTrailer))
            {
            CORRUPTION_ASSERT(0 && "SecurityTrailer is unaligned");
            return(RPC_S_PROTOCOL_ERROR);
            }

        if (RpcSecurityBeingUsed == 0)
            {
            return(RPC_S_PROTOCOL_ERROR);
            }

        //
        // Find the appropriate security context..
        //

        Id = SecurityTrailer->auth_context_id;
        Level = SecurityTrailer->auth_level;
        Service = SecurityTrailer->auth_type;
        if (DataConvertEndian(((unsigned char *)&DataRep)) != 0)
            {
            Id = RpcpByteSwapLong(Id);
            }

        //
        // Osf Hack
        //
        if (Level ==  RPC_C_AUTHN_LEVEL_CALL)
           {
           Level = RPC_C_AUTHN_LEVEL_PKT;
           }

        if ( (CurrentSecurityContext == 0)
           ||(CurrentSecurityContext->AuthContextId != Id)
           ||(CurrentSecurityContext->AuthenticationLevel != Level)
           ||(CurrentSecurityContext->AuthenticationService != Service) )
           {
            SecId = FindSecurityContext(Id, Level, Service);
            if (SecId == 0)
                {
                return (RPC_S_PROTOCOL_ERROR);
                }
            CurrentSecurityContext = SecId;
            AuthInfo.AuthenticationLevel =  Level;
            AuthInfo.AuthenticationService = Service;
            AuthContextId = Id;

            ASSERT(Level != RPC_C_AUTHN_LEVEL_NONE);

            AdditionalSpaceForSecurity = CalculateAdditionalSpaceForSecurity (
                Level,
                Service
                );
           }

        if (GetClientSupportsHeaderSigningFlag())
            ReadOnlyFlag = SECBUFFER_READONLY_WITH_CHECKSUM;
        else
            ReadOnlyFlag = SECBUFFER_READONLY;

        *RequestLength -=  (Request->common.auth_length
                            +HeaderSize + sizeof(sec_trailer) +
                            SecurityTrailer->auth_pad_length);
       
        ASSERT(*RequestLength >= 0);

        MsgSecurityInfo.SendSequenceNumber =
               DceSecurityInfo.SendSequenceNumber;
        MsgSecurityInfo.ReceiveSequenceNumber =
               DceSecurityInfo.ReceiveSequenceNumber;
        MsgSecurityInfo.PacketType = Request->common.PTYPE;

        BufferDescriptor.ulVersion = 0;
        BufferDescriptor.cBuffers = 5;
        BufferDescriptor.pBuffers = SecurityBuffers;


        SecurityBuffers[0].cbBuffer = HeaderSize;
        SecurityBuffers[0].BufferType = SECBUFFER_DATA | ReadOnlyFlag;
        SecurityBuffers[0].pvBuffer = (unsigned char  *) *SavedHeader;

        SecurityBuffers[1].cbBuffer = *RequestLength + SecurityTrailer->auth_pad_length;
        SecurityBuffers[1].BufferType = SECBUFFER_DATA;
        SecurityBuffers[1].pvBuffer = ((unsigned char  *) Request)
                + HeaderSize;

        SecurityBuffers[2].cbBuffer = sizeof(sec_trailer);
        SecurityBuffers[2].BufferType = SECBUFFER_DATA | ReadOnlyFlag;
        SecurityBuffers[2].pvBuffer = SecurityTrailer;

        SecurityBuffers[3].cbBuffer = Request->common.auth_length;
        SecurityBuffers[3].BufferType = SECBUFFER_TOKEN;
        SecurityBuffers[3].pvBuffer = SecurityTrailer + 1;

        SecurityBuffers[4].cbBuffer = sizeof(DCE_MSG_SECURITY_INFO);
        SecurityBuffers[4].BufferType = SECBUFFER_PKG_PARAMS
                | SECBUFFER_READONLY;
        SecurityBuffers[4].pvBuffer = &MsgSecurityInfo;

        Status = CurrentSecurityContext->VerifyOrUnseal(
                MsgSecurityInfo.ReceiveSequenceNumber,
                AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                &BufferDescriptor);

        if ( Status != RPC_S_OK )
            {
            ASSERT( Status == RPC_S_ACCESS_DENIED ||
                    Status == ERROR_PASSWORD_MUST_CHANGE ||
                    Status == ERROR_PASSWORD_EXPIRED ||
                    Status == ERROR_ACCOUNT_DISABLED ||
                    Status == ERROR_INVALID_LOGON_HOURS ||
                    Status == RPC_S_OUT_OF_MEMORY);
            return(Status);
            }
        }
    else if (CurrentSecurityContext == 0)
        {
        // This is a non-secure connection.  There is nothing to be done.
        ASSERT(AuthInfo.AuthenticationLevel == RPC_C_AUTHN_LEVEL_NONE);

        // Corrupt data could have lead us to previously allocate a SavedHeader.
        // This is fine because there is at most one such allocation per call.
        CORRUPTION_ASSERT(*SavedHeader == 0);

        *RequestLength -= HeaderSize;

        ASSERT(*RequestLength >= 0);
        }
    else
        {
        //
        // We are processing a fragment with zero auth length on a secure
        // connection.  This should only happen with connect or call level security.
        //
        if (CurrentSecurityContext->AuthenticationLevel != RPC_C_AUTHN_LEVEL_CONNECT
            && CurrentSecurityContext->AuthenticationLevel != RPC_C_AUTHN_LEVEL_CALL)
            {
            CORRUPTION_ASSERT(0 && "Unsecure RPC on a secure connection.");
            return RPC_S_ACCESS_DENIED;
            }
        else
            {
            if (*SavedHeader != 0)
               {
               ASSERT(*SavedHeaderSize != 0);
               RpcpFarFree(*SavedHeader);
               *SavedHeader = 0;
               *SavedHeaderSize = 0;
               }

            *RequestLength -= HeaderSize;
            }
        }

    DceSecurityInfo.ReceiveSequenceNumber += 1;

    if (*RequestLength < 0)
        {
        return RPC_S_ACCESS_DENIED;
        }

    return(RPC_S_OK);
}


BOOL
OSF_SCONNECTION::MaybeQueueThisCall (
    IN OSF_SCALL *ThisCall
    )
{
    BOOL fCallQueued = 0;

    ConnMutex.Request();
    if (fCurrentlyDispatched)
        {
        if (CallQueue.PutOnQueue(ThisCall, 0))
            {
            ThisCall->SendFault(RPC_S_OUT_OF_MEMORY, 1);

            //
            // Remove the reply reference
            //
            ThisCall->RemoveReference();  // CALL--

            //
            // Remove the dispatch reference();
            //
            ThisCall->RemoveReference();  // CALL--
            }
        fCallQueued = 1;
        }
    else
        {
        fCurrentlyDispatched = 1;
        }
    ConnMutex.Clear();

    return fCallQueued;
}


void
OSF_SCONNECTION::AbortQueuedCalls (
    )
{
    OSF_SCALL *NextCall;
    unsigned int ignore;

    while (1)
        {
        ConnMutex.Request();
        NextCall = (OSF_SCALL *) CallQueue.TakeOffQueue(&ignore);
        if (NextCall == 0)
            {
            fCurrentlyDispatched = 0;
            ConnMutex.Clear();

            break;
            }
        ConnMutex.Clear();

        //
        // Remove the reply reference
        //
        NextCall->RemoveReference();  // CALL--

        //
        // Remove the dispatch reference on the call
        //
        NextCall->RemoveReference();  // CALL--
        }
}


void
OSF_SCONNECTION::DispatchQueuedCalls (
    )
{
    OSF_SCALL *NextCall;
    unsigned int ignore;

    while (1)
        {
        ConnMutex.Request();
        NextCall = (OSF_SCALL *) CallQueue.TakeOffQueue(&ignore);
        if (NextCall == 0)
            {
            fCurrentlyDispatched = 0;
            ConnMutex.Clear();

            break;
            }
        ConnMutex.Clear();

        NextCall->DispatchHelper();

        //
        // Remove the dispatch reference on the call
        //
        NextCall->RemoveReference();  // CALL--
        }
}


RPC_STATUS
OSF_SCONNECTION::TurnOnOffKeepAlives (
    IN BOOL TurnOn,
    IN ULONG Time,
    IN ULONG Interval
    )
/*++

Routine Description:

    Turns on or off keepalives for the given connection

Arguments:

    TurnOn - if non-zero, keep alives will be turned on with
        the timeout specified. If zero, keepalives will be turned off

    Timeout - The time in milliseconds between the last keep alive
        response and the next probe.

    Interval - The timeout in milliseconds for the
        subsequent keepalive packets.  The time between
        two consequitive keep alive probes if the first one
        did not receive a response.

Return Value:

    RPC_S_OK if the transport supports keep alives
    RPC_S_CANNOT_SUPPORT otherwise

--*/
{
    KEEPALIVE_TIMEOUT uTime;
    uTime.Milliseconds = Time;

    if (TurnOn && fKeepalivesTurnedOn)
        {
        return RPC_S_OK;
        }

    if (ServerInfo->TurnOnOffKeepAlives)
        {
        if (ServerInfo->TurnOnOffKeepAlives(TransConnection,
                TurnOn,
                TRUE,
                tuMilliseconds,
                uTime,
                Interval) != RPC_S_OK)
            {
            return RPC_S_CANNOT_SUPPORT;
            }
        else
            {
            fKeepalivesTurnedOn = TRUE;
            return RPC_S_OK;
            }
        }
    else
        {
        return RPC_S_CANNOT_SUPPORT;
        }
}

DLL *OSF_SCONNECTION::Secur32Dll = NULL;
SecpSetIPAddressFn OSF_SCONNECTION::SecpSetIPAddressFnPtr = NULL;

RPC_STATUS
OSF_SCONNECTION::AcceptFirstTime (
    IN SECURITY_CREDENTIALS * NewCredentials,
    IN SECURITY_BUFFER_DESCRIPTOR PAPI * InputBufferDescriptor,
    IN OUT SECURITY_BUFFER_DESCRIPTOR PAPI * OutputBufferDescriptor,
    IN unsigned long AuthenticationLevel,
    IN unsigned long DataRepresentation,
    IN unsigned long NewContextNeededFlag
    )
/*++

Routine Description:

    Accepts the first leg of a security context negotiation. Little more
    than a wrapper for the respective SECURITY_CONTEXT function.

Arguments:

    NewCredentials - the new credentials to assign to the security context.

    InputBufferDescriptor - a structure describing the buffers with data 
        that we received from the client.

    OutputBufferDescriptor - a structure describing the buffers with data 
        to return to the client.

    AuthenticationLevel - the authentication level requested by the client.

    DataRepresentation - the data representation for this call.

    NewContextNeededFlag - true if we have to establish a new security context.

Return Value:

    RPC_S_OK or RPC_S_* error.

--*/
{
    RPC_CLIENT_IP_ADDRESS ClientIpAddress;
    SECURITY_STATUS SecurityStatus;
    RPC_STATUS RpcStatus;

    // secur32 doesn't export this function on wow
#if !defined(BUILD_WOW6432)
    TransQueryClientIpAddress (&ClientIpAddress);

    RpcStatus = EnsureSecur32DllLoaded();
    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    SecurityStatus = SecpSetIPAddressFnPtr (ClientIpAddress.Data, ClientIpAddress.DataSize);
    if (SecurityStatus != SEC_E_OK)
        {
        RpcpErrorAddRecord(EEInfoGCRuntime, 
            RPC_S_OUT_OF_MEMORY, 
            EEInfoDLOSF_SCONNECTION__AcceptFirstTime,
            SecurityStatus);

        return RPC_S_OUT_OF_MEMORY;
        }
#endif  // BUILD_WOW6432

    return CurrentSecurityContext->AcceptFirstTime (
        NewCredentials,
        InputBufferDescriptor,
        OutputBufferDescriptor,
        AuthenticationLevel,
        DataRepresentation,
        NewContextNeededFlag
        );
}

RPC_STATUS
OSF_SCONNECTION::AcceptThirdLeg (
    IN unsigned long DataRepresentation,
    IN SECURITY_BUFFER_DESCRIPTOR PAPI * BufferDescriptor,
    OUT SECURITY_BUFFER_DESCRIPTOR PAPI * OutBufferDescriptor
    )
/*++

Routine Description:

    Accepts a non-first (second or higher) leg of a security context 
    negotiation. Little more than a wrapper for the respective 
    SECURITY_CONTEXT function.

Arguments:

    DataRepresentation - the data representation for this call.

    InputBufferDescriptor - a structure describing the buffers with data 
        that we received from the client.

    OutputBufferDescriptor - a structure describing the buffers with data 
        to return to the client.

Return Value:

    RPC_S_OK or RPC_S_* error.

--*/
{
    RPC_CLIENT_IP_ADDRESS ClientIpAddress;
    SECURITY_STATUS SecurityStatus;
    RPC_STATUS RpcStatus;

    // secur32 doesn't export this function on wow
#if !defined(BUILD_WOW6432)
    TransQueryClientIpAddress (&ClientIpAddress);

    RpcStatus = EnsureSecur32DllLoaded();
    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    SecurityStatus = SecpSetIPAddressFnPtr (ClientIpAddress.Data, ClientIpAddress.DataSize);
    if (SecurityStatus != SEC_E_OK)
        {
        RpcpErrorAddRecord(EEInfoGCRuntime, 
            RPC_S_OUT_OF_MEMORY, 
            EEInfoDLOSF_SCONNECTION__AcceptThirdLeg,
            SecurityStatus);

        return RPC_S_OUT_OF_MEMORY;
        }
#endif  // BUILD_WOW6432

    return CurrentSecurityContext->AcceptThirdLeg (
        DataRepresentation,
        BufferDescriptor,
        OutBufferDescriptor
        );
}


OSF_ASSOCIATION::OSF_ASSOCIATION (
    IN OSF_ADDRESS *TheAddress,
    IN RPC_CLIENT_PROCESS_IDENTIFIER * ClientProcess,
    OUT RPC_STATUS * Status
    )
{
    ObjectType = OSF_ASSOCIATION_TYPE;
    *Status = RPC_S_OK;
    ConnectionCount = 1;
    Address = TheAddress;

    this->ClientProcess.Set(ClientProcess);

    AssociationGroupId = InterlockedExchangeAdd(&GroupIdCounter, 1);

    AssociationDictKey = Address->AddAssociation(this);

    if (AssociationDictKey == -1)
        {
        *Status = RPC_S_OUT_OF_MEMORY;
        }
}

OSF_ASSOCIATION::~OSF_ASSOCIATION (
    )
{
    if (AssociationDictKey != -1)
        {
        int HashBucketNumber;

        HashBucketNumber = Address->GetHashBucketForAssociation(AssocGroupId());
        // lock the bucket
        Address->GetAssociationBucketMutex(HashBucketNumber)->Request();

        Address->RemoveAssociation(AssociationDictKey, this);

        // unlock the bucket
        Address->GetAssociationBucketMutex(HashBucketNumber)->Clear();
        }
}

BOOL
OSF_ASSOCIATION::RemoveConnectionUnsafe (
    void
    )
{
    int HashBucketNumber;

    // get the hashed bucket
    HashBucketNumber = Address->GetHashBucketForAssociation(AssociationGroupId);
    // verify the bucket is locked
    Address->GetAssociationBucketMutex(HashBucketNumber)->VerifyOwned();

    ConnectionCount --;

    if (ConnectionCount == 0)
        {
        Address->RemoveAssociation(AssociationDictKey, this);
        AssociationDictKey = -1;
        return AssociationDictKey;  // AssociationDictKey is a quick non-zero value
        }
    else
        return FALSE;
}

void
OSF_ASSOCIATION::RemoveConnection (
    )
{
    int HashBucketNumber;
    BOOL Res;

    // get the hashed bucket
    HashBucketNumber = Address->GetHashBucketForAssociation(AssociationGroupId);
    // lock the bucket
    Address->GetAssociationBucketMutex(HashBucketNumber)->Request();
    Res = RemoveConnectionUnsafe();
    // unlock the bucket
    Address->GetAssociationBucketMutex(HashBucketNumber)->Clear();

    if (Res)
        delete this;
}

RPC_STATUS OSF_ASSOCIATION::CreateThread(void)
{
    return Address->CreateThread();
}


RPC_ADDRESS *
OsfCreateRpcAddress (
    IN TRANS_INFO  *TransportInfo
    )
/*++

Routine Description:

    This routine will be called to create an object representing an
    rpc address.  That is all it has got to do.

Arguments:

    A new rpc address will be returned, unless insufficient memory is
    available to create the new rpc address, in which case zero will
    be returned.

--*/
{
    RPC_ADDRESS * RpcAddress;
    RPC_STATUS Status = RPC_S_OK;
    RPC_CONNECTION_TRANSPORT *ServerInfo =
        (RPC_CONNECTION_TRANSPORT *) TransportInfo->InqTransInfo();

    RpcAddress = new (ServerInfo->AddressSize)
                               OSF_ADDRESS(TransportInfo, &Status);

    if ( Status != RPC_S_OK )
        {
        delete RpcAddress;
        return(0);
        }
    return(RpcAddress);
}


RPC_STATUS
OSF_SCALL::Cancel(
    void * ThreadHandle
    )
{
    InterlockedIncrement(&CancelPending);

    return RPC_S_OK;
}

unsigned
OSF_SCALL::TestCancel(
    )
{
    return InterlockedExchange(&CancelPending, 0);
}


RPC_STATUS
OSF_SCALL::ToStringBinding (
    OUT RPC_CHAR  *  * StringBinding
    )
/*++

Routine Description:

    We need to convert this connection into a string binding.  We
    will ask the address for a binding handle which we can then
    convert into a string binding.

Arguments:

    StringBinding - Returns the string representation of the binding
        handle.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_MEMORY - We do not have enough memory available to
        allocate space for the string binding.

--*/
{
    BINDING_HANDLE * BindingHandle;
    RPC_STATUS Status = RPC_S_OK;

    BindingHandle = Address->InquireBinding();
    if (BindingHandle == 0)
        return(RPC_S_OUT_OF_MEMORY);
    if ( ObjectUuidSpecified != 0)
        {
        Status = RpcBindingSetObject(BindingHandle, (UUID *) &ObjectUuid);
        }
    if (Status == RPC_S_OK)
        {
        Status = BindingHandle->ToStringBinding(StringBinding);
        }
    BindingHandle->BindingFree();
    return(Status);
}

#if DBG
void
OSF_SCALL::InterfaceForCallDoesNotUseStrict (
    void
    )
{
    CurrentBinding->InterfaceForCallDoesNotUseStrict();
}
#endif

RPC_STATUS
OSF_SCALL::InqLocalConnAddress (
    IN OUT void *Buffer,
    IN OUT unsigned long *BufferSize,
    OUT unsigned long *AddressFormat
    )
/*++

Routine Description:

    This routine is used by a server application to inquire about the local
    address on which a call is made.

Arguments:

    Buffer - The buffer that will receive the output address

    BufferSize - the size of the supplied Buffer on input. On output the
        number of bytes written to the buffer. If the buffer is too small
        to receive all the output data, ERROR_MORE_DATA is returned,
        nothing is written to the buffer, and BufferSize is set to
        the size of the buffer needed to return all the data.

    AddressFormat - a constant indicating the format of the returned address.
        Currently supported are RPC_P_ADDR_FORMAT_TCP_IPV4 and
        RPC_P_ADDR_FORMAT_TCP_IPV6.

Return Values:

    RPC_S_OK - success.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete this
        operation.

    RPC_S_INVALID_BINDING - The supplied client binding is invalid.

    RPC_S_CANNOT_SUPPORT - The local address was inquired for a protocol 
        sequence that doesn't support this type of functionality. Currently
        only ncacn_ip_tcp supports it.

    RPC_S_* or Win32 error for other errors
--*/
{
    return Connection->InqLocalConnAddress(
        Buffer,
        BufferSize,
        AddressFormat);
}

void
OSF_SCALL::WakeUpPipeThreadIfNecessary (
    IN RPC_STATUS Status
    )
/*++

Routine Description:

    If a pipe thread is being stuck on wait, it fires the event to wake
    it up.

Arguments:
    Status - the status with which the call failed.

Return Values:

--*/
{
    if (pAsync == 0)
        {
        if (fPipeCall)
            {
            CallMutex.Request();

            CurrentState = CallAborted;
            AsyncStatus = Status;

            // wake up the thread that was flow controlled, if any
            fChoked = 0;

            CallMutex.Clear();

            LogEvent(SU_SCALL, EV_STATUS, this, SyncEvent.EventHandle, 0, 1, 0);
            SyncEvent.Raise();
            }
        }
    else
        {
        if (fAsyncPipeCall)
            {
            CallMutex.Request();

            CurrentState = CallAborted;
            AsyncStatus = Status;

            CallMutex.Clear();

            // For async pipes, this path races with OSF_SCALL::ProcessReceivedPDU.
            // If the notification has been issued there, then NeededLength == 0.
            // We want to issue this notification iff NeededLength != 0, since that
            // means that there will be no thread attempting a pull and clening up
            // the call syncronously.
            if (NeededLength > 0)
                {
                IssueNotification();
                }
            }
        }
}

BOOL OSF_SCALL::ProcessVerificationTrailer (
    IN rpc_sec_verification_trailer_command *FirstCommand,
    IN unsigned char *BufferEnd,
    IN RPC_MESSAGE *RpcMessage
    )
/*++

Routine Description:

    Processes the commands in the verification trailer.

Arguments:

    FirstCommand - pointer to the first verification trailer command. At least one
        command must be present.

    BufferEnd - the first invalid position in the buffer (i.e. invalid in
        the sense beyond the end of the buffer). FirstCommand is NOT guaranteeed
        to be smaller than BufferEnd

    RpcMessage - current RPC Message.

Return Values:

    non-zero - all commands passed verification check
    0 - one or more commands failed verification check

--*/
{
    rpc_sec_verification_trailer_command *CurrentCommand;
    rpc_sec_verification_trailer_command *NextCommand;
    rpc_sec_vt_bitmask *BitmaskCommand;
    rpc_sec_vt_pcontext *PContextCommand;
    rpc_sec_vt_header2 *Header2;
    ULONG CommandCode;
    BOOL LastCommand;

    CurrentCommand = FirstCommand;

    while (TRUE)
        {
        // check that we can read the command code and length
        if ((unsigned char *)(CurrentCommand + 1) > BufferEnd)
            return FALSE;

        CommandCode = CurrentCommand->command & SEC_VT_COMMAND_CODE_MASK;
        LastCommand = CurrentCommand->command & SEC_VT_COMMAND_END;
        NextCommand = (rpc_sec_verification_trailer_command *)(((unsigned char *)CurrentCommand) 
            + sizeof(rpc_sec_verification_trailer_command)
            + CurrentCommand->length)   // length is only USHORT - cannot overflow in user mode
            ;

        // can we read the entire command up to the next command?
        if ((unsigned char *)NextCommand > BufferEnd)
            return FALSE;

        // from here, command is verified to be readable up to the declared length.
        // individual commands may only verify the length is what is expected
        switch (CommandCode)
            {
            case SEC_VT_COMMAND_BITMASK_1:
                if (CurrentCommand->length != (sizeof(rpc_sec_vt_bitmask) - sizeof(rpc_sec_verification_trailer_command)))
                    return FALSE;
                BitmaskCommand = (rpc_sec_vt_bitmask *)CurrentCommand;
                // if client supports header signing, but the cleartext data did not indicate so,
                // there must be someone in the middle tampering with data.
                if ((BitmaskCommand->bits & CLIENT_SUPPORT_HEADER_SIGNING) 
                    && (Connection->GetClientSupportsHeaderSigningFlag() == FALSE))
                    {
                    return FALSE;
                    }
                break;

            case SEC_VT_COMMAND_PCONTEXT:
                if (CurrentCommand->length != (sizeof(rpc_sec_vt_pcontext) - sizeof(rpc_sec_verification_trailer_command)))
                    return FALSE;
                PContextCommand = (rpc_sec_vt_pcontext *)CurrentCommand;
                // check that the binding information corresponds to what we have in
                // the call pcontext
                if (RpcpMemoryCompare(&PContextCommand->InterfaceId, 
                    CurrentBinding->GetInterfaceId(), 
                    sizeof(RPC_SYNTAX_IDENTIFIER) ))
                    {
                    return FALSE;
                    }

                if (RpcpMemoryCompare(&PContextCommand->TransferSyntax, 
                    CurrentBinding->GetTransferSyntaxId(), 
                    sizeof(RPC_SYNTAX_IDENTIFIER) ))
                    {
                    return FALSE;
                    }

                break;

            case SEC_VT_COMMAND_HEADER2:
                if (CurrentCommand->length != (sizeof(rpc_sec_vt_header2) - sizeof(rpc_sec_verification_trailer_command)))
                    return FALSE;
                Header2 = (rpc_sec_vt_header2 *)CurrentCommand;
                // check that the information in the two headers matches
                if (Header2->call_id != CallId)
                    return FALSE;

                if ((*(ULONG *)Header2->drep) != RpcMessage->DataRepresentation)
                    return FALSE;

                if (Header2->opnum != (USHORT)RpcMessage->ProcNum)
                    return FALSE;

                if (Header2->p_cont_id != (USHORT)CurrentBinding->GetPresentationContext())
                    return FALSE;

                if (Header2->PTYPE != rpc_request)
                    return FALSE;
                break;

            default:
                // unknown command - skip to next unless current command
                // requires processing
                if (CurrentCommand->command & SEC_VT_MUST_PROCESS_COMMAND)
                    return FALSE;
            }

        if (LastCommand)
            break;

        CurrentCommand = NextCommand;
        }
    
    return TRUE;
}

BOOL OSF_SCALL::CheckVerificationTrailer (
    IN unsigned char *BufferStart,
    IN unsigned char *BufferEnd,
    IN RPC_MESSAGE *RpcMessage
    )
/*++

Routine Description:

    Checks if the just unmarshalled fragment should be
    checked for verification trailer.

Arguments:

    BufferStart - the current position in the buffer.

    BufferEnd - the first invalid position in the buffer (i.e. invalid in
        the sense beyond the end of the buffer). BufferStart is guaranteeed
        to be at least sizeof(rpc_sec_verification_trailer) bytes before
        BufferEnd by caller.

    RpcMessage - the current RPC Message

Return Values:

    non-zero - verification trailer passes check or is not present (which is an implicit pass)
    0 - verification trailer is present and failed the check

--*/
{
    ULONG AuthnLevel;
    rpc_sec_verification_trailer *VTrailer;

    if (Connection->CurrentSecurityContext)
        {
        AuthnLevel = Connection->CurrentSecurityContext->AuthenticationLevel;
        // if this is a secure connection and the current check is in the dispatch
        // buffer, then it may be a verification trailer
        if (AuthnLevel >= RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
            {
            if ((BufferStart >= DispatchBuffer)
                && (BufferStart < (unsigned char *)DispatchBuffer + DispatchBufferOffset) )
                {
                VTrailer = (rpc_sec_verification_trailer *) AlignPtr4(BufferStart);
                if ((unsigned char *)(VTrailer + 1) > BufferEnd)
                    return TRUE;
                if (RpcpMemoryCompare(VTrailer, SecVerificationTrailerSignature, sizeof(SecVerificationTrailerSignature)))
                    return TRUE;
                
                // now we know we have a trailer. Verify it.
                return ProcessVerificationTrailer ((rpc_sec_verification_trailer_command *)(VTrailer + 1),
                    BufferEnd,
                    RpcMessage
                    );
                }
            else
                {
#if DBG
                DbgPrint("RPCRT4: Current position not in dispatch buffer - ignored\n");
#endif
                }
            }
        }

    return TRUE;
}


RPC_STATUS RPC_ENTRY
I_RpcTransServerReallocPacket (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN OUT void  *  * Buffer,
    IN unsigned int OldBufferLength,
    IN unsigned int NewBufferLength
    )
/*++

Routine Description:

    The server side transport interface modules will use this routine to
    increase the size of a buffer so that the entire packet to be
    received will fit into it, or to allocate a new buffer.  If the buffer
    is to be reallocated, the data from the old buffer is copied
    into the beginning of the new buffer.  The old buffer will be freed.

Arguments:

    ThisConnection - Supplies the connection for which we are reallocating
        a transport buffer.

    Buffer - Supplies the buffer which we want to reallocate to
        be larger.  If no buffer is supplied, then a new one is allocated
        anyway.  The new buffer is returned via this argument.

    OldBufferLength - Supplies the current length of the buffer in bytes.
        This information is necessary so we know how much of the buffer
        needs to be copied into the new buffer.

    NewBufferLength - Supplies the required length of the buffer in bytes.

Return Value:

    RPC_S_OK - The requested larger buffer has successfully been allocated.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate
        the buffer.

--*/
{
    ASSERT(0);
    return(RPC_S_INTERNAL_ERROR);
}


BUFFER RPC_ENTRY
I_RpcTransServerAllocatePacket (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN UINT Size
    )
/*++

Routine Description:

    The server side transport interface modules will use this routine to
    increase the size of a buffer so that the entire packet to be
    received will fit into it, or to allocate a new buffer.  If the buffer
    is to be reallocated, the data from the old buffer is copied
    into the beginning of the new buffer.  The old buffer will be freed.

Arguments:

    ThisConnection - Supplies the connection for which we are reallocating
        a transport buffer.

    Buffer - Supplies the buffer which we want to reallocate to
        be larger.  If no buffer is supplied, then a new one is allocated
        anyway.  The new buffer is returned via this argument.

    OldBufferLength - Supplies the current length of the buffer in bytes.
        This information is necessary so we know how much of the buffer
        needs to be copied into the new buffer.

    NewBufferLength - Supplies the required length of the buffer in bytes.

Return Value:

    RPC_S_OK - The requested larger buffer has successfully been allocated.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate
        the buffer.

--*/
{
    ASSERT(0);
    return(0);
}


unsigned short RPC_ENTRY
I_RpcTransServerMaxFrag (
    IN RPC_TRANSPORT_CONNECTION ThisConnection
    )
/*++

Routine Description:

    The server side transport interface modules will use this routine to
    determine the negotiated maximum fragment size.

Arguments:

    ThisConnection - Supplies the connection for which we are returning
    the maximum fragment size.

--*/
{
    ASSERT(0);
    return(0);
}

RPC_TRANSPORT_CONNECTION RPC_ENTRY
I_RpcTransServerNewConnection (
    IN RPC_TRANSPORT_ADDRESS ThisAddress
    )
{
    OSF_SCONNECTION * SConnection;
    OSF_ADDRESS *Address ;

    Address = InqTransAddress(ThisAddress) ;

    SConnection = Address->NewConnection();
    if ( SConnection == 0 )
        {
        return(0);
        }

    return(SConnection->TransConnection);
}



void RPC_ENTRY
I_RpcTransServerFreePacket (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN void  * Buffer
    )
/*++

Routine Description:

    We need to free a transport buffer for a transport connection; this
    will typically occur when the connection is being closed.

Arguments:

    ThisConnection - Supplies the transport connection which owns the
        buffer.

    Buffer - Supplies the buffer to be freed.

--*/
{
    ASSERT(0);
}


void  * RPC_ENTRY
I_RpcTransProtectThread (
    void
    )
/*++

Routine Description:

    In some cases, if an asyncronous io operation has been started by a
    thread, the thread can not be deleted because the io operation will
    be cancelled.  This routine will be called by a transport to indicate
    that the current thread can not be deleted.

Return Value:

    A pointer to the thread will be returned.  This is necessary, so that
    later the thread can be unprotected.

--*/
{
#ifdef RPC_OLD_IO_PROTECTION
    THREAD  * Thread = RpcpGetThreadPointer();

    Thread->ProtectThread();
    return((void  *) Thread);
#endif
    return 0;
}


void RPC_ENTRY
I_RpcTransUnprotectThread (
    IN void  * Thread
    )
/*++

Routine Description:

    When a thread no longer needs to be protected from deletion, this
    routine must be called.

Arguments:

    Thread - Supplies the thread which no longer needs to be protected
        from deletion.

--*/
{
#ifdef RPC_OLD_IO_PROTECTION
    ((THREAD  *) Thread)->UnprotectThread();
#endif
}

void
I_RpcTransVerifyServerRuntimeCallFromContext(
    void *SendContext
    )
/*++

Routine Description:

    Verifies that the supplied context follows a valid
    runtime server call object.

Arguments:

    SendContext - the context as seen by the transport

Return Value:

--*/
{
    ASSERT(InqTransSCall(SendContext)->InvalidHandle(OSF_SCALL_TYPE) == 0);    
}

const UUID BindNakEEInfoSignatureData = { /* 90740320-fad0-11d3-82d7-009027b130ab */
        0x90740320,
        0xfad0,
        0x11d3,
        {0x82, 0xd7, 0x00, 0x90, 0x27, 0xb1, 0x30, 0xab}
    };

const UUID *BindNakEEInfoSignature = &BindNakEEInfoSignatureData;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\osfpcket.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    osfpcket.cxx

Abstract:

    This file provides helper routines for dealing with packets for the
    OSF Connection Oriented RPC protocol.

Author:

    Michael Montague (mikemon) 23-Jul-1990

Revision History:

    30-Apr-1991    o-decjt

        Initialized the drep[4] fields to reflect integer, character,
        and floating point format.

--*/

#include <precomp.hxx>
#include <osfpcket.hxx>


void
ConstructPacket (
    IN OUT rpcconn_common PAPI * Packet,
    IN unsigned char PacketType,
    IN unsigned int PacketLength
    )
/*++

Routine Description:

    This routine fills in the common fields of a packet, except for the
    call_id.

Arguments:

    Packet - Supplies the packet for which we want to fill in the common
        fields; returns the filled in packet.

    PacketType - Supplies the type of the packet; this is one of the values
        in the rpc_ptype_t enumeration.

    PacketLength - Supplies the total length of the packet in bytes.

--*/
{
    Packet->rpc_vers = OSF_RPC_V20_VERS;
    Packet->rpc_vers_minor = OSF_RPC_V20_VERS_MINOR;
    Packet->PTYPE = PacketType;
    Packet->pfc_flags = 0;
    Packet->drep[0] = NDR_LOCAL_CHAR_DREP | NDR_LOCAL_INT_DREP;
    Packet->drep[1] = NDR_LOCAL_FP_DREP;
    Packet->drep[2] = 0;
    Packet->drep[3] = 0;
    Packet->frag_length = (unsigned short) PacketLength;
    Packet->auth_length = 0;
}

unsigned int PacketSizes[] =
{
    sizeof(rpcconn_request), // rpc_request = 0
    0, // = 1
    sizeof(rpcconn_response), // rpc_response = 2
    FaultSizeWithoutEEInfo, // rpc_fault = 3.  This may not use the whole rpcconn_fault
                            // since we may not send EEInfo.
    0,// = 4
    0,// = 5
    0,// = 6
    0,// = 7
    0,// = 8
    0,// = 9
    0,// = 10
    sizeof(rpcconn_bind), // rpc_bind = 11,
    sizeof(rpcconn_bind_ack), // rpc_bind_ack = 12,
    MinimumBindNakLength, // rpc_bind_nak = 13.  Similar to rpc_fault.
    sizeof(rpcconn_alter_context), // rpc_alter_context = 14,
    sizeof(rpcconn_alter_context_resp), // rpc_alter_context_resp = 15,
    sizeof(rpcconn_auth3), // rpc_auth_3 = 16,
    sizeof(rpcconn_common), // rpc_shutdown = 17.  We do not really process these much.
    sizeof(rpcconn_common), // rpc_cancel = 18,
    sizeof(rpcconn_common) // rpc_orphaned = 19
};

// in many places we treat the size of the request and response interchangeably
// Make sure this is valid on all platforms
C_ASSERT(sizeof(rpcconn_response) == sizeof(rpcconn_request));


unsigned int
MinPacketLength (
    IN rpcconn_common PAPI *Packet
    )
{
    unsigned int Size;

    if (Packet->PTYPE > rpc_orphaned)
        {
        return 0;
        }

    Size = PacketSizes[Packet->PTYPE];
    if (Size == 0)
        {
        return 0;
        }

    if (Packet->pfc_flags & PFC_OBJECT_UUID)
        {
        Size += sizeof(UUID);
        }

    if (Packet->auth_length)
        {
        Size += Packet->auth_length+sizeof(sec_trailer);

        if (Size > Packet->frag_length)
            {
            return 0;
            }

        sec_trailer  * SecurityTrailer = (sec_trailer  *) (((unsigned char  *) Packet) 
                + Packet->frag_length - Packet->auth_length - sizeof(sec_trailer));
        
        Size += SecurityTrailer->auth_pad_length;
        }

    return Size;
}


RPC_STATUS
ValidatePacket (
    IN rpcconn_common PAPI * Packet,
    IN unsigned int PacketLength
    )
/*++

Routine Description:

    This is the routine used to validate a packet and perform data
    conversion, if necessary of the common part of a packet.  In addition,
    to data converting the common part of a packet, we data convert the
    rest of the headers of rpc_request, rpc_response, and rpc_fault packets.

Arguments:

    Packet - Supplies the packet to validate and data convert (if
        necessary).

    PacketLength - Supplies the length of the packet as reported by the
        transport.

Return Value:

    RPC_S_OK - The packet has been successfully validated and the data
        converted (if necessary).

    RPC_S_PROTOCOL_ERROR - The supplied packet does not contain an rpc
        protocol version which we recognize.

--*/
{

    if ( DataConvertEndian(Packet->drep) != 0 )
        {
        // We need to data convert the packet.

        Packet->frag_length = RpcpByteSwapShort(Packet->frag_length);
        Packet->auth_length = RpcpByteSwapShort(Packet->auth_length);
        Packet->call_id = RpcpByteSwapLong(Packet->call_id);

        if (   (Packet->PTYPE == rpc_request)
            || (Packet->PTYPE == rpc_response)
            || (Packet->PTYPE == rpc_fault))
            {
            // We are going to touch fields beyond sizeof(rpcconn_common).
            // Make sure the memory is there.  Since we are touching rpcconn_request's
            // fields it is enough to compare against it.
            if (PacketLength < sizeof(rpcconn_request))
                {
                CORRUPTION_ASSERT(PacketLength >= sizeof(rpcconn_request));
                return(RPC_S_PROTOCOL_ERROR);
                }
            ((rpcconn_request PAPI *) Packet)->alloc_hint = 
                RpcpByteSwapLong(((rpcconn_request PAPI *) Packet)->alloc_hint);
            ((rpcconn_request PAPI *) Packet)->p_cont_id 
                = RpcpByteSwapShort(((rpcconn_request PAPI *) Packet)->p_cont_id);
            if ( Packet->PTYPE == rpc_request )
                {
                ((rpcconn_request PAPI *) Packet)->opnum = 
                    RpcpByteSwapShort(((rpcconn_request PAPI *) Packet)->opnum);
                }
            }
        }
    else if ( (Packet->drep[0] & NDR_DREP_ENDIAN_MASK) != NDR_LOCAL_INT_DREP )
        {
        CORRUPTION_ASSERT(0);
        return(RPC_S_PROTOCOL_ERROR);
        }

    if (Packet->frag_length != (unsigned short) PacketLength)
        {
        CORRUPTION_ASSERT(0);
        return (RPC_S_PROTOCOL_ERROR);
        }

    unsigned int MinLength = MinPacketLength(Packet);

    if (MinLength == 0 || MinLength > PacketLength)
        {
        CORRUPTION_ASSERT(0);
        return (RPC_S_PROTOCOL_ERROR);
        }

    if (   (Packet->rpc_vers != OSF_RPC_V20_VERS)
        || (Packet->rpc_vers_minor > OSF_RPC_V20_VERS_MINOR))
        {
        // Some Unix boxes give these bogus versions to us at times
        // and we will skip asserting on chk builds.
        return(RPC_S_PROTOCOL_ERROR);
        }

    return(RPC_S_OK);
}


void
ByteSwapSyntaxId (
    IN p_syntax_id_t PAPI * SyntaxId
    )
/*++

Routine Description:

    This routine is used to perform data conversion in a syntax identifier
    if necessary.

Arguments:

    SyntaxId - Supplies the syntax identifier to be byte swapped.

--*/
{
    ByteSwapUuid((RPC_UUID *)&SyntaxId->if_uuid);
    SyntaxId->if_version = RpcpByteSwapLong(SyntaxId->if_version);
}

#if 0

void
ConvertStringEbcdicToAscii (
    IN unsigned char * String
    )
/*++

Routine Description:

    We will convert a zero terminated character string from EBCDIC to
    ASCII.  The conversion will be done in place.

Arguments:

    String - Supplies the string to be converted.

--*/
{
    UNUSED(String);
    ASSERT(!RPC_S_CANNOT_SUPPORT);
}
#endif

void
UnpickleEEInfoFromBuffer (
    IN PVOID Buffer,
    IN size_t SizeOfPickledData
    )
{
    RPC_STATUS RpcStatus;
    ExtendedErrorInfo *EEInfo;

    ASSERT(IsBufferAligned(Buffer));
    ASSERT(RpcpGetEEInfo() == NULL);

    RpcStatus = UnpickleEEInfo((unsigned char *)Buffer,
        SizeOfPickledData,
        &EEInfo);

    if (RpcStatus == RPC_S_OK)
        {
        StripComputerNameIfRedundant(EEInfo);
        RpcpSetEEInfo(EEInfo);
        }
}

// the size of all these structs must be 4 byte aligned
C_ASSERT(ConstPadN(sizeof(rpc_sec_vt_pcontext), 4) == 0);
C_ASSERT(ConstPadN(sizeof(rpc_sec_vt_bitmask), 4) == 0);
C_ASSERT(ConstPadN(sizeof(rpc_sec_vt_header2), 4) == 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\osfclnt.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    osfclnt.cxx

Abstract:

    This file contains the client side implementation of the OSF connection
    oriented RPC protocol engine.

Author:

    Michael Montague (mikemon) 17-Jul-1990

Revision History:
    Mazhar Mohammed (mazharm) 11-08-1996 - Major re-haul to support async:
      - Added support for Async RPC, Pipes
      - Changed it to operate as a state machine
      - Changed class structure
      - Got rid of the TRANS classes.

    Kamen Moutafov      (kamenm)    Jan-2000    Support for multiple transfer syntaxes
    Kamen Moutafov (KamenM) Dec 99 - Feb 2000 - Support for cell debugging stuff
    Kamen Moutafov      (KamenM)    Mar-2000    Support for extended error info
--*/

#include <precomp.hxx>
#include <osfpcket.hxx>
#include <bitset.hxx>
#include <queue.hxx>
#include <ProtBind.hxx>
#include <osfclnt.hxx>
#include <rpccfg.h>
#include <epmap.h>
#include <twrtypes.h>
#include <hndlsvr.hxx>
#include <schnlsp.h>
#include <charconv.hxx>
#include <rpcqos.h>
#include <epmp.h>

//
// Maximum retries in light of getting a shutdown
// or closed in doing a bind or shutdown
//
#define MAX_RETRIES  3
// #define RPC_IDLE_CLEANUP_AUDIT
NEW_SDICT(OSF_CASSOCIATION);

MUTEX *AssocDictMutex = NULL;
OSF_CASSOCIATION_DICT * AssociationDict;
long OsfLingeredAssociations = 0;
const long MaxOsfLingeredAssociations = 8;
ULONG OsfDestroyedAssociations = 0;
const ULONG NumberOfOsfDestroyedAssociationsToSample = 128;

// in 100 nano-second intervals, this constant is 2 seconds
const DWORD DestroyedOsfAssociationBatchThreshold = 1000 * 10 * 1000 * 2;

ULARGE_INTEGER OsfLastDestroyedAssociationsBatchTimestamp;

inline BOOL
SwapTokenIfNecessary (
    IN OSF_BINDING_HANDLE *BindingHandle, OPTIONAL
    OUT HANDLE *OldToken
    )
/*++

Routine Description:

    Checks if the binding handle is named pipe and if the type of named
    pipe requires token swapping before send. If yes, it swaps the token.
    Return value is whether the token was swapped.

Arguments:

    BindingHandle - the binding handle on which the send is done. If not present,
        no swapping is done.

    OldToken - on output, the old token is saved here. This variable is always
        initialized and can be counted to be NULL even if no swapping was done.

Return Value:

    non-zero if the token was swapped.
    zero otherwise.

--*/
{
    if (BindingHandle 
        && IsNamedPipe(BindingHandle->NPType)
        && IsLocalNamedPipe(BindingHandle->NPType)
        && IsDynamicNamedPipe(BindingHandle->NPType)
        )
        {
        return BindingHandle->SwapToken(OldToken);
        }
    else
        return FALSE;
}


OSF_BINDING_HANDLE::OSF_BINDING_HANDLE (
    IN OUT RPC_STATUS  * Status
    ) : BINDING_HANDLE(Status)
{
    ALLOCATE_THIS(OSF_BINDING_HANDLE);

    ObjectType = OSF_BINDING_HANDLE_TYPE;
    Association = 0;
    ReferenceCount = 1;
    DceBinding = 0;
    TransInfo = 0;
    TransAuthInitialized = 0;
    pToken = 0;
}



OSF_BINDING_HANDLE::~OSF_BINDING_HANDLE (
    )
{
    OSF_RECURSIVE_ENTRY *RecursiveEntry;
    DictionaryCursor cursor;

    if (Association != 0)
        {
        Unbind();
        // Can't touch Association after this point.
        }
    else
        {
        delete DceBinding;
        }

    RecursiveCalls.Reset(cursor);

    while ((RecursiveEntry = RecursiveCalls.Next(cursor)))
       {
       delete RecursiveEntry->CCall;
       }
}


RPC_STATUS
OSF_BINDING_HANDLE::AcquireCredentialsForTransport(
    )
/*++
Function Name:AcquireCredentialsForTransport

Parameters:

Description:

Returns:

--*/
{
    BOOL Result, fTokenFound;
    unsigned long Size;
    RPC_STATUS Status;
    HANDLE ImpersonationToken = 0;
    TOKEN_STATISTICS TokenStatisticsInformation;
    
    //
    // This function is called only when RPC security is not being used
    //
    ASSERT(IsNamedPipe(NPType));
    ASSERT(ClientAuthInfo.AuthenticationService == RPC_C_AUTHN_NONE);
    ASSERT(Association);

    if (OpenThreadToken (GetCurrentThread(),
                        TOKEN_IMPERSONATE | TOKEN_QUERY,
                        TRUE,
                        &ImpersonationToken) == FALSE)
        {
        ClientAuthInfo.DefaultLogonId = TRUE;
        pToken = NULL;

        Status = GetLastError();
        if (Status != ERROR_NO_TOKEN)
            {
            RpcpErrorAddRecord(EEInfoGCRuntime,
                RPC_S_ACCESS_DENIED,
                EEInfoDLOSF_BINDING_HANDLE__AcquireCredentialsForTransport10,
                (ULONG)Status);

            return RPC_S_ACCESS_DENIED;
            }

        return RPC_S_OK;
        }



    Result = GetTokenInformation(
                 ImpersonationToken,
                 TokenStatistics,
                 &TokenStatisticsInformation,
                 sizeof(TOKEN_STATISTICS),
                 &Size
                 );
    if (Result != TRUE)
        {
        ClientAuthInfo.DefaultLogonId = TRUE;
        CloseHandle(ImpersonationToken);
        
        RpcpErrorAddRecord(EEInfoGCRuntime,
            RPC_S_ACCESS_DENIED,
            EEInfoDLOSF_BINDING_HANDLE__AcquireCredentialsForTransport20,
            (ULONG)GetLastError());
        return RPC_S_ACCESS_DENIED;
        }


    ClientAuthInfo.DefaultLogonId = FALSE;

    Status = Association->FindOrCreateToken(
                            ImpersonationToken,
                            &TokenStatisticsInformation.AuthenticationId,
                            &pToken,
                            &fTokenFound);
    if (Status != RPC_S_OK)
        {
        //
        // If there is a failure, the callee will free the token
        //
        return Status;
        }

    if (fTokenFound)
        {
        CloseHandle(ImpersonationToken);
        }

    ASSERT(pToken);
    FastCopyLUIDAligned(&ClientAuthInfo.ModifiedId, &pToken->ModifiedId);

    return RPC_S_OK;
}


BOOL
ReplaceToken(
    HANDLE NewToken
    )
/*++
Function Name:ReplaceToken

Parameters:

Description:

Returns:

--*/
{
    NTSTATUS NtStatus;
    HANDLE hTokenToReplace = NewToken;

    //
    // This thread should either have a null token or
    // the token we captured in Initialize. It cannot have
    // any other token.
    //
    NtStatus = NtSetInformationThread(NtCurrentThread(),
                                      ThreadImpersonationToken,
                                      &hTokenToReplace,
                                      sizeof(HANDLE));


    if (!NT_SUCCESS(NtStatus))
        {
        return FALSE;
        }

    return TRUE;
}

inline void
RestoreTokenIfNecessary (
    IN BOOL fTokenSwapped,
    IN HANDLE OldToken
    )
/*++

Routine Description:

    Restores the old token if necessary.

Arguments:

    fTokenSwapped - non-zero if the token was swapped and OldToken needs to
        be restored to the thread. Zero otherwise.

    OldToken - the token that was saved. If fTokenSwapped is zero, this parameter
        is ignored.

Return Value:

--*/
{
    if (fTokenSwapped)
        {
        ReplaceToken(OldToken);
        if (OldToken)
            {
            CloseHandle(OldToken);
            }
        }
}


BOOL
OSF_BINDING_HANDLE::SwapToken (
    HANDLE *OldToken
    )
/*++
Function Name:SwapToken

Parameters:

Description:

Returns:

--*/
{

    HANDLE ImpersonationToken = 0;
    HANDLE NewToken ;

    *OldToken = 0;

    if (!(ClientAuthInfo.AuthenticationService == RPC_C_AUTHN_NONE && IsNamedPipe(NPType)))
        {
        return FALSE;
        }

    if (pToken == 0)
        {
        NewToken = 0;
        }
    else
        {
        NewToken = pToken->hToken;
        }

    ImpersonationToken = 0;

    if (OpenThreadToken (GetCurrentThread(),
        TOKEN_IMPERSONATE | TOKEN_QUERY,
        TRUE,
        &ImpersonationToken) == FALSE)
        {
        ImpersonationToken = 0;
        }

    if (ReplaceToken(NewToken) == FALSE)
        {
        if (ImpersonationToken)
            {
            CloseHandle(ImpersonationToken);
            }

        return FALSE;
        }

    *OldToken = ImpersonationToken;

    return TRUE;
}


RPC_STATUS 
OSF_BINDING_HANDLE::NegotiateTransferSyntax (
    IN OUT PRPC_MESSAGE Message
    )
/*++
Function Name:NegotiateTransferSyntax

Parameters:

Description:
    Negotiate a transfer syntax, if necessary. A bind/alter context may be done
    in the process.

Returns:
    Status of the operation

--*/
{
    OSF_CCALL *CCall;
    RPC_STATUS Status;
    unsigned int NotChangedRetry = 0;
    unsigned int Retry;
    RPC_CLIENT_INTERFACE *ClientInterface;
    BOOL fResult;
    BOOL fRetry;

    AssocDictMutex->VerifyNotOwned();

    for (;;)
        {
        Retry = 0;
        for (;;)
            {
            //
            // Allocate a call object.
            //
            Status = AllocateCCall(&CCall, Message, &fRetry);
            Message->Handle = (RPC_BINDING_HANDLE) CCall;
            if (Status == RPC_S_OK)
                {
                // by now the Binding in the CCall should have
                // been fixed or in the async case, NDR20 should have been
                // used
                ClientInterface = (RPC_CLIENT_INTERFACE *)Message->RpcInterfaceInformation;
                if (DoesInterfaceSupportMultipleTransferSyntaxes(ClientInterface))
                    Message->TransferSyntax = CCall->GetSelectedBinding()->GetTransferSyntaxId();
                return Status;
                }

            if ((Status != RPC_P_CONNECTION_SHUTDOWN)
                && (Status != RPC_P_CONNECTION_CLOSED)
                && (fRetry == FALSE))
                {
                break;
                }

            // AllocateCCall sets fRetry to TRUE if it has freed the association.
            if (this->Association != 0 && fRetry == FALSE)
               {
               Association->ShutdownRequested(Status, NULL);
               }

            Retry++;
            if (Retry == MAX_RETRIES)
               break;
            }

        if (Status == EPT_S_NOT_REGISTERED)
            {

            BindingMutex.Request();

            if (DceBinding == NULL)
                {
                // in a scenario where multiple threads make an RPC
                // call on the same binding handle, it is possible that
                // even though this thread failed with EPT_S_NOT_REGISTERED
                // another thread succeeded and transferred the ownership of
                // the DceBinding to the association. In such case we're
                // already bound to an association, and all we need is to
                // loop around and try the call again
                BindingMutex.Clear();
                continue;
                }

            // we ran out of endpoints - drop the endpoint set for the next
            // iteration
            fResult = DceBinding->MaybeMakePartiallyBound(
                   (PRPC_CLIENT_INTERFACE)Message->RpcInterfaceInformation,
                   InqPointerAtObjectUuid());
            if (fResult)
                {
                if ( *InquireEpLookupHandle() != 0 )
                    {
                    EpFreeLookupHandle(*InquireEpLookupHandle());
                    *InquireEpLookupHandle() = 0;
                    }
                }

            BindingMutex.Clear();

            break;
            }

        if (Status != RPC_S_SERVER_UNAVAILABLE)
            {
            break;
            }

        // if this is either a static endpoint, or an endpoint resolved through
        // the interface information, there is no need to iterate
        if (!fDynamicEndpoint 
            || 
            ((RPC_CLIENT_INTERFACE *)Message->RpcInterfaceInformation)->RpcProtseqEndpointCount)
            {
            break;
            }

        //
        // If we reach here, it means that we are iterating through the list
        // of endpoints obtained from the endpoint mapper.
        //
        BindingMutex.Request();

        if (ReferenceCount == 1
            && Association != 0)
            {

            // there is an association (which means the server's endpoint
            // mapper was contacted), and the refcount is 1 (we're the
            // only user). We know this is a dynamic endpoint. We have
            // the following cases to take care of:
            // - the list of endpoints is exhausted. If this is the case,
            //   we wouldn't have gotten here, as we will get 
            //   EPT_S_NOT_REGISTERED from AllocateCCall and we would
            //   have bailed out earlier on the first iteration. Since
            //   the code above would have dropped the endpoints list for
            //   the next iteration, we will be fine
            // - we're iterating over the list of endpoints in the same
            //   call. In this case, we will be getting server unavailable
            //   from each endpoint for which the server is not there,
            //   and we will move on to the next endpoint, until we exhaust
            //   them and get EPT_S_NOT_REGISTERED

            DceBinding = Association->DuplicateDceBinding();

            if (DceBinding == NULL)
                {
                BindingMutex.Clear();
                return RPC_S_OUT_OF_MEMORY;
                }

            // We should not unbind if DceBinding could not be replicated from the
            // Association.  If we unbind when DceBinding == NULL, then Association
            // will be set to NULL and we may AV in OSF_BINDING_HANDLE::AllocateCCall
            // since it is assumed there that either Adssociation != NULL or DceBinding != NULL.
            Unbind();
            // Can't touch Association after this point.

            RpcpErrorAddRecord(EEInfoGCRuntime,
                Status,
                EEInfoDLOSF_BINDING_HANDLE__NegotiateTransferSyntax10,
                DceBinding->InqEndpoint()
                );

            // whack the endpoint and move on to the next (if any)
            fResult = DceBinding->MaybeMakePartiallyBound(
                   (PRPC_CLIENT_INTERFACE)Message->RpcInterfaceInformation,
                   InqPointerAtObjectUuid());
            if (fResult == FALSE)
                {
                NotChangedRetry += 1;
                RpcpPurgeEEInfo();
                }
            else
                {
                // we don't purge here because we want next iterations
                // to add to the record
                NotChangedRetry = 0;
                }
            }
        else
            {
            // either there is more then one reference to the binding handle,
            // or the endpoint mapper could not be contacted (i.e. no
            // association)
            NotChangedRetry += 1;
            RpcpPurgeEEInfo();
            }
        BindingMutex.Clear();

        if (NotChangedRetry > 4)
            {
            return(RPC_S_SERVER_UNAVAILABLE);
            }
        }

    ASSERT(Status != RPC_S_OK);

    if (Status == RPC_P_CONNECTION_CLOSED
        || Status == RPC_P_CONNECTION_SHUTDOWN)
        {
        return(RPC_S_CALL_FAILED_DNE);
        }
    return(Status);
}


RPC_STATUS
OSF_BINDING_HANDLE::GetBuffer (
    IN PRPC_MESSAGE Message,
    IN UUID *ObjectUuid
    )
/*++
Function Name:GetBuffer

Parameters:

Description:
    Ask the call object for a buffer

Returns:

--*/
{
    ASSERT(!"We should never be here - the binding handle cannot allocate a buffer");
    return RPC_S_INTERNAL_ERROR;
}


RPC_STATUS
OSF_BINDING_HANDLE::AllocateCCall (
    OUT OSF_CCALL *  *CCall,
    IN PRPC_MESSAGE Message,
    OUT BOOL *Retry
    )
/*++
Function Name:AllocateCCall

Parameters:
    CCall - Returns the allocated Call object

    Message - The RPC_MESSAGE for this call.

    Retry - if set on output, the caller should retry the allocation and 
        the Association may have been deleted.

Description:
    Finds an existing association or creates a new one. Asks the association
    to allocate the call object for us.

Returns:
    RPC_S_OK or an error code.

--*/
{
    OSF_RECURSIVE_ENTRY *RecursiveEntry;
    CLIENT_AUTH_INFO * AuthInfo;
    RPC_STATUS Status;
    BOOL fDynamic = FALSE;
    CLIENT_AUTH_INFO AuthInfo2;
    DictionaryCursor cursor;
    BOOL fBindingHandleReferenceRemoved;
    ULONG_PTR CallTimeout;

    *Retry = FALSE;

    BindingMutex.Request();

    //
    // First we need to check if there is already a recursive Call
    // for this thread and interface.  To make the common case quicker,
    // we will check to see if there are any Calls in the dictionary
    // first. ** We will find a recursive call only in the case of callbacks **
    //
    if ( RecursiveCalls.Size() != 0 )
        {
        RecursiveCalls.Reset(cursor);
        while ( (RecursiveEntry = RecursiveCalls.Next(cursor)) != 0 )
            {
            *CCall = RecursiveEntry->IsThisMyRecursiveCall(
                               GetThreadIdentifier(),
                               (RPC_CLIENT_INTERFACE  *)
                               Message->RpcInterfaceInformation);
            if ( *CCall != 0 )
                {
                BindingMutex.Clear();

                if ((*CCall)->CurrentState == Aborted)
                    {
                    return (*CCall)->AsyncStatus;
                    }

                //
                // This reference will be removed when the send
                // for this call is complete
                //
                (*CCall)->CurrentState = SendingFirstBuffer;
                return(RPC_S_OK);
                }
            }
        }

    if (Association == 0)
        {
        // if we don't have an object UUID, and we have a dynamic endpoint, 
        // attempt quick resolution
        if (InqIfNullObjectUuid() && DceBinding->IsNullEndpoint())
            {
            Association = FindOrCreateAssociation(
                                                  DceBinding,
                                                  TransInfo,
                                                  (RPC_CLIENT_INTERFACE *)Message->RpcInterfaceInformation
                                                  );
            AssocDictMutex->VerifyNotOwned();


            // do nothing in both cases. In failure case, we will do full
            // resolution. In success case, ownership of the dce binding
            // has passed to the association, and we don't need to copy
            // the resolved endpoint back
            }

        // if we are still NULL, attempt full resolution
        if (Association == NULL)
            {
            Status = OSF_BINDING_HANDLE::InqTransportOption(
                RPC_C_OPT_CALL_TIMEOUT,
                &CallTimeout);

            // this function cannot fail unless it is given invalid
            // parameters
            ASSERT(Status == RPC_S_OK);

            Status = DceBinding->ResolveEndpointIfNecessary(
                                   (RPC_CLIENT_INTERFACE  *)
                                   Message->RpcInterfaceInformation,
                                   InqPointerAtObjectUuid(),
                                   InquireEpLookupHandle(),
                                   FALSE,
                                   InqComTimeout(),
                                   (ULONG)CallTimeout,
                                   &ClientAuthInfo
                                   );
            if ( Status != RPC_S_OK )
                {
                BindingMutex.Clear();
                return(Status);
                }

            Association = FindOrCreateAssociation(
                                                  DceBinding,
                                                  TransInfo,
                                                  NULL
                                                  );

            AssocDictMutex->VerifyNotOwned();

            if (Association == 0)
                {
                BindingMutex.Clear();

                return RPC_S_OUT_OF_MEMORY;
                }
            }

        //
        // Ownership of the DCE binding passes to the association.  We are
        // going to set the field to zero so that no one screws with them.
        //
        DceBinding = 0;

        if (ClientAuthInfo.AuthenticationService == RPC_C_AUTHN_NONE && IsNamedPipe(NPType))
            {
            if (TransAuthInitialized == 0)
                {
                Status = AcquireCredentialsForTransport();
                if (Status != RPC_S_OK)
                    {
                    BindingMutex.Clear();
                    return Status;
                    }
                TransAuthInitialized = 1;
                }
            }
        }
    else
        {
        if (Association->IsValid() == 0)
            {
            // Check if the last association to use the binding handle is going away.
            if (ReferenceCount == 1)
                {
                // If this is the last association, we need to copy the DceBinding
                // back onto the binding handle.
                DceBinding = Association->DuplicateDceBinding();
                if (DceBinding == 0)
                    {
                    Status = RPC_S_OUT_OF_MEMORY;
                    }
                else
                    {
                    Status = Association->AssociationShutdownError;
                    Unbind();
                    // Can't touch Association after this point.
                    *Retry = TRUE;
                    }
                }
            else
                {
                Status = Association->AssociationShutdownError;
                }

            BindingMutex.Clear();

            // If we called Unbind() then as soon as we clear the mutex,
            // another thread may come and initialize Association.
            // The caller can't know whether Association has been
            // freed here by looking at this->Association upon return.
            // Fortunately, the path freeing the association is the only path
            // setting Retry = TRUE and the caller can check this flag.

            return Status;
            }
        }

    //
    // We will assume that we are successfully able to allocate a Call,
    // so we bump the reference count now.
    //
    ReferenceCount++;

    AuthInfo  = InquireAuthInformation();

    //
    // If this is a secure BH and it requires DYNAMIC TRACKING, check if
    // LogonID has changed. If it has changed, get new Credential Handle
    //
    if ((AuthInfo != 0)
        && (AuthInfo->AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE)
        && (AuthInfo->IdentityTracking == RPC_C_QOS_IDENTITY_DYNAMIC))
        {
        Status = ReAcquireCredentialsIfNecessary();
        if (Status != RPC_S_OK)
            {
            ReferenceCount -=1;
            BindingMutex.Clear();

            return (Status);
            }

        fDynamic = TRUE;
        AuthInfo = AuthInfo->ShallowCopyTo(&AuthInfo2);
        AuthInfo->ReferenceCredentials();
        }

    BindingMutex.Clear();

    Status = Association->AllocateCCall(
                                        this,
                                        Message,
                                        AuthInfo,
                                        CCall,
                                        &fBindingHandleReferenceRemoved);

    if (fDynamic)
        AuthInfo->PrepareForDestructionAfterShallowCopy();

    if ( Status == RPC_S_OK )
        {
        if ((*CCall)->CurrentState != SendingFirstBuffer
            && (*CCall)->Connection->fExclusive)
            {
            OSF_CCALL_STATE myState = (*CCall)->CurrentState;

            Status = (*CCall)->BindToServer(
                FALSE   // sync bind
                );
            if (Status != RPC_S_OK)
                {
                //
                // Call has not yet started, ok to directly
                // free the call.
                //
                if (myState == NeedOpenAndBind)
                    {
                    (*CCall)->FreeCCall(RPC_S_CALL_FAILED_DNE);
                    }
                else
                    {
                    (*CCall)->FreeCCall(Status);
                    }
                }
            }
        }
    else
        {
        if (fBindingHandleReferenceRemoved == 0)
            {
            BindingMutex.Request();
            ReferenceCount -= 1;       
            ASSERT( ReferenceCount != 0 );
            BindingMutex.Clear();
            }
        }

    return Status;
}


RPC_STATUS
OSF_BINDING_HANDLE::BindingCopy (
    OUT BINDING_HANDLE *  * DestinationBinding,
    IN UINT MaintainContext
    )
/*++

Routine Description:

    We need to copy this binding handle.  This is relatively easy to
    do: we just need to point the copied binding handle to the same
    association as this binding handle.  We also need to tell the
    association about the new binding handle.

Arguments:

    DestinationBinding - Returns a copy of this binding handle.

    MaintainContext - Supplies a flag that indicates whether or not context
        is being maintained over this binding handle.  A non-zero value
        indicates that context is being maintained.

Return Value:

    RPC_S_OUT_OF_MEMORY - This indicates that there is not enough memory
        to allocate a new binding handle.

    RPC_S_OK - We successfully copied this binding handle.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    OSF_BINDING_HANDLE * Binding;
    RPC_UUID Uuid;
    CLIENT_AUTH_INFO * AuthInfo;

    Binding = new OSF_BINDING_HANDLE(&Status);
    if ( Status != RPC_S_OK )
        {
        delete Binding;
        Binding = 0;
        }
    if ( Binding == 0 )
        {
        *DestinationBinding = 0;
        return(RPC_S_OUT_OF_MEMORY);
        }

    BindingMutex.Request();

    Status = Binding->BINDING_HANDLE::Clone( this );
    if (Status != RPC_S_OK)
        {
        delete Binding;
        Binding = 0;
        *DestinationBinding = 0;

        BindingMutex.Clear();

        return Status;
        }

    Binding->ClientAuthInfo.DefaultLogonId = ClientAuthInfo.DefaultLogonId;
    Binding->NPType = NPType;
    Binding->fDynamicEndpoint = fDynamicEndpoint;

    if (pToken)
        {
        ASSERT(Association);
        ASSERT(IsNamedPipe(NPType));
        Association->ReferenceToken(pToken);
        Binding->pToken = pToken;
        FastCopyLUIDAligned(&(Binding->ClientAuthInfo.ModifiedId),
            &(pToken->ModifiedId));
        }

    Binding->Association = Association;
    if ( DceBinding != 0 )
        {
        ASSERT( MaintainContext == 0 );

        Binding->DceBinding = DceBinding->DuplicateDceBinding();
        }
    else
        {
        Binding->DceBinding = 0;
        }

    Binding->TransInfo = TransInfo;

    if ( Association != 0 )
        {
        Association->IncrementCount();
        if ( MaintainContext != 0 )
            {
            Association->MaintainingContext();
            }
        }

    BindingMutex.Clear();

    *DestinationBinding = (BINDING_HANDLE *) Binding;
    return(RPC_S_OK);
}


RPC_STATUS
OSF_BINDING_HANDLE::BindingFree (
    )
/*++

Routine Description:

    This method gets called when the application calls RpcBindingFree.
    All we have got to do is to decrement the reference count, and if
    it has reached zero, delete the binding handle.

Return Value:

    RPC_S_OK - This operation always succeeds.

--*/
{
    BindingMutex.Request();
    ReferenceCount -= 1;

    if ( ReferenceCount == 0 )
        {
        BindingMutex.Clear();
        delete this;
        }
    else
        {
        BindingMutex.Clear();
        }

    return(RPC_S_OK);
}


RPC_STATUS
OSF_BINDING_HANDLE::PrepareBindingHandle (
    IN TRANS_INFO  * TransInfo,
    IN DCE_BINDING * DceBinding
    )
/*++

Routine Description:

    This method will be called just before a new binding handle is returned
    to the user.  We just stash the transport interface and binding
    information so we can use it later when the first remote procedure
    call is made.  At that time, we will actually bind to the interface.

Arguments:

    TransportInterface - Supplies a pointer to a data structure describing
        a loadable transport.

    DceBinding - Supplies the binding information for this binding handle.

--*/
{
    RPC_STATUS RpcStatus;
    SECURITY_QUALITY_OF_SERVICE SecQos;
    BOOL IsLocal;

    this->TransInfo = (TRANS_INFO *) TransInfo;
    this->DceBinding = DceBinding;

    fDynamicEndpoint = DceBinding->IsNullEndpoint();
    // let's see if this is named pipe, and if yes, what options do we have
    if (DceBinding->IsNamedPipeTransport())
        {
        IsLocal = (DceBinding->InqNetworkAddress() == NULL);
        if (DceBinding->InqNetworkOptions() == NULL)
            {
            if (IsLocal)
                {
                // if we go through NPFS, the default is dynamic
                SecQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
                }
            else
                {
                // if we go through RDR, the default is static
                SecQos.ContextTrackingMode = SECURITY_STATIC_TRACKING;
                }
            }
        else
            {
            RpcStatus = I_RpcParseSecurity (DceBinding->InqNetworkOptions(),
                &SecQos);
            if (RpcStatus != RPC_S_OK)
                return RpcStatus;
            }

        if (IsLocal)
            {
            if (SecQos.ContextTrackingMode == SECURITY_STATIC_TRACKING)
                NPType = nptLocalStatic;
            else
                NPType = nptLocalDynamic;
            }
        else
            {
            if (SecQos.ContextTrackingMode == SECURITY_STATIC_TRACKING)
                NPType = nptRemoteStatic;
            else
                NPType = nptRemoteDynamic;
            }
        }
    else
        {
        NPType = nptNotNamedPipe;
        }

    Association = 0;

    return RPC_S_OK;
}


RPC_STATUS
OSF_BINDING_HANDLE::ToStringBinding (
    OUT RPC_CHAR  *  * StringBinding
    )
/*++

Routine Description:

    We need to convert the binding handle into a string binding.  If the
    binding handle has not yet been used to make a remote procedure
    call, then we can just use the information in the binding handle to
    create the string binding.  Otherwise, we need to ask the association
    to do it for us.

Arguments:

    StringBinding - Returns the string representation of the binding
        handle.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_MEMORY - We do not have enough memory available to
        allocate space for the string binding.

--*/
{
    if ( Association == 0 )
        {
        *StringBinding = DceBinding->StringBindingCompose(
                                                          InqPointerAtObjectUuid());
        if (*StringBinding == 0)
            return(RPC_S_OUT_OF_MEMORY);
        return(RPC_S_OK);
        }
    return(Association->ToStringBinding(StringBinding,
                                    InqPointerAtObjectUuid()));
}


RPC_STATUS
OSF_BINDING_HANDLE::BindingReset (
    )
/*++

Routine Description:

    This routine will set the endpoint of this binding handle to zero,
    if possible.  The binding handle will become partially bound as a
    result.  If a remote procedure call has been made on this binding
    handle, it will fail as well.

Return Value:

    RPC_S_OK - The binding handle has successfully been made partially
        bound.

    RPC_S_WRONG_KIND_OF_BINDING - The binding handle currently has remote
        procedure calls active.

--*/
{
    BindingMutex.Request();

    if ( Association != 0 )
        {
        if ( ReferenceCount != 1 )
            {
            BindingMutex.Clear();
            return(RPC_S_WRONG_KIND_OF_BINDING);
            }

        DceBinding = Association->DuplicateDceBinding();

        if (DceBinding == NULL)
            {
            BindingMutex.Clear();
            return RPC_S_OUT_OF_MEMORY;
            }
        Unbind();
        // Can't touch Association after this point.
        }

    DceBinding->MakePartiallyBound();
    fDynamicEndpoint = TRUE;

    if ( *InquireEpLookupHandle() != 0 )
        {
        EpFreeLookupHandle(*InquireEpLookupHandle());
        *InquireEpLookupHandle() = 0;
        }

    BindingMutex.Clear();
    return(RPC_S_OK);
}


ULONG
OSF_BINDING_HANDLE::MapAuthenticationLevel (
    IN ULONG AuthenticationLevel
    )
/*++

Routine Description:

    The connection oriented protocol module supports all authentication
    levels except for RPC_C_AUTHN_LEVEL_CALL.  We just need to map it
    to RPC_C_AUTHN_LEVEL_PKT.

--*/
{
    UNUSED(this);

    if ( AuthenticationLevel == RPC_C_AUTHN_LEVEL_CALL )
        {
        return(RPC_C_AUTHN_LEVEL_PKT);
        }

    return(AuthenticationLevel);
}



RPC_STATUS
OSF_BINDING_HANDLE::ResolveBinding (
    IN PRPC_CLIENT_INTERFACE RpcClientInterface
    )
/*++

Routine Description:

    We need to try and resolve the endpoint for this binding handle
    if necessary (the binding handle is partially-bound).  We check
    to see if an association has been obtained for this binding
    handle; if so, we need to do nothing since the binding handle is
    fully-bound, otherwise, we try and resolve an endpoint for it.

Arguments:

    RpcClientInterface - Supplies interface information to be used
        in resolving the endpoint.

Return Value:

    RPC_S_OK - The binding handle is now fully-bound.

    RPC_S_NO_ENDPOINT_FOUND - We were unable to resolve the endpoint
        for this particular combination of binding handle (network address)
        and interface.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to resolve
        the endpoint.

--*/
{
    RPC_STATUS Status;

    BindingMutex.Request();
    if ( Association == 0 )
        {
        Status = DceBinding->ResolveEndpointIfNecessary(
                                                      RpcClientInterface,
                                                      InqPointerAtObjectUuid(),
                                                      InquireEpLookupHandle(),
                                                      FALSE,
                                                      InqComTimeout(),
                                                      DEFAULT_EPMAP_CALL_TIMEOUT, // CallTimeout
                                                      &ClientAuthInfo
                                                      );
        }
    else
        {
        Status = RPC_S_OK;
        }
    BindingMutex.Clear();

    return(Status);
}


RPC_STATUS
OSF_BINDING_HANDLE::AddRecursiveEntry (
    IN OSF_CCALL * CCall,
    IN PRPC_CLIENT_INTERFACE RpcInterfaceInformation
    )
/*++

Routine Description:

    When a callback occurs, we need to add an entry for the thread and
    interface being using for the callback to the binding handle.  This
    is so that we can later turn original calls into callbacks if they
    are from the same thread (as the original call) and to the same
    interface (as the original call).

Arguments:

    CCall - Supplies the Call on which the original call was
        sent.

    RpcInterfaceInformation - Supplies the interface used by the original
        call.

Return Value:

    RPC_S_OK - An recursive entry has been added to the binding handle for
        the supplied Call and interface.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to perform the
        operation.

--*/
{
    OSF_RECURSIVE_ENTRY * RecursiveEntry;

    BindingMutex.Request();
    RecursiveEntry = new OSF_RECURSIVE_ENTRY(GetThreadIdentifier(),
            RpcInterfaceInformation, CCall);
    if ( RecursiveEntry == 0 )
        {
        BindingMutex.Clear();
        return(RPC_S_OUT_OF_MEMORY);
        }

    CCall->RecursiveCallsKey = RecursiveCalls.Insert(
            RecursiveEntry);
    if ( CCall->RecursiveCallsKey == -1 )
        {
        BindingMutex.Clear();
        delete RecursiveEntry;
        return(RPC_S_OUT_OF_MEMORY);
        }

    ReferenceCount += 1;
    BindingMutex.Clear();

    return(RPC_S_OK);
}


void
OSF_BINDING_HANDLE::RemoveRecursiveCall (
    IN OSF_CCALL * CCall
    )
/*++

Routine Description:

    The specified Call is removed from the dictionary of active
    Calls for this binding handle.

Arguments:

    CCall - Supplies the Call to be removed from the
        dictionary of active Calls.

--*/
{
    OSF_RECURSIVE_ENTRY * RecursiveEntry;

    BindingMutex.Request();
    RecursiveEntry = RecursiveCalls.Delete(CCall->RecursiveCallsKey);
    if ( RecursiveEntry != 0 )
        {
        delete RecursiveEntry;
        }
    CCall->RecursiveCallsKey = -1;
    ReferenceCount -= 1;
    BindingMutex.Clear();
}


OSF_CASSOCIATION *
OSF_BINDING_HANDLE::FindOrCreateAssociation (
    IN DCE_BINDING * DceBinding,
    IN TRANS_INFO *TransInfo,
    IN RPC_CLIENT_INTERFACE *InterfaceInfo
    )
/*++
Function Name:FindOrCreateAssociation

Parameters:
    DceBinding - Supplies binding information; ownership of this object
        passes to this routine.

    TransportInterface - Supplies a pointer to the data structure which
        describes a loadable transport.

    InterfaceInfo - Supplied the interface information for this call. Used
        to make quick resolution on new binding handles if existing bindings
        for this interface exist. If supplied, it takes precedence over
        endpoint matching for selecting an association, and no new association
        will be created - only existing ones will be found!


Description:
    This routine finds an existing association supporting the requested
    DCE binding, or create a new association which supports the
    requested DCE binding.  Ownership of the passed DceBinding pass
    to this routine.

Returns:

    An association which supports the requested binding will be returned;
    Otherwise, zero will be returned, indicating insufficient memory.
--*/
{
    OSF_CASSOCIATION * CAssociation;
    RPC_STATUS Status = RPC_S_OK;
    DictionaryCursor cursor;
    ULONG_PTR fUnique;
    BOOL fOnlyEndpointDifferent;
    int Result;

    Status = OSF_BINDING_HANDLE::InqTransportOption(RPC_C_OPT_UNIQUE_BINDING, &fUnique);
    ASSERT(Status == RPC_S_OK);

    //
    // We start be looking in the dictionary of existing associations
    // to see if there is one supporting the binding information specified.
    //

    AssocDictMutex->Request();

    if (fUnique == 0)
        {
        AssociationDict->Reset(cursor);
        while ( (CAssociation = AssociationDict->Next(cursor)) != 0 )
            {
            if (CAssociation->IsValid())
                {
                // if we're doing shortcut endpoint resolution, and the binding
                // handle wants to mutually authenticate the server using the
                // endpoint mapper (endpoint mapper namespace partitioning) but 
                // the association hasn't used that capability, don't do shortcut
                // endpoint resolution
                if (InterfaceInfo
                    && (ClientAuthInfo.Capabilities & RPC_C_QOS_CAPABILITIES_LOCAL_MA_HINT)
                    && !CAssociation->LocalMASet
                    )
                    {
                    AssocDictMutex->Clear();
                    return NULL;
                    }

                Result = CAssociation->CompareWithDceBinding(DceBinding, 
                    &fOnlyEndpointDifferent);
                // if the DceBindings are the same, or they differ only
                // by the endpoint, and it is a NULL endpoint, and there
                // is InterfaceInfo specified, and this association 
                // supports at least one binding for this interface, and either
                // this is not the management UUID or the association has a non-
                // NULL object uuid, then choose the association
                if (!Result 
                    ||
                    (
                        fOnlyEndpointDifferent 
                        && DceBinding->IsNullEndpoint()
                        && InterfaceInfo
                        && CAssociation->DoesBindingForInterfaceExist(InterfaceInfo)
                        &&
                         (
                          (RpcpMemoryCompare(&InterfaceInfo->InterfaceId.SyntaxGUID, &MgmtIf, sizeof(UUID)) != 0)
                          ||
                          (CAssociation->DceBinding->IsNullObjectUuid() == FALSE)
                         )
                    )
                   )
                    {
                    if (CAssociation->Linger.fAssociationLingered == TRUE)
                        {
#if defined (RPC_GC_AUDIT)
                        DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) OSF lingering association resurrected %X %S %S %S\n",
                            GetCurrentProcessId(), GetCurrentProcessId(), CAssociation,
                        CAssociation->DceBinding->InqRpcProtocolSequence(),
                        CAssociation->DceBinding->InqNetworkAddress(), 
                        CAssociation->DceBinding->InqEndpoint());
#endif
                        OsfLingeredAssociations --;
                        ASSERT(OsfLingeredAssociations >= 0);
                        CAssociation->Linger.fAssociationLingered = FALSE;
                        }

                    if ((ClientAuthInfo.Capabilities & RPC_C_QOS_CAPABILITIES_LOCAL_MA_HINT)
                        && !CAssociation->LocalMASet)
                        {
                        CAssociation->LocalMASet = TRUE;
                        }

                    CAssociation->IncrementCount();
                    AssocDictMutex->Clear();

                    delete DceBinding;

                    return(CAssociation);
                    }
                }
            }
        }


    // if asked to do short endpoint resolution, don't create new association
    if (InterfaceInfo)
        {
        AssocDictMutex->Clear();
        return NULL;
        }

#if defined (RPC_GC_AUDIT)
    DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Creating association to: %S, %S, %S\n",
        GetCurrentProcessId(), GetCurrentProcessId(), DceBinding->InqRpcProtocolSequence(),
        DceBinding->InqNetworkAddress(), DceBinding->InqEndpoint());
#endif

    RPC_CONNECTION_TRANSPORT *ClientInfo =
            (RPC_CONNECTION_TRANSPORT *) TransInfo->InqTransInfo();

    CAssociation = new (ClientInfo->ResolverHintSize)
                          OSF_CASSOCIATION(DceBinding,
                                        TransInfo,
                                        &Status);

    if ( (Status != RPC_S_OK) && (CAssociation != NULL) )
        {
        CAssociation->DceBinding = 0;
        delete CAssociation;
        CAssociation = 0;
        }

    if (CAssociation != 0)
        {
        CAssociation->Key = AssociationDict->Insert(CAssociation);
        if (CAssociation->Key == -1)
            {
            CAssociation->DceBinding = 0;
            delete CAssociation;
            CAssociation = 0;
            }
        }

    AssocDictMutex->Clear();

    return(CAssociation);
}

RPC_STATUS
OSF_BINDING_HANDLE::SetTransportOption( IN unsigned long option,
                                    IN ULONG_PTR     optionValue )
{
    if (option == RPC_C_OPT_DONT_LINGER)
        {
        if (Association == NULL)
            return RPC_S_WRONG_KIND_OF_BINDING;

        if (Association->GetDontLingerState())
            return RPC_S_OK;

        Association->SetDontLingerState((BOOL)optionValue);

        return RPC_S_OK;
        }
    else
        {
        return BINDING_HANDLE::SetTransportOption(option, optionValue);
        }
}

RPC_STATUS
OSF_BINDING_HANDLE::InqTransportOption( IN  unsigned long option,
                                    OUT ULONG_PTR   * pOptionValue )
{
    if (option == RPC_C_OPT_DONT_LINGER)
        {
        if (Association == NULL)
            return RPC_S_WRONG_KIND_OF_BINDING;

        *pOptionValue = Association->GetDontLingerState();

        return RPC_S_OK;
        }
    else
        {
        return BINDING_HANDLE::InqTransportOption(option, pOptionValue);
        }
}

#pragma optimize ("t", on)

RPC_STATUS
OSF_CASSOCIATION::LookForExistingConnection (
    IN OSF_BINDING_HANDLE *BindingHandle,
    IN BOOL fExclusive,
    IN CLIENT_AUTH_INFO *ClientAuthInfo,
    IN int *PresentationContexts,
    IN int NumberOfPresentationContexts,
    OUT OSF_CCONNECTION **NewConnection,
    OUT int *PresentationContextSupported,
    OUT OSF_CCALL_STATE *InitialCallState,
    IN BOOL fUseSeparateConnection
    )
/*++
Function Name:LookForExistingConnection

Parameters:
    BindingHandle - the binding handle through which the call is made
    fExclusive - non-zero if we are looking for an exclusive connection
        zero otherwise
    ClientAuthInfo - a connection must support this specified auth info
    PresentationContexts - array of presentation contexts, any of which
        is acceptable to our callers
    NumberOfPresentationContexts - the size of the PresentationContexts
        array
    PreferredPresentationContext - the preferred presentation context for
        this connection. -1 if no preferences. Note that this is taken
        from a previous binding to the server - this is not the client
        preference.
    NewConnection - on output, the new connection or NULL. Undefined on 
        failure
    PresentationContextSupported - the presentation context that the
        chosen connection supports. This is useful only if multiple
        presentation contexts were given. Also, if the connection
        supports multiple pcontexts and multiple pcontexts were given
        this would be any of the pcontexts. This is an index into the
        NumberOfPresentationContexts array. If the connection supports
        none of the suggested presentation contexts, this is set to -1.
        In this case, alter context is required
    InitialCallState - the initial state that the call should have is
        returned in this parameter
    fUseSeparateconnection - if non-zero, a separate connection is requested

Description:

Returns:

    RPC_S_OK or RPC_S_* error

--*/
{
    OSF_CCONNECTION *CConnection, *FirstMatch = 0;
    DictionaryCursor cursor;
    RPC_STATUS Status;
    BOOL Supported;

    ASSERT(ClientAuthInfo);

    AssociationMutex.VerifyOwned();

    *PresentationContextSupported = -1;

    ActiveConnections.Reset(cursor);

    if (fExclusive || fUseSeparateConnection)
        {
        INT cConnectionFree, cConnectionBusy;

        if (fExclusive)
            {
            cConnectionFree = SYNC_CONN_FREE;
            cConnectionBusy = SYNC_CONN_BUSY;
            }
        else
            {
            cConnectionFree = ASYNC_CONN_FREE;
            cConnectionBusy = ASYNC_CONN_BUSY;
            }

        while ((CConnection = ActiveConnections.Next(cursor)) != 0)
            {
            if (cConnectionFree == (INT) CConnection->ThreadId)
                {
                Status = CConnection->SupportedAuthInfo(ClientAuthInfo,
                                                BindingHandle->NPType, fExclusive, &Supported);
                if (Status != RPC_S_OK)
                    return Status;

                if (Supported)
                    {
                    if (CConnection->SupportedPContext(PresentationContexts,
                        NumberOfPresentationContexts, PresentationContextSupported) !=0)
                        {
                        CConnection->ThreadId = cConnectionBusy;
                        *InitialCallState = SendingFirstBuffer;
                        break;
                        }
                    else
                        {
                        //
                        // We found a connection that will require an alt-context
                        // before we can use it.
                        //
                        FirstMatch = CConnection;
                        } // if-else
                    } // if Supported
                }   // if ThreadId
            } // while

            if (0 == CConnection && FirstMatch)
                {
                CConnection = FirstMatch ;
                CConnection->ThreadId = cConnectionBusy;
                *InitialCallState = NeedAlterContext;
                }
        }
    else
        {
        DWORD ThreadId = GetCurrentThreadId();

        while ((CConnection = ActiveConnections.Next(cursor)) != 0)
            {
            Status = CConnection->SupportedAuthInfo(ClientAuthInfo,
                                               BindingHandle->NPType,
                                               fExclusive,
                                               &Supported);

            if (Status != RPC_S_OK)
                return Status;

            if (Supported)
                {
                if (CConnection->SupportedPContext(PresentationContexts,
                    NumberOfPresentationContexts, PresentationContextSupported) !=0)
                    {
                    if (ThreadId == CConnection->ThreadId)
                        {
                        //
                        // We found a connection where everything matches,
                        // including the thread id. Go ahead and use it.
                        //
                        *InitialCallState = SendingFirstBuffer;
                        break;
                        }
                    }
                else
                    {
                    if (ThreadId == CConnection->ThreadId)
                        {
                        //
                        // We found a connection where the thread id matches, but
                        // it will need an alt-context, before it can be used. Mark it as
                        // our first choice.
                        //
                        FirstMatch = CConnection;
                        }
                    } // if-else
                } // if
            } // while

        if (0 == CConnection && FirstMatch)
            {
            //
            // Matching thread-id, but will need an alt-context, before
            // it can be used. The alt-context will be sent when the call
            // actually gets scheduled.
            //
            CConnection = FirstMatch;
            *InitialCallState = NeedAlterContext;
            }
        } // if-else

    if (CConnection)
        {
        if (fExclusive)
            {
            CConnection->fExclusive = 1;
            }
        else
            {
            CConnection->fExclusive = 0;
            }

        // CCONN++
        CConnection->AddReference();
        // mark this connection as just retrieved from the cache
        // see the comments to the FreshFromCache flag
        CConnection->SetFreshFromCacheFlag();
        }

    *NewConnection = CConnection;
    return RPC_S_OK;
}
#pragma optimize("", on)

/*
    Mechanism: Multiple transfer syntax negotiation

    Purpose: Negotiate a transfer syntax supported by both the client and
    the server and optimal for the server (if there is a choice). It should
    allow for fail-over of the server to a downlevel node in the case
    of mixed clusters, but it is allowed to fail the first one or more calls 
    after the failover while it adjusts (this restricted implementation was
    approved by MarioGo on RPC team meeting on Apr 10th, 2000).

    Implementation: Here's the matrix for the scenarios. The only current
    difference b/n sync and async is the initial conn establishment. The
    matrix describes only the case where we support both (the others are
    trivial)

    Sync Calls:
    Conn Av.        Preference      Action
    -------------   ------------    -------------
    No conn.        Doesn't matter  Offer both. Don't fix choice for call
    Conn NDR20      Not set         Alter context to both. This cannot 
                                    fail with invalid xfer syntax.
    Conn NDR20      NDR20           Use the conn.
    Conn NDR20      NDR64           The connection is stale. Use the
                                    connection anyway. We know it will
                                    blow and we'll open a new one.
    Conn NDR64      Not set         Alter context to both. This cannot
                                    fail with invalid xfer syntax.
    Conn NDR64      NDR20           The connection is stale. Use the
                                    connection anyway. We know it will
                                    blow and we'll open a new one.
    Conn NDR64      NDR64           Use the conn

    Conn both       Any             Use preference.

    Non-sync Calls:
    Conn Av.        Preference      Action
    -------------   ------------    -------------
    No conn.        Not set         Offer both. If NDR64 is negotiated,
                                    negotiate once more (alter context)
                                    for NDR20, so that we can send the first
                                    call, which was marshalled NDR20.
    Conn NDR20      Not set         Alter context to both. Choose NDR20.
    Conn NDR20      NDR20           Use the conn.
    Conn NDR20      NDR64           The connection is stale. Use the
                                    connection anyway. We know it will
                                    blow and we'll open a new one.
    Conn NDR64      Not set         Alter context to both. Choose NDR20.
                                    If NDR64 is chosen, alter context
                                    to NDR20. If NDR20 is chosen, use it.
    Conn NDR64      NDR20           The connection is stale. Use the
                                    connection anyway. We know it will
                                    blow and we'll open a new one.
    Conn NDR64      NDR64           Use the conn

    Conn both       All             Use preference.

 */

const int AUTO_ENABLE_IDLE_CLEANUP = 70;


RPC_STATUS
OSF_CASSOCIATION::AllocateCCall (
    IN OSF_BINDING_HANDLE *BindingHandle,
    IN PRPC_MESSAGE Message,
    IN CLIENT_AUTH_INFO * ClientAuthInfo,
    OUT OSF_CCALL ** pCCall,
    OUT BOOL *fBindingHandleReferenceRemoved
    )
/*++
Function Name:AllocateCCall

Parameters:
    CCall - Returns the allocated call.

    ClientAuthInfo - Supplies the authentication and authorization
        information required for the connection.

Description:

    In this method, we allocate a connection supporting the requested
    interface information.  This means that first we need to find the
    presentation context corresponding to the requested interface
    interface.  Then we search for an existing connection supporting
    the presentation context, and then we try and create a new
    connection. We then ask the Connection object to create a Call
    for us.

Returns:
    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to create
        objects necessary to allocate a connection.

--*/
{
    ULONG CallIdToUse;
    RPC_STATUS Status;
    OSF_BINDING *BindingsForThisInterface[MaximumNumberOfTransferSyntaxes];
    int NumberOfBindingsAvailable;
    int NumberOfBindingsToUse;
    int PresentationContextsAvailable[MaximumNumberOfTransferSyntaxes];
    int *PresentationContextsToUse;
    int PresentationContextSupported;
    int NDR20PresentationContext;
    int i;
    OSF_CCALL_STATE InitialCallState;
    OSF_CCONNECTION *CConnection = 0;
    BOOL fExclusive = !NONSYNC(Message);
    ULONG_PTR fUseSeparateConnection = (PARTIAL(Message) != 0);
    RPC_CLIENT_INTERFACE  *RpcInterfaceInformation =
        (RPC_CLIENT_INTERFACE  *) Message->RpcInterfaceInformation;
    OSF_BINDING *BindingsList;
    OSF_BINDING *BindingToUse;
    RPC_DISPATCH_TABLE *DispatchTableToUse;

    *fBindingHandleReferenceRemoved = FALSE;

    //
    // To begin with, we need to obtain the presentation context
    // corresponding to the specified interface information.
    //
    Status = AssociationMutex.RequestSafe();
    if (Status)
        return Status;

    Status = FindOrCreateOsfBinding(RpcInterfaceInformation, Message, &NumberOfBindingsAvailable,
        BindingsForThisInterface);
    if ( Status != RPC_S_OK )
        {
        AssociationMutex.Clear();
        return(Status);
        }

    CallIdToUse = CallIdCounter++;

    if (fExclusive == 0 && fUseSeparateConnection == 0)
        {
        Status = BindingHandle->InqTransportOption(
                                               RPC_C_OPT_BINDING_NONCAUSAL,
                                               &fUseSeparateConnection);
        ASSERT(Status == RPC_S_OK);
        }

    //
    // Ok, now we search for an available connection supporting the
    // requested presentation context.
    //

    // construct the array of presentation contexts any of which will
    // do the job
#ifdef DEBUGRPC
    BindingsList = 0;
    NDR20PresentationContext = -1;
#endif

    NumberOfBindingsToUse = NumberOfBindingsAvailable;
    PresentationContextsToUse = PresentationContextsAvailable;
    for (i = 0; i < NumberOfBindingsAvailable; i ++)
        {
        PresentationContextsAvailable[i] = BindingsForThisInterface[i]->GetPresentationContext();
        if (BindingsForThisInterface[i]->IsTransferSyntaxListStart())
            {
            // make sure only one binding is the list start
            ASSERT(BindingsList == 0);
            BindingsList = BindingsForThisInterface[i];
            }

        if (BindingsForThisInterface[i]->IsTransferSyntaxServerPreferred())
            {
            // one of the transfer syntaxes is marked as preferred -
            // try to use it.
            // Note that this doesn't break the mixed cluster scenario,
            // because when binding on new connection, we always offer both, regardless of
            // preferences. We hit this path only when we choose from
            // existing. If we moved the association to a different node
            // of the cluster, all the old connections will be blown
            // away, and it doesn't matter what presentation context we
            // choose for them. A successful bind to the new node will
            // reset the preferences, so we're fine
            NumberOfBindingsToUse = 1;
            PresentationContextsToUse = &PresentationContextsAvailable[i];
            }

        if (IsNonsyncMessage(Message))
            {
            // the call is non sync and there may be no preference. For non sync, 
            // we start with NDR20, because the client may be downlevel. When
            // the first bind completes, it will set the preference
            if (BindingsForThisInterface[i]->CompareWithTransferSyntax(NDR20TransferSyntax) == 0)
                {
                NDR20PresentationContext = i;
                }
            }

        // we have obtained our bindings. Add a refcount to them while we hold the association mutex
        BindingsForThisInterface[i]->AddReference();
        }

    // at least one binding must be the start of the list
    ASSERT(BindingsList != 0);

    Status = LookForExistingConnection (
                                            BindingHandle,
                                            fExclusive,
                                            ClientAuthInfo,
                                            PresentationContextsToUse,
                                            NumberOfBindingsToUse,
                                            &CConnection,
                                            &PresentationContextSupported,
                                            &InitialCallState,
                                            BOOL(fUseSeparateConnection)) ;


    AssociationMutex.Clear();

    if (Status != RPC_S_OK)
        {
        ReleaseBindingList(BindingsList);
        return Status;
        }

    if (CConnection == 0)
        {
        //
        // Allocate a new connection
        //
        RPC_CONNECTION_TRANSPORT *ClientInfo
            = (RPC_CONNECTION_TRANSPORT *) TransInfo->InqTransInfo();

        Status = RPC_S_OK;

        CConnection = new(ClientInfo->ClientConnectionSize
                          + ClientInfo->SendContextSize
                          + sizeof(PVOID))
                          OSF_CCONNECTION(
                              this,
                              ClientInfo,
                              BindingHandle->InqComTimeout(),
                              ClientAuthInfo,
                              fExclusive,
                              BOOL(fUseSeparateConnection),
                              &Status);

        if (CConnection == 0)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }

        if (Status != RPC_S_OK)
            {
            delete CConnection;
            ReleaseBindingList(BindingsList);
            return Status;
            }

        Status = AssociationMutex.RequestSafe();
        if (Status)
            {
            delete CConnection;
            ReleaseBindingList(BindingsList);
            return Status;
            }

        if (!fExclusive)
            {
            Status = TransInfo->StartServerIfNecessary();
            if (Status != RPC_S_OK)
                {
                AssociationMutex.Clear();

                delete CConnection;
                ReleaseBindingList(BindingsList);
                return Status;
                }
            }

        CConnection->ConnectionKey = ActiveConnections.Insert(CConnection);
        if (CConnection->ConnectionKey == -1)
            {
            AssociationMutex.Clear();

            delete CConnection;
            ReleaseBindingList(BindingsList);
            return RPC_S_OUT_OF_MEMORY;
            }

        if (IsValid() == FALSE)
            {
            ActiveConnections.Delete(CConnection->ConnectionKey);
            CConnection->ConnectionKey = -1;
            AssociationMutex.Clear();

            delete CConnection;

            ReleaseBindingList(BindingsList);

            return AssociationShutdownError;
            }

        if (ActiveConnections.Size() > AUTO_ENABLE_IDLE_CLEANUP)
            {
            // EnableIdleConnectionCleanup doesn't fail
            (void) EnableIdleConnectionCleanup();
            }

        InitialCallState = NeedOpenAndBind;

        //
        // Since this is the first call on the connection
        // we might as well use the cached CCall
        // we are deliberately not taking the connection mutex
        // The cached call is already marked as not available in
        // the constructor of the connection
        //
        *pCCall = CConnection->CachedCCall;

        if (fEnableIdleConnectionCleanup && (fIdleConnectionCleanupNeeded == FALSE))
            {
            fIdleConnectionCleanupNeeded = TRUE;

            //
            // Finally, we need to notify the protocol independent layer that
            // the code to delete idle connections should be executed periodically.
            // We divide by two to reduce the amount of extra time an idle
            // connection lives beyond the minimum.
            //

            GarbageCollectionNeeded(FALSE, CLIENT_DISCONNECT_TIME1 / 2);
            }

        AssociationMutex.Clear();

        if (NumberOfBindingsAvailable == 1)
            {
            // we support only one binding - just use it
            BindingToUse = BindingsForThisInterface[0];
            DispatchTableToUse = BindingToUse->GetDispatchTable();
            ReleaseBindingListWithException(BindingToUse, BindingsList);
            BindingsList = 0;
            }
        else if (IsNonsyncMessage(Message))
            {
            // if there is still more than one available binding left
            // and the call is non-sync (this can happen while the server
            // preferences are not yet recorded), artifically limit the connection
            // lookup to NDR20 to avoid downward level server compatibility problems

            ASSERT (NDR20PresentationContext != -1);

            // we may overwrite the choices made up when we iterated over the
            // available bindings. That's ok - we always want to advertise both
            // for new connections
            NumberOfBindingsToUse = 1;
            PresentationContextsToUse = &PresentationContextsAvailable[NDR20PresentationContext];

            i = (int)(PresentationContextsToUse - PresentationContextsAvailable);
            BindingToUse = BindingsForThisInterface[i];
            DispatchTableToUse = BindingToUse->GetDispatchTable();
            }
        else
            {
            // even if server preference is set, we should still suggest both
            // to support the mixed cluster scenario
            BindingToUse = 0;
            DispatchTableToUse = 0;
            }

        // The refcounts on BindingToUse/BindingsList pass to the call.
        // If the call fails, we will release these refcounts below.
        Status = (*pCCall)->ActivateCall(
                                        BindingHandle,
                                        BindingToUse,
                                        BindingsList,
                                        CallIdToUse,
                                        InitialCallState,
                                        DispatchTableToUse,
                                        CConnection);
        if (Status != RPC_S_OK)
            {
            if ((*pCCall)->Bindings.AvailableBindingsList)
                ReleaseBindingList((*pCCall)->Bindings.AvailableBindingsList);
            else
                (*pCCall)->GetSelectedBinding()->RemoveReference();

            ConnectionAborted(CConnection);

            delete CConnection;
            return Status ;
            }

        if (PARTIAL(Message))
            (*pCCall)->SetIsPipeCallFlag();

        if (!fExclusive)
            {
            BindingHandle->OSF_BINDING_HANDLE::AddReference();
            // add one more reference to the connection in case the sync
            // path fails with out of memory and starts cleaning up
            // This extra reference will make sure that the connection
            // and cached call do not go away underneath the async path
            // CCONN++
            CConnection->OSF_CCONNECTION::AddReference();
            (*pCCall)->OSF_CCALL::AddReference();
            Status = CConnection->TransPostEvent(*pCCall);

            if (Status != RPC_S_OK)
                {
                BindingHandle->OSF_BINDING_HANDLE::BindingFree();
                ConnectionAborted(CConnection);
                (*pCCall)->OSF_CCALL::RemoveReference();

                delete CConnection;
                return Status;
                }
            }
        }
    else
        {
        // there is a connection found. If the connection supports both
        // transfer syntaxes, then a server preferred syntax must have
        // been established. If there is no server preferred syntax,
        // the chosen connection supports at most one syntax currently

        // If there is only one binding to use (either because we support
        // only one, or because there is server preference set), we use it
        // if the connection supports it. Otherwise, we need to alter
        // context the connection.
        // If there are more bindings, this means there are no server
        // preferences, and it gets more complicated. First, we need to
        // alter context both to find out the server preference. The server
        // may choose the same syntax that we already support, or it may 
        // choose a different syntax. In the async case, we choose whatever
        // is currently supported, but we try to alter context both to give
        // the server a chance to indicate its preferences.

        if (NumberOfBindingsToUse == 1)
            {
            // only one binding. Do we support it?
            if (PresentationContextSupported >= 0)  // faster version of != -1
                {
                // yes - easy choice. Just use it.

                // calculate the offset of the chosen presentation context in the original
                // presentation contexts array (PresentationContextsAvailable).
                i = (int)((PresentationContextsToUse - PresentationContextsAvailable) + PresentationContextSupported);

                }
            else
                {
                // if we are here, the connection does not support the transfer
                // syntax we need. We have only one that we support, so we
                // stick with it and fail the call if we cannot
                // negotiate to it (just a shortcut version of the first case).
                // Note that the LookForExistingConnection has set the state of
                // the call to NeedAlterContext if this is the case, so the
                // bind function will do the right thing - we don't need to worry
                // about it.
                i = (int)(PresentationContextsToUse - PresentationContextsAvailable);
                }

            // this is the same offset as the offset in the BindingsForThisInterface array, since the
            // two arrays are parallel
            BindingToUse = BindingsForThisInterface[i];
            DispatchTableToUse = BindingToUse->GetDispatchTable();
            ReleaseBindingListWithException(BindingToUse, BindingsList);
            BindingsList = 0;
            }
        else
            {
            // here NumberOfBindingsToUse is more than one. This means we support
            // more than one xfer syntax, and the server preferences are not
            // set.

            InitialCallState = NeedAlterContext;

            // We offered both. At least one must be supported - otherwise
            // the connection should have been gone.
            if (PresentationContextSupported >= 0)
                {
                // this should never happen yet. It can only happen
                // in the multiple client stubs with differen xfer syntax
                // support scenario, but we don't support it yet.
                ASSERT(0);
                if (IsNonsyncMessage(Message))
                    {
                    i = (int)((PresentationContextsToUse - PresentationContextsAvailable) + PresentationContextSupported);
                    BindingToUse = BindingsForThisInterface[i];
                    DispatchTableToUse = BindingToUse->GetDispatchTable();
                    // Don't whack out the list - this allows the client to offer both
                    // BindingsList = 0;
                    }
                else
                    {
                    BindingToUse = 0;
                    DispatchTableToUse = 0;
                    }
                }
            else
                {
                if (IsNonsyncMessage(Message))
                    {
                    // if there is still more than one available binding left
                    // and the call is non-sync (this can happen while the server
                    // preferences are not yet recorded), artifically limit the connection
                    // lookup to NDR20 to avoid downward level server compatibility problems

                    ASSERT (NDR20PresentationContext != -1);

                    // we may overwrite the choices made up when we iterated over the
                    // available bindings. That's ok - we always want to advertise both
                    // in this case
                    NumberOfBindingsToUse = 1;
                    PresentationContextsToUse = &PresentationContextsAvailable[NDR20PresentationContext];

                    i = (int)(PresentationContextsToUse - PresentationContextsAvailable);
                    BindingToUse = BindingsForThisInterface[i];
                    DispatchTableToUse = BindingToUse->GetDispatchTable();
                    // Don't whack out the list - this allows the client to offer both
                    // BindingsList = 0;
                    }
                else
                    {
                    // even if server preference is set, we should still suggest both
                    // to support the mixed cluster scenario
                    BindingToUse = 0;
                    DispatchTableToUse = 0;
                    }

                }
            }

        //
        // This is not the first call on the connection. We will ask it to allocate
        // a call for us
        //
        Status = CConnection->AllocateCCall(pCCall);
        if (Status == RPC_S_OK)
            {
            // The refcounts on BindingToUse/BindingsList pass to the call.
            // If the call fails, we will release these refcounts in FreeCCall.
            Status = (*pCCall)->ActivateCall(
                                             BindingHandle,
                                             BindingToUse,
                                             BindingsList,
                                             CallIdToUse,
                                             InitialCallState,
                                             DispatchTableToUse,
                                             CConnection);
            if (Status != RPC_S_OK)
                {
                //
                // Call has not yet started, ok to directly
                // free the call.
                //
                (*pCCall)->FreeCCall(RPC_S_CALL_FAILED_DNE);
                *fBindingHandleReferenceRemoved = TRUE;
                return Status;
                }

            if (PARTIAL(Message))
                (*pCCall)->SetIsPipeCallFlag();

            Status = (*pCCall)->ReserveSpaceForSecurityIfNecessary();
            if (Status != RPC_S_OK)
                {
                //
                // Call has not yet started, ok to directly
                // free the call.
                //
                (*pCCall)->FreeCCall(RPC_S_CALL_FAILED_DNE);
                *fBindingHandleReferenceRemoved = TRUE;
                return Status;
                }
            }
        else
            {
            ReleaseBindingList(BindingsList);
            }
        }


    return Status;
}

BOOL
OSF_CASSOCIATION::ConnectionAborted (
    IN OSF_CCONNECTION *Connection
    )
/*++
Function Name:ConnectionAborted

Parameters:

Description:

Returns:

--*/
{
    BOOL fDontKill = FALSE;

    AssociationMutex.Request();
    if (Connection->ConnectionKey != -1)
        {
        LogEvent(SU_CCONN, EV_STOP, Connection, this, Connection->ConnectionKey, 1, 0);
        ActiveConnections.Delete(Connection->ConnectionKey);
        Connection->ConnectionKey = -1;
        }

    if (Connection->fConnectionAborted == 0)
        {
        NotifyConnectionClosed();
        Connection->fConnectionAborted = 1;
        }
    else
        {
        fDontKill = TRUE;
        }
    AssociationMutex.Clear();

    return fDontKill;
}

RPC_STATUS
OSF_CASSOCIATION::FindOrCreateToken (
    IN HANDLE hToken,
    IN LUID *pModifiedId,
    OUT RPC_TOKEN **ppToken,
    OUT BOOL *pfTokenFound
    )
/*++
Function Name:FindOrCreateToken

Parameters:

Description:

Returns:

--*/
{
    DictionaryCursor cursor;
    RPC_TOKEN *Token;
    RPC_STATUS Status;

    Status = AssociationMutex.RequestSafe();
    if (Status)
        return Status;
    TokenDict.Reset(cursor);
    while ((Token = TokenDict.Next(cursor)) != 0)
        {
        if (FastCompareLUIDAligned(&Token->ModifiedId, pModifiedId))
            {
            *pfTokenFound = TRUE;
            Token->RefCount++; // Token++;
            LogEvent(SU_REFOBJ, EV_INC, Token, 0, Token->RefCount, 1, 1);

            *ppToken = Token;
            Status = RPC_S_OK;
            goto Cleanup;
            }
        }

    *pfTokenFound = FALSE;

    *ppToken = new RPC_TOKEN(hToken, pModifiedId); // constructor cannot fail
    if (*ppToken == 0)
        {
        CloseHandle(hToken);
        Status = RPC_S_OUT_OF_MEMORY;
        goto Cleanup;
        }

    if (((*ppToken)->Key = TokenDict.Insert(*ppToken)) == -1)
        {
        Status = RPC_S_OUT_OF_MEMORY;
        delete *ppToken;
        goto Cleanup;
        }

    Status = RPC_S_OK;

Cleanup:
    AssociationMutex.Clear();
    return Status;
}

void
OSF_CASSOCIATION::ReferenceToken(
    IN RPC_TOKEN *pToken
    )
/*++
Function Name:ReferenceToken

Parameters:

Description:

Returns:

--*/
{
    AssociationMutex.Request();

    ASSERT(pToken->RefCount);

    pToken->RefCount++; // Token++
    LogEvent(SU_REFOBJ, EV_INC, pToken, 0, pToken->RefCount, 1, 1);

    AssociationMutex.Clear();
}

void
OSF_CASSOCIATION::DereferenceToken(
    IN RPC_TOKEN *pToken
    )
/*++
Function Name:DereferenceToken

Parameters:

Description:

Returns:

--*/
{
    AssociationMutex.Request();
    LogEvent(SU_REFOBJ, EV_DEC, pToken, 0, pToken->RefCount, 1, 1);

    pToken->RefCount--; // Token--
    if (pToken->RefCount == 0)
        {
        TokenDict.Delete(pToken->Key);
        CleanupConnectionList(pToken);
        delete pToken;
        }

    AssociationMutex.Clear();
}

void
OSF_CASSOCIATION::CleanupConnectionList(
    IN RPC_TOKEN *pToken
    )
/*++
Function Name:CleanupConnectionList

Parameters:

Description:

Returns:

--*/
{
    DictionaryCursor cursor;
    OSF_CCONNECTION *CConnection;

    AssociationMutex.VerifyOwned();

    if ( MaintainContext != 0 && ActiveConnections.Size() <= 1) return;

    ActiveConnections.Reset(cursor);
    while ( (CConnection = ActiveConnections.Next(cursor)) != 0 )
        {
        if (CConnection->ThreadId == SYNC_CONN_FREE
            || CConnection->ThreadId == ASYNC_CONN_FREE)
            {
            if (CConnection->MatchModifiedId(&(pToken->ModifiedId)) == TRUE)
                {
                CConnection->AddReference(); //CCONN++

                ConnectionAborted(CConnection);
                CConnection->DeleteConnection();

                //
                // I don't if the add/remove reference is really needed
                // I am only doing it to preserve existing semantics
                //
                CConnection->RemoveReference(); // CCONN--
                }
            }
        }

}


void
ConstructPContextList (
    OUT p_cont_list_t *pCon, // Place the list here.
    IN OSF_BINDING *AvailableBindings,
    IN int NumberOfBindings
    )
/*++
Function Name:ConstructPContextList

Parameters:

Description:
    Construct the presentation context list in the
    rpc_bind packet (and implicitly rpc_alter_context)
    packet.

Returns:

--*/
{
    int i;
    OSF_BINDING *CurrentBinding;

    pCon->n_context_elem = (unsigned char)NumberOfBindings;
    pCon->reserved = 0;
    pCon->reserved2 = 0;

    CurrentBinding = AvailableBindings;
    for (i = 0; i < NumberOfBindings; i ++, CurrentBinding = CurrentBinding->GetNextBinding())
        {
        pCon->p_cont_elem[i].p_cont_id = CurrentBinding->GetOnTheWirePresentationContext();
        pCon->p_cont_elem[i].n_transfer_syn = (unsigned char) 1;
        pCon->p_cont_elem[i].reserved = 0;

        RpcpMemoryCopy(&pCon->p_cont_elem[i].abstract_syntax,
                       CurrentBinding->GetInterfaceId(),
                       sizeof(RPC_SYNTAX_IDENTIFIER));

        RpcpMemoryCopy(pCon->p_cont_elem[i].transfer_syntaxes,
                       CurrentBinding->GetTransferSyntaxId(),
                       sizeof(RPC_SYNTAX_IDENTIFIER));
        }
}



OSF_CCONNECTION::OSF_CCONNECTION (
    IN OSF_CASSOCIATION *MyAssociation,
    IN RPC_CONNECTION_TRANSPORT * RpcClientInfo,
    IN UINT Timeout,
    IN CLIENT_AUTH_INFO * ClientAuthInfo,
    IN BOOL fExclusive,
    IN BOOL fSeparateConnection,
    OUT RPC_STATUS  * pStatus
    ) : ConnMutex(pStatus),
    ClientSecurityContext(ClientAuthInfo, 0, FALSE, pStatus)
/*++
Function Name:OSF_CCONNECTION

Parameters:

Description:
    Constructor for the connection object

Returns:

--*/
{
    LogEvent(SU_CCONN, EV_CREATE, this);

    Flags.ClearAll();

    InitConnectionSupportHeaderSign();

    Association = MyAssociation;
    // CASSOC++
    Association->AddReference();

    ObjectType = OSF_CCONNECTION_TYPE;
    ClientInfo = RpcClientInfo;
    State = ConnUninitialized;
    ComTimeout = Timeout ;
    u.ConnSendContext = (char *) TransConnection()
                      + ClientInfo->ClientConnectionSize
                      + sizeof(PVOID);
    *((PVOID *) ((char *) u.ConnSendContext - sizeof(PVOID))) = (PVOID) this;

    MaxFrag = 512;
    ConnectionKey = -1;
    AdditionalLegNeeded = 0;
    LastTimeUsed = 0;
    SavedHeader = 0;
    SavedHeaderSize = 0;
    MaxSavedHeaderSize = 0;
    BufferToFree = 0;

    fIdle = 0;
    this->fExclusive = fExclusive;
    this->fSeparateConnection = fSeparateConnection;
    InitializeWireAuthId(ClientAuthInfo);

    if (fExclusive)
        {
        AdditionalSpaceForSecurity = 0;
        ThreadId = SYNC_CONN_BUSY;
        }
    else
        {
        //
        // If it turns out that needed size is actually bigger
        // we will really the buffers
        //
        AdditionalSpaceForSecurity = 0x140;

        if (fSeparateConnection)
            {
            ThreadId = ASYNC_CONN_BUSY;
            }
        else
            {
            ThreadId = GetCurrentThreadId();
            }
        }

    fConnectionAborted = 1;


    //
    // We need two references on the connection. One for itself, and
    // one for the cached ccall, which is implicitly getting allocated.
    //
    SetReferenceCount(2);

    DceSecurityInfo.SendSequenceNumber = 0;
    DceSecurityInfo.ReceiveSequenceNumber = 0;

    if (*pStatus == RPC_S_OK)
        {
        *pStatus = TransInitialize(
                        Association->DceBinding->InqNetworkAddress(),
                        Association->DceBinding->InqNetworkOptions());
        SetTransInitializedFlag();
        }
    if (*pStatus == RPC_S_OK)
        {
        // Create a CCALL object.
        // If the app verifier is enabled, we will create an object which 
        // supports the verifier checks.
        if (gfRPCVerifierEnabled)
            {
            CachedCCall = new (ClientInfo->SendContextSize+sizeof(PVOID)) OSF_CCALL_AVRF(pStatus);
            }
        else
            {
            CachedCCall = new (ClientInfo->SendContextSize+sizeof(PVOID)) OSF_CCALL(pStatus);
            }

        if (CachedCCall == 0)
            {
            *pStatus = RPC_S_OUT_OF_MEMORY;
            }
        }
    else
        {
        CachedCCall = NULL;
        }

    CachedCCallAvailable = 0;
    CurrentCall = CachedCCall;
    ConnectionReady = 0;

}


OSF_CCONNECTION::~OSF_CCONNECTION (
    )
{
    LogEvent(SU_CCONN, EV_DELETE, this);

    RPC_STATUS Status;

    if (CachedCCall)
        {
        delete CachedCCall;
        }

    if (GetTransInitializedFlag())
        TransInitComplete();

    TransClose();

    Association->ConnectionAborted(this);

    if (SavedHeader != 0)
       {
       ASSERT(SavedHeaderSize != 0);
       RpcpFarFree(SavedHeader);
       }

   // CASSOC--
   Association->RemoveReference();
}


RPC_STATUS
OSF_CCONNECTION::ValidateHeader(
     rpcconn_common * Buffer,
     unsigned long BufferLength
     )
{
    if (ClientSecurityContext.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE)
        {
        unsigned CopyLength;

        if (Buffer->PTYPE == rpc_bind_ack ||
            Buffer->PTYPE == rpc_alter_context_resp)
            {
            CopyLength = BufferLength;
            }
        else
            {
            CopyLength = sizeof(rpcconn_response);
            }

        if (MaxSavedHeaderSize < CopyLength)
            {
            if (SavedHeader != 0)
                {
                ASSERT(MaxSavedHeaderSize != 0);
                RpcpFarFree(SavedHeader);
                }

            SavedHeader = RpcpFarAllocate(CopyLength);
            if (SavedHeader == 0)
                {
                MaxSavedHeaderSize = 0;
                return(RPC_S_OUT_OF_MEMORY);
                }
            MaxSavedHeaderSize = CopyLength;
            RpcpMemoryCopy(SavedHeader, Buffer, CopyLength);
            }
        else
            {
            RpcpMemoryCopy(SavedHeader, Buffer, CopyLength);
            }

        SavedHeaderSize = CopyLength;
        }

    RPC_STATUS Status = ValidatePacket(Buffer, BufferLength);
    if ( Status != RPC_S_OK )
        {
        ASSERT( Status == RPC_S_PROTOCOL_ERROR );
        return Status;
        }

    return RPC_S_OK;
}


RPC_STATUS
OSF_CCONNECTION::TransReceive (
    OUT PVOID  * Buffer,
    OUT UINT  * BufferLength,
    IN ULONG Timeout
    )
/*++

Routine Description:

Arguments:

    Buffer - Returns a packet received from the transport.

    BufferLength - Returns the length of the buffer.

Return Value:

    RPC_S_OK - We successfully received a packet from the server.
    RPC_S_* - an error has occurred. See the validate clause at the
        end

--*/
{
    RPC_STATUS Status;

    if ( State != ConnOpen )
        {
        return(RPC_P_CONNECTION_CLOSED);
        }

    ASSERT(CurrentCall);

    Status = ClientInfo->SyncRecv(
                                 TransConnection(),
                                 (BUFFER *) Buffer,
                                 BufferLength, 
                                 Timeout);

    if ( (Status == RPC_P_RECEIVE_FAILED)
        || (Status == RPC_P_CONNECTION_SHUTDOWN)
        || (Status == RPC_P_TIMEOUT))
        {
        State = ConnAborted;
        }

    VALIDATE(Status)
        {
        RPC_S_OK,
        RPC_S_OUT_OF_MEMORY,
        RPC_S_OUT_OF_RESOURCES,
        RPC_S_CALL_CANCELLED,
        RPC_P_RECEIVE_ALERTED,
        RPC_P_TIMEOUT,
        RPC_P_RECEIVE_FAILED,
        RPC_P_CONNECTION_SHUTDOWN
        }
    CORRUPTION_VALIDATE
        {
        RPC_S_PROTOCOL_ERROR
        } CORRUPTION_END_VALIDATE;

    return(Status);
}


RPC_STATUS
OSF_CCONNECTION::TransOpen (
    IN OSF_BINDING_HANDLE *BindingHandle,
    IN RPC_CHAR *RpcProtocolSequence,
    IN RPC_CHAR *NetworkAddress,
    IN RPC_CHAR *Endpoint,
    IN RPC_CHAR *NetworkOptions,
    IN void *ResolverHint,
    IN BOOL fHintInitialized,
    IN ULONG CallTimeout
    )
/*++
Function Name:TransOpen

Parameters:
    CallTimeout - call timeout in milliseconds

Description:

Returns:

--*/
{
    RPC_STATUS Status ;
    BOOL fTokenSwapped ;
    HANDLE OldToken = 0;
    CLIENT_AUTH_INFO *ClientAuthInfo;

    fTokenSwapped = BindingHandle->SwapToken(&OldToken);
    ClientAuthInfo = BindingHandle->InquireAuthInformation();

    if (ClientAuthInfo->AdditionalTransportCredentialsType == RPC_C_AUTHN_INFO_TYPE_HTTP)
        {
        ASSERT(ClientSecurityContext.AdditionalTransportCredentialsType == RPC_C_AUTHN_INFO_TYPE_HTTP);
        ASSERT(CompareHttpTransportCredentials(
            (const IN RPC_HTTP_TRANSPORT_CREDENTIALS_W *)ClientAuthInfo->AdditionalCredentials,
            (const IN RPC_HTTP_TRANSPORT_CREDENTIALS_W *)ClientSecurityContext.AdditionalCredentials) == 0);
        }

    Status = ClientInfo->Open(TransConnection(),
                              RpcProtocolSequence,
                              NetworkAddress,
                              Endpoint,
                              NetworkOptions,
                              ComTimeout,
                              0,
                              0,
                              ResolverHint,
                              fHintInitialized,
                              CallTimeout,
                              ClientSecurityContext.AdditionalTransportCredentialsType,
                              ClientSecurityContext.AdditionalCredentials
                              );

    RestoreTokenIfNecessary (fTokenSwapped, OldToken);

    //
    // If an error occurs in opening the connection, we go ahead and
    // delete the memory for the connection, and return zero (setting
    // this to zero does that).
    //
    VALIDATE (Status)
        {
        RPC_S_OK,
        RPC_S_PROTSEQ_NOT_SUPPORTED,
        RPC_S_SERVER_UNAVAILABLE,
        RPC_S_OUT_OF_MEMORY,
        RPC_S_OUT_OF_RESOURCES,
        RPC_S_SERVER_TOO_BUSY,
        RPC_S_INVALID_NETWORK_OPTIONS,
        RPC_S_INVALID_ENDPOINT_FORMAT,
        RPC_S_INVALID_NET_ADDR,
        RPC_S_ACCESS_DENIED,
        RPC_S_INTERNAL_ERROR,
        RPC_S_SERVER_OUT_OF_MEMORY,
        RPC_S_CALL_CANCELLED
        } END_VALIDATE;

    if ( Status == RPC_S_OK )
        {
        State = ConnOpen;
        }

    return Status ;
}


void
OSF_CCONNECTION::TransClose (
    )
{
    RPC_STATUS Status;

    if (State != ConnUninitialized)
        {
        __try
            {
            Status = ClientInfo->Close(TransConnection(), 0);

            ASSERT( Status == RPC_S_OK );
            }
        __except( EXCEPTION_EXECUTE_HANDLER )
            {
#if DBG
            PrintToDebugger("RPC: exception in Close\n") ;
#endif
            Status = RPC_S_OUT_OF_MEMORY ;
            }

        State = ConnUninitialized;
        }
}


RPC_STATUS
OSF_CCONNECTION::TransAsyncSend (
    IN OSF_BINDING_HANDLE * BindingHandle,
    IN void  * Buffer,
    IN UINT BufferLength,
    IN void  *SendContext
    )
/*++
Function Name:TransAsyncSend

Parameters:

    BindingHandle - the binding handle on whose identity we
        are doing the call

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    BOOL fTokenSwapped;
    HANDLE OldToken = 0;

    {
    rpcconn_common * pkt = (rpcconn_common *) Buffer;
    LogEvent(SU_CCONN, EV_PKT_OUT, this, pkt, (pkt->PTYPE << 16) | pkt->frag_length);
    }

    //
    // When this function is called, there is should be not outstanding send
    //
    if ( State != ConnOpen )
        {
        return(RPC_P_CONNECTION_CLOSED);
        }

    fTokenSwapped = SwapTokenIfNecessary (BindingHandle, &OldToken);

    DceSecurityInfo.SendSequenceNumber += 1;

    Status = ClientInfo->Send(TransConnection(),
                              BufferLength,
                              (BUFFER) Buffer,
                              SendContext);

    RestoreTokenIfNecessary (fTokenSwapped, OldToken);

    if ( Status != RPC_S_OK )
        {
        State = ConnAborted;
        }

    VALIDATE(Status)
        {
        RPC_S_OK,
        RPC_S_OUT_OF_MEMORY,
        RPC_S_OUT_OF_RESOURCES,
        RPC_P_SEND_FAILED
        } END_VALIDATE;


    return(Status);
}


RPC_STATUS
OSF_CCONNECTION::TransAsyncReceive (
    )
/*++
Function Name:TransAsyncReceive

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;

    if (State != ConnOpen || fConnectionAborted)
        {
        // If the connection has been aborted, then we
        // need to clean up the calls.
        if (fConnectionAborted)
            {
            // Two threads may call ConnectionAborted, but it is
            // idempotent.
            ConnectionAborted(RPC_S_CALL_FAILED);
            }

        return(RPC_P_CONNECTION_CLOSED);
        }

    //
    // If the call to Recv succeeds, this reference is removed
    // in ProcessIOEvents after the call to ProcessReceiveComplete
    //
    // CCONN++
    AddReference();

    Status = ClientInfo->Recv(TransConnection());

    VALIDATE(Status)
        {
        RPC_S_OK,
        RPC_S_OUT_OF_MEMORY,
        RPC_S_OUT_OF_RESOURCES,
        RPC_P_RECEIVE_ALERTED,
        RPC_P_RECEIVE_FAILED,
        RPC_P_CONNECTION_SHUTDOWN
        } END_VALIDATE;

    if (Status != RPC_S_OK)
        {
        if (Status == RPC_P_RECEIVE_ALERTED ||
            Status == RPC_P_RECEIVE_FAILED ||
            Status == RPC_P_CONNECTION_SHUTDOWN)
            {
            ConnectionAborted(RPC_S_CALL_FAILED);
            }
        else
            {
            ConnectionAborted(Status);
            }

        // CCONN--
        RemoveReference();
        }

    return(Status);
}

void
OsfBindToServer(
    PVOID Context
    )
{
    ((OSF_CCALL *) Context)->BindToServer(
        TRUE        // this is an async bind - slightly different
                    // refcounting is used
        );
}


RPC_STATUS
OSF_CCONNECTION::TransPostEvent (
    IN PVOID Context
    )
/*++
Function Name:TransPostEvent

Parameters:

Description:

Returns:

--*/
{
    LogEvent(SU_CCONN, EV_NOTIFY, this, Context, 0, 1);
    return ClientInfo->PostEvent( CO_EVENT_BIND_TO_SERVER, Context) ;
}


RPC_STATUS
OSF_CCONNECTION::TransSend (
    IN OSF_BINDING_HANDLE * BindingHandle,
    IN void  * Buffer,
    IN UINT BufferLength,
    IN BOOL fDisableShutdownCheck,
    IN BOOL fDisableCancelCheck,
    IN ULONG Timeout
    )
/*++

Routine Description:

Arguments:

    BindingHandle - the binding handle on whose identity we
        are doing the call

    Buffer - Supplies a packet to be sent to the server.

    BufferLength - Supplies the length of the buffer in bytes.

Return Value:

    RPC_S_OK - The packet was successfully sent to the server.
    RPC_S_* - an error occurred - see the validate clause at the
        end

--*/
{
    RPC_STATUS Status;
    BOOL fTokenSwapped;
    HANDLE OldToken = 0;

    {
        rpcconn_common * pkt = (rpcconn_common *) Buffer;
        LogEvent(SU_CCONN, EV_PKT_OUT, this, 0, (pkt->PTYPE << 16) | pkt->frag_length);
    }

    if ( State != ConnOpen )
        {
        return(RPC_P_CONNECTION_CLOSED);
        }

    if (fDisableCancelCheck == 0
        && CurrentCall->fCallCancelled)
        {
        return(RPC_S_CALL_CANCELLED);
        }

    fTokenSwapped = SwapTokenIfNecessary (BindingHandle, &OldToken);

    DceSecurityInfo.SendSequenceNumber += 1;

    Status = ClientInfo->SyncSend(TransConnection(),
                                  BufferLength,
                                  (BUFFER) Buffer,
                                  fDisableShutdownCheck,
                                  fDisableCancelCheck,
                                  INFINITE);  // Timeout

    RestoreTokenIfNecessary (fTokenSwapped, OldToken);

    if ( Status == RPC_P_SEND_FAILED )
        {
        State = ConnAborted;
        }

    VALIDATE(Status)
        {
        RPC_S_OK,
        RPC_S_OUT_OF_MEMORY,
        RPC_S_OUT_OF_RESOURCES,
        RPC_P_SEND_FAILED,
        RPC_S_CALL_CANCELLED,
        RPC_P_RECEIVE_COMPLETE,
        RPC_P_TIMEOUT
        }
    CORRUPTION_VALIDATE
        {
        RPC_S_PROTOCOL_ERROR
        } CORRUPTION_END_VALIDATE;

    return(Status);
}

void
OSF_CCONNECTION::TransAbortConnection (
    )
{
    ClientInfo->Abort(TransConnection());
}

RPC_STATUS
OSF_CCONNECTION::TransSendReceive (
    IN OSF_BINDING_HANDLE * BindingHandle,
    IN void  * SendBuffer,
    IN UINT SendBufferLength,
    OUT void  *  * ReceiveBuffer,
    OUT UINT  * ReceiveBufferLength,
    IN ULONG Timeout
    )
/*++

Routine Description:

Arguments:

    BindingHandle - the binding handle on whose identity we
        are doing the call

    SendBuffer - Supplies a packet to be sent to the server.

    SendBufferLength - Supplies the length of the send buffer in bytes.

    ReceiveBuffer - Returns a packet received from the transport.

    ReceiveBufferLength - Returns the length of the receive buffer in bytes.

    dwTimeout - the timeout to wait for the receive. -1 if infinite.

Return Value:

    RPC_S_OK - The packet was successfully sent to the server, and we
        successfully received one from the server.
    RPC_S_* - an error occurred - see the validate clause at the end

--*/
{
    RPC_STATUS Status;
    BOOL fTokenSwapped;
    HANDLE OldToken = 0;

    {
        rpcconn_common * pkt = (rpcconn_common *) SendBuffer;
        if (pkt->PTYPE != rpc_request)
            {
            LogEvent(SU_CCONN, EV_PKT_OUT, this, ULongToPtr(pkt->call_id), (pkt->PTYPE << 16) | pkt->frag_length);
            }
        else
            {
            LogEvent(SU_CCONN, EV_PKT_OUT, this, ULongToPtr(pkt->call_id),
                (((rpcconn_request *)pkt)->opnum << 24) | (pkt->PTYPE << 16) | pkt->frag_length);
            }
    }

    if ( State != ConnOpen )
        {
        return(RPC_P_CONNECTION_CLOSED);
        }

    if (CurrentCall->fCallCancelled)
        {
        return(RPC_S_CALL_CANCELLED);
        }

    fTokenSwapped = SwapTokenIfNecessary (BindingHandle, &OldToken);

    DceSecurityInfo.SendSequenceNumber += 1;

    if ( ClientInfo->SyncSendRecv != 0
         && (CurrentCall->CancelState != CANCEL_NOTINFINITE)
         && (Timeout == INFINITE))
        {
        Status = ClientInfo->SyncSendRecv(TransConnection(),
                                         SendBufferLength,
                                         (BUFFER) SendBuffer,
                                         ReceiveBufferLength,
                                         (BUFFER *) ReceiveBuffer);
        if (!Status)
            {
            rpcconn_common * pkt = (rpcconn_common *) *ReceiveBuffer;
            LogEvent(SU_CCONN, EV_PKT_IN, this, 0, (pkt->PTYPE << 16) | pkt->frag_length);
            }
        }
    else
        {
        Status = ClientInfo->SyncSend (TransConnection(),
                                       SendBufferLength,
                                       (BUFFER) SendBuffer,
                                       FALSE, 
                                       FALSE,
                                       Timeout);     // Timeout
        if ( Status == RPC_S_OK
            || Status == RPC_P_RECEIVE_COMPLETE )
            {
            Status = ClientInfo->SyncRecv(TransConnection(),
                                          (BUFFER *) ReceiveBuffer,
                                          ReceiveBufferLength,
                                          Timeout);
            if (!Status)
                {
                rpcconn_common * pkt = (rpcconn_common *) *ReceiveBuffer;
                LogEvent(SU_CCONN, EV_PKT_IN, this, 0, (pkt->PTYPE << 16) | pkt->frag_length);
                }
            }
        }

    RestoreTokenIfNecessary (fTokenSwapped, OldToken);

    if ((Status == RPC_P_SEND_FAILED)
        || (Status == RPC_P_RECEIVE_FAILED)
        || (Status == RPC_P_CONNECTION_SHUTDOWN)
        || (Status == RPC_P_TIMEOUT))
        {
        State = ConnAborted;
        }

    VALIDATE(Status)
        {
        RPC_S_OK,
        RPC_S_OUT_OF_MEMORY,
        RPC_S_OUT_OF_RESOURCES,
        RPC_P_RECEIVE_FAILED,
        RPC_S_CALL_CANCELLED,
        RPC_P_SEND_FAILED,
        RPC_P_CONNECTION_SHUTDOWN,
        RPC_P_TIMEOUT
        } 
    CORRUPTION_VALIDATE
        {
        RPC_S_PROTOCOL_ERROR
        } CORRUPTION_END_VALIDATE;

    return(Status);
}


UINT
OSF_CCONNECTION::TransMaximumSend (
    )
/*++

Return Value:

    The maximum packet size which can be sent on this transport is returned.

--*/
{
    return(ClientInfo->MaximumFragmentSize);
}


void
OSF_CCONNECTION::ConnectionAborted (
    IN RPC_STATUS Status,
    IN BOOL fShutdownAssoc
    )
/*++
Function Name:AbortConnection

Parameters:

Description:

Returns:

--*/
{
    OSF_CCALL *CCall;
    unsigned int Size;
    DictionaryCursor cursor;
    BOOL fFreeLastBuffer;

    // the failing of the call may take a reference from underneath us
    // bump up the reference count while we have a reference on the
    // object. We'll remove it by the end of the function
    // CCONN++
    ASSERT(fExclusive == 0);

    // CCONN++
    AddReference();

    // make sure the connection gets removed from the dictionary
    Association->ConnectionAborted(this);

    //
    // If the caller has asked us to shutdown the association and
    // the connection has not been flagged to protect the association
    // then we will shut it down.  
    //
    if (
        fShutdownAssoc && 
        (!Flags.GetFlag(NoAssociationShutdown))
        )
        {
        Association->ShutdownRequested(Status, NULL);
        }

    ConnMutex.Request();

    ActiveCalls.Reset(cursor);
    while (CCall = ActiveCalls.Next(cursor))
        {
        if (CCall->CALL::GetCallStatus() == RPC_S_CALL_CANCELLED)
            {
            CCall->CallFailed(RPC_S_CALL_CANCELLED);
            }
        else
            {
            fFreeLastBuffer = FALSE;
            if (CCall->fLastSendComplete)
                {
                if (CurrentCall != CCall)
                    {
                    if ((CCall->CurrentState == NeedOpenAndBind)
                        ||
                        (CCall->CurrentState == NeedAlterContext))
                        {
                        CCall->SetFreeLastBufferFlag();
                        }
                    }
                else if ((CCall->CurrentState == NeedOpenAndBind)
                        ||
                        (CCall->CurrentState == NeedAlterContext)
                        ||
                        (CCall->CurrentState == WaitingForAlterContext)
                        ||
                        (CCall->CurrentState == SendingFirstBuffer)
                       )
                    {
                    CCall->SetFreeLastBufferFlag();
                    }
                }

            //
            // If the call is an async pipe call then we are dealing with an
            // asyncronous failure from a receive or a send posted by the runtime.
            // The user may do a pull, which will detect that the call has failed
            // and will clean it up.  If we issue a call-complete notification
            // during a pull that cleans up the call, then querying the call status
            // upon receiving the notification will AV.  
            // Hence, we should not issue a notification for async pipe CCALLs if
            // we know that a receive will be called.
            // 

            CCall->CallMutex.Request();

            if (!CCall->IsAsyncPipeCallBeforePull())
                {
                CCall->CallFailed(Status);
                }
            else
                {
                //
                // Should not transition from Complete to Aborted
                //
                if (CCall->CurrentState != Complete
                    && CCall->CurrentState != Aborted)
                    {
                    //
                    // Notify the client that the call is aborted. When the stub calls
                    // I_RpcReceive, we can cleanup the call and return a failure.
                    //
                    CCall->AsyncStatus = Status;
                    CCall->CurrentState = Aborted;
                    }
                }

            CCall->CallMutex.Clear();
            }
        }

    //
    // Remove the send references on all the calls currently in the queue
    //
    while (CCall = (OSF_CCALL *) CallQueue.TakeOffQueue(&Size))
        {
        //
        // Remove the send reference, CCALL--
        //
        CCall->RemoveReference();
        }

    ConnMutex.Clear();

    //
    // Make sure we remove this connection from the dictionary
    // before deleting it. We don't want another thread to pick it up
    //
    TransAbortConnection();

    Delete();

    //
    // This routine will always be called with a reference held
    //
    ASSERT(RefCount.GetInteger());

    State = ConnAborted;

    // CCONN--
    RemoveReference();
}


void
OSF_CCONNECTION::AdvanceToNextCall(
    )
/*++
Function Name:AdvanceToNextCall

Parameters:

Description:

Returns:

--*/
{
    UINT Size;
    RPC_STATUS Status;


    ConnMutex.Request();
    CurrentCall = (OSF_CCALL *) CallQueue.TakeOffQueue(&Size);

    if (CurrentCall == 0)
        {
        MakeConnectionIdle();
        ConnMutex.Clear();
        }
    else
        {
        ConnMutex.Clear();

        Status = CurrentCall->SendData(0);

        if (Status != RPC_S_OK)
            {
            ConnectionAborted(Status);

            //
            // The connection cannot die.
            //

            //
            // Remove the send reference for this call. CCALL--
            //
            CurrentCall->RemoveReference();
            }
        }
}


inline RPC_STATUS
OSF_CCONNECTION::TransGetBuffer (
    OUT void  *  * Buffer,
    IN UINT BufferLength
    )
/*++

Routine Description:

    We need a buffer to receive data into or to put data into to be sent.
    This should be really simple, but we need to make sure that buffer we
    return is aligned on an 8 byte boundary.  The stubs make this requirement.

Arguments:

    Buffer - Returns a pointer to the buffer.

    BufferLength - Supplies the required length of the buffer in bytes.

Return Value:

    RPC_S_OK - We successfully allocated a buffer of at least the required
        size.

    RPC_S_OUT_OF_MEMORY - There is insufficient memory available to allocate
        the required buffer.

--*/
{
    int  * Memory;

    //
    // Our memory allocator returns memory which is aligned by at least
    // 8, so we dont need to worry about aligning it.
    //

    Memory = (int  *) CoAllocateBuffer(BufferLength);
    if ( Memory == 0 )
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    ASSERT(IsBufferAligned(Memory));

    *Buffer = Memory;

    ASSERT(PadPtr8(*Buffer) == 0);

    return(RPC_S_OK);
}


inline void
OSF_CCONNECTION::TransFreeBuffer (
    IN void  * Buffer
    )
/*++

Routine Description:

    We need to free a buffer which was allocated via TransGetBuffer.  The
    only tricky part is remembering to remove the padding before actually
    freeing the memory.

--*/
{
    CoFreeBuffer(Buffer);
}


RPC_STATUS
OSF_CCONNECTION::TransReallocBuffer (
    IN OUT void  *  * Buffer,
    IN UINT OldSize,
    IN UINT NewSize
    )
/*++
Function Name:TransReallocBuffer

Parameters:

Description:
    Reallocates a give buffer to the new size.

Returns:
    RPC_S_OK: the buffer is successfully reallocated
    RPC_S_OUT_OF_MEMORY: the realloc failed, the old buffer
     is still valid.

--*/
{
    BUFFER NewBuffer;
    RPC_STATUS Status;

    Status = TransGetBuffer(
                            (PVOID *) &NewBuffer,
                            NewSize);
    if (Status != RPC_S_OK)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    if (OldSize)
        {
        RpcpMemoryCopy(NewBuffer, *Buffer, OldSize);
        TransFreeBuffer(*Buffer);
        }

    *Buffer = NewBuffer;

    return RPC_S_OK;
}


inline RPC_STATUS
OSF_CCONNECTION::AllocateCCall (
    OUT OSF_CCALL **CCall
    )
/*++
Function Name:AllocateCCall

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;

    if (fExclusive)
        {
        ASSERT(CachedCCallAvailable == 1);
        CachedCCallAvailable = 0;
        *CCall = CachedCCall;
        }
    else
        {
        if (InterlockedCompareExchange( (PLONG)&CachedCCallAvailable, 0, 1))
            {
            *CCall = CachedCCall;
            }
        else
            {
            Status = RPC_S_OK;

            // Create a CCALL object.
            // If the app verifier is enabled, we will create an object which 
            // supports the verifier checks.
            if (gfRPCVerifierEnabled)
                {
                *CCall = new (ClientInfo->SendContextSize+sizeof(PVOID)) OSF_CCALL_AVRF(&Status);
                }
            else
                {
                *CCall = new (ClientInfo->SendContextSize+sizeof(PVOID)) OSF_CCALL(&Status);
                }

            if (*CCall == 0)
                {
                Status =  RPC_S_OUT_OF_MEMORY;
                }

            if (Status != RPC_S_OK)
                {
                delete *CCall;
                return Status;
                }
            }

        }

    LogEvent(SU_CCALL, EV_START, *CCall);

    return RPC_S_OK;
}


RPC_STATUS
OSF_CCONNECTION::AddCall (
    IN OSF_CCALL *CCall
    )
/*++
Function Name: AddCall

Parameters:

Description:

    Adds a call to the CallQueue unless this is a CurrentCall.

Returns:

    RPC_S_OK - The call has been added to the queue.
    RPC_S_* - The call has failed or could not be added to the queue.

--*/
{
    RPC_STATUS Status;

    //
    // Think of a better way of doing this. This condition is true the first
    // time a connection is created, and when we are talking to legacy
    // servers over non-exclusive connections
    //
    if (CurrentCall == CCall)
        {
        return RPC_S_OK;
        }

    ConnMutex.Request();
    if (CurrentCall == 0)
        {
        CurrentCall = CCall;
        }
    else
        {
        if ((State == ConnAborted) 
            || ((Association->IsAssociationReset())
                &&
                (State != ConnUninitialized)
               )
           )
            {
            ConnMutex.Clear();
            return RPC_S_CALL_FAILED;
            }

        // If PutOnQueue suceeds, the call migrates to the CallQueue.
        // It will be removed from the CallQueue when:
        // - We advance to the call in the normal course of processing.
        // - The connection is aborted and the sends fail for all queued calls.
        // - The call is freed before the send had a chance to complete,
        // for example due to an abortive cancel.
        Status = CallQueue.PutOnQueue(CCall, 0);
        if (Status != 0)
            {
            ConnMutex.Clear();
            return RPC_S_OUT_OF_MEMORY;
            }
        }
    ConnMutex.Clear();

    return RPC_S_OK;
}


void
OSF_CCONNECTION::FreeCCall (
    IN OSF_CCALL *CCall,
    IN RPC_STATUS Status,
    IN ULONG ComTimeout
    )
/*++
Function Name:FreeCCall

Parameters:
    CCall - the call that is being freed
    Status - the status with which the call completed
    ComTimeout - the communication timeout for this call

Description:
    Free the call, remove reference on the connection. If the free
    is abortive, we need to cleanup the connection and inform the
    association about it.

Returns:

--*/
{
    LogEvent(SU_CCALL, EV_STOP, CCall);

    ConnMutex.Request();

    // The call may still be sitting on the CallQueue if the
    // send did not have a chance to complete before we abortively
    // canceled it.  We need to check for this and remove the call
    // from the queue if necessary.
    CallQueue.FindAndTakeOffQueue(CCall);

    if (CCall == CachedCCall)
        {
        CachedCCallAvailable = 1;
        }
    else
        {
        delete CCall;
        }

    switch (Status)
        {
        case RPC_S_OUT_OF_MEMORY:
        case RPC_S_OUT_OF_RESOURCES:
        case RPC_S_ACCESS_DENIED:
        case RPC_S_PROTOCOL_ERROR:
        case RPC_S_CALL_FAILED:
        case RPC_S_CALL_FAILED_DNE:
        case RPC_S_CALL_CANCELLED:
        case RPC_S_SEC_PKG_ERROR:
        case RPC_S_INVALID_ARG:
        case RPC_S_SERVER_UNAVAILABLE:
        case RPC_P_CONNECTION_SHUTDOWN:
        case RPC_P_CONNECTION_CLOSED:
            //
            // Need to release the connection mutex, so we won't deadlock
            //
            ConnMutex.Clear();
            Association->ConnectionAborted(this);

            ConnMutex.Request();

            if (fExclusive)
                {
                Delete();
                }
            else
                {
                TransAbortConnection();
                }
            break;

        default:
            // RPC_S_UNKNOWN_IF & others
            // Put error codes here only if you are absolutely
            // sure you can recover. If in doubt, put them
            // above

            if (ThreadId == SYNC_CONN_BUSY)
                {
                ThreadId = SYNC_CONN_FREE;
                }
            else if (ThreadId == ASYNC_CONN_BUSY)
                {
                ThreadId = ASYNC_CONN_FREE;
                ASSERT(fExclusive == FALSE);
                if (ComTimeout != RPC_C_BINDING_INFINITE_TIMEOUT)
                    {
                    TurnOnOffKeepAlives (FALSE, 0);
                    }
                }

            SetLastTimeUsedToNow();
            break;
        }
    ConnMutex.Clear();

    //
    // Remove the reference held by the call, CCONN--
    //
    RemoveReference();
}


void
OSF_CCONNECTION::ProcessSendComplete (
   IN RPC_STATUS EventStatus,
   IN BUFFER Buffer
   )
/*++
Function Name:ProcessSendComplete

Parameters:

Description:

Returns:

--*/
{
    rpcconn_common *Packet = (rpcconn_common *) Buffer;
    OSF_CCALL *OldCall;

    switch (Packet->PTYPE)
        {
        case rpc_request:
        case rpc_response:
            TransFreeBuffer(BufferToFree);

            if (EventStatus == RPC_S_OK)
                {
                // This path may also race with RpcAsyncComplete call.
                // We haven't seen it in stress or in any tests, so it may be extremely
                // unlikely.  The bug, if it is present, is very hard.
                OldCall = CurrentCall;
                ASSERT(OldCall);

                if (Association->fMultiplex == mpx_yes)
                    {
                    //
                    // We have no more data to send on this
                    // call. Remove ourselves from the call queue
                    //

                    AdvanceToNextCall();
                    }
                else
                    {
                    if (OldCall->fOkToAdvanceCall())
                        {
                        AdvanceToNextCall();
                        }
                    }

                //
                // Remove the send reference on the call, CCALL--
                //
                OldCall->RemoveReference();

                return;
                }

            break;

        default:
            ASSERT(ConnectionReady == 0);
            TransFreeBuffer(Buffer);
            ConnectionReady = 1;
            break;
        }

    if (EventStatus != RPC_S_OK)
        {
        VALIDATE(EventStatus)
            {
            RPC_P_SEND_FAILED,
            RPC_P_CONNECTION_CLOSED,
            RPC_P_CONNECTION_SHUTDOWN
            } END_VALIDATE;

        ConnectionAborted(RPC_S_CALL_FAILED_DNE);

        // This path races with RpcAsyncCompleteCall path.  We need to make sure that
        // the call does not get deleted from under our feet.
        ConnMutex.Request();
        OldCall = CurrentCall;

        if (OldCall)
            {
            //
            // The current I/O failed.
            // Remove the send reference on the call, CCALL--
            //
            OldCall->RemoveReference();
            }

        ConnMutex.Clear();
        }
}


void
OSF_CCONNECTION::ProcessReceiveComplete (
    IN RPC_STATUS EventStatus,
    IN BUFFER Buffer,
    IN UINT BufferLength
    )
/*++
Function Name:ProcessReceiveComplete

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    OSF_CCALL *CCall;
    BOOL fSubmitReceive;
    rpcconn_common *Packet = (rpcconn_common *) Buffer;

    if (EventStatus)
        {
        LogEvent(SU_CCONN, EV_PKT_IN, this, LongToPtr(EventStatus));
        }
    else
        {
        rpcconn_common * pkt = (rpcconn_common *) Buffer;
        LogEvent(SU_CCONN, EV_PKT_IN, this, 0, (pkt->PTYPE << 16) | pkt->frag_length);
        }

    if (EventStatus != RPC_S_OK)
        {
        VALIDATE(EventStatus)
            {
            RPC_P_CONNECTION_CLOSED,
            RPC_P_RECEIVE_FAILED,
            RPC_P_CONNECTION_SHUTDOWN
            } END_VALIDATE;

        ASSERT(Buffer == 0);
        // second parameter is shutdown association. Cause association shutdown only
        // if the connection is not an idle connection that is getting garbage collected
        ConnectionAborted(RPC_S_CALL_FAILED, ThreadId != ASYNC_CONN_FREE);
        return;
        }

    ASSERT(Buffer);

    //
    // A packet's size can't exceed MaxFrag bytes with the 
    // possible exception of the bind packet or an alter context packets.
    //
    if (Packet->PTYPE != rpc_bind_ack &&
        Packet->PTYPE != rpc_alter_context_resp &&
        ((DataConvertEndian(Packet->drep) == 0 && Packet->frag_length > MaxFrag) ||
         (DataConvertEndian(Packet->drep) != 0 && RpcpByteSwapShort(Packet->frag_length) > MaxFrag)
        )
       )
        {
        CORRUPTION_ASSERT(0 && "Packet->frag_length is too large");
        fSubmitReceive = 0;
        TransAbortConnection();    
        }

    unsigned long CallId = Packet->call_id;

    if (DataConvertEndian(Packet->drep) != 0)
        {
        CallId = RpcpByteSwapLong(CallId);
        }

    ConnMutex.Request();
    CCall = ActiveCalls.Find(IntToPtr(CallId));

    if (CCall)
        {
        if (CCall->CurrentState == Aborted)
            {
            ConnMutex.Clear();
            TransAbortConnection();
            return;
            }

        // We have found the call in the active calls dictionary.  We must assume
        // that if it is in the dictionary, it has a reference count.  Under the protection
        // of the ConnMutex (which must be held when manipulating the ActiveCalls)
        // we give this call another reference count for the duration of our processing        
        CCall->AddReference();
        ConnMutex.Clear();
        //
        // We try to create a thread. If it doesn't work,
        // well too bad !, we'll go ahead and process this
        // PDU any way
        //
        Status = Association->TransInfo->CreateThread();

        VALIDATE(Status)
            {
            RPC_S_OK,
            RPC_S_OUT_OF_MEMORY,
            RPC_S_OUT_OF_THREADS
            } END_VALIDATE;

        //
        // if fSubmitReceive is 1, we need to post a receive,
        // otherwise, the receive will be posted by someone else
        //
        fSubmitReceive = CCall->ProcessReceivedPDU(
                                                   (rpcconn_common *) Buffer,
                                                   BufferLength);


        CCall->RemoveReference();
        // After this point we can no longer touch the call since it may have been freed.
        }
    else
        {
        ConnMutex.Clear();

        fSubmitReceive = 0;

        TransAbortConnection();
        }

    if (fSubmitReceive)
        {
        //
        // TransAsyncReceive will retry several times
        // before giving up.
        // We will clean up the connection on failure.
        //
        TransAsyncReceive ();
        }
    //
    // If we have not called TransAsyncReceive, then
    // we need to probe if the connection has been aborted
    // and needs to be cleaned up.
    // Submiting the next receive after processing a receive-complete
    // is our only chance to check whether a connection has been
    // aborted when the abort has been a result of association shutdown.
    // This avoids leaks in async pipe scenarios.
    //
    else
        {
        if (State != ConnOpen || fConnectionAborted)
            {
            ConnectionAborted(RPC_S_CALL_FAILED);
            }
        }
}


RPC_STATUS
OSF_CCONNECTION::OpenConnectionAndBind (
    IN OSF_BINDING_HANDLE *BindingHandle,
    IN ULONG Timeout,
    IN BOOL fAlwaysNegotiateNDR20,
    OUT FAILURE_COUNT_STATE *fFailureCountExceeded OPTIONAL
    )
/*++
Function Name: OpenConnectionAndBind

Parameters:
    BindingHandle - the binding handle on which we are doing the call
    Timeout - the timeout for the bind (if any)
    fAlwaysNegotiateNDR20 - TRUE if NDR20 should always be negotiated.
        If the server chooses NDR64, we will explicitly alter-context
        to NDR20 if this flag is set.
    fFailureCountExceeded - if supplied, must be FailureCountUnknown. If
        supplied, and we got bind failure with reason not specified, and 
        we haven't exceeded the failure count, this function will keep
        retrying. If supplied, and we received bind failure with reason
        not specified and the failure count is exceeded, it will be set
        to FailureCountExceeded.

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    BOOL fMutexHeld;
    ULONG MyAssocGroupId;
    MPX_TYPES myfMpx = Association->fMultiplex;
    ULONG MyfInitialized;
    void *MyHint = NULL;
    OSF_BINDING *BindingNegotiated;
    OSF_BINDING *IgnoredBinding;
    BOOL fPossibleAssociationReset;

    if (ARGUMENT_PRESENT(fFailureCountExceeded))
        {
        ASSERT(*fFailureCountExceeded == FailureCountUnknown);
        }

    if (!fExclusive)
        {
        //
        // First thing we do is kick off a thread to go and listen
        // this stuff is going to take very long
        //
        Status = Association->TransInfo->CreateThread();
        if (Status != RPC_S_OK)
            {
            //
            // Can't do anything right now, lets just go back and listen
            //
            return Status;
            }
        }

    while (1)
        {
        if (Association->IsResolverHintSynchronizationNeeded())
            {
            Association->AssociationMutex.Request();
            fMutexHeld = TRUE;
            }
        else
            fMutexHeld = FALSE;

        MyfInitialized = Association->AssocGroupId;

        if (MyfInitialized == 0)
            {
            // make sure the hint is allocated only once on the stack
            // otherwise, some of the retry paths will loop through here
            // and may contribute to a stack overflow
            if (MyHint == NULL)
                {
                MyHint = alloca(ClientInfo->ResolverHintSize);
                ASSERT((ClientInfo->ResolverHintSize == 0) || MyHint);
                }
            }
        else
            {
            MyHint = Association->InqResolverHint();
            }

        while (TRUE)
            {
            RpcpPurgeEEInfo();
            Status = TransOpen (
                        BindingHandle,
                        Association->DceBinding->InqRpcProtocolSequence(),
                        Association->DceBinding->InqNetworkAddress(),
                        Association->DceBinding->InqEndpoint(),
                        Association->DceBinding->InqNetworkOptions(),
                        MyHint,
                        MyfInitialized,
                        Timeout);
            if (Status != RPC_S_OK)
                {
                if (ComTimeout == RPC_C_BINDING_INFINITE_TIMEOUT
                    && (Status == RPC_S_SERVER_UNAVAILABLE
                        || Status == RPC_S_SERVER_TOO_BUSY))
                    {
                    continue;
                    }

                if (fMutexHeld)
                    {
                    Association->AssociationMutex.Clear();
                    fMutexHeld = FALSE;
                    }

                if (Status == RPC_S_SERVER_UNAVAILABLE)
                    {
                    Association->ShutdownRequested(Status, NULL);
                    }

                return Status;
                }

            if (fMutexHeld == FALSE)
                {
                Association->AssociationMutex.Request();
                fMutexHeld = TRUE;
                }

            MyAssocGroupId = Association->AssocGroupId;

            if (MyAssocGroupId != 0)
                {
                if (MyfInitialized == 0 && ClientInfo->ResolverHintSize)
                    {
                    //
                    // We lost the race, we need to check if the address
                    // we picked up is the same as the one the winner picked up
                    // if it is not, we need to loop back
                    //
                    if (Association->CompareResolverHint(MyHint))
                        {
                        if (Association->IsResolverHintSynchronizationNeeded() == FALSE)
                            {
                            // if the resolver does not require synchronization, loop
                            // around without the mutex
                            Association->AssociationMutex.Clear();
                            fMutexHeld = FALSE;
                            }

                        if (MyHint != Association->InqResolverHint())
                            Association->FreeResolverHint(MyHint);
                        MyfInitialized = 1;
                        MyHint = Association->InqResolverHint();
                        TransClose();
                        continue;
                        }
                    }

                Association->AssociationMutex.Clear();
                fMutexHeld = FALSE;

                if (MyHint != Association->InqResolverHint())
                    Association->FreeResolverHint(MyHint);
                }
            else
                {
                //
                // We won the race, we need to store the resolved address in
                // the association
                //
                if (ClientInfo->ResolverHintSize)
                    {
                    Association->SetResolverHint(MyHint);
                    Association->ResolverHintInitialized = TRUE;
                    }
                }
            break;
            } // while (1)


        if (GetTransInitializedFlag())
            TransInitComplete();

        //
        // Send a bind packet and wait for response
        //
        Status = ActuallyDoBinding (
                                CurrentCall,
                                MyAssocGroupId,
                                TRUE,       // fNewConnection
                                Timeout,
                                &BindingNegotiated,
                                &fPossibleAssociationReset,
                                fFailureCountExceeded);

        if (Status != RPC_S_OK)
            {

            if (fMutexHeld)
                {
                Association->AssociationMutex.Clear();
                fMutexHeld = FALSE;
                }

            LogEvent(SU_CCONN, EV_STATE, ULongToPtr(MyAssocGroupId), ULongToPtr(Association->AssocGroupId), Status, 1, 0);
            if ((Status == RPC_P_CONNECTION_SHUTDOWN)
                && 
                (
                 fPossibleAssociationReset
                 ||
                 (
                  ARGUMENT_PRESENT(fFailureCountExceeded)
                  &&
                  (*fFailureCountExceeded == FailureCountNotExceeded)
                 )
                )
                &&
                (Association->IsValid())
               )
                {
                //
                // Either:
                // 1. We have hit a race condition where the
                // AssocGroupId is renegotiated because the
                // close for the last connection came ahead
                // of the bind for the next connection. In this
                // case server returns BindNak with 
                // reason_not_specified, which gets translated
                // to RPC_P_CONNECTION_SHUTDOWN. Retry again.
                // or
                // 2. We got bind_nak with reason not specified
                // and the failure count was not exceeded
                //

                TransClose();

                ASSERT(fMutexHeld == FALSE);

                Association->AssociationMutex.Request();
                if (fConnectionAborted == 0)
                    {
                    ASSERT(Association);
                    Association->NotifyConnectionClosed();
                    fConnectionAborted = 1;
                    }

                if (fPossibleAssociationReset)
                    Association->FailureCount = 0;

                InitializeWireAuthId(&ClientSecurityContext);

                if (ClientSecurityContext.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE)
                    {
                    // DeleteSecurityContext checks and deletes 
                    // the security context only if necessary
                    ClientSecurityContext.DeleteSecurityContext();
                    }

                Association->AssociationMutex.Clear();

                if (ARGUMENT_PRESENT(fFailureCountExceeded))
                    {
                    *fFailureCountExceeded = FailureCountUnknown;
                    }

                continue;
                }

            if (fExclusive == 0
                && Status == RPC_S_PROTOCOL_ERROR
                && myfMpx == mpx_unknown)
                {
                Association->fMultiplex = mpx_no;
                //Association->MinorVersion = 0;

                //
                // The server seems to be a legacy server,
                // close the connection and start over,
                // this time, don't set the PFC_CONC_MPX bit
                //
                TransClose();

                ASSERT(fMutexHeld == FALSE);

                Association->AssociationMutex.Request();
                if (fConnectionAborted == 0)
                    {
                    ASSERT(Association);
                    Association->NotifyConnectionClosed();
                    fConnectionAborted = 1;
                    }
                InitializeWireAuthId(&ClientSecurityContext);

                if (ClientSecurityContext.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE)
                    {
                    // DeleteSecurityContext checks and deletes 
                    // the security context only if necessary
                    ClientSecurityContext.DeleteSecurityContext();
                    }

                Association->AssociationMutex.Clear();
                continue;
                }
            return Status;
            }

        break;
        }

    // if we negotiated NDR64, but we were asked to negotiate NDR20,
    // alter context to get the right context for this call
    if (fAlwaysNegotiateNDR20 
        && (BindingNegotiated->CompareWithTransferSyntax(NDR64TransferSyntax) == 0))
        {
        // limit the choice to NDR20 only
        // We do this by whacking the list of available bindings. Since the chosen binding
        // is NDR20, this will force the bind to negotiate NDR20. We also change the state
        // to WaitingForAlterContext
        ASSERT(CurrentCall->Bindings.SelectedBinding->CompareWithTransferSyntax(NDR20TransferSyntax) == 0);
        ReleaseBindingListWithException(CurrentCall->Bindings.SelectedBinding,
            CurrentCall->Bindings.AvailableBindingsList
            );

        CurrentCall->Bindings.AvailableBindingsList = NULL;

        CurrentCall->CurrentState = NeedAlterContext;

        Status = ActuallyDoBinding (
                                CurrentCall,
                                MyAssocGroupId,
                                FALSE,       // fNewConnection
                                Timeout,
                                &IgnoredBinding,
                                &fPossibleAssociationReset,      // never actually used here
                                NULL        // fFailureCountExceeded
                                );

        if (Status)
            {
            if (fMutexHeld)
                {
                Association->AssociationMutex.Clear();
                }
            return Status;
            }
        }

    if (fMutexHeld)
        {
        Association->AssociationMutex.Clear();
        }

    ASSERT((CurrentCall->CurrentState == NeedOpenAndBind)
           || (CurrentCall->CurrentState == NeedAlterContext)
           || (CurrentCall->CurrentState == Aborted));

    if ((CurrentCall == NULL) || (CurrentCall->CurrentState == Aborted))
        {
        TransAbortConnection();
        if ((CurrentCall != NULL) && (CurrentCall->GetCallStatus() == RPC_S_CALL_CANCELLED))
            {
            return RPC_S_CALL_CANCELLED;
            }
        else
            {
            return RPC_S_CALL_FAILED_DNE;
            }
        }

    CurrentCall->CurrentState = SendingFirstBuffer;

    if (!fExclusive)
        {
        Status = TransAsyncReceive();
        if (Status != RPC_S_OK)
            {
            return Status;
            }

        CurrentCall->CallMutex.Request();
        if (CurrentCall->CurrentBuffer == 0)
            {
            MakeConnectionIdle();
            CurrentCall->CallMutex.Clear();
            }
        else
            {
            ASSERT(IsIdle() == 0);
            CurrentCall->CallMutex.Clear();

            Status = CurrentCall->SendNextFragment();
            }
        }

    return Status ;
}


RPC_STATUS
OSF_CCONNECTION::ActuallyDoBinding (
    IN OSF_CCALL *CCall,
    IN ULONG MyAssocGroupId,
    IN BOOL fNewConnection,
    IN ULONG Timeout,
    OUT OSF_BINDING **BindingNegotiated,
    OUT BOOL *fPossibleAssociationReset,
    OUT FAILURE_COUNT_STATE *fFailureCountExceeded
    )
/*++
Function Name:ActuallyDoBinding

Parameters:
    fFailureCountExceeded - if supplied, must be FailureCountUnknown. If
        we got bind failure with reason not specified, and we haven't
        exceeded the failure count, it will be set to 
        FailureCountNotExceeded. If we received bind failure with reason
        not specified and the failure count is exceeded, it will be set
        to FailureCountExceeded.

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    rpcconn_common * Buffer = 0;
    UINT BufferLength = 0;
    OSF_BINDING *Binding;
    BOOL ServerSupportsHeaderSigning = FALSE;

    if (ARGUMENT_PRESENT(fFailureCountExceeded))
        {
        ASSERT(*fFailureCountExceeded == FailureCountUnknown);
        }

    *fPossibleAssociationReset = FALSE;

    if ( fNewConnection != 0)
        {
        ASSERT(fConnectionAborted == 1);

        Association->AssociationMutex.Request();

        if ((MyAssocGroupId != 0) && (Association->AssocGroupId != MyAssocGroupId))
            {
            // if we are already reset, then the server connection may
            // be killed also. Just back out and retry
            LogEvent(SU_CASSOC, EV_STATE, (PVOID)55, (PVOID)55, 66, 1, 0);
            *fPossibleAssociationReset = TRUE;

            Association->FailureCount = 0;

            Association->AssociationMutex.Clear();

            return (RPC_P_CONNECTION_SHUTDOWN);
            }

        Association->NotifyConnectionBindInProgress();

        Association->AssociationMutex.Clear();
        }

    Status = SendBindPacket( CCall->BindingHandle,
                             TRUE,
                             CCall,
                             MyAssocGroupId,
                             (fNewConnection ? rpc_bind : rpc_alter_context),
                             Timeout,
                             FALSE,             // synchronous
                             &Buffer,
                             &BufferLength,
                             0,                 // no input buffer
                             0                  // no input buffer
                             );
    //
    // Now mark this connection as a part of the pool
    //
    if ( fNewConnection != 0)
        {
        Association->AssociationMutex.Request();

        if (Association->fPossibleServerReset)
            {
            LogEvent(SU_CASSOC, EV_STATE, (PVOID)77, (PVOID)77, 88, 1, 0);
            *fPossibleAssociationReset = TRUE;
            }

        //
        // Did we get aborted while we were trying to bind ?
        //
        if (ConnectionKey == -1)
            {

            Association->NotifyConnectionBindCompleted();

            TransAbortConnection();

            if (Status == RPC_S_OK)
                {
                TransFreeBuffer(Buffer);
                }

            Status = RPC_P_CONNECTION_SHUTDOWN;
            }
        else
            {
            if ((Status != RPC_S_OK) || ( Buffer->PTYPE != rpc_bind_nak ))
                {
                Association->NotifyConnectionOpen();
                fConnectionAborted = 0;
                }
            
            Association->NotifyConnectionBindCompleted();
            }

        Association->AssociationMutex.Clear();
        }

    if ( Status != RPC_S_OK )
        {
        VALIDATE(Status)
            {
            RPC_S_OUT_OF_MEMORY,
            RPC_S_OUT_OF_RESOURCES,
            RPC_P_CONNECTION_SHUTDOWN,
            RPC_P_CONNECTION_CLOSED,
            RPC_S_UUID_NO_ADDRESS,
            RPC_S_ACCESS_DENIED,
            RPC_S_SEC_PKG_ERROR,
            RPC_S_CALL_CANCELLED,
            RPC_P_TIMEOUT,
            ERROR_SHUTDOWN_IN_PROGRESS
            }
        CORRUPTION_VALIDATE
            {
            RPC_S_PROTOCOL_ERROR
            } CORRUPTION_END_VALIDATE;

        //
        // We'll let the call decide whether to nuke the connection
        //
        return(Status);
        }

    // We loop around ignoring shutdown packets until we get a response.

    for (;;)
        {
        if ( Buffer->PTYPE == rpc_shutdown )
            {
            Association->ShutdownRequested(RPC_S_CALL_FAILED_DNE, NULL);

            TransFreeBuffer(Buffer);

            Status = TransReceive((void **) &Buffer,
                &BufferLength,
                Timeout);

            if ( Status != RPC_S_OK )
                {
                VALIDATE(Status)
                    {
                    RPC_S_OUT_OF_MEMORY,
                    RPC_S_OUT_OF_RESOURCES,
                    RPC_P_RECEIVE_FAILED,
                    RPC_P_CONNECTION_CLOSED,
                    RPC_S_CALL_CANCELLED,
                    RPC_P_TIMEOUT
                    } END_VALIDATE;

                if ( Status == RPC_P_RECEIVE_FAILED )
                    {
                    return RPC_P_CONNECTION_CLOSED;
                    }
                return Status;
                }

            // If there is security, we need to save the packet header;
            // byte-swapping the header will mess up decryption.

            Status = ValidateHeader(Buffer, BufferLength);
            if ( Status != RPC_S_OK )
                {
                TransFreeBuffer(Buffer);
                return Status;
                }

            continue;
            }
        else if ( fNewConnection )
            {
            // Since this is a new connection, the packet we receive
            // must be either a bind_ack or a bind_nak; anything else
            // is an error.

            if (Buffer->PTYPE == rpc_bind_ack || Buffer->PTYPE == rpc_bind_nak)
                {
                break;
                }
            else
                {
                TransFreeBuffer(Buffer);
                return RPC_S_PROTOCOL_ERROR;
                }
            }
        else
            {
            // This is a preexisting connection.
            // We allow only an alter_context_response.

            if ( Buffer->PTYPE == rpc_alter_context_resp )
                {
                break;
                }
            else
                {
                TransFreeBuffer(Buffer);
                return RPC_S_PROTOCOL_ERROR;
                }
            }
        }

    ULONG NewGroupId;

    //
    // We subtract from BufferLength the length of the authentication
    // information; that way ProcessBindAckOrNak can check the length
    // correctly, whether or not there is security information.
    //
    if (MyAssocGroupId == 0)
        {
        Association->AssociationMutex.VerifyOwned();

        Status = Association->ProcessBindAckOrNak(
                                         Buffer,
                                         BufferLength - Buffer->auth_length,
                                         this,
                                         CCall,
                                         &NewGroupId,
                                         BindingNegotiated,
                                         fFailureCountExceeded);
        }
    else
        {
        Status = Association->AssociationMutex.RequestSafe();

        if (Status == RPC_S_OK)
            {
            Status = Association->ProcessBindAckOrNak(
                                             Buffer,
                                             BufferLength - Buffer->auth_length,
                                             this,
                                             CCall,
                                             &NewGroupId,
                                             BindingNegotiated,
                                             fFailureCountExceeded);

            Association->AssociationMutex.Clear();
            }
        }

    LogEvent(SU_CCONN, EV_STATE, ULongToPtr(MyAssocGroupId), ULongToPtr(Association->AssocGroupId), Status, 1, 0);

    if (fExclusive == 0
        && Association->fMultiplex == mpx_unknown)
        {
        if (((rpcconn_common *) Buffer)->pfc_flags & PFC_CONC_MPX)
            {
            Association->fMultiplex = mpx_yes;
            }
        else
            {
            Association->fMultiplex = mpx_no;
            }
        }

    if ( Status == RPC_S_OK )
        {
        if (((rpcconn_common *)Buffer)->pfc_flags & PFC_SUPPORT_HEADER_SIGN)
            ServerSupportsHeaderSigning = TRUE;

        Status = FinishSecurityContextSetup(
                             CCall,
                             MyAssocGroupId,
                             &Buffer,
                             &BufferLength,
                             Timeout
                             );
        }
    else
        {
        TransFreeBuffer(Buffer);
        }

    if ( Status == RPC_S_OK )
        {
        if (IsVerificationTrailerNecessary())
            {
            if (ServerSupportsHeaderSigning)
                {
                // bind should happen only initially on the connection
                ASSERT(GetConnectionSupportHeaderSign() == cshsDontKnow);
                SetConnectionSupportHeaderSignUnsafe (cshsYes);
                }
            else if (GetConnectionSupportHeaderSign() == cshsDontKnow)
                {
                // if the server said it didn't support header singing,
                // assume no for now, but verify on first response
                SetConnectionSupportHeaderSignUnsafe (cshsUnconfirmedNo);
                }
            }

        Binding = CCall->GetSelectedBinding();
        if (MyAssocGroupId == 0)
            {
            Association->AssociationMutex.VerifyOwned();

            if (AddPContext(Binding->GetPresentationContext()) != 0)
                {
                Status = RPC_S_OUT_OF_RESOURCES;
                }
            else
                {
                //
                // Once we reach here, we know that the binding has been accepted,
                // so we can go ahead and set the association group id.
                // warning: as soon as the AssocGroupId is set, threads
                // will start sending the bind without acquiring the mutex
                //
                LogEvent(SU_CASSOC, EV_NOTIFY, Association, this, NewGroupId, 1, 0);
                Association->AssocGroupId = NewGroupId;
                }
            }
        else
            {
            Status = Association->AssociationMutex.RequestSafe();
            if (Status == RPC_S_OK)
                {
                if (AddPContext(Binding->GetPresentationContext()) != 0)
                    {
                    Status = RPC_S_OUT_OF_RESOURCES;
                    }
                Association->AssociationMutex.Clear();
                }
            }

        if (fNewConnection)
            {
            Status = CCall->ReserveSpaceForSecurityIfNecessary();
            }
        }
    else
        {
        if (fNewConnection != 0)
            {
            //
            // If Status == DNE, it means that we probably got a B-NAK
            // [Also note this is a new connection]
            // If we were using security, [Auth Level != NONE]
            // delete this connection, and return RPC_P_CONNECTION_SHUTDOWN
            // which will cause BH->GetBuffer code to retry 2 more times
            //

            if (Status == RPC_S_CALL_FAILED_DNE)
               {
               //
               // Retry failures over non-authenticated
               // binds also.. the ones we retry over are bind naks with
               // unspecifed reason .. one day we can get OSF to send
               // bind_nk with reason assoc_group_shutdown..
               // && (CConnection->AuthInfo.AuthenticationLevel
               // != RPC_C_AUTHN_LEVEL_NONE))
               //
               Status = RPC_P_CONNECTION_SHUTDOWN;
               }
            }
        }

    return(Status);
}


RPC_STATUS
OSF_CCONNECTION::FinishSecurityContextSetup (
    IN OSF_CCALL *Call,
    IN unsigned long AssocGroup,
    IN OUT rpcconn_common * * Buffer,
    IN OUT unsigned int * BufferLength,
    IN ULONG Timeout
    )
{
    RPC_STATUS Status = RPC_S_OK;

    if (ClientSecurityContext.AuthenticationService == RPC_C_AUTHN_NONE
        || ClientSecurityContext.AuthenticationLevel == RPC_C_AUTHN_LEVEL_NONE)
        {
        TransFreeBuffer(*Buffer);
        return RPC_S_OK;
        }

    if ( !ClientSecurityContext.FullyConstructed() )
        {
        //
        // Some packages need more than one round trip; we keep sending secure
        // alter-context packets until the security context is fully set up.
        //
        do
            {
            rpcconn_common * InputBuffer = *Buffer;

            *Buffer = 0;

            Status = SendBindPacket(
                         Call->BindingHandle,
                         FALSE,
                         Call,
                         AssocGroup,
                         rpc_alter_context,
                         Timeout,
                         FALSE,      // synchronous
                         Buffer,
                         BufferLength,
                         InputBuffer,
                         *BufferLength
                         );

            TransFreeBuffer(InputBuffer);
            }
        while (Status == RPC_S_OK && !ClientSecurityContext.FullyConstructed() );

        if (Status == RPC_S_OK && *Buffer)
            {
            TransFreeBuffer(*Buffer);
            }
        }
    else
        {
        TransFreeBuffer(*Buffer);
        }

    if (RPC_S_OK == Status)
        {
        // We need to figure out how much space to reserve for security
        // information at the end of request and response packets.
        // In addition to saving space for the signature or header,
        // we need space to pad the packet to a multiple of the maximum
        // security block size as well as for the security trailer.

        switch ( ClientSecurityContext.AuthenticationLevel )
            {

            case RPC_C_AUTHN_LEVEL_CONNECT:
                // we know all MS providers provide non-zero token on connect,
                // but the token can be safely omitted.
                // The problem is that some legacy RPC servers may expect the token to
                // be present and will check for the buffer.
            case RPC_C_AUTHN_LEVEL_PKT:
            case RPC_C_AUTHN_LEVEL_PKT_INTEGRITY:
                AdditionalSpaceForSecurity = MAXIMUM_SECURITY_BLOCK_SIZE +
                    ClientSecurityContext.MaximumSignatureLength()
                    + sizeof(sec_trailer);
                break;

            case RPC_C_AUTHN_LEVEL_PKT_PRIVACY:
                AdditionalSpaceForSecurity = MAXIMUM_SECURITY_BLOCK_SIZE +
                    ClientSecurityContext.MaximumHeaderLength()
                    + sizeof(sec_trailer);
                break;

            default:
                ASSERT(!"Unknown Security Level\n");

            }
        }

    return Status;
}


RPC_STATUS
OSF_CCONNECTION::DealWithAlterContextResp (
    IN OSF_CCALL *CCall,
    IN rpcconn_common *Packet,
    IN int PacketLength,
    IN OUT BOOL *AlterContextToNDR20IfNDR64Negotiated
    )
/*++
Function Name:DealWithAlterContextResp

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    ULONG NewGroupId;
    BOOL fContextAddingFailed;
    OSF_BINDING *Binding;
    OSF_BINDING *NegotiatedBinding;

    Status = Association->AssociationMutex.RequestSafe();
    if (Status)
        return Status;

    Status = Association->ProcessBindAckOrNak(
                         Packet,
                         PacketLength - Packet->auth_length,
                         this,
                         CCall,
                         &NewGroupId,
                         &NegotiatedBinding,
                         NULL           // fFailureCountExceeded
                         );

    if ( Status != RPC_S_OK )
        {
        Association->AssociationMutex.Clear();
        }
    else
        {
        // the binding must have been fixed on the call by now
        Binding = CCall->GetSelectedBinding();
        ASSERT(Binding);

        fContextAddingFailed = AddPContext(Binding->GetPresentationContext());
        Association->AssociationMutex.Clear();
        if (fContextAddingFailed)
            return RPC_S_OUT_OF_MEMORY;

        if (*AlterContextToNDR20IfNDR64Negotiated)
            {
            if (NegotiatedBinding->CompareWithTransferSyntax(NDR64TransferSyntax) == 0)
                {
                //
                // Wait for the send to complete
                //
                WaitForSend();

                CCall->SendAlterContextPDU();
                }
            else
                {
                *AlterContextToNDR20IfNDR64Negotiated = FALSE;
                }
            }
        }

    return Status;
}


RPC_STATUS
OSF_CCONNECTION::SendBindPacket (
    IN OSF_BINDING_HANDLE * BindingHandle, OPTIONAL
    IN BOOL fInitialPass,
    IN OSF_CCALL *Call,
    IN ULONG AssocGroup,
    IN unsigned char PacketType,
    IN ULONG Timeout,
    IN BOOL fAsync,
    OUT rpcconn_common * * Buffer,
    OUT UINT  * BufferLength,
    IN rpcconn_common * InputPacket,
    IN unsigned int InputPacketLength
    )
/*++

Routine Description:

    This routine is used to send a bind or alter context packet.  It
    will allocate a buffer, fill in the packet, and then send it and
    receive a reply.  The reply buffer is just returned to the caller.

Arguments:

    BindingHandle - the binding handle on whose identity we
        are doing the call

    fInitialPass - true if this is the first bind packet sent for this
        connection

    Call - the call whose binding information we need to use in order
        to bind.

    AssocGroup - Supplies the association group id for the association
        group of which this connection is a new member.

    PacketType - Supplies the packet type which must be one of rpc_bind
        or rpc_alter_context.

    fAsync - the binding is async

    Buffer - Returns the reply buffer.

    BufferLength - Returns the length of the reply buffer.

    InputPacket - the packet received from a peer, if this is not
        the first leg of a security negotiation

    InputPacketLength - the length of the input packet

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete
        the operation.

    RPC_S_OUT_OF_RESOURCES - Insufficient resources are available to
        complete the operation.

    RPC_S_ACCESS_DENIED - The security package won't allow this.

    RPC_P_CONNECTION_CLOSED - The connection has been closed and the
        receive operation failed.  The send operation may or may not
        have succeeded.

--*/
{
    rpcconn_bind * BindPacket = 0;
    UINT BindPacketLength, SecurityTokenLength;
    RPC_STATUS Status;
    sec_trailer * SecurityTrailer;
    SECURITY_BUFFER_DESCRIPTOR BufferDescriptor;
    SECURITY_BUFFER SecurityBuffers[4];
    DCE_INIT_SECURITY_INFO InitSecurityInfo;
    UINT CompleteNeeded = 0;
    OSF_CCALL *CallToBindFor = Call;
    OSF_BINDING *BindingsAvailable;
    OSF_BINDING *CurrentBinding;
    BOOL fMultipleBindingsAvailable;
    int AvailableBindingsCount;

    ASSERT(CallToBindFor != 0);

    BindingsAvailable = CallToBindFor->GetListOfAvaialbleBindings(&fMultipleBindingsAvailable);

    if (fMultipleBindingsAvailable)
        {
        AvailableBindingsCount = 0;
        CurrentBinding = BindingsAvailable;
        do
            {
            AvailableBindingsCount ++;
            CurrentBinding = CurrentBinding->GetNextBinding();
            }
        while (CurrentBinding != 0);
        }
    else
        {
        AvailableBindingsCount = 1;
        }

    BindPacketLength = sizeof(rpcconn_bind) + sizeof(p_cont_list_t) +
            (AvailableBindingsCount - 1) * sizeof(p_cont_elem_t);

    // The packet length should always be 4-byte aligned:
    // BindPacketLength = 0x18 + 0x30 + x*0x2c = 0 (mod 4)
    ASSERT(Pad4(BindPacketLength) == 0) ;

    //
    // If we need to send authentication information in the packet, we
    // need to save space for it.  This method prepares and sends both
    // rpc_bind and rpc_alter_context packets; we will only send
    // authentication information in rpc_bind packets.  This is due to
    // a design decision that each connection supports only a single
    // security context, which is determined when the connection is
    // created.
    //

    if (ClientSecurityContext.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE
        && !ClientSecurityContext.FullyConstructed())
        {
        VALIDATE(ClientSecurityContext.AuthenticationLevel)
            {
            RPC_C_AUTHN_LEVEL_CONNECT,
            RPC_C_AUTHN_LEVEL_PKT,
            RPC_C_AUTHN_LEVEL_PKT_INTEGRITY,
            RPC_C_AUTHN_LEVEL_PKT_PRIVACY
            } END_VALIDATE;

        if (fInitialPass)
            {
            Status = UuidCreateSequential(&(DceSecurityInfo.AssociationUuid));
            if ((Status != RPC_S_OK )
                && (Status != RPC_S_UUID_LOCAL_ONLY))
                {
                return(Status);
                }
            }

        //
        // The packet length is always aligned to a four byte boundary.
        // Save space for the token and the sec_trailer.  We also need
        // to save the length of the token because we will need it later
        // if we do third leg authentication.
        //

        TokenLength = ClientSecurityContext.Credentials->MaximumTokenLength();
        BindPacketLength += TokenLength + sizeof(sec_trailer);
        }

    // BindPacketLength may be larger then TransMaximumSend.  There
    // is nothing that we can do about it - the token can get arbitrarily
    // large.

    Status = TransGetBuffer((void * *) &BindPacket,
                            BindPacketLength);
    if ( Status != RPC_S_OK )
        {
        ASSERT( Status == RPC_S_OUT_OF_MEMORY );
        TransFreeBuffer(BindPacket);
        return(RPC_S_OUT_OF_MEMORY);
        }

    ConstructPacket((rpcconn_common *) BindPacket, PacketType, BindPacketLength);

    //
    // A three-leg protocol will be sending an RPC_AUTH_3 instead of a BIND or ALTER_CONTEXT.
    // DCE Kerberos is the only package that uses the read-only output buffers.
    //

    BindPacket->max_xmit_frag
            = BindPacket->max_recv_frag
            = (unsigned short) TransMaximumSend();
    BindPacket->assoc_group_id = AssocGroup;
    BindPacket->common.call_id = CallToBindFor->CallId;
    BindPacket->common.pfc_flags =
        PFC_FIRST_FRAG | PFC_LAST_FRAG;

    // we send this on first bind only
    if ((PacketType == rpc_bind) && IsVerificationTrailerNecessary())
        {
        BindPacket->common.pfc_flags |= PFC_SUPPORT_HEADER_SIGN;
        }

    if (fSeparateConnection == 0
        && fExclusive == 0
        && Association->fMultiplex != mpx_no)
        {
        //
        // We don't want to set PFC_CONC_MPX for all the requests
        // because the legacy NT server will send a protocol error fault
        // and nuke the connection
        //
        BindPacket->common.pfc_flags |= PFC_CONC_MPX;
        }

    ConstructPContextList((p_cont_list_t *) (BindPacket + 1),
                          BindingsAvailable,
                          AvailableBindingsCount);

    //
    // If this connection is using security, we need to stick the
    // authentication information into the packet.
    //

    if ( ClientSecurityContext.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE
         && !ClientSecurityContext.FullyConstructed() )
        {
        InitSecurityInfo.DceSecurityInfo      = DceSecurityInfo;
        InitSecurityInfo.AuthorizationService = ClientSecurityContext.AuthorizationService;
        InitSecurityInfo.PacketType           = PacketType;

        BufferDescriptor.ulVersion = 0;
        BufferDescriptor.cBuffers = 4;
        BufferDescriptor.pBuffers = SecurityBuffers;

        SecurityBuffers[3].BufferType = SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
        SecurityBuffers[3].pvBuffer   = &InitSecurityInfo;
        SecurityBuffers[3].cbBuffer   = sizeof(DCE_INIT_SECURITY_INFO);

        if (fInitialPass)
            {
            AdditionalLegNeeded = 0;

            SecurityBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
            SecurityBuffers[0].pvBuffer   = BindPacket;
            SecurityBuffers[0].cbBuffer   = sizeof(rpcconn_bind);

            SecurityBuffers[1].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
            SecurityBuffers[1].pvBuffer   = ((unsigned char  *) BindPacket)
                                          + sizeof(rpcconn_bind);
            SecurityBuffers[1].cbBuffer   = BindPacketLength
                                          - sizeof(rpcconn_bind)
                                          - ClientSecurityContext.Credentials->MaximumTokenLength();

            SecurityBuffers[2].BufferType = SECBUFFER_TOKEN;
            SecurityBuffers[2].pvBuffer   = ((unsigned char  *) BindPacket)
                                          + BindPacketLength
                                          - ClientSecurityContext.Credentials->MaximumTokenLength();
            SecurityBuffers[2].cbBuffer   = ClientSecurityContext.Credentials->MaximumTokenLength();

            Status = ClientSecurityContext.InitializeFirstTime(
                                           ClientSecurityContext.Credentials,
                                           ClientSecurityContext.ServerPrincipalName,
                                           ClientSecurityContext.AuthenticationLevel,
                                           &BufferDescriptor,
                                           &WireAuthId);

            LogEvent(SU_CCONN, EV_SEC_INIT1, this, LongToPtr(Status), SecurityBuffers[2].cbBuffer);
            }
        else
            {
            if (ClientSecurityContext.Legs == ThreeLegs)
                {
                BindPacket->common.PTYPE = rpc_auth_3;

                SecurityBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
                SecurityBuffers[0].pvBuffer   = BindPacket;
                SecurityBuffers[0].cbBuffer   = sizeof(rpcconn_auth3);

                SecurityBuffers[1].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
                SecurityBuffers[1].pvBuffer   = ((unsigned char  *) BindPacket)
                                              + sizeof(rpcconn_auth3);
                SecurityBuffers[1].cbBuffer   = sizeof(sec_trailer);

                SecurityBuffers[2].BufferType = SECBUFFER_TOKEN;
                SecurityBuffers[2].pvBuffer   = ((unsigned char  *) BindPacket)
                                              + sizeof(rpcconn_auth3)
                                              + sizeof(sec_trailer);
                SecurityBuffers[2].cbBuffer   = TokenLength;

                //
                // These structures are already 4-aligned, so no padding is needed.
                //
                BindPacketLength = sizeof(rpcconn_auth3) + sizeof(sec_trailer) + TokenLength;
                }
            else
                {
                SecurityBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
                SecurityBuffers[0].pvBuffer   = BindPacket;
                SecurityBuffers[0].cbBuffer   = sizeof(rpcconn_bind);

                SecurityBuffers[1].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
                SecurityBuffers[1].pvBuffer   = ((unsigned char  *) BindPacket)
                                              + sizeof(rpcconn_bind);
                SecurityBuffers[1].cbBuffer   = BindPacketLength
                                              - sizeof(rpcconn_bind)
                                              - TokenLength;

                SecurityBuffers[2].BufferType = SECBUFFER_TOKEN;
                SecurityBuffers[2].pvBuffer   = ((unsigned char  *) BindPacket)
                                              + BindPacketLength
                                              - TokenLength;
                SecurityBuffers[2].cbBuffer   = TokenLength;
                }

           //
           // a third leg auth may not be needed with some packages
           // on an alter context [where only pcon is changed as opposed
           // to an alternative client principal]
           //
           AdditionalLegNeeded = 0;

           if (InputPacket)
               {
               SECURITY_BUFFER_DESCRIPTOR InputBufferDescriptor;
               SECURITY_BUFFER            InputBuffers[4];
               DCE_INIT_SECURITY_INFO     InputSecurityInfo;

               InputSecurityInfo.DceSecurityInfo      = DceSecurityInfo;
               InputSecurityInfo.AuthorizationService = ClientSecurityContext.AuthorizationService;
               InputSecurityInfo.PacketType           = InputPacket->PTYPE;

               InputBufferDescriptor.ulVersion = 0;
               InputBufferDescriptor.cBuffers = 4;
               InputBufferDescriptor.pBuffers = InputBuffers;

               ASSERT((SavedHeader != 0) && (SavedHeaderSize != 0));

               InputBuffers[0].cbBuffer   = sizeof(rpcconn_bind_ack) - sizeof(unsigned short);
               InputBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
               InputBuffers[0].pvBuffer   = SavedHeader;

               InputBuffers[1].cbBuffer   = InputPacketLength
                                          - (sizeof(rpcconn_bind_ack) - sizeof(unsigned short))
                                          - InputPacket->auth_length;
               InputBuffers[1].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
               InputBuffers[1].pvBuffer   = ((unsigned char *) SavedHeader)
                                          + sizeof(rpcconn_bind_ack) - sizeof(unsigned short);

               InputBuffers[2].cbBuffer   = InputPacket->auth_length;
               InputBuffers[2].BufferType = SECBUFFER_TOKEN;
               InputBuffers[2].pvBuffer   = ((unsigned char *) InputPacket) + InputPacketLength - InputPacket->auth_length;

               InputBuffers[3].cbBuffer   = sizeof(DCE_INIT_SECURITY_INFO);
               InputBuffers[3].BufferType = SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
               InputBuffers[3].pvBuffer   = &InputSecurityInfo;

               Status = ClientSecurityContext.InitializeThirdLeg(
                          ClientSecurityContext.Credentials,
                          *((unsigned long *) &(BindPacket->common.drep[0])),
                          &InputBufferDescriptor,
                          &BufferDescriptor
                          );

               }
           else
               {
               Status = ClientSecurityContext.InitializeThirdLeg(
                          ClientSecurityContext.Credentials,
                          *((unsigned long *) &(BindPacket->common.drep[0])),
                          0,
                          &BufferDescriptor
                          );
               }

           LogEvent(SU_CCONN, EV_SEC_INIT3, this, LongToPtr(Status), SecurityBuffers[2].cbBuffer);
           }

        //
        // The security package has encrypted or signed the data.
        //

        if ( Status == RPC_P_CONTINUE_NEEDED )
            {
            //
            // Remember the fact that the security package requested that
            // it be called again.  This will be important later: see
            // OSF_CASSOCIATION::ActuallyDoBinding.
            //

            AdditionalLegNeeded = 1;
            }
        else if ( Status == RPC_P_COMPLETE_NEEDED )
            {
            CompleteNeeded = 1;
            }
        else if ( Status == RPC_P_COMPLETE_AND_CONTINUE )
            {
            AdditionalLegNeeded = 1;
            CompleteNeeded = 1;
            }
        else if ( Status != RPC_S_OK )
            {
            VALIDATE(Status)
                {
                RPC_S_OUT_OF_MEMORY,
                RPC_S_ACCESS_DENIED,
                RPC_S_SEC_PKG_ERROR,
                RPC_S_UNKNOWN_AUTHN_SERVICE,
                RPC_S_INVALID_ARG,
                ERROR_SHUTDOWN_IN_PROGRESS
                } END_VALIDATE;

            TransFreeBuffer(BindPacket);
            return(Status);
            }

        //
        // The Snego package can behave either as a 3- or 4-leg protocol depending
        // upon the server. It knows which way to go after the first call to
        // InitializeSecurityContext().
        //
        if (fInitialPass && AdditionalLegNeeded)
            {
            ClientSecurityContext.Legs = GetPackageLegCount( WireAuthId );
            if (ClientSecurityContext.Legs == LegsUnknown)
                {
                TransFreeBuffer(BindPacket);
                return RPC_S_OUT_OF_MEMORY;
                }
            }

        //
        // In NT 4.0 and before, the length was considered a read-only field.
        //
        SecurityTokenLength = (UINT) SecurityBuffers[2].cbBuffer;

        if (!AdditionalLegNeeded &&
            0 == SecurityTokenLength)
            {
            //
            // No more packets to send.
            //
            TransFreeBuffer(BindPacket);
            return RPC_S_OK;
            }

        //
        // We need to fill in the fields of the security trailer.
        //

        // The size allocated above included space for MaximumTokenLength.
        SecurityTrailer = (sec_trailer *)
                (((unsigned char  *) BindPacket)
                + BindPacketLength
                - ClientSecurityContext.Credentials->MaximumTokenLength()
                - sizeof(sec_trailer));

        SecurityTrailer->auth_type = WireAuthId;
        SecurityTrailer->auth_level = (unsigned char) ClientSecurityContext.AuthenticationLevel;
        SecurityTrailer->auth_pad_length = 0;
        SecurityTrailer->auth_reserved = 0;
        // we used to pass a pointer to the connection, which is information
        // disclosure. If we ever get to the point of supporting more than
        // one security context per connection for this wire protocol, we should
        // use a dictionary index to indicate the security context for a given
        // connection. As long as pass non-zero here, we're fine.
        SecurityTrailer->auth_context_id = SecurityContextIdWireRep;

        //
        // Ok, finally, we need to adjust the length of the packet,
        // and set the length of the authentication information.
        //

        BindPacket->common.auth_length = (unsigned short) SecurityTokenLength;
        BindPacketLength = BindPacketLength
                - ClientSecurityContext.Credentials->MaximumTokenLength()
                + SecurityTokenLength;
        BindPacket->common.frag_length = (unsigned short) BindPacketLength;

        if ( CompleteNeeded != 0 )
            {
            Status = ClientSecurityContext.CompleteSecurityToken(
                    &BufferDescriptor);
            if (Status != 0)
                {
                TransFreeBuffer(BindPacket);
                return(Status);
                }
            }
        }

    ASSERT(BindPacket->common.frag_length <= MAX_SUPPORTED_FRAG_LENGTH);

    if (fAsync)
        {
        Status = TransAsyncSend(BindingHandle,
                                BindPacket,
                                BindPacketLength,
                                u.ConnSendContext);
        }
    else if (BindPacket->common.PTYPE == rpc_auth_3)
        {
        Status = TransSend(BindingHandle,
                           BindPacket,
                           BindPacketLength,
                           TRUE,    // fDisableShutdownCheck
                           FALSE,   // fDisableCancelCheck
                           Timeout
                           );
        //
        // Null out the reply buffer, because there is none !
        //
        *Buffer = NULL;
        }
    else
        {
        Status = TransSendReceive(BindingHandle,
                                  BindPacket,
                                  BindPacketLength,
                                  (void * *) Buffer,
                                  BufferLength,
                                  Timeout);
        }

    if ( Status != RPC_S_OK )
        {
        VALIDATE(Status)
            {
            RPC_S_OUT_OF_MEMORY,
            RPC_S_ACCESS_DENIED,
            RPC_S_OUT_OF_RESOURCES,
            RPC_P_CONNECTION_CLOSED,
            RPC_P_RECEIVE_FAILED,
            RPC_P_SEND_FAILED,
            RPC_P_CONNECTION_SHUTDOWN,
            RPC_S_CALL_CANCELLED,
            RPC_P_TIMEOUT
            }
        CORRUPTION_VALIDATE
            {
            RPC_S_PROTOCOL_ERROR
            } CORRUPTION_END_VALIDATE;

        TransFreeBuffer(BindPacket);
        if ((Status == RPC_P_RECEIVE_FAILED)
            || (Status == RPC_P_SEND_FAILED))
            {
            return(RPC_P_CONNECTION_CLOSED);
            }

        return(Status);
        }
    else
        {
        ClearFreshFromCacheFlag();
        if (fAsync == 0)
            {
            switch (BindPacket->common.PTYPE)
                {
                case rpc_auth_3:
                    // don't have a new packet
                    break;

                case rpc_fault:
                    Status = ValidatePacket(*Buffer, *BufferLength);
                    if (Status == RPC_S_OK)
                        {
                        Status = ((rpcconn_fault *) *Buffer)->status;
                        }
                    break;

                default:
                    Status = ValidateHeader(*Buffer, *BufferLength);
                }

            TransFreeBuffer(BindPacket);
            }
        }

    return Status;
}


void
OSF_CCONNECTION::SetMaxFrag (
    IN unsigned short max_xmit_frag,
    IN unsigned short max_recv_frag
    )
{
    UNUSED(max_recv_frag);

    unsigned TranMax = TransMaximumSend();

    MaxFrag = max_xmit_frag;

    if (MaxFrag > TranMax || MaxFrag == 0)
        {
        MaxFrag = (unsigned short) TranMax;
        }

    CORRUPTION_ASSERT( MaxFrag >= MUST_RECV_FRAG_SIZE );
}


RPC_STATUS
OSF_CCONNECTION::SendFragment(
    IN rpcconn_common  *pFragment,
    IN OSF_CCALL *CCall,
    IN UINT LastFragmentFlag,
    IN UINT HeaderSize,
    IN UINT MaxSecuritySize,
    IN UINT DataLength,
    IN UINT MaxFragmentLength,
    IN unsigned char  *ReservedForSecurity,
    IN BOOL fAsync,
    IN void *SendContext,
    IN ULONG Timeout,
    OUT void **ReceiveBuffer,
    OUT UINT *ReceiveBufferLength
    )
/*++
    Routine Description:

    Sends on fragment
--*/

{
    sec_trailer  * SecurityTrailer;
    UINT SecurityLength;
    UINT AuthPadLength;
    SECURITY_BUFFER_DESCRIPTOR BufferDescriptor;
    SECURITY_BUFFER SecurityBuffers[5];
    DCE_MSG_SECURITY_INFO MsgSecurityInfo;
    RPC_STATUS Status;
    ULONG ReadOnlyFlag;
    long AuthLengthChange;

    if (ClientSecurityContext.AuthenticationLevel == RPC_C_AUTHN_LEVEL_NONE
        || (ClientSecurityContext.AuthenticationLevel == RPC_C_AUTHN_LEVEL_CONNECT
            && MaxSecuritySize == 0))
        {
        SecurityLength = 0;
        if (LastFragmentFlag != 0)
            {
            pFragment->pfc_flags |= PFC_LAST_FRAG;
            }
        }
    else
        {
        VALIDATE(ClientSecurityContext.AuthenticationLevel)
            {
            RPC_C_AUTHN_LEVEL_PKT_INTEGRITY,
            RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
            RPC_C_AUTHN_LEVEL_PKT,
            RPC_C_AUTHN_LEVEL_CONNECT
            } END_VALIDATE;

        if (GetConnectionSupportHeaderSign() == cshsYes)
            ReadOnlyFlag = SECBUFFER_READONLY_WITH_CHECKSUM;
        else
            ReadOnlyFlag = SECBUFFER_READONLY;

        if ( LastFragmentFlag == 0 )
            {
            SecurityTrailer = (sec_trailer  *)
                (((unsigned char  *) pFragment)
                + MaxFragmentLength - MaxSecuritySize);

            //
            // It is not the last fragment, so we need to save away the
            // part of the buffer which could get overwritten with
            // authentication information.  We can not use memcpy,
            // because the source and destination regions may overlap.
            //
            RpcpMemoryMove(ReservedForSecurity,
                       SecurityTrailer,
                       MaxSecuritySize);
            AuthPadLength = 0;
            }
        else
            {
            ASSERT( MAXIMUM_SECURITY_BLOCK_SIZE == 16 );
            AuthPadLength = Pad16(HeaderSize+DataLength+sizeof(sec_trailer));
            // Zero-out un-initialized pad.
            if (AuthPadLength != 0)
                {
                RpcpMemorySet(((unsigned char  *) pFragment) + HeaderSize + DataLength, 0, AuthPadLength);
                }
            DataLength += AuthPadLength;
            ASSERT( ((HeaderSize+DataLength+sizeof(sec_trailer))
                        % MAXIMUM_SECURITY_BLOCK_SIZE) == 0 );
            SecurityTrailer = (sec_trailer  *)
                (((unsigned char  *) pFragment)
                + DataLength + HeaderSize);

            pFragment->pfc_flags |= PFC_LAST_FRAG;
            }

        SecurityTrailer->auth_type = (unsigned char) WireAuthId;
        SecurityTrailer->auth_level = (unsigned char) ClientSecurityContext.AuthenticationLevel;
        SecurityTrailer->auth_pad_length = (unsigned char) AuthPadLength;
        SecurityTrailer->auth_reserved = 0;
        SecurityTrailer->auth_context_id = SecurityContextIdWireRep;

        BufferDescriptor.ulVersion = 0;
        BufferDescriptor.cBuffers = 5;
        BufferDescriptor.pBuffers = SecurityBuffers;

        SecurityBuffers[0].cbBuffer = HeaderSize;
        SecurityBuffers[0].BufferType = SECBUFFER_DATA | ReadOnlyFlag;
        SecurityBuffers[0].pvBuffer = ((unsigned char  *) pFragment);

        SecurityBuffers[1].cbBuffer = (LastFragmentFlag != 0 ?
             (DataLength)
            : (MaxFragmentLength - HeaderSize - MaxSecuritySize)
            );
        SecurityBuffers[1].BufferType = SECBUFFER_DATA;
        SecurityBuffers[1].pvBuffer = ((unsigned char  *) pFragment)
            + HeaderSize;

        SecurityBuffers[2].BufferType = SECBUFFER_DATA | ReadOnlyFlag;
        SecurityBuffers[2].cbBuffer = sizeof(sec_trailer);
        SecurityBuffers[2].pvBuffer = SecurityTrailer;

        SecurityBuffers[3].cbBuffer = MaxSecuritySize - sizeof(sec_trailer);
        SecurityBuffers[3].BufferType = SECBUFFER_TOKEN;
        SecurityBuffers[3].pvBuffer = SecurityTrailer + 1;

        SecurityBuffers[4].cbBuffer = sizeof(DCE_MSG_SECURITY_INFO);
        SecurityBuffers[4].BufferType = (SECBUFFER_PKG_PARAMS
            | SECBUFFER_READONLY);
        SecurityBuffers[4].pvBuffer = &MsgSecurityInfo;

        MsgSecurityInfo.SendSequenceNumber =
            DceSecurityInfo.SendSequenceNumber;
        MsgSecurityInfo.ReceiveSequenceNumber =
            InquireReceiveSequenceNumber();
        MsgSecurityInfo.PacketType = pFragment->PTYPE;

        //
        // DCE computes check sums for Header also
        // Make sure Header remains intact
        // Infact may need to extend security interface if
        // some packages return dynamic size seals/signatures
        //

        pFragment->auth_length = SecurityLength = (unsigned short)
                                         SecurityBuffers[3].cbBuffer;

        SecurityLength += sizeof(sec_trailer);
        if ( LastFragmentFlag != 0)
            {
            pFragment->pfc_flags |= PFC_LAST_FRAG;
            pFragment->frag_length = HeaderSize + DataLength
                + SecurityLength;
            }
        else
            {
            pFragment->frag_length += SecurityLength - MaxSecuritySize;
            }

        Status = ClientSecurityContext.SignOrSeal(
                                    MsgSecurityInfo.SendSequenceNumber,
                                    ClientSecurityContext.AuthenticationLevel
                                    != RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                    &BufferDescriptor);

        //
        // The fragment may have been checksumed. Do not touch the signed portions 
        // of the fragment after this (including the header), if you do it will 
        // cause a checksum error
        //

        AuthLengthChange = pFragment->auth_length - SecurityBuffers[3].cbBuffer;
        ASSERT( AuthLengthChange >= 0);

        // if the token ended up shorter than the buffer we supplied,
        // sanitize the rest of the token buffer to avoid leaking
        // process data on the wire.
        if (AuthLengthChange > 0)
            {
            RpcpMemorySet(((unsigned char *)(SecurityBuffers[3].pvBuffer)) + SecurityBuffers[3].cbBuffer,
                0,
                AuthLengthChange
                );
            }

        if (Status != RPC_S_OK)
            {
            if ( LastFragmentFlag == 0 )
                {
                RpcpMemoryCopy(SecurityTrailer,
                             ReservedForSecurity,
                             MaxSecuritySize);
                }
            if (Status == ERROR_SHUTDOWN_IN_PROGRESS)
                {
                return Status;
                }

            if ((Status == SEC_E_CONTEXT_EXPIRED)
                || (Status == SEC_E_QOP_NOT_SUPPORTED))
                {
                return (RPC_S_SEC_PKG_ERROR);
                }
            return (RPC_S_ACCESS_DENIED);
            }
        }

    ASSERT(pFragment->frag_length <= MaxFrag);

    if (LastFragmentFlag != 0)
        {
        ASSERT(!RpcpCheckHeap());

        if (fAsync)
            {
            Status = TransAsyncSend(CCall->BindingHandle,
                                    pFragment,
                                    pFragment->frag_length,
                                    SendContext);
            }
        else
            {
            if (ReceiveBuffer)
                {
                Status = TransSendReceive(CCall->BindingHandle,
                                          pFragment,
                                          pFragment->frag_length,
                                          ReceiveBuffer,
                                          ReceiveBufferLength,
                                          Timeout);
                }
            else
                {
                Status = TransSend(CCall->BindingHandle,
                                   pFragment,
                                   pFragment->frag_length,
                                   FALSE,   // fDisableShutdownCheck
                                   FALSE,   // fDisableCancelCheck
                                   Timeout);
                }
            }

        if (Status != RPC_S_OK)
            {
            if ((Status == RPC_P_CONNECTION_CLOSED)
                || (Status == RPC_P_SEND_FAILED))
                {
                RpcpErrorAddRecord(EEInfoGCRuntime,
                    RPC_S_CALL_FAILED_DNE,
                    EEInfoDLOSF_CCONNECTION__SendFragment10,
                    (ULONG)Status);
 
                return(RPC_S_CALL_FAILED_DNE);
                }
            if (Status == RPC_P_RECEIVE_FAILED)
                {
                RpcpErrorAddRecord(EEInfoGCRuntime,
                    RPC_S_CALL_FAILED,
                    EEInfoDLOSF_CCONNECTION__SendFragment10,
                    (ULONG)Status);
 
                return(RPC_S_CALL_FAILED);
                }
            if (Status == RPC_P_TIMEOUT)
                {
                RpcpErrorAddRecord(EEInfoGCRuntime,
                    RPC_S_CALL_CANCELLED,
                    EEInfoDLOSF_CCONNECTION__SendFragment10,
                    (ULONG)Status,
                    (ULONG)Timeout);

                return(RPC_S_CALL_CANCELLED);
                }

            VALIDATE(Status)
                {
                RPC_S_OUT_OF_MEMORY,
                RPC_S_OUT_OF_RESOURCES,
                RPC_P_CONNECTION_SHUTDOWN,
                RPC_S_CALL_CANCELLED
                } 
            CORRUPTION_VALIDATE
                {
                RPC_S_PROTOCOL_ERROR
                } CORRUPTION_END_VALIDATE;

            return(Status);
            }

        ClearFreshFromCacheFlag();
        return(RPC_S_OK);
        }

    if (fAsync)
        {
        Status = TransAsyncSend(CCall->BindingHandle,
                                pFragment,
                                pFragment->frag_length,
                                CCall->CallSendContext);
        }
    else
        {
        Status = TransSend(CCall->BindingHandle,
                           pFragment,
                           pFragment->frag_length,
                           FALSE,   // fDisableShutdownCheck
                           FALSE,   // fDisableCancelCheck
                           Timeout);

        //
        // We need to restore the part of the buffer which we overwrote
        // with authentication information.
        //
        if ((ClientSecurityContext.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE)
            && (ClientSecurityContext.AuthenticationLevel != RPC_C_AUTHN_LEVEL_CONNECT
                || (MaxSecuritySize != 0)))
            {
            //
            // if MaxSecuritySize == 0, there will be no copying,
            // so its OK to not check for it.
            //
            VALIDATE(ClientSecurityContext.AuthenticationLevel)
                {
                RPC_C_AUTHN_LEVEL_PKT_INTEGRITY,
                RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                RPC_C_AUTHN_LEVEL_PKT,
                RPC_C_AUTHN_LEVEL_CONNECT
                } END_VALIDATE;

            RpcpMemoryCopy(SecurityTrailer, ReservedForSecurity,
                           MaxSecuritySize);
            }

        if (ReceiveBuffer
            && Status == RPC_P_RECEIVE_COMPLETE)
            {
            // we're going to do a receive - whack any eeinfo
            // on the thread that the WS_CheckForShutdowns has
            // added
            RpcpPurgeEEInfo();

            Status = TransReceive(ReceiveBuffer, 
                ReceiveBufferLength,
                Timeout);
            }
        }

    if ( Status != RPC_S_OK )
        {
        if ((Status == RPC_P_CONNECTION_CLOSED)
            || (Status == RPC_P_SEND_FAILED))
            {
            RpcpErrorAddRecord(EEInfoGCRuntime,
                RPC_S_CALL_FAILED_DNE,
                EEInfoDLOSF_CCONNECTION__SendFragment20,
                (ULONG)Status);

            return(RPC_S_CALL_FAILED_DNE);
            }

        if (Status == RPC_P_TIMEOUT)
            {
            RpcpErrorAddRecord(EEInfoGCRuntime,
                RPC_S_CALL_CANCELLED,
                EEInfoDLOSF_CCONNECTION__SendFragment20,
                (ULONG)Status,
                (ULONG)Timeout);
            return RPC_S_CALL_CANCELLED;
            }

        VALIDATE(Status)
            {
            RPC_S_OUT_OF_MEMORY,
            RPC_S_OUT_OF_RESOURCES,
            RPC_P_CONNECTION_SHUTDOWN,
            RPC_S_CALL_CANCELLED,
            RPC_P_RECEIVE_FAILED  
            } 
        CORRUPTION_VALIDATE
            {
            RPC_S_PROTOCOL_ERROR
            } CORRUPTION_END_VALIDATE;

        return(Status);
        }

    ClearFreshFromCacheFlag();
    return Status;
}



RPC_STATUS
OSF_CCONNECTION::SupportedAuthInfo (
    IN CLIENT_AUTH_INFO * ClientAuthInfo,
    IN NamedPipeType NPType,
    IN BOOL IsExclusiveConnection,
    OUT BOOL *Supported
    )
/*++

Arguments:

    ClientAuthInfo - Supplies the authentication and authorization information
        required of this connection.  A value of zero (the pointer is
        zero) indicates that we want an unauthenticated connection.

    NPType - the type of transport w.r.t. to named pipes. See the definition
        of NamedPipeType for description of the bitmasks

    IsExclusiveConnection - if NPType is not named pipe, this parameter is ignored.
        Otherwise non-zero means the connection is exclusive. Zero means the
        connection is non-exclusive.

    Supported - on output, non-zero if the auth info is supported, zero otherwise.
        Undefined on failure.

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    return (ClientSecurityContext.IsSupportedAuthInfo(ClientAuthInfo, NPType, IsExclusiveConnection, Supported));
}


RPC_STATUS
OSF_CCONNECTION::AddActiveCall (
    IN ULONG CallId,
    IN OSF_CCALL *CCall
    )
/*++
Function Name:AddActiveCall

Parameters:

Description:

Returns:

--*/
{
    int retval;

    ConnMutex.Request();
    if (State == ConnAborted)
        {
        ConnMutex.Clear();
        return RPC_S_CALL_FAILED;
        }

    retval = ActiveCalls.Insert(IntToPtr(CallId), CCall);
    ConnMutex.Clear();

    if (retval == -1)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    return RPC_S_OK;
}


RPC_STATUS
OSF_CCONNECTION::CallCancelled (
    OUT PDWORD Timeout
    )
/*++
Function Name:CallCancelled

Parameters:

Description:
    This function is called by the transport interface when it notices that it has
    received an altert. This routine is called via I_RpcIOAlerted

Returns:

--*/
{
    if (fExclusive == 0 || CurrentCall == 0)
        {
        return RPC_S_NO_CALL_ACTIVE;
        }
    ASSERT(fExclusive && CurrentCall);

    //
    // Even if we get alerted in the bind path, we already have a call object.
    // That makes it easy for us to track cancels
    //

    return CurrentCall->CallCancelled(Timeout);
}

MTSyntaxBinding *CreateOsfBinding(
        IN RPC_SYNTAX_IDENTIFIER *InterfaceId,
        IN TRANSFER_SYNTAX_STUB_INFO *TransferSyntaxInfo,
        IN int CapabilitiesBitmap
        )
{
    return new OSF_BINDING(InterfaceId, 
        TransferSyntaxInfo, 
        CapabilitiesBitmap);
}

BOOL CheckOsfBindingForDestruction(
        IN MTSyntaxBinding *Binding,
        IN void *CallbackContext
        )
{
    OSF_CASSOCIATION *Association;
    OSF_BINDING *OsfBinding;

    OsfBinding = (OSF_BINDING *)Binding;
    // is this binding ready for cleanup
    if (OsfBinding->IsRefCountZero())
        {
        Association = (OSF_CASSOCIATION *)CallbackContext;
        Association->DestroyBinding(OsfBinding);
        return TRUE;
        }
    else
        return FALSE;
}

extern "C" RPC_IF_HANDLE _mgmt_ClientIfHandle;


OSF_CCALL::OSF_CCALL (
    RPC_STATUS __RPC_FAR * pStatus
    ) : CallMutex(pStatus),
      SyncEvent(pStatus, 0),
      fAdvanceCallCount(0)
{
    LogEvent(SU_CCALL, EV_CREATE, this);

    ObjectType = OSF_CCALL_TYPE;
    ReservedForSecurity = 0;
    SecBufferLength = 0;
    SavedHeaderSize = 0;
    SavedHeader = 0;
    InReply = 0;
    EEInfo = NULL;
    CachedAPCInfoAvailable = 1;
    CallbackLevel = 0;

    CallSendContext = (char *) this+sizeof(OSF_CCALL)+sizeof(PVOID);
    *((PVOID *) ((char *) CallSendContext - sizeof(PVOID))) = (PVOID) this;
}


OSF_CCALL::~OSF_CCALL (
    )
{
    LogEvent(SU_CCALL, EV_DELETE, this);

    if (CachedAPCInfoAvailable == 0)
        {
        ASSERT(!"Can't destroy call with queued APCs on it");
        }

    if (ReservedForSecurity)
        {
        RpcpFarFree(ReservedForSecurity);
        }

    if (SavedHeader)
        {
        RpcpFarFree(SavedHeader);
        }

    Connection->NotifyCallDeleted();
}

RPC_STATUS OSF_CCALL::ReserveSpaceForSecurityIfNecessary (void)
{
    SECURITY_CONTEXT *ClientSecurityContext ;

    ClientSecurityContext = &(Connection->ClientSecurityContext);
    //
    // We need to figure out about security: do we need to put authentication
    // information into each packet, and if so, how much space should we
    // reserve. So that we have space to save the contents of the buffer
    // which will be overwritten with authentication information (for all but
    // the last fragment).
    //
    if (ClientSecurityContext->AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE)
        {
        VALIDATE(ClientSecurityContext->AuthenticationLevel)
            {
            RPC_C_AUTHN_LEVEL_PKT_INTEGRITY,
            RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
            RPC_C_AUTHN_LEVEL_CONNECT,
            RPC_C_AUTHN_LEVEL_PKT
            } END_VALIDATE;

        MaxSecuritySize = Connection->AdditionalSpaceForSecurity
                - MAXIMUM_SECURITY_BLOCK_SIZE;

        if (MaxSecuritySize < sizeof(sec_trailer))
            {
            ASSERT(MaxSecuritySize >= sizeof(sec_trailer));
            return(RPC_S_INTERNAL_ERROR);
            }

        if (MaxSecuritySize == sizeof(sec_trailer))
            {
            if (ClientSecurityContext->AuthenticationLevel
                != RPC_C_AUTHN_LEVEL_CONNECT)
                {
                ASSERT(0);
                return(RPC_S_INTERNAL_ERROR);
                }

            MaxSecuritySize = 0;
            }
        else
            {
            if (SecBufferLength < Connection->AdditionalSpaceForSecurity)
                {
                if (ReservedForSecurity)
                    {
                    RpcpFarFree(ReservedForSecurity);
                    }

                ReservedForSecurity = (unsigned char *)
                    RpcpFarAllocate(Connection->AdditionalSpaceForSecurity);
                if (ReservedForSecurity == 0)
                    {
                    SecBufferLength = 0;
                    return RPC_S_OUT_OF_MEMORY;
                    }
                SecBufferLength = Connection->AdditionalSpaceForSecurity;
                }

            }

        SetMaxSecuritySizeUpdatedFlag();
        }

    // if the header size has already been determined, update the frag length
    // if not, we'll let the GetBuffer thread do it. Also, there is a small
    // race condition where we may update it twice, but since this is perf
    // only, we don't care - in the common case the gains are huge when we
    // don't have to update
    if (HeaderSize != 0)
        UpdateMaxFragLength(ClientSecurityContext->AuthenticationLevel);
    fDataLengthNegotiated = TRUE;

    return RPC_S_OK;
}


void OSF_CCALL::UpdateObjectUUIDInfo (IN UUID *ObjectUuid)
{
    UUID *ObjectUuidToUse;
    ULONG AuthnLevel;

    //
    // Do the initial setup
    //
    if (ObjectUuid)
        {
        ObjectUuidToUse = ObjectUuid;
        }
    else if (BindingHandle->InqIfNullObjectUuid() == 0)
        {
        ObjectUuidToUse = BindingHandle->InqPointerAtObjectUuid();
        }
    else
        {
        ObjectUuidToUse = 0;
        UuidSpecified = 0;
        HeaderSize = sizeof(rpcconn_request);
        }

    if (ObjectUuidToUse)
        {
        UuidSpecified = 1;
        HeaderSize = sizeof(rpcconn_request) + sizeof(UUID);
        RpcpMemoryCopy(&this->ObjectUuid, ObjectUuidToUse, sizeof(UUID));
        }

    AuthnLevel = Connection->ClientSecurityContext.AuthenticationLevel;
    // recalc if either there is no security size or if it is ready (i.e. updated)
    if (GetMaxSecuritySizeUpdatedFlag() || (AuthnLevel == RPC_C_AUTHN_LEVEL_NONE))
        {
        UpdateMaxFragLength(AuthnLevel);
        }
}

void OSF_CCALL::UpdateMaxFragLength (ULONG AuthnLevel)
{
    BOOL fExclusive = Connection->fExclusive;

    // if the connection is exclusive, this all happens on the same thread -
    // no need for a mutex
    if (!fExclusive)
        CallMutex.Request();

    MaximumFragmentLength = Connection->MaxFrag;

    if (AuthnLevel != RPC_C_AUTHN_LEVEL_NONE)
        {
        MaximumFragmentLength -= ((MaximumFragmentLength
                                  - HeaderSize - MaxSecuritySize)
                                  % MAXIMUM_SECURITY_BLOCK_SIZE);
        }

    MaxDataLength = MaximumFragmentLength
        - HeaderSize - MaxSecuritySize;

    if (!fExclusive)
        CallMutex.Clear();
}


BOOL
OSF_CCALL::IssueNotification (
    IN RPC_ASYNC_EVENT Event
    )
{
    BOOL fRes;
    RPC_STATUS Status;

    if (pAsync == 0)
        {
        if (Connection->fExclusive == 0)
            {
            SyncEvent.Raise();
            }

        return 0;
        }

    // we must have bailed out by now if this is sync
    ASSERT (pAsync);

    fRes = CCALL::IssueNotificationEntry(Event);

    if (!fRes)
        return 0;

    if (AsyncStatus == RPC_S_OK)
        {
        RPC_SECURITY_CALLBACK_FN *SecurityCallback = NULL;

        Status = BindingHandle->InqTransportOption(
                                                   RPC_C_OPT_SECURITY_CALLBACK,
                                                   (ULONG_PTR *) &SecurityCallback);
        ASSERT(Status == RPC_S_OK);

        if (SecurityCallback)
            {
            (*SecurityCallback) (this);
            }
        }

    return CCALL::IssueNotificationMain(Event);
}

const int MAX_ASYNC_RETRIES = 3;


RPC_STATUS
OSF_CCALL::BindToServer (
    BOOL fAsyncBind
    )
/*++
Function Name:BindToServer

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    OSF_BINDING_HANDLE *pLocalBindingHandle = BindingHandle;
    OSF_CCONNECTION *pLocalConnection;
    ULONG Timeout;
    BOOL fBindingHandleTimeoutUsed = TRUE;
    BOOL fAlwaysNegotiateNDR20 = FALSE;
    OSF_BINDING *IgnoredBinding;
    ULONG LocalAssociationGroupId;
    BOOL Ignored;
    FAILURE_COUNT_STATE fFailureCountExceeded = FailureCountUnknown;
    int AsyncRetries = 0;

    if (EEInfo)
        {
        FreeEEInfoChain(EEInfo);
        EEInfo = NULL;
        }

    if (fAsyncBind == FALSE)
        {
        //
        // We party on the call even after the connection is aborted.
        // We need to keep a reference on the call
        // CCALL++
        // We do this only in the sync case, as in the async,
        // the reference has already been added for us by the caller
        //
        AddReference();
        }
    else
        {
        ASSERT(Connection->fExclusive == FALSE);

        // if this is a new, non-exclusive conn
        if (pLocalBindingHandle && (CurrentState == NeedOpenAndBind))
            {

            // if we have had no preferences at the time of
            // establishment (which is signified by the fact that both
            // SelectedBinding and AvalableBindingsList is set)
            if (Bindings.SelectedBinding && Bindings.AvailableBindingsList)
                {
                fAlwaysNegotiateNDR20 = TRUE;
                }
            }
        }

    Connection->CurrentCall = this;

    if (pLocalBindingHandle)
        {

        Timeout = GetEffectiveTimeoutForBind(pLocalBindingHandle, &fBindingHandleTimeoutUsed);

        do
            {
            switch (CurrentState)
                {
                case NeedOpenAndBind:
                    Status = Connection->OpenConnectionAndBind(
                        pLocalBindingHandle,
                        Timeout,
                        fAlwaysNegotiateNDR20,
                        &fFailureCountExceeded);
                    break;

                case NeedAlterContext:
                    if (Connection->fExclusive)
                        {
                        LocalAssociationGroupId = Connection->Association->AssocGroupId;
                        if (LocalAssociationGroupId)
                            {
                            Status = Connection->ActuallyDoBinding(
                                       this,
                                       Connection->Association->AssocGroupId,
                                       0,
                                       Timeout,
                                       &IgnoredBinding,
                                       &Ignored,     // fPossibleAssociationReset
                                       NULL          // fFailureCountExceeded
                                       );
                            if (Status == RPC_S_OK)
                                {
                                CurrentState = SendingFirstBuffer;
                                }
                            }
                        else
                            Status = RPC_S_CALL_FAILED_DNE;
                        }
                    else
                        {
                        Status = SendAlterContextPDU();
                        }
                    break;

                default:
#if DBG
                    PrintToDebugger("RPC: BindToServer was a nop, CurrentState: %d\n",
                                    CurrentState);
#endif
                    Status = RPC_S_OK;
                    break;
                }

            if (fAsyncBind)
                {
                ASSERT(fFailureCountExceeded != FailureCountNotExceeded);

                // if this is a bind_nak with reason not specified, and retry
                // attempts exhausted, shutdown the association, but without this
                // connection, and then retry the OpenConnectionAndBind
                if (
                    (fFailureCountExceeded == FailureCountExceeded)
                    &&
                    (CurrentState == NeedOpenAndBind)
                   )
                    {
                    Connection->Association->ShutdownRequested(RPC_S_OK, Connection);

                    // do some cleanup work on the current connection to avoid
                    // leaks.
                    Connection->TransClose();

                    Connection->InitializeWireAuthId(&Connection->ClientSecurityContext);

                    if (Connection->ClientSecurityContext.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE)
                        {
                        // DeleteSecurityContext checks and deletes 
                        // the security context only if necessary
                        Connection->ClientSecurityContext.DeleteSecurityContext();
                        }

                    fFailureCountExceeded = FailureCountUnknown;
                    AsyncRetries ++;

                    // retry the bind
                    continue;
                    }

                pLocalBindingHandle->BindingFree();
                }

            // all paths except those with explicit continue exit the loop
            break;
            }
        while (AsyncRetries <= MAX_ASYNC_RETRIES);

        }
    else
        Status = RPC_S_CALL_FAILED_DNE;

    // save the data member in a local variable
    pLocalConnection = Connection;
    if (Status != RPC_S_OK)
        {
        if (pLocalBindingHandle)
            {
            Status = GetStatusForTimeout(
                pLocalBindingHandle,
                Status,
                fBindingHandleTimeoutUsed);
            }

        if (Connection->fExclusive == 0)
            {
            if (Status == RPC_P_CONNECTION_CLOSED
                || Status == RPC_P_CONNECTION_SHUTDOWN
                || Status == RPC_P_SEND_FAILED)
                {
                Status = RPC_S_CALL_FAILED_DNE;
                }

            Connection->ConnectionAborted(Status, 0);

            //
            // Remove the send reference for this call, CCALL--
            //
            RemoveReference();
            }
        }

    //
    // Remove the reference we added above
    // CCALL--
    //
    RemoveReference();

    if (fAsyncBind)
        pLocalConnection->RemoveReference();

    return Status;
}



RPC_STATUS
OSF_CCALL::ActuallyAllocateBuffer (
    OUT void  *  * Buffer,
    IN UINT BufferLength
    )
/*++

Routine Description:

    We need a buffer to receive data into or to put data into to be sent.
    This should be really simple, but we need to make sure that buffer we
    return is aligned on an 8 byte boundary.  The stubs make this requirement.

Arguments:

    Buffer - Returns a pointer to the buffer.

    BufferLength - Supplies the required length of the buffer in bytes.

Return Value:

    RPC_S_OK - We successfully allocated a buffer of at least the required
        size.

    RPC_S_OUT_OF_MEMORY - There is insufficient memory available to allocate
        the required buffer.

--*/
{
    return Connection->TransGetBuffer(Buffer, BufferLength);
}


void
OSF_CCALL::ActuallyFreeBuffer (
    IN void  * Buffer
    )
/*++

Routine Description:

    We need to free a buffer which was allocated via TransGetBuffer.  The
    only tricky part is remembering to remove the padding before actually
    freeing the memory.

--*/
{
    Connection->TransFreeBuffer(Buffer);
}


RPC_STATUS
OSF_CCALL::ActivateCall (
    IN OSF_BINDING_HANDLE *BindingHandle,
    IN OSF_BINDING *Binding,
    IN OSF_BINDING *AvailableBindingsList,
    IN ULONG CallIdToUse,
    IN OSF_CCALL_STATE InitialCallState,
    IN PRPC_DISPATCH_TABLE DispatchTable,
    IN OSF_CCONNECTION *CConnection
    )
/*++
Function Name:ActivateCall

Parameters:

    BindingHandle - the binding handle on which the call is made

    Binding - the OSF_BINDING to use for this call. Carries a refcount
        if AvailableBindingList is NULL.

    AvailableBindingsList - the list of available bindings for this call.
        If the binding is already selected, it will be NULL. If not, each
        element from the list carries a refcount.

    CallIdToUse - what call id to use.

    InitialCallState - the initial state of this call

    DispatchTable - the dispatch table to use for this call. Used only for callbacks

    CConnection - the connection on which the call will be made.

Returns:

Remarks:
    In the case of failure, the binding(s) should be released by the caller.

--*/
{
    RPC_STATUS Status = RPC_S_OK;

    ASSERT(BufferQueue.IsQueueEmpty());
    MaxSecuritySize = 0;
    MaxDataLength = 0;
    Connection = CConnection;
    this->BindingHandle = BindingHandle;
    CurrentBuffer = 0;
    CurrentOffset = 0;
    CurrentState = InitialCallState;
    CallStack = 0;
    RcvBufferLength = 0;
    pAsync = 0;
    NeededLength = 0;
    MaximumFragmentLength = 0;
    LastBuffer = NULL;
    RecursiveCallsKey = -1;
    fDataLengthNegotiated = FALSE;
    AllocHint = 0;
    Flags.ClearAll();

    if (Binding)
        {
        // we can have both binding and binding list only for non-sync
        // calls
        ASSERT((AvailableBindingsList == NULL) || (Connection->fExclusive == FALSE));
        }
    else
        {
        // if we don't have a binding, this must be a sync call.
        // Async calls must have their bindings fixed by now
        ASSERT(Connection->fExclusive);
        }

    Bindings.SelectedBinding = Binding;
    Bindings.AvailableBindingsList = AvailableBindingsList;

    this->DispatchTableCallback = DispatchTable;
    CallId = CallIdToUse;
    fCallCancelled = FALSE;
    CancelState = CANCEL_NOTREGISTERED;
    AdditionalSpaceForSecurity = Connection->AdditionalSpaceForSecurity;
    fPeerChoked = 0;
    HeaderSize = 0;

    if (Connection->fExclusive == 0)
        {
        //
        // 1. The first reference is removed when
        //    all the sends are complete. This is called the send reference
        //    CCALL++
        // 2. The second one is removed when the client is done with the call,
        //     ie: when freebuffer is called or when an operation fails. This is called
        //     the call reference. CCALL++
        //
        SetReferenceCount(2);

        fAdvanceCallCount.SetInteger(0);
        AsyncStatus = RPC_S_ASYNC_CALL_PENDING ;
        FirstSend = 1;
        NotificationIssued = -1;
        fChoked = 0;
        fLastSendComplete = 0;

        CallingThread = RpcpGetThreadPointer();
        ASSERT(CallingThread != 0);

        Status = Connection->AddActiveCall(
                                       CallIdToUse,
                                       this);
        }
    else
        {
        CallingThread = 0;
        }

    return Status;
}


RPC_STATUS
OSF_CCALL::SendHelper (
    IN PRPC_MESSAGE Message,
    OUT BOOL *fFirstSend
    )
/*++
Function Name:Send

Parameters:
    Message - Contains information about the request

Description:

Returns:

--*/
{
    void  *NewBuffer;
    int RemainingLength = 0;
    RPC_STATUS Status = RPC_S_OK;
    BOOL fRegisterFailed = 0;

    ASSERT(HeaderSize != 0);

    *fFirstSend = 0;

    if (PARTIAL(Message))
        {
        if (AllocHint == 0)
            AllocHint = Message->BufferLength;

        if (fDataLengthNegotiated == 0
            || Message->BufferLength < MaxDataLength)
            {
            if (pAsync && (pAsync->Flags & RPC_C_NOTIFY_ON_SEND_COMPLETE))
                {
                if (!IssueNotification(RpcSendComplete))
                    {
                    CallFailed(Status);

                    // this is async only. We don't need to unregister for cancels
                    return Status;
                    }
                }

            return (RPC_S_SEND_INCOMPLETE);
            }

        ASSERT(MaxDataLength);

        RemainingLength = Message->BufferLength % MaxDataLength;

        if (RemainingLength)
            {
            Status = GetBufferDo(RemainingLength, &NewBuffer);

            if (Status != RPC_S_OK)
                {
                CallFailed(Status);

                UnregisterCallForCancels();

                return Status;
                }

            Message->BufferLength -= RemainingLength;
            RpcpMemoryCopy(NewBuffer,
                           (char *) Message->Buffer + Message->BufferLength,
                           RemainingLength);
            }
        }
    else
        {
        ASSERT(LastBuffer == NULL);
        LastBuffer = Message->Buffer;
        AllocHint = Message->BufferLength;
        }

    //
    // Add a reference for this send, CCALL++
    //
    AddReference();

    //
    // You get to actually send only if you are the CurrentCall
    // and the connection is idle.
    //
Retry:
    if (AsyncStatus != RPC_S_ASYNC_CALL_PENDING)
        {
        Status = AsyncStatus;

        ASSERT(Status != RPC_S_OK);
        if (Status == RPC_S_CALL_FAILED_DNE)
            {
            Status = RPC_S_CALL_FAILED;
            }

        // N.B. The connection that does the bind will have
        // its send reference removed in case of failure, and
        // will be the current call. Therefore, we remove
        // the reference only if we aren't the current call
        if (Connection->CurrentCall != this)
            {
            //
            // We didn't get a chance to submit a new send
            // Remove the send reference CCALL--
            //
            OSF_CCALL::RemoveReference();
            }

        goto Cleanup;
        }

    CallMutex.Request();
    if (CurrentBuffer)
        {
        //
        // If the call had failed, we will find out after the we return
        // from this routine
        //
        if (pAsync == 0 && BufferQueue.Size() >= 4)
            {
            fChoked = 1;
            CallMutex.Clear();

            SyncEvent.Wait();
            goto Retry;
            }

        //
        // Since CurrentBuffer != 0, the connection could not have been
        // in a quiscent state. Therefore, we don't need to tickle it. This
        // also means that the call is currently in the call queue of the connection.
        // So, we don't need to add ourselves to the call queue.
        //
        if (BufferQueue.PutOnQueue(Message->Buffer, Message->BufferLength))
            {
            Status = RPC_S_OUT_OF_MEMORY;
            if (Connection->CurrentCall != this)
                {
                //
                // We didn't get a chance to submit a new send
                // Remove the send reference CCALL--
                //
                OSF_CCALL::RemoveReference();
                }
            }
        CallMutex.Clear();
        }
    else
        {
        CurrentOffset = 0;
        CurrentBuffer = Message->Buffer;
        CurrentBufferLength = Message->BufferLength;

        if (FirstSend)
            {
            FirstSend = 0;
            CallStack++;
            CallMutex.Clear();

            Status = RegisterCallForCancels();
            if (Status != RPC_S_OK)
                {
                fRegisterFailed = 1;

                if (Connection->CurrentCall != this)
                    {
                    //
                    // We didn't get a chance to submit a new send
                    // Remove the send reference CCALL--
                    //
                    OSF_CCALL::RemoveReference();
                    }

                goto Cleanup;
                }

            Status = Connection->AddCall(this);

            *fFirstSend = 1;

            if (Status != RPC_S_OK)
                {

                if (Connection->CurrentCall != this)
                    {
                    //
                    // We didn't get a chance to submit a new send
                    // Remove the send reference CCALL--
                    //
                    OSF_CCALL::RemoveReference();
                    }

                goto Cleanup;
                }
            }
        else
            {
            CallMutex.Clear();
            }

        //
        // The connection could be in a quiescent state
        // we need to tickle it
        //
        Connection->ConnMutex.Request();
        if (CurrentState == Complete)
            {
            Connection->ConnMutex.Clear();
            // Status should already be RPC_S_OK
            ASSERT(Status == RPC_S_OK);
            goto Cleanup;
            }
        if (Connection->CurrentCall == this
            && Connection->IsIdle())
            {
            Connection->MakeConnectionActive();
            if ((Connection->fExclusive == FALSE)
                && (BindingHandle->InqComTimeout() != RPC_C_BINDING_INFINITE_TIMEOUT))
                {
                // this is a best effort - ignore failure
                (void)Connection->TurnOnOffKeepAlives(TRUE,   // turn on
                    BindingHandle->InqComTimeout()
                    );
                }
            Connection->ConnMutex.Clear();

            Status = SendData(0);
            if (Status != RPC_S_OK)
                {
                //
                // We didn't get a chance to submit a new send
                // Remove the send reference CCALL--
                //
                OSF_CCALL::RemoveReference();
                }
            }
        else
            {
            Connection->ConnMutex.Clear();
            }
        }

Cleanup:

    if (Status)
        {
        ASSERT(Status != RPC_S_SEND_INCOMPLETE);

        if (RemainingLength)
            {
            //
            // NewBuffer should be initialized
            //
            FreeBufferDo(NewBuffer);
            }

        AsyncStatus = Status;
        if (!fRegisterFailed)
            {
            UnregisterCallForCancels();
            }
        }
    else
        {
        if (RemainingLength)
            {
            Message->Buffer = NewBuffer;
            Message->BufferLength = RemainingLength;
            ActualBufferLength = RemainingLength;

            Status = RPC_S_SEND_INCOMPLETE;
            }
        else
            {
            ActualBufferLength = 0;
            Message->Buffer = 0;
            Message->BufferLength = 0;
            }

        //
        // Call reference is removed in FreeBuffer
        //
        }

    //
    // Remove the reference for this send we added above, CCALL--
    //
    OSF_CCALL::RemoveReference();

    return Status;
}


RPC_STATUS
OSF_CCALL::Send (
    IN PRPC_MESSAGE Message
    )
{
    int i;
    BOOL fFirstSend;
    void *TempBuffer;
    RPC_STATUS Status;
    PRPC_ASYNC_STATE MypAsync = this->pAsync;
    OSF_BINDING_HANDLE *MyBindingHandle = this->BindingHandle;

    AddVerificationTrailer(Message);

    //
    // WARNING: Do not use any members of OSF_CCALL beyond this point.
    // the object could have been deleted.
    //
    for (i = 0;;i++)
        {
        Status = ((OSF_CCALL *) Message->Handle)->SendHelper(Message, &fFirstSend);

        if (Status == RPC_S_OK)
            {
            if (!PARTIAL(Message) && MypAsync)
                {
                //
                // Last send
                //
                ((OSF_CCALL *) Message->Handle)->CallMutex.Request();
                ASSERT(((OSF_CCALL *) Message->Handle)->fLastSendComplete == 0);

                if (((OSF_CCALL *) Message->Handle)->CurrentState == Aborted)
                    {
                    Status = ((OSF_CCALL *) Message->Handle)->GetCallStatus();

                    ((OSF_CCALL *) Message->Handle)->CallMutex.Clear();

                    //
                    // Remove the call reference, CCALL--
                    //
                    ((OSF_CCALL *) Message->Handle)->RemoveReference();

                    //
                    // No need to free the send buffer, it will be freed when the
                    // send is complete
                    //
                    }
                else
                    {
                    //
                    // For any future failures, a notification is issued
                    //
                    ((OSF_CCALL *) Message->Handle)->fLastSendComplete = 1;
                    ((OSF_CCALL *) Message->Handle)->CallMutex.Clear();
                    }
                }

            return Status;
            }

        if (Status != RPC_S_CALL_FAILED_DNE || i > 0 || fFirstSend == 0)
            {
            if (Status != RPC_S_SEND_INCOMPLETE)
                {
                ((OSF_CCALL *) Message->Handle)->FreeBufferDo(Message->Buffer);

                //
                // Remove the call reference, CCALL--
                //
                ((OSF_CCALL *) Message->Handle)->RemoveReference();
                }

            return Status;
            }


        Status = AutoRetryCall(Message,
                                FALSE, // not in SendReceive path
                                MyBindingHandle,
                                Status,
                                MypAsync);
        if (Status != RPC_S_OK)
            break;
        }

    return Status;
}

RPC_STATUS 
OSF_CCALL::AutoRetryCall (
    IN OUT RPC_MESSAGE *Message, 
    IN BOOL fSendReceivePath,
    IN OSF_BINDING_HANDLE *LocalBindingHandle, 
    IN RPC_STATUS CurrentStatus,
    IN RPC_ASYNC_STATE *AsyncState OPTIONAL
    )
/*++
Function Name:AutoRetryCall

Parameters:
    Message - Contains information about the request
    fSendReceivePath - TRUE if this is the send receive path, FALSE if it is the
        Send path. We need to differentiate, because we do the cleanup of the old
        call in slightly different ways
    LocalBindingHandle - a local copy of the binding handle that was used to
        make the original call
    AsyncState - a pointer to the async state of the original call (if any)

Description:

    Retries the current call. We first save the old buffer to a new buffer.

Returns:

--*/
{
    void *TempBuffer;
    RPC_STATUS Status;
    UUID MyUuid;
    UUID *UuidToUse;
    BOOL fUuidSpecified;
    OSF_CCALL *OldCall;
    RPC_SYNTAX_IDENTIFIER TransferSyntax;
    BOOL fInterfaceSupportsMultipleTransferSyntaxes;

    // any failure after this is unrelated
    RpcpPurgeEEInfo();

    OldCall = (OSF_CCALL *) Message->Handle;

    fInterfaceSupportsMultipleTransferSyntaxes =
        DoesInterfaceSupportMultipleTransferSyntaxes(Message->RpcInterfaceInformation);

    ASSERT(OldCall->HeaderSize != 0);
    fUuidSpecified = OldCall->UuidSpecified;

    if (fUuidSpecified)
        {
        RpcpMemoryCopy(&MyUuid,
                       &(OldCall->ObjectUuid), sizeof(UUID));
        }

    TempBuffer = RpcpFarAllocate(Message->BufferLength);
    if (TempBuffer != 0)
        RpcpMemoryCopy(TempBuffer, Message->Buffer, Message->BufferLength);

    // save the transfer syntax before we nuke the call
    if (fInterfaceSupportsMultipleTransferSyntaxes)
        RpcpMemoryCopy(&TransferSyntax, Message->TransferSyntax, sizeof(RPC_SYNTAX_IDENTIFIER));

    OldCall->CleanupOldCallOnAutoRetry(Message->Buffer, fSendReceivePath, CurrentStatus);

    if (TempBuffer == 0)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    Message->Handle = LocalBindingHandle;

    UuidToUse = fUuidSpecified ? &MyUuid : 0;

    Status = NegotiateTransferSyntaxAndGetBuffer(Message, &TransferSyntax, UuidToUse);

    if (Status != RPC_S_OK)
        {
        // the transfer syntax should not change in the async path for now - this
        // indicates application error, and it's better to ASSERT here in checked
        // builds, than leave the app writer bewildered on what has gone wrong if
        // we just spew the error code back
        if (!fSendReceivePath)
            {
            ASSERT(Status != RPC_P_TRANSFER_SYNTAX_CHANGED);
            }

        RpcpFarFree(TempBuffer);
        return Status;
        }

    if (AsyncState)
        {
        Status = I_RpcAsyncSetHandle(Message, AsyncState);
        if (Status != RPC_S_OK)
            {
            RpcpFarFree(TempBuffer);
            return Status;
            }
        }

    RpcpMemoryCopy(Message->Buffer, TempBuffer, Message->BufferLength);
    RpcpFarFree(TempBuffer);

    return RPC_S_OK;
}


RPC_STATUS
OSF_CCALL::AsyncSend (
    IN PRPC_MESSAGE Message
    )
/*++
Function Name:AsyncSend

Parameters:
    Message - Contains information about the request.

Description:
    This function is used in conjunction with Async RPC. This function may
    be used to send regular requests as well as pipe requests.

Returns:

--*/
{
    return Send(Message);
}


RPC_STATUS
OSF_CCALL::Receive (
    IN OUT PRPC_MESSAGE Message,
    IN UINT Size
    )
/*++
Function Name:Receive

Parameters:

Description:
    This function is used in conjunction with synchronous pipes. It is used to receive
    partial pipe data. If the RPC_BUFFER_EXTRA flag is set, the pipe data is
    appended to the end of the current buffer. If it is not set, the pipe data is copied
    from starting from the beginning of the buffer.

Returns:

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    unsigned long OldFlags = IsExtraMessage(Message);

    ASSERT(pAsync == 0);

    if (!EXTRA(Message) && Message->Buffer)
        {
        ActuallyFreeBuffer((char  *)Message->Buffer-sizeof(rpcconn_request));
        Message->Buffer = 0;
        }


    while (TRUE)
        {
        switch (CurrentState)
            {
            case Complete:
                Status = GetCoalescedBuffer(Message);
                break;

            case Aborted:
                ASSERT(AsyncStatus != RPC_S_OK);
                Status = AsyncStatus;
                break;

            default:
                if (RcvBufferLength >= Connection->MaxFrag)
                    {
                    Status = GetCoalescedBuffer(Message);
                    if (Status != RPC_S_OK)
                        {
                        break;
                        }

                    if (PARTIAL(Message) && Message->BufferLength >= Size)
                        {
                        break;
                        }

                    Message->RpcFlags |= RPC_BUFFER_EXTRA;
                    }
                else
                    {
                    //
                    // the call is not yet complete, wait for it.
                    //
                    SyncEvent.Wait();
                    }
                continue;
            }
        break;
        }

    Message->DataRepresentation = Connection->Association->SavedDrep;
    Message->RpcFlags &= ~(RPC_BUFFER_EXTRA);
    Message->RpcFlags |= OldFlags;

    if (Status != RPC_S_OK)
        {
        UnregisterCallForCancels();
        AsyncStatus = Status;

        // Remove the call reference, CCALL--
        OSF_CCALL::RemoveReference();
        }

    return Status;
}


RPC_STATUS
OSF_CCALL::GetCoalescedBuffer (
    IN PRPC_MESSAGE Message
    )
/*++
Function Name:GetCoalescedBuffer

Parameters:
    Message - the message structure that will receive the params

Description:
    This routine will coalesce the buffers in the buffer queue into a single
    buffer and return it in the Message structure. If the RPC_BUFFER_EXTRA
    flag is set, the data is appended to the existing buffer in Message->Buffer.

Returns:
    RPC_S_OK - the function was successful in doing its job
    RPC_S_OUT_OF_MEMORY - ran out of memory.
--*/
{
    char *Current;
    PVOID NewBuffer, Buffer;
    UINT bufferlength;
    UINT TotalLength;
    int Extra = IsExtraMessage(Message);
    RPC_STATUS Status;
    BOOL fSubmitReceive = 0;

    CallMutex.Request();
    if (RcvBufferLength == 0)
        {
        CallMutex.Clear();
        if (!Extra)
            {
            ASSERT(CurrentState == Complete);
            Message->Buffer = BufferQueue.TakeOffQueue(&bufferlength);

            ASSERT(Message->Buffer);
            ASSERT(bufferlength == 0);

            Message->BufferLength = 0;
            Message->RpcFlags |= RPC_BUFFER_COMPLETE;
            CallStack--;
            }
        return RPC_S_OK;
        }

    if (Extra)
        {
        TotalLength = RcvBufferLength + Message->BufferLength;
        }
    else
        {
        TotalLength = RcvBufferLength;
        }

    Status = Connection->TransGetBuffer (
                                         &NewBuffer,
                                         TotalLength+sizeof(rpcconn_request));
    if (Status != RPC_S_OK)
        {
        CallMutex.Clear();
        return RPC_S_OUT_OF_MEMORY;
        }

    NewBuffer = (char *) NewBuffer+sizeof(rpcconn_request);

    if (Extra && Message->Buffer)
        {
        RpcpMemoryCopy(NewBuffer, Message->Buffer, Message->BufferLength);
        Current = (char *) NewBuffer + Message->BufferLength;

        Connection->TransFreeBuffer(
                                    (char *) Message->Buffer
                                    -sizeof(rpcconn_request));
        }
    else
        {
        Current = (char *) NewBuffer;
        }

    while ((Buffer = BufferQueue.TakeOffQueue(&bufferlength)) != 0)
        {
        RpcpMemoryCopy(Current, Buffer, bufferlength);
        Current += bufferlength;

        Connection->TransFreeBuffer(
                                    (char *) Buffer
                                    -sizeof(rpcconn_request));
        }

    if (fPeerChoked)
        {
        fSubmitReceive = 1;
        fPeerChoked = 0;
        }

    Message->Buffer = NewBuffer;
    Message->BufferLength = TotalLength;

    if (CurrentState == Complete)
        {
        Message->RpcFlags |= RPC_BUFFER_COMPLETE;
        CallStack--;
        }

    RcvBufferLength = 0;
    CallMutex.Clear();

    if (fSubmitReceive)
        {
        Connection->TransAsyncReceive();
        }

    return RPC_S_OK;
}


RPC_STATUS
OSF_CCALL::AsyncReceive (
    IN OUT PRPC_MESSAGE Message,
    IN UINT Size
    )
/*++
Function Name:AsyncReceive

Parameters:
    Message - Contains information about the call
    Size - This field is ignored on the client.

Description:
    This is API is used to receive the non-pipe data in an async call. It this
    function is called before the call is actually complete, an
    RPC_S_ASYNC_CALL_PENDING is returned.

Returns:

--*/
{
    RPC_STATUS Status;

    if (!EXTRA(Message) && Message->Buffer)
        {
        ActuallyFreeBuffer((char  *)Message->Buffer-sizeof(rpcconn_request));
        Message->Buffer = 0;
        Message->BufferLength = 0;
        }

    while (TRUE)
        {
        switch (CurrentState)
            {
            case Complete:
                Status = GetCoalescedBuffer(Message);

                break;

            case Aborted:
                Status = AsyncStatus;

                break;

            default:
                if (PARTIAL(Message))
                    {
                    CallMutex.Request();

                    // We should try to satisfy the size requirement only
                    // if the call has not yet been completed or aborted.
                    // If the call has been completed, we will just give back all we have.
                    // If the call has been aborted, we will clean up.
                    if (RcvBufferLength < Size &&
                        CurrentState != Complete &&
                        CurrentState != Aborted)
                        {
                        if (NOTIFY(Message))
                            {
                            NeededLength = Size;
                            }
                        CallMutex.Clear();

                        return RPC_S_ASYNC_CALL_PENDING;
                        }
                    else if (CurrentState != Aborted)
                        {
                        CallMutex.Clear();

                        // We need to release CallMutex before calling GetCoalescedBuffer
                        // since it may call OSF_CCONNECTION::TransAsyncReceive which
                        // may get ConnectionMutex to clean up the connection.
                        // Other parts of the code take ConnectionMutex and then CallMutex, so
                        // this may cause a deadlock.  This call does not need to be guarded.
                        Status = GetCoalescedBuffer(Message);
                        }
                    else
                        {
                        CallMutex.Clear();

                        // The call has been aborted.
                        ASSERT(AsyncStatus != RPC_S_OK && AsyncStatus != RPC_S_ASYNC_CALL_PENDING);
                        Status = AsyncStatus;
                        }
                    }
                else
                    {
                    return RPC_S_ASYNC_CALL_PENDING;
                    }
                break;
            }
        break;
        }

    Message->DataRepresentation = Connection->Association->SavedDrep;
    
    if (Status != RPC_S_OK)
        {
        if (EEInfo)
            {
            // Try to move the EEInfo to the thread.
            // It is possible that the call is made on a thread that has never had RPC TLS initialized.
            // We can only move the EEInfo to the thread if it has RPC TLS.
            // If the THREAD object does not exist and could not be created, we have
            // to discard the EEInfo.
            if (ThreadSelf() != NULL)
                {
                RpcpPurgeEEInfo();
                RpcpSetEEInfo(EEInfo);
                }
            else
                {
                FreeEEInfoChain(EEInfo);
                }
            
            EEInfo = NULL;
            }
        
        // It is possible that this path is executed after call-complete
        // notification has been issued for an aborted call in async pipes.
        // Consider this scenario:
        //
        // - A call C is created.  No pulls have been done yet.
        // - A connection for the call is aborted.  A call-complete notification
        // is issued for the call.
        // - If a pull is called in a race, cleaning up the call here may cause
        // an AV when the user queries call status after getting call-complete.
        //
        // Therefore we should not clean up if notification has been issued for an
        // async pipe call.  We will cleanup when the call is completed.
        //
        // We will also need to fake success, since the app assumes that the call
        // is done and cleaned up once an async pipe pull returned a failure.
        if (!GetIsAsyncPipeCallFlag() || NotificationIssued == -1)
            {
            //
            // FreeBuffer is not going to be called. Cleanup now..
            //
            AsyncStatus = Status;

            // remove the call reference, CCALL--
            OSF_CCALL::RemoveReference();

            }
        else
            {
            // Let's fake success by returning call-pending.  This way there is no data
            // transfered to the user and she can calmly wait for the failure to come
            // asyncronously.
            Status = RPC_S_ASYNC_CALL_PENDING;
            }
        }

    return Status;
}


RPC_STATUS
OSF_CCALL::SetAsyncHandle (
    IN PRPC_ASYNC_STATE pAsync
    )
/*++
Function Name:SetAsyncHandle

Parameters:

Description:

Returns:

--*/
{
    if (DoesAsyncCallHavePipe((char *)pAsync))
        {
        SetIsAsyncPipeCallFlag();
        }

    return CALL::SetAsyncHandle(pAsync);
}


RPC_STATUS
OSF_CCALL::ReceiveReply (
    IN rpcconn_request *Request,
    IN PRPC_MESSAGE Message
    )
/*++
Function Name:ReceiveReply

Parameters:

Description:
    Helper function to receive the complete reply. The reply may either be a
    callback, or a response.

Returns:

--*/
{
    int BytesRead;
    PVOID NewBuffer;
    RPC_STATUS Status;
    UINT BytesRemaining;
    RPC_MESSAGE NewMessage;
    UINT NewBufferLength;
    ULONG AllocHint = Request->alloc_hint;
    ULONG Timeout;

    //
    // Allocate a buffer, big enough to hold the non pipe data.
    // All the non pipe data will go into the first buffer, all other fragments
    // will go as separate buffers in the received buffer queue
    //
    if (AllocHint)
        {
        // NDR doesn't handle above 2G. Make sure we're not handed more than that
        if (AllocHint & 0x80000000UL)
            {
            Connection->TransFreeBuffer(Request);
            return RPC_S_PROTOCOL_ERROR;
            }

        Status = Connection->TransGetBuffer(
                                         &NewBuffer,
                                         AllocHint+sizeof(rpcconn_request));

        if (Status != RPC_S_OK)
            {
            Connection->TransFreeBuffer(Request);
            return Status;
            }

        NewBuffer = (char *) NewBuffer+sizeof(rpcconn_request);
        RpcpMemoryCopy(NewBuffer, Message->Buffer, Message->BufferLength);

        Connection->TransFreeBuffer(Request);

        Message->Buffer = NewBuffer;

        BytesRemaining = AllocHint - Message->BufferLength;
        }
    else
        {
        BytesRemaining = 0;
        }

    BytesRead = Message->BufferLength;
    NewMessage.RpcFlags = Message->RpcFlags;

    Timeout = GetBindingHandleTimeout(BindingHandle);

    //
    // Receive the complete data
    //
    while (!COMPLETE(&NewMessage))
        {
        Status = Connection->TransReceive(
                                          &NewBuffer,
                                          &NewBufferLength,
                                          Timeout);
        if (Status != RPC_S_OK)
            {
            Connection->TransFreeBuffer((char *) Message->Buffer-sizeof(rpcconn_request));

            if ((Status == RPC_P_RECEIVE_FAILED)
                || (Status == RPC_P_CONNECTION_CLOSED)
                || (Status == RPC_P_CONNECTION_SHUTDOWN))
                {
                RpcpErrorAddRecord(EEInfoGCRuntime,
                    RPC_S_CALL_FAILED,
                    EEInfoDLOSF_CCALL__ReceiveReply10,
                    Status);
                return(RPC_S_CALL_FAILED);
                }

            if (Status == RPC_P_TIMEOUT)
                {
                RpcpErrorAddRecord(EEInfoGCRuntime,
                    RPC_S_CALL_CANCELLED,
                    EEInfoDLOSF_CCALL__ReceiveReply20,
                    (ULONG)Status,
                    (ULONG)Timeout);

                return RPC_S_CALL_CANCELLED;
                }

            return Status;
            }

        // Sanity check the packet.
        // We expect response packet or a request if we are InCallbackRequest (CallStack > 0).
        // If alloc_hint was previously specified and we set BytesRemaining the server
        // better stick to it.
        unsigned char PTYPE = ((rpcconn_request *)NewBuffer)->common.PTYPE;
        if (!((PTYPE == rpc_response
               || (PTYPE == rpc_request && CurrentState == InCallbackRequest && this->CallStack > 0))))
            {
            CORRUPTION_ASSERT(0);
            Connection->TransFreeBuffer((char *) Message->Buffer-sizeof(rpcconn_request));
            return RPC_S_PROTOCOL_ERROR;
            }

        Status = ActuallyProcessPDU(
                                    (rpcconn_common *) NewBuffer,
                                    NewBufferLength,
                                    &NewMessage);

        if (Status != RPC_S_OK)
            {
            Connection->TransFreeBuffer((char *) Message->Buffer-sizeof(rpcconn_request));
            return Status;
            }

        if (BytesRemaining < NewMessage.BufferLength)
            {
            //
            // This code path is taken only in the OSF interop case
            //
            Message->Buffer = (char *) Message->Buffer - sizeof(rpcconn_request);
            Status = Connection->TransReallocBuffer(
                                 &Message->Buffer,
                                 BytesRead+sizeof(rpcconn_request),
                                 BytesRead
                                 +NewMessage.BufferLength
                                 +sizeof(rpcconn_request));

            if (Status != RPC_S_OK)
                {
                Connection->TransFreeBuffer(Message->Buffer);
                return Status;
                }
            Message->Buffer = (char *) Message->Buffer + sizeof(rpcconn_request);
            BytesRemaining = NewMessage.BufferLength;
            }

        RpcpMemoryCopy((char *) Message->Buffer+BytesRead,
                       NewMessage.Buffer,
                       NewMessage.BufferLength);

        ActuallyFreeBuffer(NewBuffer);

        BytesRead += NewMessage.BufferLength;
        BytesRemaining -= NewMessage.BufferLength;
        }

    CORRUPTION_ASSERT(BytesRemaining == 0);

    Message->BufferLength = BytesRead;
    Message->RpcFlags = RPC_BUFFER_COMPLETE;

    return RPC_S_OK;
}


RPC_STATUS
OSF_CCALL::DealWithCallback (
    IN rpcconn_request *Request,
    IN PRPC_MESSAGE Message
    )
/*++
Function Name:DealWithCallback

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status, ExceptionCode;
    void *OriginalBuffer ;

    if (CallStack == 1)
        {
        BindingHandle->AddRecursiveEntry(this,
                                     (RPC_CLIENT_INTERFACE  *)
                                     Message->RpcInterfaceInformation);

        }

    EnterCallback();

    if (!COMPLETE(Message))
        {
        ASSERT(Request);
        ASSERT(Request->common.PTYPE == rpc_request);

        //
        // Receive the complete callback request.
        //
        Status = ReceiveReply(Request, Message);
        if (Status != RPC_S_OK)
            {
            return Status;
            }
        }

    ASSERT(COMPLETE(Message));

    CurrentState = SendingFirstBuffer;
    OriginalBuffer = Message->Buffer;

    //
    // Dispatch the callback
    //
    Status = DispatchCallback(
                              DispatchTableCallback,
                              Message,
                              &ExceptionCode);


    ExitCallback();

    ActuallyFreeBuffer((char *) OriginalBuffer-sizeof(rpcconn_request));

    if ( Status != RPC_S_OK )
        {
        VALIDATE(Status)
            {
            RPC_P_EXCEPTION_OCCURED,
            RPC_S_PROCNUM_OUT_OF_RANGE
            } END_VALIDATE;

        if (Status == RPC_S_PROCNUM_OUT_OF_RANGE)
            {
            SendFault(RPC_S_PROCNUM_OUT_OF_RANGE, 0);
            }
        else
            {
            SendFault(ExceptionCode, 0);
            Status = ExceptionCode;
            }

        RpcpPurgeEEInfo();

        return Status;
        }

    CurrentState = InCallbackReply;

    CurrentOffset = 0;
    CurrentBuffer = Message->Buffer;
    CurrentBufferLength = Message->BufferLength;
    LastBuffer = Message->Buffer;

    Status = SendNextFragment(rpc_response);

    ASSERT(Connection->fExclusive);

    if (Connection->fExclusive)
        {
        if (Status != RPC_S_OK || (CurrentBufferLength == 0))
            {
            goto Cleanup;
            }

        while (CurrentBufferLength)
            {
            Status = SendNextFragment(rpc_response, FALSE);
            if (Status != RPC_S_OK)
                {
                break;
                }
            }

Cleanup:
            // Do not remove this call from the dictionary if it has already
            // been removed.  If it has been removed, RecursiveCallsKey == -1.
            if (CallStack == 1 && RecursiveCallsKey != -1)
                {
                BindingHandle->RemoveRecursiveCall(this);
                }

            FreeBufferDo(Message->Buffer);
        }
    else
        {
        //
        // Callbacks not allowed in the async or in pipes
        //
        Status = RPC_S_CALL_FAILED;
        }

    return Status;
}


RPC_STATUS
OSF_CCALL::FastSendReceive (
    IN OUT PRPC_MESSAGE Message,
    OUT BOOL *fRetry
    )
/*++
Function Name:FastSendReceive

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    UINT BufferLength;
    rpcconn_common *Request;
    DebugClientCallInfo *ClientCallInfo;
    DebugCallTargetInfo *CallTargetInfo;
    CellTag ClientCallInfoCellTag;
    CellTag CallTargetInfoCellTag;
    THREAD *ThisThread = RpcpGetThreadPointer();
    BOOL fDebugInfoSet = FALSE;
    ULONG Timeout;
    unsigned char SavedPTYPE;

    CurrentOffset = 0;
    CurrentBuffer = Message->Buffer;
    CurrentBufferLength = Message->BufferLength;
    Message->RpcFlags = 0;

    ASSERT(ThisThread);

    // if either client side debugging is enabled or we are
    // calling on a thread that has a scall dispatched
    if (IsClientSideDebugInfoEnabled() || ((ThisThread->Context) && IsServerSideDebugInfoEnabled()))
        {
        CStackAnsi AnsiString;
        RPC_CHAR *Endpoint;
        RPC_CHAR *NetworkAddress;
        int EndpointLength;
        int NetworkAddressLength;

        if (!IsClientSideDebugInfoEnabled())
            {
            Status = SetDebugClientCallInformation(&ClientCallInfo, &ClientCallInfoCellTag,
                &CallTargetInfo, &CallTargetInfoCellTag, Message, ThisThread->DebugCell,
                ThisThread->DebugCellTag);
            }
        else
            {
            Status = SetDebugClientCallInformation(&ClientCallInfo, &ClientCallInfoCellTag,
                &CallTargetInfo, &CallTargetInfoCellTag, Message, NULL, NULL);
            }

        if (Status != RPC_S_OK)
            return Status;

        ClientCallInfo->CallID = CallId;

        Endpoint = Connection->InqEndpoint();
        NetworkAddress = Connection->InqNetworkAddress();
        EndpointLength = RpcpStringLength(Endpoint) + 1;
        NetworkAddressLength = RpcpStringLength(NetworkAddress) + 1;
        *(AnsiString.GetPAnsiString()) = (char *)_alloca(max(EndpointLength, NetworkAddressLength));

        Status = AnsiString.Attach(Endpoint, EndpointLength, EndpointLength * 2);

        // effectively ignore failure in the conversion
        if (Status == RPC_S_OK)
            {
            strncpy(ClientCallInfo->Endpoint, AnsiString, sizeof(ClientCallInfo->Endpoint));
            }

        CallTargetInfo->ProtocolSequence = Connection->ClientInfo->TransId;
        Status = AnsiString.Attach(NetworkAddress, NetworkAddressLength, NetworkAddressLength * 2);
        if (Status == RPC_S_OK)
            {
            strncpy(CallTargetInfo->TargetServer, AnsiString, sizeof(CallTargetInfo->TargetServer));
            }   

        fDebugInfoSet = TRUE;
        }

    Status = SendNextFragment(rpc_request, TRUE, (void **) &Request, &BufferLength) ;
    if (Status != RPC_S_OK)
        {
        goto Cleanup;
        }

    *fRetry = FALSE;

    while (CurrentBufferLength)
        {
        Status = SendNextFragment(rpc_request, FALSE, (void **) &Request, &BufferLength);
        if (Status != RPC_S_OK)
            {
            goto Cleanup;
            }
        }

    //
    // We have sent the complete request. It is time to start
    // receiving the reply. The reply could either be a response
    // or a callback
    //
    CurrentState = WaitingForReply;

    RpcpPurgeEEInfo();

    while (1)
        {
        //
        // This is the only place where we can receive a callback PDU
        //

        // Request will be freed if it were of rpc_alter_context_resp type.
        // We should not touch it after the call to ActuallyProcessPDU.
        SavedPTYPE = Request->PTYPE;

        Status = ActuallyProcessPDU(
                                    Request,
                                    BufferLength,
                                    Message);

        if (Status != RPC_S_OK)
            {
            goto Cleanup;
            }

        NO_CORRUPTION_VALIDATE(SavedPTYPE)
            {
            rpc_request,
            rpc_response,
            rpc_shutdown
            } NO_CORRUPTION_END_VALIDATE;

        switch (SavedPTYPE)
            {
            case rpc_request:
                // Check to make sure this procnum can actually receive callbacks and
                // a valid callback is specified.
                // On error - ignore the PDU.
                if (DispatchTableCallback &&
                    Message->ProcNum < DispatchTableCallback->DispatchTableCount &&
                    DispatchTableCallback->DispatchTable[Message->ProcNum] != NULL &&
                    CurrentState == InCallbackRequest)
                    {
                    Status = DealWithCallback(
                                              (rpcconn_request *) Request,
                                              Message);
                    Message->RpcFlags = 0;
                    }
                else
                    {
                    CORRUPTION_ASSERT(0);
                    Status = RPC_S_PROTOCOL_ERROR;
                    goto Cleanup;
                    }
                break;

            case rpc_response:
                if (!COMPLETE(Message))
                    {
                    Status = ReceiveReply(
                                          (rpcconn_request *) Request,
                                          Message);
                    }
                goto Cleanup;

            default:
                // ignore the pdu
                break;
            }

        Timeout = GetBindingHandleTimeout(BindingHandle);
        Status = Connection->TransReceive(
                                    (PVOID *) &Request,
                                    &BufferLength,
                                    Timeout);
        if (Status != RPC_S_OK)
            {
            if ((Status == RPC_P_RECEIVE_FAILED )
                || ( Status == RPC_P_CONNECTION_CLOSED ) )
                {
                RpcpErrorAddRecord(EEInfoGCRuntime,
                    RPC_S_CALL_FAILED_DNE,
                    EEInfoDLOSF_CCALL__FastSendReceive10,
                    Status);
                Status = RPC_S_CALL_FAILED;
                }
            else if (Status == RPC_P_CONNECTION_SHUTDOWN)
                {
                RpcpErrorAddRecord(EEInfoGCRuntime,
                    RPC_S_CALL_FAILED_DNE,
                    EEInfoDLOSF_CCALL__FastSendReceive20,
                    Status);
                Status = RPC_S_CALL_FAILED_DNE;
                }
            else if (Status == RPC_P_TIMEOUT)
                {
                Status = RPC_S_CALL_CANCELLED;
                RpcpErrorAddRecord(EEInfoGCRuntime,
                    Status,
                    EEInfoDLOSF_CCALL__FastSendReceive30,
                    RPC_P_TIMEOUT,
                    Timeout);
                }

            goto Cleanup;
            }
        }

Cleanup:

    if (fDebugInfoSet)
        {
        FreeCell(CallTargetInfo, &CallTargetInfoCellTag);
        FreeCell(ClientCallInfo, &ClientCallInfoCellTag);
        }
    return Status;
}


void
OSF_CCALL::CallFailed (
    IN RPC_STATUS Status
    )
/*++
Function Name:

Parameters:

Description:

Returns:

--*/
{
    ExtendedErrorInfo * pThreadEEInfo;
    BOOL fIssueNotification;

    CallMutex.Request();

    //
    // Should not transition from Complete -> Aborted
    //
    if (CurrentState != Complete
        && CurrentState != Aborted)
        {
        //
        // Notify the client that the call is complete. When the stub calls
        // I_RpcReceive, we can cleanup the call and return a failure
        // status.
        //
        AsyncStatus = Status;

        //
        // For async pipes, this path races with OSF_CCALL::ProcessResponse.
        // If the notification has been issued there, then the user may do a pull.
        // We do not want to issue a notification iff there will be a thread
        // attempting a pull and cleaning up the call syncronously.
        //
        // If this is not an async pipe call, then we should only issue notification
        // iff there will be no more sends.
        // 
        // Therefore the condition for issuing notification is:
        // (async pipe call -> there will not be a pull) && (!async pipe call -> fLastSendComplete)
        //
        fIssueNotification = GetIsAsyncPipeCallFlag() ? !IsAsyncPipeCallBeforePull() : fLastSendComplete;

        CurrentState = Aborted;

        //
        // If the last send is complete, then we need to issue the notification so
        // that I_RpcReceive is called. If the last send is not complete, we don't need
        // to issue the notification.
        //
        if (pAsync)
            {

            if (EEInfo)
                {
                FreeEEInfoChain(EEInfo);
                EEInfo = NULL;
                }
            pThreadEEInfo = RpcpGetEEInfo();
            if (pThreadEEInfo)
                {
                EEInfo = pThreadEEInfo;
                RpcpClearEEInfo();
                }
           
            if (fIssueNotification)
                {
                IssueNotification();
                }
            }
        else
            {
            SyncEvent.Raise();
            }
        }
    CallMutex.Clear();
}


RPC_STATUS
OSF_CCALL::CallCancelled (
    OUT PDWORD Timeout
    )
/*++
Function Name:CallCancelled

Parameters:

Description:
    This function is called via the connection whenever the transport interface
    notices that it has received an alert. This function should only be used in conjuction
    with sync non pipe calls.

Returns:
    RPC_S_OK: The call was cancelled
    others - if a failure occured.

--*/
{
    RPC_STATUS Status;

    if (CurrentState == NeedOpenAndBind)
        {
        *Timeout = 0;
        return RPC_S_OK;
        }

    if (fCallCancelled == 0)
        {
        return RPC_S_NO_CALL_ACTIVE;
        }

    Status = SendCancelPDU();
    //
    // Ignore the return status
    //

    *Timeout = (DWORD) ThreadGetRpcCancelTimeout();

    return Status;
}


inline RPC_STATUS
OSF_CCALL::SendReceiveHelper (
    IN OUT PRPC_MESSAGE Message,
    OUT BOOL *fRetry
    )
/*++
Function Name:SendReceive

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    THREAD *ThreadInfo;

    CallStack++;

    ASSERT(!PARTIAL(Message) && !ASYNC(Message));

    ThreadInfo = RpcpGetThreadPointer();
    ASSERT(ThreadInfo);

    if (CallStack == 1)
        {
        Status = ThreadInfo->RegisterForCancels(this);
        if (Status != RPC_S_OK)
            {
            return Status;
            }
        }

    if (ThreadInfo->CancelTimeout == RPC_C_CANCEL_INFINITE_TIMEOUT)
        {
        CancelState = CANCEL_INFINITE;
        }
    else
        {
        CancelState = CANCEL_NOTINFINITE;
        }

    LastBuffer = Message->Buffer;

    ASSERT (Connection->fExclusive);
    ASSERT(CurrentState == SendingFirstBuffer);
    Status = FastSendReceive(Message, fRetry);

    if (CallStack == 1)
        {
        ThreadInfo->UnregisterForCancels();
        }

    CallStack--;

    if (Status == RPC_S_OK
        && CallStack == 0)
        {
        RPC_SECURITY_CALLBACK_FN *SecurityCallback = NULL;

        CurrentState = Complete;
        Status = BindingHandle->OSF_BINDING_HANDLE::InqTransportOption(
                                                   RPC_C_OPT_SECURITY_CALLBACK,
                                                   (ULONG_PTR *) &SecurityCallback);
        ASSERT(Status == RPC_S_OK);

        if (SecurityCallback)
            {
            (*SecurityCallback) (this);
            }
        }

    return Status;
}


RPC_STATUS
OSF_CCALL::SendReceive (
    IN OUT PRPC_MESSAGE Message
    )
/*++
Function Name:SendReceive

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    void *TempBuffer ;
    OSF_BINDING_HANDLE *MyBindingHandle;
    void *OriginalBuffer;
    BOOL fRetry = TRUE;
    int RetryAttempts = 0;
    OSF_CCONNECTION *LocalConnection;

    AssocDictMutex->VerifyNotOwned();

    AddVerificationTrailer(Message);

    MyBindingHandle = BindingHandle;

    //
    // WARNING: Do not use any members of OSF_CCALL beyond this point.
    // the object could have been deleted.
    //
    while (RetryAttempts <= 5)
        {
        OriginalBuffer = Message->Buffer;
        Status = ((OSF_CCALL *) Message->Handle)->SendReceiveHelper(Message, &fRetry);

        if (Status == RPC_S_OK || ((OSF_CCALL *) Message->Handle)->CallStack > 0)
            {
            ((OSF_CCALL *) Message->Handle)->FreeBufferDo(OriginalBuffer);
            break;
            }
        else
            {
            ASSERT(Status != RPC_S_SEND_INCOMPLETE);
            ASSERT(((OSF_CCALL *) Message->Handle)->CallStack == 0);

            if (Status == RPC_P_CONNECTION_SHUTDOWN)
                {
                Status = RPC_S_CALL_FAILED_DNE;
                }

            LocalConnection = ((OSF_CCALL *) Message->Handle)->Connection;

            if (fRetry == FALSE
                || (Status != RPC_S_CALL_FAILED_DNE)
                || (LocalConnection->ClientSecurityContext.AuthenticationLevel
                == RPC_C_AUTHN_LEVEL_PKT_PRIVACY))
                {
                ((OSF_CCALL *) Message->Handle)->FreeBufferDo(OriginalBuffer);
                ((OSF_CCALL *) Message->Handle)->FreeCCall(Status);
                LogEvent(SU_CCALL, EV_DELETE, Message->Handle, 0, Status, 1, 1);
                break;
                }
            }

        if (!LocalConnection->GetFreshFromCacheFlag())
            {
            // count this as a retry attempt only if the
            // connection was not from the cache
            RetryAttempts ++;
            }

        Status = AutoRetryCall(Message,
                                TRUE, // this is the SendReceive path
                                MyBindingHandle,
                                Status,
                                0);
        if (Status != RPC_S_OK)
            break;

        if (RetryAttempts > 5)
            Status = RPC_S_CALL_FAILED_DNE;
        }


    return Status;
}


RPC_STATUS
OSF_CCALL::ProcessRequestOrResponse (
    IN rpcconn_request *Request,
    IN UINT PacketLength,
    IN BOOL fRequest,
    IN OUT PRPC_MESSAGE Message
    )
/*++
Function Name:ProcessRequestOrResponse

Parameters:
    fRequest - If true, this is a request. Otherwise, it is a response

Description:
    This function is called by ActuallyProcessPDU

Returns:

--*/
{
    RPC_STATUS Status;
    OSF_BINDING *LocalBinding;

    if ((Request->common.pfc_flags & PFC_OBJECT_UUID) != 0)
        {
        CORRUPTION_ASSERT(0);
        return RPC_S_PROTOCOL_ERROR;
        }

    if ((Request->common.pfc_flags & PFC_FIRST_FRAG))
        {
        InReply = 1;
        ASSERT(BufferQueue.IsQueueEmpty());

        Message->DataRepresentation = Connection->Association->SavedDrep;

        //
        // Transition to the next state
        //
        if (fRequest)
            {
            CurrentState = InCallbackRequest;
            }
        else
            {
            CurrentState = Receiving;
            }
        }
    else
        {
        if (CurrentState == WaitingForReply)
            {
            CORRUPTION_ASSERT(0);
            return RPC_S_PROTOCOL_ERROR;
            }
        }

    if ((Request->common.pfc_flags & PFC_LAST_FRAG) != 0)
        {
        Message->RpcFlags |= RPC_BUFFER_COMPLETE;
        }

    Status = EatAuthInfoFromPacket(
                                   Request,
                                   &PacketLength);

    if (Status != RPC_S_OK)
        {
        return Status;
        }

    // tell the connection the call came back successfully. If this was not a pipe call
    if (GetIsPipeCallFlag() == FALSE)
        {
        Connection->SuccessfulResponseReceived();

        // if the binding is still not verified, count it as verified
        LocalBinding = GetSelectedBinding();
        if (LocalBinding->GetPContextVerifiedFlag() == FALSE)
            LocalBinding->SetPContextVerifiedFlag();
        }

    Message->BufferLength = PacketLength - sizeof(rpcconn_request);
    Message->Buffer =  (void *) (Request + 1);

    return RPC_S_OK;
}


RPC_STATUS
OSF_CCALL::ActuallyProcessPDU (
    IN rpcconn_common *Packet,
    IN UINT PacketLength,
    IN OUT PRPC_MESSAGE Message,
    IN BOOL fAsync,
    OUT BOOL *pfSubmitReceive
    )
/*++
Function Name:ActuallyProcessPDU

Parameters:

Description:

    Packet is freed on failure or if it is of type rpc_alter_context_resp.
    The caller should not touch the packet in these cases after the return.

Returns:

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    ULONG FaultStatus;
    BOOL AlterContextToNDR20IfNDR64Negotiated;

    //
    // If there is security save the rpc header
    //
    if (Connection->ClientSecurityContext.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE )
        {
        CallMutex.Request();
        if (SavedHeader == 0)
            {
            SavedHeader = RpcpFarAllocate(sizeof(rpcconn_response));
            if (SavedHeader == 0)
               {
               CallMutex.Clear();
               Status = RPC_S_OUT_OF_MEMORY;
               goto Cleanup;
               }
            SavedHeaderSize = sizeof(rpcconn_response);
            }
        CallMutex.Clear();

        RpcpMemoryCopy(
                       SavedHeader,
                       Packet,
                       sizeof(rpcconn_response));
        }

    Status = ValidatePacket(Packet, PacketLength);
    if (Status != RPC_S_OK)
        {
        goto Cleanup;
        }

    switch (Packet->PTYPE)
        {
        case rpc_response:
            Status =  ProcessRequestOrResponse(
                                            (rpcconn_request *) Packet,
                                            PacketLength,
                                            0,
                                            Message);
            if (Status != RPC_S_OK)
                {
                goto Cleanup;
                }

            if (fAsync)
                {
                Status = ProcessResponse((rpcconn_response *) Packet,
                                         Message, pfSubmitReceive);
                }

            break;

        case rpc_alter_context_resp:
            if (CurrentState != WaitingForAlterContext)
                {
                CORRUPTION_ASSERT(0);
                Status = RPC_S_PROTOCOL_ERROR;
                goto Cleanup;
                }

            // if we have chosen NDR20 in the call, we must warn the DealWithAlterContextResp
            // to alter context once more to NDR20 if NDR64 was chosen by the server
            if (Bindings.AvailableBindingsList 
                && Bindings.SelectedBinding
                && (Bindings.SelectedBinding->CompareWithTransferSyntax(NDR20TransferSyntax) == 0))
                {
                AlterContextToNDR20IfNDR64Negotiated = TRUE;
                }
            else
                {
                AlterContextToNDR20IfNDR64Negotiated = FALSE;
                }

            Status = Connection->DealWithAlterContextResp(
                                                          this,
                                                          Packet,
                                                          PacketLength,
                                                          &AlterContextToNDR20IfNDR64Negotiated);

            ActuallyFreeBuffer(Packet);

            if (Status != RPC_S_OK)
                {
                return Status;
                }

            // if we sent another alter context, return and wait for the response
            // N.B. We don't need to wait for the send because we're not
            // going to proceed with another send. When we get the response
            // and process it, we will wait for the send (when this condition
            // evaluates to FALSE).
            if (AlterContextToNDR20IfNDR64Negotiated)
                return RPC_S_OK;

            //
            // Wait for the send to complete
            //
            Connection->WaitForSend();

            //
            // We sent the alter-context PDU when it was our turn,
            // now that we have received a response, we need to get
            // the ball rolling.
            //
            CurrentState = SendingFirstBuffer;

            ASSERT(Connection->IsIdle() == 0);

            CallMutex.Request();
            if (CurrentBuffer)
                {
                CallMutex.Clear();

                Status = SendNextFragment();
                }
            else
                {
                //
                // We don't have a buffer to send from this call, we will force
                // the connection to idle and wait for the this call to give us
                // its buffer. The send function will notice that the connection is
                // idle, and send its first data buffer.
                //
                Connection->MakeConnectionIdle();
                CallMutex.Clear();

                ASSERT(Status == RPC_S_OK);
                }

            // The Packet has been freed above.
            return Status;

        case rpc_request:
            //
            // if we are going to reuse this function to handle
            // sync SendReceive, we need to keep track of this
            // and puke on the other cases (ie: when using Async
            // and when using pipes).
            //
            if (fAsync)
                {
                SendFault(RPC_S_CALL_FAILED, 0);
                Status = RPC_S_CALL_FAILED;
                goto Cleanup;
                }

            if ( Packet->call_id != CallId )
                {
                CORRUPTION_ASSERT(0);
                Status = RPC_S_PROTOCOL_ERROR;
                goto Cleanup;
                }

            if (((rpcconn_request  *) Packet)->p_cont_id
                        != GetSelectedBinding()->GetOnTheWirePresentationContext() )
                {
                SendFault(RPC_S_UNKNOWN_IF, 0);
                Status = RPC_S_UNKNOWN_IF;
                goto Cleanup;
                }

            Status =  ProcessRequestOrResponse(
                                            (rpcconn_request *) Packet,
                                            PacketLength,
                                            1,
                                            Message);
            if (Status != RPC_S_OK)
                {
                goto Cleanup;
                }

            Message->ProcNum = ((rpcconn_request *) Packet)->opnum;
            break;

        case rpc_fault:
            //
            // Flag the connection to protect a shutdown of the association.
            // This flag will be checked when we abort the connection to see
            // if its ok to abort the entire association.  When receiving a
            // fault, we only want to close the connection, not the association
            //
            Connection->Flags.SetFlagUnsafe(NoAssociationShutdown);
            
            FaultStatus = ((rpcconn_fault  *) Packet)->status;

            if ((FaultStatus == 0)
                && (Packet->frag_length >= FaultSizeWithoutEEInfo + 4))
                {
                //
                // DCE 1.0.x style fault status:
                // Zero status and stub data contains the fault.
                //
                FaultStatus = *(ULONG  *) ((unsigned char *)Packet + FaultSizeWithoutEEInfo);
                }

            if (DataConvertEndian(Packet->drep) != 0)
                {
                FaultStatus = RpcpByteSwapLong(FaultStatus);
                }

            CORRUPTION_ASSERT(FaultStatus != 0);

            Status = MapFromNcaStatusCode(FaultStatus);

            ASSERT(Status != RPC_S_OK);

            if (((rpcconn_fault  *) Packet)->reserved & FaultEEInfoPresent)
                {
                size_t EEInfoSize = GetEEInfoSizeFromFaultPacket((rpcconn_fault  *) Packet);

                // Sanity-check the EEInfo length
                if (EEInfoSize > Packet->frag_length - FaultSizeWithoutEEInfo)
                    {
                    CORRUPTION_ASSERT(0 && "Reported EEInfo size is larger then the packet");
                    }
                else
                    {
                    UnpickleEEInfoFromBuffer(((rpcconn_fault  *) Packet)->buffer, EEInfoSize);
                    }                
                }

            //
            // In 3.5 we didnt Sign/Seal Faults. So .. Unsign/UnSeal doesnt
            // get called and hence Client side and Server side Seq# are
            // out of Sync..  So cheat ..
            //

            Connection->IncReceiveSequenceNumber();

            if (fAsync)
                {
                if (Connection->Association->fMultiplex == mpx_no
                    && fOkToAdvanceCall())
                    {
                    //
                    // In the multiplexed case, the call is advanced
                    // when the send completes
                    //
                    Connection->AdvanceToNextCall();
                    }
                }
            break;

        case rpc_orphaned :
        case rpc_cancel :
        case rpc_shutdown :
            //
            // For the first release, we will just ignore these messages.
            //
            ASSERT(Status == RPC_S_OK);
            break;

        default:
            // We should never get here for trully invalid packets.  In ValidatePacket
            // we will call MinPacketLength and notice that PTYPE is bogus failing then.
            // So someone must have sent us a packet with type comprehensible to server only.
            CORRUPTION_ASSERT(0 && "Invalid packet type");
            Status = RPC_S_PROTOCOL_ERROR;
            break;
        }

Cleanup:
    if (Status != RPC_S_OK)
        {
        ActuallyFreeBuffer(Packet);
        }

    return Status;
}


BOOL
OSF_CCALL::ProcessReceivedPDU (
    IN void  *Buffer,
    IN int BufferLength
    )
/*++
Function Name:ProcessReceivedPDU

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    RPC_MESSAGE Message;
    rpcconn_common * Packet = (rpcconn_common *) Buffer;
    BOOL fSubmitReceive = 1;

    Message.RpcFlags = 0;

    Status = ActuallyProcessPDU(
                                Packet,
                                BufferLength,
                                &Message,
                                1,
                                &fSubmitReceive);

    if (Status != RPC_S_OK)
        {
        CallFailed(Status);
        }

    return fSubmitReceive;
}


RPC_STATUS
OSF_CCALL::UpdateBufferSize (
    IN OUT void **Buffer,
    IN int CurrentBufferLength
    )
{
    RPC_MESSAGE Message;
    RPC_STATUS Status;

    Message.RpcFlags = 0;
    Message.Handle = this;
    Message.ProcNum = ProcNum;
    Message.BufferLength = CurrentBufferLength;

    Status = GetBufferWithoutCleanup(&Message, 0);
    if (Status != RPC_S_OK)
        {
        CallFailed(Status);
        return Status;
        }

    RpcpMemoryCopy(Message.Buffer, *Buffer, CurrentBufferLength);

    ActuallyFreeBuffer((char  *) (*Buffer) - sizeof(rpcconn_request));

    return RPC_S_OK;
}

RPC_STATUS
OSF_CCALL::NegotiateTransferSyntaxAndGetBuffer (
    IN OUT PRPC_MESSAGE Message,
    IN RPC_SYNTAX_IDENTIFIER *OldTransferSyntax,
    IN UUID *ObjectUuid
    )
{
    OSF_BINDING_HANDLE *BindingHandle;
    OSF_CCALL *CCall;
    RPC_STATUS Status;
    BOOL fInterfaceSupportsMultipleTransferSyntaxes;

    BindingHandle = (OSF_BINDING_HANDLE *)Message->Handle;

    ASSERT(BindingHandle->Type(OSF_BINDING_HANDLE_TYPE));

    fInterfaceSupportsMultipleTransferSyntaxes =
        DoesInterfaceSupportMultipleTransferSyntaxes(Message->RpcInterfaceInformation);

    Status = BindingHandle->OSF_BINDING_HANDLE::NegotiateTransferSyntax(Message);

    if (Status != RPC_S_OK)
        return Status;

    CCall = (OSF_CCALL *)Message->Handle;

    if (fInterfaceSupportsMultipleTransferSyntaxes)
        {
        if (RpcpMemoryCompare(OldTransferSyntax, Message->TransferSyntax, sizeof(RPC_SYNTAX_IDENTIFIER)) != 0)
            {
            // the transfer syntax has changed - possible during auto-reconnect, especially in a
            // mixed cluster environment

            //
            // We cannot free the call, because an async bind may be
            // in progress. All we should do is remove our ref counts
            // The async bind path holds its own ref count, so
            // we don't need to worry about it
            //
            CCall->AsyncStatus = RPC_S_CALL_FAILED_DNE;
            // we need to remove only one reference - the second reference
            // is removed during a successful bind, and another reference
            // will be added when a successful send is made - we're not
            // there yet, so we have only one reference.
            CCall->OSF_CCALL::RemoveReference();
            // When NDR starts supporting remarshalling, we should
            // return RPC_P_TRANSFER_SYNTAX_CHANGED
            return RPC_S_CALL_FAILED_DNE;
            }
        }

    Status = CCall->GetBuffer(Message, ObjectUuid);

    return Status;
}


RPC_STATUS
OSF_CCALL::SendMoreData (
    IN BUFFER Buffer
    )
/*++
Function Name:SendMoreData

Parameters:

Description:
    This function can only be called on a send completion

Returns:

--*/
{
    RPC_STATUS Status;
    void  * SecurityTrailer;

    CallMutex.Request();
    if (Buffer)
        {
        //
        // If we reach here, it means that this routine was called
        // as a result of a send complete
        //
        ASSERT(HeaderSize != 0);
        ASSERT(CurrentBuffer);
        ASSERT(CurrentBuffer != LastBuffer
               || CurrentBufferLength > MaxDataLength);


        CurrentOffset += MaxDataLength;
        CurrentBufferLength -= MaxDataLength;

        if (CurrentBufferLength == 0)
            {
            FreeBufferDo(CurrentBuffer);

            if (pAsync && (pAsync->Flags & RPC_C_NOTIFY_ON_SEND_COMPLETE))
                {
                if (!IssueNotification(RpcSendComplete))
                    {
                    CallMutex.Clear();
#if DBG
                    PrintToDebugger("RPC: SendMoreData failed: %d\n", AsyncStatus);
#endif
                    return RPC_S_OUT_OF_MEMORY;
                    }
                }

            //
            // We can be in SendingFirstBuffer, if the we had a very small pipe
            //

            VALIDATE(CurrentState)
                {
                SendingMoreData,
                SendingFirstBuffer
                } END_VALIDATE;

            CurrentOffset = 0;
            CurrentBuffer = BufferQueue.TakeOffQueue(
                                                     (unsigned int *) &CurrentBufferLength);

            if (fChoked == 1 && pAsync == 0 && BufferQueue.Size() <=1)
                {
                fChoked = 0;
                SyncEvent.Raise();
                }

            if (CurrentBuffer)
                {
                if ((AdditionalSpaceForSecurity < Connection->AdditionalSpaceForSecurity)
                   && UpdateBufferSize(&CurrentBuffer, CurrentBufferLength) != RPC_S_OK)
                   {
                   CallMutex.Clear();

                   return RPC_S_OUT_OF_MEMORY;
                   }
                }
            else
                {
                Connection->MakeConnectionIdle();
                ASSERT(CurrentBufferLength == 0);
                CallMutex.Clear();

                return RPC_S_OK;
                }
            }
        else
            {
            //
            // We need to restore the part of the buffer which we overwrote
            // with authentication information.
            //
            if (Connection->ClientSecurityContext.AuthenticationLevel
                != RPC_C_AUTHN_LEVEL_NONE)
                {
                VALIDATE(Connection->ClientSecurityContext.AuthenticationLevel)
                    {
                    RPC_C_AUTHN_LEVEL_PKT_INTEGRITY,
                    RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                    RPC_C_AUTHN_LEVEL_PKT,
                    RPC_C_AUTHN_LEVEL_CONNECT
                    } END_VALIDATE;

                ASSERT(HeaderSize != 0);

                SecurityTrailer = (char  *) Buffer
                     + MaximumFragmentLength - MaxSecuritySize;

                RpcpMemoryCopy(SecurityTrailer, ReservedForSecurity,
                                   MaxSecuritySize);
                }
            }
        }
    else
        {
        if (AdditionalSpaceForSecurity <
            Connection->AdditionalSpaceForSecurity)
            {
            if (UpdateBufferSize(&CurrentBuffer, CurrentBufferLength) != RPC_S_OK)
                {
                CallMutex.Clear();

                return RPC_S_OUT_OF_MEMORY;
                }
            }
        }
    CallMutex.Clear();

    BOOL fFirstSend = (CurrentState == SendingFirstBuffer)
                      && (CurrentOffset == 0);
    //
    // When the last fragment is sent
    // the state changes to WaitingForReply
    //
    Status = SendNextFragment(rpc_request, fFirstSend);

    if (Status != RPC_S_OK)
        {
        VALIDATE(CurrentState)
            {
            InCallbackReply,
            SendingMoreData,
            SendingFirstBuffer,
            WaitingForReply,
            Aborted
            } END_VALIDATE;


         if (CurrentState == InCallbackReply)
             {
             AsyncStatus = Status;
             SendFault(Status, 0);
             Status = RPC_S_OK;
             }
        }

    return Status;
}


RPC_STATUS
OSF_CCALL::SendData (
    IN BUFFER Buffer
    )
{
    RPC_STATUS Status = RPC_S_OK;

    switch (CurrentState)
        {
        case NeedAlterContext:
            //
            // need to send an alter context on the call
            //
            Status = SendAlterContextPDU();
            break;

        case WaitingForAlterContext:
            //
            // We are still waiting for alter-context to complete,
            // we don't have anything to do at this very point.
            // We will start sending data once we receive the
            // response to the alter-context.
            //
            break;

        case SendingMoreData:
        case InCallbackReply:
        case SendingFirstBuffer:
            //
            // the call is still sending the non pipe data
            // we need to finish sending this before
            // we can move on the the next call.
            //
            Status = SendMoreData(Buffer);
            break;

        case Aborted:
            //
            // some failure occured. the call is now in an
            // aborted state
            //
            Status = AsyncStatus;
#if DBG
                PrintToDebugger("RPC: Call in aborted state\n");
#endif
            ASSERT(Status != RPC_S_OK);
            break;

        case Complete:
            //
            // the call is complete, the receive complete before the send could
            // complete, but we should have advanced to the next call when
            // sending the last fragment. We should never get into this state,
            // unless we are talking to a legacy server
            //
            ASSERT(Status == RPC_S_OK);
            ASSERT(Connection->Association->fMultiplex == mpx_no);
            break;

        case Receiving:
            //
            // We should never be in this state unless we are talking to a legacy
            // server
            //
            ASSERT(Connection->Association->fMultiplex == mpx_no);
            // intentional fall through
        case WaitingForReply:
            ASSERT(Status == RPC_S_OK);
            break;

        case InCallbackRequest:
        default:
            //
            // we should never be in these states.
#if DBG
            PrintToDebugger("RPC: Bad call state: %d\n", CurrentState);
#endif
            ASSERT(0);
            Status = RPC_S_INTERNAL_ERROR;
            break;
        }

    return Status;
}


void
OSF_CCALL::ProcessSendComplete (
    IN RPC_STATUS EventStatus,
    IN BUFFER Buffer
    )
/*++
Function Name:ProcessSendComplete

Parameters:

Description:

Returns:

--*/
{
    if (EventStatus == RPC_S_OK)
        {
        EventStatus = SendData(Buffer);
        }

    if (EventStatus != RPC_S_OK)
        {
        if (EventStatus == RPC_P_CONNECTION_CLOSED
            || EventStatus == RPC_P_CONNECTION_SHUTDOWN
            || EventStatus == RPC_P_SEND_FAILED)
            {
            EventStatus = RPC_S_CALL_FAILED;
            }

        Connection->ConnectionAborted(EventStatus);

        //
        // Remove the send reference on the call, CCALL--
        //
        RemoveReference();
        }
}


RPC_STATUS
OSF_CCALL::SendNextFragment (
    IN unsigned char PacketType,
    IN BOOL fFirstSend,
    OUT void **ReceiveBuffer,
    OUT UINT *ReceivedLength
    )
/*++
Function Name:SendNextFragment

Parameters:

Description:

Returns:

--*/
{
    int PacketLength;
    RPC_STATUS Status;
    BOOL LastFragmentFlag;
    rpcconn_common  *pFragment;
    void *SendContext = CallSendContext;
    int MyBufferLength;
    int MyHeaderSize = HeaderSize;
    ULONG Timeout;

    ASSERT(HeaderSize != 0);
    ASSERT(MaxDataLength);
    ASSERT(CurrentBuffer);

    if (UuidSpecified && (CallStack > 1 || PacketType != rpc_request))
        {
        MyHeaderSize -= sizeof(UUID);
        }

    //
    // Prepare the fragment
    //
    if (CurrentBuffer == LastBuffer
        && CurrentBufferLength <= MaxDataLength)
        {
        PacketLength = CurrentBufferLength + MyHeaderSize + MaxSecuritySize;
        LastFragmentFlag = 1;

        if (CurrentState != InCallbackReply)
            {
            ASSERT((CurrentState == SendingFirstBuffer)
                   || (CurrentState == SendingMoreData)
                   || (CurrentState == Aborted));

            CurrentState = WaitingForReply;

            if (Connection->fExclusive == 0)
                {
                //
                // This async send will complete on the connection
                // and the connection will free the buffer
                //
                SendContext = Connection->u.ConnSendContext;
                Connection->BufferToFree = ActualBuffer(CurrentBuffer);
                }
            }
        }
    else
        {
        PacketLength =  MaximumFragmentLength;
        LastFragmentFlag = 0;

        if (CurrentBufferLength == MaxDataLength
            && CurrentState == SendingFirstBuffer)
            {
            CurrentState = SendingMoreData;
            }
        }

    pFragment = (rpcconn_common  *)
            ((char  *) CurrentBuffer + CurrentOffset - MyHeaderSize);

    ConstructPacket(pFragment,
                    PacketType,
                    PacketLength);

    if (fFirstSend)
        {
        pFragment->pfc_flags |= PFC_FIRST_FRAG;
        }

    if ( PacketType == rpc_request )
        {
        if (UuidSpecified && (pAsync || CallStack == 1))
            {
            pFragment->pfc_flags |= PFC_OBJECT_UUID;
            RpcpMemoryCopy(((unsigned char  *) pFragment)
                    + sizeof(rpcconn_request),
                    &ObjectUuid,
                    sizeof(UUID));
            }

        if (fFirstSend && AllocHint)
            ((rpcconn_request  *) pFragment)->alloc_hint = AllocHint;
        else
            ((rpcconn_request  *) pFragment)->alloc_hint = CurrentBufferLength;
        ((rpcconn_request  *) pFragment)->p_cont_id
            = GetSelectedBinding()->GetOnTheWirePresentationContext();
        ((rpcconn_request  *) pFragment)->opnum = (unsigned short) ProcNum;
        }
    else
        {
        // we always use CurrentBufferLength for the alloc hint in the non-request
        // case because the non-request case is for callbacks only, and they
        // don't use pipes. In the non-pipe case CurrentBufferLength is accurate
        // as the alloc hint.
        ((rpcconn_response  *) pFragment)->alloc_hint = CurrentBufferLength;
        ((rpcconn_response  *) pFragment)->p_cont_id
            = GetSelectedBinding()->GetOnTheWirePresentationContext();
        ((rpcconn_response  *) pFragment)->alert_count = 0;
        ((rpcconn_response  *) pFragment)->reserved = 0;
        }

    pFragment->call_id = CallId;

    MyBufferLength = CurrentBufferLength;

    if (Connection->fExclusive)
        {
        Timeout = GetBindingHandleTimeout(BindingHandle);

        if (LastFragmentFlag == 0)
            {
            CurrentOffset += MaxDataLength;
            CurrentBufferLength -= MaxDataLength;
            if (UuidSpecified && (CallStack > 1 || PacketType != rpc_request))
                {
                CurrentOffset += sizeof(UUID);
                CurrentBufferLength -= sizeof(UUID);
                }
            ASSERT(((long)CurrentBufferLength) >= 0);
            }
        else
            {
            CurrentBufferLength = 0;
            }
        }
    else
        Timeout = INFINITE;

    if (ReceiveBuffer)
        {
        *ReceiveBuffer = NULL;
        }

#ifdef _BUILD_WITH_DELAYS_
    // Useful for catching race conditions where buffer being sent gets freed
    // in async paths.
    Sleep(100);
#endif

    Status = Connection->SendFragment (
                           pFragment,
                           this,
                           LastFragmentFlag,
                           MyHeaderSize,
                           MaxSecuritySize,
                           MyBufferLength,
                           MaximumFragmentLength,
                           ReservedForSecurity,
                           !(Connection->fExclusive),
                           SendContext,
                           Timeout,
                           ReceiveBuffer,
                           ReceivedLength);

    if (ReceiveBuffer && *ReceiveBuffer)
        {
        CurrentBufferLength = 0;
        }


    return Status;
}


RPC_STATUS
OSF_CCALL::ProcessResponse (
    IN rpcconn_response *Packet,
    IN PRPC_MESSAGE Message,
    OUT BOOL *pfSubmitReceive
    )
/*++
Function Name:ProcessResponse

Parameters:

Description:
    Process the response data. The first buffer is placed on the buffer queue
    only after alloc_hint bytes have been received.

Returns:

--*/
{
    RPC_STATUS Status;

    //
    // We don't need to look at alloc_hint for the response PDUs
    // we can simply queue up the buffers. When we get the last one,
    // we'll coalesce them for for the non pipe case. For the pipe case,
    // we will progressively give the buffers to the stub.
    //

    CallMutex.Request();

    if (QueueBuffer(Message->Buffer,
                    Message->BufferLength))
        {
        CallFailed(RPC_S_OUT_OF_MEMORY);
        CallMutex.Clear();

        return RPC_S_OUT_OF_MEMORY;
        }

    if (COMPLETE(Message))
        {
        CurrentState = Complete;

        // If a receive-complete notification has been armed and
        // there is a buffer that has not yet been given to NDR, 
        // we need to issue a notification before
        // completing the call.
        //
        // We do not want to issue the notification if the received buffer
        // has zero length since there is nothing to give NDR.
        if (NeededLength > 0 && RcvBufferLength > 0)
            {
            // There is no need to disarm the notification since there
            // will be no more pipe buffers received.

            IssueNotification(RpcReceiveComplete);
            }

        AsyncStatus = RPC_S_OK;
        CallMutex.Clear();

        if (Connection->Association->fMultiplex == mpx_no
            && fOkToAdvanceCall())
            {
            //
            // In the multiplexed case, the call is advanced
            // when the send completes
            //
            Connection->AdvanceToNextCall();
            }

        // For async out-pipe we need to wait for the user to retrieve the data
        // before comleting the call.
        // When the pipe is drained, NdrCheckAsyncPipeStatus will return RPC_X_INVALID_PIPE_OBJECT.
        //
        // For async in-pipe we need to wait issuing the call-complete notification untill we know
        // that the client has processed the send-complete notification for the last
        // non-null push.  When the client has done so, it will do a null push and the runtime
        // will do the last send.
        if (GetIsAsyncPipeCallFlag())
            {
            long PipeStatus;

            while (TRUE)
                {
                Status = NdrCheckAsyncPipeStatus((char *)pAsync, &PipeStatus);
                // Issue notification when the last send is done and the pipe has been drained.
                // We know that NdrCheckAsyncPipeStatus has been called in the past and returned
                // successfully since IsAsyncPipeCallFlag is set, therefore RPC_X_INVALID_PIPE_OBJECT
                // should be returned iff NDR is done with pipes.
                if (fLastSendComplete && Status == RPC_X_INVALID_PIPE_OBJECT)
                    break;

                PauseExecution(20); 
                }
            }

        IssueNotification();
        }
    else
        {
        if (pAsync == 0)
            {
            if (BufferQueue.Size() >= 4
                && pfSubmitReceive)
                {
                fPeerChoked = 1;
                *pfSubmitReceive = 0;
                }

            CallMutex.Clear();

            SyncEvent.Raise();
            }
        else
            {
            // This path races with the issuing of notification in CallFailed.
            // There, the notification will be issued iff fLastSendComplete.
            // Therefore we should issue notification here iff the call has not been
            // aborted or !fLastSendComplete.  This way we avoid issuing two notifications.
            if (CurrentState != Aborted || !fLastSendComplete)
                {
                // Issue receive-complete notification if we have enough data
                // to satisfy the NeededLength requirement.
                if (NeededLength > 0
                    && RcvBufferLength >= NeededLength)
                    {
                    // Disarm the notificaiton.
                    NeededLength = 0;
                    
                    IssueNotification(RpcReceiveComplete);
                    }
                else
                    {
                    if (GetIsAsyncPipeCallFlag()
                        && BufferQueue.Size() >= 4
                        && pfSubmitReceive)
                        {
                        fPeerChoked = 1;
                        *pfSubmitReceive = 0;
                        }
                    }
                }

            CallMutex.Clear();
            }
        }

    return RPC_S_OK;
}


RPC_STATUS
OSF_CCALL::SendAlterContextPDU (
    )
/*++
Function Name:SendAlterContextPDU

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    ULONG Timeout;
    BOOL fBindingHandleTimeoutUsed;

    //
    // We try to create a thread to go down and listen
    //
    Status = BindingHandle->TransInfo->CreateThread();

    VALIDATE(Status)
        {
        RPC_S_OK,
        RPC_S_OUT_OF_MEMORY,
        RPC_S_OUT_OF_THREADS
        } END_VALIDATE;

    CurrentState = WaitingForAlterContext;

    ASSERT(Connection->Association->AssocGroupId);

    Timeout = GetEffectiveTimeoutForBind(
        BindingHandle,
        &fBindingHandleTimeoutUsed);

    //
    // Send the alter-context PDU
    //
    Status = Connection->SendBindPacket(
                            BindingHandle,
                            FALSE,
                            this,
                            Connection->Association->AssocGroupId,
                            rpc_alter_context,
                            Timeout
                            );


    if (Status != RPC_S_OK)
        {
        Status = GetStatusForTimeout(BindingHandle, Status, fBindingHandleTimeoutUsed);

        CallFailed(Status);
#if DBG
        PrintToDebugger("RPC: SendAlterContextPDU failed: %d\n", Status);
#endif
        }

    return Status;
}


RPC_STATUS
OSF_CCALL::EatAuthInfoFromPacket (
    IN rpcconn_request  * Request,
    IN OUT UINT  * RequestLength
    )
/*++

Routine Description:

    If there is authentication information in the packet, this routine
    will check it, and perform security as necessary.  This may include
    calls to the security support package.

Arguments:

    Request - Supplies the packet which may contain authentication
        information.

    RequestLength - Supplies the length of the packet in bytes, and
        returns the length of the packet without authentication
        information.

Return Value:

    RPC_S_OK - Everything went just fine.

    RPC_S_ACCESS_DENIED - A security failure of some sort occured.

    RPC_S_PROTOCOL_ERROR - This will occur if no authentication information
        is in the packet, and some was expected, or visa versa.

--*/
{
    RPC_STATUS Status;
    sec_trailer  * SecurityTrailer;
    SECURITY_BUFFER SecurityBuffers[5];
    DCE_MSG_SECURITY_INFO MsgSecurityInfo;
    SECURITY_BUFFER_DESCRIPTOR BufferDescriptor;
    ULONG ReadOnlyFlag;

    if ( Request->common.auth_length != 0 )
        {
        SecurityTrailer = (sec_trailer  *)
                (((unsigned char  *) Request)
                + Request->common.frag_length
                - Request->common.auth_length
                - sizeof(sec_trailer));
        
        if (!IsBufferAlignedOnStructBoundary(SecurityTrailer))
            {
            CORRUPTION_ASSERT(0 && "SecurityTrailer is unaligned");
            return(RPC_S_PROTOCOL_ERROR);
            }

        CORRUPTION_ASSERT(SecurityTrailer->auth_context_id == SecurityContextIdWireRep);

        if ((Connection->ClientSecurityContext.AuthenticationLevel
            == RPC_C_AUTHN_LEVEL_NONE))
            {
            return(RPC_S_PROTOCOL_ERROR);
            }

        if (Connection->GetConnectionSupportHeaderSign() == cshsYes)
            ReadOnlyFlag = SECBUFFER_READONLY_WITH_CHECKSUM;
        else
            ReadOnlyFlag = SECBUFFER_READONLY;

        *RequestLength -= Request->common.auth_length;

        MsgSecurityInfo.SendSequenceNumber =
                Connection->InquireSendSequenceNumber();
        MsgSecurityInfo.ReceiveSequenceNumber =
                Connection->InquireReceiveSequenceNumber();
        MsgSecurityInfo.PacketType = Request->common.PTYPE;

        BufferDescriptor.ulVersion = 0;
        BufferDescriptor.cBuffers = 5;
        BufferDescriptor.pBuffers = SecurityBuffers;

        SecurityBuffers[0].cbBuffer = sizeof(rpcconn_request);
        SecurityBuffers[0].BufferType = SECBUFFER_DATA | ReadOnlyFlag;
        SecurityBuffers[0].pvBuffer = ((unsigned char  *) SavedHeader);

        // Make sure the data buffer length will not become negative.
        ASSERT(*RequestLength >= sizeof(rpcconn_request) + sizeof (sec_trailer));

        SecurityBuffers[1].cbBuffer = *RequestLength
                                      - sizeof(rpcconn_request)
                                      - sizeof (sec_trailer);
        SecurityBuffers[1].BufferType = SECBUFFER_DATA;
        SecurityBuffers[1].pvBuffer = ((unsigned char  *) Request)
                                      + sizeof(rpcconn_request);

        SecurityBuffers[2].cbBuffer = sizeof(sec_trailer);
        SecurityBuffers[2].BufferType = SECBUFFER_DATA | ReadOnlyFlag;
        SecurityBuffers[2].pvBuffer = SecurityTrailer;

        SecurityBuffers[3].cbBuffer = Request->common.auth_length;
        SecurityBuffers[3].BufferType = SECBUFFER_TOKEN;
        SecurityBuffers[3].pvBuffer = SecurityTrailer + 1;

        SecurityBuffers[4].cbBuffer = sizeof(DCE_MSG_SECURITY_INFO);
        SecurityBuffers[4].BufferType = (SECBUFFER_PKG_PARAMS
                                         | SECBUFFER_READONLY);
        SecurityBuffers[4].pvBuffer = &MsgSecurityInfo;

        Status = Connection->ClientSecurityContext.VerifyOrUnseal(
                            MsgSecurityInfo.ReceiveSequenceNumber,
                            Connection->ClientSecurityContext.AuthenticationLevel
                            != RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                            &BufferDescriptor);

        if ( Status != RPC_S_OK )
            {
            ASSERT( (Status == RPC_S_ACCESS_DENIED) ||
                    (Status == ERROR_PASSWORD_MUST_CHANGE) ||
                    (Status == ERROR_PASSWORD_EXPIRED) ||
                    (Status == ERROR_ACCOUNT_DISABLED) ||
                    (Status == ERROR_INVALID_LOGON_HOURS) ||
                    (Status == RPC_S_OUT_OF_MEMORY));

            return(Status);
            }
        *RequestLength -= (sizeof(sec_trailer)
                           + SecurityTrailer->auth_pad_length);
        }
    else
        {
        if ((Connection->ClientSecurityContext.AuthenticationLevel
                        == RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
            || (Connection->ClientSecurityContext.AuthenticationLevel
                        == RPC_C_AUTHN_LEVEL_PKT_PRIVACY))
            {
            return(RPC_S_PROTOCOL_ERROR);
            }
        }

    Connection->IncReceiveSequenceNumber();

    return(RPC_S_OK);
}


void
OSF_CCALL::SendFault (
    IN RPC_STATUS Status,
    IN int DidNotExecute
    )
{
    rpcconn_fault Fault;

    memset(&Fault, 0, sizeof(Fault));

    ConstructPacket((rpcconn_common  *) &Fault,rpc_fault,
                    sizeof(rpcconn_fault));

    if (DidNotExecute)
        Fault.common.pfc_flags |= PFC_DID_NOT_EXECUTE;

    Fault.common.pfc_flags |= PFC_FIRST_FRAG | PFC_LAST_FRAG;
    Fault.p_cont_id = GetSelectedBinding()->GetOnTheWirePresentationContext();
    Fault.status = MapToNcaStatusCode(Status);
    Fault.common.call_id = CallId;

    Connection->TransSend(BindingHandle,
        &Fault,
        sizeof(rpcconn_fault), 
        TRUE,   // fDisableShutdownCheck
        TRUE,   // fDisableCancelCheck
        INFINITE
        );
}

RPC_STATUS
OSF_CCALL::SendCancelPDU(
    )
{
    rpcconn_common CancelPDU;
    RPC_STATUS Status;
    ULONG Timeout;

    ConstructPacket(
                    (rpcconn_common  *) &CancelPDU,
                    rpc_cancel,
                    sizeof(rpcconn_common));

    CancelPDU.call_id = CallId;
    CancelPDU.pfc_flags = PFC_LAST_FRAG | PFC_PENDING_CANCEL;

    Timeout = GetBindingHandleTimeout(BindingHandle);

    Status = Connection->TransSend(BindingHandle,
        &CancelPDU, 
        sizeof(rpcconn_common), 
        TRUE,    // fDisableShutdownCheck
        TRUE,    // fDisableCancelCheck
        Timeout
        );

    if (Status == RPC_P_TIMEOUT)
        {
        Status = RPC_S_CALL_CANCELLED;
        }
    else
        {
        ASSERT(Status != RPC_S_CALL_CANCELLED);
        }

    return Status;
}


RPC_STATUS
OSF_CCALL::SendOrphanPDU (
    )
{
    rpcconn_common Orphan;
    RPC_STATUS Status;
    ULONG Timeout;

    ConstructPacket(
                    (rpcconn_common  *) &Orphan,
                    rpc_orphaned,
                    sizeof(rpcconn_common));

    Orphan.call_id = CallId;
    Orphan.pfc_flags = PFC_FIRST_FRAG | PFC_LAST_FRAG;

    Timeout = GetBindingHandleTimeout(BindingHandle);

    Status = Connection->TransSend(BindingHandle,
        &Orphan, 
        sizeof(rpcconn_common),
        TRUE,    // fDisableShutdownCheck
        TRUE,    // fDisableCancelCheck
        Timeout
        );

    return Status;
}

RPC_STATUS
OSF_CCALL::NegotiateTransferSyntax (
    IN OUT PRPC_MESSAGE Message
    )
{
    // this can only happen for callbacks
    ASSERT(IsCallInCallback());

    // just return the transfer syntax already negotiated in the binding
    Message->TransferSyntax = GetSelectedBinding()->GetTransferSyntaxId();
    return RPC_S_OK;
}

RPC_STATUS
OSF_CCALL::GetBuffer (
    IN OUT PRPC_MESSAGE Message,
    IN UUID *ObjectUuid
    )
/*++

Routine Description:

Arguments:

    Message - Supplies a description containing the length of buffer to be
        allocated, and returns the allocated buffer.

    ObjectUuid - this parameter is ignored

Return Value:

    RPC_S_OK - A buffer of the requested size has successfully been allocated.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available.

--*/
{
    RPC_STATUS Status;

    AssocDictMutex->VerifyNotOwned();

    UpdateObjectUUIDInfo(ObjectUuid);
    Status = GetBufferWithoutCleanup(Message, ObjectUuid);

    // do the cleanup to get regular GetBuffer semantics
    if (Status != RPC_S_OK)
        {
        //
        // We cannot free the call, because an async bind may be
        // in progress. All we should do is remove our ref counts
        // The async bind path holds its own ref count, so
        // we don't need to worry about it
        //
        AsyncStatus = RPC_S_CALL_FAILED_DNE;
        if (Connection->fExclusive == 0)
            {
            // async calls have one more reference
            OSF_CCALL::RemoveReference();
            }

        // We should wait cleaning up the call if we are in a callback.
        // If we clean it up now, then the object will be gone on the return to
        // DispatchCallback and we will AV.
        if (!IsCallInCallback())
            {
            OSF_CCALL::RemoveReference();
            }
        }

    return(Status);
}

RPC_STATUS
OSF_CCALL::GetBufferWithoutCleanup (
    IN OUT PRPC_MESSAGE Message,
    IN UUID *ObjectUuid
    )
{
    RPC_STATUS Status;
    ULONG MaxFrag;
    ULONG NewLength;

    MaxFrag = Connection->MaxFrag;
    ProcNum = Message->ProcNum;

    //
    // In addition to saving space for the request (or response) header
    // and an object UUID, we want to save space for security information
    // if necessary.
    //

    if ((Message->RpcFlags & RPC_BUFFER_PARTIAL)
        && (Message->BufferLength < MaxFrag))
        {
        ActualBufferLength = MaxFrag;
        }
    else
        {
        ActualBufferLength = Message->BufferLength;
        }

    NewLength = ActualBufferLength
                    + sizeof(rpcconn_request)
                    + sizeof(UUID)
                    + (2 * Connection->AdditionalSpaceForSecurity)
                    + SizeVerificationTrailer();

    Status = ActuallyAllocateBuffer(&Message->Buffer,
                                           NewLength);
    if ( Status != RPC_S_OK )
        {
        ASSERT( Status == RPC_S_OUT_OF_MEMORY );
        return Status;
        }

    ASSERT(HeaderSize != 0);
    if (UuidSpecified)
        {
        Message->Buffer = (char  *) Message->Buffer
                                    + sizeof(rpcconn_request)
                                    + sizeof(UUID);
        }
    else
        {
        Message->Buffer = (char  *) Message->Buffer
                                    + sizeof(rpcconn_request);
        }

    return RPC_S_OK;
}

RPC_STATUS
OSF_CCALL::GetBufferDo (
    IN UINT culRequiredLength,
    OUT void  * * ppBuffer,
    IN int fDataValid,
    IN int DataLength
    )
/*++
Function Name:GetBufferDo

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;
    void  *NewBuffer;

    Status = ActuallyAllocateBuffer(&NewBuffer,
                                        culRequiredLength
                                        + sizeof(rpcconn_request)
                                        + sizeof(UUID));
    if (Status)
        return(RPC_S_OUT_OF_MEMORY);

    ASSERT(HeaderSize != 0);
    if (UuidSpecified)
        {
        NewBuffer = (((unsigned char  *) NewBuffer)
                        + sizeof(rpcconn_request))
                        + sizeof(UUID);
        }
    else
        {
        NewBuffer = (((unsigned char  *) NewBuffer)
                        + sizeof(rpcconn_request));
        }

    if (fDataValid)
        {
        RpcpMemoryCopy(NewBuffer, *ppBuffer, DataLength);
        ActuallyFreeBuffer(*ppBuffer);
        }

    *ppBuffer = NewBuffer;

    return(RPC_S_OK);
}

void
OSF_CCALL::FreeBufferDo (
    IN void  *Buffer
    )
/*++
Function Name:FreeBufferDo

Parameters:

Description:

Returns:

--*/
{
    ASSERT(HeaderSize != 0);
    if (UuidSpecified)
        {
        Buffer = (char  *) Buffer  - sizeof(rpcconn_request) - sizeof(UUID);
        }
    else
        {
        Buffer = (char  *) Buffer  - sizeof(rpcconn_request);
        }
    ActuallyFreeBuffer((char  *)Buffer);
}

void
OSF_CCALL::FreeBuffer (
    IN PRPC_MESSAGE Message
    )
/*++
Function Name:FreeBuffer

Parameters:

Description:

Returns:

--*/
{
    if (CallStack == 0)
        {
        if (Message->Buffer != NULL)
            {
            if (CurrentState == Complete)
                {
                ActuallyFreeBuffer((char  *)Message->Buffer-sizeof(rpcconn_response));
                }
            else
                {
                FreeBufferDo(Message->Buffer);
                }
            }

        if (Connection->fExclusive)
            {
            FreeCCall(RPC_S_OK);
            }
        else
            {
            UnregisterCallForCancels();

            // Remove the call reference CCALL--
            RemoveReference();
            }
        }
    else
        {
        if (Message->Buffer != NULL)
            {
            ActuallyFreeBuffer((char  *)Message->Buffer-sizeof(rpcconn_response));
            CurrentBufferLength = 0;
            }
        else
            {
            // Wipe out stale EEInfo that may be sitting in TLS.
            // FreeBuffer may be called as a result of RpcAsyncCompleteCall.
            // In this case it is possible that the call is made on a thread that
            // has never had the RPC TLS inited.
            if (RpcpGetThreadPointer() != NULL)
                {
                RpcpPurgeEEInfo ();
                }

            FreeCCall(RPC_S_OK);
            }
        }
}

void
OSF_CCALL::FreePipeBuffer (
    IN PRPC_MESSAGE Message
    )
/*++
Function Name:FreePipeBuffer

Parameters:

Description:

Returns:

--*/
{
    ASSERT(HeaderSize != 0);
    if (UuidSpecified)
        {
        Message->Buffer = (char  *) Message->Buffer
                                    - sizeof(rpcconn_request) - sizeof(UUID);
        }
    else
        {
        Message->Buffer = (char  *) Message->Buffer
                                    - sizeof(rpcconn_request);
        }

    ActuallyFreeBuffer((char  *)Message->Buffer);
}


RPC_STATUS
OSF_CCALL::ReallocPipeBuffer (
    IN PRPC_MESSAGE Message,
    IN UINT NewSize
    )
/*++
Function Name:ReallocPipeBuffer

Parameters:

Description:

Returns:

--*/
{
    void  *TempBuffer;
    RPC_STATUS Status;
    ULONG SizeToAlloc;
    ULONG MaxFrag = Connection->MaxFrag;

    if (NewSize > ActualBufferLength)
        {
        SizeToAlloc = (NewSize > MaxFrag) ? NewSize:MaxFrag;

        Status = ActuallyAllocateBuffer(&TempBuffer,
                              SizeToAlloc
                              + sizeof(rpcconn_request) + sizeof(UUID)
                              + (2 * Connection->AdditionalSpaceForSecurity));

        if ( Status != RPC_S_OK )
            {
            ASSERT( Status == RPC_S_OUT_OF_MEMORY );
            return(RPC_S_OUT_OF_MEMORY);
            }

        ASSERT(HeaderSize != 0);
        //
        // N.B. Potentially, if we could return ActualBufferLength
        // in NewSize, the stubs can take advantage of that and gain
        // perf.
        //
        if (UuidSpecified)
            {
            TempBuffer = (char  *) TempBuffer
                                        + sizeof(rpcconn_request)
                                        + sizeof(UUID);
            }
        else
            {
            TempBuffer = (char  *) TempBuffer
                                        + sizeof(rpcconn_request);
            }

        if (Message->BufferLength > 0)
            {
            RpcpMemoryCopy(TempBuffer, Message->Buffer,
                                      Message->BufferLength);
            FreePipeBuffer(Message);
            }

        Message->Buffer = TempBuffer;
        ActualBufferLength = SizeToAlloc;
        }

    Message->BufferLength = NewSize;

    return (RPC_S_OK);
}


void
OSF_CCALL::FreeCCall (
    IN RPC_STATUS Status
    )
/*++

Routine Description:

    This routine is used to free a call.

--*/
{
    void  *Buffer;
    UINT BufferLength;
    OSF_BINDING_HANDLE *MyBindingHandle;
    ULONG Timeout;

    ASSERT(BindingHandle != 0);

    // Wait for the IO completion processing if it is being done asyncronously.
    Connection->ConnMutex.Request();

    if (Connection->fExclusive == 0)
        {
        // It is possible that we have already removed this call from
        // the dictionary if we performed an abortive cancel.  Since
        // removal is Idempotent (assuming the CallId doesn't wrap too quickly)
        // we are fine.
        Connection->ActiveCalls.Delete(IntToPtr(CallId));
        }

    Connection->ConnMutex.Clear();

    // At this point no IO completion processing on the call can start because
    // the call is gone from the dict and all active processing has completed.

    LogEvent(SU_CCALL, EV_DELETE, this, NULL, Status, 1, 1);

    //
    // Empty the buffer queue and nuke the buffers
    //
    while (Buffer = BufferQueue.TakeOffQueue(&BufferLength))
        {
        if (InReply)
            {
            ActuallyFreeBuffer((char *) Buffer-sizeof(rpcconn_request));
            }
        else
            {
            FreeBufferDo(Buffer);
            }
        }

    // Check whether OSF_CCONNECTION::ConnectionAborted requested the freeing
    // of LastBuffer.
    if (GetFreeLastBufferFlag())
        {
        ActuallyFreeBuffer(ActualBuffer(LastBuffer));
        LastBuffer = NULL;
        }

    if (Bindings.AvailableBindingsList)
        ReleaseBindingList(Bindings.AvailableBindingsList);
    else
        GetSelectedBinding()->RemoveReference();

    if (RecursiveCallsKey != -1)
        {
        BindingHandle->RemoveRecursiveCall(this);
        }

    //
    // We will not send an Orphan PDU if the call was cancelled
    // This is because, we are going to close the connection anyway
    // When a connection close is received while a call is in progress,
    // it is treated as an orphan
    //
    MyBindingHandle = BindingHandle;
    BindingHandle = 0;


    //
    // N.B. If this call failed with a fatal error, we will nuke the connection
    // and all calls after it.
    //

    //
    // There is a race condition between RpcAsyncCompleteCall and
    // OSF_CCONNECTION::ProcessSendComplete.  It is possible that:
    // 
    // T1: Picks a send-complete notification to process for call C
    // T2: Hits a failure on some connection,
    // T2: shuts down the association,
    // T2: shuts down C's connection, failing C and issuing call-complete for C.
    // T3: pick up the notification and RpcAsyncCompletes C, freeing it.
    //
    // In MaybeAdvanceToNextCall we will grab the ConnMutex.  We will also need to
    // grab it while processing the notification.
    //

    //
    // If its been this long and we are still the current call,
    // we need to advance the call
    //
    Connection->MaybeAdvanceToNextCall(this);

    //
    // release this CCall to the connection
    //
    if (MyBindingHandle)
        Timeout = MyBindingHandle->InqComTimeout();
    else
        Timeout = 0;

    Connection->FreeCCall(this, 
        Status,
        Timeout);
    //
    // The ref count on the binding handle
    // needs to be decremented if the binding handle is still there
    //
    if (MyBindingHandle)
        MyBindingHandle->BindingFree();
    
}

#if 1

RPC_STATUS
OSF_CCALL::Cancel(
    void * ThreadHandle
    )
{
    fCallCancelled = TRUE;
    return RPC_S_OK;
}
#else

RPC_STATUS
OSF_CCALL::Cancel(
    void * Tid
    )
{
    RPC_STATUS Status;
    Cancelled = TRUE;
    Status = I_RpcIOAlerted((OSF_CCONNECTION *)this,(DWORD)Tid);
    return RPC_S_OK;
}
#endif


RPC_STATUS
OSF_CCALL::CancelAsyncCall (
    IN BOOL fAbort
    )
/*++
Function Name:CancelAsyncCall

Parameters:
    fAbort - TRUE: the cancel is abortive, ie, the call completes immediately
                FALSE: a cancel PDU is sent to the server, the call doesn't complete
                until the server returns

Description:

Returns:
    RPC_S_OK: The call was successfully cancelled
    others - an error occured during the cancellation process
--*/
{
    RPC_STATUS Status;

    // The EEInfo that may be sitting on this thread could have
    // nothing to do with the the async call that we are about to cancel.
    RpcpPurgeEEInfo();

    switch (CurrentState)
        {
        case NeedOpenAndBind:
        case NeedAlterContext:
        case WaitingForAlterContext:
            //
            // The call has not yet started
            // fail the call right now
            //

            CallFailed(RPC_S_CALL_CANCELLED);
            break;

        case Aborted:
        case Complete:
            //
            // The call has either failed or has completed
            // we don't need to do anything
            //
            break;

        default:
            //
            // The call is in progress, we need to cancel it.
            //
            if (fAbort)
                {
                SendOrphanPDU();

                Connection->ConnMutex.Request();
                // The call is cancled, we will be issuing call complete notification
                // but first we remove this call from the dictionary.  If we
                // delay this removal till FreeCCalls, then we will break the rule
                // that all calls in the ActiveCalls dictionary must have reference counts.
                // Since the call is cancled, we do not need to look it up any more
                // (for instance in ProcessReceiveComplete
                Connection->ActiveCalls.Delete(IntToPtr(CallId));
                
                Connection->ConnMutex.Clear();

                CallFailed(RPC_S_CALL_CANCELLED);
                }
            else
                {
                return SendCancelPDU();
                }
        }

    return RPC_S_OK;
}

RPC_STATUS 
OSF_CCALL::BindCompleteNotify (
    IN p_result_t *OsfResult, 
    IN int IndexOfPresentationContextAccepted,
    OUT OSF_BINDING **BindingNegotiated
    )
/*++
Function Name:BindCompleteNotify

Parameters:
    OsfResult - The one and only result element that contained acceptance
    IndexOfPresentationContextAccepted - the index of the accepted
        presentation context. Recall that the server indicates acceptance
        by position.
    BindingNegotiated - on success for multiple bindings proposed, the 
        pointer to the OSF binding that the server chose. On failure, or if 
        only one binding is proposed, it is undefined.

Description:
    Examines the accepted context, does a bunch of validity checks, and
    if necessary, fixes the binding which the call will use. If the binding
    is already fixed, it won't touch it.

Returns:
    RPC_S_OK: The acceptance is valid, and the call binding was fixed
    others: error code
--*/
{
    int CurrentBindingIndex;

    if (Bindings.AvailableBindingsList == NULL)
        {
        // only one binding was proposed - it better be accepted
        if (GetSelectedBinding()->CompareWithTransferSyntax(&OsfResult->transfer_syntax) != 0)
            {
            return RPC_S_PROTOCOL_ERROR;
            }

        if (IndexOfPresentationContextAccepted > 0)
            return RPC_S_PROTOCOL_ERROR;
        }
    else
        {
        OSF_BINDING *CurrentBinding = GetBindingList();
        OSF_BINDING *BindingToUse;

        // multiple bindings were proposed - lookup the binding that
        // the server chose, fix our binding and record the server
        // preferences
        BindingToUse = 0;
        CurrentBindingIndex = 0;
        do
            {
            if (CurrentBinding->CompareWithTransferSyntax(&OsfResult->transfer_syntax) == 0)
                {
                BindingToUse = CurrentBinding;
                break;
                }
            CurrentBinding = CurrentBinding->GetNextBinding();
            CurrentBindingIndex ++;
            }
        while (CurrentBinding != 0);

        if (BindingToUse == 0)
            {
            CORRUPTION_ASSERT(0);
            // if the transfer syntax approved is none of the transfer syntaxes we suggested
            // this is a protocol error
            return RPC_S_PROTOCOL_ERROR;
            }

        if (CurrentBindingIndex != IndexOfPresentationContextAccepted)
            {
            CORRUPTION_ASSERT(0);
            // if server did choose a transfer syntax from a different p_cont_elem_t,
            // this is a protocol error
            return RPC_S_PROTOCOL_ERROR;
            }

        // we have suggested multiple syntaxes, and the server picked one of them - record
        // the server preferences. Instead of just setting the preference on the binding
        // the server chose, we need to walk the list, and reset the preferences on the
        // other bindings, to handle mixed cluster scenario case, where the server
        // preferences actually change
        BindingToUse->TransferSyntaxIsServerPreferred();
        CurrentBinding = GetBindingList();
        do
            {
            if (CurrentBinding != BindingToUse)
                CurrentBinding->TransferSyntaxIsNotServerPreferred();

            CurrentBinding = CurrentBinding->GetNextBinding();
            }
        while (CurrentBinding != 0);

        if (Bindings.SelectedBinding == NULL)
            {
            Bindings.SelectedBinding = BindingToUse;
            }
        ReleaseBindingListWithException (Bindings.SelectedBinding, Bindings.AvailableBindingsList);
        Bindings.AvailableBindingsList = 0;

        *BindingNegotiated = BindingToUse;

        DispatchTableCallback = BindingToUse->GetDispatchTable();
        }
    return RPC_S_OK;
}

int OSF_CCALL::SizeVerificationTrailer (
    void
    )
/*++

Routine Description:

    Calculates and returns the size of the verification
    trailer during a sizing pass.

Arguments:

Return Value:

    The additional size of the verification trailer to
    add to the packet size including possible alignment.

--*/
{
    ULONG VTSize = 0;
    BOOL VTHeaderSized = FALSE;
    OSF_BINDING *Binding;

    if (Connection->IsVerificationTrailerNecessary() && (GetIsPipeCallFlag() == FALSE))
        {
        // quick check for cshsDontKnow and cshsUnconfirmedNo
        if (Connection->GetConnectionSupportHeaderSign() < cshsYes)
            {
            // add space for the trailer header and alignment
            VTSize += VTHeaderSize;
            VTHeaderSized = TRUE;

            // add space for the bitmask command 
            VTSize += sizeof(rpc_sec_vt_bitmask);
            }

        Binding = GetSelectedBinding();
        // if the presentation context hasn't been verified, we need to put it
        // in the trailer
        if (Binding->GetPContextVerifiedFlag() == FALSE)
            {
            // add space for the trailer header and alignment if necessary
            if (VTHeaderSized == FALSE)
                {
                VTSize += VTHeaderSize;
                VTHeaderSized = TRUE;
                }

            VTSize += sizeof(rpc_sec_vt_pcontext);
            }

        if (Connection->IsSChannel())
            {
            // add space for the trailer header and alignment if necessary
            if (VTHeaderSized == FALSE)
                {
                VTSize += VTHeaderSize;
                VTHeaderSized = TRUE;
                }

            VTSize += sizeof(rpc_sec_vt_header2);            
            }
        }

    return VTSize;
}

C_ASSERT(sizeof(rpc_sec_verification_trailer) == sizeof(SecVerificationTrailerSignature));

void OSF_CCALL::AddVerificationTrailer (
    IN RPC_MESSAGE *RpcMessage
    )
/*++

Routine Description:

    Adds a verification trailer to the NDR buffer for
    the given RpcMessage.

Arguments:

    RpcMessage - the RPC message we were asked to send.

Return Value:

--*/
{
    rpc_sec_vt_bitmask *vt_bitmask;
    rpc_sec_verification_trailer_command *LastCommand;
    rpc_sec_vt_pcontext *vt_pcontext;
    rpc_sec_vt_header2 *vt_header2;
    unsigned char *CurrentPosition;
    OSF_BINDING *Binding;
    BOOL VTHeaderAdded;
    
    if (Connection->IsVerificationTrailerNecessary() && (GetIsPipeCallFlag() == FALSE))
        {
        CurrentPosition = (unsigned char *)RpcMessage->Buffer + RpcMessage->BufferLength;
        VTHeaderAdded = FALSE;
        LastCommand = NULL;

        // quick check for cshsDontKnow and cshsUnconfirmedNo
        if (Connection->GetConnectionSupportHeaderSign() < cshsYes)
            {
            // We know that state will never go back. That is, state will never go from cshsYes
            // or cshsConfirmedNo to cshsDontKnow or cshsUnconfirmedNo. So if we are in states
            // that add trailer, we must have been in those states during sizing too. Thus we know
            // the size is there

            vt_bitmask = (rpc_sec_vt_bitmask *)AddVerificationTrailerHeader (RpcMessage);
            VTHeaderAdded = TRUE;

            vt_bitmask->command_common.command = SEC_VT_COMMAND_BITMASK_1;
            vt_bitmask->command_common.length = sizeof(rpc_sec_vt_bitmask) - FIELD_OFFSET(rpc_sec_vt_bitmask, bits);
            vt_bitmask->bits = CLIENT_SUPPORT_HEADER_SIGNING;
            LastCommand = (rpc_sec_verification_trailer_command *)vt_bitmask;
            CurrentPosition = (unsigned char *)(vt_bitmask + 1);
            // make sure we are 4 byte aligned after the current position
            ASSERT(PadPtr4(CurrentPosition) == 0);
            }

        Binding = GetSelectedBinding();
        // if the presentation context hasn't been verified, we need to put it
        // in the trailer
        if (Binding->GetPContextVerifiedFlag() == FALSE)
            {
            // We know that state will never go back. That is, state will never go from verified to
            // unverified. Thus if it is not verified here, it wasn't verified during sizing
            // either, which means it must have been sized.
            if (VTHeaderAdded == FALSE)
                {
                vt_pcontext = (rpc_sec_vt_pcontext *)AddVerificationTrailerHeader (RpcMessage);
                VTHeaderAdded = TRUE;
                }
            else
                {
                vt_pcontext = (rpc_sec_vt_pcontext *)CurrentPosition;
                }

            vt_pcontext->command_common.command = SEC_VT_COMMAND_PCONTEXT;
            vt_pcontext->command_common.length = sizeof(rpc_sec_vt_pcontext) - FIELD_OFFSET(rpc_sec_vt_pcontext, InterfaceId);
            RpcpMemoryCopy(&vt_pcontext->InterfaceId, Binding->GetInterfaceId(), sizeof(RPC_SYNTAX_IDENTIFIER));
            RpcpMemoryCopy(&vt_pcontext->TransferSyntax, Binding->GetTransferSyntaxId(), sizeof(RPC_SYNTAX_IDENTIFIER));

            LastCommand = (rpc_sec_verification_trailer_command *)vt_pcontext;
            CurrentPosition = (unsigned char *)(vt_pcontext + 1);
            // make sure we are 4 byte aligned after the current position
            ASSERT(PadPtr4(CurrentPosition) == 0);
            }

        if (Connection->IsSChannel())
            {
            if (VTHeaderAdded == FALSE)
                {
                vt_header2 = (rpc_sec_vt_header2 *)AddVerificationTrailerHeader (RpcMessage);
                VTHeaderAdded = TRUE;
                }
            else
                {
                vt_header2 = (rpc_sec_vt_header2 *)CurrentPosition;
                }

            vt_header2->command_common.command = SEC_VT_COMMAND_HEADER2;
            vt_header2->command_common.length = sizeof(rpc_sec_vt_header2) - FIELD_OFFSET(rpc_sec_vt_header2, PTYPE);

            vt_header2->call_id = CallId;
            vt_header2->Reserved1 = 0;
            vt_header2->Reserved2 = 0;
            vt_header2->drep[0] = NDR_LOCAL_CHAR_DREP | NDR_LOCAL_INT_DREP;
            vt_header2->drep[1] = NDR_LOCAL_FP_DREP;
            vt_header2->drep[2] = 0;
            vt_header2->drep[3] = 0;
            vt_header2->opnum = (USHORT)RpcMessage->ProcNum;
            vt_header2->p_cont_id = Binding->GetOnTheWirePresentationContext();
            vt_header2->PTYPE = rpc_request;

            LastCommand = (rpc_sec_verification_trailer_command *)vt_header2;
            CurrentPosition = (unsigned char *)(vt_header2 + 1);
            // make sure we are 4 byte aligned after the current position
            ASSERT(PadPtr4(CurrentPosition) == 0);
            }

        // was there at least one command?
        if (LastCommand)
            {
            // yes. Mark is as last and update the total length
            LastCommand->command |= SEC_VT_COMMAND_END;
            RpcMessage->BufferLength = (ULONG)(CurrentPosition - (unsigned char *)RpcMessage->Buffer);
            }
        }
}

rpc_sec_verification_trailer_command *OSF_CCALL::AddVerificationTrailerHeader (
    IN RPC_MESSAGE *RpcMessage
    )
/*++

Routine Description:

    Adds the header of the verification trailer to the NDR buffer for
    the given RpcMessage.

Arguments:

    RpcMessage - the RPC message we were asked to send.

Return Value:

    The place to write the first command after the trailer header.

--*/
{
    rpc_sec_verification_trailer *vt;
    unsigned char *LastPosition;

    LastPosition = (unsigned char *)RpcMessage->Buffer + RpcMessage->BufferLength;
    vt = (rpc_sec_verification_trailer *) AlignPtr4(LastPosition);

    // zero out the alignment gap
    RpcpMemorySet(LastPosition, 0, ((unsigned char *)vt) - LastPosition);

    RpcpMemoryCopy(vt, SecVerificationTrailerSignature, sizeof(rpc_sec_verification_trailer));

    return (rpc_sec_verification_trailer_command *)(vt + 1);
}

RPC_STATUS
OSF_CCALL_AVRF::GetBuffer (
    IN OUT PRPC_MESSAGE Message,
    IN UUID *ObjectUuid
    )
/*++

Routine Description:

    Checks is the call is remote.
    If it is, checks whether sufficiently strong security is being used and
    calls the parent's method.

--*/
{
    DCE_BINDING *DceBinding = this->Connection->Association->DceBinding;
    BOOL fWeakSecurity = false;

    //
    // Check to make sure that the security being used is strong enough
    // when making remote calls.
    // We will make this check on each call.
    //
    ASSERT(DceBinding->InqNetworkAddress() != 0);

    if (gfRPCVerifierEnabledWithBreaks
        && DceBinding->InqNetworkAddress()[0] != 0)
        {
        //
        // Check if this is a remote call.
        // This is a "best-effort" check, since in general it is hard to tell if the call is remote.
        // Here, we may decide that some calls are remote when they are actually local.
        //
        // We first check if the server's name begins with the local machine's name.
        // If it does, then we may be using it's name, or it's DNS name, or just happen to be using
        // a very similar server name (which is unlikely).
        // And finally we try a TCP loopback address.
        //

        // The server name is considered to be case-insensitive.
        // We are going to create copies of the names and convert both to lower case
        // before comparing.
        size_t SizeOfComputerName = gLocalComputerNameLength*sizeof(RPC_CHAR);
        size_t SizeOfNetworkAddress = (RpcpStringLength(DceBinding->InqNetworkAddress())+1)*sizeof(RPC_CHAR);
        RPC_CHAR *LowerCaseComputerName = (RPC_CHAR *)alloca(SizeOfComputerName);
        RPC_CHAR *LowerCaseNetworkAddress = (RPC_CHAR *)alloca(SizeOfNetworkAddress);
        memcpy(LowerCaseComputerName, gLocalComputerName, SizeOfComputerName);
        memcpy(LowerCaseNetworkAddress, DceBinding->InqNetworkAddress(), SizeOfNetworkAddress);
        LowerCaseComputerName = RpcpStringToLower(LowerCaseComputerName);
        LowerCaseNetworkAddress = RpcpStringToLower(LowerCaseNetworkAddress);

        // See if the server looks like a remote one.
        if (RpcpStrStr(LowerCaseNetworkAddress, LowerCaseComputerName) != LowerCaseNetworkAddress &&
            RpcpStringCompareInt(DceBinding->InqNetworkAddress(), RPC_CONST_STRING("localhost")) != 0 &&
            RpcpStringCompareInt(DceBinding->InqNetworkAddress(), RPC_CONST_STRING("127.0.0.1")) != 0 &&
            RpcpStringCompareInt(DceBinding->InqNetworkAddress(), RPC_CONST_STRING("\\\\.")) != 0 &&
            RpcpStringCompareInt(DceBinding->InqNetworkAddress(), RPC_CONST_STRING(".")) != 0 )
            {
            UUID *IfUuid = &(((RPC_CLIENT_INTERFACE *)Message->RpcInterfaceInformation)->InterfaceId.SyntaxGUID);

            //
            // Check to make sure strong security is being used.
            //

            // Check if an unsafe protseq is being used.
            if (IsProtseqUnsafe(DceBinding->InqRpcProtocolSequence()))
                {
                RPC_VERIFIER_WARNING_MSG("Possible security threat: Client is calling server over an unsafe protseq",
                                         RPC_VERIFIER_UNSAFE_PROTOCOL);
                fWeakSecurity = true;
                }

            // Make sure that the client uses encryption.
            if (this->Connection->ClientSecurityContext.AuthenticationLevel != RPC_C_AUTHN_LEVEL_PKT_PRIVACY &&
                !IsInterfaceExempt(IfUuid, ALLOW_UNENCRYPTED_REMOTE_ACCESS))
                {
                RPC_VERIFIER_WARNING_MSG("Possible security threat: Client is calling a remote endpoint without RPC_C_AUTHN_LEVEL_PKT_PRIVACY",
                                         RPC_VERIFIER_WEAK_SECURITY_FOR_REMOTE_CALL);
                fWeakSecurity = true;
                }

            // Make sure that the client asks for mutual authentication.
            if(!(this->Connection->ClientSecurityContext.Capabilities & RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH) &&
               !IsInterfaceExempt(IfUuid, ALLOW_NO_MUTUAL_AUTH_REMOTE_ACCESS))
                {
                RPC_VERIFIER_WARNING_MSG("Possible security threat: Client is calling a remote endpoint without mutual authentication",
                                         RPC_VERIFIER_WEAK_SECURITY_FOR_REMOTE_CALL);
                fWeakSecurity = true;
                }

            // If strong security is not being used, print a warning message.
            if (fWeakSecurity)
                {
                DbgPrint("RPC: Protocol: %S NetworkAddress: %S Interface UUID: ",
                         DceBinding->InqRpcProtocolSequence(),
                         DceBinding->InqNetworkAddress());
                PrintUUID(IfUuid);
                DbgPrint("\n");
                RPC_VERIFIER_PRINT_OFFENDING_STACK(3, 4);
                }
            }
        }

    return OSF_CCALL::GetBuffer(Message, ObjectUuid);
}


OSF_CASSOCIATION::OSF_CASSOCIATION (
    IN DCE_BINDING * DceBinding,
    IN TRANS_INFO *TransInfo,
    IN OUT RPC_STATUS  * Status
    ) : AssociationMutex(Status), 
        CallIdCounter(1),
        BindHandleCount(1)
/*++

Routine Description:

    We construct a OSF_CASSOCIATION object in this routine.  This consists
    of initializing some instance variables, and saving the parameters
    away.

Arguments:

    DceBinding - Supplies the binding information for this association.
        Ownership of this data passes to this object.

    RpcClientInfo - Supplies the information necessary to use the loadable
        transport corresponding to the network interface type used by
        this association.

--*/
{
    ALLOCATE_THIS(OSF_CASSOCIATION);

    LogEvent(SU_CASSOC, EV_START, this, 0, 0, 1, 0);

    ObjectType = OSF_CASSOCIATION_TYPE;
    AssocGroupId = 0;

    this->DceBinding = DceBinding;
    this->TransInfo = TransInfo;

    SecondaryEndpoint = 0;
    OpenConnectionCount = 0;
    ConnectionsDoingBindCount = 0;
    fPossibleServerReset = 0;

    ResolverHintInitialized = FALSE;
    DontLinger = FALSE;

    MaintainContext = 0;

    AssociationValid = TRUE;
    FailureCount = 0;
    fMultiplex = mpx_unknown;
    SetReferenceCount(1);
    SavedDrep = 0;

    fIdleConnectionCleanupNeeded = FALSE;

    Linger.fAssociationLingered = FALSE;

    LocalMASet = FALSE;
}

OSF_CASSOCIATION::~OSF_CASSOCIATION (
    )
{
    OSF_BINDING * Binding;
    DictionaryCursor cursor;

    if (ResolverHintInitialized)
        {
        FreeResolverHint(InqResolverHint());
        }

    if (DceBinding != 0)
       {
       delete DceBinding;
       }

    FreeAllBindings();

    if ( SecondaryEndpoint != 0 )
        {
        delete SecondaryEndpoint;
        }

    if (fIdleConnectionCleanupNeeded)
        {
        if (InterlockedDecrement(&PeriodicGarbageCollectItems) == 0)
            {
#if defined (RPC_GC_AUDIT)
            DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) PeriodicGarbageCollectItems dropped to 0\n",
                GetCurrentProcessId(), GetCurrentProcessId());
#endif
            }
        }
}


void
OSF_CASSOCIATION::NotifyConnectionOpen (
    )
/*++
Function Name:NotifyConnectionOpen

Parameters:

Description:

Returns:

--*/
{
    AssociationMutex.VerifyOwned();

    OpenConnectionCount++;
    LogEvent(SU_CASSOC, EV_INC, this, 0, OpenConnectionCount, 1, 1);
}


void
OSF_CASSOCIATION::NotifyConnectionClosed (
    )
/*++

Routine Description:

    This routine is necessary so that we can know when to set the association
    group id back to zero.  We do this when no more connections owned by
    this association can possibly be connected with the server.

--*/
{
    AssociationMutex.Request();

    ASSERT( OpenConnectionCount > 0 );
    OpenConnectionCount -= 1;

    LogEvent(SU_CASSOC, EV_DEC, this, 0, OpenConnectionCount, 1, 1);
    if ( OpenConnectionCount == 0 )
        {
        if (ConnectionsDoingBindCount == 0)
            {
            LogEvent(SU_CASSOC, EV_NOTIFY, this, ULongToPtr(OpenConnectionCount), 0, 1, 0);
            if (IsValid())
                {
                // don't reset invalid associations
                FreeAllBindings();
                ResetAssociation();
                }
            }
        else
            {
            if (IsValid())
                {
                // don't signal possible reset on invalid associations - this will
                // cause more retries
                fPossibleServerReset = TRUE;
                }
            }
        }
    AssociationMutex.Clear();
}

void 
OSF_CASSOCIATION::NotifyConnectionBindInProgress (
    void
    )
{
    AssociationMutex.VerifyOwned();

    ConnectionsDoingBindCount ++;

    LogEvent(SU_CASSOC, EV_INC, this, (PVOID)1, ConnectionsDoingBindCount, 1, 1);
}

void 
OSF_CASSOCIATION::NotifyConnectionBindCompleted (
    void
    )
{
    AssociationMutex.VerifyOwned();

    ConnectionsDoingBindCount --;

    LogEvent(SU_CASSOC, EV_DEC, this, (PVOID)1, ConnectionsDoingBindCount, 1, 1);
    if (ConnectionsDoingBindCount == 0)
        {
        if (OpenConnectionCount == 0)
            {
            LogEvent(SU_CASSOC, EV_NOTIFY, this, ULongToPtr(OpenConnectionCount), ConnectionsDoingBindCount, 1, 0);
            if (IsValid())
                {
                // don't reset invalid associations
                FreeAllBindings();
                ResetAssociation();
                }
            }
        else
            {
            if (IsValid())
                {
                // don't signal possible reset on invalid associations - this will
                // cause more retries
                fPossibleServerReset = FALSE;
                }
            }
        }
}

RPC_STATUS
OSF_CASSOCIATION::ProcessBindAckOrNak (
    IN rpcconn_common  * Buffer,
    IN UINT BufferLength,
    IN OSF_CCONNECTION * CConnection,
    IN OSF_CCALL *CCall,
    OUT ULONG *NewGroupId,
    OUT OSF_BINDING **BindingNegotiated,
    OUT FAILURE_COUNT_STATE *fFailureCountExceeded
    )
/*++

Routine Description:

Arguments:

    Buffer - Supplies the buffer containing either the bind_ack, bind_nak,
        or alter_context_resp packet.

    BufferLength - Supplies the length of the buffer, less the length of
        the authorization information.

    CConnection - Supplies the connection from which we received the packet.

    CCall - the call for which the bind is done.

    NewGroupId - if the bind was successful the new association group id
        will be returned.

    BindingNegotiated - The binding that was negotiated in the case of 
        success and multiple proposed bindings. Undefined if there is
        failure, or if only one binding was proposed.

    fFailureCountExceeded - if supplied, must be FailureCountUnknown. If
        we got bind failure with reason not specified, and we haven't
        exceeded the failure count, it will be set to 
        FailureCountNotExceeded. If we received bind failure with reason
        not specified and the failure count is exceeded, it will be set
        to FailureCountExceeded.

Return Value:

    RPC_S_OK - The client has successfully bound with the server.

    RPC_S_PROTOCOL_ERROR - The packet received from the server does not
        follow the protocol.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to make a
        copy of the secondary endpoint.

    RPC_S_UNSUPPORTED_TRANS_SYN - The transfer syntax supplied by the client
        is not supported by the server.

    RPC_S_UNKNOWN_IF - The interface to which the client wished to bind is not
        supported by the server.

    RPC_S_SERVER_TOO_BUSY - The server is too busy to accept the clients
        bind request.

    RPC_S_UNKNOWN_AUTHN_TYPE - The server does not support the authentication
        type specified by the client.

--*/
{
    rpcconn_bind_ack  *pBindAck;
    rpcconn_bind_nak  *pBindNak;
    p_result_list_t  *pResults;
    int port_spec_plus_pad;
    UINT SecondaryEndpointLength;
    unsigned char  * Pointer;
    RPC_STATUS Status;
    int NumberOfResultElements;
    int i;
    BOOL fConvertEndian;
    int PresentationContextAccepted;

    if (ARGUMENT_PRESENT(fFailureCountExceeded))
        {
        ASSERT(*fFailureCountExceeded == FailureCountUnknown);
        }

    AssociationMutex.VerifyOwned();

    SavedDrep = (Buffer->drep[0]| (Buffer->drep[1] << 8));

    //
    // The common header of the packet has already been validated and data
    // converted, if necessary, by whoever called this method.
    //

    if (   (Buffer->PTYPE == rpc_bind_ack)
        || (Buffer->PTYPE == rpc_alter_context_resp))
        {
        FailureCount = 0;

        //
        // The bind_ack and alter_context_resp packets are the same.
        //

        pBindAck = (rpcconn_bind_ack  *) Buffer;

        //
        // We need to convert the max_xmit_frag, max_recv_frag, and
        // assoc_group_id fields of the packet.
        //

        if ( DataConvertEndian(Buffer->drep) != 0 )
            {
            pBindAck->max_xmit_frag = RpcpByteSwapShort(pBindAck->max_xmit_frag);
            pBindAck->max_recv_frag = RpcpByteSwapShort(pBindAck->max_recv_frag);
            pBindAck->assoc_group_id = RpcpByteSwapLong(pBindAck->assoc_group_id);
            pBindAck->sec_addr_length = RpcpByteSwapShort(pBindAck->sec_addr_length);
            }

        if ( Buffer->PTYPE == rpc_bind_ack )
            {
            if (Buffer->pfc_flags & PFC_CONC_MPX)
                {
                fMultiplex = mpx_yes;
                }

            CConnection->SetMaxFrag(pBindAck->max_xmit_frag,
                                    pBindAck->max_recv_frag);
            }

        BufferLength -= sizeof(rpcconn_bind_ack);
        Pointer = (unsigned char  *) (pBindAck + 1);

        if ( pBindAck->sec_addr_length )
            {
            SecondaryEndpointLength = pBindAck->sec_addr_length;

            //
            // The secondary address length is two bytes long.  We want
            // to align the total of the secondary address length itself,
            // the the secondary address.  Hence, the length of the secondary
            // address and the necessary pad is calculated below.  Think
            // very carefully before changing this piece of code.
            //

            port_spec_plus_pad = SecondaryEndpointLength +
                                 Pad4(SecondaryEndpointLength + 2);

            if ( BufferLength < (UINT) port_spec_plus_pad )
                {
                return(RPC_S_PROTOCOL_ERROR);
                }

            #if 0

            if ( SecondaryEndpoint != 0 )
                {
                delete SecondaryEndpoint;
                }

            SecondaryEndpoint = new unsigned char[SecondaryEndpointLength];

            if ( SecondaryEndpoint == 0 )
                return(RPC_S_OUT_OF_MEMORY);

            RpcpMemoryCopy(SecondaryEndpoint, Pointer, SecondaryEndpointLength);
            if ( DataConvertCharacter(Buffer->drep) != 0 )
                {
                ConvertStringEbcdicToAscii(SecondaryEndpoint);
                }

            #endif

            BufferLength -= port_spec_plus_pad;
            Pointer = Pointer + port_spec_plus_pad;
            }
        else
            {
            Pointer = Pointer + 2;
            BufferLength -= 2;
            }

        pResults = (p_result_list_t *) Pointer;

        // the buffer must have at least as much results as it claims to have
        NumberOfResultElements = pResults->n_results;
        if (BufferLength < sizeof(p_result_list_t) + sizeof(p_result_t) * (NumberOfResultElements - 1))
            {
            return(RPC_S_PROTOCOL_ERROR);
            }

        PresentationContextAccepted = -1;
        fConvertEndian = DataConvertEndian(Buffer->drep);

        // we walk through the list of elements, and see which ones are accepted, and which
        // ones are rejected. If we have at least one accepted, the bind succeeds. If all are
        // rejected, we arbitrarily pick the first error code and declare it the cause of
        // the failure. Note that according to DCE spec, it is not a protocol error to
        // have a bind ack and no presentation contexts accepted
        for (i = 0; i < NumberOfResultElements; i ++)
            {
            if (fConvertEndian)
                {
                pResults->p_results[i].result = RpcpByteSwapShort(pResults->p_results[i].result);
                pResults->p_results[i].reason = RpcpByteSwapShort(pResults->p_results[i].reason);
                ByteSwapSyntaxId(&(pResults->p_results[i].transfer_syntax));
                }

            if ( pResults->p_results[i].result == acceptance )
                {
                // currently we can handle at most one acceptance. Everything else
                // is a protocol error. This is fine since we know only we will
                // propose NDR64, and any third party should accept at most NDR20
                // Our servers will always choose exactly one
                if (PresentationContextAccepted >= 0)
                    return RPC_S_PROTOCOL_ERROR;
                PresentationContextAccepted = i;
                }
            }

        if (PresentationContextAccepted < 0)    // faster version of == -1
            {
            if ( pResults->p_results[0].result != provider_rejection )
                {
                return(RPC_S_CALL_FAILED_DNE);
                }

            switch (pResults->p_results[0].reason)
                {
                case abstract_syntax_not_supported:
                    return(RPC_S_UNKNOWN_IF);

                case proposed_transfer_syntaxes_not_supported:
                    return(RPC_S_UNSUPPORTED_TRANS_SYN);

                case local_limit_exceeded:
                    return(RPC_S_SERVER_TOO_BUSY);

                default:
                    return(RPC_S_CALL_FAILED_DNE);
                }
            }

        // we have bound successfully. Notify the call so that
        // it can fix what binding it will use
        Status = CCall->BindCompleteNotify(
            &pResults->p_results[PresentationContextAccepted],
            PresentationContextAccepted,
            BindingNegotiated);
        if (Status != RPC_S_OK)
            return Status;

        *NewGroupId = pBindAck->assoc_group_id;

        return RPC_S_OK;
        }

    if (Buffer->PTYPE == rpc_bind_nak)
        {
        if (BufferLength < MinimumBindNakLength)
            {
            RpcpErrorAddRecord (EEInfoGCRuntime,
                RPC_S_PROTOCOL_ERROR,
                EEInfoDLOSF_CASSOCIATION__ProcessBindAckOrNak10,
                (ULONG)BufferLength,
                (ULONG)MinimumBindNakLength);

            return(RPC_S_PROTOCOL_ERROR);
            }

        pBindNak = (rpcconn_bind_nak  *) Buffer;

        if ( DataConvertEndian(Buffer->drep) != 0 )
            {
            pBindNak->provider_reject_reason = RpcpByteSwapShort(pBindNak->provider_reject_reason);
            }

        if (pBindNak->common.frag_length > BindNakSizeWithoutEEInfo)
            {
            if (RpcpMemoryCompare(&pBindNak->Signature, BindNakEEInfoSignature, sizeof(UUID)) == 0)
                {
                size_t EEInfoSize = GetEEInfoSizeFromBindNakPacket(pBindNak);

                // Sanity-check the EEInfo length
                if (EEInfoSize > Buffer->frag_length - FaultSizeWithoutEEInfo)
                    {
                    CORRUPTION_ASSERT(0 && "Reported EEInfo size is larger then the packet");
                    }
                else
                    {
                    UnpickleEEInfoFromBuffer(pBindNak->buffer, EEInfoSize);
                    }
                }
            }

        if (   (pBindNak->provider_reject_reason == temporary_congestion)
            || (pBindNak->provider_reject_reason
                    == local_limit_exceeded_reject))
            {
            Status = RPC_S_SERVER_TOO_BUSY;
            }
        else if ( pBindNak->provider_reject_reason
                    == protocol_version_not_supported )
            {
            Status = RPC_S_PROTOCOL_ERROR;
            }
        else if ( pBindNak->provider_reject_reason
                    == authentication_type_not_recognized )
            {
            Status = RPC_S_UNKNOWN_AUTHN_SERVICE;
            }

        else if ( pBindNak->provider_reject_reason
                    == invalid_checksum )
            {
            Status = RPC_S_ACCESS_DENIED;
            }
        else
            {
            FailureCount++;
            if (FailureCount >= 40)
                {
                LogEvent(SU_CASSOC, EV_ABORT, this, 0, FailureCount, 1, 0);
                AssociationValid = FALSE;
                AssociationShutdownError = RPC_S_CALL_FAILED_DNE;
                if (ARGUMENT_PRESENT(fFailureCountExceeded))
                    *fFailureCountExceeded = FailureCountExceeded;
                }
            else if (ARGUMENT_PRESENT(fFailureCountExceeded))
                {
                *fFailureCountExceeded = FailureCountNotExceeded;
                }

            Status = RPC_S_CALL_FAILED_DNE;
            }

        RpcpErrorAddRecord(EEInfoGCRuntime,
            Status,
            EEInfoDLOSF_CASSOCIATION__ProcessBindAckOrNak20,
            (ULONG)pBindNak->provider_reject_reason,
            (ULONG)FailureCount);

        return (Status);
        }

    return(RPC_S_PROTOCOL_ERROR);
}

void
OSF_CASSOCIATION::UnBind (
    )
{
    OSF_CCONNECTION * CConnection;
    BOOL fWillLinger = FALSE;
    DWORD OldestAssociationTimestamp;
    OSF_CASSOCIATION *CurrentAssociation;
    OSF_CASSOCIATION *OldestAssociation = NULL;
    BOOL fEnableGarbageCollection = FALSE;
    DictionaryCursor cursor;
    RPC_CHAR *NetworkAddress;
    long LocalBindHandleCount;

    LogEvent(SU_CASSOC, EV_DEC, this, (PVOID)2, BindHandleCount.GetInteger(), 1, 0);
    LocalBindHandleCount = BindHandleCount.Decrement();

    if (LocalBindHandleCount == 0)
        {
        // we don't linger remote named pipes, as sometimes this results in
        // credentials conflict
        NetworkAddress = DceBinding->InqNetworkAddress();
        if ((OpenConnectionCount > 0) 
             && 
             AssocGroupId 
             && 
             AssociationValid 
             &&
             (!DontLinger)
             &&
             ( 
                (NetworkAddress == NULL)
                ||
                (NetworkAddress[0] == 0)
                ||
                (!DceBinding->IsNamedPipeTransport())
             )
           )
            {
            if (IsGarbageCollectionAvailable())
                {
                if (OsfLingeredAssociations >= MaxOsfLingeredAssociations)
                    {
                    OldestAssociationTimestamp = ~(DWORD)0;

                    // need to walk the dictionary and clean up the oldest item
                    AssociationDict->Reset(cursor);
                    while ((CurrentAssociation = AssociationDict->Next(cursor)) != 0)
                        {
                        if (CurrentAssociation->Linger.fAssociationLingered)
                            {
                            // yes, if the tick count wraps around, we may make a
                            // suboptimal decision and destroy a newer lingering
                            // association. That's ok - it will be a slight perf hit once
                            // every ~47 days - it won't be a bug
                            if (OldestAssociationTimestamp > CurrentAssociation->Linger.Timestamp)
                                {
                                OldestAssociation = CurrentAssociation;
                                }
                            }
                        }

                    // there must be an oldest association here
                    ASSERT(OldestAssociation);
                    AssociationDict->Delete(OldestAssociation->Key);
                    OldestAssociation->Key = -1;

                    // no need to update OsfLingeredAssociations - we removed one,
                    // but we add one, so the balance is the same

                    }
                else
                    {
                    OsfLingeredAssociations ++;
                    ASSERT(OsfLingeredAssociations <= MaxOsfLingeredAssociations);
                    }

                Linger.Timestamp = GetTickCount() + gThreadTimeout;
                Linger.fAssociationLingered = TRUE;

                fWillLinger = TRUE;

                // Add one artifical reference. Once we release the AssocDictMutex,
                // a gc thread can come in and nuke the association, and if we
                // decide that we cannot do garbage collecting below and decide
                // to shutdown the association we may land on a freed object
                // CASSOC++
                OSF_CASSOCIATION::AddReference();
                }
            else
                {
                // good association, but can't linger it, because gc is not available
                // let's see if we can turn it on
                OsfDestroyedAssociations ++;
                fEnableGarbageCollection = CheckIfGCShouldBeTurnedOn(
                    OsfDestroyedAssociations, 
                    NumberOfOsfDestroyedAssociationsToSample,
                    DestroyedOsfAssociationBatchThreshold,
                    &OsfLastDestroyedAssociationsBatchTimestamp
                    );

                }
            }

        if (!fWillLinger)
            {
            AssociationDict->Delete(Key);
            }

        AssocDictMutex->Clear();

        if (!fWillLinger)
            {
            AssociationValid = FALSE;

            LogEvent(SU_CASSOC, EV_STOP, this, 0, 0, 1, 0);
            ShutdownRequested(RPC_S_CALL_FAILED_DNE, NULL);
            }

        AssociationMutex.Clear();

        if (OldestAssociation)
            {
#if defined (RPC_GC_AUDIT)
            int Diff;

            Diff = (int)(GetTickCount() - OldestAssociation->Linger.Timestamp);
            DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) OSF association sync gc'ed %d ms after expire\n",
                GetCurrentProcessId(), GetCurrentProcessId(), Diff);
#endif
            OldestAssociation->AssociationMutex.Request();
            OldestAssociation->AssociationValid = FALSE;

            OldestAssociation->ShutdownRequested(RPC_S_CALL_FAILED_DNE, NULL);

            OldestAssociation->AssociationMutex.Clear();

            OldestAssociation->OSF_CASSOCIATION::RemoveReference();
            }

        if (!fWillLinger)
            {
            // CASSOC--
            OSF_CASSOCIATION::RemoveReference();
            // N.B. If fWillLinger is FALSE, don't touch the this pointer
            // after here
            }

        if (fEnableGarbageCollection)
            {
            // ignore the return value - we'll make a best effort to
            // create the thread, but if there's no memory, that's
            // still ok as the garbage collection thread only
            // provides better perf in this case
            (void) CreateGarbageCollectionThread();
            }

        if (fWillLinger)
            {
            fWillLinger = GarbageCollectionNeeded(TRUE, gThreadTimeout);
            if (fWillLinger == FALSE)
                {
                // uh-oh - we couldn't register for garbage collection - probably
                // extremely low on memory. If nobody has picked us up in the meantime, 
                // delete this association. Otherwise, let it go - somebody is using
                // it and we don't need to worry about gc'ing it. We also need to guard
                // against the gc thread trying to do Delete on this also. If it does
                // so, it will set the Key to -1 before it releases 
                // the mutex - therefore we can check for this. A gc thread cannot
                // completely kill the object as we will hold one reference on it
                AssocDictMutex->Request();
                if ((Linger.fAssociationLingered) && (Key != -1))
                    {
                    OsfLingeredAssociations --;
                    ASSERT(OsfLingeredAssociations >= 0);
                    AssociationDict->Delete(Key);
                    Key = -1;

                    AssociationShutdownError = RPC_S_CALL_FAILED_DNE;
                    AssociationValid = FALSE;

                    AssocDictMutex->Clear();

                    LogEvent(SU_CASSOC, EV_STOP, this, 0, 0, 1, 0);
                    ShutdownRequested(RPC_S_CALL_FAILED_DNE, NULL);

                    // CASSOC--
                    OSF_CASSOCIATION::RemoveReference();

                    }
                else
                    {
                    AssocDictMutex->Clear();
                    }
                }
#if defined (RPC_GC_AUDIT)
            else
                {
                DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) OSF association lingered %X\n",
                    GetCurrentProcessId(), GetCurrentProcessId(), this);
                }
#endif

            // Remove the artifical reference we added above
            // CASSOC--
            OSF_CASSOCIATION::RemoveReference();
            // N.B. don't touch the this pointer after here
            }
        }
    else
        {
        AssocDictMutex->Clear();
        AssociationMutex.Clear();
        }
}


RPC_STATUS
OSF_CASSOCIATION::FindOrCreateOsfBinding (
    IN PRPC_CLIENT_INTERFACE RpcInterfaceInformation,
    IN RPC_MESSAGE *Message,
    OUT int *NumberOfBindings,
    IN OUT OSF_BINDING *BindingsForThisInterface[]
    )
/*++

Routine Description:

    This method gets called to find the osf bindings (a dictionary
    entry) corresponding to the specified rpc interface information.
    The caller of this routine must be holding (ie. requested) the
    association mutex.

Arguments:

    RpcInterfaceInformation - Supplies the interface information for
        which we are looking for an osf binding object.
    Message - supplies the RPC_MESSAGE for this call
    NumberOfBindings - an out parameter that will return the number
        of retrieved bindings
    BindingsForThisInterface - a caller supplied array where the
        found bindings will be placed.

Return Value:

    RPC_S_OK for success, other for failure

--*/
{
    BOOL Ignored[MaximumNumberOfTransferSyntaxes];
    AssociationMutex.VerifyOwned();

    return MTSyntaxBinding::FindOrCreateBinding(RpcInterfaceInformation,
        Message, 
        &Bindings, 
        CreateOsfBinding, 
        CheckOsfBindingForDestruction,
        this,       // CallbackContext
        NumberOfBindings,
        (MTSyntaxBinding **)BindingsForThisInterface, 
        Ignored);
}

BOOL
OSF_CASSOCIATION::DoesBindingForInterfaceExist (
    IN PRPC_CLIENT_INTERFACE RpcInterfaceInformation
    )
/*++

Routine Description:

    Checks if an association supports a binding for this interface.

Arguments:

    RpcInterfaceInformation - Supplies the interface information for
        which we are looking for an osf binding object.

Return Value:

    FALSE if it doesn't. Non-zero if it does.

--*/
{
    OSF_BINDING *Binding;
    DictionaryCursor cursor;
    BOOL fRetVal = FALSE;
    BOOL Result;

    // we can't just ask for the mutex for two reasons:
    // 1. If we are in lsa we can't directly ask for the mutex
    // since we may deadlock. In lsa the security providers can make RPC
    // calls from within the security context establishment routine. If
    // they do, they will hold an association mutex, and ask for the
    // association dict mutex within the inner RPC call. This thread
    // already holds the assoc dict mutex and will ask for the assoc
    // mutex (reverse order) causing a deadlock. 
    // 2. If you have a slow connection and two threads making calls on
    // it, you can have one thread holding the association mutex and
    // waiting for the slow connection to bind for the first time and
    // another thread holding the association dict mutex and waiting
    // here on the first thread. This will be really bad as this means
    // that while the association dict mutex is held, no OSF RPC from
    // this process will go out.
    // Since this routine
    // is used only to shortcut remote endpoint resolution, and as
    // optimization, in lsa, if we can't get the mutex, we forego the
    // optimization and return not found. This will cause caller to
    // do remote endpoint resolution
    Result = AssociationMutex.TryRequest();
    if (!Result)
        return FALSE;

    Bindings.Reset(cursor);
    while ((Binding = Bindings.Next(cursor)) != 0)
        {
        // if we have a binding on the same interface,
        // return TRUE
        if (RpcpMemoryCompare(Binding->GetInterfaceId(), 
            &RpcInterfaceInformation->InterfaceId,
            sizeof(RPC_SYNTAX_IDENTIFIER)) == 0)
            {
            fRetVal = TRUE;
            break;
            }
        }

    AssociationMutex.Clear();

    return fRetVal;
}

void
OSF_CASSOCIATION::ShutdownRequested (
    IN RPC_STATUS AssociationShutdownError OPTIONAL,
    IN OSF_CCONNECTION *ExemptConnection OPTIONAL
    )
/*++

Routine Description:

    Aborts all connections in the association, except the Exempt
    connection, and marks the association as invalid.

Arguments:

    AssociationShutdownError - the error with which the association
        is to be shutdown

    ExemptConnection - an optional pointer to a connection which
        is not to be aborted.

--*/
{
    OSF_CCONNECTION * CConnection;
    DictionaryCursor cursor;
    BOOL fDontKill;
    BOOL fExemptConnectionSkipped = FALSE;

    AssociationMutex.Request();

    if (!ExemptConnection)
        {
        ASSERT(AssociationShutdownError != RPC_S_OK);
        LogEvent(SU_CASSOC, EV_STOP, this, 0, 0, 1, 0);
        // we will abort all connections - the association is invalid
        // mark it as such
        AssociationValid = FALSE;
        this->AssociationShutdownError = AssociationShutdownError;
        }

    ActiveConnections.Reset(cursor);
    while ((CConnection = ActiveConnections.Next(cursor)) != NULL)
        {
        if (CConnection == ExemptConnection)
            {
            fExemptConnectionSkipped = TRUE;
            continue;
            }

        fDontKill = ConnectionAborted(CConnection);

        if (fDontKill == FALSE)
            {
            // CCONN++
            CConnection->AddReference();

            CConnection->DeleteConnection();

            // CCONN--
            CConnection->RemoveReference();
            }
        }

    if (ExemptConnection)
        {
        ASSERT(fExemptConnectionSkipped);
        }

    // if at least one connection wasn't aborted, the association
    // is still valid - it just needs resetting
    if (ExemptConnection)
        ResetAssociation();

    AssociationMutex.Clear();
}

void OSF_CASSOCIATION::FreeAllBindings (
    void
    )
/*++

Routine Description:

    Frees all bindings in the association.

Arguments:

Return Value:

--*/
{
    OSF_BINDING *Binding;
    DictionaryCursor cursor;

    Bindings.Reset(cursor);
    while ((Binding = Bindings.Next(cursor)) != 0)
        {
        // if the lifetime reference is not removed, remove it
        if (Binding->IsCapabilityBitmapReset() == FALSE)
            {
            Binding->ResetCapabilityBitmap();
            Binding->RemoveReference();
            }

        if (Binding->IsRefCountZero())
            DestroyBinding (Binding);
        }
}

void OSF_CASSOCIATION::DestroyBinding (
    IN OSF_BINDING *Binding
    )
/*++

Routine Description:

    Destroys a given binding. At the time we're guaranteed to hold
    the association mutex and the reference count of the binding
    to be 0.

Arguments:

    Binding - binding to destroy and remove from the dictionary

Return Value:

--*/
{
    OSF_CCONNECTION *Connection;
    DictionaryCursor cursor;

    ASSERT(Binding->IsRefCountZero());
    ASSERT(Binding->IsCapabilityBitmapReset());

    // first, walk the connection list and tell all connections that
    // thought they support this presentation context that they don't anymore

    ActiveConnections.Reset(cursor);

    while ((Connection = ActiveConnections.Next(cursor)) != 0)
        {
        // DeletePContext is idempotent - if the corresponding bit is
        // not set, nothing is done.
        Connection->DeletePContext(Binding->GetPresentationContext());
        }

    Bindings.Delete(Binding->GetPresentationContext());

    delete Binding;
}


RPC_STATUS
OSF_CASSOCIATION::ToStringBinding (
    OUT RPC_CHAR  *  * StringBinding,
    IN RPC_UUID * ObjectUuid
    )
/*++

Routine Description:

    We need to convert the binding handle into a string binding.  If the
    binding handle has not yet been used to make a remote procedure
    call, then we can just use the information in the binding handle to
    create the string binding.  Otherwise, we need to ask the association
    to do it for us.

Arguments:

    StringBinding - Returns the string representation of the binding
        handle.

    ObjectUuid - Supplies the object uuid of the binding handle which
        is requesting that we create a string binding.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_MEMORY - We do not have enough memory available to
        allocate space for the string binding.

--*/
{
    *StringBinding = DceBinding->StringBindingCompose(ObjectUuid);
    if (*StringBinding == 0)
        return(RPC_S_OUT_OF_MEMORY);
    return(RPC_S_OK);
}


int
OSF_CASSOCIATION::CompareWithDceBinding (
    IN DCE_BINDING * DceBinding,
    OUT BOOL *fOnlyEndpointDifferent
    )
/*++

Routine Description:

    This routine compares the specified binding information with the
    binding information in the object, this.

Arguments:

    DceBinding - Supplies the binding information to compare against
        the binding information in this.

    fOnlyEndpointDiffers - this output variable will be set to TRUE
        if the result is non-zero and only the endpoint is different.
        It will be set to FALSE if the result is non-zero, and there
        is more than the endpoint different. If this function returns
        0, the fOnlyEndpointDiffers argument is undefined.

Return Value:

    Zero will be returned if the specified binding information,
    DceBinding, is the same as in this.  Otherwise, non-zero will be
    returned.

--*/
{
    int Result;

    if ((Result = this->DceBinding->Compare(DceBinding, fOnlyEndpointDifferent)) != 0)
        return(Result);


    return(0);
}


OSF_CCONNECTION *
OSF_CASSOCIATION::FindIdleConnection (
    void
    )
/*++

Routine Description:

    This routine is used to find a connection which has been idle more
    than the minimum number of seconds specified.  If one is found, it
    is removed from the set of free connections and returned.  The
    association dict mutex will be held when this routine is called.

Arguments:

Return Value:

    If one or more idle connections are found, the first will be returned. Next
    connections can be retrieved by following the u.NextConnection link until
    NULL is reached; if no connections are idle, NULL will be returned.

--*/
{
    OSF_CCONNECTION *CConnection;
    OSF_CCONNECTION *FirstConnection;
    BOOL fMutexTaken;
    BOOL fThreadCreated = 0;
    DictionaryCursor cursor;
    ULONG TickCount;
    ULONG ClientDisconnectTime;
#if defined (RPC_IDLE_CLEANUP_AUDIT)
    ULONG ConnectionsPickedForCleanup = 0;
#endif

    //
    // If we need to maintain context with server, we do not want to close
    // the last open connection.  To be on the safe side, we will make
    // sure that there is at least one free connection.
    //

    fMutexTaken = AssociationMutex.TryRequest();
    if (!fMutexTaken)
        {
#if defined (RPC_IDLE_CLEANUP_AUDIT)
        DbgPrintEx(77, DPFLTR_ERROR_LEVEL, "%d (0x%X) Association mutex busy - aborting\n",
            GetCurrentProcessId(), GetCurrentProcessId());
#endif
        return NULL;
        }

    if ( ActiveConnections.Size() <= 1 )
        {
        if ( (MaintainContext != 0) || (ActiveConnections.Size() == 0))
            {
            ClearIdleConnectionCleanupFlag();
            AssociationMutex.Clear();
            return(0);
            }
        }

    FirstConnection = NULL;

    if (ActiveConnections.Size() > AGGRESSIVE_TIMEOUT_THRESHOLD)
        {
        ClientDisconnectTime = CLIENT_DISCONNECT_TIME2;
        }
    else
        {
        ClientDisconnectTime = CLIENT_DISCONNECT_TIME1;
        }

#if defined (RPC_IDLE_CLEANUP_AUDIT)
    DbgPrintEx(77, DPFLTR_ERROR_LEVEL, "%d (0x%X) Dictionary size for assoc %p is %d. Using timeout %d\n",
        GetCurrentProcessId(), GetCurrentProcessId(), this, ActiveConnections.Size(), ClientDisconnectTime);
#endif

    ActiveConnections.Reset(cursor);
    while ( (CConnection = ActiveConnections.Next(cursor)) != 0 )
        {
        if (CConnection->ThreadId == SYNC_CONN_FREE
            || CConnection->ThreadId == ASYNC_CONN_FREE)
            {
            TickCount = NtGetTickCount();
            if ( CConnection->InquireLastTimeUsed() == 0 )
                {
                CConnection->SetLastTimeUsedToNow();
                }
            // TickCount is ULONG and InquireLastTimeUsed is ULONG
            // If the tick count has wrapped, the result will still
            // be valid. Note that even though it is not technically 
            // impossible that the cleanup is not called for ~47 
            // days, and the next time we're called the connection 
            // looks like just used, a call after that will still
            // timeout and destroy the connection. If the caller has
            // waited for 47 days, it will wait for 30 more seconds.
            else if ( TickCount - CConnection->InquireLastTimeUsed() > ClientDisconnectTime )
                {
                if (!fThreadCreated)
                    {
                    RPC_STATUS Status;

                    Status = TransInfo->CreateThread();
                    if (Status != RPC_S_OK)
                        {
                        AssociationMutex.Clear();
                        return (0);
                        }
                    fThreadCreated = 1;
                    }

                // link all obtained connections on a list
                CConnection->u.NextConnection = FirstConnection;
                FirstConnection = CConnection;

                //
                // This reference will be removed by OsfDeleteIdleConnections, CCONN++
                //
                CConnection->AddReference();

                // remove the connection from the association dictionary so that nobody
                // picks it up
                ConnectionAborted(CConnection);

#if defined (RPC_IDLE_CLEANUP_AUDIT)
                ConnectionsPickedForCleanup ++;
#endif

                // are we up to the last connection?
                if ((ActiveConnections.Size() <= 1) && (MaintainContext != 0))
                    break;
                }
            }
        }

    AssociationMutex.Clear();

#if defined (RPC_IDLE_CLEANUP_AUDIT)
    DbgPrintEx(77, DPFLTR_ERROR_LEVEL, "%d (0x%X) Assoc %p - %d connections picked for cleanup\n",
        GetCurrentProcessId(), GetCurrentProcessId(), this, ConnectionsPickedForCleanup);
#endif

    return(FirstConnection);
}


void
OSF_CCONNECTION::OsfDeleteIdleConnections (
    void
    )
/*++

Routine Description:

    This routine will be called to delete connections which have been
    idle for a certain amount of time.  We need to be careful of a couple
    of things in writing this routine:

    (1) We dont want to grab the global mutex for too long, because this
        will prevent threads which are trying to do real work from doing
        it.

    (2) We dont want to be holding the global mutex when we delete the
        connection.

--*/
{
    OSF_CASSOCIATION *Association;
    OSF_CCONNECTION *FirstConnection;
    OSF_CCONNECTION *CurrentConnection;
    OSF_CCONNECTION *NextConnection;
    BOOL fMutexTaken;
    DictionaryCursor cursor;
    ULONG ClientDisconnectTime;

#if defined (RPC_IDLE_CLEANUP_AUDIT)
    DbgPrintEx(77, DPFLTR_ERROR_LEVEL, "%d (0x%X) Attempting OSF garbage collection\n",
        GetCurrentProcessId(), GetCurrentProcessId());
#endif

    fMutexTaken = AssocDictMutex->TryRequest();
    if (!fMutexTaken)
        {
#if defined (RPC_IDLE_CLEANUP_AUDIT)
        DbgPrintEx(77, DPFLTR_ERROR_LEVEL, "%d (0x%X) Association dict mutex busy - aborting\n",
            GetCurrentProcessId(), GetCurrentProcessId());
#endif
        return;
        }

    AssociationDict->Reset(cursor);
    while ( (Association = AssociationDict->Next(cursor)) != 0 )
        {
        //
        // The architecture says that the client should disconnect
        // connections which have been idle too long.
        //
        FirstConnection = Association->FindIdleConnection();

        if (FirstConnection != 0)
            {
            AssocDictMutex->Clear();

            CurrentConnection = FirstConnection;

            while (CurrentConnection != NULL)
                {
                NextConnection = CurrentConnection->u.NextConnection;

                Association->ConnectionAborted(CurrentConnection);

                CurrentConnection->DeleteConnection();

                // CCONN--
                CurrentConnection->RemoveReference();

                CurrentConnection = NextConnection;
                }

            fMutexTaken = AssocDictMutex->TryRequest();
            if (!fMutexTaken)
                return;
            }
        }
    AssocDictMutex->Clear();
}

RPC_STATUS
OSF_CCONNECTION::TurnOnOffKeepAlives (
    IN BOOL TurnOn,
    IN ULONG Time
    )
/*++

Routine Description:

    Turns on or off keepalives for the given connection

Arguments:

    TurnOn - if non-zero, keep alives will be turned on with
        a value appropriate for this transport. If zero, keep
        alives will be turned off

    Timeout - if TurnOn is not zero, the interval between a response to the last
        keep alive and the next keep alive.  If TurnOn is zero this parameter
        is ignored.  The time scale is in runtime units - 
        RPC_C_BINDING_MIN_TIMEOUT to RPC_C_BINDING_MAX_TIMEOUT

Return Value:

    RPC_S_OK if the transport supports keep alives
    RPC_S_CANNOT_SUPPORT otherwise

--*/
{
    KEEPALIVE_TIMEOUT uTime;
    uTime.RuntimeUnits = Time;

    if (ClientInfo->TurnOnOffKeepAlives)
        {
        // While turning on the keepalive we need to protect the IO
        // against connection closure.
        return ClientInfo->TurnOnOffKeepAlives(TransConnection(),
            TurnOn,
            TRUE,
            tuRuntime,
            uTime,
            5000);
        }
    else
        {
        return RPC_S_CANNOT_SUPPORT;
        }
}

void
OSF_CASSOCIATION::OsfDeleteLingeringAssociations (
    void
    )
/*++

Routine Description:

    Will attempt to clean up lingering conn associations.

Return Value:

--*/
{
    BOOL fMutexTaken;
    OSF_CASSOCIATION *CurrentAssociation;
    OSF_CASSOCIATION *NextAssociation;
    OSF_CASSOCIATION *FirstAssociation;
    DictionaryCursor cursor;
    DWORD CurrentTickCount;
    int Diff;

    // if there are no osf associations, return
    if (!AssociationDict)
        return;

    fMutexTaken = AssocDictMutex->TryRequest();
    if (!fMutexTaken)
        {
        // we couldn't cleanup anything - restore the flag
        if (!GarbageCollectionRequested)
            GarbageCollectionRequested = TRUE;
        return;
        }

    FirstAssociation = NULL;
    CurrentTickCount = GetTickCount();

    // need to walk the dictionary and clean up all associations with
    // expired timeouts
    AssociationDict->Reset(cursor);

    while ((CurrentAssociation = AssociationDict->Next(cursor)) != 0)
        {
        if (CurrentAssociation->Linger.fAssociationLingered)
            {
            // this will work even for wrapped tick count
            Diff = (int)(CurrentTickCount - CurrentAssociation->Linger.Timestamp);
            if (Diff > 0)
                {
#if defined (RPC_GC_AUDIT)
                DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) OSF association gc'ed %d ms after expire\n",
                    GetCurrentProcessId(), GetCurrentProcessId(), Diff);
#endif
                // enlink the expired associations to a list - we'll clean it up
                // later
                CurrentAssociation->NextAssociation = FirstAssociation;
                FirstAssociation = CurrentAssociation;
                AssociationDict->Delete(CurrentAssociation->Key);
                // indicate to the other threads (needed once we release the mutex)
                // that this association is being cleaned up and they cannot clean it up
                CurrentAssociation->Key = -1;
                OsfLingeredAssociations --;

                // Add one artificial reference to the association. This will
                // prevent a thread that is doing unbind and lingered the
                // association, but later found out it couldn't destroy it
                // (see OSF_CASSOCIATION::UnBind) from deleteing the object
                // from underneath us
                // CASSOC++
                CurrentAssociation->OSF_CASSOCIATION::AddReference();
                }
            else
                {
                // this item hasn't expired yet - update the first gc time, and
                // raise the GarbageCollectionRequested flag if necessary
                if ((int)(CurrentAssociation->Linger.Timestamp - NextOneTimeCleanup) < 0)
                    {
                    // there is a race between this thread and threads calling
                    // GarbageCollectionNeeded. Those threads may overwrite the
                    // value we're about to write, which can result in delayed
                    // garbage collection for this value - that's ok.
                    NextOneTimeCleanup = CurrentAssociation->Linger.Timestamp;
                    }

                if (!GarbageCollectionRequested)
                    GarbageCollectionRequested = TRUE;
                }
            }
        }

    AssocDictMutex->Clear();

    // destroy the associations at our leasure
    CurrentAssociation = FirstAssociation;
    while (CurrentAssociation != NULL)
        {
        CurrentAssociation->AssociationMutex.Request();
        NextAssociation = CurrentAssociation->NextAssociation;
        CurrentAssociation->AssociationValid = FALSE;

        CurrentAssociation->ShutdownRequested(RPC_S_CALL_FAILED_DNE, NULL);

        CurrentAssociation->AssociationMutex.Clear();

        // Remove the artificial reference we added above
        // CASSOC--
        CurrentAssociation->OSF_CASSOCIATION::RemoveReference();

        CurrentAssociation->OSF_CASSOCIATION::RemoveReference();
        CurrentAssociation = NextAssociation;
        }
}


int
InitializeRpcProtocolOfsClient (
    )
/*++

Routine Description:

    We perform loadtime initialization necessary for the code in this
    file.  In particular, it means we allocate the association dictionary
    and the association dictionary mutex.

Return Value:

    Zero will be returned if initialization completes successfully;
    otherwise, non-zero will be returned.

--*/
{
    RPC_STATUS Status = RPC_S_OK;

    if (AssocDictMutex == NULL)
        {
        AssocDictMutex = new MUTEX(&Status,
                                   TRUE    // pre-allocate semaphore
                                   );
        if (AssocDictMutex == 0
            || Status != RPC_S_OK)
            {
            delete AssocDictMutex;
            AssocDictMutex = NULL;
            return 1;
            }
        }

    if (AssociationDict == NULL)
        {
        AssociationDict = new OSF_CASSOCIATION_DICT;
        if (AssociationDict == 0)
            {
            delete AssocDictMutex;
            AssocDictMutex = NULL;
            return(1);
            }
        }

    return(0);
}


RPC_STATUS
OsfMapRpcProtocolSequence (
    IN BOOL ServerSideFlag,
    IN RPC_CHAR  * RpcProtocolSequence,
    OUT TRANS_INFO *  *ClientTransInfo
    )
/*++
Routine Description:

    This routine is used to determine whether a given rpc protocol sequence
    is supported, and to get a pointer to the transport interface, so we
    do not have to keep looking it up.

Arguments:

    RpcProtocolSequence - Supplies the rpc protocol sequence.

    A pointer to the transport interface is returned.  This pointer
    must not be dereferenced by the caller.

Return Value:
    RPC_S_OK - The rpc protocol sequence is supported.

    RPC_S_PROTSEQ_NOT_SUPPORTED - The rpc protocol sequence is
    not supported.

    RPC_S_OUT_OF_MEMORY - There is insufficient memory to perform
    the operation.
--*/
{
    RPC_CHAR * DllName;
    RPC_STATUS Status;

    Status= RpcConfigMapRpcProtocolSequence(ServerSideFlag,
                                            RpcProtocolSequence,
                                            &DllName);
    if (Status != RPC_S_OK)
        {
        return Status;
        }

    Status = LoadableTransportInfo(DllName,
                                   RpcProtocolSequence,
                                   ClientTransInfo);
    delete DllName;

    return(Status);
}


BINDING_HANDLE *
OsfCreateBindingHandle (
    )
/*++

Routine Description:

    This routine does exactly one thing: it creates a binding handle of
    the appropriate type for the osf connection protocol module.

Return Value:

    A new binding handle will be returned.  Zero will be returned if
    insufficient memory is available to create the binding handle.

--*/
{
   BINDING_HANDLE * BindingHandle;
   RPC_STATUS Status = RPC_S_OK;

   BindingHandle = new OSF_BINDING_HANDLE(&Status);
   if ( Status != RPC_S_OK )
       {
       delete BindingHandle;
       return(0);
       }
   return(BindingHandle);
}


extern "C" {


RPC_STATUS
OsfTowerConstruct(
    IN char  * ProtocolSeq,
    IN char  * Endpoint,
    IN char  * NetworkAddress,
    OUT unsigned short  * Floors,
    OUT ULONG  * ByteCount,
    OUT unsigned char  *  * Tower
    )
/*++

Routine Description:

    This routine constructs and returns the upper floors of a tower.
    It invokes the appropriate loadable transport and has them construct
    it.

Return Value:


--*/
{
    TRANS_INFO *ClientTransInfo;
    RPC_STATUS Status = RPC_S_OK;

#ifdef UNICODE
    CStackUnicode Pseq;
    USES_CONVERSION;
#else
    RPC_CHAR * Pseq;
#endif

#ifdef UNICODE
    ATTEMPT_STACK_A2W(Pseq, ProtocolSeq);
#else
    Pseq = (RPC_CHAR  * )ProtocolSeq;
#endif

    if (Status == RPC_S_OK)
        {
        Status = OsfMapRpcProtocolSequence( 0,
                                            Pseq,
                                            &ClientTransInfo);
        }

    if (Status == RPC_S_OK)
        {
        Status = ClientTransInfo->InqTransInfo()->TowerConstruct( ProtocolSeq,
                                                                  NetworkAddress,
                                                                  Endpoint,
                                                                  Floors,
                                                                  ByteCount,
                                                                  Tower);
        }

    return(Status);
}


RPC_STATUS
OsfTowerExplode(
    IN BYTE *Floor,
    IN BYTE *UpperBound,
    IN ULONG RemainingFloors,
    OUT char PAPI * PAPI * Protseq, OPTIONAL
    OUT char PAPI * PAPI * Endpoint, OPTIONAL
    OUT char PAPI * PAPI * NWAddress OPTIONAL
    )
/*++

Routine Description:

    This routine accepts upper floors of a tower [Floor 3 onwards]
    It invokes the appropriate loadable transport based on the opcode
    it finds in level 3 to return protocol sequence, endpoint and nwaddress.

    This routine doesn't do the decoding itself - rather it just dispatches
    to the appropriate transport routine.

Return Value:


--*/
{
    RPC_STATUS Status;
    unsigned short TransportId;
    unsigned char  * ProtocolSequence;
    TRANS_INFO *ClientTransInfo;
    CStackUnicode Pseq;
    USES_CONVERSION;

    // first, do some basic verification to make sure we can read this floor
    if (Floor + sizeof(FLOOR_234) - 2 >= UpperBound)
        return EP_S_CANT_PERFORM_OP;

    if (RemainingFloors == 0)
        return EP_S_CANT_PERFORM_OP;

    TransportId = ((PFLOOR_234)Floor)->FloorId;

    ClientTransInfo = GetLoadedClientTransportInfoFromId(TransportId);
    if (ClientTransInfo == 0)
        {
        Status = RpcGetWellKnownTransportInfo(TransportId, Pseq.GetPUnicodeString());

        if (Status != RPC_S_OK)
            {
            Status = RpcGetAdditionalTransportInfo(TransportId, &ProtocolSequence);

            if (Status == RPC_S_OK)
                {
                ATTEMPT_STACK_A2W(Pseq, ProtocolSequence);
                }
            else
                {
                return (Status);
                }
            }

        Status = OsfMapRpcProtocolSequence(0,
                                            Pseq,
                                            &ClientTransInfo);

        if (Status != RPC_S_OK)
            {
            return Status;
            }
        }

    ASSERT(ClientTransInfo != 0);

    Status = ClientTransInfo->InqTransInfo()->TowerExplode(
                                    Floor,
                                    UpperBound,
                                    RemainingFloors,
                                    Protseq,
                                    NWAddress,
                                    Endpoint);

    return(Status);
}

} // extern "C"

void ReleaseBindingListWithException (
    IN OSF_BINDING *ExemptBinding, OPTIONAL
    IN OSF_BINDING *BindingList
    )
/*++

Routine Description:

    Manages the selection of a binding from a list in terms
    of refcounting. This means releasing one refcount for every
    binding except the selected binding.

Arguments:

    ExemptBinding - the binding that was selected. If NULL,
    no binding was selected.

    BindingList - the list of bindings.

Return Value:

--*/
{
    OSF_BINDING *CurrentBinding;
    OSF_BINDING *NextBinding;

    CurrentBinding = BindingList;
    while (CurrentBinding)
        {
        // grab the next binding before we release the refcount
        NextBinding = CurrentBinding->GetNextBinding();
        if (CurrentBinding != ExemptBinding)
            CurrentBinding->RemoveReference();

        CurrentBinding = NextBinding;
        }
}

RPC_STATUS SetAuthInformation (
    IN RPC_BINDING_HANDLE BindingHandle,
    IN CLIENT_AUTH_INFO *AuthInfo
    )
/*++

Routine Description:

    Sets the auth info for a binding handle. Caller must take
    care to pass only OSF binding handles. Transport credentials
    are set, but normal are not (on purpose).

Arguments:

    BindingHandle - the binding handle on which to set auth info.

    AuthInfo - the auth info to set.

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    OSF_BINDING_HANDLE *OsfBindingHandle;
    SEC_WINNT_AUTH_IDENTITY_W *NewAuthIdentity;
    RPC_HTTP_TRANSPORT_CREDENTIALS_W *HttpCredentials;
    RPC_STATUS Status;

    OsfBindingHandle = (OSF_BINDING_HANDLE *)BindingHandle;
    // the only non-trivial piece to copy is the transport credentials
    // since they are encrypted in memory
    if (AuthInfo->AdditionalTransportCredentialsType == RPC_C_AUTHN_INFO_TYPE_HTTP)
        {
        ASSERT(AuthInfo->AdditionalCredentials);
        HttpCredentials = (RPC_HTTP_TRANSPORT_CREDENTIALS_W *)AuthInfo->AdditionalCredentials;
        HttpCredentials = DuplicateHttpTransportCredentials(HttpCredentials);
        if (HttpCredentials == NULL)
            return RPC_S_OUT_OF_MEMORY;

        if (HttpCredentials->TransportCredentials)
            {
            Status = DecryptAuthIdentity(HttpCredentials->TransportCredentials);
            if (Status != RPC_S_OK)
                {
                // on failure the credentials will be wiped out already by
                // DecryptAuthIdentity. Just free the credentials
                FreeHttpTransportCredentials (HttpCredentials);
                return Status;
                }

            // the credentials are not encrypted anymore
            HttpCredentials->Flags &= ~RPC_C_HTTP_FLAG_AUTH_IDENTITY_ENCRYPTED;
            }
        }
    else
        {
        HttpCredentials = NULL;
        }

    Status = OsfBindingHandle->SetAuthInformation(
                                      NULL,
                                      AuthInfo->AuthenticationLevel,
                                      RPC_C_AUTHN_NONE,
                                      AuthInfo->AuthIdentity,
                                      AuthInfo->AuthorizationService,
                                      NULL,     // SecurityCredentials
                                      RPC_C_IMP_LEVEL_IMPERSONATE,
                                      RPC_C_QOS_IDENTITY_STATIC,
                                      RPC_C_QOS_CAPABILITIES_DEFAULT,
                                      TRUE,  // Acquire new credentials
                                      AuthInfo->AdditionalTransportCredentialsType,
                                      HttpCredentials,
                                      NULL
                                      );

    // success or not, we need to wipe out and free the transport credentials (if any)
    if (HttpCredentials)
        {
        WipeOutAuthIdentity (HttpCredentials->TransportCredentials);
        FreeHttpTransportCredentials (HttpCredentials);
        }

    return Status;    
}

RPC_STATUS RPC_ENTRY
I_RpcTransIoCancelled (
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    OUT PDWORD Timeout
    )
/*++
Function Name:I_RpcTransIOCancelled

Parameters:
    TransConnection: The connection on which the thread was partying on, when the
    alert was received.
    Timeout - If the call was cancelled, on return, this param will contain
     the cancel timeout.

Description:
    This function is called by the transport interface, when it notices that an alert has
    been received. This function should only be called when the transport is dealing with
    a sync call.

Returns:
    RPC_S_OK: The call was cancelled
    RPC_S_NO_CALL_ACTIVE: no call was cancelled
    others - If a failure occured.
--*/
{
    THREAD *ThreadInfo = RpcpGetThreadPointer();

    ASSERT(ThreadInfo != 0);
    if (ThreadInfo->GetCallCancelledFlag() == 0)
        {
        return RPC_S_NO_CALL_ACTIVE;
        }

    return InqTransCConnection(ThisConnection)->CallCancelled(Timeout);
}


unsigned short RPC_ENTRY
I_RpcTransClientMaxFrag (
    IN RPC_TRANSPORT_CONNECTION ThisConnection
    )
/*++

Routine Description:

    The client side transport interface modules will use this routine to
    determine the negotiated maximum fragment size.

Arguments:

    ThisConnection - Supplies the connection for which we are returning
    the maximum fragment size.

--*/
{
   return (unsigned short) InqTransCConnection(ThisConnection)->InqMaximumFragmentLength();
}


BUFFER RPC_ENTRY
I_RpcTransConnectionAllocatePacket(
    RPC_TRANSPORT_CONNECTION ThisConnection,
    UINT Size
    )
/*++
Function Name:I_RpcTransConnectionAllocatePacket

Parameters:

Description:

Returns:

--*/
{
    return(RpcAllocateBuffer(Size));
}

void RPC_ENTRY
I_RpcTransConnectionFreePacket(
    RPC_TRANSPORT_CONNECTION ThisConnection,
    BUFFER Ptr
    )
/*++
Function Name:I_RpcTransConnectionFreePacket

Parameters:

Description:

Returns:

--*/
{
    RpcFreeBuffer(Ptr);
}

RPC_STATUS RPC_ENTRY
I_RpcTransConnectionReallocPacket(
    IN RPC_TRANSPORT_CONNECTION ThisConnection,
    IN BUFFER *ppBuffer,
    IN UINT OldSize,
    IN UINT NewSize
    )
/*++
Function Name:I_RpcTransConnectionReallocPacket

Parameters:

Description:

Returns:

--*/
{
    // We may be truncationg buffers using this function
    // when running with corruption injection.
    // In that case NewSize < OldSize and we should not assert.
    CORRUPTION_ASSERT(NewSize > OldSize);

    PVOID Buffer = RpcAllocateBuffer(NewSize);

    if (Buffer)
        {

        if (OldSize)
            {
            // When expanding the buffer: OldSize<NewSize and we must copy over OldSize bytes.
            // When truncating the buffer: NewSize<OldSize and we must copy over NewSize bytes.
            RpcpMemoryCopy(Buffer, *ppBuffer, min(OldSize, NewSize));
            RpcFreeBuffer(*ppBuffer);
            }

        *ppBuffer = Buffer;

        return(RPC_S_OK);
        }

    return(RPC_S_OUT_OF_MEMORY);
}

BOOL RPC_ENTRY
I_RpcTransPingServer (
    IN RPC_TRANSPORT_CONNECTION ThisConnection
    )
{
    #if 0
    RPC_STATUS Status = RPC_S_OK;
    THREAD *ThisThread = ThreadSelf();
    BOOL fRetVal;

    if (ThisThread->fPinging)
        {
        //
        // We are already pinging, it is best to give up
        // on the server
        //
        return FALSE;
        }

    ThisThread->fPinging = 1;
    EVENT ThreadEvent(&Status);
    EVENT WriteEvent(&Status);
    HANDLE hOldThreadEvent, hOldWriteEvent;

    ASSERT(ThisThread);

    if (Status != RPC_S_OK)
        {
        return TRUE;
        }


    hOldWriteEvent = ThisThread->hWriteEvent;
    hOldThreadEvent = ThisThread->hThreadEvent;

    ThisThread->hWriteEvent = WriteEvent.EventHandle;
    ThisThread->hThreadEvent = ThreadEvent.EventHandle;

    fRetVal =  InqTransCConnection(ThisConnection)->PingServer();

    ThisThread->hWriteEvent = hOldWriteEvent;
    ThisThread->hThreadEvent = hOldThreadEvent;
    ThisThread->fPinging = 0;

    return fRetVal;
    #else
    return(FALSE);
    #endif
}

void
I_RpcTransVerifyClientRuntimeCallFromContext(
    void *SendContext
    )
/*++

Routine Description:

    Verifies that the supplied context follows a valid
    runtime client call object.

Arguments:

    SendContext - the context as seen by the transport

Return Value:

--*/
{
    REFERENCED_OBJECT *pObj;

    pObj = (REFERENCED_OBJECT *) *((PVOID *)
                     ((char *) SendContext - sizeof(void *)));
    ASSERT(pObj->InvalidHandle(OSF_CCALL_TYPE | OSF_CCONNECTION_TYPE) == 0);
}

BOOL
I_RpcTransIsClientConnectionExclusive (
    void *RuntimeConnection
    )
/*++

Routine Description:

    Checks whether the supplied runtime connection
    is exclusive.

Arguments:

    RuntimeConnection - the connection to check.

Return Value:

    non-zero if the connection is exclusive. 0 otherwise.

--*/
{
    OSF_CCONNECTION *Connection = InqTransCConnection(RuntimeConnection);
    ASSERT(Connection->InvalidHandle(OSF_CCONNECTION_TYPE) == 0);

    return Connection->IsExclusive();
}


RPC_STATUS RPC_ENTRY
I_RpcBindingInqWireIdForSnego (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char *WireId
    )
/*++

Routine Description:

Arguments:

Return Value:

    The status for the operation is returned.

--*/
{
    OSF_CCALL * Call;

    InitializeIfNecessary();

    Call = (OSF_CCALL *) Binding;

    if (Call->InvalidHandle(OSF_CCALL_TYPE))
        return(RPC_S_INVALID_BINDING);

    return(Call->InqWireIdForSnego(WireId));
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcBindingHandleToAsyncHandle (
    IN RPC_BINDING_HANDLE Binding,
    OUT void **AsyncHandle
    )
{
    OSF_CCALL * Call;

    InitializeIfNecessary();

    Call = (OSF_CCALL *) Binding;

    if (Call->InvalidHandle(OSF_CCALL_TYPE))
        return(RPC_S_INVALID_BINDING);

    return Call->BindingHandleToAsyncHandle(AsyncHandle);
}

RPC_STATUS RPC_ENTRY
I_RpcBindingInqMarshalledTargetInfo (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned long *MarshalledTargetInfoLength,
    OUT unsigned char **MarshalledTargetInfo
    )
/*++

Routine Description:

    Queries the security context for a given binding handle to
    obtain the MarshalledTargetInfo.

Arguments:

    Binding -

    MarshalledTargetInfo - String allocated by the RPC runtime containing
        the marshalled TargetInfo.  The user frees this string.
    
    MarshalledTargetInfoLength - Length of the string allocated by the RPC runtime containing
        the marshalled TargetInfo.

Return Value:

    The status for the operation is returned.

--*/
{
    OSF_CCALL * Call;

    InitializeIfNecessary();

    Call = (OSF_CCALL *) Binding;

    if (Call->InvalidHandle(OSF_CCALL_TYPE))
        return(RPC_S_INVALID_BINDING);

    return(Call->InqMarshalledTargetInfo(MarshalledTargetInfoLength,MarshalledTargetInfo));
}


extern "C"
{

void
I_Trace (
    int IgnoreFirst,
    const char  * IgnoreSecond,
    ...
    )
/*++

Routine Description:

    This is an old routine which is no longer used.  Because it is exported
    by the dll, we need to leave an entry point.

--*/
{
    UNUSED(IgnoreFirst);
    UNUSED(IgnoreSecond);
}

}; // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\pipe.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pipe.h
//
//--------------------------------------------------------------------------

#ifndef __PIPE_HXX
#define __PIPE_HXX

enum receive_states {
        start,
        copy_pipe_elem,
        return_partial_pipe_elem, // also save pipe elem
        return_partial_count, // also save count
        read_partial_count, // also a start state
        read_partial_pipe_elem //also a start state
        } ;

typedef struct {
    void *Buffer ;
    int BufferLength ;
    receive_states CurrentState ;
    char PAPI *CurPointer ;          // current pointer in the buffer
    int BytesRemaining ;      // bytes remaining in current buffer
    int ElementsRemaining ; // elements remaining in current pipe chunk
    DWORD PartialCount ;
    int PartialCountSize ;
    int PartialPipeElementSize ;
    int EndOfPipe ;
    int PipeElementSize ;
    void PAPI *PartialPipeElement ;
    void PAPI *AllocatedBuffer ;
    int BufferSize ;
    int SendBufferOffset ;
    void PAPI *PreviousBuffer ;
    int PreviousBufferSize ;
    HANDLE BindingHandle;
    } PIPE_STATE ;

//
// N.B. this structure is the same as MIDL_ASYNC_STUB_STATE
//
typedef struct async_stub_state {
    void *CallHandle ;
    RPC_STATUS (*CompletionRoutine) (
        PRPC_ASYNC_STATE pAsync,
        void *Reply) ;
    int Length ;
    void *UserData ;
    int State ;
    void *Buffer ;
    int BufferLength ;
    unsigned long Flags ;
    PIPE_STATE PipeState ;
    BOOL (*ReceiveFunction) (
        PRPC_ASYNC_STATE pAsync,
        PRPC_MESSAGE Message) ;
    } RPC_ASYNC_STUB_STATE ;

void I_RpcReadPipeElementsFromBuffer (
    PIPE_STATE PAPI *state,
    char PAPI *TargetBuffer,
    int TargetBufferSize, 
    int PAPI *NumCopied
    ) ;

//states
enum
{
 SEND_COMPLETE,
 SEND_INCOMPLETE
} ;

RPC_STATUS RPC_ENTRY
MyRpcCompleteAsyncCall (
    IN PRPC_ASYNC_STATE pAsync,
    IN void *Reply
    );
    
#define STUB(_x_) ((RPC_ASYNC_STUB_STATE *) (_x_->StubInfo))
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\pipe.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       pipe.cxx
//
//--------------------------------------------------------------------------

#include <precomp.hxx>
#include "pipe.h"

void I_RpcReadPipeElementsFromBuffer (
    PIPE_STATE PAPI *state,
    char PAPI *TargetBuffer,
    int TargetBufferSize, 
    int PAPI *NumCopied
    )
{
    char PAPI *temp, PAPI *temp1 ;
    int size ;
    int totalsize ;

    ASSERT(state->CurrentState == start ||
                 (state->PartialCountSize < sizeof(DWORD) &&
                 state->PartialPipeElementSize < state->PipeElementSize)) ;

    if (TargetBufferSize < state->PipeElementSize)
        {
        return ;
        }

    while (1)
        {
        switch(state->CurrentState)
            {
            case     start:
                // read in an element count
                if (state->BytesRemaining == 0)
                    {
                    return ;
                    }

                // transition: end of src
                if (state->BytesRemaining <sizeof(DWORD))
                    {
                    state->CurrentState = return_partial_count ;
                    break;
                    }

                // transition: scan chunk count
                state->PartialCount = 0 ;
                state->PartialCountSize = 0 ;
                state->PartialPipeElementSize = 0 ;

                state->ElementsRemaining = *((DWORD *) state->CurPointer) ;
#if DBG
                PrintToDebugger("PIPES: <start> ElementsRemainaing: %d\n",
                                        state->ElementsRemaining) ;
#endif

                state->CurPointer +=  sizeof(DWORD) ;
                state->BytesRemaining -= sizeof(DWORD) ;
                if (state->ElementsRemaining == 0)
                    {
                    state->EndOfPipe = 1 ;
                    return ;
                    }
                else
                    {
                    state->CurrentState = copy_pipe_elem ;
                    }
                break;

            case     read_partial_count: // also a start state & final state
                size = sizeof(DWORD) ;
                totalsize = 0 ;
                ASSERT(state->PartialCountSize > 0 && state->PartialCountSize < 4) ;
                ASSERT(state->ElementsRemaining == 0) ;

                temp = (char *) &(state->PartialCount) ;
                temp1 = (char *) &(state->ElementsRemaining) ;

                for (;state->PartialCountSize;
                    state->PartialCountSize--, size--, totalsize++)
                    {
                     *temp1++ = *temp++ ;
                    }

                for (;size && state->BytesRemaining;
                        size--,state->BytesRemaining--, totalsize++)
                    {
                    *temp1++ = *state->CurPointer++ ;
                    }

#if DBG
                PrintToDebugger("PIPES: <read_partial_count>ElementsRemainaing: %d\n",
                                        state->ElementsRemaining) ;
#endif

                if (size == 0)
                    {
                    state->CurrentState = copy_pipe_elem ;
                    }
                else
                    {
                    // copy the stuff back into Partial count
                    // and keep it around for the next call
                    // the next time around, we'll end up in the same
                    // state
                    temp = (char *) &(state->PartialCount) ;
                    temp1 = (char *) &(state->ElementsRemaining) ;

                    ASSERT(totalsize < sizeof(DWORD)) ;

                    for (;totalsize; totalsize--, state->PartialCountSize++)
                        {
                        *temp++ = *temp1++ ;
                        }

                    return ;
                    }
                break;

            case     read_partial_pipe_elem: //also a start state
                ASSERT(state->PartialPipeElementSize > 0 &&
                             state->PartialPipeElementSize < state->PipeElementSize) ;

                if (TargetBufferSize < state->PipeElementSize)
                    {
                    // this is not an error
                    return ;
                    }

                size = state->PipeElementSize ;

                if (state->BytesRemaining >= size-state->PartialPipeElementSize)
                    {
                    temp = (char *) state->PartialPipeElement ;
    
                    for (;state->PartialPipeElementSize;
                        state->PartialPipeElementSize--, size--,
                        TargetBufferSize--)
                        {
                         *TargetBuffer++ = *temp++ ;
                        }
    
                    for (;size && state->BytesRemaining;
                            size--, state->BytesRemaining--, 
                            TargetBufferSize--)
                        {
                        *TargetBuffer++ = *state->CurPointer++ ;
                        }

                    state->CurrentState = copy_pipe_elem ;
                    *NumCopied += 1 ;
                    }
                else
                    {
                    // copy the stuff back into partial pipe buffer
                    // and keep it around for the next call
                    // the next time around, we'll end up in the same
                    // state
                    temp = (char *) state->PartialPipeElement+
                               state->PartialPipeElementSize ;
                    
                    for (;state->BytesRemaining; state->BytesRemaining--,
                         state->PartialPipeElementSize++)
                        {
                        *temp++ = *state->CurPointer++ ;
                        }

                    return ;
                    }
                break;

            case     copy_pipe_elem: // also a start state
                if (state->BytesRemaining >= state->PipeElementSize)
                    {
                    if (TargetBufferSize >= state->PipeElementSize)
                        {
                        for (size = state->PipeElementSize; size;
                                size--, TargetBufferSize--, state->BytesRemaining--)
                            {
                            *TargetBuffer++ = *state->CurPointer++ ;
                            }

                        state->ElementsRemaining-- ;
                        *NumCopied += 1 ;

                        if (state->ElementsRemaining == 0)
                            {
                            state->CurrentState = start ;
                            if (TargetBufferSize < state->PipeElementSize)
                                {
                                return ;
                                }
                            }
                        }
                    else
                        {
                        // end of target buffer
                        // return the appropriate count
                        return ;
                        }
                    }
                else
                    {
                    if (state->BytesRemaining)
                        {
                        state->CurrentState = return_partial_pipe_elem ;
                        }
                    else
                        {
                        return ;
                        }
                    }
                break;

            case     return_partial_pipe_elem: // also save pipe elem
                ASSERT(state->BytesRemaining < state->PipeElementSize) ;

                state->PartialPipeElementSize = 0;

                for (temp = (char *) state->PartialPipeElement; state->BytesRemaining;
                    state->BytesRemaining--, state->PartialPipeElementSize++)
                    {
                    *temp++ = *state->CurPointer++ ;
                    }
                state->CurrentState = read_partial_pipe_elem ;
                return;

            case     return_partial_count: // also save count
                state->PartialCountSize = 0 ;
                ASSERT(state->BytesRemaining < sizeof(DWORD)) ;

                for (temp = (char *) &(state->PartialCount); state->BytesRemaining;
                    state->BytesRemaining--, state->PartialCountSize++)
                    {
                    *temp++ = *state->CurPointer++ ;
                    }
                state->CurrentState = read_partial_count ;
                return;

            default:
                ASSERT(0) ;
                break;
            }
        }
}

RPC_STATUS RPC_ENTRY
MyRpcCompleteAsyncCall (
    IN PRPC_ASYNC_STATE pAsync,
    IN void *Reply
    )
/*++
Function Name:MyRpcCompleteAsyncCall
    This is function is used by the bvts, the real stuff will call
    RpcCompleteAsyncCall. 
    
Parameters:

Description:

Returns:

--*/
{
    return STUB(pAsync)->CompletionRoutine (pAsync, Reply) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\protbind.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1990 - 1999
//
//  File:       ProtBind.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

File: ProtBind.cxx

Description:

    The implementation of the classes that support the binding process for 
    connection oriented and local.

History :

kamenm     10-01-00    Cloned from other files with a face lift and few stitches added

-------------------------------------------------------------------- */

#include <precomp.hxx>
#include <ProtBind.hxx>

// the following lookup table uses the least significant byte of
// SyntaxGUID.Data4[0]. It is 0xF for NDR20, 0x3 for NDR64, and
// 0x5 for NDRTest
const int SyntaxBindingCapabilitiesLookup[0x10] = {
    MTSyntaxBinding::SyntaxBindingCapabilityInvalid,     // 0
    MTSyntaxBinding::SyntaxBindingCapabilityInvalid,     // 1
    MTSyntaxBinding::SyntaxBindingCapabilityInvalid,     // 2
    MTSyntaxBinding::SyntaxBindingCapabilityNDR64,       // 3 - NDR64
    MTSyntaxBinding::SyntaxBindingCapabilityInvalid,     // 4
    MTSyntaxBinding::SyntaxBindingCapabilityNDRTest,     // 5 - NDRTest
    MTSyntaxBinding::SyntaxBindingCapabilityInvalid,     // 6
    MTSyntaxBinding::SyntaxBindingCapabilityInvalid,     // 7
    MTSyntaxBinding::SyntaxBindingCapabilityInvalid,     // 8
    MTSyntaxBinding::SyntaxBindingCapabilityInvalid,     // 9
    MTSyntaxBinding::SyntaxBindingCapabilityInvalid,     // 0xA
    MTSyntaxBinding::SyntaxBindingCapabilityInvalid,     // 0xB
    MTSyntaxBinding::SyntaxBindingCapabilityInvalid,     // 0xC
    MTSyntaxBinding::SyntaxBindingCapabilityInvalid,     // 0xD
    MTSyntaxBinding::SyntaxBindingCapabilityInvalid,     // 0xE
    MTSyntaxBinding::SyntaxBindingCapabilityNDR20        // 0xF - NDR20
    };


RPC_STATUS 
MTSyntaxBinding::FindOrCreateBinding (
    IN PRPC_CLIENT_INTERFACE RpcInterfaceInformation,
    IN RPC_MESSAGE *Message,
    IN SIMPLE_DICT *BindingsDict,
    IN CreateBindingFn CreateBinding,
    IN CheckBindingForDestructionFn CheckBinding, OPTIONAL
    IN void *CallbackContext, OPTIONAL
    OUT int *NumberOfBindings,
    IN OUT MTSyntaxBinding *BindingsForThisInterface[],
    IN OUT BOOL BindingCreated[]
    )
/*++

Routine Description:

    This method gets called to find the bindings (a dictionary
    entry) corresponding to the specified rpc interface information.
    The caller of this routine is responsible for synchronization

Arguments:

    RpcInterfaceInformation - Supplies the interface information for
        which we are looking for an osf binding object.

    Message - supplies the RPC_MESSAGE for this call

    BindingsDict - the dictionary of available bindings (and where
        to put created bindings)

    CreateBinding - a callback function for creating a binding

    CheckBinding - a callback function to detect stale bindings and
        to destroy them.

    CallbackContext - an optional context to be supplied to the CheckBinding
        callback.

    NumberOfBindings - an out parameter that will return the number
        of retrieved bindings

    BindingsForThisInterface - a caller supplied array where the
        found bindings will be placed.

    BindingCreated - a caller supplied array of the same size as
        BindingsForThisInterface where this function will record
        which binding was created and which was found.

Return Value:

    RPC_S_OK for success, other for failure

--*/
{
    MTSyntaxBinding *Binding;
    DictionaryCursor cursor;
    unsigned int i;
    ULONG NumberOfTransferSyntaxes;
    MIDL_SYNTAX_INFO *SyntaxInfoArray;
    int NextBindingToBeReturned;
    RPC_STATUS Status;
    BOOL fHasMultiSyntaxes;
    TRANSFER_SYNTAX_STUB_INFO *CurrentTransferInfo;
    int ClientPreferredTransferSyntax;
    MTSyntaxBinding *CurrentBinding;
    int CapabilitiesBitmap;
    unsigned char CurrentTransferInfoLookupValue;
    int CurrentCapability;
    BOOL IsBindingDestroyed;

    if ((RpcInterfaceInformation->Length != sizeof(RPC_CLIENT_INTERFACE)) &&
        (RpcInterfaceInformation->Length != NT351_INTERFACE_SIZE))
        {
        return RPC_S_UNKNOWN_IF;
        }

    if (DoesInterfaceSupportMultipleTransferSyntaxes(RpcInterfaceInformation))
        {
        Status = NdrClientGetSupportedSyntaxes (RpcInterfaceInformation,
            &NumberOfTransferSyntaxes, &SyntaxInfoArray);
        if (Status != RPC_S_OK)
            return Status;

        ASSERT(NumberOfTransferSyntaxes > 0);
        ASSERT(SyntaxInfoArray != NULL);

        fHasMultiSyntaxes = TRUE;
        }
    else
        {
        fHasMultiSyntaxes = FALSE;
        NumberOfTransferSyntaxes = 1;
        }

    // build the capabilities bitmap
    CapabilitiesBitmap = 0;
    for (i = 0; i < NumberOfTransferSyntaxes; i ++)
        {
        if (fHasMultiSyntaxes)
            {
            CurrentTransferInfo 
                = (TRANSFER_SYNTAX_STUB_INFO *)&SyntaxInfoArray[i].TransferSyntax;
            }
        else
            {
            CurrentTransferInfo 
                = (TRANSFER_SYNTAX_STUB_INFO *)&RpcInterfaceInformation->TransferSyntax;
            }

        CurrentTransferInfoLookupValue = CurrentTransferInfo->TransferSyntax.SyntaxGUID.Data4[0] & 0xF;
        CurrentCapability = SyntaxBindingCapabilitiesLookup[CurrentTransferInfoLookupValue];

        ASSERT(CurrentCapability != MTSyntaxBinding::SyntaxBindingCapabilityInvalid);

        if (CurrentCapability == MTSyntaxBinding::SyntaxBindingCapabilityInvalid)
            return RPC_S_UNSUPPORTED_TRANS_SYN;

        CapabilitiesBitmap |= CurrentCapability;
        }

    // if we create a binding here, we must also properly link it to the
    // other bindings that differ only by transfer syntax. We rely on the fact
    // that the stubs will always return multiple transfer syntaxes in the same
    // order. Therefore, we add them one by one, and if we fail towards the end
    // we leave the already added entries there. The next time we come, we
    // will try to continue off where we left
    NextBindingToBeReturned = 0;
    CurrentBinding = 0;
    for (i = 0; i < NumberOfTransferSyntaxes; i ++)
        {
        //
        // First we search for an existing presentation context
        // corresponding to the specified interface information.  Otherwise,
        // we create a new presentation context.
        //
        if (fHasMultiSyntaxes)
            {
            CurrentTransferInfo 
                = (TRANSFER_SYNTAX_STUB_INFO *)&SyntaxInfoArray[i].TransferSyntax;
            }
        else
            {
            CurrentTransferInfo 
                = (TRANSFER_SYNTAX_STUB_INFO *)&RpcInterfaceInformation->TransferSyntax;
            }

        BindingsDict->Reset(cursor);
        while ((Binding = (MTSyntaxBinding *)BindingsDict->Next(cursor)) != 0)
            {
            if (CheckBinding)
                {
                IsBindingDestroyed = CheckBinding(Binding, CallbackContext);
                if (IsBindingDestroyed)
                    continue;
                }

            if (Binding->CompareWithRpcInterfaceInformation(&RpcInterfaceInformation->InterfaceId,
                    CurrentTransferInfo, CapabilitiesBitmap) == 0)
                {
                BindingCreated[NextBindingToBeReturned] = FALSE;

                CurrentBinding = Binding;
                goto StoreResultAndLookForNextTransferSyntax;
                }
            }

        // if we are here, we haven't found any bindings for this transfer syntax -
        // create some
        Binding = CreateBinding(&RpcInterfaceInformation->InterfaceId, 
            CurrentTransferInfo, CapabilitiesBitmap);

        if (Binding == 0)
            {
            *NumberOfBindings = i;
            return(RPC_S_OUT_OF_MEMORY);
            }

        Binding->SetPresentationContext(BindingsDict->Insert(Binding));
        if (Binding->GetPresentationContext() == -1)
            {
            delete Binding;
            *NumberOfBindings = i;
            return RPC_S_OUT_OF_MEMORY;
            }

        if (CurrentBinding != 0)
            CurrentBinding->SetNextBinding(Binding);

        CurrentBinding = Binding;

        // the first transfer syntax info is marked as the list start
        // this helps us figure out where the list starts later on
        if (i == 0)
            Binding->TransferSyntaxIsListStart();

        BindingCreated[NextBindingToBeReturned] = TRUE;

StoreResultAndLookForNextTransferSyntax:
        // return the newly created binding to our caller
        BindingsForThisInterface[NextBindingToBeReturned] = Binding;
        NextBindingToBeReturned ++;
        }

    *NumberOfBindings = NumberOfTransferSyntaxes;
    return RPC_S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\queue.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       queue.cxx
//
//--------------------------------------------------------------------------

/*++

--*/

#include <precomp.hxx>
#include <queue.hxx>


QUEUE::QUEUE (
    )
/*++

Routine Description:

    We will construct an empty queue.

--*/
{
    ALLOCATE_THIS(QUEUE);

    QueueSlots = InitialQueueSlots;
    NumberOfQueueSlots = INITIALQUEUESLOTS;
    EndOfQueue = 0;
}


QUEUE::~QUEUE (
    )
/*++

Routine Desciption:

    We need to free up the queue slots if they have expanded beyond
    the initial ones.

--*/
{
    if (QueueSlots != InitialQueueSlots)
        delete QueueSlots;
}


int
QUEUE::PutOnQueue (
    IN void * Item,
    IN unsigned int Length
    )
/*++

Routine Description:

    The item will be placed on the tail of the queue.

Arguments:

    Item - Supplies the item to be placed on the queue.

    Length - Supplies the length of the item.

Return Value:

    Zero will be returned if everything completes successfully; otherwise,
    non-zero will be returned indicating an out of memory error.

--*/
{
    QUEUE_ITEM * NewQueueSlots;
    int Count;

    if (EndOfQueue == NumberOfQueueSlots)
        {
        NewQueueSlots = (QUEUE_ITEM *) new char[
                sizeof(QUEUE_ITEM) * NumberOfQueueSlots * 2];
        if (NewQueueSlots == 0)
            return(1);
        memcpy(NewQueueSlots, QueueSlots,
                sizeof(QUEUE_ITEM) * NumberOfQueueSlots);
        if (QueueSlots != InitialQueueSlots)
            delete QueueSlots;
        QueueSlots = NewQueueSlots;
        NumberOfQueueSlots *= 2;
        }

    for (Count = EndOfQueue; Count > 0; Count--)
        {
        ASSERT(QueueSlots[Count-1].Buffer != Item);
        QueueSlots[Count] = QueueSlots[Count - 1];
        }

    EndOfQueue += 1;
    QueueSlots[0].Buffer = Item;
    QueueSlots[0].BufferLength = Length;

    return(0);
}

int
QUEUE::PutOnFrontOfQueue (
    IN void * Item,
    IN unsigned int Length
    )
/*++

Routine Description:

    The item will be placed on the front of the queue.

Arguments:

    Item - Supplies the item to be placed on the queue.

    Length - Supplies the length of the item.

Return Value:

    Zero will be returned if everything completes successfully; otherwise,
    non-zero will be returned indicating an out of memory error.

--*/
{
    QUEUE_ITEM * NewQueueSlots;
    int Count;

    if (EndOfQueue == NumberOfQueueSlots)
        {
        NewQueueSlots = (QUEUE_ITEM *) new char[
                sizeof(QUEUE_ITEM) * NumberOfQueueSlots * 2];
        if (NewQueueSlots == 0)
            return(1);
        memcpy(NewQueueSlots, QueueSlots,
                sizeof(QUEUE_ITEM) * NumberOfQueueSlots);
        if (QueueSlots != InitialQueueSlots)
            delete QueueSlots;
        QueueSlots = NewQueueSlots;
        NumberOfQueueSlots *= 2;
        }

    QueueSlots[EndOfQueue].Buffer = Item;
    QueueSlots[EndOfQueue].BufferLength = Length;
    EndOfQueue += 1;

    return(0);
}
    

void *
QUEUE::TakeOffQueue (
    OUT unsigned int * Length
    )
/*++

Routine Description:

    This routine will remove an item from the front of the queue and
    return it.

Arguments:

    Length - Returns the length of the item in the queue.

Return Value:

    If the queue is not empty, the last item in the queue will be
    returned; otherwise, zero will be returned.

--*/
{
    if (EndOfQueue == 0)
        return(0);
    EndOfQueue -= 1;
    *Length = QueueSlots[EndOfQueue].BufferLength;

    return(QueueSlots[EndOfQueue].Buffer);
}


void *
QUEUE::TakeOffEndOfQueue (
    OUT unsigned int * Length
    )
/*++

Routine Description:

    This routine will remove an item from the tail of the queue and
    return it.

Arguments:

    Length - Returns the length of the item in the queue.

Return Value:

    If the queue is not empty, the last item in the queue will be
    returned; otherwise, zero will be returned.

--*/
{
    void *Buffer;
    int Count;

    if (EndOfQueue == 0)
        return(0);

    *Length = QueueSlots[0].BufferLength;
    Buffer = QueueSlots[0].Buffer;
    
    EndOfQueue -= 1;

    for (Count = 0; Count < EndOfQueue; Count++)
        {
        QueueSlots[Count] = QueueSlots[Count + 1];
        }

    return(Buffer);
}

   
int
QUEUE::FindAndTakeOffQueue (
    IN void * Item
    )
/*++

Routine Description:

    Searches for a given element on the queue and removes it from the queue
    if found.

Arguments:

Return Value:

    1 - If the element was found and removed.
    0 - Otherwise.

--*/
{
    int Count;
    int fFound = 0;
    
    if (IsQueueEmpty())
        {
        return 0;
        }

    for (Count = 0; Count < EndOfQueue; Count++)
        {
        if (QueueSlots[Count].Buffer == Item)
            {
            fFound = 1;
            EndOfQueue -= 1;
            }

        if (fFound && Count < EndOfQueue)
            {
            QueueSlots[Count] = QueueSlots[Count + 1];
            }
        }

    return fFound;
}

int 
QUEUE::MergeWithQueue (
    IN QUEUE *pQueue
    )
/*++

Routine Description:

    Takes the contents of the second queue and merges it into the first queue. Does not check for
    duplicates. Does not implement transactional semantics - i.e. if merging fails halfway due to lack
    of memory, the operation is aborted, and the amount of elements that were transferred remain in
    the this queue. Appropriate synchronization must be taken care for by the caller.

Arguments:

    pQueue - the queue that we want to merge from.

Return Value:

    0 - success
    !0 - failure - out of memory

--*/
{
    unsigned int nLength;
    void *pQueueElement;

    while (1)
        {
        pQueueElement = pQueue->TakeOffQueue(&nLength);
        if (pQueueElement == 0)
            break;

        if (PutOnQueue(pQueueElement, nLength) != 0)
            {
            // guaranteed to succeed since we never decrease buffers
            pQueue->PutOnFrontOfQueue(pQueueElement, nLength);
            return 1;
            }
        }
    return 0;
}

int 
QUEUE::MergeWithQueueInFront (
    IN QUEUE *SourceQueue
    )
/*++

Routine Description:

    Takes the contents of the second queue and merges it into the front of first queue. Does not check for
    duplicates. Does not implement transactional semantics - i.e. if merging fails halfway due to lack
    of memory, the operation is aborted, and the amount of elements that were transferred remain in
    the this queue. Appropriate synchronization must be taken care for by the caller.

Arguments:

    SourceQueue - the queue that we want to merge from.

Return Value:

    0 - success
    !0 - failure - out of memory

--*/
{
    unsigned int nLength;
    void *pQueueElement;

    while (1)
        {
        pQueueElement = SourceQueue->TakeOffEndOfQueue(&nLength);
        if (pQueueElement == 0)
            break;

        if (PutOnFrontOfQueue(pQueueElement, nLength) != 0)
            {
            // guaranteed to succeed since we never decrease buffers
            SourceQueue->PutOnFrontOfQueue(pQueueElement, nLength);
            return 1;
            }
        }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\principal.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:



Abstract:

    Functions to manipulate SSL-tyle principal names and certificates

Author:

    Jeff Roberts

Revisions:

    Jeff Roberts  (jroberts)  1-20-1998

        created the file

--*/

#include <precomp.hxx>

#include <rpcssl.h>
#include <cryptimp.hxx>
#include <CharConv.hxx>

#define INITIAL_NAME_LENGTH 100

// The prefix lengths do not include the NULL char.  Actual strings are one
// character longer.  This is generally OK, since these strings are prefixes and
// the NULL char gets overwritten.

#define     MSSTD_PREFIX_LENGTH 6
const RPC_CHAR MSSTD_PREFIX[]    = RPC_T("msstd:");

#define     FULLPATH_PREFIX_LENGTH 8
const RPC_CHAR FULLPATH_PREFIX[] = RPC_T("fullsic:");

//------------------------------------------------------------------------

DWORD
AddComponentName( RPC_CHAR *     *  pBuffer,
                  unsigned long  *  pBufferLength,
                  unsigned long  *  pCursor,
                  CERT_NAME_BLOB *  Name
                  );

DWORD
RpcCertMatchPrincipalName(
                   PCCERT_CONTEXT Context,
                   RPC_CHAR PrincipalName[]
                   );

DWORD
MatchFullPathPrincipalName(
                   PCCERT_CONTEXT Context,
                   RPC_CHAR EncodedPrincipalName[]
                   );

DWORD
CompareRdnElement(
               PCCERT_CONTEXT Context,
               DWORD dwGetNameStringType,
               void *pvGetNameStringTypePara,
               RPC_CHAR PrincipalName[],
               BOOL CaseSensitive
               );

DWORD
MarkPrincipalNameComponents(
                            RPC_CHAR * PrincipalName,
                            unsigned *   pCount
                            );

PCCERT_CONTEXT
FindMatchingCertificate( HCERTSTORE Store,
                         RPC_CHAR * SubjectName,
                         RPC_CHAR * IssuerName
                         );

DWORD
MatchMsPrincipalName(
                   PCCERT_CONTEXT Context,
                   RPC_CHAR EncodedPrincipalName[]
                   );

DWORD
DecodeEscapedString(
                    RPC_CHAR * Source,
                    RPC_CHAR * Destination
                    );

DWORD
FindIssuerContext( PCCERT_CONTEXT * pContext,
                   HCERTSTORE     * pStore,
                   BOOL           * pfFreeStore
                   );

RPC_CHAR *
EndOfRfc1779Name(
                 RPC_CHAR * Name
                 );

unsigned
Int4StrLen(
            unsigned long * String
            );

//------------------------------------------------------------------------

RPC_CHAR * __cdecl RpcpStringReverse (
        RPC_CHAR * string
        )
{
    RPC_CHAR *start = string;
    RPC_CHAR *left = string;
    RPC_CHAR ch;

    // Find end of string.
    while (*(++string))
         ;

    // Move the the last non-NULL character.
    string--;

    while (left < string)
        {
        ch = *left;
        *(left++) = *string;
        *(string--) = ch;
        }

    return(start);
}


DWORD
RpcCertMatchPrincipalName(
                   PCCERT_CONTEXT Context,
                   RPC_CHAR PrincipalName[]
                   )
/*++

Routine Description:

    This routine

Arguments:

    <Context>  is a CryptoAPI 2.0 context

    <PrincipalName> is a principal name prefixed with either "msstd:" or "fullsic:"

Return Value:

    0 if successful, otherwise an error

--*/
{
    DWORD Status = 0;

    InitializeIfNecessary();

    if (!LoadCrypt32Imports())
        {
        return GetLastError();
        }

    if (0 == RpcpStringNCompare(PrincipalName, MSSTD_PREFIX, MSSTD_PREFIX_LENGTH))
        {
        Status = MatchMsPrincipalName(Context, PrincipalName + MSSTD_PREFIX_LENGTH);
        }
    else if (0 == RpcpStringNCompare(PrincipalName, FULLPATH_PREFIX, FULLPATH_PREFIX_LENGTH))
        {
        Status = MatchFullPathPrincipalName(Context, PrincipalName + FULLPATH_PREFIX_LENGTH);
        }
    else
        {
        RTL_SOFT_ASSERT( 0 && "RPC: principal name is in incorrect format" );
        Status = ERROR_INVALID_PARAMETER;
        }

    return Status;
}


DWORD
MatchMsPrincipalName(
                   PCCERT_CONTEXT Context,
                   RPC_CHAR EncodedPrincipalName[]
                   )
{
    PCERT_NAME_INFO Subject = 0;
    DWORD Status = 0;
    RPC_CHAR * PrincipalName = 0;

    //
    // It's time to decode the principal name.
    // The encoding is just a matter of extra backslashes when the
    // principal name contains our metacharacters.  Decoding will
    // always make the string smaller.
    //
    // Don't forget that RpcpStringLength returns the length of the string
    // excluding the  terminating NULL and we need to alloca space for it.
    //
    PrincipalName = (RPC_CHAR *) _alloca(sizeof(RPC_CHAR) * (RpcpStringLength(EncodedPrincipalName)+1));

    Status = DecodeEscapedString(EncodedPrincipalName, PrincipalName);
    if (Status)
        {
        RpcpErrorAddRecord(EEInfoGCSecurityProvider,
                           Status,
                           EEInfoDLMatchMsPrincipalName10);

        return Status;
        }


    if (RpcpCharacter((const RPC_SCHAR *) PrincipalName, '@'))
        {
        // Compare the principal name to the certificate subject's
        // email-address RDN attribute.
        return CompareRdnElement(Context, CERT_NAME_EMAIL_TYPE, NULL, PrincipalName, TRUE); 
        }
    else
        {
        // Compare the principal name to the certificate subject's
        // common-name RDN attribute.
        return CompareRdnElement(Context, CERT_NAME_ATTR_TYPE, szOID_COMMON_NAME, PrincipalName, FALSE);
        }

    ASSERT( 0 );
}


DWORD
CompareRdnElement(
               PCCERT_CONTEXT Context,
               DWORD dwGetNameStringType,
               void *pvGetNameStringTypePara,
               RPC_CHAR PrincipalName[],
               BOOL CaseSensitive
               )
{
    //
    // Decode the certificate's Subject field so we can see its attributes.
    //
    DWORD Status = 0;

    RPC_CHAR * pPrincipalName;

    DWORD NameSize = CertGetNameStringW(Context,
                                        dwGetNameStringType,
                                        0, // dwFlags
                                        pvGetNameStringTypePara, // pvTypePara
                                        NULL,
                                        0);
        
    if (NameSize > 1)
        {
        pPrincipalName = (RPC_CHAR *) _alloca( sizeof(wchar_t) * NameSize );

        NameSize = CertGetNameStringW(Context,
                                      dwGetNameStringType,
                                      0,
                                      pvGetNameStringTypePara,
                                      pPrincipalName,
                                      NameSize);
        
        ASSERT(NameSize > 1);
        }
    else
        {
        RpcpErrorAddRecord(EEInfoGCSecurityProvider,
                           ERROR_ACCESS_DENIED,
                           EEInfoDLCompareRdnElement10,
                           GetLastError());

        return ERROR_ACCESS_DENIED;
        }

    //
    // Now compare the cetificate info to the principal name.
    //
    if (CaseSensitive)
        {
        if (0 != RpcpStringSCompare(PrincipalName, pPrincipalName))
            {
            return ERROR_ACCESS_DENIED;
            }
        }
    else
        {
        if (0 != RpcpStringCompareInt(PrincipalName, pPrincipalName))
            {
            return ERROR_ACCESS_DENIED;
            }
        }

    return 0;
}


DWORD
DecodeEscapedString(
                    RPC_CHAR * Source,
                    RPC_CHAR * Destination
                    )
{
    for (;;)
        {
        if (*Source == '\\')
            {
            if(Source[1] != '<' && Source[1] != '*')
                {
                    Source++;
                }
            if (!*Source)
                {
                return ERROR_INVALID_PARAMETER;
                }
            *Destination = *Source;
            }
        else
            {
            *Destination = *Source;
            if (!*Source)
                {
                return 0;
                }
            }

        ++Source;
        ++Destination;
        }
}


DWORD
MatchFullPathPrincipalName(
                   PCCERT_CONTEXT Context,
                   RPC_CHAR EncodedPrincipalName[]
                   )
/*++

Routine Description:


Arguments:

    <Context>  is a CryptoAPI 2.0 context

    <PrincipalName> is a principal name with no prefix

        It can be in several forms:

            - complete and explicit, e.g.

                "\<CA>\<Name>"
                "\<CA>\<SA1>\<SA2>\<Name>"

            - wildcard in the subject-name position:

                "\<CA>\*"

            - no CA specified

                "Name"          - This is equivalent to "\*\<Name>"
                "\<Name>"       - same

Return Value:

    0 if all components were successfully validated
    ERROR_NO_TOP_LEVEL_AUTHORITY if the top cert isn't in the CA store

    Some other error if something failed.

--*/
{
    DWORD       Status = 0;
    DWORD       ReturnedStatus = 0;
    HCERTSTORE  Store = Context->hCertStore;
    unsigned    PrincipalNameLength;
    RPC_CHAR *  CopyOfPrincipalName = 0;

    if (!*EncodedPrincipalName)
        {
        return ERROR_INVALID_PARAMETER;
        }

    PrincipalNameLength = RpcpStringLength(EncodedPrincipalName);

    //
    // If the name doesn't begin with a backslash, then treat it as "\*\subjectname".
    //
    if (EncodedPrincipalName[0] != '\\')
        {
        CopyOfPrincipalName = (RPC_CHAR *) _alloca( (5 + PrincipalNameLength + 2) *
                                                    sizeof(RPC_CHAR));

        RpcpStringCopy(CopyOfPrincipalName, RPC_CONST_STRING("\\*\\<"));
        RpcpStringCat(CopyOfPrincipalName, EncodedPrincipalName);
        RpcpStringCat(CopyOfPrincipalName, RPC_CONST_STRING(">"));

        return MatchFullPathPrincipalName( Context, CopyOfPrincipalName );
        }

    //
    // Form is "\<CA>\<Name>".  More precisely, the name looks like a
    // file system path, where each element of the path
    // is either
    //      "*"
    // or
    //      '<' plus an RFC1779 name plus '>'
    //
    unsigned    idx;
    unsigned    ComponentCount;
    RPC_CHAR **    Components = 0;
    RPC_CHAR *     Cursor;

    CopyOfPrincipalName = (RPC_CHAR *) _alloca( (PrincipalNameLength + 2) * sizeof(RPC_CHAR));

    RpcpStringCopy(CopyOfPrincipalName, EncodedPrincipalName);

    //
    // Sizing pass.  Count the number of path elements and separate them by '\0'.
    //
    Status = MarkPrincipalNameComponents( CopyOfPrincipalName, &ComponentCount );
    if (Status)
        {
        RpcpErrorAddRecord(EEInfoGCSecurityProvider,
                           Status,
                           EEInfoDLMatchFullPathPrincipalName10);

        return Status;
        }

    ASSERT(ComponentCount >= 1);

    // If the ComponentCount is 1 then the principal name was of the form "\<Name>".
    // After marking the name's components it should be of the form "\0\0Name\0".
    // This means that to handle it it is enough to call MatchFullPathPrincipalName
    // passing in CopyOfPrincipalName+2 which will be "Name\0".
    if (ComponentCount == 1)
        {
        return MatchFullPathPrincipalName( Context, CopyOfPrincipalName + 2 );        
        }

    //
    // Init the component array.  The 0'th element of the array points to
    // the last component of the principal name (i.e., the client's subject name).
    //
    Components = (RPC_CHAR **) _alloca( sizeof(RPC_CHAR *) * ComponentCount );

    Cursor = CopyOfPrincipalName;
    idx    = ComponentCount-1;
    do
        {
        while (!*Cursor)
            {
            ++Cursor;
            }

        ASSERT( Cursor < CopyOfPrincipalName+PrincipalNameLength );

        Components[idx] = Cursor;

        Cursor += RpcpStringLength( Cursor );
        }
    while ( idx-- > 0 );

    //
    // Verify the principal name of all certs except the top authority one.
    //
    PCCERT_CONTEXT NewContext = 0;

    for (idx=0; idx < ComponentCount-1; ++idx)
        {
        if (NewContext)
            {
            CertFreeCertificateContext( NewContext );
            }

        NewContext = FindMatchingCertificate( Store,
                                              Components[idx],
                                              Components[idx+1]
                                              );
        if (!NewContext)
            {
            Status = GetLastError();

            if (Status == ERROR_NOT_ENOUGH_MEMORY)
                {
                ReturnedStatus = ERROR_NOT_ENOUGH_MEMORY;
                }
            else
                {
                ReturnedStatus = ERROR_ACCESS_DENIED;
                }

            RpcpErrorAddRecord(EEInfoGCSecurityProvider,
                               ReturnedStatus,
                               EEInfoDLMatchFullPathPrincipalName20,
                               Status);

            return ReturnedStatus;
            }
        }

    ASSERT(NewContext != NULL);

    //
    // Look for the top-level authority certificate in the CA and ROOT stores,
    // matching the last remaining principal name component.
    //
    HCERTSTORE CaStore;
    HCERTSTORE RootStore;

    CaStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_W,
                             0,
                             0,
                             CERT_SYSTEM_STORE_CURRENT_USER,
                             RPC_CONST_STRING("CA")
                             );
    if (!CaStore)
        {
        Status = GetLastError();
        RpcpErrorAddRecord(EEInfoGCSecurityProvider,
                           Status,
                           EEInfoDLMatchFullPathPrincipalName30);

        CertFreeCertificateContext( NewContext );
        return Status;
        }


    RootStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_W,
                               0,
                               0,
                               CERT_SYSTEM_STORE_CURRENT_USER,
                               RPC_CONST_STRING("ROOT")
                               );
    if (!RootStore)
        {
        Status = GetLastError();
        RpcpErrorAddRecord(EEInfoGCSecurityProvider,
                           Status,
                           EEInfoDLMatchFullPathPrincipalName40);

        CertCloseStore( CaStore, 0 );
        CertFreeCertificateContext( NewContext );
        return Status;
        }

    //
    // Use Context instead of Components[] for the issuer name
    // so that the self-signed cert that we look for
    // is always the one that matches the Context we have.
    // Otherwise we'd be wrong about strings with a wildcard as top-level authority.
    //
    PCCERT_CONTEXT Parent = 0;

    // CertFindCertificateInStore should always continue to search in the same store.
    // For example, if the CERT_CONTEXT Parent has been retrieved from CaStore then the
    // next call to CertFindCertificateInStore can't search in RootStore.
    // Thus, we need to remember in which cert store we had been searching and only continue
    // in that store.
    BOOL SearchingInRootStore = TRUE;

    while (1)
        {
        if (SearchingInRootStore)
            {
            Parent = CertFindCertificateInStore(
                                                RootStore,
                                                X509_ASN_ENCODING,
                                                0,                             // no flags
                                                CERT_FIND_SUBJECT_NAME,        // exact match
                                                &NewContext->pCertInfo->Issuer,
                                                Parent
                                                );
            }

        if (!Parent || SearchingInRootStore == FALSE)
            {
            Parent = CertFindCertificateInStore(
                                                CaStore,
                                                X509_ASN_ENCODING,
                                                0,                             // no flags
                                                CERT_FIND_SUBJECT_NAME,        // exact match
                                                &NewContext->pCertInfo->Issuer,
                                                Parent
                                                );
            SearchingInRootStore = FALSE;
            }

        if (!Parent)
            {
            goto finish;
            }

        if (CertCompareCertificateName( X509_ASN_ENCODING,
                                        & Parent->pCertInfo->Issuer,
                                        &Context->pCertInfo->Issuer
                                        ))
            {
            goto finish;
            }
        }

finish:

    CertCloseStore( CaStore, 0 );
    CertCloseStore( RootStore, 0 );
    CertFreeCertificateContext( NewContext );

    if (!Parent)
        {
        Status = GetLastError();
        if (Status == ERROR_NOT_ENOUGH_MEMORY)
            {
            ReturnedStatus = ERROR_NOT_ENOUGH_MEMORY;
            }
        else
            {
            ReturnedStatus = SEC_E_NO_AUTHENTICATING_AUTHORITY;
            }

        RpcpErrorAddRecord(EEInfoGCSecurityProvider,
                           ReturnedStatus,
                           EEInfoDLMatchFullPathPrincipalName50,
                           Status);

        return ReturnedStatus;
        }

    CertFreeCertificateContext( Parent );

    return 0;
}


PCCERT_CONTEXT
FindMatchingCertificate( HCERTSTORE Store,
                         RPC_CHAR * SubjectName,
                         RPC_CHAR * IssuerName
                         )
{
    PCCERT_CONTEXT   Context = 0;
    CERT_NAME_BLOB * IssuerBlob = 0;
    CERT_NAME_BLOB * SubjectBlob = 0;

    ASSERT( IssuerName[0] != '*' || SubjectName[0] != '*' );

    //
    // Make an issuer blob, if necessary.
    //
    if (IssuerName[0] != '*')
        {
        unsigned long BlobSize = INITIAL_NAME_LENGTH;

        IssuerBlob = (CERT_NAME_BLOB *) _alloca( sizeof(CERT_NAME_BLOB)+INITIAL_NAME_LENGTH );

        IssuerBlob->cbData = INITIAL_NAME_LENGTH;
        IssuerBlob->pbData = (unsigned char *) (IssuerBlob+1);

        if (! CertStrToNameT( X509_ASN_ENCODING,
                              IssuerName,
                              0,                  // no format restrictions
                              NULL,               // reserved, MBZ
                              IssuerBlob->pbData,
                              &IssuerBlob->cbData,
                              NULL                // would point to first invalid character
                              ))
            {
            BlobSize = IssuerBlob->cbData;

            IssuerBlob = (CERT_NAME_BLOB *) _alloca( sizeof(CERT_NAME_BLOB)+BlobSize );

            IssuerBlob->cbData = BlobSize;
            IssuerBlob->pbData = (unsigned char *) (IssuerBlob+1);

            if (! CertStrToNameT( X509_ASN_ENCODING,
                                     IssuerName,
                                     0,                  // no format restrictions
                                     NULL,               // reserved, MBZ
                                     IssuerBlob->pbData,
                                     &IssuerBlob->cbData,
                                     NULL                // would point to first invalid character
                                     ))
                {
                return 0;
                }
            }
        }

    //
    // Make a subject blob, if necessary.
    //
    if (SubjectName[0] != '*')
        {
        unsigned long BlobSize = INITIAL_NAME_LENGTH;

        SubjectBlob = (CERT_NAME_BLOB *) _alloca( sizeof(CERT_NAME_BLOB)+INITIAL_NAME_LENGTH );

        SubjectBlob->cbData = INITIAL_NAME_LENGTH;
        SubjectBlob->pbData = (unsigned char *) (SubjectBlob+1);

        if (! CertStrToNameT( X509_ASN_ENCODING,
                              SubjectName,
                              0,                  // no format restrictions
                              NULL,               // reserved, MBZ
                              SubjectBlob->pbData,
                              &SubjectBlob->cbData,
                              NULL                // would point to first invalid character
                              ))
            {
            BlobSize = SubjectBlob->cbData;

            SubjectBlob = (CERT_NAME_BLOB *) _alloca( sizeof(CERT_NAME_BLOB)+BlobSize );

            SubjectBlob->cbData = BlobSize;
            SubjectBlob->pbData = (unsigned char *) (SubjectBlob+1);

            if (! CertStrToNameT( X509_ASN_ENCODING,
                                     SubjectName,
                                     0,                  // no format restrictions
                                     NULL,               // reserved, MBZ
                                     SubjectBlob->pbData,
                                     &SubjectBlob->cbData,
                                     NULL                // would point to first invalid character
                                     ))
                {
                return 0;
                }
            }
        }

    //
    // Search for a certificate.
    //
    if (SubjectName[0] == '*')
        {
        //
        // Search by issuer only.
        //
        Context = CertFindCertificateInStore(
                                            Store,
                                            X509_ASN_ENCODING,
                                            0,                             // no flags
                                            CERT_FIND_ISSUER_NAME,         // exact match
                                            IssuerBlob,
                                            NULL                           // previous context in search
                                            );
        return Context;
        }
    else if (IssuerName[0] == '*')
        {
        //
        // Search by subject only.
        //
        Context = CertFindCertificateInStore(
                                            Store,
                                            X509_ASN_ENCODING,
                                            0,                             // no flags
                                            CERT_FIND_SUBJECT_NAME,        // exact match
                                            SubjectBlob,
                                            NULL                           // previous context in search
                                            );
        return Context;
        }
    else
        {
        //
        // Search by both.  The primary search is by subject,
        // on the theory that most subject names are distinct and
        // most issuer names are not.
        //
        // Context starts of as NULL and we pass previous context to
        // CertFindCertificateInStore in order to advance to the next
        // and free the privious one.
        //
        while (1)
            {
            Context = CertFindCertificateInStore(
                                                Store,
                                                X509_ASN_ENCODING,
                                                0,                             // no flags
                                                CERT_FIND_SUBJECT_NAME,        // exact match
                                                SubjectBlob,
                                                Context                        // previous context in search
                                                );
            if (!Context)
                {
                return Context;
                }

            if (CertCompareCertificateName( X509_ASN_ENCODING,
                                            &Context->pCertInfo->Issuer,
                                            IssuerBlob
                                            ))
                {
                return Context;
                }
            }
        }

    ASSERT( 0 && "should never get here" );
}


DWORD
MarkPrincipalNameComponents(
                            RPC_CHAR * PrincipalName,
                            unsigned *   pCount
                            )
{
    RPC_CHAR * Cursor;
    unsigned     ComponentCount;

    ComponentCount = 0;
    Cursor = PrincipalName;
    do
        {
        ++ComponentCount;

        if ( *Cursor != '\\' )
            {
            return ERROR_INVALID_PARAMETER;
            }

        *Cursor = '\0';
        ++Cursor;

        if (*Cursor == '*')
            {
            ++Cursor;
            }
        else if (*Cursor == '<')
            {
            *Cursor = '\0';
            ++Cursor;

            Cursor = EndOfRfc1779Name( Cursor );
            if (*Cursor != '>')
                {
                return ERROR_INVALID_PARAMETER;
                }

            *Cursor = '\0';
            ++Cursor;
            }
        else
            {
            return ERROR_INVALID_PARAMETER;
            }
        }
    while ( *Cursor );

    *pCount = ComponentCount;

    return 0;
}


RPC_CHAR *
EndOfRfc1779Name(
                 RPC_CHAR * Name
                 )
{
    unsigned Quotes = 0;

    for ( ; *Name; ++Name)
        {
        if (*Name == '>')
            {
            if (0 == (Quotes % 2))
                {
                return Name;
                }
            }
        else if (*Name == '\\')
            {
            ++Name;
            }
        else if (*Name == '"')
            {
            ++Quotes;
            }
        }

    return Name;
}


RPC_STATUS
RpcCertGeneratePrincipalName(
                      PCCERT_CONTEXT Context,
                      DWORD          Flags,
                      RPC_CHAR **       pBuffer
                      )
{
    THREAD *Thread;
    DWORD   Status = 0;

    InitializeIfNecessary();

    Thread = ThreadSelf();
    if (Thread)
        {
        RpcpPurgeEEInfoFromThreadIfNecessary(Thread);
        }

    if (!LoadCrypt32Imports())
        {
        return GetLastError();
        }

    if (Flags & RPC_C_FULL_CERT_CHAIN)
        {
        RPC_CHAR * Buffer;
        unsigned long Cursor = 0;
        unsigned long BufferLength = INITIAL_NAME_LENGTH;
        HCERTSTORE Store = Context->hCertStore;
        BOOL    fFreeStore = FALSE;

        Buffer = new RPC_CHAR[BufferLength];
        if (!Buffer)
            {
            return ERROR_NOT_ENOUGH_MEMORY;
            }

        PCCERT_CONTEXT Node = Context;
        do
            {
            Status = AddComponentName( &Buffer,
                                       &BufferLength,
                                       &Cursor,
                                       &Node->pCertInfo->Subject
                                       );
            if (Status)
                {
                RpcpErrorAddRecord(EEInfoGCSecurityProvider,
                                   Status,
                                   EEInfoDLRpcCertGeneratePrincipalName10);

                return Status;
                }

            //
            // Load the next certificate.
            //
            PCCERT_CONTEXT OldNode = Node;

            if (OldNode == Context)
                {
                OldNode = NULL;
                }

            if (CertCompareCertificateName( X509_ASN_ENCODING,
                                            &Node->pCertInfo->Subject,
                                            &Node->pCertInfo->Issuer
                                            ))
                {
                if (OldNode != NULL)
                    {
                    CertFreeCertificateContext( OldNode );
                    }
                break;
                }

            CERT_NAME_BLOB *Issuer;
            if (OldNode)
                {
                Issuer = &OldNode->pCertInfo->Issuer;
                }
            else
                {
                Issuer = &Context->pCertInfo->Issuer;
                }

            Node = CertFindCertificateInStore( Store,
                                               X509_ASN_ENCODING,
                                               0,                             // no flags
                                               CERT_FIND_SUBJECT_NAME,        // exact match
                                               Issuer,
                                               OldNode                        // previous context in search
                                               );
            if (!Node)
                {
                //
                // Take the top-level CA name from the current node's issuer field.
                //
                Status = AddComponentName( &Buffer,
                                           &BufferLength,
                                           &Cursor,
                                           Issuer
                                           );
                if (Status)
                    {
                    RpcpErrorAddRecord(EEInfoGCSecurityProvider,
                                       Status,
                                       EEInfoDLRpcCertGeneratePrincipalName20);
                    return Status;
                    }
                }
            }
        while ( Node );

        if (Cursor+FULLPATH_PREFIX_LENGTH+1 > BufferLength)
            {
            DWORD LongerBufferLength = BufferLength+FULLPATH_PREFIX_LENGTH+1;
            RPC_CHAR * LongerBuffer = new RPC_CHAR[LongerBufferLength];
            if (!LongerBuffer)
                {
                delete [] Buffer;
                return ERROR_NOT_ENOUGH_MEMORY;
                }

            RpcpStringNCopy( LongerBuffer, Buffer, BufferLength );

            delete [] Buffer;

            Buffer       = LongerBuffer;
            BufferLength = LongerBufferLength;
            }

        RpcpStringCopy( Buffer+Cursor,FULLPATH_PREFIX );
        RpcpStringReverse( Buffer+Cursor );
        RpcpStringReverse( Buffer );

        *pBuffer = Buffer;
        return 0;
        }
    else
        {

        RPC_CHAR * outputName;

        DWORD NameSize = CertGetNameStringW(Context,
                                            CERT_NAME_EMAIL_TYPE,
                                            0, // dwFlags
                                            NULL, // pvTypePara
                                            NULL,
                                            0);

        if (NameSize > 1)
            {
            outputName = new RPC_CHAR[ NameSize + MSSTD_PREFIX_LENGTH ];
            
            if (!outputName)
                {
                return ERROR_NOT_ENOUGH_MEMORY;
                }

            RpcpStringCopy(outputName, MSSTD_PREFIX);
        
            NameSize = CertGetNameStringW(Context,
                                          CERT_NAME_EMAIL_TYPE,
                                          0,
                                          NULL,
                                          outputName + MSSTD_PREFIX_LENGTH,
                                          NameSize);

            ASSERT(NameSize > 1);
            }
        else
            {
            NameSize = CertGetNameStringW(Context,
                                          CERT_NAME_ATTR_TYPE,
                                          0,
                                          szOID_COMMON_NAME,
                                          NULL,
                                          0);
            
            if (NameSize > 1)
                {
                outputName = new RPC_CHAR[ NameSize + MSSTD_PREFIX_LENGTH ];

                if (!outputName)
                    {
                    return ERROR_NOT_ENOUGH_MEMORY;
                    }
                
                RpcpStringCopy(outputName, MSSTD_PREFIX);
        
                NameSize = CertGetNameString(Context,
                                             CERT_NAME_ATTR_TYPE,
                                             0,
                                             szOID_COMMON_NAME,
                                             outputName + MSSTD_PREFIX_LENGTH,
                                             NameSize);
                
                ASSERT(NameSize > 1);
                }
            else
                {
                RpcpErrorAddRecord(EEInfoGCSecurityProvider,
                                   ERROR_INVALID_PARAMETER,
                                   EEInfoDLRpcCertGeneratePrincipalName30,
                                   GetLastError());

                return ERROR_INVALID_PARAMETER;
                } 
            }
        
        *pBuffer = outputName;

        return 0;
        }

    ASSERT( 0 && "never reach here" );
    return ERROR_INVALID_PARAMETER;
}


DWORD
AddComponentName( RPC_CHAR *     *  pBuffer,
                  unsigned long  *  pBufferLength,
                  unsigned long  *  pCursor,
                  CERT_NAME_BLOB *  Name
                  )
{
    (*pBuffer)[(*pCursor)++] = '>';

    DWORD Length = *pBufferLength - *pCursor;

    Length = CertNameToStrT( X509_ASN_ENCODING,
                             Name,
                             CERT_X500_NAME_STR,
                             *pBuffer + *pCursor,
                             Length
                             );

    if (Length >= *pBufferLength - *pCursor)
        {
        DWORD LongerBufferLength = 2 * *pBufferLength + Length;
        RPC_CHAR * LongerBuffer = new RPC_CHAR[LongerBufferLength];
        if (!LongerBuffer)
            {
            delete *pBuffer;
            return ERROR_NOT_ENOUGH_MEMORY;
            }

        RpcpStringNCopy( LongerBuffer, *pBuffer, *pBufferLength );

        delete *pBuffer;

        *pBuffer       = LongerBuffer;
        *pBufferLength = LongerBufferLength;

        Length = *pBufferLength - *pCursor;

        Length = CertNameToStrT( X509_ASN_ENCODING,
                                 Name,
                                 CERT_X500_NAME_STR,
                                 *pBuffer + *pCursor,
                                 Length
                                 );
        }

    RpcpStringReverse(*pBuffer + *pCursor);
    *pCursor += Length-1; // write over the '\0'

    (*pBuffer)[(*pCursor)++] = '<';
    (*pBuffer)[(*pCursor)++] = '\\';

    return 0;
}


unsigned
Int4StrLen(
           unsigned long * String
           )
{
    unsigned long * Cursor = String;

    while (*Cursor)
        {
        ++Cursor;
        }

    return (unsigned) (Cursor - String);
}

HMODULE Crypt32Handle = 0;
struct CRYPT32_FUNCTION_TABLE CFT;


BOOL
LoadCrypt32Imports()
{
    if (0 == Crypt32Handle)
        {
        RequestGlobalMutex();

        if (Crypt32Handle)
            {
            goto Cleanup;
            }

        Crypt32Handle = LoadLibrary(RPC_CONST_SSTRING("crypt32.dll"));
        if (!Crypt32Handle)
            {
            goto Cleanup;
            }

        FARPROC * ppProc = (FARPROC *) &CFT;

        *ppProc++ = GetProcAddress(Crypt32Handle, "CertOpenStore");
        *ppProc++ = GetProcAddress(Crypt32Handle, "CertCloseStore");
        *ppProc++ = GetProcAddress(Crypt32Handle, "CertFindCertificateInStore");
        *ppProc++ = GetProcAddress(Crypt32Handle, "CertFreeCertificateContext");
        *ppProc++ = GetProcAddress(Crypt32Handle, "CertCompareCertificateName");
#ifdef UNICODE
        *ppProc++ = GetProcAddress(Crypt32Handle, "CertStrToNameW");
        *ppProc++ = GetProcAddress(Crypt32Handle, "CertNameToStrW");
#else
        *ppProc++ = GetProcAddress(Crypt32Handle, "CertStrToNameA");
        *ppProc++ = GetProcAddress(Crypt32Handle, "CertNameToStrA");
#endif
        *ppProc++ = GetProcAddress(Crypt32Handle, "CertFindRDNAttr");
        *ppProc++ = GetProcAddress(Crypt32Handle, "CryptDecodeObject");

#if MANUAL_CERT_CHECK
        *ppProc++ = GetProcAddress(Crypt32Handle, "CertVerifyCertificateChainPolicy");
        *ppProc++ = GetProcAddress(Crypt32Handle, "CertGetCertificateChain");
        *ppProc++ = GetProcAddress(Crypt32Handle, "CertFreeCertificateChain");
#endif

        *ppProc++ = GetProcAddress(Crypt32Handle, "CertGetNameStringW");

        ppProc = (FARPROC *) &CFT;

        for (int i = 0; i < sizeof(CRYPT32_FUNCTION_TABLE)/sizeof(FARPROC); i++)
            {
            if (*ppProc++ == 0)
                {
                FreeLibrary(Crypt32Handle);
                Crypt32Handle = 0;
                goto Cleanup;
                }
            }
        ClearGlobalMutex();
        }

    return TRUE;

Cleanup:
    ClearGlobalMutex();
    return FALSE;
}

#if MANUAL_CERT_CHECK

DWORD
RpcCertVerifyContext(
    IN PCERT_CONTEXT Context,
    IN DWORD CapabilityFlags
    )
{
    DWORD s = 0;
    HCERTSTORE CaStore = 0;
    PCCERT_CHAIN_CONTEXT Chain = 0;

    //
    // Windows 2000 checked only the CA store, so we should check it also.
    //
    CaStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_W,
                             0,
                             0,
                             CERT_SYSTEM_STORE_CURRENT_USER,
                             RPC_CONST_STRING("CA")
                             );
    if (!CaStore)
        {
        s = GetLastError();
        RpcpErrorAddRecord(EEInfoGCSecurityProvider,
                           s,
                           EEInfoDLRpcCertVerifyContext10);

        goto Cleanup;
        }

    //
    // Build a certificate chain from the single certificate we have.
    //
    CERT_CHAIN_PARA ChainParameters;

    ChainParameters.cbSize = sizeof(CERT_CHAIN_PARA);
    ChainParameters.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
    ChainParameters.RequestedUsage.Usage.cUsageIdentifier = 0;

    if (!CertGetCertificateChain( NULL,     // use default chain engine
                                  Context,
                                  NULL,     // match against current time
                                  CaStore,  // aditional store to search
                                  &ChainParameters,
                                  0,        // no special flags
                                  0,        // reserved, MBZ
                                  &Chain
                                  ))
        {
        s = GetLastError();
        RpcpErrorAddRecord(EEInfoGCSecurityProvider,
                           s,
                           EEInfoDLRpcCertVerifyContext20);

        goto Cleanup;
        }

    //
    // Verify the chain.
    //
    CERT_CHAIN_POLICY_PARA   PolicyParameters;
    CERT_CHAIN_POLICY_STATUS PolicyStatus;

    PolicyParameters.cbSize = sizeof(CERT_CHAIN_POLICY_PARA);
    PolicyParameters.dwFlags = 0;
    PolicyParameters.pvExtraPolicyPara = 0;

    if (CapabilityFlags & RPC_C_QOS_CAPABILITIES_ANY_AUTHORITY)
        {
        PolicyParameters.dwFlags |= CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG;
        }

    PolicyStatus.cbSize = sizeof(CERT_CHAIN_POLICY_STATUS);

    if (!CertVerifyCertificateChainPolicy( CERT_CHAIN_POLICY_BASE,
                                           Chain,
                                           &PolicyParameters,
                                           &PolicyStatus))
        {
        s = GetLastError();
        RpcpErrorAddRecord(EEInfoGCSecurityProvider,
                           s,
                           EEInfoDLRpcCertVerifyContext30);

        goto Cleanup;
        }

    if (PolicyStatus.dwError)
        {
        s = ERROR_ACCESS_DENIED;
        RpcpErrorAddRecord(EEInfoGCSecurityProvider,
                           s,
                           EEInfoDLRpcCertVerifyContext40,
                           GetLastError());

        goto Cleanup;
        }

    //
    // Certificate verification succeeded.
    //
    s = 0;

Cleanup:

    if (Chain)
        {
        CertFreeCertificateChain( Chain );
        }

    if (CaStore)
        {
        CertCloseStore( CaStore, 0 );
        }

    return s;
}

#endif

RPC_STATUS
ValidateSchannelPrincipalName(
    IN RPC_CHAR * EncodedName
    )
//
// Does a quick syntactic check of an SSL principal name.
// The name should not be modified in any way.
//
// It should begin either with "msstd:" or "fullsic:".
// If msstd, then any non-enpty name will do.
// If fullsic, it should be a series of RFC1179 names, each surrounded
// by angle brackets, and separated by backslashes.  We check this by cloning
// the string and marking the components.
//
{
#define MAX_SSL_SPN_LENGTH  8000

    if (0 == RpcpStringNCompare(EncodedName, MSSTD_PREFIX, MSSTD_PREFIX_LENGTH))
        {
        if (EncodedName[MSSTD_PREFIX_LENGTH] == 0)
            {
            return ERROR_INVALID_PARAMETER;
            }
        }
    else if (0 == RpcpStringNCompare(EncodedName, FULLPATH_PREFIX, FULLPATH_PREFIX_LENGTH))
        {
        RPC_STATUS Status;
        size_t Length;
        unsigned ComponentCount;
        RPC_CHAR * PrincipalName;
        RPC_CHAR * EncodedPrincipalName;

        Length = RpcpStringLength( EncodedName );
        if (Length > MAX_SSL_SPN_LENGTH)
            {
            return ERROR_INVALID_PARAMETER;
            }

        PrincipalName = (RPC_CHAR *) _alloca(sizeof(RPC_CHAR) * (Length+1));

        Status = DecodeEscapedString(EncodedName, PrincipalName);
        if (Status)
            {
            return Status;
            }

        Status = MarkPrincipalNameComponents( PrincipalName + FULLPATH_PREFIX_LENGTH, &ComponentCount );
        if (Status)
            {
            return Status;
            }

        if (ComponentCount < 1)
            {
            return ERROR_INVALID_PARAMETER;
            }
        }
    else
        {
        return ERROR_INVALID_PARAMETER;
        }

    return RPC_S_OK;
}

RPC_STATUS
I_RpcTransCertMatchPrincipalName(
                   PCCERT_CONTEXT Context,
                   RPC_CHAR PrincipalName[]
                   )
/*++

Routine Description:

    Verifies that the passed in context match the passed in 
        principal name and frees the certificate.

Arguments:

    Context - certificate context.

    PrincipalName - a principal name prefixed with either "msstd:" or "fullsic:"
    
Return Value:

    RPC_S_OK or RPC_S_ACCESS_DENIED

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = RpcCertMatchPrincipalName(Context, PrincipalName);

    if (RpcStatus == ERROR_OUTOFMEMORY)
        RpcStatus = RPC_S_OUT_OF_MEMORY;
    else if (RpcStatus != RPC_S_OK)
        RpcStatus = RPC_S_ACCESS_DENIED;

    CertFreeCertificateContext(Context);

    return RpcStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\rpccfg.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    rpccfg.h


Abstract:

    The entry points for configuration of the rpc runtime are prototyped
    in this file.  Each operating environment must defined these routines.

Author:

    Michael Montague (mikemon) 25-Nov-1991

Revision History:

--*/

#ifndef __RPCCFG_H__
#define __RPCCFG_H__

RPC_STATUS
RpcConfigMapRpcProtocolSequence (
    IN unsigned int ServerSideFlag,
    IN RPC_CHAR PAPI * RpcProtocolSequence,
    OUT RPC_CHAR * PAPI * TransportInterfaceDll
    );

RPC_STATUS
RpcConfigInquireProtocolSequences (
    IN BOOL fGetAllProtseqs,
    OUT RPC_PROTSEQ_VECTOR PAPI * PAPI * ProtseqVector
    );

RPC_STATUS
RpcGetAdditionalTransportInfo(
    IN  unsigned long TransportId,
    OUT unsigned char PAPI * PAPI * ProtocolSequence
    );

RPC_STATUS
RpcGetWellKnownTransportInfo(
    IN unsigned long TransportId,
    OUT RPC_CHAR **PSeq
    );

RPC_STATUS
RpcGetSecurityProviderInfo(
    unsigned long AuthnId,
    RPC_CHAR * PAPI * Dll,
    unsigned long PAPI * Count
    );

extern DWORD DefaultAuthLevel;
extern DWORD DefaultProviderId;

void
RpcpGetDefaultSecurityProviderInfo();


extern RPC_STATUS
ValidateSchannelPrincipalName(
    IN RPC_CHAR * EncodedName
    );

#endif // __RPCCFG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\rpcerr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1991 - 1999
//
//  File:       rpcerr.h
//
//--------------------------------------------------------------------------

/*********************************************************/
/**               Microsoft LAN Manager                 **/
/**       Copyright(c) Microsoft Corp., 1987-1990       **/
/**                                                     **/
/**     Rpc Error Codes from the compiler and runtime   **/
/**                                                     **/
/*********************************************************/

/*
If you change this file, you must also change ntstatus.mc and winerror.mc
*/

#ifndef __RPCERR_H__
#define __RPCERR_H__

#define RPC_S_OK                          0
#define RPC_S_INVALID_ARG                 1
#define RPC_S_INVALID_STRING_BINDING      2
#define RPC_S_OUT_OF_MEMORY               3
#define RPC_S_WRONG_KIND_OF_BINDING       4
#define RPC_S_INVALID_BINDING             5
#define RPC_S_PROTSEQ_NOT_SUPPORTED       6
#define RPC_S_INVALID_RPC_PROTSEQ         7
#define RPC_S_INVALID_STRING_UUID         8
#define RPC_S_INVALID_ENDPOINT_FORMAT     9

#define RPC_S_INVALID_NET_ADDR            10
#define RPC_S_INVALID_NAF_ID              11
#define RPC_S_NO_ENDPOINT_FOUND           12
#define RPC_S_INVALID_TIMEOUT             13
#define RPC_S_OBJECT_NOT_FOUND            14
#define RPC_S_ALREADY_REGISTERED          15
#define RPC_S_TYPE_ALREADY_REGISTERED     16
#define RPC_S_ALREADY_LISTENING           17
#define RPC_S_NO_PROTSEQS_REGISTERED      18
#define RPC_S_NOT_LISTENING               19

#define RPC_S_OUT_OF_THREADS              20
#define RPC_S_UNKNOWN_MGR_TYPE            21
#define RPC_S_UNKNOWN_IF                  22
#define RPC_S_NO_BINDINGS                 23
#define RPC_S_NO_PROTSEQS                 24
#define RPC_S_CANT_CREATE_ENDPOINT        25
#define RPC_S_OUT_OF_RESOURCES            26
#define RPC_S_SERVER_UNAVAILABLE          27
#define RPC_S_SERVER_TOO_BUSY             28
#define RPC_S_INVALID_NETWORK_OPTIONS     29

#define RPC_S_NO_CALL_ACTIVE              30
#define RPC_S_INVALID_LEVEL               31
#define RPC_S_CANNOT_SUPPORT              32
#define RPC_S_CALL_FAILED                 33
#define RPC_S_CALL_FAILED_DNE             34
#define RPC_S_PROTOCOL_ERROR              35

// Unused.

// Unused.

#define RPC_S_UNSUPPORTED_TRANS_SYN       38
#define RPC_S_BUFFER_TOO_SMALL            39

#define RPC_S_NO_CONTEXT_AVAILABLE        40
#define RPC_S_SERVER_OUT_OF_MEMORY        41
#define RPC_S_UNSUPPORTED_TYPE            42
#define RPC_S_ZERO_DIVIDE                 43
#define RPC_S_ADDRESS_ERROR               44
#define RPC_S_FP_DIV_ZERO                 45
#define RPC_S_FP_UNDERFLOW                46
#define RPC_S_FP_OVERFLOW                 47
#define RPC_S_INVALID_TAG                 48
#define RPC_S_INVALID_BOUND               49

#define RPC_S_NO_ENTRY_NAME               50
#define RPC_S_INVALID_NAME_SYNTAX         51
#define RPC_S_UNSUPPORTED_NAME_SYNTAX     52
#define RPC_S_UUID_LOCAL_ONLY             53
#define RPC_S_UUID_NO_ADDRESS             54
#define RPC_S_DUPLICATE_ENDPOINT          55
#define RPC_S_INVALID_SECURITY_DESC       56
#define RPC_S_ACCESS_DENIED               57
#define RPC_S_UNKNOWN_AUTHN_TYPE          58
#define RPC_S_MAX_CALLS_TOO_SMALL         59

#define RPC_S_STRING_TOO_LONG             60
#define RPC_S_PROTSEQ_NOT_FOUND           61
#define RPC_S_PROCNUM_OUT_OF_RANGE        62
#define RPC_S_BINDING_HAS_NO_AUTH         63
#define RPC_S_UNKNOWN_AUTHN_SERVICE       64
#define RPC_S_UNKNOWN_AUTHN_LEVEL         65
#define RPC_S_INVALID_AUTH_IDENTITY       66
#define RPC_S_UNKNOWN_AUTHZ_SERVICE       67
#define EPT_S_INVALID_ENTRY               68
#define EPT_S_CANT_PERFORM_OP             69

#define EPT_S_NOT_REGISTERED              70
#define RPC_S_NOTHING_TO_EXPORT           71
#define RPC_S_INCOMPLETE_NAME             72
#define RPC_S_UNIMPLEMENTED_API           73
#define RPC_S_INVALID_VERS_OPTION         74
#define RPC_S_NO_MORE_MEMBERS             75
#define RPC_S_NOT_ALL_OBJS_UNEXPORTED     76
#define RPC_S_INTERFACE_NOT_FOUND         77
#define RPC_S_ENTRY_ALREADY_EXISTS        78
#define RPC_S_ENTRY_NOT_FOUND             79

#define RPC_S_NAME_SERVICE_UNAVAILABLE    80
#define RPC_S_CALL_IN_PROGRESS            81
#define RPC_S_NO_MORE_BINDINGS            82
#define RPC_S_GROUP_MEMBER_NOT_FOUND      83
#define EPT_S_CANT_CREATE                 84
#define RPC_S_INVALID_OBJECT              85
#define RPC_S_CALL_CANCELLED              86
#define RPC_S_BINDING_INCOMPLETE          87
#define RPC_S_COMM_FAILURE                88
#define RPC_S_UNSUPPORTED_AUTHN_LEVEL     89

#define RPC_S_NO_PRINC_NAME               90
#define RPC_S_NOT_RPC_ERROR               91
#define RPC_S_SEC_PKG_ERROR               92
#define RPC_S_NOT_CANCELLED               93
#define RPC_S_SEND_INCOMPLETE             94
#define RPC_S_NO_INTERFACES               95
#define RPC_S_ASYNC_CALL_PENDING          96
#define RPC_S_INVALID_ASYNC_HANDLE        97
#define RPC_S_INVALID_ASYNC_CALL          98

#define RPC_S_INTERNAL_ERROR              100

/* The list of servers available for auto_handle binding has been exhausted. */

#define RPC_X_NO_MORE_ENTRIES		256

/* Insufficient memory available to set up necessary data structures. */

#define RPC_X_NO_MEMORY			257

/* The specified bounds of an array are inconsistent. */

#define RPC_X_INVALID_BOUND		258

/* The discriminant value does not match any of the case values. */
/* There is no default case. */

#define RPC_X_INVALID_TAG		259

/* The file designated by DCERPCCHARTRANS cannot be opened. */

#define RPC_X_SS_CHAR_TRANS_OPEN_FAIL	260

/* The file containing char translation table has fewer than 512 bytes. */

#define RPC_X_SS_CHAR_TRANS_SHORT_FILE	261

/* A null context handle is passed in an [in] parameter position. */

#define RPC_X_SS_IN_NULL_CONTEXT	262

/* Only raised on the callee side. */
/* A uuid in an [in] handle does not correspond to any known context. */

#define RPC_X_SS_CONTEXT_MISMATCH	263

/* Only raised on the caller side. */
/* A uuid in an [in, out] context handle changed during a call. */

#define RPC_X_SS_CONTEXT_DAMAGED	264

#define RPC_X_SS_HANDLES_MISMATCH	265

#define RPC_X_SS_CANNOT_GET_CALL_HANDLE	266

#define RPC_X_NULL_REF_POINTER		267

#define RPC_X_ENUM_VALUE_OUT_OF_RANGE	268

#define RPC_X_BYTE_COUNT_TOO_SMALL	269

#define RPC_X_BAD_STUB_DATA			270

#define RPC_X_INVALID_ES_ACTION			271
#define RPC_X_WRONG_ES_VERSION			272
#define RPC_X_WRONG_STUB_VERSION		273
#define RPC_X_INVALID_BUFFER			274
#define RPC_X_INVALID_PIPE_OBJECT    275
#define RPC_X_INVALID_PIPE_OPERATION 276
#define RPC_X_WRONG_PIPE_VERSION     277
#define RPC_X_PIPE_CLOSED            278
#define RPC_X_PIPE_EMPTY             279
#define RPC_X_WRONG_PIPE_ORDER       280
#define RPC_X_PIPE_DISCIPLINE_ERROR  281

#define RPC_X_PIPE_APP_MEMORY        RPC_S_OUT_OF_MEMORY
#define RPC_X_INVALID_PIPE_OPERATION RPC_X_WRONG_PIPE_ORDER

#endif /* __RPCERR_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\rpcqos.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    rpcqos.h

Abstract:

    This header file serves one purpose only: it allows the named pipe client
    side loadable transport for NT and the local RPC over LPC to use a common
    routine for parsing the security information from the network options.

Author:

    Michael Montague (mikemon) 10-Apr-1992

Revision History:

--*/

#ifndef __RPCQOS_H__
#define __RPCQOS_H__

#ifdef __cplusplus
extern "C" {
#endif

RPCRTAPI
RPC_STATUS
I_RpcParseSecurity (
    IN RPC_CHAR * NetworkOptions,
    OUT SECURITY_QUALITY_OF_SERVICE * SecurityQos
    );

#ifdef __cplusplus
}
#endif

#endif /* __RPCQOS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\rpcobj.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    rpcobj.cxx

Abstract:

    The implementation of the object dictionary lives in this file;
    it is used to map from an object uuid to a type uuid.  From there
    we need to map to a manager entry point vector.

Author:

    Michael Montague (mikemon) 14-Nov-1991

Revision History:

--*/

#include <precomp.hxx>
#include <rpcobj.hxx>

static RPC_OBJECT_INQ_FN PAPI * ObjectTypeInquiryFn = 0;


class OBJECT_ENTRY
/*++

Class Description:

    Each of the entries in the object dictionary consist of one of these
    objects.

Fields:

    ObjectUuid - Contains the object uuid of this entry.

    TypeUuid - Contains the type uuid of the object uuid in this entry.

    DictionaryKey - Contains the key in the dictionary for this object
        entry.  I made this a public instance variable for two reasons:
            (1) I was just going to defined a writer and a reader for
                it (routines to set and get the value).
            (2) This class is private to a source file, so it is very
                obvious the scope of usage.

--*/
{
private:

    RPC_UUID ObjectUuid;
    RPC_UUID TypeUuid;

public:

    unsigned int DictionaryKey;

    OBJECT_ENTRY (
        IN RPC_UUID PAPI * ObjectUuid,
        IN RPC_UUID PAPI * TypeUuid
        );

    int
    MatchObjectUuid (
        IN RPC_UUID PAPI * ObjectUuid
        );

    void
    CopyToTypeUuid (
        OUT RPC_UUID PAPI * TypeUuid
        );
};


OBJECT_ENTRY::OBJECT_ENTRY (
    IN RPC_UUID PAPI * ObjectUuid,
    IN RPC_UUID PAPI * TypeUuid
    )
/*++

Routine Description:

    This routine is used to construct an entry in the object dictionary.

Arguments:

    ObjectUuid - Supplies the uuid to use to initialize the object uuid
        in this entry.

    TypeUuid - Supplies the uuid to use to initialize the type uuid in
        this entry.

--*/
{
    ALLOCATE_THIS(OBJECT_ENTRY);

    this->ObjectUuid.CopyUuid(ObjectUuid);
    this->TypeUuid.CopyUuid(TypeUuid);
}


inline int
OBJECT_ENTRY::MatchObjectUuid (
    IN RPC_UUID PAPI * ObjectUuid
    )
/*++

Routine Description:

    This method compares the supplied object uuid against the object
    uuid contained in this object entry.

Arguments:

    ObjectUuid - Supplies the object uuid.

Return Value:

    Zero will be returned if the supplied object uuid is the same as the
    object uuid contained in this.

--*/
{
    return(this->ObjectUuid.MatchUuid(ObjectUuid));
}


inline void
OBJECT_ENTRY::CopyToTypeUuid (
    OUT RPC_UUID PAPI * TypeUuid
    )
/*++

Routine Description:

    We copy the type uuid for this object entry into the supplied type
    uuid.

Arguments:

    TypeUuid - Returns a copy of the type uuid in this object entry.

--*/
{
    TypeUuid->CopyUuid(&(this->TypeUuid));
}

NEW_SDICT(OBJECT_ENTRY);

OBJECT_ENTRY_DICT * ObjectDictionary = NULL;


OBJECT_ENTRY *
FindObject (
    IN RPC_UUID PAPI * ObjectUuid
    )
/*++

Routine Description:

    This routine is used to find the object entry in the object dictionary
    having the specified object uuid.

Arguments:

    ObjectUuid - Supplies the object uuid which we wish to find.

Return Value:

    The object entry having the supplied object uuid will be returned if
    it can be found, otherwise, zero will be returned.

--*/
{
    OBJECT_ENTRY * ObjectEntry;
    DictionaryCursor cursor;

    ObjectDictionary->Reset(cursor);
    while ((ObjectEntry = ObjectDictionary->Next(cursor)) != 0)
        {
        if (ObjectEntry->MatchObjectUuid(ObjectUuid) == 0)
            return(ObjectEntry);
        }

    return(0);
}


RPC_STATUS
ObjectInqType (
    IN RPC_UUID PAPI * ObjUuid,
    OUT RPC_UUID PAPI * TypeUuid
    )
/*++

Routine Description:

    We search in the dictionary for the specified object UUID; if it
    is found, we return its type UUID.

Parameters:

    ObjUuid - Supplies the object UUID for which we are trying to
        find the type UUID.

    TypeUuid - Returns the type UUID of the object UUID, presuming
        that the object UUID is found.

Return Value:

    RPC_S_OK - The operation completed successfully; the object uuid
        is registered with the runtime or the object inquiry function
        knows the object uuid.

    RPC_S_OBJECT_NOT_FOUND - The specified object uuid has not been
        registered with the runtime and the object inquiry function
        does not know about the object uuid.

--*/
{
    RPC_STATUS Status;
    OBJECT_ENTRY * ObjectEntry;

    if (   ObjUuid == NULL
        || ObjUuid->IsNullUuid())
        {
        TypeUuid->SetToNullUuid();
        return(RPC_S_OK);
        }

    RequestGlobalMutex();
    ObjectEntry = FindObject(ObjUuid);
    if (ObjectEntry == 0)
        {
        if (ObjectTypeInquiryFn == 0)
            {
            ClearGlobalMutex();
            TypeUuid->SetToNullUuid();
            return(RPC_S_OBJECT_NOT_FOUND);
            }
        ClearGlobalMutex();
        (*ObjectTypeInquiryFn)((UUID PAPI *) ObjUuid, (UUID PAPI *) TypeUuid,
                &Status);
        return(Status);
        }

    ObjectEntry->CopyToTypeUuid(TypeUuid);
    ClearGlobalMutex();
    return(RPC_S_OK);
}


RPC_STATUS
ObjectSetInqFn (
    IN RPC_OBJECT_INQ_FN PAPI * InquiryFn
    )
/*++

Routine Description:

    With just two lines of code, the comment for this routine is
    already longer than the routine.

Arguments:

    InquiryFn - Supplies a function to be used when the type of an
        unknown object is inquired.

Return Value:

    RPC_S_OK - This is always returned by the second line of code.

--*/
{
    ObjectTypeInquiryFn = InquiryFn;

    return(RPC_S_OK);
}


RPC_STATUS
ObjectSetType (
    IN RPC_UUID PAPI * ObjUuid,
    IN RPC_UUID PAPI * TypeUuid OPTIONAL
    )
/*++

Routine Description:

    This routine is used to associate a type UUID with an object UUID.

Arguments:

    ObjUuid - Supplies the object UUID.

    TypeUuid - Supplies the type UUID to associate with the object
        UUID.

Return Value:

    RPC_S_OK - The type UUID was successfully associated with the
        object UUID.

    RPC_S_ALREADY_REGISTERED - The object uuid specified has already
        been registered with the runtime.

    RPC_S_OUT_OF_MEMORY - There is insufficient memory available to
        associate the object UUID with the type UUID.

    RPC_S_INVALID_OBJECT - The object uuid specified is the nil uuid.

--*/
{
    OBJECT_ENTRY * ObjectEntry;

    if ( ObjUuid->IsNullUuid() != 0 )
        {
        return(RPC_S_INVALID_OBJECT);
        }

    RequestGlobalMutex();
    ObjectEntry = FindObject(ObjUuid);
    if (   (ARGUMENT_PRESENT(TypeUuid) == 0)
        || (TypeUuid->IsNullUuid() != 0))
        {
        if (ObjectEntry != 0)
            {
            ObjectDictionary->Delete(ObjectEntry->DictionaryKey);
            ClearGlobalMutex();
            return(RPC_S_OK);
            }
        ClearGlobalMutex();
        return(RPC_S_OK);
        }

    if (ObjectEntry != 0)
        {
        ClearGlobalMutex();
        return(RPC_S_ALREADY_REGISTERED);
        }

    ObjectEntry = new OBJECT_ENTRY(ObjUuid,TypeUuid);
    if (ObjectEntry == 0)
        {
        ClearGlobalMutex();
        return(RPC_S_OUT_OF_MEMORY);
        }

    ObjectEntry->DictionaryKey = ObjectDictionary->Insert(ObjectEntry);
    if (ObjectEntry->DictionaryKey == -1)
        {
        ClearGlobalMutex();
        delete ObjectEntry;
        return(RPC_S_OUT_OF_MEMORY);
        }

    ClearGlobalMutex();
    return(RPC_S_OK);
}


int
InitializeObjectDictionary (
    )
/*++

Routine Description:

    At DLL initialization time, this routine will get called.

Return Value:

    Zero will be returned if initialization completes successfully;
    otherwise, non-zero will be returned.

--*/
{
    if (ObjectDictionary == 0)
        {
        ObjectDictionary = new OBJECT_ENTRY_DICT;
        if (ObjectDictionary == 0)
            return(1);
        }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\rpcerrp.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    rpcerrp.h


Abstract:

    This file contains internal error codes used by the rpc runtime.
    Each error code has a define which begins with RPC_P_.

Author:

    Michael Montague (mikemon) 19-Nov-1991

Revision History:

--*/

#ifndef __RPCERRP_H__
#define __RPCERRP_H__

#ifdef WIN32RPC
#define RPC_P_NETWORK_ADDRESS_TOO_SMALL   0xC0021000L
#define RPC_P_ENDPOINT_TOO_SMALL          0xC0021001L
#define RPC_P_UNSUPPORTED_TRANSFER_SYNTAX 0xC0021005L
#define RPC_P_UNSUPPORTED_INTERFACE       0xC0021006L
#define RPC_P_RECEIVE_ALERTED             0xC0021007L
#define RPC_P_CONNECTION_CLOSED           0xC0021008L
#define RPC_P_RECEIVE_FAILED              0xC0021009L
#define RPC_P_SEND_FAILED                 0xC002100AL
#define RPC_P_TIMEOUT                     0xC002100BL
#define RPC_P_SERVER_TRANSPORT_ERROR      0xC002100CL
#define RPC_P_OK_REQUEST                  0xC002100DL
#define RPC_P_EXCEPTION_OCCURED           0xC002100EL
#define RPC_P_CONTINUE_NEEDED             0xC002100FL
#define RPC_P_COMPLETE_NEEDED             0xC0021010L
#define RPC_P_COMPLETE_AND_CONTINUE       0xC0021011L
#define RPC_P_CONNECTION_SHUTDOWN         0xC0021012L
#define RPC_P_EPMAPPER_EP                 0xC0021013L
#define RPC_P_OVERSIZE_PACKET             0xC0021014L
#define RPC_P_RECEIVE_COMPLETE            0xC0021015L
#define RPC_P_CONTEXT_EXPIRED             0xC0021016L
//#define RPC_P_ABORT_CALL                  0xC0020017L
#define RPC_P_IO_PENDING                  0xC0020018L
#define RPC_P_NO_BUFFERS                  0xC0020019L
#define RPC_P_FOUND_IN_CACHE              0xC0021020L
#define RPC_P_MATCHED_CACHE               0xC0021021L
#define RPC_P_PARTIAL_RECEIVE             0xC0021022L
#define RPC_P_HOST_DOWN                   0XC0021023L
#define RPC_P_PORT_DOWN                   0xC0021024L
#define RPC_P_CLIENT_SHUTDOWN_IN_PROGRESS 0xC0021025L
#define RPC_P_TRANSFER_SYNTAX_CHANGED     0xC0021026L
#define RPC_P_ADDRESS_FAMILY_INVALID      0xC0021028L
#define RPC_P_PACKET_CONSUMED             0xC0021029L
#define RPC_P_CHANNEL_NEEDS_RECYCLING     0xC002102AL
#define RPC_P_PACKET_NEEDS_FORWARDING     0xC002102BL
#define RPC_P_AUTH_NEEDED                 0xC002102CL
#define RPC_P_ABORT_NEEDED                0xC002102DL
#define RPC_P_INITIALIZE_HTTP2_CONNECTION 0xC002102EL
#else // WIN32RPC

#define RPC_P_NETWORK_ADDRESS_TOO_SMALL   1000
#define RPC_P_ENDPOINT_TOO_SMALL          1001
#define RPC_P_UNSUPPORTED_TRANSFER_SYNTAX 1005
#define RPC_P_UNSUPPORTED_INTERFACE       1006
#define RPC_P_RECEIVE_ALERTED             1007
#define RPC_P_CONNECTION_CLOSED           1008
#define RPC_P_RECEIVE_FAILED              1009
#define RPC_P_SEND_FAILED                 1010
#define RPC_P_TIMEOUT                     1011
#define RPC_P_SERVER_TRANSPORT_ERROR      1012
#define RPC_P_OK_REQUEST                  1013
#define RPC_P_EXCEPTION_OCCURED           1014
#define RPC_P_CONTINUE_NEEDED             1015
#define RPC_P_COMPLETE_NEEDED             1016
#define RPC_P_COMPLETE_AND_CONTINUE       1017
#define RPC_P_CONNECTION_SHUTDOWN         1018
#define RPC_P_EPMAPPER_EP                 1019
#define RPC_P_OVERSIZE_PACKET             1020
#define RPC_P_THREAD_LISTENING            1021
#define RPC_P_CONTEXT_EXPIRED             1022
#define RPC_P_ABORT_CALL                  1023
#define RPC_P_IO_PENDING                  1024
#define RPC_P_NO_BUFFERS                  1025
#define RPC_P_FOUND_IN_CACHE              1026
#define RPC_P_MATCHED_CACHE               1027
#define RPC_P_PARTIAL_RECEIVE             1028
#endif // WIN32RPC

//
// DCE on-the-wire error codes
//
#define NCA_STATUS_COMM_FAILURE             0x1C010001
#define NCA_STATUS_OP_RNG_ERROR             0x1C010002
#define NCA_STATUS_UNK_IF                   0x1C010003
#define NCA_STATUS_WRONG_BOOT_TIME          0x1C010006
#define NCA_STATUS_YOU_CRASHED              0x1C010009
#define NCA_STATUS_PROTO_ERROR              0x1C01000B
#define NCA_STATUS_OUT_ARGS_TOO_BIG         0x1C010013
#define NCA_STATUS_SERVER_TOO_BUSY          0x1C010014
#define NCA_STATUS_UNSUPPORTED_TYPE         0x1C010017
#define NCA_STATUS_INVALID_PRES_CXT_ID      0x1C01001c
#define NCA_STATUS_UNSUPPORTED_AUTHN_LEVEL  0x1C01001d
#define NCA_STATUS_INVALID_CHECKSUM         0x1C01001f
#define NCA_STATUS_INVALID_CRC              0x1C010020

#define NCA_STATUS_ZERO_DIVIDE              0x1C000001
#define NCA_STATUS_ADDRESS_ERROR            0x1C000002
#define NCA_STATUS_FP_DIV_ZERO              0x1C000003
#define NCA_STATUS_FP_UNDERFLOW             0x1C000004
#define NCA_STATUS_FP_OVERFLOW              0x1C000005
#define NCA_STATUS_INVALID_TAG              0x1C000006
#define NCA_STATUS_INVALID_BOUND            0x1C000007
#define NCA_STATUS_VERSION_MISMATCH         0x1C000008
#define NCA_STATUS_UNSPEC_REJECT            0x1C000009
#define NCA_STATUS_BAD_ACTID                0x1C00000A
#define NCA_STATUS_WHO_ARE_YOU_FAILED       0x1C00000B
#define NCA_STATUS_CALL_DNE                 0x1C00000C
#define NCA_STATUS_FAULT_CANCEL             0x1C00000D
#define NCA_STATUS_ILLEGAL_INSTRUCTION      0x1C00000E
#define NCA_STATUS_FP_ERROR                 0x1C00000F
#define NCA_STATUS_OVERFLOW                 0x1C000010
#define NCA_STATUS_FAULT_UNSPEC             0x1C000012
#define NCA_STATUS_FAULT_PIPE_EMPTY         0x1C000014
#define NCA_STATUS_FAULT_PIPE_CLOSED        0x1C000015
#define NCA_STATUS_FAULT_PIPE_ORDER         0x1C000016
#define NCA_STATUS_FAULT_PIPE_DISCIPLINE    0x1C000017
#define NCA_STATUS_FAULT_PIPE_COMM_ERROR    0x1C000018
#define NCA_STATUS_FAULT_PIPE_MEMORY        0x1C000019
#define NCA_STATUS_CONTEXT_MISMATCH         0x1C00001A
#define NCA_STATUS_REMOTE_OUT_OF_MEMORY     0x1C00001B

#define NCA_STATUS_PARTIAL_CREDENTIALS      0x16C9A117

#endif // __RPCERRP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\sdict2.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1990 - 1999
//
//  File:       sdict2.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

File : sdict2.cxx

Title : Simple dictionary.

Description :

History :

-------------------------------------------------------------------- */

#include <precomp.hxx>
#include <sdict2.hxx>

SIMPLE_DICT2::SIMPLE_DICT2 (
    )
{
    unsigned int iDictSlots;

    ALLOCATE_THIS(SIMPLE_DICT2);

    cDictSlots = INITIALDICT2SLOTS;
    DictKeys = InitialDictKeys;
    DictItems = InitialDictItems;
    for (iDictSlots = 0; iDictSlots < cDictSlots; iDictSlots++)
        {
        DictKeys [iDictSlots] = (void *) 0;
        DictItems[iDictSlots] = (void *) 0;
        }
}

SIMPLE_DICT2::~SIMPLE_DICT2 (
    )
{
    if (DictKeys != InitialDictKeys)
        {
        ASSERT(DictItems != InitialDictItems);

        delete DictKeys;
        delete DictItems;
        }
}

int
SIMPLE_DICT2::Insert (
    void * Key,
    void * Item
    )
{
    unsigned int iDictSlots;
    void * * NewDictKeys;
    void * * NewDictItems;

    for (iDictSlots = 0; iDictSlots < cDictSlots; iDictSlots++)
        {
        if (DictKeys[iDictSlots] == (void *) 0)
            {
            DictKeys[iDictSlots] = Key;
            DictItems[iDictSlots] = Item;
            return(0);
            }
        }
    // Otherwise, we need to expand the size of the dictionary.
    NewDictKeys = (void * *)
                    new unsigned char [sizeof(void *) * cDictSlots * 2];
    NewDictItems = (void * *)
                    new unsigned char [sizeof(void *) * cDictSlots * 2];
    if (NewDictKeys == (void *) 0)
        {
        if (NewDictItems)
            delete NewDictItems;
        return(-1);
        }
    if (NewDictItems == (void *) 0)
        {
        delete NewDictKeys;
        return(-1);
        }

    for (iDictSlots = 0; iDictSlots < cDictSlots; iDictSlots++)
        {
        NewDictKeys[iDictSlots] = DictKeys[iDictSlots];
        NewDictItems[iDictSlots] = DictItems[iDictSlots];
        }
    cDictSlots *= 2;
    NewDictKeys[iDictSlots] = Key;
    NewDictItems[iDictSlots] = Item;
    for (iDictSlots++; iDictSlots < cDictSlots; iDictSlots++)
        {
        NewDictKeys[iDictSlots] = (void *) 0;
        NewDictItems[iDictSlots] = (void *) 0;
        }
    if (DictKeys != InitialDictKeys)
        {
        ASSERT(DictItems != InitialDictItems);

        delete DictKeys;
        delete DictItems;
        }

    DictKeys = NewDictKeys;
    DictItems = NewDictItems;

    return(0);
}

void *
SIMPLE_DICT2::Delete (
    void * Key
    )
{
    unsigned int iDictSlots;

    for (iDictSlots = 0; iDictSlots < cDictSlots; iDictSlots++)
        {
        if (DictKeys[iDictSlots] == Key)
            {
            void * Item = DictItems[iDictSlots];

            DictKeys [iDictSlots] = (void *) 0;
            DictItems[iDictSlots] = (void *) 0;

            return Item;
            }
        }
    return((void *) 0);
}

void *
SIMPLE_DICT2::Find (
    void * Key
    )
{
    unsigned int iDictSlots;

    for (iDictSlots = 0; iDictSlots < cDictSlots; iDictSlots++)
        {
        if (DictKeys[iDictSlots] == Key)
            {
            return(DictItems[iDictSlots]);
            }
        }
    return((void *) 0);
}

void
SIMPLE_DICT2::Update (
    void * Key,
    void *Item
    )
{
    unsigned int iDictSlots;

    for (iDictSlots = 0; iDictSlots < cDictSlots; iDictSlots++)
        {
        if (DictKeys[iDictSlots] == Key)
            {
            DictItems[iDictSlots] = Item ;
            return;
            }
        }

    ASSERT(0) ;
}

void *SIMPLE_DICT2::Next (DictionaryCursor &cursor, BOOL fRemove)
{
    for ( ; cursor < cDictSlots; cursor++)
        {
        if (DictKeys[cursor])
            {
            if (fRemove)
                {
                DictKeys[cursor] = 0;
                }

            return(DictItems[cursor++]);
            }
        }

    cursor = Nil;
    return(Nil);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\sdict.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1990 - 1999
//
//  File:       sdict.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

File : sdict.cxx

Title : A simple dictionary.

Description :

History :

mikemon    ??-??-??    Beginning of time.
mikemon    10-30-90    Fixed the dictionary size.

-------------------------------------------------------------------- */

#include <precomp.hxx>

SIMPLE_DICT::SIMPLE_DICT()
{
    ALLOCATE_THIS(SIMPLE_DICT);

    cDictSize = 0;
    cDictSlots = INITIALDICTSLOTS;

    DictSlots = InitialDictSlots;
    memset(DictSlots, 0, sizeof(void *) * cDictSlots);
}

SIMPLE_DICT::~SIMPLE_DICT()
{
    if (DictSlots != InitialDictSlots)
        delete DictSlots;
}

unsigned int
SIMPLE_DICT::Insert (
    void *Item
    )
{
    unsigned int iDictSlots;
    BOOL Res;

    for (iDictSlots = 0; iDictSlots < cDictSlots; iDictSlots++)

        if (DictSlots[iDictSlots] == Nil)
            {
            DictSlots[iDictSlots] = Item;
            cDictSize += 1;
            return(iDictSlots);
            }

    // If we fell through to here, it must mean that the dictionary is
    // full; hence we need to allocate more space and copy the old
    // dictionary into it.

    Res = ExpandToSize(cDictSlots * 2);
    if (!Res)
        return (-1);

    DictSlots[iDictSlots] = Item;
    cDictSize += 1;
    return(iDictSlots);
}

void * 
SIMPLE_DICT::DeleteItemByBruteForce(
    void * Item
    )
{
   
    if (Item == 0)
       {
       return (0);
       }

    for (unsigned int i = 0; i < cDictSlots; i++)
        {
        if (DictSlots[i] == Item)
           {
           DictSlots[i] = Nil; 
           cDictSize -= 1;
           return (Item);
           }
        }

    return (0);
}

void *
SIMPLE_DICT::Delete (
    unsigned int Key
    )
{
    void *Item;

    if (Key >= cDictSlots)
        {
        return(Nil);
        }

    Item = DictSlots[Key];
    ASSERT((DictSlots[Key]));

    cDictSize -= 1;
    DictSlots[Key] = Nil;

    return(Item);
}

unsigned int
SIMPLE_DICT::ExpandToSize (
    unsigned int Size
    )
{
    void * * NewDictSlots;

    if (Size <= cDictSlots)
        return cDictSlots;  // cDictSlots is simply a quick non-zero value

    NewDictSlots = (void * *) new char[sizeof(void *) * Size];
    if (!NewDictSlots)
        return(0);

    RpcpMemoryCopy(NewDictSlots, DictSlots, sizeof(void *) * cDictSlots);
    RpcpMemorySet(NewDictSlots + cDictSlots, 0,  sizeof(void *) * (Size - cDictSlots));

    if (DictSlots != InitialDictSlots)
        delete DictSlots;
    DictSlots = NewDictSlots;

    cDictSlots = Size;

    return cDictSlots; // cDictSlots is simply a quick non-zero value
}

void
SIMPLE_DICT::DeleteAll (
    void
    )
{
    RpcpMemorySet(DictSlots, 0, cDictSlots * sizeof(void *));
}

void *
SIMPLE_DICT::Next (DictionaryCursor &cursor
    )
{
    for ( ; cursor < cDictSlots; cursor++)
        {
        if (DictSlots[cursor])
            return(DictSlots[cursor++]);
        }

    cursor = Nil;
    return(Nil);
}

void *SIMPLE_DICT::RemoveNext(DictionaryCursor &cursor)
{
    for ( ; cursor < cDictSlots; cursor++)
        {
        if (DictSlots[cursor])
            {
            void *Item = DictSlots[cursor];
            
            cDictSize -= 1;
            DictSlots[cursor] = Nil;
            cursor++;
            
            return(Item);
            }
        }

    cursor = Nil;
    return(Nil);
}

void *SIMPLE_DICT::NextWithKey (DictionaryCursor &cursor, unsigned int *Key)
{
    for ( ; cursor < cDictSlots; cursor++)
        {
        if (DictSlots[cursor])
            {
            *Key = cursor;
            return(DictSlots[cursor++]);
            }
        }

    cursor = Nil;
    return(Nil);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\rpcssp.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    rpcssp.h

Abstract:

    This file contains the interface use by the RPC runtime to access
    a security support package.

Author:

    Michael Montague (mikemon) 15-Apr-1992

Revision History:

--*/

#ifndef __RPCSSP_H__
#define __RPCSSP_H__

#ifdef WIN32RPC
#define SECURITY_WIN32
#endif // WIN32RPC

#ifdef MAC
#define SECURITY_MAC
#endif

#ifdef DOS
#ifdef WIN
#define SECURITY_WIN16
#else // WIN
#define SECURITY_DOS
#endif // WIN
#endif // DOS

#include <security.h>

typedef struct _DCE_SECURITY_INFO
{
    unsigned long SendSequenceNumber;
    unsigned long ReceiveSequenceNumber;
    UUID AssociationUuid;
} DCE_SECURITY_INFO;

typedef struct _DCE_INIT_SECURITY_INFO
{
    DCE_SECURITY_INFO DceSecurityInfo;
    unsigned long AuthorizationService;
    unsigned char PacketType;
} DCE_INIT_SECURITY_INFO;

typedef struct _DCE_MSG_SECURITY_INFO
{
    unsigned long SendSequenceNumber;
    unsigned long ReceiveSequenceNumber;
    unsigned char PacketType;
} DCE_MSG_SECURITY_INFO;

#endif /* __RPCSSP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Revision History:

!ENDIF

TARGETNAME=rpcmtrt
TARGETTYPE=LIBRARY
TARGETPATH=obj

INCLUDES= \
    ..\; \
    ..\..\inc; \
    $(NET_INC_PATH); \
    $(DS_INC_PATH); \
    $(DS_INC_PATH)\crypto; \
    ..\..\rtifs\$(O); \
    ..\..\trans; \
    ..\..\CharConv; \
    ..\..\..\ndrlib; \
    $(INCLUDES); \
    $(SDXROOT)\public\internal\base\inc

#
# Setup for application developer to set breakpoints with windbg
#

MSC_WARNING_LEVEL=/W3 /WX

#NTDEBUG=ntsd
#NTDEBUGTYPE=windbg
#MSC_OPTIMIZATION=/Od

PRECOMPILED_INCLUDE=..\precomp.hxx
PRECOMPILED_CXX=1

SOURCES=$(SOURCES)      \
        ..\async.cxx    \
        ..\bcache.cxx   \
        ..\binding.cxx  \
        ..\bitset.cxx   \
        ..\bufapi.cxx   \
        ..\CellHeap.cxx \
        ..\clntapip.cxx \
        ..\dcebind.cxx  \
        ..\dcecmisc.cxx \
        ..\dcecmmn.cxx  \
        ..\dcestrng.cxx \
        ..\dcesvr.cxx   \
        ..\dcethunk.cxx \
        ..\dceuuid.cxx  \
        ..\delaytab.cxx \
        ..\dgclnt.cxx   \
        ..\dgpkt.cxx    \
        ..\dgsvr.cxx    \
        ..\dispatch.c   \
        ..\dispatch.c   \
        ..\eeinfo.cxx   \
        ..\epclnt.cxx   \
        ..\epmapper.cxx \
        ..\epmgmt.cxx   \
        ..\eventwrp.cxx \
        ..\gc.cxx       \
        ..\handle.cxx   \
        ..\hashtabl.cxx \
        ..\hndlsvr.cxx  \
        ..\init.cxx     \
        ..\LinkList.cxx \
        ..\locks.cxx    \
        ..\memory.cxx   \
        ..\miscnt.cxx   \
        ..\msgapi.cxx   \
        ..\mutex.cxx    \
        ..\osfclnt.cxx  \
        ..\osfpcket.cxx \
        ..\osfsvr.cxx   \
        ..\principal.cxx\
        ..\ProtBind.cxx \
        ..\queue.cxx    \
        ..\rpcobj.cxx   \
        ..\rpcuuid.cxx  \
        ..\sdict.cxx    \
        ..\sdict2.cxx   \
        ..\secclnt.cxx  \
	..\sidcache.cxx \
        ..\sinfoapi.cxx \
        ..\svrapip.cxx  \
        ..\svrbind.cxx  \
        ..\svrmgmt.c    \
        ..\swmr.cxx     \
        ..\threads.cxx  \
        ..\tower.cxx    \
        ..\uuidsup.cxx  \
        ..\util.cxx


RPCENV= $(RPCENV) -DWIN32RPC -DNTWIN32RPC -D_RPCRT4_

C_DEFINES=$(RPCENV) $(RPCTARGETENV) /DMSWMSG -D_RPCRT4_

# Used only for unit tests
# USE_MSVCRT=1
#        ..\linklist.cxx

UMTYPE=console
UMTEST=usvr*uclnt*dumpcert
UMLIBS=$(UMLIBS) \
    ..\..\dll\$(ALT_PROJECT_TARGET)\$(O)\rpcrt4.lib\
    $(O)\pipe.obj \
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\user32.lib   \
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SDK_LIB_PATH)\ws2_32.lib \
    $(SDK_LIB_PATH)\iphlpapi.lib \
    $(SDK_LIB_PATH)\crypt32.lib \
    ..\..\CharConv\$(ALT_PROJECT_TARGET)\$(O)\CharConv.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\sinfoapi.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1990 - 1999
//
//  File:       sinfoapi.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

                      Microsoft OS/2 LAN Manager
                   Copyright(c) Microsoft Corp., 1990

-------------------------------------------------------------------- */
/* --------------------------------------------------------------------

File : sinfoapi.cxx

-------------------------------------------------------------------- */

#include <precomp.hxx>
#include <hndlsvr.hxx>
#include <thrdctx.hxx>

/* --------------------------------------------------------------------
A server thread calls this API to obtain the current call handle it should
be using.
-------------------------------------------------------------------- */
RPC_BINDING_HANDLE RPC_ENTRY
I_RpcGetCurrentCallHandle (
    )
{
#ifdef RPC_DELAYED_INITIALIZATION

    if ( RpcHasBeenInitialized == 0 )
        {
        RPC_STATUS RpcStatus;

        RpcStatus = PerformRpcInitialization();
        if ( RpcStatus != RPC_S_OK )
            return((RPC_BINDING_HANDLE) 0);
        }

#endif // RPC_DELAYED_INITIALIZATION

    return(RpcpGetThreadContext());
}

/* --------------------------------------------------------------------
-------------------------------------------------------------------- */

RPC_STATUS RPC_ENTRY
I_RpcServerInqTransportType(
    OUT unsigned int __RPC_FAR * Type
    )
/*++

Routine Description:

    Determines what kind of transport on the current thread

Arguments:

    Type - Points to the type of binding if the functions succeeds.
           One of:
           TRANSPORT_TYPE_CN
           TRANSPORT_TYPE_DG
           TRANSPORT_TYPE_LPC
           TRANSPORT_TYPE_WMSG

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_INVALID_BINDING - When the argument is not a binding handle.

--*/
{
    SCALL *SCall ;

    AssertRpcInitialized();

    ASSERT(!RpcpCheckHeap());

    SCall = (SCALL *) RpcpGetThreadContext() ;
    if (!SCall)
        {
        return (RPC_S_NO_CALL_ACTIVE) ;
        }

    return (SCall->InqTransportType(Type)) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\secclnt.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    secclnt.cxx

Abstract:

    Implementation of security objects.

Author:

    Michael Montague (mikemon) 11-Apr-1992

Revision History:

    21-Feb-1997     jroberts    Added some SSL support.

--*/


#include <precomp.hxx>
#include <wincrypt.h>
#include <rpcssl.h>
#include <cryptimp.hxx>
#include <rpccfg.h>
#include <spseal.h>
#include <schnlsp.h>
#include <hndlsvr.hxx>

int SecuritySupportLoaded = 0;
int FailedToLoad = 0;

unsigned long NumberOfProviders = 0;
unsigned long LoadedProviders = 0;
unsigned long AvailableProviders = 0;
SECURITY_PROVIDER_INFO PAPI * ProviderList = 0;
MUTEX * SecurityCritSect;   // Mutex for the Server credentials cache.

// Incremented each time we leak SECURITY_CONTEXT::SecurityContext or
// SECURITY_CREDENTIALS::CredentialsHandle due to DeleteSecurityContext
// or FreeCredentialHandle returning SEC_E_INSUFFICIENT_MEMORY.
unsigned int nSecurityStructuresLeaked = 0;

struct PACKAGE_LEG_INFO
{
    DWORD               Package;
    PACKAGE_LEG_COUNT   Legs;
};

const PACKAGE_LEG_INFO PredefinedPackageLegInfo[] =
{
    { RPC_C_AUTHN_WINNT,        ThreeLegs },
    { RPC_C_AUTHN_GSS_NEGOTIATE,EvenNumberOfLegs },
    { RPC_C_AUTHN_GSS_KERBEROS, EvenNumberOfLegs },
    { RPC_C_AUTHN_GSS_SCHANNEL, EvenNumberOfLegs },
    { RPC_C_AUTHN_DPA,          ThreeLegs },
    { RPC_C_AUTHN_DCE_PRIVATE,  ThreeLegs },
    { 0x44,                     ThreeLegs },        // RPC_C_AUTHN_NETLOGON from net\svcdlls\logonsrv\nlbind.h
    { 0,                        LegsUnknown }
};

// defined in principal.cxx
//
extern
DWORD
RpcCertMatchPrincipalName(
                   PCCERT_CONTEXT Context,
                   RPC_CHAR PrincipalName[]
                   );

#ifdef UNICODE
#define SEC_TCHAR   SEC_WCHAR
#else
#define SEC_TCHAR   SEC_CHAR
#endif


RPC_STATUS
FindSecurityPackage (
    IN unsigned long AuthenticationService,
    IN unsigned long AuthenticationLevel,
    OUT unsigned int __RPC_FAR * ProviderIndex,
    OUT unsigned int __RPC_FAR * PackageIndex
    );



RPC_STATUS
InsureSecuritySupportLoaded (
    )
/*++

Routine Description:

    This routine insures that the security support is loaded; if it is not
    loaded, then we go ahead and load it.

Return Value:

    A zero result indicates that security support has successfully been
    loaded, and is ready to go.

--*/
{
    RPC_STATUS Status = RPC_S_OK;

    if ( SecuritySupportLoaded != 0 )
        {
        return(0);
        }

    RequestGlobalMutex();
    if ( SecuritySupportLoaded != 0 )
        {
        ClearGlobalMutex();
        return(0);
        }

    SecurityCritSect = new MUTEX(&Status,
                                 TRUE  // pre-allocate semaphore
                                 );

    if (SecurityCritSect == 0)
        {
        Status = RPC_S_OUT_OF_MEMORY;
        }

    if (Status == RPC_S_OK)
        {
        SecuritySupportLoaded = 1;
        }

     ClearGlobalMutex();
     return (Status);
}



RPC_STATUS
IsAuthenticationServiceSupported (
    IN unsigned long AuthenticationService
    )
/*++

Routine Description:

    This routine is used to determine whether or not an authentication
    service is supported by the current configuration.

Arguments:

    AuthenticationService - Supplies a proposed authentication service.

Return Value:

    RPC_S_OK - The supplied authentication service is supported by the
        current configuration.

    RPC_S_UNKNOWN_AUTHN_SERVICE - The supplied authentication service
        is unknown, and not supported by the current configuration.

--*/
{
    unsigned int PackageIndex, ProviderIndex;

    // First make sure that the security support has been loaded.

    if ( InsureSecuritySupportLoaded() != RPC_S_OK )
        {
        return(RPC_S_OUT_OF_MEMORY);
        }


     return ( FindSecurityPackage(
                       AuthenticationService,
                       RPC_C_AUTHN_LEVEL_CONNECT,
                       &ProviderIndex,
                       &PackageIndex
                       ) );

}


RPC_STATUS
FindSecurityPackage (
    IN unsigned long AuthenticationService,
    IN unsigned long AuthenticationLevel,
    OUT unsigned int __RPC_FAR * ProviderIndex,
    OUT unsigned int __RPC_FAR * PackageIndex
    )
/*++

Routine Description:

    The methods used to acquire credentials for the client and the server use
    this routine to find a security package, given the an authentication
    service.

Arguments:

    AuthenticationService - Supplies the authentication service to be used
        (for the credentials and for the context).

    AuthenticationLevel - Supplies the authentication level to be used by
        these credentials.  It will already have been mapped by the protocol
        module into the final level.

    RpcStatus - Returns the status of the operation.  It will be one of the
        following values.

        RPC_S_OK - The return value from this routine is the index of
            the appropriate security package.

        RPC_S_UNKNOWN_AUTHN_SERVICE - The specified authentication service is
            not supported by the current configuration.

        RPC_S_UNKNOWN_AUTHN_LEVEL - The specified authentication level is not
            supported by the requested authentication service.

Return Value:

    If RpcStatus contains RPC_S_OK, then the index of the appropriate
    security package will be returned.

--*/
{
    unsigned int Index, i;
    INIT_SECURITY_INTERFACE InitSecurityInterface;
    PSecurityFunctionTable SecurityInterface = 0;
    SecPkgInfo PAPI * tmpPkgList;
    SECURITY_PACKAGE_INFO * SecurityPackages;
    SECURITY_PROVIDER_INFO PAPI * List;
    unsigned long NumberOfPackages, Total;
    RPC_CHAR * DllName = NULL;
    DLL * ProviderDll;
    RPC_STATUS Status = RPC_S_UNKNOWN_AUTHN_SERVICE;

    // First make sure that the security support has been loaded.

    if ( InsureSecuritySupportLoaded() != RPC_S_OK )
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    // 0xFFFF ia a "not-an-RPC-ID", indicating that the protocol
    // is not for use by RPC.
    if (AuthenticationService == 0xFFFF)
        {
        return(RPC_S_UNKNOWN_AUTHN_SERVICE);
        }

    SecurityCritSect->Request();

    List = ProviderList;
    for (i = 0; i < LoadedProviders; i ++)
        {

        SecurityPackages = List->SecurityPackages;
        NumberOfPackages = List->Count;

        for (Index = 0;Index < (unsigned int) NumberOfPackages;Index++)
            {
            if ( SecurityPackages[Index].PackageInfo.wRPCID == AuthenticationService )
               {
               if ( (AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
                   || ( AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT) )
                  {
                  if ( (SecurityPackages[Index].PackageInfo.fCapabilities
                            & SECPKG_FLAG_INTEGRITY) == 0 )
                     {
                     Status = RPC_S_UNKNOWN_AUTHN_LEVEL;
                     goto Cleanup;
                     }
                  }
               if ( AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT_PRIVACY )
                  {
                  if ( (SecurityPackages[Index].PackageInfo.fCapabilities
                            & SECPKG_FLAG_PRIVACY) == 0 )
                     {
                     Status =  RPC_S_UNKNOWN_AUTHN_LEVEL;
                     goto Cleanup;
                     }
                  }
              Status = RPC_S_OK;
              *ProviderIndex = i;
              *PackageIndex = Index;
              break;
              }
           } //For over all packages in one provider(dll)

        if (Status == RPC_S_OK)
           {
           SecurityCritSect->Clear();
           return(Status);
           }
        List++;
        } //For over all providers(dll)

    if ((LoadedProviders == AvailableProviders) && (LoadedProviders != 0))
       {
       goto Cleanup;
       }

    Status = RpcGetSecurityProviderInfo (
                  AuthenticationService, &DllName, &Total);

    ASSERT(!RpcpCheckHeap());

    if (Status != RPC_S_OK)
       {
       goto Cleanup;
       }

    if (ProviderList == 0)
        {
        ProviderList = (SECURITY_PROVIDER_INFO PAPI *)
                        new char [sizeof(SECURITY_PROVIDER_INFO) * Total];
        if (ProviderList == 0)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            goto Cleanup;
            }
        AvailableProviders = Total;
        }
    else
        {
        List = ProviderList;
        for (i = 0; i < LoadedProviders; i ++)
            {
            if (RpcpStringCompare(DllName, List->ProviderDllName) == 0)
                {
                delete DllName;
                Status = RPC_S_UNKNOWN_AUTHN_SERVICE;
                goto Cleanup;
                }
            List++;
            }
        }

    ProviderDll = new DLL(DllName, &Status);

    if (ProviderDll == NULL)
        {
        Status = RPC_S_OUT_OF_MEMORY;
        goto Cleanup;
        }

    if (Status == RPC_S_INVALID_ARG)
        {
        delete ProviderDll;
        Status = RPC_S_UNKNOWN_AUTHN_SERVICE;
        goto Cleanup;
        }
    else if (Status != RPC_S_OK)
        {
        delete ProviderDll;
        goto Cleanup;
        }

    ASSERT(!RpcpCheckHeap());

    InitSecurityInterface = (INIT_SECURITY_INTERFACE_W)
            ProviderDll->GetEntryPoint(SECURITY_ENTRYPOINT_ANSIW);

    if ( InitSecurityInterface == 0 )
        {
        delete ProviderDll;
        Status = RPC_S_UNKNOWN_AUTHN_SERVICE;
        goto Cleanup;
        }

    SecurityInterface = (*InitSecurityInterface)();
    if (   (SecurityInterface == 0)
        || (SecurityInterface->dwVersion
                    < SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION) )
        {
        delete ProviderDll;
        Status = RPC_S_UNKNOWN_AUTHN_SERVICE;
        goto Cleanup;
        }

    Status = (*SecurityInterface->EnumerateSecurityPackages)(
                          &NumberOfPackages, &tmpPkgList);

    if ( Status != SEC_E_OK)
        {
        delete ProviderDll;

        if (Status == SEC_E_INSUFFICIENT_MEMORY)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }
        else
            {
            VALIDATE(Status) {
                SEC_E_SECPKG_NOT_FOUND
                } END_VALIDATE;
            Status = RPC_S_UNKNOWN_AUTHN_SERVICE;
            }

        goto Cleanup;
        }

   ProviderList[LoadedProviders].Count = NumberOfPackages;
   ProviderList[LoadedProviders].RpcSecurityInterface = SecurityInterface;
   ProviderList[LoadedProviders].ProviderDll = ProviderDll;
   ProviderList[LoadedProviders].ProviderDllName = DllName;
   *ProviderIndex = LoadedProviders;

   //
   // Fill in the SecurityPackages member for this Provider.
   //
   ProviderList[LoadedProviders].SecurityPackages =
        (SECURITY_PACKAGE_INFO *) new char
        [sizeof(SECURITY_PACKAGE_INFO) * NumberOfPackages];
   if (ProviderList[LoadedProviders].SecurityPackages == NULL)
       {
       Status = RPC_S_OUT_OF_MEMORY;
       goto Cleanup;
       }

   //
   // Save the SecPkgInfo array to the SecurityPackages structure.
   //
   for (i = 0; i < NumberOfPackages; i++)
       {
       ProviderList[LoadedProviders].
       SecurityPackages[i].
       PackageInfo = tmpPkgList[i];

       ProviderList[LoadedProviders].
       SecurityPackages[i].
       ServerSecurityCredentials = NULL;
       }


   SecurityPackages = ProviderList[LoadedProviders].SecurityPackages;
   Status = RPC_S_UNKNOWN_AUTHN_SERVICE;
   for (i = 0; i < NumberOfPackages; i++)
       {
       if ( SecurityPackages[i].PackageInfo.wRPCID == AuthenticationService )
          {
          if ( ( AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT_INTEGRITY )
             ||( AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT) )
              {
              if ( (SecurityPackages[i].PackageInfo.fCapabilities
                    & SECPKG_FLAG_INTEGRITY) == 0 )
                  {
                  Status = RPC_S_UNKNOWN_AUTHN_LEVEL;
                  continue;
                  }
              }
          if ( AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT_PRIVACY )
              {
              if ( (SecurityPackages[i].PackageInfo.fCapabilities
                            & SECPKG_FLAG_PRIVACY) == 0 )
                  {
                  Status = RPC_S_UNKNOWN_AUTHN_LEVEL;
                  continue;
                  }
              }
          *PackageIndex = i;
          Status = RPC_S_OK;
          break;
          }
       }
   LoadedProviders++;

Cleanup:
   SecurityCritSect->Clear();
   return(Status);
}




RPC_STATUS
FindServerCredentials (
    IN RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn,
    IN void __RPC_FAR * Arg,
    IN unsigned long AuthenticationService,
    IN unsigned long AuthenticationLevel,
    IN RPC_CHAR __RPC_FAR * Principal,
    IN OUT SECURITY_CREDENTIALS ** SecurityCredentials
    )
/*++

Routine Description:

    The method is used to find cached server credentials for use by the
    server.

Arguments:

    AuthenticationService - Supplies the authentication service to be used
        (for the credentials and for the context).

    AuthenticationLevel - Supplies the authentication level to be used by
        these credentials.  It will already have been mapped by the protocol
        module into the final level.

    SecurityCredentials - TBS

    RpcStatus - Returns the status of the operation.  It will be one of the
        following values.

        RPC_S_OK - The return value from this routine is the index of
            the appropriate security package.

        RPC_S_UNKNOWN_AUTHN_SERVICE - The specified authentication service is
            not supported by the current configuration.

        RPC_S_UNKNOWN_AUTHN_LEVEL - The specified authentication level is not
            supported by the requested authentication service.

Return Value:

    If RpcStatus contains RPC_S_OK, then valid credentials are passed
    back.

--*/
{

    SECURITY_STATUS SecurityStatus;
    TimeStamp TimeStamp;
    RPC_STATUS RpcStatus, CredStatus = RPC_S_OK;
    PSecurityFunctionTable RpcSecurityInterface;
    SECURITY_PACKAGE_INFO *pPackageInfo = 0;
    SECURITY_CREDENTIALS *pSecCredentials = 0;
    CredHandle tmpCredHandle;
    unsigned int ProviderIndex;
    unsigned int PackageIndex;

    //
    // NULL out the OUT parameters.
    //
    *SecurityCredentials = NULL;

    //
    // Find the right security package
    //
    RpcStatus = FindSecurityPackage(
                    AuthenticationService,
                    AuthenticationLevel,
                    &ProviderIndex,
                    &PackageIndex
                    );
    if (RpcStatus != RPC_S_OK)
        {
        RpcpErrorAddRecord (EEInfoGCRuntime,
            RpcStatus,
            EEInfoDLFindServerCredentials10,
            AuthenticationService,
            AuthenticationLevel);

        return (RpcStatus);
        }

    //
    // Now, get the server-credentials for this security package.
    //
    pPackageInfo = &(ProviderList[ProviderIndex].
                     SecurityPackages[PackageIndex]
                     );


    // Protect the access
    SecurityCritSect->Request();

    //
    // Check to see if credentials have already been acquired for this
    // package. If yes, return them.
    //
    if (pPackageInfo->ServerSecurityCredentials)
        {
        *SecurityCredentials = pPackageInfo->ServerSecurityCredentials;
        // Add a reference for the caller.
        pPackageInfo->ServerSecurityCredentials->ReferenceCredentials();
        SecurityCritSect->Clear();
        return (RPC_S_OK);
        }

    //
    // Allocate a new set of credentials. Ref count is 1, if successful.
    //
    pSecCredentials = new SECURITY_CREDENTIALS(&CredStatus);
    if (pSecCredentials == NULL)
        {
        SecurityCritSect->Clear();
        return (RPC_S_OUT_OF_MEMORY);
        }
    if (CredStatus != RPC_S_OK)
        {
        delete pSecCredentials;
        SecurityCritSect->Clear();
        return (CredStatus);
        }

    //
    // This is the first time Credentials are being acquired for this
    // package. Acquire them now.
    //
    RpcSecurityInterface = ProviderList[ProviderIndex].RpcSecurityInterface;

    SecurityStatus = (*RpcSecurityInterface->AcquireCredentialsHandle)(
            (SEC_TCHAR __SEC_FAR *) Principal,
            pPackageInfo->PackageInfo.Name,
            SECPKG_CRED_INBOUND,
            0,
            Arg,
            (SEC_GET_KEY_FN) GetKeyFn,
            Arg,
            &(pSecCredentials->CredentialsHandle),
            &TimeStamp
            );

    if (SecurityStatus != SEC_E_OK)
        {
        SetExtendedError(SecurityStatus);
        RpcpErrorAddRecord (EEInfoGCSecurityProvider,
            SecurityStatus,
            EEInfoDLFindServerCredentials20,
            Principal,
            pPackageInfo->PackageInfo.Name);

        SecurityCritSect->Clear();
        delete pSecCredentials;

        switch (SecurityStatus)
            {
            case SEC_E_INSUFFICIENT_MEMORY:
                RpcStatus = RPC_S_OUT_OF_MEMORY;
                break;

            case SEC_E_SHUTDOWN_IN_PROGRESS:
                RpcStatus = ERROR_SHUTDOWN_IN_PROGRESS;
                break;

            case SEC_E_SECPKG_NOT_FOUND:
                RpcStatus = RPC_S_UNKNOWN_AUTHN_SERVICE;
                break;

            case SEC_E_NO_SPM:
                RpcStatus = RPC_S_SEC_PKG_ERROR;
                break;

            default:
                {
#if DBG
                if ((SecurityStatus != SEC_E_NO_CREDENTIALS) &&
                    (SecurityStatus != SEC_E_UNKNOWN_CREDENTIALS))
                    {
                    PrintToDebugger("RPC SEC: AcquireCredentialsForServer "
                                    "Returned 0x%x\n", SecurityStatus);
                    }
#endif
                RpcStatus = RPC_S_INVALID_AUTH_IDENTITY;
                }
            } // end of switch


        RpcpErrorAddRecord (EEInfoGCRuntime,
            RpcStatus,
            EEInfoDLFindServerCredentials30,
            SecurityStatus);

        return RpcStatus;
        }

    //
    // Setup the new Credentials.
    //
    pSecCredentials->Valid = TRUE;
    pSecCredentials->AuthenticationService = AuthenticationService;
    pSecCredentials->ProviderIndex = ProviderIndex;
    pSecCredentials->PackageIndex = PackageIndex;

    //
    // Cache the new credentials. They are created with refcount 1
    // and this refcount will be removed in RemoveCredentialsFromCache
    //
    pPackageInfo->ServerSecurityCredentials = pSecCredentials;

    // Add a reference for the Cache.
    pPackageInfo->ServerSecurityCredentials->ReferenceCredentials();

    *SecurityCredentials = pSecCredentials;

    SecurityCritSect->Clear();

    return (RPC_S_OK);
}




RPC_STATUS
RemoveCredentialsFromCache (
    IN unsigned long AuthenticationService
    )
/*++

Routine Description:

    An RPC server can call RpcRegisterAuthInfo() a second time on the same
    Authentication Service to update the GetKeyFunction and Arg values.
    In this case, we need to flush our credentials cache so that when
    the server tries to acquires credentials again,  the credentials can
    be acquired using the new values.

Arguments:

    AuthenticationService - Supplies the authentication service to be used
        (for the credentials and for the context).

Return Value:

    RPC_S_OK, If Cache has been successfully flushed.
    Return Value from FindSecurityPackage(), if not

--*/
{
    unsigned int ProviderIndex;
    unsigned int PackageIndex;
    SECURITY_PACKAGE_INFO *pPackageInfo = 0;
    RPC_STATUS   RpcStatus;

    //
    // First, find the right security package
    //
    RpcStatus = FindSecurityPackage(
                    AuthenticationService,
                    RPC_C_AUTHN_LEVEL_DEFAULT,  // Doesn't matter
                    &ProviderIndex,
                    &PackageIndex
                    );

    ASSERT(RpcStatus == RPC_S_OK);

    if (RpcStatus != RPC_S_OK)
        {
        return (RpcStatus);
        }

    pPackageInfo = &(ProviderList[ProviderIndex].SecurityPackages[PackageIndex]);

    //
    // Flush the credentials.
    //
    SecurityCritSect->Request();

    if (pPackageInfo->ServerSecurityCredentials)
        {
        // Remove the reference maintained by the cache.
        pPackageInfo->ServerSecurityCredentials->DereferenceCredentials();
        pPackageInfo->ServerSecurityCredentials = NULL;
        }

    SecurityCritSect->Clear();

    return (RPC_S_OK);
}


#define INVALID_INDEX   0xFFFF


SECURITY_CREDENTIALS::SECURITY_CREDENTIALS (
    IN OUT RPC_STATUS PAPI * Status
    ) : CredentialsMutex(Status)
/*++

Routine Description:

    We need this here to keep the compiler happy.

--*/
{
    DefaultPrincName = NULL;

    ReferenceCount = 1;
    Valid = FALSE;

    // Initialize to invalid values.
    ProviderIndex = INVALID_INDEX;
    PackageIndex  = INVALID_INDEX;
}

SECURITY_CREDENTIALS::~SECURITY_CREDENTIALS (
    )
{
    PSecurityFunctionTable RpcSecurityInterface;

    if (DefaultPrincName != NULL)
        {
        RpcSecurityInterface = InquireProviderFunctionTable();

        ASSERT(RpcSecurityInterface != NULL);

        (*RpcSecurityInterface->FreeContextBuffer)(DefaultPrincName);
        }
}



void
SECURITY_CREDENTIALS::ReferenceCredentials(
    )
{
    CredentialsMutex.Request();
    LogEvent(SU_SECCRED, EV_INC, this, 0, ReferenceCount, 1, 0);
    ReferenceCount++;
    CredentialsMutex.Clear();
}


void
SECURITY_CREDENTIALS::DereferenceCredentials(
    void
    )
{
    CredentialsMutex.Request();
    LogEvent(SU_SECCRED, EV_DEC, this, 0, ReferenceCount, 1, 0);
    ReferenceCount--;

    ASSERT(((long)ReferenceCount) >= 0);

    if (ReferenceCount == 0)
        {
        //
        // Server side SCENARIOS when (ReferenceCount == 0)
        //
        // a. RemoveCredentialsFromCache() removes the extra reference
        //    held by the cache. It does so holding the cache Mutex ie.,
        //    SecurityCritSect. So, no other thread can get a reference
        //    on the credentials in the cache.
        //
        // b. DereferenceCredentials() has been called by one of the
        //    threads possessing the cached credentials AND the cache
        //    has already removed it's reference. Cache will remove its
        //    reference only when it removes this credential from the
        //    cache. This implies no other thread could have gotten a
        //    reference on the credentials in the cache, in the meantime.
        //
        // These two imply that ReferenceCount cannot change here. Also,
        // in case (a), credentials will soon be removed from the cache.
        // In case (b), credentials have already been removed.
        //

        CredentialsMutex.Clear();
        FreeCredentials();
        delete this;
        } // if (ReferenceCount == 0)
     else
        {
        CredentialsMutex.Clear();
        }
}



RPC_STATUS
SECURITY_CREDENTIALS::AcquireCredentialsForClient (
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
    IN unsigned long AuthenticationService,
    IN unsigned long AuthenticationLevel
    )
/*++

Routine Description:

    We need to use this method in order to acquire security credentials.  We
    need the security credentials so that we (as a client) can initialize
    a security context with a server.  This method, with
    SECURITY_CREDENTIALS::FreeCredentials may cache security credentials,
    but that is transparent to clients of this class.

Arguments:

    AuthIdentity - Supplies the security identity for which we wish to obtain
        credentials.  If this argument is not supplied, then we use the
        security identity of this process.

    AuthenticationService - Supplies the authentication service to be used
        (for the credentials and for the context).

    AuthenticationLevel - Supplies the authentication level to be used by
        these credentials.  It will already have been mapped by the protocol
        module into the final level.

Return Value:

    RPC_S_OK - We now have security credentials for the requested
        authentication service.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to perform the
        operation.

    RPC_S_UNKNOWN_AUTHN_SERVICE - The specified authentication service is
        not supported by the current configuration.

    RPC_S_INVALID_AUTH_IDENTITY - The specified identity is not known to
        the requested authentication service.

    RPC_S_UNKNOWN_AUTHN_LEVEL - The specified authentication level is not
        supported by the requested authentication service.

--*/
{
    SECURITY_STATUS SecurityStatus;
    TimeStamp TimeStamp;
    RPC_STATUS RpcStatus;
    PSecurityFunctionTable RpcSecurityInterface;

    unsigned Flags = SCH_CRED_USE_DEFAULT_CREDS;

    RpcStatus    = FindSecurityPackage(
                          AuthenticationService,
                          AuthenticationLevel,
                          &ProviderIndex,
                          &PackageIndex
                          );

    if ( RpcStatus != RPC_S_OK )
        {
        RpcpErrorAddRecord(EEInfoGCRuntime,
            RpcStatus,
            EEInfoDLAcquireCredentialsForClient20,
            AuthenticationService,
            AuthenticationLevel);

        return(RpcStatus);
        }

    RpcSecurityInterface = ProviderList[ProviderIndex].RpcSecurityInterface;

    if (AuthIdentity == RPC_C_NO_CREDENTIALS)
        {
        Flags = 0;
        AuthIdentity = 0;
        }

    //
    // RPC does its own name checking using msstd or fullsic names.
    // This requires the ability to disable schannel's name checking,
    // a feature available only with credentials version-4 or better.
    //
#define MINIMUM_SCHANNEL_CRED_VERSION 4

    if (AuthenticationService == RPC_C_AUTHN_GSS_SCHANNEL && 
        AuthIdentity != NULL)
        {
        SCHANNEL_CRED * cred = (SCHANNEL_CRED *) AuthIdentity;

        Flags |= SCH_CRED_NO_SERVERNAME_CHECK;

        if (cred->dwVersion < MINIMUM_SCHANNEL_CRED_VERSION)
            {
            RpcpErrorAddRecord(EEInfoGCRuntime,
                ERROR_INVALID_PARAMETER,
                EEInfoDLAcquireCredentialsForClient30,
                AuthenticationService,
                AuthenticationLevel);

            return RPC_S_INVALID_AUTH_IDENTITY;
            }

        cred->dwFlags |= Flags;
        }

    SecurityStatus = (*RpcSecurityInterface->AcquireCredentialsHandle)(
            0,
            ProviderList[ProviderIndex].SecurityPackages[PackageIndex].PackageInfo.Name,
            SECPKG_CRED_OUTBOUND,
            0,
            AuthIdentity, 0, 0, &CredentialsHandle, &TimeStamp);

    if ( SecurityStatus != SEC_E_OK )
        {
        RpcpErrorAddRecord(EEInfoGCSecurityProvider,
            SecurityStatus,
            EEInfoDLAcquireCredentialsForClient10,
            AuthenticationService,
            AuthenticationLevel);
        }

    if (SecurityStatus != SEC_E_OK)
        {
        if ( SecurityStatus == SEC_E_INSUFFICIENT_MEMORY )
            {
            RpcStatus = RPC_S_OUT_OF_MEMORY;
            }
        else if ( SecurityStatus == SEC_E_SECPKG_NOT_FOUND )
            {
            RpcStatus = RPC_S_UNKNOWN_AUTHN_SERVICE;
            }
        else if ( SecurityStatus == SEC_E_SHUTDOWN_IN_PROGRESS )
            {
            RpcStatus = ERROR_SHUTDOWN_IN_PROGRESS;
            }
        else if ( SecurityStatus == SEC_E_NO_SPM)
            {
            RpcStatus = RPC_S_SEC_PKG_ERROR;
            }
        else
            {

            VALIDATE(SecurityStatus)
                     {
                     SEC_E_NO_CREDENTIALS,
                     SEC_E_UNKNOWN_CREDENTIALS,
                     SEC_E_NO_AUTHENTICATING_AUTHORITY,
                     SEC_E_INVALID_TOKEN
                     }
            END_VALIDATE;

            RpcStatus = RPC_S_INVALID_AUTH_IDENTITY;
            }

        RpcpErrorAddRecord(EEInfoGCRuntime,
            RpcStatus,
            EEInfoDLAcquireCredentialsForClient30,
            SecurityStatus);

        return RpcStatus;
        }

    this->AuthenticationService = AuthenticationService;
    Valid = TRUE;
    return(RPC_S_OK);
}


RPC_STATUS
SECURITY_CREDENTIALS::InquireDefaultPrincName(
    OUT SEC_CHAR __SEC_FAR **MyDefaultPrincName
    )
{
    SECURITY_STATUS SecurityStatus;
    SecPkgCredentials_NamesA CredentialsNames;
    PSecurityFunctionTable RpcSecurityInterface;
    RPC_STATUS Status;

    if (DefaultPrincName == NULL)
    {
        RpcSecurityInterface = InquireProviderFunctionTable();
        if (RpcSecurityInterface == NULL) {
            return (RPC_S_OUT_OF_MEMORY);
        }
        if (RpcSecurityInterface->QueryCredentialsAttributes == NULL) {
            return (RPC_S_CANNOT_SUPPORT);
        }
        SecurityStatus = (*RpcSecurityInterface->QueryCredentialsAttributes)(
            InquireCredHandle(), SECPKG_CRED_ATTR_NAMES, &CredentialsNames);

        if (SecurityStatus != SEC_E_OK)
            {
            SetExtendedError(SecurityStatus);

            RpcpErrorAddRecord (EEInfoGCSecurityProvider,
                SecurityStatus,
                EEInfoDLInquireDefaultPrincName10,
                AuthenticationService);

            if (SecurityStatus == SEC_E_INSUFFICIENT_MEMORY)
                {
                Status = RPC_S_OUT_OF_MEMORY;
                }
            else if ( SecurityStatus == SEC_E_SHUTDOWN_IN_PROGRESS )
                {
                Status = ERROR_SHUTDOWN_IN_PROGRESS;
                }
            else
                {
                Status = RPC_S_SEC_PKG_ERROR;
                }

            RpcpErrorAddRecord (EEInfoGCRuntime,
                Status,
                EEInfoDLInquireDefaultPrincName20,
                SecurityStatus);

            return Status;
            }

        if (CredentialsNames.sUserName == NULL)
            {
            return RPC_S_OUT_OF_MEMORY;
            }

        DefaultPrincName = CredentialsNames.sUserName;
    }

    *MyDefaultPrincName = DefaultPrincName;

    return (RPC_S_OK);
}



void
SECURITY_CREDENTIALS::FreeCredentials (
    )
/*++

Routine Description:

    When we are done using the credentials, we call this routine to free
    them.

--*/
{
    unsigned int nRetries = 0;

    if (Valid)
        {
        SECURITY_STATUS SecurityStatus;

        PSecurityFunctionTable RpcSecurityInterface
            = ProviderList[ProviderIndex].RpcSecurityInterface;

        // SEC_E_INSUFFICIENT_MEMORY may be returned under extremely low
        // memory conditions.  We will do the following:
        // - Retry 10 times to delete the credential handle.
        // - Raise a flag in the process that we have leaked one or more security ts.
        do 
            {
            SecurityStatus = (*RpcSecurityInterface->FreeCredentialHandle)(
                    &CredentialsHandle);
            nRetries++;
            }
        while (SecurityStatus == SEC_E_INSUFFICIENT_MEMORY && nRetries < 10);

        if (SecurityStatus == SEC_E_INSUFFICIENT_MEMORY)
            {
            nSecurityStructuresLeaked++;
            }

#if DBG
        if ((SecurityStatus != SEC_E_OK) && (SecurityStatus != SEC_E_SHUTDOWN_IN_PROGRESS))
            {
            PrintToDebugger("FreeCredentialHandle(0x%x) Returned [%lx]\n",
                            &CredentialsHandle,
                            SecurityStatus);
            }
        if (SecurityStatus == SEC_E_INSUFFICIENT_MEMORY)
            {
            PrintToDebugger("CredentialsHandle(0x%x) leaked\n",
                            &CredentialsHandle);
            }
#endif

        ASSERT( SecurityStatus == SEC_E_OK ||
                SecurityStatus == SEC_E_SECPKG_NOT_FOUND ||
                SecurityStatus == SEC_E_SHUTDOWN_IN_PROGRESS ||
                SecurityStatus == SEC_E_INSUFFICIENT_MEMORY);
        }
}


RPC_STATUS
SECURITY_CONTEXT::SetMaximumLengths (
    )
/*++

Routine Description:

    This routine initializes the maximum header length and maximum signature
    length fields of this object.

--*/
{
    SECURITY_STATUS SecurityStatus;
    SecPkgContext_Sizes ContextSizes;
    RPC_STATUS Status;

    if (FailedContext != 0)
        {
        // We cheat if 3rd Leg Failed as we dont really have a true Context
        // Provider is going to really complain if we call QueryContextAttr()
        // .. we get around that by picking large values.
        // The rest of the code prevents these values to be really used
        // We do this because we do not want to block 3rd Leg, rather fail the
        // first request!

        MaxSignatureLength = 256;
        MaxHeaderLength    = 256;
        cbBlockSize        = 64;
        return RPC_S_OK;
        }

    ASSERT( FullyConstructed() );

    SecurityStatus = (*RpcSecurityInterface->QueryContextAttributes)(
            &SecurityContext, SECPKG_ATTR_SIZES, &ContextSizes);

    if (SecurityStatus != SEC_E_OK)
        {
#ifdef DEBUGRPC
        PrintToDebugger("RPC: secclnt.cxx: QueryContextAttributes returned: %lx\n",
                        SecurityStatus);
#endif
        Status = GetLastError();

        RpcpErrorAddRecord (EEInfoGCSecurityProvider,
            RPC_S_OUT_OF_MEMORY,
            EEInfoDLSetMaximumLengths10,
            SecurityStatus,
            Status,
            AuthenticationService,
            (ULONGLONG)&SecurityContext
            );

        return RPC_S_OUT_OF_MEMORY;
        }

    MaxSignatureLength = (unsigned int) ContextSizes.cbMaxSignature;
    MaxHeaderLength    = (unsigned int) ContextSizes.cbSecurityTrailer;
    cbBlockSize        = (unsigned int) ContextSizes.cbBlockSize;

    ASSERT(ContextSizes.cbBlockSize <= MAXIMUM_SECURITY_BLOCK_SIZE );

    return RPC_S_OK;
}


SECURITY_CONTEXT::SECURITY_CONTEXT (
    CLIENT_AUTH_INFO *myAuthInfo,
    unsigned myAuthContextId,
    BOOL fUseDatagram,
    RPC_STATUS __RPC_FAR * pStatus
    )
    : CLIENT_AUTH_INFO  (myAuthInfo, pStatus),
      AuthContextId     (myAuthContextId),
      fDatagram         ((boolean) fUseDatagram),
      fFullyConstructed (FALSE),
      Legs              (LegsUnknown),
      ContextAttributes (0)
/*++

Routine Description:

    We need to set the flag indicating that there is no security context
    to be deleted.

--*/
{
    CORRUPTION_ASSERT( AuthenticationLevel != 0 );

    DontForgetToDelete = 0;
    FailedContext = 0;
    FailedContextEEInfo = NULL;
    AuthzClientContext = NULL;
}


RPC_STATUS
SECURITY_CONTEXT::CompleteSecurityToken (
    IN OUT SECURITY_BUFFER_DESCRIPTOR PAPI * BufferDescriptor
    )
/*++

--*/
{
    SECURITY_STATUS SecurityStatus;
    RPC_STATUS Status;

    ASSERT(   ( SecuritySupportLoaded != 0 )
           && ( FailedToLoad == 0 ) );

    SecurityStatus = (*RpcSecurityInterface->CompleteAuthToken)(
            &SecurityContext, BufferDescriptor);
    if (SecurityStatus == SEC_E_OK)
        {
        return (RPC_S_OK);
        }

    SetExtendedError(SecurityStatus);

    RpcpErrorAddRecord (EEInfoGCSecurityProvider,
        SecurityStatus,
        EEInfoDLCompleteSecurityToken10,
        AuthenticationService,
        AuthenticationLevel);

    if (  (SecurityStatus == SEC_E_NO_CREDENTIALS)
        || (SecurityStatus == SEC_E_LOGON_DENIED)
        || (SecurityStatus == SEC_E_INVALID_TOKEN)
        || (SecurityStatus == SEC_E_UNKNOWN_CREDENTIALS)
        || (SecurityStatus == SEC_E_WRONG_PRINCIPAL)
        || (SecurityStatus == SEC_E_TIME_SKEW))
        {
        Status = RPC_S_ACCESS_DENIED;
        }
    else if ( SecurityStatus ==  SEC_E_INSUFFICIENT_MEMORY )
        {
        Status = RPC_S_OUT_OF_MEMORY;
        }
    else if ( SecurityStatus == SEC_E_SHUTDOWN_IN_PROGRESS )
        {
        Status = ERROR_SHUTDOWN_IN_PROGRESS;
        }
    else
        {
#if DBG
        PrintToDebugger("RPC: CompleteSecurityContext Returned %lx\n",
                         SecurityStatus);
#endif
        Status = RPC_S_SEC_PKG_ERROR;
        }

    RpcpErrorAddRecord (EEInfoGCRuntime,
        Status,
        EEInfoDLCompleteSecurityToken20,
        SecurityStatus);
    return Status;
}


RPC_STATUS
SECURITY_CONTEXT::SignOrSeal (
    IN unsigned long Sequence,
    IN unsigned int SignNotSealFlag,
    IN OUT SECURITY_BUFFER_DESCRIPTOR PAPI * BufferDescriptor
    )
/*++

Routine Description:

    A protocol module will use this routine to prepare a message to be
    sent so that it can be verified that the message has not been tampered
    with, and that it has not been exchanged out of sequence.  The sender
    will use this routine to prepare the message; the receiver will use
    SECURITY_CONTEXT::VerifyOrUnseal to verify the message.  Typically,
    the security package will generate a cryptographic checksum of the
    message and include sequencing information.

Arguments:

    SignNotSealFlag - Supplies a flag indicating that MakeSignature should
        be called rather than SealMessage.

    BufferDescriptor - Supplies the message to to signed or sealed and returns
        the resulting message (after being signed or sealed).

Return Value:

    RPC_S_OK - This routine will always succeed.

--*/
{
    SECURITY_STATUS SecurityStatus;
    SEAL_MESSAGE_FN SealMessage;

    {
    DWORD Status = 0;

    CallTestHook( TH_SECURITY_FN_SIGN, this, &Status );

    if (Status)
        {
        return Status;
        }
    }

    if ( SignNotSealFlag == 0 )
        {
        SealMessage = (SEAL_MESSAGE_FN) RpcSecurityInterface->Reserved3;
        SecurityStatus = (*SealMessage)(&SecurityContext,
                0, BufferDescriptor, Sequence);
        }
    else
        {
        SecurityStatus = (*RpcSecurityInterface->MakeSignature)(
                &SecurityContext, 0, BufferDescriptor, Sequence);
        }

#if DBG
        if ( (SecurityStatus != SEC_E_OK)
           &&(SecurityStatus != SEC_E_CONTEXT_EXPIRED)
           &&(SecurityStatus != SEC_E_QOP_NOT_SUPPORTED) )
           {
           PrintToDebugger("Sign/Seal Returned [%lx]\n", SecurityStatus);
           }
#endif

    if ( SecurityStatus == SEC_E_SHUTDOWN_IN_PROGRESS )
        {
        SecurityStatus = ERROR_SHUTDOWN_IN_PROGRESS;
        }

    if (SecurityStatus != SEC_E_OK)
        {
        RpcpErrorAddRecord (EEInfoGCSecurityProvider,
            SecurityStatus,
            EEInfoDLSignOrSeal10,
            AuthenticationService,
            AuthenticationLevel);
        }

    return(SecurityStatus);
}

extern BOOL gfRpcDisableVerifyOrUnsealAssert;


RPC_STATUS
SECURITY_CONTEXT::VerifyOrUnseal (
    IN unsigned long Sequence,
    IN unsigned int VerifyNotUnsealFlag,
    IN OUT  SECURITY_BUFFER_DESCRIPTOR PAPI * BufferDescriptor
    )
/*++

Routine Description:

    This routine works with SECURITY_CONTEXT::SignOrSeal.  A sender will
    prepare a message using SignOrSeal, and then the receiver will use
    this routine to verify that the message has not been tampered with, and
    that it has not been exchanged out of sequence.

Arguments:

    VerifyNotUnsealFlag - Supplies a flag indicating that VerifySignature
        should be called rather than UnsealMessage.

    BufferDescriptor - Supplies the message to be verified or unsealed.

Return Value:

    RPC_S_OK - The message has not been tampered with, and it is from the
        expected client.

    RPC_S_ACCESS_DENIED - A security violation occured.

--*/
{
    SECURITY_STATUS SecurityStatus;
    RPC_STATUS RpcStatus;
    unsigned long QualityOfProtection;
    UNSEAL_MESSAGE_FN UnsealMessage;

    {
    DWORD Status = 0;

    CallTestHook( TH_SECURITY_FN_VERIFY, this, &Status );

    if (Status)
        {
        return Status;
        }
    }

    //
    // If the context had failed previously..
    // Just go ahead and return an error..
    // This is only for connetion-oriented RPC.
    //
    if (FailedContext != 0 || !FullyConstructed() )
       {
       RpcpSetEEInfo(FailedContextEEInfo);
       FailedContextEEInfo = NULL;
       SetLastError(FailedContext);

       if ((FailedContext == ERROR_PASSWORD_MUST_CHANGE)
           || (FailedContext == ERROR_PASSWORD_EXPIRED)
           || (FailedContext == ERROR_ACCOUNT_DISABLED)
           || (FailedContext == ERROR_INVALID_LOGON_HOURS))
           {
           return FailedContext;
           }

        RpcpErrorAddRecord (EEInfoGCRuntime,
            RPC_S_ACCESS_DENIED,
            EEInfoDLVerifyOrUnseal20,
            FailedContext);

       return (RPC_S_ACCESS_DENIED);
       }

    if ( VerifyNotUnsealFlag == 0 )
        {
        UnsealMessage = (UNSEAL_MESSAGE_FN) RpcSecurityInterface->Reserved4;
        SecurityStatus = (*UnsealMessage)(
                &SecurityContext, BufferDescriptor, Sequence,
                &QualityOfProtection);
        }
    else
        {
        SecurityStatus = (*RpcSecurityInterface->VerifySignature)(
                &SecurityContext, BufferDescriptor, Sequence,
                &QualityOfProtection);
        }

    if ( SecurityStatus != SEC_E_OK )
        {

#if DBG
        if ((SecurityStatus != SEC_E_MESSAGE_ALTERED)
           &&(SecurityStatus != SEC_E_OUT_OF_SEQUENCE)
           &&(SecurityStatus != SEC_E_SECPKG_NOT_FOUND))    // on system shutdown, if the security
           {                        // package is already uninitialized, we may get this error
           PrintToDebugger("Verify/UnSeal Returned Unexp. Code [%lx]\n",
                            SecurityStatus);
           }
#endif

        SetExtendedError(SecurityStatus);

        if ( SecurityStatus == SEC_E_INSUFFICIENT_MEMORY )
            {
            RpcStatus = RPC_S_OUT_OF_MEMORY;
            }
        else
            {
            if (!gfRpcDisableVerifyOrUnsealAssert
                && !fDatagram)
                {
                VALIDATE (SecurityStatus)
                    {
                    SEC_E_SHUTDOWN_IN_PROGRESS,
                    SEC_E_SECPKG_NOT_FOUND
                    }
                CORRUPTION_VALIDATE
                    {
                    SEC_E_MESSAGE_ALTERED,
                    SEC_E_OUT_OF_SEQUENCE,
                    SEC_E_INVALID_TOKEN
                    } CORRUPTION_END_VALIDATE;
                }

            RpcStatus = RPC_S_ACCESS_DENIED;
            }

        RpcpErrorAddRecord (EEInfoGCSecurityProvider,
            RpcStatus,
            EEInfoDLVerifyOrUnseal10,
            SecurityStatus,
            AuthenticationService,
            AuthenticationLevel);

        SetLastError(RpcStatus);
        return(RpcStatus);
        }
    return(RPC_S_OK);
}


RPC_STATUS
SECURITY_CONTEXT::InitializeFirstTime (
    IN SECURITY_CREDENTIALS * Credentials,
    IN RPC_CHAR * ServerPrincipalName,
    IN unsigned long AuthenticationLevel,
    IN OUT SECURITY_BUFFER_DESCRIPTOR PAPI * BufferDescriptor,
    IN OUT unsigned char *NewAuthType
    )
/*++

Routine Description:

Arguments:

Return Value:

    RPC_S_OK - Send the token to the server; everything worked fine so
        far.

    RPC_P_CONTINUE_NEEDED - Indicates that that everything is ok, but that
        we need to call into the security package again when we have
        received a token back from the server.

    RPC_P_COMPLETE_NEEDED - Indicates that everyting is ok, but that we
        need to call CompleteAuthToken before sending the message.

    RPC_P_COMPLETE_AND_CONTINUE - Needs both a complete and a continue.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to perform the
        operation.

    RPC_S_ACCESS_DENIED - Access is denied.

--*/
{
    SECURITY_STATUS SecurityStatus;
    TimeStamp TimeStamp;
    unsigned long ContextRequirements;
    RPC_STATUS Status;
    RPC_STATUS Status2;
    unsigned char RetrievedAuthType;
    BOOL fDone;

    ASSERT(   ( SecuritySupportLoaded != 0 )
           && ( FailedToLoad == 0 ) );

    RpcSecurityInterface = Credentials->InquireProviderFunctionTable();

    switch ( AuthenticationLevel )
        {
        case RPC_C_AUTHN_LEVEL_CONNECT :
            ContextRequirements = 0;
            break;

        case RPC_C_AUTHN_LEVEL_PKT :
            ContextRequirements = ISC_REQ_REPLAY_DETECT;
            break;

        case RPC_C_AUTHN_LEVEL_PKT_INTEGRITY :
            ContextRequirements = ISC_REQ_REPLAY_DETECT
                                | ISC_REQ_SEQUENCE_DETECT
                                | ISC_REQ_INTEGRITY;
            break;

        case RPC_C_AUTHN_LEVEL_PKT_PRIVACY :
            ContextRequirements = ISC_REQ_REPLAY_DETECT
                                | ISC_REQ_SEQUENCE_DETECT
                                | ISC_REQ_CONFIDENTIALITY
                                | ISC_REQ_INTEGRITY;
            break;

        default :
            ASSERT(   ( AuthenticationLevel == RPC_C_AUTHN_LEVEL_CONNECT )
                   || ( AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT )
                   || ( AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT_INTEGRITY )
                   || ( AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT_PRIVACY ) );
            return RPC_S_INTERNAL_ERROR;
        }


    if (fDatagram)
        {
        ContextRequirements |= ISC_REQ_DATAGRAM;
        }
    else
        {
        ContextRequirements |= ISC_REQ_CONNECTION;
        }

    switch(ImpersonationType)
        {
        case RPC_C_IMP_LEVEL_IDENTIFY:
            ContextRequirements |= ISC_REQ_IDENTIFY;
            break;

        case RPC_C_IMP_LEVEL_IMPERSONATE:
            break;

        case RPC_C_IMP_LEVEL_DELEGATE:
            ContextRequirements |= ISC_REQ_DELEGATE;
            break;

        default:
            ASSERT(   ImpersonationType == RPC_C_IMP_LEVEL_ANONYMOUS
                   || ImpersonationType == RPC_C_IMP_LEVEL_IDENTIFY
                   || ImpersonationType == RPC_C_IMP_LEVEL_IMPERSONATE
                   || ImpersonationType == RPC_C_IMP_LEVEL_DELEGATE 
                   || ImpersonationType == RPC_C_IMP_LEVEL_DEFAULT );
            ContextRequirements |= ISC_REQ_IDENTIFY;
            break;
        }

    if (Capabilities & RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH)
        {
        ContextRequirements |= ISC_REQ_MUTUAL_AUTH;
        }

    if (Credentials->AuthenticationService == RPC_C_AUTHN_GSS_SCHANNEL)
        {
#if MANUAL_CERT_CHECK
        ContextRequirements |= ISC_REQ_MANUAL_CRED_VALIDATION;
#endif
        }
    else
        {
        ContextRequirements |= ISC_REQ_USE_DCE_STYLE;
        }

    SecurityStatus = (*RpcSecurityInterface->InitializeSecurityContext)(
            Credentials->InquireCredHandle(),
            0,
            (SEC_TCHAR __SEC_FAR *) ServerPrincipalName,
            ContextRequirements,
            0,
            0,
            (fDatagram ? BufferDescriptor : 0),
            0,
            &SecurityContext,
            (fDatagram ? 0 : BufferDescriptor),
            &ContextAttributes,
            &TimeStamp
            );

    if (   ( SecurityStatus != SEC_E_OK )
        && ( SecurityStatus != SEC_I_CONTINUE_NEEDED )
        && ( SecurityStatus != SEC_I_COMPLETE_NEEDED )
        && ( SecurityStatus != SEC_I_COMPLETE_AND_CONTINUE ) )
        {
        SetExtendedError(SecurityStatus);

        RpcpErrorAddRecord (EEInfoGCSecurityProvider,
            SecurityStatus,
            EEInfoDLInitializeFirstTime10,
            AuthenticationService,
            AuthenticationLevel,
            ServerPrincipalName,
            ContextRequirements);

        if ((SecurityStatus == SEC_E_NO_CREDENTIALS)
           || (SecurityStatus == SEC_E_LOGON_DENIED)
           || (SecurityStatus == SEC_E_INVALID_TOKEN)
           || (SecurityStatus == SEC_E_UNKNOWN_CREDENTIALS)
           || (SecurityStatus == SEC_E_NO_KERB_KEY)
           || (SecurityStatus == SEC_E_TIME_SKEW) 
           || (SecurityStatus == STATUS_AUTHENTICATION_FIREWALL_FAILED))
            {
            Status = RPC_S_ACCESS_DENIED;
            }
        else if ( SecurityStatus == SEC_E_SHUTDOWN_IN_PROGRESS )
            {
            Status = ERROR_SHUTDOWN_IN_PROGRESS;
            }
        else if (SecurityStatus == SEC_E_SECPKG_NOT_FOUND)
            {
            Status = RPC_S_UNKNOWN_AUTHN_SERVICE;
            }
        else if ( SecurityStatus ==  SEC_E_INSUFFICIENT_MEMORY )
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }
        else
            {
#if DBG
            PrintToDebugger("RPC: InitializeFirstTime Returned %lx\n", SecurityStatus);
#endif
            //
            // Originally the default for all providers was SEC_PKG_ERROR.  This seems less
            // helpful than ACCESS_DENIED, but we can't change it for NTLM and Kerberos because
            // it might break old app code.
            //
            // SCHANNEL is new, so we can return ACCESS_DENIED.
            //
            if (AuthenticationService == RPC_C_AUTHN_GSS_SCHANNEL)
                {
                Status = RPC_S_ACCESS_DENIED;
                }
            else
                {
                Status = RPC_S_SEC_PKG_ERROR;
                }
            }

        RpcpErrorAddRecord (EEInfoGCRuntime,
            Status,
            EEInfoDLInitializeFirstTime20,
            SecurityStatus);

        return Status;
        }

    RetrievedAuthType = 0;

    DontForgetToDelete = 1;

    if (NewAuthType)
        {
        ASSERT(*NewAuthType == this->AuthenticationService);

        if (*NewAuthType == RPC_C_AUTHN_GSS_NEGOTIATE)
            {
            SecPkgContext_NegotiationInfo NegoInfo;
            SECURITY_STATUS Status;

            Status = (*RpcSecurityInterface->QueryContextAttributes)(
                         &SecurityContext,
                         SECPKG_ATTR_NEGOTIATION_INFO,
                         &NegoInfo);
            if (Status == SEC_E_OK)
                {
                if (NegoInfo.NegotiationState == SECPKG_NEGOTIATION_COMPLETE)
                    {
                    RetrievedAuthType = (unsigned char) NegoInfo.PackageInfo->wRPCID;
                    }
                (*RpcSecurityInterface->FreeContextBuffer)(NegoInfo.PackageInfo);
                }
            else
                {
                RpcpErrorAddRecord (EEInfoGCSecurityProvider,
                    RPC_S_OUT_OF_MEMORY,
                    EEInfoDLInitializeFirstTime30,
                    Status,
                    (ULONG)AuthenticationService,
                    AuthenticationLevel,
                    (ULONG)ContextRequirements);

                return RPC_S_OUT_OF_MEMORY;
                }
            }
        }

    Flags = ContextRequirements;

    fDone = TRUE;

    if ( SecurityStatus == SEC_I_CONTINUE_NEEDED )
        {
        if (!fDatagram)
            {
            fDone = FALSE;
            }
        Status = RPC_P_CONTINUE_NEEDED;
        }

    else if ( SecurityStatus == SEC_I_COMPLETE_NEEDED )
        {
        // Can't set the maximum lengths on a partly completed connection.

        Status = RPC_P_COMPLETE_NEEDED;
        }
    else if ( SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE )
        {
        if (!fDatagram)
            {
            fDone = FALSE;
            }
        Status = RPC_P_COMPLETE_AND_CONTINUE;
        }
    else
        {
        Status = RPC_S_OK;
        }

    if (fDone)
        {
        fFullyConstructed = TRUE;

        Status2 = SetMaximumLengths();
        if (Status2 != RPC_S_OK)
            {
            return Status2;
            }
        }

    if (RetrievedAuthType)
        *NewAuthType = RetrievedAuthType;

    return(Status);
}


RPC_STATUS
SECURITY_CONTEXT::InitializeThirdLeg (
    IN SECURITY_CREDENTIALS * Credentials,
    IN unsigned long DataRepresentation,
    IN SECURITY_BUFFER_DESCRIPTOR PAPI * InputBufferDescriptor,
    IN OUT SECURITY_BUFFER_DESCRIPTOR PAPI * OutputBufferDescriptor
    )
/*++

Routine Description:

Arguments:

Return Value:

    RPC_S_OK - Send the token to the server; everything worked fine so
        far.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to perform the
        operation.

    RPC_S_ACCESS_DENIED - Access is denied.

--*/
{
    SECURITY_STATUS SecurityStatus;
    TimeStamp TimeStamp;
    RPC_STATUS Status;

    ASSERT(   (SecuritySupportLoaded != 0)
           && (FailedToLoad == 0) );

    SecurityStatus = (*RpcSecurityInterface->InitializeSecurityContext)(
            Credentials->InquireCredHandle(),
            &SecurityContext,
            0,
            Flags,
            0,
            DataRepresentation,
            InputBufferDescriptor,
            0,
            &SecurityContext,
            OutputBufferDescriptor,
            &ContextAttributes,
            &TimeStamp
            );

    if (   ( SecurityStatus != SEC_E_OK )
        && ( SecurityStatus != SEC_I_CONTINUE_NEEDED )
        && ( SecurityStatus != SEC_I_COMPLETE_NEEDED )
        && ( SecurityStatus != SEC_I_COMPLETE_AND_CONTINUE ) )
        {
        SetExtendedError(SecurityStatus);

        RpcpErrorAddRecord (EEInfoGCSecurityProvider,
            SecurityStatus,
            EEInfoDLInitializeThirdLeg10,
            AuthenticationService,
            AuthenticationLevel,
            ContextAttributes);

        if (  (SecurityStatus == SEC_E_NO_CREDENTIALS)
           || (SecurityStatus == SEC_E_LOGON_DENIED)
           || (SecurityStatus == SEC_E_INVALID_TOKEN)
           || (SecurityStatus == SEC_E_UNKNOWN_CREDENTIALS)
           || (SecurityStatus == SEC_E_NO_KERB_KEY)
           || (SecurityStatus == SEC_E_TIME_SKEW)
           || (SecurityStatus == STATUS_AUTHENTICATION_FIREWALL_FAILED))
            {
            Status = RPC_S_ACCESS_DENIED;
            }
        else if ( SecurityStatus == SEC_E_SHUTDOWN_IN_PROGRESS )
            {
            Status = ERROR_SHUTDOWN_IN_PROGRESS;
            }
        else if (SecurityStatus == SEC_E_SECPKG_NOT_FOUND)
            {
            Status = RPC_S_UNKNOWN_AUTHN_SERVICE;
            }
        else if ( SecurityStatus ==  SEC_E_INSUFFICIENT_MEMORY )
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }
        else
            {
#if DBG
            PrintToDebugger("RPC: InitializeThirdLeg Returned %lx\n",
                            SecurityStatus );
#endif
            //
            // Originally the default for all connection-oriented providers
            // was SEC_PKG_ERROR.  This seems less helpful than ACESS_DENIED,
            // but we can't change it for NTLM and Kerberos because it might
            // break old app code. SCHANNEL is new, so we can return ACCESS_DENIED.
            //
            // Datagram returns the bare error code.
            //
            if (AuthenticationService == RPC_C_AUTHN_GSS_SCHANNEL)
                {
                Status = RPC_S_ACCESS_DENIED;
                }
            else if (fDatagram)
                {
                // leave the error code alone
                }
            else
                {
                Status = RPC_S_SEC_PKG_ERROR;
                }
            }

        RpcpErrorAddRecord (EEInfoGCRuntime,
            Status,
            EEInfoDLInitializeThirdLeg20,
            SecurityStatus);

        return Status;
        }

    if ( SecurityStatus == SEC_I_CONTINUE_NEEDED )
        {
        return(RPC_P_CONTINUE_NEEDED);
        }

    if ( SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE )
        {
        return(RPC_P_COMPLETE_AND_CONTINUE);
        }

    ASSERT(SecurityStatus == SEC_E_OK
           || SecurityStatus == SEC_I_COMPLETE_NEEDED);

    if ( (ImpersonationType == RPC_C_IMP_LEVEL_IDENTIFY) &&
         (!(ContextAttributes & ISC_RET_IDENTIFY)) )
        {
        RpcpErrorAddRecord (EEInfoGCRuntime,
            RPC_S_SEC_PKG_ERROR,
            EEInfoDLInitializeThirdLeg30,
            SEC_E_SECURITY_QOS_FAILED,
            ImpersonationType,
            ContextAttributes);
        SetExtendedError(SEC_E_SECURITY_QOS_FAILED);
        return (RPC_S_SEC_PKG_ERROR);
        }

    if ( (ImpersonationType == RPC_C_IMP_LEVEL_DELEGATE) &&
         (!(ContextAttributes & ISC_RET_DELEGATE)) &&
         (!(Capabilities & RPC_C_QOS_CAPABILITIES_IGNORE_DELEGATE_FAILURE)) &&
         (!(IsIgnoreDelegationFailureSet())) )
        {
        RpcpErrorAddRecord (EEInfoGCRuntime,
            RPC_S_SEC_PKG_ERROR,
            EEInfoDLInitializeThirdLeg40,
            SEC_E_SECURITY_QOS_FAILED,
            ImpersonationType,
            ContextAttributes,
            Capabilities);
        SetExtendedError(SEC_E_SECURITY_QOS_FAILED);
        return (RPC_S_SEC_PKG_ERROR);
        }

    if ( (!(ContextAttributes & ISC_RET_MUTUAL_AUTH) )&&
         (Capabilities & RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH) )
        {
        RpcpErrorAddRecord (EEInfoGCRuntime,
            RPC_S_SEC_PKG_ERROR,
            EEInfoDLInitializeThirdLeg50,
            SEC_E_SECURITY_QOS_FAILED,
            ImpersonationType,
            ContextAttributes);
         SetExtendedError(SEC_E_SECURITY_QOS_FAILED);
         return (RPC_S_SEC_PKG_ERROR);
        }

    if ( SecurityStatus == SEC_I_COMPLETE_NEEDED )
        {
        fFullyConstructed = TRUE;

        Status = SetMaximumLengths();
        if (Status != RPC_S_OK)
            return Status;
        return(RPC_P_COMPLETE_NEEDED);
        }

    fFullyConstructed = TRUE;

    Status = SetMaximumLengths();
    if (Status != RPC_S_OK)
        return Status;

    if (AuthenticationService == RPC_C_AUTHN_GSS_SCHANNEL)
        {
        return VerifyCertificate();
        }

    return(RPC_S_OK);
}

RPC_STATUS
SECURITY_CONTEXT::GetWireIdForSnego(
    OUT unsigned char *WireId
    )
{
    SecPkgContext_NegotiationInfo NegoInfo;
    SECURITY_STATUS SecStatus;
    RPC_STATUS RpcStatus = RPC_S_OK;

    if (AuthenticationService != RPC_C_AUTHN_GSS_NEGOTIATE)
        return RPC_S_INVALID_BINDING;

    ASSERT(RpcSecurityInterface != NULL);

    SecStatus = (*RpcSecurityInterface->QueryContextAttributes)(
                 &SecurityContext,
                 SECPKG_ATTR_NEGOTIATION_INFO,
                 &NegoInfo);
    if (SecStatus == SEC_E_OK)
        {
        if (NegoInfo.NegotiationState == SECPKG_NEGOTIATION_COMPLETE)
            {
            *WireId = (unsigned char) NegoInfo.PackageInfo->wRPCID;
            }
        else
            RpcStatus = RPC_S_SEC_PKG_ERROR;

        (*RpcSecurityInterface->FreeContextBuffer)(NegoInfo.PackageInfo);
        }
    else
        {
        SetExtendedError(SecStatus);
        RpcStatus = RPC_S_OUT_OF_MEMORY;
        }

    return RpcStatus;
}

RPC_STATUS
SECURITY_CONTEXT::InqMarshalledTargetInfo (
    OUT unsigned long *MarshalledTargetInfoLength,
    OUT unsigned char **MarshalledTargetInfo
    )
{
    SecPkgContext_TargetInformation TargetInfo;
    SECURITY_STATUS SecStatus;
    RPC_STATUS RpcStatus = RPC_S_OK;

    ASSERT(RpcSecurityInterface != NULL);

    SecStatus = (*RpcSecurityInterface->QueryContextAttributes)(
                 &SecurityContext,
                 SECPKG_ATTR_TARGET_INFORMATION,
                 &TargetInfo);
    if (SecStatus == SEC_E_OK)
        {
        // Security will allocate the string containing MarshalledTargetInfo.
        // We can just pass it on to user and have the user free it.
        *MarshalledTargetInfoLength = TargetInfo.MarshalledTargetInfoLength;
        *MarshalledTargetInfo = TargetInfo.MarshalledTargetInfo;
        ASSERT( 
                  ((*MarshalledTargetInfoLength == 0) && (*MarshalledTargetInfo == NULL)) ||
                  ((*MarshalledTargetInfoLength != 0) && (*MarshalledTargetInfo != NULL))        
              );
        }
    else
        {
        SetExtendedError(SecStatus);
        RpcStatus = RPC_S_OUT_OF_MEMORY;
        }

    return RpcStatus;
}


RPC_STATUS
SECURITY_CONTEXT::AcceptFirstTime (
    IN SECURITY_CREDENTIALS * NewCredentials,
    IN SECURITY_BUFFER_DESCRIPTOR PAPI * InputBufferDescriptor,
    IN OUT SECURITY_BUFFER_DESCRIPTOR PAPI * OutputBufferDescriptor,
    IN unsigned long AuthenticationLevel,
    IN unsigned long DataRepresentation,
    IN unsigned long NewContextNeededFlag
    )
/*++

Routine Description:

Arguments:

Return Value:

    RPC_S_OK - Everything worked just fine.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete the
        operation.

    RPC_P_CONTINUE_NEEDED - Indicates that everything is ok, but that we
        need to send the output token back to the client, and then wait
        for a token back from the client.

    RPC_P_COMPLETE_NEEDED - Indicates that everyting is ok, but that we
        need to call CompleteAuthToken before sending the message.

    RPC_P_COMPLETE_AND_CONTINUE - Needs both a complete and a continue.

    RPC_S_ACCESS_DENIED - Access is denied.

--*/
{
    SECURITY_STATUS SecurityStatus;
    TimeStamp TimeStamp;
    unsigned long ContextRequirements;
    RPC_STATUS RpcStatus;
    DWORD Status = 0;

    ASSERT(   (SecuritySupportLoaded != 0)
           && (FailedToLoad == 0) );

    if (Credentials)
        {
        Credentials->DereferenceCredentials();
        }
    Credentials = NewCredentials;
    Credentials->ReferenceCredentials();

    RpcSecurityInterface = Credentials->InquireProviderFunctionTable();

    if (NewContextNeededFlag == 1)
        {
        DeleteSecurityContext();
        }

    switch ( AuthenticationLevel )
        {
        case RPC_C_AUTHN_LEVEL_CONNECT :
            ContextRequirements = ASC_REQ_MUTUAL_AUTH;
            break;

        case RPC_C_AUTHN_LEVEL_PKT :
            ContextRequirements = ASC_REQ_MUTUAL_AUTH
                    | ASC_REQ_REPLAY_DETECT;
            break;

        case RPC_C_AUTHN_LEVEL_PKT_INTEGRITY :
            ContextRequirements = ASC_REQ_MUTUAL_AUTH
                    | ASC_REQ_REPLAY_DETECT | ASC_REQ_SEQUENCE_DETECT;
            break;

        case RPC_C_AUTHN_LEVEL_PKT_PRIVACY :
            ContextRequirements = ASC_REQ_MUTUAL_AUTH
                    | ASC_REQ_REPLAY_DETECT | ASC_REQ_SEQUENCE_DETECT
                    | ASC_REQ_CONFIDENTIALITY;
            break;

        default :
            ASSERT(AuthenticationLevel == RPC_C_AUTHN_LEVEL_CONNECT ||
                   AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT ||
                   AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT_INTEGRITY ||
                   AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT_PRIVACY );
            return RPC_S_INTERNAL_ERROR;
        }

    if (fDatagram)
        {
        ContextRequirements |= ASC_REQ_DATAGRAM;
        }
    else
        {
        ContextRequirements |= ASC_REQ_CONNECTION;
        }

    if (Credentials->AuthenticationService == RPC_C_AUTHN_WINNT ||
        Credentials->AuthenticationService == RPC_C_AUTHN_DCE_PRIVATE ||
        Credentials->AuthenticationService == RPC_C_AUTHN_GSS_KERBEROS ||
        Credentials->AuthenticationService == RPC_C_AUTHN_GSS_NEGOTIATE)
        {
        ContextRequirements |= ASC_REQ_USE_DCE_STYLE | ASC_REQ_DELEGATE;
        }

    if (AuthenticationService == RPC_C_AUTHN_WINNT
        || AuthenticationService == RPC_C_AUTHN_GSS_NEGOTIATE)
        {
        ContextRequirements |= ASC_REQ_ALLOW_NON_USER_LOGONS;
        }

    CallTestHook( TH_SECURITY_FN_ACCEPT1, this, &Status );

    if (Status)
        {
        SetExtendedError(Status);
        return Status;
        }

    SecurityStatus = (*RpcSecurityInterface->AcceptSecurityContext)(
            Credentials->InquireCredHandle(), 0, InputBufferDescriptor,
            ContextRequirements, DataRepresentation, &SecurityContext,
            OutputBufferDescriptor, &ContextAttributes, &TimeStamp);

    if (   ( SecurityStatus != SEC_E_OK )
        && ( SecurityStatus != SEC_I_CONTINUE_NEEDED )
        && ( SecurityStatus != SEC_I_COMPLETE_NEEDED )
        && ( SecurityStatus != SEC_I_COMPLETE_AND_CONTINUE ) )
        {
        RpcpErrorAddRecord (EEInfoGCSecurityProvider,
            SecurityStatus,
            EEInfoDLAcceptFirstTime10,
            AuthenticationService,
            AuthenticationLevel,
            ContextRequirements);

        SetExtendedError(SecurityStatus);

        if (  (SecurityStatus == SEC_E_NO_CREDENTIALS)
            || (SecurityStatus == SEC_E_LOGON_DENIED)
            || (SecurityStatus == SEC_E_INVALID_TOKEN)
            || (SecurityStatus == SEC_E_NO_AUTHENTICATING_AUTHORITY)
            || (SecurityStatus == SEC_E_UNKNOWN_CREDENTIALS) 
            || (SecurityStatus == SEC_E_CONTEXT_EXPIRED)
            || (SecurityStatus == SEC_E_TIME_SKEW)
            || (SecurityStatus == STATUS_AUTHENTICATION_FIREWALL_FAILED))
            {
            RpcStatus = RPC_S_ACCESS_DENIED;
            }
        else if ( SecurityStatus == SEC_E_SHUTDOWN_IN_PROGRESS )
            {
            RpcStatus = ERROR_SHUTDOWN_IN_PROGRESS;
            }
        else if (SecurityStatus == SEC_E_SECPKG_NOT_FOUND)
            {
            RpcStatus = RPC_S_UNKNOWN_AUTHN_SERVICE;
            }
        else
            RpcStatus = RPC_S_OUT_OF_MEMORY;
        }
    else
        {
        RpcStatus = RPC_S_OK;
        }

    // We need to make sure that the context returned supports the required
    // functionality.
    // This needs to be done only for a completed context.
    if (SecurityStatus == SEC_E_OK)
        {
        if (((ContextRequirements & ASC_REQ_REPLAY_DETECT) && !(ContextAttributes & ASC_RET_REPLAY_DETECT))
            || ((ContextRequirements & ASC_REQ_SEQUENCE_DETECT) && !(ContextAttributes & ASC_RET_SEQUENCE_DETECT))
            || ((ContextRequirements & ASC_REQ_CONFIDENTIALITY) && !(ContextAttributes & ASC_RET_CONFIDENTIALITY)))
            {
            RpcStatus = RPC_S_ACCESS_DENIED;
            }
        }

    if (RpcStatus != RPC_S_OK)
        {
        RpcpErrorAddRecord (EEInfoGCRuntime,
            RpcStatus,
            EEInfoDLAcceptFirstTime20,
            SecurityStatus);

        return RpcStatus;
        }

    DontForgetToDelete = 1;

    Flags = ContextRequirements;

    if ( SecurityStatus == SEC_I_CONTINUE_NEEDED )
        {
        return(RPC_P_CONTINUE_NEEDED);
        }
    if ( SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE )
        {
        return(RPC_P_COMPLETE_AND_CONTINUE);
        }

    ASSERT((SecurityStatus == SEC_I_COMPLETE_NEEDED)
        || (SecurityStatus == SEC_E_OK));


    fFullyConstructed = TRUE;

    RpcStatus = SetMaximumLengths();
    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    Credentials->DereferenceCredentials();
    Credentials = 0;
    if ( SecurityStatus == SEC_I_COMPLETE_NEEDED )
        return(RPC_P_COMPLETE_NEEDED);
    else
        return(RPC_S_OK);
}


RPC_STATUS
SECURITY_CONTEXT::AcceptThirdLeg (
    IN unsigned long DataRepresentation,
    IN SECURITY_BUFFER_DESCRIPTOR PAPI * BufferDescriptor,
    OUT SECURITY_BUFFER_DESCRIPTOR PAPI * OutBufferDescriptor
    )
/*++

Routine Description:

Arguments:

Return Value:

    RPC_S_OK - Everything worked just fine.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete the
        operation.

    RPC_S_ACCESS_DENIED - Access is denied.

    RPC_P_COMPLETE_NEEDED - Indicates that everyting is ok, but that we
        need to call CompleteAuthToken before sending the message.

--*/
{
    SECURITY_STATUS SecurityStatus;
    TimeStamp TimeStamp;
    RPC_STATUS RpcStatus;
    
    // Set when AcceptSecurityContext returns a failure.
    BOOL ASCReturnedFailure = FALSE;
    // Set when AcceptSecurityContext suceeds but returns ContextAttributes
    // which indicate that the resulting security context does not support
    // the required security settings and is unusable.
    BOOL ASCReturnedBadContextAttributes = FALSE;

    ASSERT(   (SecuritySupportLoaded != 0)
           && (FailedToLoad == 0) );

    SetLastError(0);


    {
    DWORD Status = 0;

    CallTestHook( TH_SECURITY_FN_ACCEPT3, this, &Status );

    if (Status)
        {
        FailedContext = Status;

        SetExtendedError(Status);

        return Status;
        }
    }

    SecurityStatus = (*RpcSecurityInterface->AcceptSecurityContext)(
            Credentials->InquireCredHandle(),
            &SecurityContext,
            BufferDescriptor,
            Flags,
            DataRepresentation,
            &SecurityContext,
            OutBufferDescriptor,
            &ContextAttributes,
            &TimeStamp
            );

    //
    // If 3rd Leg Failed Bit is set, map all errors other than out of memory
    // to SUCCESS
    //
    if ( 
        ( 
         ( SecurityStatus != SEC_E_OK )
         && ( SecurityStatus != SEC_I_COMPLETE_NEEDED)
         && ( SecurityStatus != SEC_I_CONTINUE_NEEDED)
         && ( SecurityStatus != SEC_I_COMPLETE_AND_CONTINUE)
         && ( SecurityStatus != SEC_E_INSUFFICIENT_MEMORY )
         && ( ContextAttributes & ASC_RET_THIRD_LEG_FAILED ) 
        )
        || 
        (  
         ( SecurityStatus == SEC_E_LOGON_DENIED )
         || ( SecurityStatus == SEC_E_NO_CREDENTIALS )
         || ( SecurityStatus == SEC_E_INVALID_TOKEN )
         || ( SecurityStatus == SEC_E_UNKNOWN_CREDENTIALS )
         || ( SecurityStatus == SEC_E_NO_AUTHENTICATING_AUTHORITY ) 
         || ( SecurityStatus == SEC_E_TIME_SKEW )
         || ( SecurityStatus == STATUS_AUTHENTICATION_FIREWALL_FAILED )
        ) 
       )
        {
        ASCReturnedFailure = TRUE;
        }

    // We need to make sure that the context returned supports the required
    // functionality.
    // This needs to be done only for a completed context.
    if (SecurityStatus == SEC_E_OK)
        {
        if (((Flags & ASC_REQ_REPLAY_DETECT) && !(ContextAttributes & ASC_RET_REPLAY_DETECT))
            || ((Flags & ASC_REQ_SEQUENCE_DETECT) && !(ContextAttributes & ASC_RET_SEQUENCE_DETECT))
            || ((Flags & ASC_REQ_CONFIDENTIALITY) && !(ContextAttributes & ASC_RET_CONFIDENTIALITY)))
            {
            ASCReturnedBadContextAttributes = TRUE;
            }
        }

    if (ASCReturnedFailure || ASCReturnedBadContextAttributes)
        {
        if (ASCReturnedFailure)
            FailedContext = GetLastError();
        else
            FailedContext = RPC_S_ACCESS_DENIED;

        RpcpErrorAddRecord (EEInfoGCSecurityProvider,
            SecurityStatus,
            EEInfoDLAcceptThirdLeg10,
            AuthenticationService,
            AuthenticationLevel,
            FailedContext);

        if (!fDatagram)
            {
            SecurityStatus = SEC_E_OK;
            }

        SetExtendedError(SecurityStatus);

        if (ASCReturnedFailure)
            {
            if ( (FailedContext != ERROR_PASSWORD_MUST_CHANGE)
                && (FailedContext != ERROR_PASSWORD_EXPIRED)
                && (FailedContext != ERROR_ACCOUNT_DISABLED)
                && (FailedContext != ERROR_INVALID_LOGON_HOURS) )
                {
                FailedContext = RPC_S_ACCESS_DENIED;

                RpcpErrorAddRecord (EEInfoGCRuntime,
                    FailedContext,
                    EEInfoDLAcceptThirdLeg30);
                }
            }

        ASSERT(FailedContextEEInfo == NULL);
        FailedContextEEInfo = RpcpGetEEInfo();
        RpcpClearEEInfo();
        }

    if (   ( SecurityStatus != SEC_E_OK )
        && ( SecurityStatus != SEC_I_COMPLETE_NEEDED )
        && ( SecurityStatus != SEC_I_CONTINUE_NEEDED )
        && ( SecurityStatus != SEC_I_COMPLETE_AND_CONTINUE ) )
        {
        SetExtendedError(SecurityStatus);

        RpcpErrorAddRecord (EEInfoGCSecurityProvider,
            SecurityStatus,
            EEInfoDLAcceptThirdLeg20,
            AuthenticationService,
            AuthenticationLevel);

        if ( SecurityStatus == SEC_E_SHUTDOWN_IN_PROGRESS )
            {
            RpcStatus = ERROR_SHUTDOWN_IN_PROGRESS;
            }
        else if (   (SecurityStatus == SEC_E_SECPKG_NOT_FOUND)
            || (SecurityStatus == SEC_E_NO_CREDENTIALS)
            || (SecurityStatus == SEC_E_LOGON_DENIED)
            || (SecurityStatus == SEC_E_INVALID_TOKEN)
            || (SecurityStatus == SEC_E_UNKNOWN_CREDENTIALS)
            || (SecurityStatus == SEC_E_NO_AUTHENTICATING_AUTHORITY) 
            || (SecurityStatus == SEC_E_CONTEXT_EXPIRED)
            || (SecurityStatus == SEC_E_TIME_SKEW)
            || (SecurityStatus == STATUS_AUTHENTICATION_FIREWALL_FAILED))
            {
            RpcStatus = RPC_S_ACCESS_DENIED;
            }
        else
            {
            ASSERT( SecurityStatus == SEC_E_INSUFFICIENT_MEMORY );
            RpcStatus = RPC_S_OUT_OF_MEMORY;
            }

        RpcpErrorAddRecord (EEInfoGCRuntime,
            RpcStatus,
            EEInfoDLAcceptThirdLeg40,
            SecurityStatus);

        return RpcStatus;
        }

    if ( SecurityStatus == SEC_I_CONTINUE_NEEDED )
        {
        return(RPC_P_CONTINUE_NEEDED);
        }
    if ( SecurityStatus == SEC_I_COMPLETE_AND_CONTINUE )
        {
        return(RPC_P_COMPLETE_AND_CONTINUE);
        }


    ASSERT ( (SecurityStatus == SEC_I_COMPLETE_NEEDED)
        || (SecurityStatus == SEC_E_OK));

    fFullyConstructed = TRUE;

    RpcStatus = SetMaximumLengths();
    if (RpcStatus)
        {
        FailedContext = RpcStatus;

        ASSERT(FailedContextEEInfo == NULL);
        FailedContextEEInfo = RpcpGetEEInfo();
        RpcpClearEEInfo();

        //
        // We don't want to block third leg - mimic success
        // Failed context has already been set
        //
        MaxSignatureLength = 256;
        MaxHeaderLength    = 256;
        cbBlockSize        = 64;
        }

    if (SecurityStatus == SEC_I_COMPLETE_NEEDED)
        return(RPC_P_COMPLETE_NEEDED);
    else
        return RPC_S_OK;
}



unsigned long
SECURITY_CONTEXT::InquireAuthorizationService (
    )
/*++

Return Value:

    The authorization service for this security context will be returned.

--*/
{
    SecPkgContext_DceInfo DceInfo;
    SECURITY_STATUS SecurityStatus;
    SecurityStatus = (*RpcSecurityInterface->QueryContextAttributes)(
            &SecurityContext, SECPKG_ATTR_DCE_INFO, &DceInfo);
    ASSERT( SecurityStatus == SEC_E_OK );
    return(DceInfo.AuthzSvc);
}


RPC_AUTHZ_HANDLE
SECURITY_CONTEXT::InquirePrivileges (
    )
/*++

Return Value:

    The privileges of the client at the other end of this security context
    will be returned.

--*/
{
    SecPkgContext_DceInfo DceInfo;
    SECURITY_STATUS SecurityStatus;

    SecurityStatus = (*RpcSecurityInterface->QueryContextAttributes)(
            &SecurityContext, SECPKG_ATTR_DCE_INFO, &DceInfo);
    ASSERT( SecurityStatus == SEC_E_OK );
    return(DceInfo.pPac);
}


RPC_STATUS
SECURITY_CONTEXT::GetDceInfo (
        RPC_AUTHZ_HANDLE __RPC_FAR * PacHandle,
        unsigned long __RPC_FAR * AuthzSvc
        )

/*++

Return Value:

    The privileges of the client at the other end of this security context
    will be returned.

--*/
{
    SecPkgContext_DceInfo DceInfo;
    SECURITY_STATUS SecurityStatus;

    *PacHandle = 0;
    *AuthzSvc  = 0;

    SecurityStatus = (*RpcSecurityInterface->QueryContextAttributes)(
            &SecurityContext, SECPKG_ATTR_DCE_INFO, &DceInfo);

    ASSERT( (SecurityStatus == SEC_E_OK)
           ||  (SecurityStatus == SEC_E_UNSUPPORTED_FUNCTION)
           ||  (SecurityStatus == SEC_E_INVALID_HANDLE));

    if (SecurityStatus == SEC_E_OK)
        {
        *PacHandle = DceInfo.pPac;
        *AuthzSvc  = DceInfo.AuthzSvc;
        return RPC_S_OK;
        }

    if (AuthenticationService == RPC_C_AUTHN_GSS_SCHANNEL)
        {
        SecurityStatus = (*RpcSecurityInterface->QueryContextAttributes)(
            &SecurityContext, SECPKG_ATTR_REMOTE_CERT_CONTEXT, PacHandle);

        if (SecurityStatus != SEC_E_OK)
            {
            *PacHandle = 0;
            }
        }

    if (SecurityStatus != SEC_E_OK)
        {
        return RPC_S_SEC_PKG_ERROR;
        }

    return RPC_S_OK;
}


void
SECURITY_CONTEXT::DeleteSecurityContext (
    void
    )
/*++

Routine Description:

    If there is a valid security context, we need to delete it.

--*/
{
    SECURITY_STATUS SecurityStatus;
    unsigned int nRetries = 0;

    if ( DontForgetToDelete != 0 )
        {
        if (AuthzClientContext)
            {
            AuthzFreeContextFn(AuthzClientContext);
            AuthzClientContext = NULL;
            }

        // SEC_E_INSUFFICIENT_MEMORY may be returned under extremely low
        // memory conditions.  We will do the following:
        // - Retry 10 times to delete the security context.
        // - Raise a flag in the process that we have leaked one or more security contexts.
        do 
            {
            SecurityStatus = (*RpcSecurityInterface->DeleteSecurityContext)(
                    &SecurityContext );
            nRetries++;
            }
        while (SecurityStatus == SEC_E_INSUFFICIENT_MEMORY && nRetries < 10);

        if (SecurityStatus == SEC_E_INSUFFICIENT_MEMORY)
            {
            nSecurityStructuresLeaked++;
            }

        // when the process shutdowns, the security system may return SEC_E_SECPKG_NOT_FOUND
        // since it is uninitialized. This is the only time when this error will be
        // returned, so it is safe to ignore.
        if (SecurityStatus == SEC_E_SECPKG_NOT_FOUND)
             SecurityStatus = SEC_E_OK;

#if DBG
        if ((SecurityStatus != SEC_E_OK) && (SecurityStatus != SEC_E_SHUTDOWN_IN_PROGRESS))
            {
            PrintToDebugger("DeleteSecurityContext(0x%x) Returned [%lx]\n",
                            &SecurityContext,
                            SecurityStatus);
            }
        if (SecurityStatus == SEC_E_INSUFFICIENT_MEMORY)
            {
            PrintToDebugger("SecurityContext(0x%x) leaked\n",
                            &SecurityContext);
            }
#endif

        ASSERT( SecurityStatus == SEC_E_OK ||
                SecurityStatus == SEC_E_SHUTDOWN_IN_PROGRESS ||
                SecurityStatus == SEC_E_INSUFFICIENT_MEMORY);

        DontForgetToDelete = 0;
        }

    if (FailedContextEEInfo)
        {
        FreeEEInfoChain(FailedContextEEInfo);
        FailedContextEEInfo = NULL;
        }
}

RPC_STATUS
SECURITY_CONTEXT::CheckForFailedThirdLeg (
    void
    )
/*++

Routine Description:

    If the third leg has failed, we will return the error code
    and restore the eeinfo.

--*/
{
    ASSERT(   ( SecuritySupportLoaded != 0 )
           && ( FailedToLoad == 0 ) );

    if (FailedContext != 0)
        {
        if (FailedContextEEInfo)
            {
            RpcpSetEEInfo(FailedContextEEInfo);
            FailedContextEEInfo = NULL;
            }
        return (RPC_S_ACCESS_DENIED);
        }

    return RPC_S_OK;
}


void
SECURITY_CONTEXT::DeletePac(
        void __RPC_FAR * PacHandle
        )

/*++

Return Value:


--*/
{
    if (AuthenticationService == RPC_C_AUTHN_GSS_SCHANNEL)
        {
        if (!LoadCrypt32Imports())
            {
            return;
            }

        CertFreeCertificateContext( (PCERT_CONTEXT) PacHandle );
        }
    else
        {
        (*RpcSecurityInterface->FreeContextBuffer)( PacHandle );
        }
}


RPC_STATUS
SECURITY_CONTEXT::ImpersonateClient (
    )
/*++

Routine Description:

    The server thread calling this routine will impersonate the client at the
    other end of this security context.

Return Value:

    RPC_S_OK - The impersonation successfully occured.

    RPC_S_NO_CONTEXT_AVAILABLE - There is no security context available to
        be impersonated.

--*/
{
    SECURITY_STATUS SecurityStatus;

    ASSERT(   ( SecuritySupportLoaded != 0 )
           && ( FailedToLoad == 0 ) );

    if (FailedContext != 0)
       {
       if (FailedContextEEInfo)
           {
           RpcpSetEEInfo(FailedContextEEInfo);
           FailedContextEEInfo = NULL;
           }
       return (RPC_S_ACCESS_DENIED);
       }

    ASSERT( FullyConstructed() );

    SecurityStatus = (*RpcSecurityInterface->ImpersonateSecurityContext)(
            &SecurityContext);

    if ( SecurityStatus != SEC_E_OK )
        {
        RpcpErrorAddRecord (EEInfoGCSecurityProvider,
            RPC_S_NO_CONTEXT_AVAILABLE,
            EEInfoDLImpersonateClient10,
            SecurityStatus,
            AuthenticationService,
            AuthenticationLevel);

        ASSERT( SecurityStatus == SEC_E_NO_IMPERSONATION );
        return(RPC_S_NO_CONTEXT_AVAILABLE);
        }

    return(RPC_S_OK);
}


void
SECURITY_CONTEXT::RevertToSelf (
    )
/*++

Routine Description:

    The server thread calling this routine will stop impersonating.  If the
    thread is not impersonating, then this is a noop.

--*/
{
    SECURITY_STATUS SecurityStatus;

    ASSERT(   ( SecuritySupportLoaded != 0 )
           && ( FailedToLoad == 0 ) );

    SecurityStatus = (*RpcSecurityInterface->RevertSecurityContext)(
            &SecurityContext);

    ASSERT( SecurityStatus == SEC_E_OK );
}

RPC_STATUS
SECURITY_CONTEXT::GetAccessToken (
    OUT HANDLE *ImpersonationToken,
    OUT BOOL *fNeedToCloseToken
    )
/*++

Routine Description:

    Gets the access token maintained by the security provider.

Arguments:

    ImpersonationToken - contains the impersonation token on success
    fNeedToCloseToken - true if the resulting token needs closing.
        False otherwise. Some security providers support handing off
        of the token itself (faster). Some don't. All support handing
        off a copy of the token. Depending on what security provider
        we have, we'll get the token, and set this variable. This
        parameter is undefined in case of failure.

Return Value:
    RPC_S_OK on success, or RPC_S_* on failure. Supports EEInfo.

--*/
{
    SECURITY_STATUS SecurityStatus;
    HANDLE Token;

    ASSERT(   ( SecuritySupportLoaded != 0 )
           && ( FailedToLoad == 0 ) );

    ASSERT( FullyConstructed() );

    SecurityStatus = (*RpcSecurityInterface->QueryContextAttributes)(
            &SecurityContext,
            SECPKG_ATTR_ACCESS_TOKEN,
            &Token);

    if ( (SecurityStatus != SEC_E_OK)
        && (SecurityStatus != SEC_E_UNSUPPORTED_FUNCTION) )
        {
        RpcpErrorAddRecord (EEInfoGCSecurityProvider,
            RPC_S_NO_CONTEXT_AVAILABLE,
            EEInfoDLSECURITY_CONTEXT__GetAccessToken10,
            SecurityStatus,
            AuthenticationService,
            AuthenticationLevel);

        ASSERT( 0 );
        return(RPC_S_NO_CONTEXT_AVAILABLE);
        }

    if (SecurityStatus != SEC_E_OK)
        {
        ASSERT(SecurityStatus == SEC_E_UNSUPPORTED_FUNCTION);

        // the security provider does not provide quick retrieval
        // of token - go the long way
        SecurityStatus = (*RpcSecurityInterface->QuerySecurityContextToken)(
            &SecurityContext, &Token);

        if (SecurityStatus != SEC_E_OK)
            {
            RpcpErrorAddRecord (EEInfoGCSecurityProvider,
                RPC_S_NO_CONTEXT_AVAILABLE,
                EEInfoDLSECURITY_CONTEXT__GetAccessToken20,
                SecurityStatus,
                AuthenticationService,
                AuthenticationLevel);

            ASSERT( SecurityStatus == SEC_E_NO_IMPERSONATION );
            return(RPC_S_NO_CONTEXT_AVAILABLE);
            }

        *fNeedToCloseToken = TRUE;
        }
    else
        {
        *fNeedToCloseToken = FALSE;
        }

    *ImpersonationToken = Token;
    return RPC_S_OK;
}


PACKAGE_LEG_COUNT
GetPackageLegCount(
    DWORD id
    )
/*++

Routine Description:

    This fn determines whether the given security package is a 3- or 4-leg
    protocol. The relevance of this information is described in
    ReadPackageLegInfo(). This fn. first searches the hardcoded entries in
    PredefinedPackageLegInfo[], and if the package is not found it turns to the
    registry information stored in FourLeggedPackages[].

Return Values:

    LegsUnknown = the fn cannot give a reliable answer

    ThreeLegs = this is a 3-leg protocol

    EvenNumberOfLegs = this is not a 3-leg protocol

--*/
{
    int i;

    if ( InsureSecuritySupportLoaded() != RPC_S_OK )
        {
        return LegsUnknown;
        }

    for (i=0; PredefinedPackageLegInfo[i].Package != 0; ++i)
        {
        if (PredefinedPackageLegInfo[i].Package == id)
            {
            return PredefinedPackageLegInfo[i].Legs;
            }
        }

    CLAIM_MUTEX Lock( *SecurityCritSect );

    if (!FourLeggedPackages)
        {
        if (!ReadPackageLegInfo())
            {
            return LegsUnknown;
            }
        }

    ASSERT(FourLeggedPackages);

    for (i=0; FourLeggedPackages[i] != 0; ++i)
        {
        if (FourLeggedPackages[i] == id)
            {
            return EvenNumberOfLegs;
            }
        }

    return ThreeLegs;
}

DWORD
SECURITY_CONTEXT::VerifyCertificate()
{
    DWORD SecurityStatus = 0;

    //
    // Compare the name on the certificate against the expected principal name.
    //
    if (ServerPrincipalName)
        {
        //
        // Get a copy of the raw certificate.
        //
        if (!LoadCrypt32Imports())
            {
            return GetLastError();
            }

        PCERT_CONTEXT ClientContext;

        SecurityStatus = (*RpcSecurityInterface->QueryContextAttributes)(
                                &SecurityContext,
                                SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                                &ClientContext
                                );
        if (SecurityStatus)
            {
            RpcpErrorAddRecord ( EEInfoGCSecurityProvider,
                                 RPC_S_OUT_OF_MEMORY,
                                 EEInfoDLInitializeThirdLeg60,
                                 SecurityStatus );

            ASSERT( SecurityStatus == SEC_E_INSUFFICIENT_MEMORY );
            return SecurityStatus;
            }

        SecurityStatus = RpcCertMatchPrincipalName( ClientContext, ServerPrincipalName );
        switch (SecurityStatus)
            {
            case 0:
            case ERROR_NOT_ENOUGH_MEMORY:
                break;

            default:

                //
                // we are supposed to have verified the princ name earlier.
                //
                ASSERT( SecurityStatus != ERROR_INVALID_PARAMETER );

                SetExtendedError(SecurityStatus);

                SecurityStatus = RPC_S_ACCESS_DENIED;
                break;
            }

        CertFreeCertificateContext( ClientContext );
        }

    return SecurityStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\rpcuuid.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    rpcuuid.cxx

Abstract:

    The implementations of the methods used to manipulate RPC_UUID
    instances (which contain UUIDs) live in this file.

Author:

    Michael Montague (mikemon) 15-Nov-1991

Revision History:

    Danny Glasser (dannygl) 03-Mar-1992
        Created worker functions for IsNullUuid, CopyUuid, and
        ConvertToString.  This is necessary for medium-model
        (i.e. Win16) support, because the Glock C++ translator
        doesn't support far "this" pointers.

    Danny Glasser (dannygl) 07-Mar-1992
        Same as above for ConvertFromString.

    Michael Montague (mikemon) 30-Nov-1992
        Removed the I_ routines.

--*/

#include <precomp.hxx>
#include <osfpcket.hxx>


static RPC_CHAR PAPI *
HexStringToULong (
    IN RPC_CHAR PAPI * String,
    OUT unsigned long PAPI * Number
    )
/*++

Routine Description:

    This routine converts the hex representation of a number into an
    unsigned long.  The hex representation is assumed to be a full
    eight characters long.

Arguments:

    String - Supplies the hex representation of the number.

    Number - Returns the number converted from hex representation.

Return Value:

    A pointer to the end of the hex representation is returned if the
    hex representation was successfully converted to an unsigned long.
    Otherwise, zero is returned, indicating that an error occured.

--*/
{
    unsigned long Result;
    int Count;

    Result = 0;
    for (Count = 0; Count < 8; Count++, String++)
        {
        if (   (*String >= RPC_CONST_CHAR('0'))
            && (*String <= RPC_CONST_CHAR('9')))
            Result = (Result << 4) + *String - RPC_CONST_CHAR('0');
        else if (   (*String >= RPC_CONST_CHAR('A'))
                 && (*String <= RPC_CONST_CHAR('F')))
            Result = (Result << 4) + *String - RPC_CONST_CHAR('A') + 10;
        else if (   (*String >= RPC_CONST_CHAR('a'))
                 && (*String <= RPC_CONST_CHAR('f')))
            Result = (Result << 4) + *String - RPC_CONST_CHAR('a') + 10;
        else
            return(0);
        }
    *Number = Result;
    return(String);
}


static RPC_CHAR PAPI *
HexStringToUShort (
    IN RPC_CHAR PAPI * String,
    OUT unsigned short PAPI * Number
    )
/*++

Routine Description:

    This routine converts the hex representation of a number into an
    unsigned short.  The hex representation is assumed to be a full
    four characters long.

Arguments:

    String - Supplies the hex representation of the number.

    Number - Returns the number converted from hex representation.

Return Value:

    A pointer to the end of the hex representation is returned if the
    hex representation was successfully converted to an unsigned short.
    Otherwise, zero is returned, indicating that an error occured.

--*/
{
    unsigned short Result;
    int Count;

    Result = 0;
    for (Count = 0; Count < 4; Count++, String++)
        {
        if (   (*String >= RPC_CONST_CHAR('0'))
            && (*String <= RPC_CONST_CHAR('9')))
            Result = (Result << 4) + *String - RPC_CONST_CHAR('0');
        else if (   (*String >= RPC_CONST_CHAR('A'))
                 && (*String <= RPC_CONST_CHAR('F')))
            Result = (Result << 4) + *String - RPC_CONST_CHAR('A') + 10;
        else if (   (*String >= RPC_CONST_CHAR('a'))
                 && (*String <= RPC_CONST_CHAR('f')))
            Result = (Result << 4) + *String - RPC_CONST_CHAR('a') + 10;
        else
            return(0);
        }
    *Number = Result;
    return(String);
}


static RPC_CHAR PAPI *
HexStringToUChar (
    IN RPC_CHAR PAPI * String,
    OUT unsigned char PAPI * Number
    )
/*++

Routine Description:

    This routine converts the hex representation of a number into an
    unsigned char.  The hex representation is assumed to be a full
    two characters long.

Arguments:

    String - Supplies the hex representation of the number.

    Number - Returns the number converted from hex representation.

Return Value:

    A pointer to the end of the hex representation is returned if the
    hex representation was successfully converted to an unsigned char.
    Otherwise, zero is returned, indicating that an error occured.

--*/
{
    RPC_CHAR Result;
    int Count;

    Result = 0;
    for (Count = 0; Count < 2; Count++, String++)
        {
        if (   (*String >= RPC_CONST_CHAR('0'))
            && (*String <= RPC_CONST_CHAR('9')))
            Result = (Result << 4) + *String - RPC_CONST_CHAR('0');
        else if (   (*String >= RPC_CONST_CHAR('A'))
                 && (*String <= RPC_CONST_CHAR('F')))
            Result = (Result << 4) + *String - RPC_CONST_CHAR('A') + 10;
        else if (   (*String >= RPC_CONST_CHAR('a'))
                 && (*String <= RPC_CONST_CHAR('f')))
            Result = (Result << 4) + *String - RPC_CONST_CHAR('a') + 10;
        else
            return(0);
        }
    *Number = (unsigned char)Result;
    return(String);
}


int
RPC_UUID::ConvertFromString (
    IN RPC_CHAR PAPI * String
    )
/*++

Routine Description:

    We convert the string representation of uuid into an actual uuid
    in this method.  The convert uuid is placed into this.

Arguments:

    String - Supplies the string representation of the uuid.

Return Value:

    0 - The operation completed successfully.

    1 - String does not supply a valid uuid.

--*/
{
    String = HexStringToULong(String,&Data1);
    if (String == 0)
        return(1);
    if (*String++ != RPC_CONST_CHAR('-'))
        return(1);
    String = HexStringToUShort(String,&Data2);
    if (String == 0)
        return(1);
    if (*String++ != RPC_CONST_CHAR('-'))
        return(1);
    String = HexStringToUShort(String,&Data3);
    if (String == 0)
        return(1);
    if (*String++ != RPC_CONST_CHAR('-'))
        return(1);
    String = HexStringToUChar(String,&Data4[0]);
    if (String == 0)
        return(1);
    String = HexStringToUChar(String,&Data4[1]);
    if (String == 0)
        return(1);
    if (*String++ != RPC_CONST_CHAR('-'))
        return(1);
    String = HexStringToUChar(String,&Data4[2]);
    if (String == 0)
        return(1);
    String = HexStringToUChar(String,&Data4[3]);
    if (String == 0)
        return(1);
    String = HexStringToUChar(String,&Data4[4]);
    if (String == 0)
        return(1);
    String = HexStringToUChar(String,&Data4[5]);
    if (String == 0)
        return(1);
    String = HexStringToUChar(String,&Data4[6]);
    if (String == 0)
        return(1);
    String = HexStringToUChar(String,&Data4[7]);
    if (String == 0)
        return(1);

    if ( *String != 0 )
        {
        return(1);
        }

    return(0);
}


void
RPC_UUID::SetToNullUuid (
    )
/*++

Routine Description:

    This is set to the null UUID value.

--*/
{
    RpcpMemorySet( (UUID __RPC_FAR *) this, 0, sizeof(UUID));
}


static RPC_CHAR HexDigits[] =
{
    RPC_CONST_CHAR('0'),
    RPC_CONST_CHAR('1'),
    RPC_CONST_CHAR('2'),
    RPC_CONST_CHAR('3'),
    RPC_CONST_CHAR('4'),
    RPC_CONST_CHAR('5'),
    RPC_CONST_CHAR('6'),
    RPC_CONST_CHAR('7'),
    RPC_CONST_CHAR('8'),
    RPC_CONST_CHAR('9'),
    RPC_CONST_CHAR('a'),
    RPC_CONST_CHAR('b'),
    RPC_CONST_CHAR('c'),
    RPC_CONST_CHAR('d'),
    RPC_CONST_CHAR('e'),
    RPC_CONST_CHAR('f')
};


RPC_CHAR PAPI *
ULongToHexString (
    IN RPC_CHAR PAPI * String,
    IN unsigned long Number
    )
/*++

Routine Description:

    We convert an unsigned long into hex representation in the specified
    string.  The result is always eight characters long; zero padding is
    done if necessary.

Arguments:

    String - Supplies a buffer to put the hex representation into.

    Number - Supplies the unsigned long to convert to hex.

Return Value:

    A pointer to the end of the hex string is returned.

--*/
{
    *String++ = HexDigits[(Number >> 28) & 0x0F];
    *String++ = HexDigits[(Number >> 24) & 0x0F];
    *String++ = HexDigits[(Number >> 20) & 0x0F];
    *String++ = HexDigits[(Number >> 16) & 0x0F];
    *String++ = HexDigits[(Number >> 12) & 0x0F];
    *String++ = HexDigits[(Number >> 8) & 0x0F];
    *String++ = HexDigits[(Number >> 4) & 0x0F];
    *String++ = HexDigits[Number & 0x0F];
    return(String);
}


static RPC_CHAR PAPI *
UShortToHexString (
    IN RPC_CHAR PAPI * String,
    IN unsigned short Number
    )
/*++

Routine Description:

    We convert an unsigned short into hex representation in the specified
    string.  The result is always four characters long; zero padding is
    done if necessary.

Arguments:

    String - Supplies a buffer to put the hex representation into.

    Number - Supplies the unsigned short to convert to hex.

Return Value:

    A pointer to the end of the hex string is returned.

--*/
{
    *String++ = HexDigits[(Number >> 12) & 0x0F];
    *String++ = HexDigits[(Number >> 8) & 0x0F];
    *String++ = HexDigits[(Number >> 4) & 0x0F];
    *String++ = HexDigits[Number & 0x0F];
    return(String);
}


static RPC_CHAR PAPI *
UCharToHexString (
    IN RPC_CHAR PAPI * String,
    IN RPC_CHAR Number
    )
/*++

Routine Description:

    We convert an unsigned char into hex representation in the specified
    string.  The result is always two characters long; zero padding is
    done if necessary.

Arguments:

    String - Supplies a buffer to put the hex representation into.

    Number - Supplies the unsigned char to convert to hex.

Return Value:

    A pointer to the end of the hex string is returned.

--*/
{
    *String++ = HexDigits[(Number >> 4) & 0x0F];
    *String++ = HexDigits[Number & 0x0F];
    return(String);
}


RPC_CHAR PAPI *
RPC_UUID::ConvertToString (
    OUT RPC_CHAR PAPI * String
    )
/*++

Routine Description:

    The string representation of this uuid is written into the string
    argument.  The printf statement used to print a uuid follows.

    printf("%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X",
            Uuid.Data1, Uuid.Data2, Uuid.Data3, Uuid.Data4[0],
            Uuid.Data4[1], Uuid.Data4[2], Uuid.Data4[3], Uuid.Data4[4],
            Uuid.Data4[5], Uuid.Data4[6], Uuid.Data4[7]);

Arguments:

    String - Returns the string representation of the uuid.

Return Value:

    A pointer to the end of the string representation of the uuid is
    returned.

--*/
{
    String = ULongToHexString(String, Data1);
    *String++ = RPC_CONST_CHAR('-');
    String = UShortToHexString(String,Data2);
    *String++ = RPC_CONST_CHAR('-');
    String = UShortToHexString(String,Data3);
    *String++ = RPC_CONST_CHAR('-');
    String = UCharToHexString(String, Data4[0]);
    String = UCharToHexString(String, Data4[1]);
    *String++ = RPC_CONST_CHAR('-');
    String = UCharToHexString(String, Data4[2]);
    String = UCharToHexString(String, Data4[3]);
    String = UCharToHexString(String, Data4[4]);
    String = UCharToHexString(String, Data4[5]);
    String = UCharToHexString(String, Data4[6]);
    String = UCharToHexString(String, Data4[7]);
    return(String);
}


int
RPC_UUID::IsNullUuid (
    )
/*++

Routine Description:

    This predicate tests whether this is the null uuid or not.

Return Value:

    FALSE - This is not the null uuid.

    TRUE - This is the null uuid.

--*/
{
    unsigned long PAPI * Vector;

    Vector = (unsigned long PAPI *) (UUID PAPI *) this;
    if (   (Vector[0] == 0)
        && (Vector[1] == 0)
        && (Vector[2] == 0)
        && (Vector[3] == 0))
        return(TRUE);
    return(FALSE);
}


unsigned short
RPC_UUID::HashUuid (
    )
/*++

Routine Description:

    This routine computes a unsigned short hash value for the Uuid.

Return Value:

    A hash value.

--*/
{
    unsigned short __RPC_FAR *Values;

    Values = (unsigned short __RPC_FAR *) (UUID *) this;

    return(  Values[0] ^ Values[1] ^ Values[2] ^ Values[3]
           ^ Values[4] ^ Values[5] ^ Values[6] ^ Values[7] );
}

void ByteSwapUuid(
    RPC_UUID PAPI *pUuid
    )
{
    pUuid->Data1 = RpcpByteSwapLong(pUuid->Data1);
    pUuid->Data2 = RpcpByteSwapShort(pUuid->Data2);
    pUuid->Data3 = RpcpByteSwapShort(pUuid->Data3);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\startsvc.h ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    startsvc.h

Abstract:

    This file contains the interface for insuring that the rpcss service
    has been started.

Author:

    Michael Montague (mikemon) (02-Oct-1992)

Revision History:

--*/

#ifndef __STARTSVC_H__
#define __STARTSVC_H__

#ifdef __cplusplus
extern "C" {
#endif
RPC_STATUS RPC_ENTRY
StartServiceIfNecessary (
    void
    );
#ifdef __cplusplus
}
#endif

#endif // __STARTSVC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\sidcache.cxx ===
/*++

Copyright (C) Microsoft Corporation, 2002

Module Name:

    sidcache.cxx

Abstract:

    This contains the SID_CACHE definition and wrappers to access the per process
    SIDCache.  

Author:

    Maurice Flanagan (mauricf) June 27, 2002

Revision History:
   

--*/

#include <precomp.hxx>
#include <sidcache.hxx>


SID_CACHE *SIDCache = NULL;

RPC_STATUS
QuerySIDCache(
    IN  RPC_CHAR *ServerPrincipalName, 
    OUT PSID *Sid
    )
/*++

Routine Description:

    This wraps access to our global SIDCache object.  

Arguments, either:

    ServerPrincipalName - the server principal name to be translated to
        a SID
    
    Sid - On output contains a pointer to the allocated SID. On success (RPC_S_OK) this will be
          NULL if the SPN was not found in our cache.  Undefined on failure. 
          Pointer must be freed with delete.

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    ASSERT(ServerPrincipalName != NULL);
    ASSERT(Sid != NULL);

    if (SIDCache == NULL)
        {
        return RPC_S_OUT_OF_MEMORY;            
        }

    return SIDCache->Query(ServerPrincipalName, Sid);
}

RPC_STATUS
AddToSIDCache(
    IN RPC_CHAR *ServerPrincipalName,
    IN PSID Sid
    )
/*++

Routine Description:

    This wraps access to our global SIDCache object.  

Arguments, either:

    ServerPrincipalName - The server principal name which we want to add to our cache.
    
    Sid - The SID associated with this server principal name.

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    ASSERT(ServerPrincipalName != NULL);
    ASSERT(Sid != NULL);

    if (SIDCache == NULL)
        {
        return RPC_S_OUT_OF_MEMORY;            
        }

   return SIDCache->Add(ServerPrincipalName, Sid);
}

RPC_STATUS
RemoveFromSIDCache(
    IN RPC_CHAR *ServerPrincipalName
    )
/*++

Routine Description:

    This wraps access to our global SIDCache object.  

Arguments, either:

    ServerPrincipalName - The server principal name which we want to remove from our cache
    
Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    if (SIDCache == NULL)
        {
        return RPC_S_OUT_OF_MEMORY;            
        }

    return SIDCache->Remove(ServerPrincipalName);
}

RPC_STATUS
SID_CACHE::Query (
    IN  RPC_CHAR *ServerPrincipalName,
    OUT PSID *Sid
    )
/*++

Routine Description:

    This checks the chache for a matching ServerPrincipalName and if found it returns the SID.
    The goal of the cache is to maintain the last N (N is currently 4) most recently accessed entries.
    We must loop through the entire cache and increment the Age of every entry.  If there is a matching
    entry (a hit) then we start the age over again at zero.  Every SPN in the cache is unique in the cache.

Arguments, either:

    ServerPrincipalName - The server principal name which we want to lookup in our cache

    Sid - Filled in with the value found in the cache, or NULL if not found.  Undefined on error return.
    
Return Value:

    RPC_S_OK or RPC_S_OUT_OF_MEMORY 

--*/
 
{
    DWORD idx;
    BOOL  fFound = FALSE;
    *Sid = NULL; 

    CacheMutex.Request();
    for (idx = 0; idx < CacheSize; idx++)
        {
        if (Cache[idx].SPN != NULL)
            {
            if ((!fFound) && (RpcpStringCompare(ServerPrincipalName, Cache[idx].SPN) == 0))
                {
                ASSERT(Cache[idx].SID != NULL);
                Cache[idx].Age = 0;
                fFound = TRUE;
                *Sid = DuplicateSID(Cache[idx].SID);
                if (*Sid == NULL)
                    {
                    CacheMutex.Clear();
                    return RPC_S_OUT_OF_MEMORY;
                    }
                }         
            else
                {
                Cache[idx].Age++;
                }
            }
        }

    CacheMutex.Clear();
    return RPC_S_OK;
}

RPC_STATUS
SID_CACHE::Add (
    IN RPC_CHAR *ServerPrincipalName,
    IN PSID Sid
    )
/*++

Routine Description:

    This adds an entry to the cache for this SPN and sets this SID.  
    We only have four slots, first we check if this SPN has an entry, if so we free the existing SID
    and add the new one in its place.  Next we check for an empty slot, if so we use it.  Lastly we
    find the first oldest slot and use that (freeing the existing SPN and SID).

Arguments, either:

    ServerPrincipalName - The server principal name which we want to add to our cache, we
                                      make a copy of it.

                                   
    Sid - The SID to associate with this SPN, we make a copy of this (DuplicateSID)
    
Return Value:

    RPC_S_OK or RPC_S_* error

--*/

{
    RPC_STATUS Status = RPC_S_OK;
    DWORD     idx = 0;
    DWORD     IdxToUse = -1;
    DWORD     OldestIdx = -1, OldestAge;
    DWORD     EmptyIdx = -1;
    

    // What slot to use, in order:

    // Slot with same SPN
    // Empty slot
    // Oldest slot

    CacheMutex.Request();
    for (idx = 0; idx < CacheSize; idx++)
        {
        // Is this SPN already in the cache?
        if (Cache[idx].SPN != NULL)
            {
            if (RpcpStringCompare(ServerPrincipalName, Cache[idx].SPN) == 0)
                {
                if (!EqualSid(Sid, Cache[idx].SID))
                    {
                    delete [] Cache[idx].SID;
                    Cache[idx].SID = DuplicateSID(Sid);
                    if (Cache[idx].SID == NULL)
                        {
                        delete [] Cache[idx].SPN;
                        Cache[idx].SPN = NULL;
                        CacheMutex.Clear();
                        return RPC_S_OUT_OF_MEMORY;
                        }
                    }
                Cache[idx].Age = 0;
                CacheMutex.Clear();
                return RPC_S_OK;
                }
            }

        if (EmptyIdx == -1)
            {
            if (Cache[idx].SPN == NULL) 
                {
                // remember this empty slot
                EmptyIdx = idx;
                }
            else 
                {
                if (OldestIdx == -1)
                    {
                    OldestAge = Cache[idx].Age;
                    OldestIdx = idx;
                    }
                else if (OldestAge < Cache[idx].Age)
                    {
                    OldestAge = Cache[idx].Age;
                    OldestIdx = idx;
                    }                    
                }
            }
        }
         

    // We have either the oldest or an empty slot
    if (EmptyIdx == -1)
        {
        delete [] Cache[OldestIdx].SPN;    
        delete [] Cache[OldestIdx].SID;
        Cache[OldestIdx].SPN = NULL;
        Cache[OldestIdx].SID = NULL;
        IdxToUse = OldestIdx;
        }
    else
        {
        IdxToUse = EmptyIdx;
        }

    ASSERT(IdxToUse != -1);

    Cache[IdxToUse].Age = 0;
    Cache[IdxToUse].SPN = new RPC_CHAR [RpcpStringLength(ServerPrincipalName) +1];
    if (Cache[IdxToUse].SPN == NULL)
        {
        CacheMutex.Clear();
        return RPC_S_OUT_OF_MEMORY;
        }
    RpcpStringNCopy(Cache[IdxToUse].SPN, ServerPrincipalName, RpcpStringLength(ServerPrincipalName) +1);
    Cache[IdxToUse].SID = DuplicateSID(Sid);
    if (Cache[IdxToUse].SID == NULL)
        {
        delete [] Cache[IdxToUse].SPN;
        Cache[IdxToUse].SPN = NULL;
        CacheMutex.Clear();
        return RPC_S_OUT_OF_MEMORY;
        }

    CacheMutex.Clear();
    return RPC_S_OK;
}

RPC_STATUS
SID_CACHE::Remove (
    IN  RPC_CHAR *ServerPrincipalName
    )
{
    DWORD idx;

    if (ServerPrincipalName == NULL)
        return RPC_S_OK;
    
    CacheMutex.Request();
    for (idx = 0; idx < CacheSize; idx++)
        {
        if (Cache[idx].SPN != NULL)
            {
            if (RpcpStringCompare(ServerPrincipalName, Cache[idx].SPN) == 0)
                {
                ASSERT(Cache[idx].SID != NULL);
                delete [] Cache[idx].SPN;
                delete [] Cache[idx].SID;
                Cache[idx].SPN = NULL;
                Cache[idx].SID = NULL;
                Cache[idx].Age = 0;
                break;
                }
            }
        }
    CacheMutex.Clear();
    return RPC_S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\startsvc.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    startsvc.c

Abstract:

    This routine implements on-demand starting of the RpcSs service.

Author:

    Bharat Shah (barats) 4-5-92

Revision History:

--*/

#include <sysinc.h>
#include <rpc.h>
#include <winsvc.h>
#include <startsvc.h>

#define SUCCESS         0
const RPC_CHAR *pRPCEPMPR = RPC_CONST_STRING("RPCSS");



RPC_STATUS RPC_ENTRY
StartServiceIfNecessary(
    void
    )
/*++

Routine Description:

    If the rpcss service has not yet been started, then we attempt to
    start it.

Returns:

    RPC_S_OK - The rpcss service is running.

    Service controller errors.


--*/
{

    SC_HANDLE           hServiceController = NULL;
    SC_HANDLE           hService = NULL;
    SERVICE_STATUS      ServiceStatus;
    DWORD               status;
    DWORD               Counter = 0L;
    BOOL                FirstTime = TRUE;
    unsigned long       ArgC = 0;
    RPC_CHAR     PAPI *     ArgV[1] = { NULL };

    //
    // Get a handle to the service controller.
    //
    hServiceController = OpenSCManager(
                            NULL,
                            NULL,
                            GENERIC_READ);

    if (hServiceController == NULL)
       {
        status = GetLastError();
        return(status);
       }

    //
    // Get a handle to the service
    //
    hService = OpenService(
                hServiceController,
                pRPCEPMPR,
                GENERIC_READ|SERVICE_START);

    if (hService == NULL)
       {
        status = GetLastError();
        goto CleanExit;
       }

    //
    // Call StartService
    //
    /*
    if (!StartService(hService,ArgC,ArgV))
       {
          status = GetLastError();
          if (status == ERROR_SERVICE_ALREADY_RUNNING)
             status = RPC_S_OK;
          goto CleanExit;
       }
    */

    do
      {

        if (!QueryServiceStatus(hService,&ServiceStatus))
            {
              status = GetLastError();
              goto CleanExit;
            }

        switch(ServiceStatus.dwCurrentState)
        {

          case SERVICE_RUNNING:
                status = SUCCESS;
                goto CleanExit;
                break;

          case SERVICE_STOP_PENDING:
          case SERVICE_START_PENDING:
                if (!FirstTime && (Counter == ServiceStatus.dwCheckPoint))
                   {
                    status = ERROR_SERVICE_REQUEST_TIMEOUT;
                    goto CleanExit;
                   }
                else
                   {
                    FirstTime = FALSE;
                    Counter = ServiceStatus.dwCheckPoint;
                    Sleep(ServiceStatus.dwWaitHint);
                   }
                 break;
 
          case SERVICE_STOPPED:
                if (!StartService(hService, ArgC, ArgV))
                   {
                   status = GetLastError();
                   if (status == ERROR_SERVICE_ALREADY_RUNNING)
                               status = RPC_S_OK;
                   goto CleanExit;
                   }
                 Sleep(500);
                 break;

          default:
                 status = GetLastError();
                 goto CleanExit;
                 break;
       }
    }
   while (TRUE);

CleanExit:

    if(hServiceController != NULL) {
        (VOID) CloseServiceHandle(hServiceController);
    }
    if(hService != NULL) {
        (VOID) CloseServiceHandle(hService);
    }
    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\svrapip.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1991 - 1999
//
//  File:       svrapip.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

                      Microsoft OS/2 LAN Manager
                   Copyright(c) Microsoft Corp., 1990

-------------------------------------------------------------------- */
/* --------------------------------------------------------------------

File : svrapip.cxx

Description :

This file contains the private entry points into the server runtime.

History :

mikemon    02-02-91    Created.

-------------------------------------------------------------------- */

#include <precomp.hxx>

void RPC_ENTRY
I_RpcRequestMutex (
    IN OUT I_RPC_MUTEX * Mutex
    )
{
    if (*Mutex == 0)
        {
        RPC_STATUS RpcStatus = RPC_S_OK;

        MUTEX *mutex = new MUTEX(&RpcStatus);

        if ( NULL == mutex )
            {
            RpcpRaiseException(RPC_S_OUT_OF_MEMORY);
            return;
            }

        if ( RpcStatus != RPC_S_OK )
            {
            delete mutex;
            RpcpRaiseException(RPC_S_OUT_OF_MEMORY);
            return;
            }

        if (InterlockedCompareExchangePointer(Mutex, mutex, NULL) != NULL)
            {
            delete mutex;
            }
        }

    ((MUTEX *) (*Mutex))->Request();
}

void RPC_ENTRY
I_RpcClearMutex (
    IN I_RPC_MUTEX Mutex
    )
{
    ((MUTEX *) Mutex)->Clear();
}

void RPC_ENTRY
I_RpcDeleteMutex (
    IN I_RPC_MUTEX Mutex
    )
{
    delete ((MUTEX *) Mutex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\svrbind.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    svrbind.cxx

Abstract:

    This file contains the implementation of the server binding handle
    class, SVR_BINDING_HANDLE.

Author:

    Michael Montague (mikemon) 23-Nov-1991

Revision History:

--*/

#include <precomp.hxx>


RPC_STATUS
SVR_BINDING_HANDLE::InsureRealBindingHandle (
    )
/*++

Routine Description:

    This method is used to insure that we have transformed this binding
    handle into a real full fledged binding handle.  If we do not
    have a real binding handle, then we attempt to create one.

Return Value:

    RPC_S_OK will be returned if we successfully obtain a real binding
    handle.  Otherwise, the result of trying to create a binding handle
    will be returned; see DCE_BINDING::CreateBindingHandle for a list
    of error codes.

--*/
{
    RPC_STATUS Status;

    if (RealBindingHandle == 0)
        {

        RealBindingHandle = DceBinding->CreateBindingHandle(&Status);

        if (Status != RPC_S_OK)
            {
            RealBindingHandle = 0;
            return(Status);
            }

        // This binding needs to transfer its ObjectUuid, if any,
        // to the new binding.  It is not possible to efficiently add
        // the object uuid to the DceBinding first.

        if (InqIfNullObjectUuid() == 0)
            {
            RealBindingHandle->SetObjectUuid(InqPointerAtObjectUuid());
            }

        DceBinding = 0;
        }
    return(RPC_S_OK);
}


SVR_BINDING_HANDLE::SVR_BINDING_HANDLE (
    IN DCE_BINDING * DceBinding,
    IN RPC_CHAR * DynamicEndpoint, 
    IN OUT RPC_STATUS *Status
    ) : BINDING_HANDLE(Status)
/*++

Routine Description:

    This constructor is trivial.  We just stash the binding information
    and dynamic endpoint away for future use.

Arguments:

    DceBinding - Supplies the binding information.  Ownership of this
        object passes to this routine.

    DynamicEndpoint - Supplies the dynamic endpoint for the rpc address
        corresponding to this binding.  Ownership of this object passes
        to this routine.

--*/
{
    ObjectType = SVR_BINDING_HANDLE_TYPE;
    this->DceBinding = DceBinding;
    RealBindingHandle = 0;

    if( DynamicEndpoint )
        {
        EndpointIsDynamic = 1;
        DceBinding->AddEndpoint(DynamicEndpoint);
        }
    else
        {
        EndpointIsDynamic = 0;
        }
}


SVR_BINDING_HANDLE::~SVR_BINDING_HANDLE (
    )
/*++

Routine Description:

    Since ownership of the binding information passed to the constructor
    of this instance, we need to delete the binding information now.
    Actually, before we can delete the binding information we need to
    check to see if ownership has passed to the real binding handle.

--*/
{
    if (DceBinding != 0)
        delete DceBinding;
}


inline HANDLE_TYPE // Return SVR_BINDING_HANDLE_TYPE.
SVR_BINDING_HANDLE::Type (
    )
{
    UNUSED(this);

    return (SVR_BINDING_HANDLE_TYPE);
}


void
SVR_BINDING_HANDLE::MakePartiallyBound(
    )
/*++

Routine Description:

    This routine is called by RPC_SERVER::NsBindingsModify(). We just
    remove the endpoint information from DceBinding member variable.

--*/
{
    if (EndpointIsDynamic)
        {
        DceBinding->MakePartiallyBound();
        }
}




RPC_STATUS
SVR_BINDING_HANDLE::SendReceive (
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:

    We need to transport the server binding handle into a full fledged
    binding handle, and then let the full fledged binding handle take
    care of performing the requested operation.

Arguments:

    Message - Supplies and returns information describing the remote
        procedure call to be sent.

Return Value:

    For possible return codes, see DCE_BINDING::CreateBindingHandle and
    SendReceive.

--*/
{
    RPC_STATUS Status;

    Status = InsureRealBindingHandle();
    if (Status != RPC_S_OK)
        return(Status);
    return(RealBindingHandle->SendReceive(Message));
}


RPC_STATUS
SVR_BINDING_HANDLE::NegotiateTransferSyntax (
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:

    We need to transport the server binding handle into a full fledged
    binding handle, and then let the full fledged binding handle take
    care of performing the requested operation.

Arguments:

    Message - Supplies and returns information describing the buffer
        we need to allocate.

Return Value:

    For possible return codes, see DCE_BINDING::CreateBindingHandle and
    the different flavors of NegotiateTransferSyntax.

--*/
{
    RPC_STATUS Status;

    Status = InsureRealBindingHandle();
    if (Status != RPC_S_OK)
        return(Status);
    return(RealBindingHandle->NegotiateTransferSyntax(Message));
}


RPC_STATUS
SVR_BINDING_HANDLE::GetBuffer (
    IN OUT PRPC_MESSAGE Message,
    IN UUID *ObjectUuid
    )
/*++

Routine Description:

    We need to transport the server binding handle into a full fledged
    binding handle, and then let the full fledged binding handle take
    care of performing the requested operation.

Arguments:

    Message - Supplies and returns information describing the buffer
        we need to allocate.

Return Value:

    For possible return codes, see DCE_BINDING::CreateBindingHandle and
    the different flavors of GetBuffer.

--*/
{
    RPC_STATUS Status;

    Status = InsureRealBindingHandle();
    if (Status != RPC_S_OK)
        return(Status);
    return(RealBindingHandle->GetBuffer(Message, ObjectUuid));
}


void
SVR_BINDING_HANDLE::FreeBuffer (
    IN PRPC_MESSAGE Message
    )
/*++

Routine Description:

    We need to transport the server binding handle into a full fledged
    binding handle, and then let the full fledged binding handle take
    care of performing the requested operation.

Arguments:

    Message - Supplies the buffer to be freed.

--*/
{
    RPC_STATUS Status;

    Status = InsureRealBindingHandle();
    ASSERT(Status == RPC_S_OK);
    RealBindingHandle->FreeBuffer(Message);
}


RPC_STATUS
SVR_BINDING_HANDLE::BindingCopy (
    OUT BINDING_HANDLE * PAPI * DestinationBinding,
    IN unsigned int MaintainContext
    )
/*++

Routine Description:

    We need to copy this binding handle.  This is relatively easy to
    do: we just need to duplicate the binding information and construct
    another server binding handle.

Arguments:

    DestinationBinding - Returns a copy of this binding handle.

    MaintainContext - Supplies a flag that indicates whether or not context
        is being maintained over this binding handle.  A non-zero value
        indicates that context is being maintained.

Return Value:

    RPC_S_OUT_OF_MEMORY - This indicates that there is not enough memory
        to allocate a new binding handle.

    RPC_S_OK - We successfully copied this binding handle.

--*/
{
    SVR_BINDING_HANDLE * Binding;
    DCE_BINDING * DceBinding;
    RPC_STATUS Status;

    if (RealBindingHandle != 0)
        return(RealBindingHandle->BindingCopy(DestinationBinding,
                MaintainContext));

    // Even if the binding is really dynamic, the endpoint has
    // been added to the DceBinding in the constructor.

    DceBinding = this->DceBinding->DuplicateDceBinding();
    if (DceBinding == 0)
        {
        *DestinationBinding = 0;
        return(RPC_S_OUT_OF_MEMORY);
        }

    Binding = new SVR_BINDING_HANDLE(DceBinding,0, &Status);
    *DestinationBinding = Binding;
    if (Binding == 0)
        return(RPC_S_OUT_OF_MEMORY);
    return(RPC_S_OK);
}


RPC_STATUS
SVR_BINDING_HANDLE::BindingFree (
    )
/*++

Routine Description:

    The application wants to free this binding handle.  If there is a real
    binding handle, we need to invoke BindingFree on it as well; otherwise,
    all we have got to do is to delete it.

Return Value:

    RPC_S_OK - This value will be returned, unless an error occurs in the
        BindingFree operation invoked on the real binding handle.

--*/
{
    RPC_STATUS Status;

    if (RealBindingHandle != 0)
        {
        Status = RealBindingHandle->BindingFree();
        RealBindingHandle = 0;
        if (Status != RPC_S_OK)
            return(Status);
        }

    delete this;
    return(RPC_S_OK);
}


RPC_STATUS
SVR_BINDING_HANDLE::ToStringBinding (
    OUT RPC_CHAR PAPI * PAPI * StringBinding
    )
/*++

Routine Description:

    We need to convert the binding handle into a string binding.  We
    can just use the information in this server binding handle to
    create the string binding.

Arguments:

    StringBinding - Returns the string representation of the binding
        handle.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_MEMORY - We do not have enough memory available to
        allocate space for the string binding.

--*/
{
    if (RealBindingHandle != 0)
        return(RealBindingHandle->ToStringBinding(StringBinding));

     *StringBinding = DceBinding->StringBindingCompose(
            InqPointerAtObjectUuid());
    if (*StringBinding == 0)
        return(RPC_S_OUT_OF_MEMORY);
    return(RPC_S_OK);
}


RPC_STATUS
SVR_BINDING_HANDLE::ToStaticStringBinding (
    OUT RPC_CHAR PAPI * PAPI * StringBinding
    )
/*++

Routine Description:

    We need to convert the binding handle into a string binding.  We
    can just use the information in this server binding handle to
    create the string binding.

Arguments:

    StringBinding - Returns the string representation of the binding
        handle.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_MEMORY - We do not have enough memory available to
        allocate space for the string binding.

--*/
{
    RPC_STATUS Status;
    RPC_CHAR __RPC_FAR * CopiedStringBinding;
    RPC_UUID *MyUuid = 0;
    DCE_BINDING *MyDceBinding;

    if (RealBindingHandle != 0)
        {
        Status = RealBindingHandle->ToStringBinding(StringBinding);
        if (Status != RPC_S_OK)
            {
            return Status;
            }

        if (EndpointIsDynamic == 0)
            {
            return RPC_S_OK;
            }
    
        // 
        // The endpoint is dynamic, need to strip it out
        //
        CopiedStringBinding = (RPC_CHAR *)
              _alloca( (RpcpStringLength(StringBinding)+1)*(sizeof(RPC_CHAR)) );
        if (CopiedStringBinding == 0)
            {
            return (RPC_S_OUT_OF_MEMORY);
            }
        RpcpStringCopy(CopiedStringBinding, StringBinding);
        
        MyDceBinding = new DCE_BINDING(CopiedStringBinding,&Status);
    
        if ( MyDceBinding == 0 )
            {
            return(RPC_S_OUT_OF_MEMORY);
            }
        
        if ( Status != RPC_S_OK )
            {
            delete MyDceBinding;
            return(Status);
            }
        }
    else
        {
        MyUuid = InqPointerAtObjectUuid();
        MyDceBinding = DceBinding;
        }

    *StringBinding = MyDceBinding->StringBindingCompose(
                                                        MyUuid, 
                                                        EndpointIsDynamic);

    if (DceBinding != MyDceBinding)
        {
        delete MyDceBinding;
        }

    if (*StringBinding == 0)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    return(RPC_S_OK);
}


RPC_STATUS
SVR_BINDING_HANDLE::InquireDynamicEndpoint (
    OUT RPC_CHAR PAPI * PAPI * DynamicEndpoint
    )
/*++

Routine Description:

    This routine is used to obtain the dynamic endpoint from a binding
    handle which was created from an rpc address.  If there is a dynamic
    endpoint, we just need to duplicate it, and return a pointer to it.

Arguments:

    DynamicEndpoint - Returns a pointer to the dynamic endpoint, it is
        always set to zero.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_MEMORY - Unable to allocate memory for the endpoint string.

--*/
{
    if (EndpointIsDynamic == 1 && DceBinding)
        {
        *DynamicEndpoint = DuplicateStringPAPI(DceBinding->InqEndpoint());
        if (*DynamicEndpoint == 0)
            return(RPC_S_OUT_OF_MEMORY);
        }
    else
        {
        *DynamicEndpoint = 0;
        }
    return(RPC_S_OK);
}


RPC_STATUS
SVR_BINDING_HANDLE::PrepareBindingHandle (
    IN TRANS_INFO *  TransportInterface,
    IN DCE_BINDING * DceBinding
    )
{
    UNUSED(this);
    UNUSED(TransportInterface);
    UNUSED(DceBinding);

    ASSERT( 0 );
    return RPC_S_OK;
}

RPC_STATUS
SVR_BINDING_HANDLE::ResolveBinding (
    IN PRPC_CLIENT_INTERFACE RpcClientInterface
    )
{
    RPC_STATUS Status;

    Status = InsureRealBindingHandle();
    if (Status != RPC_S_OK)
        return (Status);
    return(RealBindingHandle->ResolveBinding(RpcClientInterface));
}

RPC_STATUS
SVR_BINDING_HANDLE::BindingReset (
    )
{
    RPC_STATUS Status;

    Status = InsureRealBindingHandle();
    if (Status != RPC_S_OK)
        return(Status);
    Status = RealBindingHandle->BindingReset();
    if (Status == RPC_S_OK)
        {
        EndpointIsDynamic = 0;
        }
    return (Status);
}


RPC_STATUS
SVR_BINDING_HANDLE::InquireTransportType(
    OUT unsigned int PAPI *Type
    )
{
    RPC_STATUS Status;

    Status = InsureRealBindingHandle();
    if (Status != RPC_S_OK)
        return(Status);
    return(RealBindingHandle->InquireTransportType(Type));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\swmr.cxx ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    SWMR.cxx

Abstract:

    Implementation of Single Writer Multiple Readers lock.

Author:

    Kamen Moutafov    [KamenM]

Revision History:

    KamenM      Aug 2000    Created

Notes:
    Mechanism: Single Writer Multiple Reader Lock (SWMRLock)
    Design Goals: 
        1. Low resource usage for unused locks (i.e. one
        is embedded in each context handle) in the common case.
        2. Fairness in dispatching, including conversions from
        shared to exclusive and vice versa.
        3. Decent performance in the common case.
        4. Efficient handling of convoys
        5. Ability to claim the lock from one thread and release
        it from another.
    Design non-goals:
        1. Good throughput when multiple threads claim the lock.

    Description:
        The SWMRLock contains one mini spin lock, and a queue
        of waiters. The spin lock is used to synchronize few
        enqueue/dequeue operations. The queue is used to keep
        all claimants of the lock, and to wake up the next
        waiter when necessary.

    Scenarios:
        1. Multiple synchronized sync callers (writers). They will 
        borrow the thread event, and will make two interlocks to 
        get it.
        2. Multiple non-synchronized sync/async callers (readers). 
        They will use the cached waiter - 0 events, two interlocks 
        to get it.
        3. Multiple non-synchronized sync/async callers (readers) 
        followed by one synchronzied sync caller (writer). All readers
        will use the cached waiter, and the sync writer who destroys
        the context handle will borrow the thread event.

    Data Structures:
        Generic state:
                    *****************
                    *               *
                    *    SWMRLock   *
                    *               *
                    *****************
                       |        |
           FirstWaiter |        |   LastWaiter & ~StateMask
           +-----------+        +-------------------+
           |                                        |
           |                                        |
           V                                        V
    /////////////////                       /////////////////////
    /               /  Next          Next   /                   /
    /   SWMRWaiter  / -----> ...   -------->/    SWMRWaiter     /
    /               /                       /                   /
    /////////////////                       /////////////////////

        Scenario 1:
                    *****************
                    *               *
                    *    SWMRLock   *
                    *               *
                    *****************
                       |        |
           FirstWaiter |        |   LastWaiter & ~StateMask (LastWaiter = Pointer | LastWriter)
           +-----------+        +-------------------+
           |                                        |
           |                                        |
           V                                        V
    /////////////////                       /////////////////////
    /               /                       /                   /
    /     Writer    /                       /       Writer      /
    /               /                       /                   /
    / Flags:        /                       / Flags:            /
    /  swmrwtWriter /                       /  swmrwtWriter     /
    /  | OwnLock    /                       /                   /
    / RefCount: 1   /  Next          Next   / RefCount: 1       /
    / Next:         / -----> ...   -------->/ Next: NULL        /
    / hEvent: EVENT /                       / hEvent: EVENT     /
    /  or NULL      /                       /                   /
    /               /                       /                   /
    /////////////////                       /////////////////////

        Scenario 2:
                    *****************
                    *               *
                    *    SWMRLock   *
                    *               *
                    *****************
                       |
                       | FirstWaiter
                       | == LastWaiter (LastWaiter = Pointer | LastReader)
                       |
                       |
                       |
                       V
                /////////////////
                /               /
                /     Reader    /
                /               /
                / Flags:        /
                /  swmrwtReader /
                /  | OwnLock    /
                / RefCount: N   /
                / Next: NULL    /
                / hEvent: NULL  /
                /               /
                /////////////////

        Scenario 3:
                    *****************
                    *               *
                    *    SWMRLock   *
                    *               *
                    *****************
                       |        |
           FirstWaiter |        |   LastWaiter & ~StateMask (LastWaiter = Pointer | LastWriter)
           +-----------+        +-------------------+
           |                                        |
           |                                        |
           V                                        V
    /////////////////                       /////////////////////
    /               /                       /                   /
    /     Reader    /                       /       Writer      /
    /               /                       /                   /
    / Flags:        /                       / Flags:            /
    /  swmrwtReader /                       /  swmrwtWriter     /
    /  | OwnLock    /                       /                   /
    / RefCount: N   /         Next          / RefCount: 1       /
    / Next:         / --------------------->/ Next: NULL        /
    / hEvent: EVENT /                       / hEvent: EVENT     /
    /  or NULL      /                       /                   /
    /               /                       /                   /
    /////////////////                       /////////////////////

--*/

// undef this to get unit tests for SWMR
// #define _TEST_SWMR_

#include <precomp.hxx>

#if defined(_TEST_SWMR_)
extern "C" {
#include <rpcperf.h>
#include <rpcrt.h>

void Test (void);
extern long Clients;
}

HANDLE ProcessHeap;

void *
__cdecl
operator new (
    IN size_t size
    )
{
    return(RtlAllocateHeap(ProcessHeap, 0, size));
}

void
__cdecl
operator delete (
    IN void * obj
    )
{
    RtlFreeHeap(ProcessHeap, 0, obj);
}


#define _NOT_COVERED_ (0)
#endif

#include <swmr.hxx>

void
SpinOrYield (
    IN OUT BOOL *fNonFirstIteration,
    IN SWMRWaiterQueue *Queue
    )
{
    int i;

#if defined(_TEST_SWMR_)
    if ((2 > 1) && (*fNonFirstIteration == FALSE))
#else
    if ((gNumberOfProcessors > 1) && (*fNonFirstIteration == FALSE))
#endif
        {
        for (i = 0; i < 2000; i ++)
            {
            if (Queue->GetLastWaiterState() == SWMRWaiterQueue::Free)
                return;
            }
        }
    else
        {
        Sleep (10);
        }

    *fNonFirstIteration = TRUE;
}

#if defined(_TEST_SWMR_)
long TestCounter = 0;
#endif

SWMRWaiter *
SWMRLock::AllocateWaiter (
    IN SWMRWaiterType WaiterType,
    IN BOOL fEventRequired
    )
/*++

Routine Description:

    Allocates a waiter. First, it tries the cache. If this
    fails, it does the allocation.

Arguments:
    WaiterType - whether the needed waiter is a reader or writer
    fEventRequired - if non-FALSE, the event is required and must
    be allocated before return. Otherwise, the event may not be allocated

Return Value:
    The new waiter. If NULL, either a waiter could not be allocated or its
    event couldn't be initialized.

--*/
{
    SWMRWaiter *NewWaiter;
    RPC_STATUS RpcStatus;

    if (CachedWaiterAvailable)
        {
        if (InterlockedCompareExchange(&CachedWaiterAvailable, 0, 1) == 1)
            {
            RpcStatus = CachedWaiter.Initialize(WaiterType, fEventRequired);
            if (RpcStatus != RPC_S_OK)
                return NULL;
            return &CachedWaiter;
            }
        }

    NewWaiter = new SWMRWaiter;
    if (NewWaiter)
        {
        RpcStatus = NewWaiter->Initialize(WaiterType, fEventRequired);
        if (RpcStatus != RPC_S_OK)
            {
            delete NewWaiter;
            NewWaiter = NULL;
            }
        }
    return NewWaiter;
}

void
SWMRLock::FreeWaiter (
    IN SWMRWaiter *Waiter
    )
/*++

Routine Description:

    Frees a waiter.

Arguments:
    Waiter - the waiter to be freed. This cannot be the cached waiter.

Return Value:

--*/
{
    ASSERT(Waiter);

    Waiter->FreeWaiterData();

    delete Waiter;
}

void
SWMRLock::StoreOrFreeSpareWaiter (
    IN OUT SWMRWaiter **WaiterCache OPTIONAL,
    IN SWMRWaiter *Waiter OPTIONAL
    )
/*++

Routine Description:

    Given an optional waiter cache, this code decides what
    to do with a waiter that is no longer used. The policy is
    as follows:
    If the waiter is NULL, return.
    If the waiter is the cached waiter, mark the cached waiter
    as available.
    If it is not the cached waiter, and there is a waiter cache
    passed, store the waiter.
    Else, free the waiter.

Arguments:
    WaiterCache - The waiter cache.
    Waiter - waiter to be freed.

Return Value:

--*/
{
    if (Waiter)
        {
        if (Waiter != &CachedWaiter)
            {
            if (WaiterCache && (*WaiterCache == NULL))
                {
                *WaiterCache = Waiter;
                }
            else
                {
                FreeWaiter(Waiter);
                }
            }
        else
            {
            ASSERT(CachedWaiterAvailable == 0);
            InterlockedExchange(&CachedWaiterAvailable, 1);
            }
        }
}

void
SWMRLock::LockSharedOnLastReader (
    IN OUT SWMRWaiter **WaiterCache OPTIONAL,
    IN OUT SWMRWaiter *OldWaiter,
    IN OUT SWMRWaiter *AllocatedWaiter
    )
/*++

Routine Description:

    Does the locking for shared access if the last waiter is a reader

Arguments:
    WaiterCache - See WaiterCache in LockSharedOrExclusive
    OldWaiter - the OldWaiter obtained when the lock was taken
    AllocatedWaiter - new waiter available for use. In this case,
    we only free it.

Return Value:

Notes:
    The function is called with the lock held. It must release the lock
        as soon as it can.

--*/
{
    SWMRWaiter *LastWaiter;

    // here we know we're adding a reader to waiting readers
    LastWaiter = RemoveReaderStateFromWaiterPtr(OldWaiter);

    ASSERT((LastWaiter->Flags & SWMRWaiter::WaiterTypeMask) == swmrwtReader);
    ASSERT(LastWaiter->Next == NULL);
    ASSERT(LastWaiter->RefCount >= 1);

    LastWaiter->RefCount ++;
    if ((LastWaiter->Flags & SWMRWaiter::OwnLockMask) == 0)
        {
        UnlockAndCommit(OldWaiter);

        // if we have created a waiter, try to cache it or free it
        StoreOrFreeSpareWaiter(WaiterCache, AllocatedWaiter);

        // the last waiter on the queue doesn't own the lock -
        // wait on it. We know the block can't go away because
        // we have added our refcount. On return, we will
        // own the lock
        ASSERT(LastWaiter->hEvent);

        WaitForSingleObject(LastWaiter->hEvent, INFINITE);
        }
    else
        {
        UnlockAndCommit(OldWaiter);

        // if we have created a waiter, try to cache it or free it
        StoreOrFreeSpareWaiter(WaiterCache, AllocatedWaiter);
        }
}

void
SWMRLock::LockSharedOrExclusiveOnLastWriter (
    IN OUT SWMRWaiter **WaiterCache OPTIONAL,
    IN OUT SWMRWaiter *OldWaiter,
    IN OUT SWMRWaiter *AllocatedWaiter,
    IN ULONG_PTR DesiredState
    )
/*++

Routine Description:

    Does the locking for both shared and exclusive access if the last waiter 
    is a writer

Arguments:
    WaiterCache - See WaiterCache in LockSharedOrExclusive
    OldWaiter - the OldWaiter obtained when the lock was taken
    AllocatedWaiter - new waiter available for use. In this case,
    we only free it.
    DesiredState - the state of the new last waiter

Return Value:

Notes:
    The function is called with the lock held. It must release the lock
        as soon as it can.

--*/
{
    SWMRWaiter *LastWaiter;

    ASSERT(AllocatedWaiter != NULL);

    // here we know we're adding a reader to writer
    LastWaiter = RemoveWriterStateFromWaiterPtr(OldWaiter);

    ASSERT((LastWaiter->Flags & SWMRWaiter::WaiterTypeMask) == swmrwtWriter);
    ASSERT(LastWaiter->Next == NULL);
    ASSERT(LastWaiter->RefCount == 1);
    ASSERT(LastWaiter != AllocatedWaiter);

    LastWaiter->Next = AllocatedWaiter;

    LastWaiter = SetStateInWaiterPtr(AllocatedWaiter, DesiredState);
    UnlockAndCommit(LastWaiter);

    if (WaiterCache)
        *WaiterCache = NULL;

    // Wait for it. On return, we will own the lock
    ASSERT(AllocatedWaiter->hEvent);

    WaitForSingleObject(AllocatedWaiter->hEvent, INFINITE);
}

void
SWMRLock::LockExclusiveOnLastReader (
    IN OUT SWMRWaiter **WaiterCache OPTIONAL,
    IN OUT SWMRWaiter *OldWaiter,
    IN OUT SWMRWaiter *AllocatedWaiter
    )
/*++

Routine Description:

    Does the locking for exclusive access if the last waiter is a reader

Arguments:
    WaiterCache - See WaiterCache in LockSharedOrExclusive
    OldWaiter - the OldWaiter obtained when the lock was taken
    AllocatedWaiter - new waiter available for use. In this case,
    we only free it.

Return Value:

Notes:
    The function is called with the lock held. It must release the lock
        as soon as it can.

--*/
{
    SWMRWaiter *LastWaiter;

    ASSERT(AllocatedWaiter != NULL);

    // here we know we're adding a writer to a reader
    LastWaiter = RemoveReaderStateFromWaiterPtr(OldWaiter);

    ASSERT((LastWaiter->Flags & SWMRWaiter::WaiterTypeMask) == swmrwtReader);
    ASSERT(LastWaiter->Next == NULL);
    ASSERT(LastWaiter->RefCount >= 1);
    ASSERT(LastWaiter != AllocatedWaiter);

    LastWaiter->Next = AllocatedWaiter;

    LastWaiter = AddWriterStateInWaiterPtr(AllocatedWaiter);
    UnlockAndCommit(LastWaiter);

    if (WaiterCache)
        *WaiterCache = NULL;

    // Wait for it. On return, we will own the lock
    ASSERT(AllocatedWaiter->hEvent);
    WaitForSingleObject(AllocatedWaiter->hEvent, INFINITE);
}

RPC_STATUS 
SWMRLock::LockSharedOrExclusive (
    IN OUT SWMRWaiter **WaiterCache OPTIONAL,
    IN SWMRWaiterType WaiterType,
    IN ULONG_PTR DesiredState
    )
/*++

Routine Description:

    Worker function that does most of the work association
    with claiming a lock for shared or exclusive access. In fact,
    it does all the work apart from hanlding a reader after writer,
    reader after reader, writer after reader and writer after writer

Arguments:
    WaiterCache - An optional parameter allowing caching of waiter blocks.
        If WaiterCache == NULL, no caching will be done.
        If WaiterCache != NULL, but *WaiterCache == NULL, *WaiterCache
        may be set to the new Waiter block. If *WaiterCache != NULL,
        the cached value will be used. Its hEvent may or may not be set. If
        not set and needed, this routine may fill it in.
    WaiterType - the type of the caller. If this is swmrwtReader, DesiredState
        must be LastReader and vice versa. If this is swmrwtWriter, DesiredState
        must ve LastWriter and vice versa. We could have done with one argument
        only, except we want to save one if.
    DesiredState - LastReader or LastWriter

Return Value:
    RPC_S_OK or RPC_S_* for error

--*/
{
    ULONG_PTR LastWaiterState;
    SWMRWaiter *Waiter;
    SWMRWaiter *OldWaiter;
    SWMRWaiter *LastWaiter;
    BOOL fNonFirstIteration = FALSE;
    RPC_STATUS RpcStatus;

    ASSERT((DesiredState == LastReader) || (DesiredState == LastWriter));
    if (DesiredState == LastReader)
        {
        ASSERT(WaiterType == swmrwtReader);
        }
    else
        {
        ASSERT(WaiterType == swmrwtWriter);
        }

    if (WaiterCache)
        {
        Waiter = *WaiterCache;
        if (Waiter)
            {
            *WaiterCache = NULL;
            Waiter->Initialize(WaiterType, FALSE);
            }
        }
    else
        {
        Waiter = NULL;
        }

    while (TRUE)
        {
        // on entry to this loop:
        // Waiter may be NULL, or non-NULL. If non-NULL,
        // its RefCount, Next and WaiterType are
        // initialized. If hEvent is non-NULL, it must
        // be valid too. (Flags & OwnLockMask) is 0

        if (Waiter)
            {
            ASSERT((Waiter->Flags & SWMRWaiter::OwnLockMask) == 0);
            }

        LastWaiterState = GetLastWaiterState();

        switch (LastWaiterState)
            {
            case Free:
                if (!Waiter)
                    {
                    Waiter = AllocateWaiter(WaiterType, FALSE);
                    if (!Waiter)
                        {
                        return RPC_S_OUT_OF_MEMORY;
                        }
                    }

                // we know we have a waiter here
                OldWaiter = Lock();
                if (!VerifyState(OldWaiter, Free))
                    {
                    UnlockAndCommit(OldWaiter);
                    // the state has changed while we were switching - loop around
                    continue;
                    }      

                Waiter->Flags |= SWMRWaiter::OwnLock;

                SetFirstWaiter(Waiter);
                LastWaiter = SetStateInWaiterPtr(Waiter, DesiredState);
                UnlockAndCommit(LastWaiter);

                if (WaiterCache)
                    *WaiterCache = NULL;

                if (WaiterType == swmrwtWriter)
                    SetLastWriterThreadId();

                return RPC_S_OK;

                // no break necessary
                // break;

            case LastReader:
                if (WaiterType == swmrwtReader)
                    {
                    OldWaiter = Lock();
                    if (!VerifyState(OldWaiter, LastReader))
                        {
                        UnlockAndCommit(OldWaiter);
                        // the state has changed while we were switching - loop around
                        continue;
                        }

                    LockSharedOnLastReader(WaiterCache, OldWaiter, Waiter);

                    // cache is consumed or freed after LockSharedOnLastReader 

                    LastWaiter = RemoveReaderStateFromWaiterPtr(OldWaiter);
                    }
                else
                    {
                    if (!Waiter)
                        {
                        Waiter = AllocateWaiter(WaiterType, TRUE);
                        if (!Waiter)
                            {
                            return RPC_S_OUT_OF_MEMORY;
                            }
                        }
                    else
                        {
                        RpcStatus = Waiter->InitializeEventIfNecessary();
                        if (RpcStatus != RPC_S_OK)
                            {
                            StoreOrFreeSpareWaiter(WaiterCache, Waiter);
                            return RpcStatus;
                            }
                        }

                    OldWaiter = Lock();
                    if (!VerifyState(OldWaiter, LastReader))
                        {
                        UnlockAndCommit(OldWaiter);
                        // the state has changed while we were switching - loop around
                        continue;
                        }

                    LockExclusiveOnLastReader(WaiterCache,
                        OldWaiter,
                        Waiter);

                    // the cache has been consumed and indicated as such

                    LastWaiter = Waiter;
                    SetLastWriterThreadId();
                    }

                // on return, we must own the lock
                ASSERT((LastWaiter->Flags & SWMRWaiter::OwnLockMask) == SWMRWaiter::OwnLock);

                SetFirstWaiter(LastWaiter);

                return RPC_S_OK;

                // break is not needed
                // break;

            case LastWriter:
                // the lock is owned by a writer - we must queue ourselves.
                // For this, we need a waiter block
                if (!Waiter)
                    {
                    Waiter = AllocateWaiter(WaiterType,
                        TRUE);
                    if (!Waiter)
                        {
                        return RPC_S_OUT_OF_MEMORY;
                        }
                    }
                else
                    {
                    RpcStatus = Waiter->InitializeEventIfNecessary();
                    if (RpcStatus != RPC_S_OK)
                        {
                        StoreOrFreeSpareWaiter(WaiterCache, Waiter);
                        return RpcStatus;
                        }
                    }

                OldWaiter = Lock();
                if (!VerifyState(OldWaiter, LastWriter))
                    {
                    UnlockAndCommit(OldWaiter);
                    // the state has changed while we were switching - loop around
                    continue;
                    }

                LockSharedOrExclusiveOnLastWriter(WaiterCache,
                    OldWaiter,
                    Waiter,
                    DesiredState);

                // the cache has been consumed and indicated as such

                // on return, we must own the lock
                ASSERT((Waiter->Flags & SWMRWaiter::OwnLockMask) == SWMRWaiter::OwnLock);

                SetFirstWaiter(Waiter);

                if (WaiterType == swmrwtWriter)
                    SetLastWriterThreadId();

                return RPC_S_OK;

                // no need for break
                // break

            case Locked:
                SpinOrYield(&fNonFirstIteration, this);
                break;

            // no need for default
            // default:
            }
        }
}

void
SWMRLock::UnlockShared (
    IN OUT SWMRWaiter **WaiterCache OPTIONAL
    )
/*++

Routine Description:

    Releases a lock obtained for shared access.

Arguments:
    WaiterCache - An optional parameter allowing caching of waiter blocks.
        If WaiterCache == NULL, no caching will be done.
        If WaiterCache != NULL, but *WaiterCache == NULL, *WaiterCache
        may be set to the new Waiter block. If *WaiterCache != NULL,
        and a waiter block is produces as a result of the operation, it will
        be freed.

Return Value:

--*/
{
    SWMRWaiter *OldWaiter;
    SWMRWaiter *FirstWaiter;
    long NewRefCount;
    SWMRWaiter *Next;
    HANDLE hEvent;

    FirstWaiter = GetFirstWaiter();
    ASSERT(FirstWaiter != NULL);

    OldWaiter = Lock();

    NewRefCount = -- FirstWaiter->RefCount;

    if (NewRefCount == 0)
        {
        Next = FirstWaiter->Next;
        if (Next)
            {
            Next->Flags |= SWMRWaiter::OwnLock;
            hEvent = Next->hEvent;
            ASSERT(hEvent);

            ASSERT((Next->Flags & SWMRWaiter::WaiterTypeMask) == swmrwtWriter);

            SetFirstWaiter(Next);

            UnlockAndCommit(OldWaiter);
            StoreOrFreeSpareWaiter(WaiterCache, FirstWaiter);
            SetEvent(hEvent);
            }
        else
            {
            UnlockAndCommit(NULL);
            StoreOrFreeSpareWaiter(WaiterCache, FirstWaiter);
            }
        }
    else
        {
        UnlockAndCommit(OldWaiter);
        }
}

void
SWMRLock::UnlockExclusive (
    IN OUT SWMRWaiter **WaiterCache OPTIONAL
    )
/*++

Routine Description:

    Releases a lock obtained for exclusive access.

Arguments:
    WaiterCache - An optional parameter allowing caching of waiter blocks.
        If WaiterCache == NULL, no caching will be done.
        If WaiterCache != NULL, but *WaiterCache == NULL, *WaiterCache
        may be set to the new Waiter block. If *WaiterCache != NULL,
        and a waiter block is produces as a result of the operation, it will
        be freed.

Return Value:

--*/
{
    SWMRWaiter *OldWaiter;
    SWMRWaiter *FirstWaiter;
    SWMRWaiter *Next;

    FirstWaiter = GetFirstWaiter();
    ASSERT(FirstWaiter != NULL);

    OldWaiter = Lock();

    Next = FirstWaiter->Next;
    if (Next)
        {
        Next->Flags |= SWMRWaiter::OwnLock;

        SetFirstWaiter(Next);

        UnlockAndCommit(OldWaiter);
        StoreOrFreeSpareWaiter(WaiterCache, FirstWaiter);
        ASSERT(Next->hEvent);
        SetEvent(Next->hEvent);
        }
    else
        {
        UnlockAndCommit(NULL);
        StoreOrFreeSpareWaiter(WaiterCache, FirstWaiter);
        }
}

void
SWMRLock::Unlock (
    IN OUT SWMRWaiter **WaiterCache OPTIONAL
    )
/*++

Routine Description:

    Releases a lock obtained for any access.

Arguments:
    WaiterCache - An optional parameter allowing caching of waiter blocks.
        If WaiterCache == NULL, no caching will be done.
        If WaiterCache != NULL, but *WaiterCache == NULL, *WaiterCache
        may be set to the new Waiter block. If *WaiterCache != NULL,
        and a waiter block is produces as a result of the operation, it will
        be freed.

Return Value:

--*/
{
    SWMRWaiter *OldWaiter;
    SWMRWaiter *FirstWaiter;
    SWMRWaiter *Next;

    FirstWaiter = GetFirstWaiter();
    ASSERT(FirstWaiter != NULL);

    if ((FirstWaiter->Flags & SWMRWaiter::WaiterTypeMask) == swmrwtReader)
        {
        UnlockShared(WaiterCache);
        }
    else
        {
        ASSERT((FirstWaiter->Flags & SWMRWaiter::WaiterTypeMask) == swmrwtWriter);
        UnlockExclusive(WaiterCache);
        }
}

RPC_STATUS
SWMRLock::ConvertToExclusive (
    IN OUT SWMRWaiter **WaiterCache OPTIONAL
    )
/*++

Routine Description:

    Converts a shared lock to exclusive. In the process it *does not*
    release the shared lock (except for case described below in Return Value).
    This means that it is legal for the caller
    to walk a list in shared mode, then decide to delete an element
    and convert it to exclusive. If it gets ERROR_MORE_WRITES, it has the lock,
    but a writer may have intervened and any data structure protected by the lock
    may have been modified. In this case the thread must protect itself 
    appropriately. If it gets RPC_S_OK then there is no danger of other writers 
    coming in and changing the data structure in any way

Arguments:
    WaiterCache - An optional parameter allowing caching of waiter blocks.
        If WaiterCache == NULL, no caching will be done.
        If WaiterCache != NULL, but *WaiterCache == NULL, *WaiterCache
        may be set to the new Waiter block. If *WaiterCache != NULL,
        the cached value will be used. Its hEvent must be set

Return Value:
    RPC_S_OK or RPC_S_* for error. If RPC_S_CANNOT_SUPPORT is returned,
    this means the lock is already owned exclusively. It is safe
    for multiple threads to try to convert the same lock ownership to exclusive.
    The only peculiarity is that if two threads try to get convert the same reader
    lock to exclusive, one has to lose the reader lock, and it will get 
    ERROR_MORE_WRITES. The other will get RPC_S_OK, and it knows it hasn't lost
    the reader lock.

--*/
{
    SWMRWaiter *CurrentOwner = GetFirstWaiter();
    SWMRWaiter *OldWaiter;
    SWMRWaiter *LastWaiter;
    SWMRWaiter *AllocatedWaiter = NULL;
    RPC_STATUS RpcStatus;
    SWMRWaiter *NextOwner;

    // make sure the current lock is not already in exclusive mode
    if ((CurrentOwner->Flags & SWMRWaiter::WaiterTypeMask) == swmrwtWriter)
        {
        return RPC_S_CANNOT_SUPPORT;
        }

    while (TRUE)
        {

        ASSERT(CurrentOwner->RefCount > 0);

        if (CurrentOwner->RefCount == 1)
            {
            OldWaiter = Lock();

            if (CurrentOwner->RefCount == 1)
                {
                NextOwner = CurrentOwner->Next;
                // if there is next, it's flags are either swmrwtReader, swmrwtWriter,
                // or swmrwtWriter | WriterInsertedBefore
                if (NextOwner)
                    {
                    ASSERT(
                            (NextOwner->Flags == swmrwtReader)
                            || (NextOwner->Flags == swmrwtWriter)
                            || (NextOwner->Flags == (swmrwtWriter | SWMRWaiter::WriterInsertedBefore))
                          );

                    // we need to raise the flag only for next writers who don't have the flag raised
                    if (NextOwner->Flags == swmrwtWriter)
                        {
                        NextOwner->Flags = swmrwtWriter | SWMRWaiter::WriterInsertedBefore;
                        }
                    }
                CurrentOwner->Flags = swmrwtWriter | SWMRWaiter::OwnLock;
                LastWaiter = RemoveStateFromWaiterPtr(OldWaiter);
                if (LastWaiter == CurrentOwner)
                    {
                    LastWaiter = AddWriterStateInWaiterPtr(LastWaiter);
                    UnlockAndCommit(LastWaiter);
                    }
                else
                    {
                    UnlockAndCommit(OldWaiter);
                    }

                // if we have spun around, and a waiter has been allocated,
                // make sure it is freed
                StoreOrFreeSpareWaiter(WaiterCache, AllocatedWaiter);

                SetLastWriterThreadId();

                // get out of the loop
                break;
                }

            // somebody beat us to the punch. Just unlock and loop around
            UnlockAndCommit(OldWaiter);

            }
        else
            {
            // there are multiple readers on this waiter. We need to allocate
            // a new block to wait on.
            if (!AllocatedWaiter)
                {
                if (WaiterCache)
                    {
                    AllocatedWaiter = *WaiterCache;
                    if (AllocatedWaiter)
                        {
                        *WaiterCache = NULL;
                        RpcStatus = AllocatedWaiter->Initialize(swmrwtWriter, TRUE);
                        if (RpcStatus != RPC_S_OK)
                            {
                            *WaiterCache = AllocatedWaiter;
                            return RpcStatus;
                            }
                        }
                    }

                // if we there was no cache, or we found nothing in the cache
                // create a waiter
                if (!AllocatedWaiter)
                    {
                    AllocatedWaiter = AllocateWaiter(swmrwtWriter, TRUE);
                    if (!AllocatedWaiter)
                        {
                        return RPC_S_OUT_OF_MEMORY;
                        }
                    }
                }
            else
                {
                RpcStatus = AllocatedWaiter->InitializeEventIfNecessary();
                if (RpcStatus != RPC_S_OK)
                    {
                    StoreOrFreeSpareWaiter(WaiterCache, AllocatedWaiter);
                    return RpcStatus;
                    }
                }

            OldWaiter = Lock();
            if (CurrentOwner->RefCount > 1)
                {
                // form a separate waiter block and queue it after the current
                // reader block
                AllocatedWaiter->Next = CurrentOwner->Next;
                CurrentOwner->Next = AllocatedWaiter;
                CurrentOwner->RefCount --;
                ASSERT(CurrentOwner->RefCount >= 1);
                ASSERT(CurrentOwner->Flags == (swmrwtReader | SWMRWaiter::OwnLock));
                LastWaiter = RemoveStateFromWaiterPtr(OldWaiter);

                // if we were the last waiter ...
                if (LastWaiter == CurrentOwner)
                    {
                    // ... update the last to point to us
                    LastWaiter = AddWriterStateInWaiterPtr(AllocatedWaiter);
                    UnlockAndCommit(LastWaiter);
                    }
                else
                    {
                    ASSERT (AllocatedWaiter->Next != NULL);
                    // if the next waiter is a writer, indicate to it
                    // that we have moved in before it. This allows
                    // arbitraging b/n multiple converts from shared
                    // to exclusive. Pure writers will ignore this flag
                    if (AllocatedWaiter->Next->Flags == swmrwtWriter)
                        {
                        AllocatedWaiter->Next->Flags = swmrwtWriter | SWMRWaiter::WriterInsertedBefore;
                        }
                    else
                        {
                        ASSERT((AllocatedWaiter->Next->Flags & SWMRWaiter::WaiterTypeMask) != swmrwtWriter);
                        }
                    // just unlock
                    UnlockAndCommit(OldWaiter);
                    }

                ASSERT(AllocatedWaiter->hEvent);
                WaitForSingleObject(AllocatedWaiter->hEvent, INFINITE);

                // we must own the lock here
                ASSERT((AllocatedWaiter->Flags == (SWMRWaiter::OwnLock | swmrwtWriter))
                    || (AllocatedWaiter->Flags == (SWMRWaiter::OwnLock | swmrwtWriter | SWMRWaiter::WriterInsertedBefore)));

                // indicate the cache has been consumed
                if (WaiterCache)
                    {
                    *WaiterCache = NULL;
                    }

                SetLastWriterThreadId();

                if (AllocatedWaiter->Flags 
                    == (SWMRWaiter::OwnLock | swmrwtWriter | SWMRWaiter::WriterInsertedBefore))
                    {
                    return ERROR_MORE_WRITES;
                    }
                else
                    {
                    return RPC_S_OK;
                    }
                }
            else
                {
                // this has become a single reader entry (us).
                // just convert it to a writer - release
                // the lock and loop around
                UnlockAndCommit(OldWaiter);
                }
            }
        }

    return RPC_S_OK;
}

RPC_STATUS
SWMRLock::ConvertToShared (
    IN OUT SWMRWaiter **WaiterCache OPTIONAL,
    IN BOOL fSyncCacheUsed
    )
/*++

Routine Description:

    Converts an exclusive lock to shared. In the process it *does not*
    release the shared lock. This means that it is legal for the caller
    to walk a list in exclusive mode, then decide to move to shared mode
    so that new readers can come in, and it is safe to assume that no
    new writer has intervened in the meantime.

Arguments:
    WaiterCache - An optional parameter allowing caching of waiter blocks.
        If WaiterCache == NULL, no caching will be done.
        If WaiterCache != NULL, but *WaiterCache == NULL, *WaiterCache
        may be set to the new Waiter block. If *WaiterCache != NULL,
        the cached value will be used. Its hEvent must be set
    fSyncCacheUsed - if a caller was using sync cache (i.e. a thread tied
        or a call tied cache), it may specify non-FALSE to this parameter
        to cause this function to allocate a new waiter block if the waiter
        block may be needed by other waiters.
        Note that whether the cache is sync depends on previous calls to
        LockShared/LockExclusive/ConvertToExclusive. If you don't have
        enough information to determine what those calls were using,
        always specify TRUE. This will always work. FALSE can be used
        as an additional optimization if we know the history of our waiter
        block.

Return Value:
    RPC_S_OK or RPC_S_* for error. If RPC_S_CANNOT_SUPPORT is returned,
    this means the lock is already owned in shared mode. It is safe
    for multiple threads to try to convert the same lock ownership to shared.

--*/
{
    SWMRWaiter *CurrentOwner = GetFirstWaiter();
    SWMRWaiter *OldWaiter;
    SWMRWaiter *LastWaiter;
    SWMRWaiter *AllocatedWaiter = NULL;
    SWMRWaiter *NextWaiter;
    HANDLE hEvent;

    // make sure the current lock is not already in shared mode
    if ((CurrentOwner->Flags & SWMRWaiter::WaiterTypeMask) == swmrwtReader)
        return RPC_S_CANNOT_SUPPORT;

    if (fSyncCacheUsed)
        {
        // you cannot claim that you use a sync cache if you don't have
        // any cache at all
        ASSERT(WaiterCache != NULL);
        }

    ASSERT(CurrentOwner->RefCount == 1);

    while (TRUE)
        {
        NextWaiter = CurrentOwner->Next;

        // we have three cases - last owner, non-last owner with following
        // readers and non-last owner with following writers
        if (NextWaiter == NULL)
            {
            // if a sync cache was used, we must return whatever we took
            // out of the cache, and recreate a waiter for the cache,
            // because we're going to become last readers, and other
            // readers may join, causing lifetime issues with our cached
            // entry if it is sync
            if (fSyncCacheUsed && (*WaiterCache == NULL) && (CurrentOwner != &CachedWaiter))
                {
                if (!AllocatedWaiter)
                    {
                    AllocatedWaiter = AllocateWaiter(swmrwtReader, FALSE);
                    if (!AllocatedWaiter)
                        {
                        return RPC_S_OUT_OF_MEMORY;
                        }
                    AllocatedWaiter->Flags = swmrwtReader | SWMRWaiter::OwnLock;
                    }

                LastWaiter = AddReaderStateInWaiterPtr(AllocatedWaiter);
                }
            else
                {
                LastWaiter = AddReaderStateInWaiterPtr(CurrentOwner);
                }

            OldWaiter = Lock();
            NextWaiter = CurrentOwner->Next;
            if (NextWaiter)
                {
                // somebody managed to queue a waiter before we converted -
                // unlock and loop around
                UnlockAndCommit(OldWaiter);
                }
            else
                {
                if (AllocatedWaiter)
                    {
                    // the first waiter has changed - update it
                    SetFirstWaiter(AllocatedWaiter);
                    }
                else
                    {
                    // update the flags of the old waiter
                    CurrentOwner->Flags = swmrwtReader | SWMRWaiter::OwnLock;
                    }

                UnlockAndCommit(LastWaiter);

                if (AllocatedWaiter)
                    {
                    ASSERT(CurrentOwner != &CachedWaiter);
                    // we were asked to free up a previous cached item
                    *WaiterCache = CurrentOwner;
                    }

                // break out of the loop
                break;
                }
            }
        else if ((NextWaiter->Flags & SWMRWaiter::WaiterTypeMask) == swmrwtReader)
            {
            // we need to take the lock to avoid races with threads
            // trying to queue themselves after the next waiter
            OldWaiter = Lock();

            // here we effectively join the next waiter and discard the current
            // waiter block. This allows
            // us to free the current item to the cache, ensuring good
            // performance for sync caches
            NextWaiter->Flags |= SWMRWaiter::OwnLock;
            NextWaiter->RefCount ++;
            hEvent = NextWaiter->hEvent;
            ASSERT(hEvent);

            SetFirstWaiter(NextWaiter);

            UnlockAndCommit(OldWaiter);

            SetEvent(hEvent);

            StoreOrFreeSpareWaiter(WaiterCache, CurrentOwner);
            StoreOrFreeSpareWaiter(WaiterCache, AllocatedWaiter);

            break;
            }
        else
            {
            ASSERT((NextWaiter->Flags == swmrwtWriter)
                || (NextWaiter->Flags == (swmrwtWriter | SWMRWaiter::WriterInsertedBefore)));

            // We must reset the flags. This is because there may be pending
            // WriterInsertedBefore. We want to clear this so that we don't
            // return ERROR_MORE_WRITES if they convert back to exclusive and
            // find this stale flag
            CurrentOwner->Flags = SWMRWaiter::OwnLock | swmrwtReader;

            StoreOrFreeSpareWaiter(WaiterCache, AllocatedWaiter);

            break;
            }
        }

    return RPC_S_OK;
}

#if defined(_TEST_SWMR_)
SWMRLock TestLock;

long TestCheck = 0;

HANDLE HoldEvent = NULL;
BOOL fHoldFlag = FALSE;
long HoldingThreadCount = 0;

DWORD WINAPI TestThreadProc (LPVOID )
{
    RPC_STATUS RpcStatus;
    long OldTestCheck;
    SWMRWaiter **WaiterCache;
    SWMRWaiter *CachedWaiter = NULL;
    int i, j;
    int RndNum;
    BOOL fReader;
    BOOL fSyncCache;

    RndNum = rand();
    if (RndNum % 2)
        {
        WaiterCache = NULL;
        }
    else
        {
        WaiterCache = &CachedWaiter;
        }

    RndNum = rand();
    // one out of 3 is writer
    if ((RndNum % 3) == 2)
        {
        fReader = FALSE;
        Dump("%d is a writer\n", GetCurrentThreadId());
        }
    else
        {
        fReader = TRUE;
        Dump("%d is a reader\n", GetCurrentThreadId());
        }

    for (; TestCounter < (signed)Iterations; )
        {
        if (fHoldFlag)
            {
            InterlockedIncrement(&HoldingThreadCount);
            WaitForSingleObject(HoldEvent, INFINITE);
            }

        if (fReader)
            {
            RpcStatus = TestLock.LockShared(WaiterCache);
            }
        else
            {
            RpcStatus = TestLock.LockExclusive(WaiterCache);
            }

        if (RpcStatus != RPC_S_OK)
            continue;

        // once in a while we will swap the reader to writer and vice versa
        if ((rand() % 17) == 0)
            {
            if (fReader)
                {
                // current reader. ConvertToExclusive. This can fail due to the
                // fault injection. Retry
                do
                    {
                    RpcStatus = TestLock.ConvertToExclusive(WaiterCache);
                    }
                while ((RpcStatus != RPC_S_OK) && (RpcStatus != ERROR_MORE_WRITES));
                fReader = FALSE;
                }
            else
                {
                if (WaiterCache)
                    {
                    fSyncCache = (rand() % 3) == 0;
                    }
                else
                    {
                    fSyncCache = FALSE;
                    }

                // current writer. ConvertToShared
                do
                    {
                    RpcStatus = TestLock.ConvertToShared(WaiterCache, fSyncCache);
                    }
                while (RpcStatus != RPC_S_OK);
                fReader = TRUE;
                }
            }

        if (fReader)
            {
            OldTestCheck = InterlockedIncrement(&TestCheck);
            ASSERT(OldTestCheck >= 1);
            if (OldTestCheck < 1)
                DebugBreak();
            }
        else
            {
            OldTestCheck = InterlockedCompareExchange(&TestCheck, 1, 0);
            ASSERT(OldTestCheck == 0);
            if (OldTestCheck != 0)
                DebugBreak();
            }

        TestCounter ++;

        if ((TestCounter % 100000) == 0)
            {
            // print something to screen
            Dump("%d: Test %ld\n", GetCurrentThreadId(), TestCounter);
            }

        for (i = 0; i < 50; i ++)
            {
            // random function call to prevent the compiler from
            // optimizing the loop away
            RndNum = GetCurrentThreadId();
            }

        if (fReader)
            {
            OldTestCheck = InterlockedDecrement(&TestCheck);
            ASSERT(OldTestCheck >= 0);
            if (OldTestCheck < 0)
                DebugBreak();
            }
        else
            {
            OldTestCheck = InterlockedCompareExchange(&TestCheck, 0, 1);
            if (OldTestCheck != 1)
                DebugBreak();
            ASSERT(OldTestCheck == 1);
            }

        if (fReader)
            {
            TestLock.UnlockShared(WaiterCache);
            }
        else
            {
            TestLock.UnlockExclusive(WaiterCache);
            }

        RndNum = rand() % 100;
        if (RndNum == 11)
            {
            Sleep(10);
            }
        }

    if (CachedWaiter)
        {
        TestLock.FreeWaiterCache(&CachedWaiter);
        }

    return 0;
}

void Test (void)
{
    int i;
    HANDLE hThread;
    int Retries;

    srand( GetTickCount() );
    HoldEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    ProcessHeap = GetProcessHeap();

    for (i = 0; i < Clients; i ++)
        {
        hThread = CreateThread(NULL, 0, TestThreadProc, NULL, 0, NULL);
        CloseHandle(hThread);
        }

    while (TRUE)
        {
        Sleep(rand());
        if (TestCounter >= (signed)Iterations)
            continue;

        Retries = 0;
        fHoldFlag = TRUE;
        while (HoldingThreadCount < Clients)
            {
            if (Retries > 3)
                {
                Dump("Threads did not pick up the hold command! Breaking ...\n");
                DebugBreak();
                ASSERT(0);
                }
            Sleep(50);
            Dump("Holding threads ...\n");
            Retries ++;
            }

        Dump("All threads checked in. Releasing ...\n");
        HoldingThreadCount = 0;
        fHoldFlag = FALSE;
        PulseEvent(HoldEvent);
        }
    
    Sleep(INFINITE);
}

#endif // _TEST_SWMR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\threads.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1990 - 1999
//
//  File:       threads.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

                      Microsoft OS/2 LAN Manager
                   Copyright(c) Microsoft Corp., 1990

-------------------------------------------------------------------- */
/* --------------------------------------------------------------------

File: threads.cxx

Description:

This file provides a system independent threads package for use on the
NT operating system.

History:
  5/24/90 [mikemon] File created.
  Kamen Moutafov (KamenM) Dec 99 - Feb 2000 - Support for cell debugging stuff

-------------------------------------------------------------------- */

#include <precomp.hxx>

#include <rpcuuid.hxx>
#include <binding.hxx>
#include <handle.hxx>
#include <hndlsvr.hxx>
#include <lpcpack.hxx>
#include <lpcsvr.hxx>
#include <ProtBind.hxx>
#include <lpcclnt.hxx>

unsigned long DefaultThreadStackSize = 0;

void
PauseExecution (
    unsigned long milliseconds
    )
{

    Sleep(milliseconds);

}


DLL::DLL (
    IN RPC_CHAR * DllName,
    OUT RPC_STATUS * Status
    )
/*++

Routine Description:

    We will load a dll and create an object to represent it.

Arguments:

    DllName - Supplies the name of the dll to be loaded.

    Status - Returns the status of the operation.  This will only be set
        if an error occurs.  The possible error values are as follows.

        RPC_S_OUT_OF_MEMORY - Insufficient memory is available to load
            the dll.

        RPC_S_INVALID_ARG - The requested dll can not be found.

--*/
{
    DWORD dwLastError;

    if (RpcpStringCompare(DllName, RPC_T("rpcrt4.dll")) == 0)
        {
        DllHandle = 0;
        return;
        }

    // Per the above condition, we can only be loading rpcrt4.dll on this path.
    // Since this is a known dll, we do not have to bother loading it explicitly
    // from the system folder.
    DllHandle = (void *)LoadLibrary((const RPC_SCHAR *)DllName);
    if ( DllHandle == 0 )
        {
        dwLastError = GetLastError();
        if ( (dwLastError == ERROR_NOT_ENOUGH_MEMORY)
             || (dwLastError == ERROR_COMMITMENT_LIMIT) )
            {
            *Status = RPC_S_OUT_OF_MEMORY;
            }
        else
            {
            *Status = RPC_S_INVALID_ARG;
            }
        }
}


DLL::~DLL (
    )
/*++

Routine Description:

    We just need to free the library, but only if was actually loaded.

--*/
{
    if ( DllHandle != 0 )
        {
        BOOL Status = FreeLibrary((HMODULE)DllHandle);
        ASSERT( Status );
        }
}


extern HANDLE GetCompletionPortHandleForThread(void);
extern void ReleaseCompletionPortHandleForThread(HANDLE h);


void *
DLL::GetEntryPoint (
    IN char * Procedure
    )
/*++

Routine Description:

    We obtain the entry point for a specified procedure from this dll.

Arguments:

    Procedure - Supplies the name of the entry point.

Return Value:

    A pointer to the requested procedure will be returned if it can be
    found; otherwise, zero will be returned.

--*/
{
    FARPROC ProcedurePointer;

    if (DllHandle == 0)
        {
        if (strcmp(Procedure, "TransportLoad") == 0)
            return (PVOID)TransportLoad;
        else if (strcmp(Procedure, "GetCompletionPortHandleForThread") == 0)
            return (PVOID)GetCompletionPortHandleForThread;
        else if (strcmp(Procedure, "ReleaseCompletionPortHandleForThread") == 0)
            return (PVOID) ReleaseCompletionPortHandleForThread;

        ASSERT(0);
        return NULL;
        }

    ProcedurePointer = GetProcAddress((HINSTANCE)DllHandle, (LPSTR) Procedure);
    if ( ProcedurePointer == 0 )
        {
        ASSERT( GetLastError() == ERROR_PROC_NOT_FOUND );
        }

    return(ProcedurePointer);
}

unsigned long
CurrentTimeSeconds (
    void
    )
// Return the current time in seconds.  When this time is counted
// from is not particularly important since it is used as a delta.
{

    return(GetTickCount()*1000L);

}


RPC_STATUS
SetThreadStackSize (
    IN unsigned long ThreadStackSize
    )
/*++

Routine Description:

    We want to set the default thread stack size.

Arguments:

    ThreadStackSize - Supplies the required thread stack size in bytes.

Return Value:

    RPC_S_OK - We will always return this, because this routine always
        succeeds.

--*/
{
    if (DefaultThreadStackSize < ThreadStackSize)
        DefaultThreadStackSize = ThreadStackSize;

    return(RPC_S_OK);
}


long
ThreadGetRpcCancelTimeout (
    )
{

 THREAD * ThreadInfo = RpcpGetThreadPointer();

 ASSERT(ThreadInfo);
 return (ThreadInfo->CancelTimeout);
}


RPC_STATUS
ThreadStartRoutine (
    IN THREAD * Thread
    )
{
    RpcpSetThreadPointer(Thread);

    Thread->StartRoutine();

    return 0;
}

THREAD *
ThreadSelfHelper (
    )
{
    THREAD * Thread;
    RPC_STATUS Status = RPC_S_OK;

    Thread = new THREAD(&Status);
    if (Thread == 0)
        {
        return 0;
        }

    if (Status != RPC_S_OK)
        {
        delete Thread;
        return 0;
        }

    return Thread;
}


RPC_STATUS RPC_ENTRY
RpcMgmtSetCancelTimeout(
    long Timeout
    )
/*++

Routine Description:

    An application will use this routine to set the cancel
    timeout for a thread.

Arguments:

    Timeout - Supplies the cancel timeout value to set in the thread.
    0 = No cancel timeout
    n = seconds
    RPC_C_CANCEL_INFINITE_TIMEOUT = Infinite

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_INVALID_TIMEOUT - The specified timeout value is invalid.

--*/
{
    InitializeIfNecessary();

    THREAD *Thread = ThreadSelf() ;

    if (!Thread)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    return Thread->SetCancelTimeout(Timeout);
}

RPC_STATUS
RegisterForCancels(
    CALL * Call
    )
{
    THREAD * ThreadInfo = ThreadSelf();
    if (ThreadInfo == 0)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    return ThreadInfo->RegisterForCancels(Call);
}

RPC_STATUS
UnregisterForCancels(
    )
{
    THREAD *ThreadInfo = RpcpGetThreadPointer();

    ASSERT(ThreadInfo);

    ThreadInfo->UnregisterForCancels ();

    return RPC_S_OK;
}



RPC_STATUS RPC_ENTRY
RpcCancelThread(
    IN void * ThreadHandle
    )
{
    if (!QueueUserAPC(CancelAPCRoutine, ThreadHandle, 0))
        {
        return RPC_S_ACCESS_DENIED;
        }

    return RPC_S_OK;
}

RPC_STATUS RPC_ENTRY
RpcCancelThreadEx (
    IN void *ThreadHandle,
    IN long Timeout
    )
{
    if (!QueueUserAPC(CancelExAPCRoutine, ThreadHandle, (UINT_PTR) Timeout))
        {
        return RPC_S_ACCESS_DENIED;
        }

    return RPC_S_OK;
}


RPC_STATUS RPC_ENTRY
RpcServerTestCancel (
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL
    )
/*++
Function Name:RpcServerTestCancel

Parameters:
    BindingHandle - This is the SCALL on which the server is trying to test for cancels.

Description:
    New API used by a server to check if a call has been cancelled.
    If BindingHandle is NULL, the test is perfomed on the dispatched call
    on the thread on which it is called. Async servers need to call
    RpcServerTestCancel(RpcAsyncGetCallHandle(pAsync))

Returns:
    RPC_S_OK: The call was cancelled
    RPC_S_CALL_IN_PROGRESS: The call was not cancelled
    RPC_S_INVALID_BINDING: The handle is invalid
    RPC_S_NO_CALL_ACTIVE: No call is active on this thread
--*/
{
    CALL *Call;

    if (BindingHandle == 0)
        {
        Call = (CALL *) RpcpGetThreadContext();
        if (Call == 0)
            {
#if DBG
            PrintToDebugger("RPC: RpcServerTestCancel: no call active\n");
#endif
            return RPC_S_NO_CALL_ACTIVE;
            }
        }
    else
        {
        Call = (CALL *) BindingHandle;
        if (Call->InvalidHandle(SCALL_TYPE))
            {
#if DBG
            PrintToDebugger("RPC: RpcServerTestCancel: bad handle\n");
#endif
            return RPC_S_INVALID_BINDING;
            }
        }

    if (Call->TestCancel())
        {
        return RPC_S_OK;
        }

    return RPC_S_CALL_IN_PROGRESS;
}


RPC_STATUS RPC_ENTRY
RpcTestCancel(
    )
/*++
Function Name:RpcTestCancel

Parameters:

Description:
    This function is here only for backward compatibility. The new API to test
    for cancels is RpcServerTestCancel.

Returns:

--*/
{
    return RpcServerTestCancel(0);
}

void RPC_ENTRY
RpcServerYield ()
{
    THREAD * ThreadInfo = RpcpGetThreadPointer();
    ASSERT(ThreadInfo);

    if (ThreadInfo)
        {
        ThreadInfo->YieldThread();
        }
}


THREAD::THREAD (
    IN THREAD_PROC Procedure,
    IN void * Parameter,
    OUT RPC_STATUS * Status
#ifdef RPC_OLD_IO_PROTECTION
    ) : ProtectCount(1), ReleaseCount(0),
#else
    ) :
#endif
    ThreadEvent(Status)
/*++

Routine Description:

    We construct a thread in this method.  It is a little bit weird, because
    we need to be able to clean things up if we cant create the thread.

Arguments:

    Procedure - Supplies the procedure which the new thread should execute.

    Parameter - Supplies a parameter to be passed to the procedure.

    RpcStatus - Returns the status of the operation.  This will be set to
        RPC_S_OUT_OF_THREADS if we can not create a new thread.

--*/
{
    unsigned long ThreadIdentifier;
    HANDLE ImpersonationToken, NewToken = 0;
    NTSTATUS NtStatus;

    CommonConstructor();

    SavedProcedure = Procedure;
    SavedParameter = Parameter;
    HandleToThread = 0;

    if (*Status != RPC_S_OK)
        {
        return;
        }

    if (IsServerSideDebugInfoEnabled())
        {
        DebugCell = (DebugThreadInfo *) AllocateCell(&DebugCellTag);
        if (DebugCell == NULL)
            {
            *Status = RPC_S_OUT_OF_MEMORY;
            return;
            }
        else
            {
            DebugCell->TypeHeader = 0;
            DebugCell->Type = dctThreadInfo;
            DebugCell->Status = dtsAllocated;
            }
        }

    //
    // If there is a token on the calling thread, null it out
    //
    if (OpenThreadToken (GetCurrentThread(),
                     TOKEN_IMPERSONATE | TOKEN_QUERY,
                     TRUE,
                     &ImpersonationToken) == FALSE)
        {
        if ( GetLastError() == ERROR_NO_TOKEN )
            {
            ImpersonationToken = 0 ;
            }
        else
            {
            //
            // More interesting.  There may be a token, and
            // we can't open it.  Note that the anonymous token can't be opened
            // this way.  Complain:
            //
#if DBG
            PrintToDebugger( "RPC : OpenThreadToken returned %d\n", GetLastError() );
#endif
            ASSERT(0);
            *Status = RPC_S_ACCESS_DENIED;
            return;
            }
        }
    else
        {
        NtStatus = NtSetInformationThread(NtCurrentThread(),
                                          ThreadImpersonationToken,
                                          &NewToken,
                                          sizeof(HANDLE));

        if (!NT_SUCCESS(NtStatus))
            {
            *Status = RPC_S_ACCESS_DENIED;
#if DBG
            PrintToDebugger("RPC : NtSetInformationThread : %lx\n", NtStatus);
#endif
            ASSERT(0);
            CloseHandle(ImpersonationToken);
            return;
            }
        }

    HandleToThread = CreateThread(0, DefaultThreadStackSize,
                    (LPTHREAD_START_ROUTINE) ThreadStartRoutine,
                    this, 0, &ThreadIdentifier);
    if ( HandleToThread == 0 )
        {
        *Status = RPC_S_OUT_OF_THREADS;
        }

    if (ImpersonationToken)
        {
        //
        // If there was a token, restore it.
        //
        NtStatus = NtSetInformationThread(NtCurrentThread(),
                                      ThreadImpersonationToken,
                                      &ImpersonationToken,
                                      sizeof(HANDLE));

#if DBG
        if (!NT_SUCCESS(NtStatus))
            {
            PrintToDebugger("RPC : NtSetInformationThread : %lx\n", NtStatus);
            }
#endif // DBG

        CloseHandle(ImpersonationToken);
        }
}


THREAD::THREAD (
    OUT RPC_STATUS * Status
#ifdef RPC_OLD_IO_PROTECTION
    ) : ProtectCount(1), ReleaseCount(0),
#else
    ) :
#endif
    ThreadEvent(Status)
/*++
Routine Description:
    This overloaded constructor is called only by the main app thread.
    this is needed because in WMSG we will be dispatching in the
    context of main app thread.

Arguments:
    RpcStatus - Returns the status of the operation
--*/
{
    HANDLE hProcess ;

    CommonConstructor();

    SavedProcedure = 0;
    SavedParameter = 0;
    HandleToThread = 0;

    if (*Status != RPC_S_OK)
        {
        return;
        }

    hProcess = GetCurrentProcess() ;

    if (!DuplicateHandle(hProcess,
                         GetCurrentThread(),
                         hProcess,
                         &HandleToThread,
                         0,
                         FALSE,
                         DUPLICATE_SAME_ACCESS))
        {
        *Status = RPC_S_OUT_OF_MEMORY ;
        return;
        }

    RpcpSetThreadPointer(this);

    *Status = RPC_S_OK ;
}

void
THREAD::CommonConstructor (
    )
/*++
Function Name:CommonConstructor

Parameters:

Description:

Returns:

--*/
{
    CancelTimeout = RPC_C_CANCEL_INFINITE_TIMEOUT;
    Context = 0;
    SecurityContext = 0;
    ClearCallCancelledFlag();
    fAsync = FALSE;
    ExtendedStatus = RPC_S_OK;
    DebugCell = NULL;
    ThreadEEInfo = NULL;
    NDRSlot = NULL;
    CachedLrpcCall = NULL;
    LastSuccessfullyDestroyedContext = NULL;
    CachedWaiterPtr = NULL;
    CachedWaiterAvailable = TRUE;
    CachedEEInfoBlock = NULL;
    ParametersOfCachedEEInfo = 0;

    ActiveCall = 0;

    for (int i = 0; i < 4; i++)
        {
        BufferCache[i].pList = 0;
        BufferCache[i].cBlocks = 0;
        }

    #ifdef CHECK_MUTEX_INVERSION
    ConnectionMutexHeld = 0;
    #endif
}

THREAD::~THREAD (
    )
{
    ASSERT (0 == SecurityContext);
#ifdef RPC_OLD_IO_PROTECTION
    ASSERT(ProtectCount == ReleaseCount.GetInteger());
#endif

    if (CachedWaiterPtr && (CachedWaiterPtr != &CachedWaiter))
        SWMRLock::FreeWaiterCache(&CachedWaiterPtr);

    if (DebugCell != NULL)
        {
        FreeCell(DebugCell, &DebugCellTag);
        }

    if ( HandleToThread != 0 )
        {
        CloseHandle(HandleToThread);
        HandleToThread = UlongToPtr(0xbaadbaad);
        }

    if (CachedLrpcCall)
        {
        delete CachedLrpcCall;
        }

    if (ThreadEEInfo)
        PurgeEEInfo();

    if (CachedEEInfoBlock)
        FreeEEInfoRecordShallow(CachedEEInfoBlock);

    gBufferCache->ThreadDetach(this);
}

void *
THREAD::ThreadHandle (
    )
/*++
Function Name:ThreadHandle

Parameters:

Description:

Returns:

--*/
{
    while ( HandleToThread == 0 )
        {
        PauseExecution(100L);
        }

    return(HandleToThread);
}

RPC_STATUS
THREAD::SetCancelTimeout (
    IN long Timeout
    )
/*++
Function Name:SetCancelTimeout

Parameters:

Description:

Returns:

--*/
{

    CancelTimeout = Timeout;

    return RPC_S_OK;
}


void
SetExtendedError (
    IN RPC_STATUS Status
    )
{
    THREAD *pThread = ThreadSelf();

    if (pThread == 0)
        {
        return;
        }

    pThread->SetExtendedError(Status);
}


RPC_STATUS
I_RpcGetExtendedError (
    )
{
    THREAD *pThread = ThreadSelf();

    if (pThread == 0)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    return pThread->GetExtendedError();
}


HANDLE RPC_ENTRY
I_RpcTransGetThreadEvent(
    )
/*++

Routine Description:

    Returns the receive event specific to this thread.

Arguments:

    None

Return Value:

    Returns the send event. This function will not fail
--*/
{
    THREAD *pThis = RpcpGetThreadPointer();

    ASSERT(pThis);
    ASSERT(pThis->ThreadEvent.EventHandle);

    return(pThis->ThreadEvent.EventHandle);
}


RPC_STATUS
THREAD::CancelCall (
    IN BOOL fTimeoutValid,
    IN long Timeout
    )
{
    RPC_STATUS Status;

    if (fTimeoutValid)
        {
        CancelTimeout = Timeout;
        }

    SetCallCancelledFlag();
    if (ActiveCall)
        {
        Status = ActiveCall->Cancel(HandleToThread);
        }
    else
        {
        Status =  RPC_S_NO_CALL_ACTIVE;
        }

    return Status;
}


RPC_STATUS
THREAD::RegisterForCancels (
    IN CALL *Call
    )
{
    Call->NestingCall = ActiveCall;
    ActiveCall = Call;

    return RPC_S_OK;
}


void
THREAD::UnregisterForCancels (
    )
{
    if (ActiveCall)
        {
        ActiveCall = ActiveCall->NestingCall;
        }

    //
    // Need to think about when we should cancel the next call if ActiveCall != 0
    //
}

void
THREAD::PurgeEEInfo (
    void
    )
{
    ASSERT(ThreadEEInfo != NULL);
    FreeEEInfoChain(ThreadEEInfo);
    ThreadEEInfo = NULL;
}

VOID RPC_ENTRY
CancelAPCRoutine (
    IN ULONG_PTR Timeout
    )
{
    RPC_STATUS Status;
    THREAD *Thread = ThreadSelf() ;

    if (Thread == 0)
        {
        return;
        }

    Status = Thread->CancelCall();
#if DBG
    if (Status != RPC_S_OK)
        {
        PrintToDebugger("RPC: CancelCall failed %d\n", Status);
        }
#endif
}

void
THREAD::GetWaiterCache (
    OUT SWMRWaiter **WaiterCache,
    IN SCALL *SCall,
    IN SWMRWaiterType WaiterType
    )
{
    ASSERT(WaiterCache != NULL);

    if (CachedWaiterPtr)
        {
        LogEvent(SU_THREAD, EV_POP, CachedWaiterPtr->hEvent, CachedWaiterPtr, 0, 1, 1);
        // if we have something in the cache, we may as well use it
        *WaiterCache = CachedWaiterPtr;
        CachedWaiterPtr = NULL;
        }
    else if ((WaiterType == swmrwtWriter) && SCall->IsSyncCall() && CachedWaiterAvailable)
        {
        // the cache is empty, but this is exclusive, sync usage, so we can 
        // borrow the thread event and cook up a waiter.  We also make sure that
        // we aren't using the CachedWaiter already (such as in the multi-context handle case).
        CachedWaiterAvailable = FALSE;
        SWMRWaiter::CookupWaiterFromEventAndBuffer(&CachedWaiter, WaiterType, ThreadEvent.EventHandle);
        *WaiterCache = &CachedWaiter;
        }
    else
        {
        // the cache is empty and this is either shared or async usage so we can't 
        // use the thread buffer/event.
        *WaiterCache = NULL;
        }
}

void
THREAD::FreeWaiterCache (
    IN OUT SWMRWaiter **WaiterCache
    )
{
    ASSERT(WaiterCache != NULL);

    if (*WaiterCache == &CachedWaiter)
        {
        ASSERT(CachedWaiterAvailable == FALSE);
        // We are done using the CachedWaiter, indicate that it is avaliable
        CachedWaiterAvailable = TRUE;
        }
    else if (*WaiterCache)
        // if we got something in the cache and this is not a cooked up item
        {
        if (CachedWaiterPtr)
            {
            // if our cache is already full, just free the new waiter
            SWMRLock::FreeWaiterCache(WaiterCache);
            }
        else
            {
            // store it
            CachedWaiterPtr = *WaiterCache;
            LogEvent(SU_THREAD, EV_PUSH, CachedWaiterPtr->hEvent, CachedWaiterPtr, 0, 1, 1);
            *WaiterCache = NULL;
            }
        }
}

VOID RPC_ENTRY
CancelExAPCRoutine (
    IN ULONG_PTR Timeout
    )
{
    RPC_STATUS Status;
    THREAD *Thread = ThreadSelf() ;

    if (Thread == 0)
        {
        return;
        }

    Status = Thread->CancelCall(TRUE, (long) Timeout);
#if DBG
    if (Status != RPC_S_OK)
        {
        PrintToDebugger("RPC: CancelCall failed %d\n", Status);
        }
#endif
}


void
RpcpRaiseException (
    IN RPC_STATUS exception
    )
{
    if ( exception == STATUS_ACCESS_VIOLATION )
        {
        exception = ERROR_NOACCESS;
        }

    RaiseException(exception,
                   EXCEPTION_NONCONTINUABLE,
                   0,
                   0);

    ASSERT(0);
}



void RPC_ENTRY
RpcRaiseException (
    IN RPC_STATUS exception
    )
{
    NukeStaleEEInfoIfNecessary(exception);
    RpcpRaiseException(exception);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\svrmgmt.c ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    svrmgmt.c

Abstract:

    We implement the server side of the remote management routines in this
    file.

Author:

    Michael Montague (mikemon) 14-Apr-1993

Revision History:

--*/

#include <sysinc.h>
#include <rpc.h>
#include <mgmt.h>


int
DefaultMgmtAuthorizationFn (
    IN RPC_BINDING_HANDLE ClientBinding,
    IN unsigned long RequestedMgmtOperation,
    OUT RPC_STATUS __RPC_FAR * Status
    )
/*++

Routine Description:

    This is the default authorization function used to control remote access
    to the server's management routines.

Arguments:

    ClientBinding - Supplies the client binding handle of the application
        which is calling this routine.

    RequestedMgmtOperation - Supplies which management routine is being called.

    Status - Returns RPC_S_OK.

Return Value:

    A value of non-zero will be returned if the client is authorized to
    call the management routine; otherwise, zero will be returned.

--*/
{
    ((void) ClientBinding);

    *Status = RPC_S_OK;

    if ( RequestedMgmtOperation != RPC_C_MGMT_STOP_SERVER_LISTEN )
        {
        return(1);
        }

    return(0);
}

RPC_MGMT_AUTHORIZATION_FN MgmtAuthorizationFn = DefaultMgmtAuthorizationFn;


RPC_STATUS RPC_ENTRY
RpcMgmtSetAuthorizationFn (
    IN RPC_MGMT_AUTHORIZATION_FN AuthorizationFn
    )
/*++

Routine Description:

    An application can use this routine to set the authorization function
    which will be called when a remote call arrives for one of the server's
    management routines, or to return to using the default (built-in)
    authorizatio function.

Arguments:

    AuthorizationFn - Supplies a new authorization function.
                      The fn may be nil, in which case the built-in auth fn
                      is used instead.

Return Value:

    RPC_S_OK - This will always be returned.

--*/
{
    if (AuthorizationFn)
        {
        MgmtAuthorizationFn = AuthorizationFn;
        }
    else
        {
        MgmtAuthorizationFn = DefaultMgmtAuthorizationFn;
        }

    return(RPC_S_OK);
}


void
rpc_mgmt_inq_if_ids (
    RPC_BINDING_HANDLE binding,
    rpc_if_id_vector_p_t __RPC_FAR * if_id_vector,
    unsigned long __RPC_FAR * status
    )
/*++

Routine Description:

    This is the management code corresponding to the rpc_mgmt_inq_if_ids
    remote operation.

--*/
{
    if (status == NULL)
        RpcRaiseException(ERROR_INVALID_PARAMETER);

    //
    // If the auth fn returns false, the op is denied.
    //
    if ( (*MgmtAuthorizationFn)(binding, RPC_C_MGMT_INQ_IF_IDS, status) == 0 )
        {
        if (0 == *status || RPC_S_OK == *status)
            {
            *status = RPC_S_ACCESS_DENIED;
            }

        return;
        }

    *status = RpcMgmtInqIfIds(0, (RPC_IF_ID_VECTOR **) if_id_vector);
}


void
rpc_mgmt_inq_princ_name (
    RPC_BINDING_HANDLE binding,
    unsigned32 authn_svc,
    unsigned32 princ_name_size,
    unsigned char server_princ_name[],
    error_status_t * status
    )
/*++

Routine Description:

    This is the management code corresponding to the
    rpc_mgmt_inq_server_princ_name remote operation.

--*/
{
    unsigned char * ServerPrincName;
    
    if (status == NULL)
        RpcRaiseException(ERROR_INVALID_PARAMETER);

    //
    // We have to call the function, even if princ_name_size == 0. 
    // The call may be using it just to see if it has access
    //
    
    //
    // If the auth fn returns false, the op is denied.
    //
    if ( (*MgmtAuthorizationFn)(binding, RPC_C_MGMT_INQ_PRINC_NAME, status)
         == 0 )
        {
        if (0 == *status || RPC_S_OK == *status)
            {
            *status = RPC_S_ACCESS_DENIED;
            }

        if (princ_name_size)
            {
            *server_princ_name = '\0';
            }   
        return;
        }

    *status = RpcMgmtInqServerPrincNameA(0, authn_svc, &ServerPrincName);
    if ( *status == 0 )
        {
        unsigned int count;
        if (princ_name_size)
            {
            count = strlen(ServerPrincName);
            if (count > princ_name_size - 1)
                {
                *status = RPC_S_BUFFER_TOO_SMALL;
                }
            else
                {
                RpcpMemoryCopy(server_princ_name, ServerPrincName, count + 1);
                }
            RpcStringFreeA(&ServerPrincName);
            }
        }
    else
        {
        if (princ_name_size)
            {
            *server_princ_name = '\0';
            }
        }
}


void
rpc_mgmt_inq_stats (
    RPC_BINDING_HANDLE binding,
    unsigned32 * count,
    unsigned32 statistics[],
    error_status_t * status
    )
/*++

Routine Description:

    This is the management code corresponding to the rpc_mgmt_inq_stats
    remote operation.

--*/
{
    RPC_STATS_VECTOR __RPC_FAR * StatsVector;
    unsigned long Index;

    if (status == NULL)
        RpcRaiseException(ERROR_INVALID_PARAMETER);

    //
    // If the auth fn returns false, the op is denied.
    //
    if ( (*MgmtAuthorizationFn)(binding, RPC_C_MGMT_INQ_STATS, status) == 0 )
        {
        if (0 == *status || RPC_S_OK == *status)
            {
            *status = RPC_S_ACCESS_DENIED;
            }

        return;
        }

    *status = RpcMgmtInqStats(0, &StatsVector);
    if ( *status == RPC_S_OK )
        {
        for (Index = 0; Index < StatsVector->Count && Index < *count; Index++)
            {
            statistics[Index] = StatsVector->Stats[Index];
            }
        *count = Index;
        RpcMgmtStatsVectorFree(&StatsVector);
        }
}


unsigned long
rpc_mgmt_is_server_listening (
    RPC_BINDING_HANDLE binding,
    unsigned long __RPC_FAR * status
    )
/*++

Routine Description:

    This is the management code corresponding to the
    rpc_mgmt_is_server_listening remote operation.

--*/
{
    if (status == NULL)
        RpcRaiseException(ERROR_INVALID_PARAMETER);

    //
    // If the auth fn returns false, the op is denied.
    //
    if ( (*MgmtAuthorizationFn)(binding, RPC_C_MGMT_IS_SERVER_LISTEN, status)
         == 0 )
        {
        if (0 == *status || RPC_S_OK == *status)
            {
            *status = RPC_S_ACCESS_DENIED;
            }

        return 1;
        }

    *status = RpcMgmtIsServerListening(0);
    if ( *status == RPC_S_OK )
        {
        return(1);
        }

    if ( *status == RPC_S_NOT_LISTENING )
        {
        *status = RPC_S_OK;
        }

    return(0);
}


void
rpc_mgmt_stop_server_listening (
    RPC_BINDING_HANDLE binding,
    unsigned long __RPC_FAR * status
    )
/*++

Routine Description:

    This is the management code corresponding to the
    rpc_mgmt_stop_server_listening remote operation.

--*/
{
    if (status == NULL)
        RpcRaiseException(ERROR_INVALID_PARAMETER);

    //
    // If the auth fn returns false, the op is denied.
    //
    if ( (*MgmtAuthorizationFn)(binding, RPC_C_MGMT_STOP_SERVER_LISTEN, status)
          == 0 )
        {
        if (0 == *status || RPC_S_OK == *status)
            {
            *status = RPC_S_ACCESS_DENIED;
            }

        return;
        }

    // N.B. RpcMgmtStopServerListening just flags the global
    // server as not listening. There is no danger of deadlock

    *status = RpcMgmtStopServerListening(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\sysinc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1991 - 1999
//
//  File:       sysinc.h
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

File : sysinc.h

Description :

This file includes all of the system include files necessary for a
specific version of the runtime.  In addition, it defines some system
dependent debugging options.

***** If you are adding are changing something for a specific     *****
***** system you MUST 1) make the change for all the defined      *****
***** systems and 2) add a comment if needed in the template for  *****
***** future systems.                                             *****

History :

mikemon    08-01-91    Created.
mikemon    10-31-91    Moved system dependent stuff from util.hxx to
                       here.
mariogo    10-19-94    Order conquered chaos and the world rejoiced

-------------------------------------------------------------------- */

#ifndef __SYSINC_H__
#define __SYSINC_H__

// Some system indepentent macros

#ifndef DEBUGRPC
#define INTERNAL_FUNCTION   static
#define INTERNAL_VARIABLE   static
#else
#define INTERNAL_FUNCTION
#define INTERNAL_VARIABLE
#endif  // ! DEBUGRPC

// The following functions are can be implemented as macros
// or functions for system type.

// extern void  *
// RpcpFarAllocate (
//     IN unsigned int Length
//     );

// extern void
// RpcpFarFree (
//     IN void  * Object
//     );

// extern int
// RpcpStringCompare (
//     IN RPC_CHAR  * FirstString,
//     IN RPC_CHAR  * SecondString
//     );

// extern int
// RpcpStringNCompare (
//     IN RPC_CHAR * FirstString,
//     IN RPC_CHAR * SecondString,
//     IN unsigned int Length
//     );

// extern RPC_CHAR *
// RpcpStringCopy (
//    OUT RPC_CHAR * Destination,
//    IN  RPC_CHAR * Source
//    );

// extern RPC_CHAR *
// RpcpStringCat (
//    OUT RPC_CHAR * Destination,
//    IN  CONST RPC_CHAR * Source
//    );

// extern int
// RpcpStringLength (
//    IN RPC_CHAR * WideCharString
//    );

// extern void
// RpcpMemoryMove (
//    OUT void  * Destination,
//    IN  void  * Source,
//    IN  unsigned int Length
//    );

// extern void  *
// RpcpMemoryCopy (
//    OUT void  * Destination,
//    IN  void  * Source,
//    IN  unsigned int Length
//    );

// extern void *
// RpcpMemorySet (
//    OUT void  * Buffer,
//    IN  unsigned char  Value,
//    IN  unsigned int Length
//    );

// extern char *
// RpcpItoa(
//    IN  int Value,
//    OUT char *Buffer,
//    IN  int Radix);

// extern int
// RpcpStringPrintfA(
//    OUT char *Buffer,
//    IN  char *Format,
//    ...);

// extern void
// PrintToDebugger(
//    IN char *Format,
//    ...);

// extern void
// RpcpBreakPoint(
//    );

#ifdef __cplusplus
extern "C" {
#endif

extern void GlobalMutexRequestExternal(void);
extern void GlobalMutexClearExternal(void);

#ifdef __cplusplus
} // extern "C"
#endif


#include<nt.h>
#include<ntrtl.h>
#include<nturtl.h>
#include<stdio.h>
#include<string.h>
#include<memory.h>
#include<malloc.h>
#include<stdlib.h>
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include<windows.h>

#ifdef __cplusplus
extern "C" {
#endif

#if DBG
#define DEBUGRPC
#endif

#if DBG
#undef ASSERT
#define ASSERT( exp ) \
    if (!(exp)) { RtlAssert( #exp, __FILE__, __LINE__, NULL ); DebugBreak(); }
#endif

#define NO_RETURN { ASSERT(0); }

#define ASSUME(exp) ASSERT(exp)

#define FORCE_INLINE inline

#ifndef FORCE_VTABLES
#define NO_VTABLE __declspec(novtable)
#else
#define NO_VTABLE
#endif

#define RPC_DELAYED_INITIALIZATION 1

// flag to preallocate the events on some critical sections
#ifndef PREALLOCATE_EVENT_MASK

#define PREALLOCATE_EVENT_MASK  0x80000000  // Defined only in dll\resource.c

#endif // PREALLOCATE_EVENT_MASK

#define RPC_CHAR WCHAR
#define RPC_SCHAR RPC_CHAR
#define RPC_CONST_CHAR(character) ((RPC_CHAR) L##character)
#define RPC_CONST_STRING(string) ((const RPC_CHAR *) L##string)
#define RPC_CONST_SSTRING(string)	RPC_CONST_STRING(string)
#define RPC_STRING_LITERAL(string)	((RPC_CHAR *) L##string)
#define RPC_T(string)			(L##string)

#define UNUSED(_x_) ((void)(_x_))
#define MAX_DLLNAME_LENGTH 256

#if DBG
#define ASSERT_VALID(c)     ((c)->AssertValid())
#define ASSERT_VALID1(c, p1)     ((c)->AssertValid(p1))
#else
#define ASSERT_VALID
#define ASSERT_VALID1
#endif

#define LOCALE_US	(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT))

#define RpcpFarAllocate(Length) \
    ((void *) new char[Length])

#define RpcpFarFree(Object) \
    (delete Object)

#define RpcpStringSCompare(FirstString, SecondString) \
    lstrcmp((const wchar_t *) FirstString, (const wchar_t *) SecondString)

#define RpcpStringCompare(FirstString, SecondString) \
    _wcsicmp((const wchar_t *) FirstString, (const wchar_t *) SecondString)

#define RpcpStringNCompare(FirstString, SecondString, Length) \
    _wcsnicmp((const wchar_t*) FirstString, (const wchar_t *) SecondString, \
            (size_t) Length)

// always compares ASCII
#define RpcpStringCompareA(FirstString, SecondString) \
    _stricmp((const char *) FirstString, (const char *) SecondString)

#define RpcpStringNCompareA(FirstString, SecondString, Size) \
    _strnicmp((const char *) FirstString, (const char *) SecondString, Size)

#define RpcpStringCompareInt(FirstString, SecondString) \
    (CompareStringW(LOCALE_US, NORM_IGNORECASE, \
    (const wchar_t *) FirstString, -1, (const wchar_t *) SecondString, -1) != CSTR_EQUAL)

#define RpcpStringCompareIntA(FirstString, SecondString) \
    (CompareStringA(LOCALE_US, NORM_IGNORECASE, \
    FirstString, -1, SecondString, -1) != CSTR_EQUAL)

#define RpcpStringCopy(Destination, Source) \
    wcscpy((wchar_t *) Destination, (const wchar_t *) Source)

#define RpcpStringNCopy(DestinationString, SourceString, Length) \
    wcsncpy((wchar_t *) DestinationString, (wchar_t *) SourceString, Length)

#define RpcpStringCat(Destination, Source) \
    wcscat((wchar_t *) Destination, (const wchar_t *) Source)

#define RpcpStringLength(String) \
    wcslen((const wchar_t *) String)

#define RpcpStrStr(String1, String2) \
    wcsstr((const wchar_t *) String1, (const wchar_t *) String2)

#define RpcpStringLengthA(String) \
    strlen(String)

#define RpcpStringToLower(String) \
    _wcslwr(String)

#define RpcpMemoryCompare(FirstBuffer, SecondBuffer, Length) \
    memcmp(FirstBuffer, SecondBuffer, Length)

#define RpcpMemoryCopy(Destination, Source, Length) \
    RtlCopyMemory(Destination, Source, Length)

#define RpcpMemoryMove(Destination, Source, Length) \
    RtlMoveMemory(Destination, Source, Length)

#define RpcpMemorySet(Buffer, Value, Length) \
    RtlFillMemory(Buffer, Length, Value)

#if defined(TYPE_ALIGNMENT)
#undef TYPE_ALIGNMENT
#endif

#define TYPE_ALIGNMENT(x) __alignof(x)

void
RpcpRaiseException (
    IN long exception
    );

RPC_CHAR * __cdecl RpcpStringReverse (RPC_CHAR *string);
void * I_RpcBCacheAllocate (IN unsigned int size);
void I_RpcBCacheFree (IN void * obj);

void I_RpcDoCellUnitTest(IN OUT void *p);

// some test hook definitions
typedef enum tagSystemFunction001Commands
{
    sf001cHttpSetInChannelTarget,
    sf001cHttpSetOutChannelTarget,
    sf001cIgnoreCorruptionAsserts
} SystemFunction001Commands;

#ifdef STATS
void I_RpcGetStats(DWORD *pdwStat1, DWORD *pdwStat2, DWORD *pdwStat3, DWORD *pdwStat4);
#endif

#define RpcpItoa(Value, Buffer, Radix) \
    _itoa(Value, Buffer, Radix)

#define RpcpItow(Value, Buffer, Radix) \
    _itow(Value, Buffer, Radix)

#define RpcpCharacter(Buffer, Character) \
	wcschr(Buffer, Character)

#define RpcpStringPrintfA sprintf
#define RpcpStringConcatenate(FirstString, SecondString) \
     wcscat(FirstString, (const wchar_t *) SecondString)

LONG
I_RpcSetNDRSlot(
    IN void *NewSlot
    );

void *
I_RpcGetNDRSlot(
    void
    );

long 
NDRCCopyContextHandle (
    IN void *SourceBinding,
    OUT void **DestinationBinding
    );

BOOL CheckVerificationTrailer (
    IN void *BufferStart,
    IN void *BufferEnd,
    IN void *RpcMessage
    );

#if defined(_M_IA64) || defined(_M_AMD64)
#define CONTEXT_HANDLE_BEFORE_MARSHAL_MARKER ((PVOID)0xbaadbeefbaadbeef)
#define CONTEXT_HANDLE_AFTER_MARSHAL_MARKER ((PVOID)0xdeaddeaddeaddead)
#else
#define CONTEXT_HANDLE_BEFORE_MARSHAL_MARKER ((PVOID)0xbaadbeef)
#define CONTEXT_HANDLE_AFTER_MARSHAL_MARKER ((PVOID)0xdeaddead)
#endif


#define ANSI_strtol    strtol

#define PrintToConsole  printf  /* Use only in test applications */

#if defined(_M_IA64) || defined(_M_AMD64)
// uncomment this to disable locator support for IA64 or amd64
//#define NO_LOCATOR_CODE
//#define APPLETALK_ON
//#define NETBIOS_ON
//#define NCADG_MQ_ON
//#define SPX_ON
//#define IPX_ON
#else
#define APPLETALK_ON
//#define NETBIOS_ON
//#define NCADG_MQ_ON
#define SPX_ON
//#define IPX_ON
#endif

#if !defined(SPX_ON) && !defined(IPX_ON)
#define SPX_IPX_OFF
#endif

#ifdef DEBUGRPC

#define PrintToDebugger DbgPrint
#define RpcpBreakPoint() DebugBreak()

// ASSERT defined by system

extern BOOL ValidateError(
    IN unsigned int Status,
    IN unsigned int Count,
    IN const int ErrorList[]);

//
// The syntax of VALIDATE is the following:
//
// VALIDATE (ErrorCode)
//     {
//     List of allowed errors
//     } END_VALIDATE;
//
// The code will assert on a checked build if ErrorCode is not in the list.
//
#define VALIDATE(_myValueToValidate) \
    { int _myTempValueToValidate = (_myValueToValidate); \
      static const int _myValidateArray[] =

#define END_VALIDATE ; \
    if (ValidateError(_myTempValueToValidate,\
                      sizeof(_myValidateArray)/sizeof(int), \
                      _myValidateArray) == 0) ASSERT(0);}

//
// The syntax of CORRUPTION_VALIDATE is the following:
//
// VALIDATE (ErrorCode)
//     {
//     List of allowed errors
//     }
// CORRUPTION_VALIDATE
//     {
//     List of allowed corruption-related errors
//     } CORRUPTION_END_VALIDATE;
//
// The code will assert on a checked build if ErrorCode is not in the allowed list
// and there is no corruption injection enabled, or corruption injection is enabled
// and the ErrorCode is also not in the corruption-related list.
//
#define CORRUPTION_VALIDATE ; \
      static const int _myCorruptionValidateArray[] =

#define CORRUPTION_END_VALIDATE ; \
    if (ValidateError(_myTempValueToValidate,\
                      sizeof(_myValidateArray)/sizeof(int), \
                      _myValidateArray) == 0 && \
        (!gfRpcVerifierCorruptionExpected || \
         ValidateError(_myTempValueToValidate,\
                       sizeof(_myCorruptionValidateArray)/sizeof(int), \
                       _myCorruptionValidateArray) == 0 \
        ) \
       ) ASSERT(0); }

//
// The syntax of NO_CORRUPTION_VALIDATE is the following:
//
// NO_CORRUPTION_VALIDATE (ErrorCode)
//     {
//     List of allowed errors
//     } NO_CORRUPTION_END_VALIDATE;
//
// The code will assert on a checked build if ErrorCode is not in the list and
// corruption injection is not enabled.
//
#define NO_CORRUPTION_VALIDATE(_myValueToValidate) \
    { int _myTempValueToValidate = (_myValueToValidate); \
      static const int _myValidateArray[] =

#define NO_CORRUPTION_END_VALIDATE ; \
    if ( \
        !gfRpcVerifierCorruptionExpected && \
        ValidateError(_myTempValueToValidate,\
                      sizeof(_myValidateArray)/sizeof(int), \
                      _myValidateArray) == 0 \
       ) ASSERT(0); }

#else // DEBUGRPC

    // PrintToDebugger defined only on debug builds...

    #define RpcpBreakPoint()

/* Does nothing on retail systems */
#define VALIDATE(_myValueToValidate) { int _bogusarray1[] =
#define END_VALIDATE ; }
#define CORRUPTION_VALIDATE ; } ; { int _bogusarray2[] =
#define CORRUPTION_END_VALIDATE ; }
#define NO_CORRUPTION_VALIDATE(_myValueToValidate) { int _bogusarray1[] =
#define NO_CORRUPTION_END_VALIDATE ; }

#endif // DEBUGRPC

// List Operations
//

#define RpcpInitializeListHead(ListHead)    InitializeListHead(ListHead)


#define RpcpIsListEmpty(ListHead)           IsListEmpty(ListHead)


PLIST_ENTRY
RpcpfRemoveHeadList(
    PLIST_ENTRY ListHead
    );


#define RpcpRemoveHeadList(ListHead)        RemoveHeadList(ListHead)


PLIST_ENTRY
RpcpfRemoveTailList(
    PLIST_ENTRY ListHead
    );


#define RpcpRemoveTailList(ListHead)        RemoveTailList(ListHead)


VOID
RpcpfRemoveEntryList(
    PLIST_ENTRY Entry
    );


#define RpcpRemoveEntryList(Entry)          RemoveEntryList(Entry)


VOID
RpcpfInsertTailList(
    PLIST_ENTRY ListHead,
    PLIST_ENTRY Entry
    );


#define RpcpInsertTailList(ListHead,Entry)  InsertTailList(ListHead,Entry)


VOID
RpcpfInsertHeadList(
    PLIST_ENTRY ListHead,
    PLIST_ENTRY Entry
    );


#define RpcpInsertHeadList(ListHead,Entry)  InsertHeadList(ListHead,Entry)

#ifdef __cplusplus
}
#endif

//
// Don't read this part.  These are needed to support macros
// used in the past.  Please use the supported versions above.
//

#define PAPI __RPC_FAR

// Some old C++ compiler the runtime once used didn't allocate
// the this pointer before calling the constructor.  If you
// have such a compiler now, I'm very sorry for you.

#define ALLOCATE_THIS(class)
#define ALLOCATE_THIS_PLUS(class, amt, errptr, errcode)

#ifdef __cplusplus
#define START_C_EXTERN      extern "C" {
#define END_C_EXTERN        }
#else
#define START_C_EXTERN
#define END_C_EXTERN
#endif

// These must always evaluate "con" even on retail systems.

#ifdef DEBUGRPC
#define EVAL_AND_ASSERT(con) ASSERT(con)
#else
#define EVAL_AND_ASSERT(con) (con)
#endif

#define RequestGlobalMutex GlobalMutexRequest
#define ClearGlobalMutex GlobalMutexClear
#define RpcItoa RpcpItoa

// Double check basic stuff.
#if !defined(TRUE)              || \
    !defined(FALSE)             || \
    !defined(ASSERT)            || \
    !defined(VALIDATE)          || \
    !defined(IN)                || \
    !defined(OUT)               || \
    !defined(CONST)             || \
    !defined(UNALIGNED)         || \
    !defined(UNUSED)

    #error "Some basic macro is not defined"
#endif

//
// External NDR routines that may be used by the runtime.
//

extern long
NdrCheckAsyncPipeStatus( 
    IN char * AsyncHandle,
    OUT long * pState );

#endif /* __SYSINC_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\twrproto.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    tower.c 

Abstract:

    This file accompanies tower.c

Author:

    Bharat Shah  (barats) 3-25-92

Revision History:

--*/

//Function Prototypes


#ifdef __cplusplus
extern "C" {
#endif 

RPC_STATUS
TowerExplode(
    twr_p_t Tower,
    RPC_IF_ID PAPI * Ifid,
    RPC_TRANSFER_SYNTAX PAPI * XferId,
    char PAPI * PAPI * Protseq,
    char PAPI * PAPI * Endpoint,
    char PAPI * PAPI * NWAddress
    );

RPC_STATUS
OsfTowerConstruct(
    char PAPI * ProtocolSeq,
    char PAPI * Endpoint,
    char PAPI * NetworkAddress,
    unsigned short PAPI * Floors,
    unsigned long PAPI * ByteCount,
    unsigned char PAPI * PAPI * Tower
    );

RPC_STATUS
OsfTowerExplode(
    IN BYTE *Floor,
    IN BYTE *UpperBound,
    IN ULONG RemainingFloors,
    OUT char PAPI * PAPI * Protseq, OPTIONAL
    OUT char PAPI * PAPI * Endpoint, OPTIONAL
    OUT char PAPI * PAPI * NWAddress OPTIONAL
    );

RPC_STATUS
TowerConstruct(
    RPC_IF_ID PAPI * Ifid,
    RPC_TRANSFER_SYNTAX PAPI * Xferid,
    char PAPI * Protseq,
    char PAPI * Endpoint,
    char PAPI * NWAddress,
    twr_p_t PAPI * Tower
    );

RPC_STATUS
ExtractStringFromUntrustedPacket (
    IN BYTE *UpperBound,
    IN ULONG ClaimedStringLength,
    IN char *StringStart,
    OUT char **ExtractedString
    );

BYTE *
VerifyFloorLHSAndRHS (
    IN BYTE *FloorStart,
    IN BYTE *UpperBound,
    IN ULONG FloorNum
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\twrtypes.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    tower.c

Abstract:

    This file accompanies tower.c

Author:

    Bharat Shah  (barats) 3-25-92

Revision History:

--*/

//Towers are not DWORD or WORD aligned. Consequently we need to
//Pack these structures that are used to parse/construct towers
#pragma pack(1)

typedef struct _FLOOR_0OR1 {
   unsigned short ProtocolIdByteCount;
   byte FloorId;
   UUID Uuid;
   unsigned short MajorVersion;
   unsigned short AddressByteCount;
   unsigned short MinorVersion;
} FLOOR_0OR1;
typedef FLOOR_0OR1 PAPI UNALIGNED * PFLOOR_0OR1;

typedef struct _FLOOR_234 {
   unsigned short ProtocolIdByteCount;
   byte FloorId;
   unsigned short AddressByteCount;
   byte Data[2];
} FLOOR_234;
typedef FLOOR_234 PAPI UNALIGNED * PFLOOR_234;

typedef struct _FLOOR_2 {
   unsigned short ProtocolIdByteCount;
   byte RpcProtocol;
   unsigned short AddressByteCount;
   unsigned short RpcProtocolMinor;
} FLOOR_2;
typedef FLOOR_2 PAPI UNALIGNED * PFLOOR_2;

typedef struct _FLOOR_3 {
   unsigned short ProtocolIdByteCount;
   byte PortType;
   unsigned short AddressByteCount;
   char     EndPoint[2];
} FLOOR_3;
typedef FLOOR_3 PAPI UNALIGNED * PFLOOR_3;

typedef struct _FLOOR_4 {
   unsigned short ProtocolIdByteCount;
   byte HostType;
   unsigned short AddressByteCount;
   char Host[2];
} FLOOR_4;
typedef FLOOR_4 PAPI UNALIGNED * PFLOOR_4;


typedef struct _GENERIC_ID {
   UUID Uuid;
   unsigned short MajorVersion;
   unsigned short MinorVersion;
} GENERIC_ID;
typedef GENERIC_ID PAPI UNALIGNED * PGENERIC_ID;

//This comment to force some changes for C++
#pragma pack()

#define UUID_ENCODING     0x0D

#define TCP_IP            0x07
#define UDP_IP            0x08
#define DNA_PHASE_4       0x02
#define DNA_PHASE_5       0x03
#define MS_CN_NMP         0x0F
#define MS_LRPC           0x10

#define MS_CN_HOSTNAME    0x11
#define IP_HOSTNAME       0x09
#define AT_NBP_NAME       0x18

#define CONNECTIONLESS    0x0A
#define CONNECTIONFUL     0x0B
#define CONN_LRPC         0x0C

#define NEXTFLOOR(t,x) (t)((byte PAPI *)x + ((t)x)->ProtocolIdByteCount\
                                        + ((t)x)->AddressByteCount\
                                        + sizeof(((t)x)->ProtocolIdByteCount)\
                                        + sizeof(((t)x)->AddressByteCount))

#define NCACN_NP          0x0F   // N.B. Different on the OSF web site
#define NCACN_IP_TCP      0x07
#define NCADG_IP_UDP      0x08
#define NCACN_SPX         0x0C
#define NCADG_IPX         0x0E
#define NCACN_NB          0x12
#define NCACN_AT_DSP      0x16
#define NCADG_AT_DDP      0x17
#define NCACN_VNS_SPP     0x1A
#define NCADG_MQ          0x1D   // N.B. Not showing on the OSF web site
#define NCACN_HTTP        0x1F   // N.B. Not showing on the OSF web site


/*
  Some predefined Ids for NetBIOS
*/

#define NB_NBID        0x13
#define NB_XNSID       0x15
#define NB_IPID        0x09
#define NB_IPXID       0x0d
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\tower.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    tower.c

Abstract:

    This file contains encoding/decoding for the tower representation
    of the binding information that DCE runtime uses.

    TowerConstruct/TowerExplode will be called by the Runtime EpResolveBinding
    on the client side, TowerExplode will be called by the Endpoint Mapper
    and in addition the name service may call TowerExplode, TowerConstruct.

Author:

    Bharat Shah  (barats) 3-23-92
    KamenM      05/02/2002    Major security and cleanup changes

Revision History:

--*/
#include <precomp.hxx>
#include <epmp.h>
#include <twrtypes.h>
#include <twrproto.h>


//
// TowerVerify() defines.
//
// Note: DECnet Protocol uses 6 Floors, all others 5.
//
#define MAX_FLOOR_COUNT             6
#define MIN_FLOOR_COUNT             3

#ifndef UNALIGNED
#error UNALIGNED not defined by sysinc.h or its includes and is needed.
#endif

#pragma pack(1)


/*
   Some Lrpc specific stuff
*/

#define NP_TRANSPORTID_LRPC 0x10
#define NP_TOWERS_LRPC      0x04

// "ncalrpc" including the NULL terminator
const int LrpcProtocolSequenceLength = 8;


RPC_STATUS
Floor0or1ToId(
    IN PFLOOR_0OR1 Floor,
    OUT PGENERIC_ID Id
    )
/*++

Routine Description:

    This function extracts Xfer Syntax or If info from a
    a DCE tower Floor 0 or 1 encoding

Arguments:

    Floor - A pointer to Floor0 or Floor 1 encoding

    Id    - on output, the transfer syntax or interface id

Return Value:

    EP_S_CANT_PERFORM_OP - The Encoding for the floor [0 or 1] is incorrect.

N.B.

    Caller must have verified that the whole floor is present (i.e. we can't walk
    off the end of the buffer)

--*/
{
    if (Floor->FloorId != UUID_ENCODING)
        {
        return (EP_S_CANT_PERFORM_OP);
        }

    RpcpMemoryCopy((char PAPI *)&Id->Uuid, (char PAPI *) &Floor->Uuid,
          sizeof(UUID));

    Id->MajorVersion = Floor->MajorVersion;
    Id->MinorVersion = Floor->MinorVersion;

    return(RPC_S_OK);
}


RPC_STATUS
CopyIdToFloor(
    OUT PFLOOR_0OR1 Floor,
    IN  PGENERIC_ID Id
    )
/*++

Routine Description:

    This function constructs FLOOR 0 or 1 from the given IF-id or Transfer
    Syntax Id.

Arguments:

   Floor - Pointer to Floor 0 or 1 structure that will be constructed

   Id    - Pointer to If-id or Xfer Syntax Id.

Return Value:

  RPC_S_OK

--*/
{

    Floor->FloorId = UUID_ENCODING;
    Floor->ProtocolIdByteCount = sizeof(Floor->Uuid) + sizeof(Floor->FloorId)
                               + sizeof(Floor->MajorVersion);
    Floor->AddressByteCount  = sizeof(Floor->MinorVersion);

    RpcpMemoryCopy((char PAPI *) &Floor->Uuid, (char PAPI *) &Id->Uuid,
          sizeof(UUID));

    Floor->MajorVersion = Id->MajorVersion;
    Floor->MinorVersion = Id->MinorVersion;

    return(RPC_S_OK);
}

BYTE *
VerifyFloorLHSAndRHS (
    IN BYTE *FloorStart,
    IN BYTE *UpperBound,
    IN ULONG FloorNum
    )
/*++


Routine Description:

    Verifies that the left hand side (LHS) byte count and the 
    right hand side (RHS) byte count in the given floor are accurate
    with respect to the floor start and size (i.e. jumping from the LHS
    we go to the right hand side, and from there, to the end of the floor
    without walking off the end).

Arguments:

    FloorStart - the start of the current floor.

    UpperBound - pointer to first invalid byte after the buffer.

    FloorNum - the number of the floor. Used for debugging only

Return Value:

    The position of the next floor, or NULL if the floor fails the check.

--*/
{
    USHORT LHSBytes, RHSBytes;

    if (FloorStart + 2 >= UpperBound)
        return NULL;

    LHSBytes = *(unsigned short UNALIGNED *)FloorStart;
    if (FloorStart + (ULONG)LHSBytes + 4 >= UpperBound)      // the LHSBytes counter itself is 2 bytes, and we 
        {                               // must provide at least 2 bytes for the RHSBytes
#ifdef DEBUGRPC
        PrintToDebugger("RPC: TowerVerify(): LHS of Tower floor %d "
                        "greater than equal to FloorSize\n", FloorNum);
#endif // DEBUGRPC
        return NULL;
        }

    FloorStart += LHSBytes + 2;
    RHSBytes = *(unsigned short UNALIGNED *)FloorStart;
    if (FloorStart + (ULONG)RHSBytes + 2 > UpperBound)      // the RHSBytes counter itself is 2 bytes
        {                               
#ifdef DEBUGRPC
        PrintToDebugger("RPC: TowerVerify(): RHS of Tower floor %d "
                        "greater than equal to FloorSize\n", FloorNum);
#endif // DEBUGRPC
        return NULL;
        }

    return FloorStart + RHSBytes + 2;
}

RPC_STATUS
ExtractStringFromUntrustedPacket (
    IN BYTE *UpperBound,
    IN ULONG ClaimedStringLength,
    IN char *StringStart,
    OUT char **ExtractedString
    )
/*++


Routine Description:

    Extracts a string from untrusted packet. Verifies
    string boundaries, reasonable length (at least one character
    and no more than 1000), and null termination.

Arguments:

    UpperBound - the first invalid byte after the end of the buffer.

    ClaimedStringLength - the string length that the packet claims.

    StringStart - the alleged start of the string - untrusted.

    ExtractedString - the extracted string. Must be freed with delete. Undefined
        on failure.

Return Value:

    RPC_S_OK, RPC_S_OUT_OF_MEMORY or EP_S_CANT_PERFORM_OP

--*/
{
    char *NewString;

    if ((ClaimedStringLength < 2) || (ClaimedStringLength > 1000))
        return EP_S_CANT_PERFORM_OP;

    if (StringStart + ClaimedStringLength > (char *)UpperBound)
        return EP_S_CANT_PERFORM_OP;

    // the claimed string length includes the terminating NULL
    if (StringStart[ClaimedStringLength - 1] != '\0')
        return EP_S_CANT_PERFORM_OP;

    NewString = new char [ClaimedStringLength];
    if (NewString == NULL)
        return RPC_S_OUT_OF_MEMORY;

    RpcpMemoryCopy(NewString, StringStart, ClaimedStringLength);
    *ExtractedString = NewString;
    return RPC_S_OK;
}


RPC_STATUS
LrpcTowerConstruct(
    IN char PAPI * Endpoint,
    OUT unsigned short PAPI UNALIGNED * Floors,
    OUT unsigned long  PAPI UNALIGNED * ByteCount,
    OUT unsigned char PAPI * UNALIGNED PAPI * Tower
    )
{
    unsigned long TowerSize;
    FLOOR_234 UNALIGNED *Floor;

    int EndpointLength;

    *Floors = NP_TOWERS_LRPC;
    if ((Endpoint == NULL) || (*Endpoint == '\0'))
        {
        EndpointLength = 0;
        }
    else
        {
        EndpointLength = RpcpStringLengthA(Endpoint) + 1;
        }

    if (EndpointLength == 0)
        TowerSize = 2;
    else
        TowerSize = EndpointLength;

    TowerSize += sizeof(FLOOR_234) - 2;

    *ByteCount = TowerSize;
    if ((*Tower = (unsigned char *)I_RpcAllocate(TowerSize)) == NULL)
        {
        return (RPC_S_OUT_OF_MEMORY);
        }

    Floor = (PFLOOR_234) *Tower;

    Floor->ProtocolIdByteCount = 1;
    Floor->FloorId = (unsigned char)(NP_TRANSPORTID_LRPC & 0xFF);
    if (EndpointLength)
        {
        Floor->AddressByteCount = (unsigned short)EndpointLength;
        RpcpMemoryCopy((char PAPI *)&Floor->Data[0], Endpoint,
               EndpointLength);
        }
    else
        {
        Floor->AddressByteCount = 2;
        Floor->Data[0] = 0;
        }

    return(RPC_S_OK);
}


RPC_STATUS
LrpcTowerExplode(
    IN PFLOOR_234 Floor34,
    IN BYTE *UpperBound,
    IN ULONG RemainingFloors,
    OUT char ** Protseq, OPTIONAL
    OUT char ** Endpoint, OPTIONAL
    OUT char ** NetworkAddress OPTIONAL
    )
{
    BYTE *CurrentPosition;
    BYTE *NextFloor;
    RPC_STATUS RpcStatus;
    ULONG EndpointLength;

    // Initialize all our OUT pointers so we don't end up deleting uninitialized memory
    if (Protseq)
        *Protseq = NULL;
        
    if (Endpoint)
        *Endpoint = NULL;
      
    
    // we expect only one floor more
    if (RemainingFloors != 1)
        return EP_S_CANT_PERFORM_OP;

    if (Protseq != NULL)
        {
        *Protseq = new char[LrpcProtocolSequenceLength];
        if (*Protseq == NULL)
            {
            return(RPC_S_OUT_OF_MEMORY);
            }
        RpcpMemoryCopy(*Protseq, "ncalrpc", LrpcProtocolSequenceLength);
        }

    if (Endpoint == NULL)
        {
        return (RPC_S_OK);
        }

    CurrentPosition = (BYTE *)Floor34;
    // an endpoint must be at least two chars long (null terminator included). 
    // Since FLOOR_234 has space for 2 chars, we need to subtract one
    if (CurrentPosition + sizeof(FLOOR_234) >= UpperBound)
        return EP_S_CANT_PERFORM_OP;

    NextFloor = VerifyFloorLHSAndRHS (CurrentPosition,
        UpperBound,
        3   // FloorNum
        );
    
    if (NextFloor == NULL)
        {
        RpcStatus = EP_S_CANT_PERFORM_OP;
        goto AbortAndExit;
        }

    EndpointLength = Floor34->AddressByteCount;

    RpcStatus = ExtractStringFromUntrustedPacket (UpperBound,
        EndpointLength,
        (char *)&Floor34->Data[0],
        Endpoint
        );

    if (RpcStatus == RPC_S_OK)
        return(RPC_S_OK);
    else
        {
        // fall through to cleanup call below
        }

AbortAndExit:
    if (Protseq && *Protseq)
        delete [] *Protseq;

    if (Endpoint && *Endpoint)
        delete [] *Endpoint;

    return RpcStatus;
}


RPC_STATUS
GetProtseqAndEndpointFromFloor3(
    IN PFLOOR_234 Floor,
    IN BYTE *UpperBound,
    IN ULONG RemainingFloors,
    OUT char **Protseq, OPTIONAL
    OUT char **Endpoint, OPTIONAL
    OUT char **NWAddress OPTIONAL
    )
{
/*++

Routine Description:

    This function extracts the Protocol Sequence and Endpoint info
    from a "Lower Tower" representation

Arguments:

   Floor - Pointer to Floor2 structure.

   UpperBound - the first invalid byte after the end of the buffer.

   RemainingFloors - the number of floors remaining.

   Protseq - A pointer that will contain Protocol seq on return
             The memory will be allocated by this routine and caller
             will have to free this memory using delete. Undefined on
             failure.

   Endpoint - A pointer that will contain Endpoint on return
             The memory will be allocated by this routine and caller
             will have to free this memory using delete. Undefined on
             failure.

   NWAddress - A pointer that will contain Endpoint on return
             The memory will be allocated by this routine and caller
             will have to free this memory using delete. Undefined on
             failure.

Return Value:

  RPC_S_OK

  RPC_S_OUT_OF_MEMORY - There is no memory to return Protseq or Endpoint string

  EP_S_CANT_PERFORM_OP - Lower Tower Encoding is incorrect.

--*/

    USHORT ProtocolType;
    RPC_STATUS Status;
    BYTE *CurrentPosition;
    PFLOOR_234 Floor34;

    CurrentPosition = (BYTE *)Floor;
    if (CurrentPosition + sizeof(FLOOR_234) >= UpperBound)
        {
        return EP_S_CANT_PERFORM_OP;
        }

    Floor34 = (PFLOOR_234)VerifyFloorLHSAndRHS(CurrentPosition,
        UpperBound,
        2   // FloorNum
        );

    if (Floor34 == NULL)
        return EP_S_CANT_PERFORM_OP;

    ProtocolType = Floor->FloorId;

    if (NWAddress != 0)
        {
        *NWAddress = 0;
        }

    switch(ProtocolType)
        {

        case CONN_LRPC:
            Status = LrpcTowerExplode(Floor34, UpperBound, RemainingFloors - 1,
                                     Protseq, Endpoint, NWAddress);
            break;

        case CONNECTIONFUL:
        case CONNECTIONLESS:

            Status = OsfTowerExplode((BYTE *)Floor34, UpperBound, RemainingFloors - 1,
                                       Protseq, Endpoint, NWAddress);
            break;

        default:
            Status = EP_S_CANT_PERFORM_OP;
    }

    return(Status);
}


RPC_STATUS
TowerExplode(
    IN twr_p_t Tower,
    OUT  RPC_IF_ID *Ifid, OPTIONAL
    OUT  RPC_TRANSFER_SYNTAX *XferId, OPTIONAL
    OUT  char **Protseq, OPTIONAL
    OUT  char **Endpoint, OPTIONAL
    OUT  char **NWAddress OPTIONAL
    )
/*++


Routine Description:

    This function converts a DCE tower representation of various binding
    information to binding info that is suitable to MS runtime.
    Specically it returns Ifid, Xferid, Protseq and Endpoint information
    encoded in the tower.

Arguments:

    Tower - Tower encoding.

    Ifid  - A pointer to Ifid

    Xferid - A pointer to Xferid

    Protseq - A pointer to pointer returning Protseq

    Endpoint- A pointer to pointer returning Endpoint

Return Value:

    RPC_S_OK

    EP_S_CANT_PERFORM_OP - Error while parsing the Tower encoding

    RPC_S_OUT_OF_MEMORY - There is no memory to return Protseq and Endpoint
                          strings.
--*/
{
    PFLOOR_0OR1 Floor00;
    PFLOOR_0OR1 Floor01;
    PFLOOR_234  Floor234;
    unsigned short FloorCount;
    RPC_STATUS RpcStatus;
    BYTE *UpperBound, *LowerBound;
    BYTE *CurrentPosition;

    if (Tower == NULL)
        {
        RpcStatus = EP_S_CANT_PERFORM_OP;
        goto CleanupAndExit;
        }

    //
    // LowerBound points to Floor1
    // UpperBound points to the byte after the last Floor
    //
    LowerBound = Tower->tower_octet_string + 2; // FloorCount is 2 bytes
    UpperBound = Tower->tower_octet_string + Tower->tower_length;

    // make sure we at least have the floor count
    if (UpperBound <= LowerBound)
        {
        RpcStatus = EP_S_CANT_PERFORM_OP;
        goto CleanupAndExit;
        }

    // go to the floor count
    CurrentPosition = Tower->tower_octet_string;
    // the tower octet string immediately follows the tower_length in the IDL
    // so we know it is 4 bytes aligned. No need for unaligned here.
    FloorCount = *((USHORT *)CurrentPosition);

    if (    FloorCount > MAX_FLOOR_COUNT
         || FloorCount < MIN_FLOOR_COUNT)
        {
        #ifdef DEBUGRPC
        PrintToDebugger("RPC: TowerVerify(): Too many/few floors - %d\n",
                        FloorCount);
        #endif // DEBUGRPC
        
        RpcStatus = EP_S_CANT_PERFORM_OP;
        goto CleanupAndExit;
        }

    // skip the floor count and go to the first floor
    CurrentPosition += 2;   // floor count is 2 bytes

    if (CurrentPosition + sizeof(FLOOR_0OR1) >= UpperBound)
        {
        RpcStatus = EP_S_CANT_PERFORM_OP;
        goto CleanupAndExit;
        }

    Floor01 = (PFLOOR_0OR1)VerifyFloorLHSAndRHS(CurrentPosition,
        UpperBound,
        0       // FloorNum
        );

    if (Floor01 == NULL)
        {
        RpcStatus = EP_S_CANT_PERFORM_OP;
        goto CleanupAndExit;
        }

    Floor00 = (PFLOOR_0OR1) CurrentPosition;

    //Process Floor 0 Interface Spec.
    if (Ifid != NULL)
        {
        RpcStatus = Floor0or1ToId(Floor00, (PGENERIC_ID) Ifid);
        if (RpcStatus != RPC_S_OK)
            {
            RpcStatus = EP_S_CANT_PERFORM_OP;
            goto CleanupAndExit;
            }
        }

    CurrentPosition = (BYTE *)Floor01;
    if (CurrentPosition + sizeof(FLOOR_0OR1) >= UpperBound)
        {
        RpcStatus = EP_S_CANT_PERFORM_OP;
        goto CleanupAndExit;
        }

    Floor234 = (PFLOOR_234)VerifyFloorLHSAndRHS(CurrentPosition,
        UpperBound,
        1       // FloorNum
        );

    if (Floor234 == NULL)
        {
        RpcStatus = EP_S_CANT_PERFORM_OP;
        goto CleanupAndExit;
        }

    //Now we point to and process Floor 1 Transfer Syntax Spec.
    if (XferId != NULL)
        {
        RpcStatus = Floor0or1ToId(Floor01, (PGENERIC_ID) XferId);
        if (RpcStatus != RPC_S_OK)
            {
            RpcStatus = EP_S_CANT_PERFORM_OP;
            goto CleanupAndExit;
            }
        }

    // Now Floor234 points to Floor 2. RpcProtocol [Connect-Datagram]

    // we already did 2 floors - subtract them from the count of floors
    RpcStatus = GetProtseqAndEndpointFromFloor3(Floor234, UpperBound, FloorCount - 2, Protseq, Endpoint, NWAddress);

    // fall through with the status

CleanupAndExit:
#if DBG
    if (RpcStatus != RPC_S_OK)
        {
        DbgPrint("RPCRT4: %X: TowerExplode: Failed to decrypt tower: %X\n", 
            GetCurrentProcessId(), RpcStatus);
        }
#endif  // DBG
    return RpcStatus;
}


RPC_STATUS
TowerConstruct(
    IN RPC_IF_ID PAPI * Ifid,
    IN RPC_TRANSFER_SYNTAX PAPI * Xferid,
    IN char PAPI * RpcProtocolSequence,
    IN char PAPI * Endpoint, OPTIONAL
    IN char PAPI * NWAddress, OPTIONAL
    OUT twr_t PAPI * PAPI * Tower
    )
/*++


Routine Description:

    This function constructs a DCE tower representation from
    Protseq, Endpoint, XferId and IfId

Arguments:

    Ifid  - A pointer to Ifid

    Xferid - A pointer to Xferid

    Protseq - A pointer to Protseq

    Endpoint- A pointer to Endpoint

    Tower - The constructed tower returmed - The memory is allocated
            by  the routine and caller will have to free it.

Return Value:

    RPC_S_OK

    EP_S_CANT_PERFORM_OP - Error while parsing the Tower encoding

    RPC_S_OUT_OF_MEMORY - There is no memory to return the constructed
                          Tower.
--*/
{

    unsigned short Numfloors,  PAPI *FloorCnt;
    twr_t PAPI * Twr;
    PFLOOR_0OR1 Floor;
    PFLOOR_234  Floor234, Floor234_1;
    RPC_STATUS Status;
    unsigned long TowerLen, ByteCount;
    char PAPI * UpperTower;
    unsigned short ProtocolType;


    if ( RpcpStringCompareA(RpcProtocolSequence, "ncalrpc") == 0 )
        {
        ProtocolType = CONN_LRPC;
        Status = LrpcTowerConstruct(Endpoint, &Numfloors,
                                &ByteCount, (unsigned char **)&UpperTower);
        }
    else

        {

        if (   (RpcProtocolSequence[0] == 'n')
            && (RpcProtocolSequence[1] == 'c')
            && (RpcProtocolSequence[2] == 'a')
            && (RpcProtocolSequence[3] == 'c')
            && (RpcProtocolSequence[4] == 'n')
            && (RpcProtocolSequence[5] == '_'))
            {
            ProtocolType = CONNECTIONFUL;
            }
        else if (   (RpcProtocolSequence[0] == 'n')
            && (RpcProtocolSequence[1] == 'c')
            && (RpcProtocolSequence[2] == 'a')
            && (RpcProtocolSequence[3] == 'd')
            && (RpcProtocolSequence[4] == 'g')
            && (RpcProtocolSequence[5] == '_'))
            {
            ProtocolType = CONNECTIONLESS;
            }

        else
            {
            return(RPC_S_INVALID_RPC_PROTSEQ);
            }

        Status = OsfTowerConstruct(
                       RpcProtocolSequence,
                       Endpoint,
                       NWAddress,
                       &Numfloors,
                       &ByteCount,
                       (unsigned char **)&UpperTower
                       );
        }

    if (Status != RPC_S_OK)
        {
        return (Status);
        }

    TowerLen = 2 + ByteCount;
    TowerLen += 2 * sizeof(FLOOR_0OR1) + sizeof(FLOOR_2) ;

    if ( (*Tower = Twr = (twr_t *)I_RpcAllocate((unsigned int)TowerLen+4)) == NULL)
        {
        I_RpcFree(UpperTower);
        return(RPC_S_OUT_OF_MEMORY);
        }

    Twr->tower_length = TowerLen;

    FloorCnt = (unsigned short PAPI *)&Twr->tower_octet_string;
    *FloorCnt = Numfloors;

    Floor = (PFLOOR_0OR1)(FloorCnt+1);

    //Floor 0 - IfUuid and IfVersion
    CopyIdToFloor(Floor, (PGENERIC_ID)Ifid);
    Floor++;

    //Floor 1 - XferUuid and XferVersion
    CopyIdToFloor(Floor, (PGENERIC_ID)Xferid);

    //Floor 2
    //ProtocolId = CONNECTIONFUL/CONNECTIONLESS/LRPC and Address = 0(ushort)
    Floor234 = (PFLOOR_234) (Floor + 1);
    Floor234->ProtocolIdByteCount = 1;
    Floor234->FloorId = (byte) ProtocolType;
    Floor234->Data[0] = 0x0;
    Floor234->Data[1] = 0x0;
    Floor234->AddressByteCount = 2;

    //Floor 3,4,5.. use the tower encoded by the Transports
    Floor234_1 = NEXTFLOOR(PFLOOR_234, Floor234);

    RpcpMemoryCopy((char PAPI *)Floor234_1, (char PAPI *)UpperTower,
          (size_t)ByteCount);
    I_RpcFree(UpperTower);

    return(RPC_S_OK);
}

#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\rpc\runtime\mtrt\usvr.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1990 - 1999
//
//  File:       usvr.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

                      Microsoft OS/2 LAN Manager
                   Copyright(c) Microsoft Corp., 1990

-------------------------------------------------------------------- */
/* --------------------------------------------------------------------

File : usvr.cxx

Description :

Server test program for the RPC runtime.  This program functions as half
of the build verification test for the RPC runtime.  The other half is
the client test program.

This particular program is independent of the particular operating
system other than requiring threads support of some sort (including
mutexes).

RPC server runtime APIs:

RpcCreateServer
RpcDeleteServer
RpcAddAddress
RpcRemoveAddress
RpcAddInterface
RpcRemoveInterface
RpcMonitorAssociation
RpcQueryConfig
RpcGetCurrentCallHandle
RpcGetAssociationContext
RpcQueryCall
RpcQueryBinding
RpcQueryProtocolStack
I_RpcGetBuffer
I_RpcFreeBuffer
I_RpcSendReceive


-------------------------------------------------------------------- */
#include <precomp.hxx>
#include "pipe.h"
#include "astub.h"
#define _PNP_POWER_
#include <winsock2.h>
#include <Charconv.hxx>
#include <direct.h>

extern "C"
{
#include <iphlpapi.h>
}

/*
Transports:

    Update this to add a new transport.
*/

#define RPC_TRANSPORT_NAMEPIPE 1
#define RPC_LRPC 2
#define RPC_TRANSPORT_TCP 3
#define RPC_TRANSPORT_DNET 4
#define RPC_TRANSPORT_NETBIOS 5
#define RPC_TRANSPORT_SPX 6
#define RPC_TRANSPORT_UDP 7
#define RPC_TRANSPORT_IPX 8
#define RPC_TRANSPORT_DSP 9
#define RPC_TRANSPORT_VNS 10
#define RPC_WMSG          11
#define RPC_TRANSPORT_MSMQ 12

#define MAXLISTENTHREADS 12345
#define MAX_CALL_REQUESTS 500

#define EXTENDED_ERROR_EXCEPTION 77777

#define SIZEOUT_ASYNC_EXCEPTION (0xfffffff)

typedef DWORD
(RPCRTAPI RPC_ENTRY *SET_TEST_HOOK_FN)(
                    RPC_TEST_HOOK_ID id,
                    RPC_TEST_HOOK_FN fn
                    );

//
// Global variables.
//
BOOL fExtendedError        = FALSE;

unsigned int MinimumListenThreads  = 1;
unsigned int UseEndpointMapperFlag = 0;
unsigned int NoSecurityTests       = 0;
unsigned int DatagramFlag          = 0;
unsigned int AutoListenFlag        = 0;
unsigned int IFSecurity        = 0;
int Verbose = 0;

unsigned int WarnFlag = 0; // Flag for warning messages;
unsigned int ErrorFlag = 0; // Flag for error messages;
unsigned int TransportType;
int MaxRpcSize = 1000000;
unsigned long ulSecurityPackage = 10 ;
int FireWallFlag = 0;

char NetBiosProtocol[20] = "ncacn_nb_nb";  // NetBios transport protocol
char *TransportOption = "-namepipe";

int ServerType ;
#define SYNC_WMSG 1
#define ASYNC_WMSG 2
HWND hWnd ;
char szAppName[] = "usvr";
THREAD_IDENTIFIER CurrentTid ;

extern RPC_SERVER_INTERFACE IsabelleInterfaceInformation;


RPC_STATUS Status; // Contains the status of the last RPC API call.
I_RPC_MUTEX PrintMutex = 0; // Mutex used to serialize print operations.

#define CHUNK_SIZE   50
#define NUM_CHUNKS 100
#define BUFF_SIZE 100

typedef int pipe_element_t ;

typedef struct {
    void (*Pull) (
            PIPE_STATE *state,
            pipe_element_t *buffer,
            int max_buf,
            int *actual_transfer_count
            ) ;

    void (*Push) (
        PIPE_STATE *state,
        pipe_element_t *buffer,
        int max_buf
        ) ;

    PIPE_STATE *state ;
    } pipe_t ;

int ShutdownCalled ;
unsigned int IsabelleErrors = 0;
unsigned int HelgaErrors = 0;
unsigned int SylviaErrors = 0;

SET_TEST_HOOK_FN SetTestHookFn;

//
// forward declarations
//


extern void
Async (
    ) ;


extern void
SendAck (
    ) ;


void
DgTransport (
    );

void
SecurityErrorWrapper(
    int subtest
    );

DWORD
GenericServerListen(
    char * name,
    int endpoint
    );

DWORD
GenericServerUnlisten(
    char * name
    );

//
// function definitions
//

void
ApiError ( // An API error occured; we just print a message.
    IN char * Routine, // The routine which called the API.
    IN char * API,
    IN RPC_STATUS status
    )
{
    if (ErrorFlag)
        {
        I_RpcRequestMutex(&PrintMutex);
        PrintToConsole("    ApiError in %s (%s = %u)\n",Routine,API,status);
        I_RpcClearMutex(PrintMutex);
        }
}

void
PauseExecution (
    unsigned long milliseconds
    )
{

    Sleep(milliseconds);

}

void
CompleteReceive(
    PRPC_MESSAGE Callee
    )
{
    DWORD size = 0;

    Callee->RpcFlags |=  RPC_BUFFER_EXTRA;
    Callee->RpcFlags &= ~RPC_BUFFER_PARTIAL;

    if ((Callee->RpcFlags & RPC_BUFFER_COMPLETE) == 0)
        {
        Status =  I_RpcReceive(Callee, size) ;
        if (Status)
            {
            ApiError("CompleteReceive", "I_RpcReceive", Status) ;
            }
        }

    ASSERT(Callee->RpcFlags & RPC_BUFFER_COMPLETE);
}

RPC_STATUS
RpcServerUseProtseqEpWrapper (
    IN unsigned char PAPI * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned char PAPI * Endpoint,
    IN void PAPI * SecurityDescriptor
    )
{
    RPC_POLICY Policy ;

    if (FireWallFlag)
        {
        Policy.Length = sizeof(RPC_POLICY) ;
        Policy.NICFlags = RPC_C_BIND_TO_ALL_NICS;
        Policy.EndpointFlags = RPC_C_DONT_FAIL;
        return RpcServerUseProtseqEpExA(Protseq, MaxCalls, Endpoint,
                        SecurityDescriptor,&Policy) ;
        }
    else
        {
        return RpcServerUseProtseqEpA(Protseq, MaxCalls, Endpoint, SecurityDescriptor) ;
        }
}

RPC_STATUS
RpcServerUseProtseqWrapper (
    IN unsigned char PAPI * Protseq,
    IN unsigned int MaxCalls,
    IN void PAPI * SecurityDescriptor OPTIONAL
    )
{
    RPC_POLICY Policy ;

    if (FireWallFlag)
        {
        Policy.Length = sizeof(RPC_POLICY) ;
        Policy.NICFlags = RPC_C_BIND_TO_ALL_NICS ;
        return RpcServerUseProtseqExA(Protseq, MaxCalls, SecurityDescriptor, &Policy) ;
        }
    else
        {
        return RpcServerUseProtseqA(Protseq, MaxCalls, SecurityDescriptor) ;
        }
}

RPC_STATUS
RpcServerUseAllProtseqsWrapper (
    IN unsigned int MaxCalls,
    IN void PAPI * SecurityDescriptor OPTIONAL
    )
{
    RPC_POLICY Policy ;

    if (FireWallFlag)
        {
        Policy.Length = sizeof(RPC_POLICY) ;
        Policy.NICFlags = RPC_C_BIND_TO_ALL_NICS ;
        return RpcServerUseAllProtseqsEx(MaxCalls, SecurityDescriptor, &Policy) ;
        }
    else
        {
        return RpcServerUseAllProtseqs(MaxCalls, SecurityDescriptor) ;
        }
}

RPC_STATUS
RpcServerUseProtseqIfWrapper (
    IN unsigned char PAPI * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void PAPI * SecurityDescriptor
    )
{
    RPC_POLICY Policy ;

    if (FireWallFlag)
        {
        Policy.Length = sizeof(RPC_POLICY) ;
        Policy.NICFlags = RPC_C_BIND_TO_ALL_NICS ;
        return RpcServerUseProtseqIfExA(Protseq, MaxCalls, IfSpec,
                    SecurityDescriptor, &Policy) ;
        }
    else
        {
        return RpcServerUseProtseqIfA(Protseq, MaxCalls, IfSpec, SecurityDescriptor) ;
        }
}

RPC_STATUS
RpcServerUseAllProtseqsIfWrapper (
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void PAPI * SecurityDescriptor OPTIONAL
    )
{
    RPC_POLICY Policy ;

    if (FireWallFlag)
        {
        Policy.Length = sizeof(RPC_POLICY) ;
        Policy.NICFlags = RPC_C_BIND_TO_ALL_NICS ;
        return RpcServerUseAllProtseqsIfEx(MaxCalls, IfSpec, SecurityDescriptor, &Policy) ;
        }
    else
        {
        return RpcServerUseAllProtseqsIf(MaxCalls, IfSpec, SecurityDescriptor) ;
        }
}

#if 0
void
GlobalMutexRequest (
    void
    )
{
    I_RpcRequestMutex(&PrintMutex);
}

void
GlobalMutexClear (
    void
    )
{
    I_RpcClearMutex(PrintMutex);
}
#endif

void
OtherError ( // Some other error occured; again, we just print a message.
    IN char * Routine, // The routine where the error occured.
    IN char * Message
    )
{
    if (ErrorFlag)
        {
        I_RpcRequestMutex(&PrintMutex);
        PrintToConsole("    Error in %s (%s)\n",Routine,Message);
        I_RpcClearMutex(PrintMutex);
        }
}

void
Shutdown ( // Awaken the thread waiting on WaitForShutdown.
    )
{
    Status = RpcMgmtStopServerListening(0);
    if (Status)
        {
        ApiError("Shutdown","RpcMgmtStopServerListening",Status);
        }
    ShutdownCalled = 1 ;
}

RPC_STATUS
IfCallbackFunction(
    IN RPC_IF_HANDLE  InterfaceUuid,
    IN void *Context
    )
{
    return (RPC_S_OK) ;
}

RPC_STATUS
stub_RegisterIf (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID PAPI * MgrTypeUuid OPTIONAL,
    IN RPC_MGR_EPV PAPI * MgrEpv OPTIONAL
    )
{
    unsigned int Flags = 0;

    if (AutoListenFlag)
        {
        Flags |= RPC_IF_AUTOLISTEN ;
        ShutdownCalled = 0 ;
        }

    if (IFSecurity)
        {
        Flags |= RPC_IF_ALLOW_SECURE_ONLY;
        }

    return RpcServerRegisterIf2(IfSpec, MgrTypeUuid, MgrEpv,
                                               Flags, 1000, MaxRpcSize, 0);
}

RPC_STATUS
stub_ServerListen (
    IN unsigned int MinimumCallThreads,
    IN unsigned int MaxCalls,
    IN unsigned int DontWait
    )
{
    if (AutoListenFlag)
        {
        while (ShutdownCalled == 0)
            {
            PauseExecution(500) ;
            }
        return (RPC_S_OK) ;
        }
    else
        {
        return RpcServerListen(MinimumCallThreads, MaxCalls, DontWait) ;
        }
}

void IsabelleError (
    )
{
    IsabelleErrors += 1 ;
}

void HelgaError (
    )
{
    HelgaErrors += 1 ;
}

void SylviaError (
    )
{
    SylviaErrors += 1 ;
}

#define SIGFRIED 0
#define ELLIOTMINIMIZE 1
#define ELLIOTMAXIMIZE 2
#define ELLIOTNORMAL 3
#define ANDROMIDA 4
#define FREDRICK 7
#define ISABELLENORMAL 10
#define ISABELLEMINIMIZE 11
#define ISABELLEMAXIMIZE 12
#define CHRISTOPHER 13
#define CHRISTOPHERHELGA 14
#define CHRISTOPHERISABELLE 15
#define TYLER 17
#define CHRISTOPHERMUSTFAILONE 18
#define CHRISTOPHERMUSTFAILTWO 19
#define RICHARD 20
#define RICHARDHELPER 21
#define DAVIDFIRST 22
#define DAVIDSECOND 23
#define BARTHOLOMEW 24
#define GRANT 25
#define HERMAN 26
#define IVAN 27
#define JASON 28
#define KENNETH 29
#define TESTYIELD 30
#define SPIPE TESTYIELD
#define SECURITY_ERROR TESTYIELD


/*
Transports:

    Update this to add a new transport.
*/

char * NamepipeAddresses [] =
{
    "\\pipe\\sigfried",
    "\\pipe\\elliotmi",
    "\\pipe\\elliotma",
    "\\pipe\\elliotno",
    "\\pipe\\andromno",
    0,
    0,
    "\\pipe\\fredrick",
    0,
    0,
    "\\pipe\\isabelno",
    "\\pipe\\isabelmi",
    "\\pipe\\isabelma",
    "\\pipe\\christ",
    "\\pipe\\zippyhe",
    "\\pipe\\zippyis",
    0,
    "\\pipe\\tyler",
    "\\\blippo",
    "\\\\\\chrismft",
    "\\pipe\\richard",
    "\\pipe\\richardh",
    "\\pipe\\david1",
    "\\pipe\\david2",
    "\\pipe\\bart",
    "\\pipe\\grant",
    "\\pipe\\herman",
    "\\pipe\\ivan",
    "\\pipe\\jason",
    "\\pipe\\kenneth",
    "\\pipe\\testyield"
};

char * DspAddresses [] =
{
    "\\pipe\\sigfried",
    "\\pipe\\elliotmi",
    "\\pipe\\elliotma",
    "\\pipe\\elliotno",
    "\\pipe\\andromno",
    0,
    0,
    "\\pipe\\fredrick",
    0,
    0,
    "\\pipe\\isabelno",
    "\\pipe\\isabelmi",
    "\\pipe\\isabelma",
    "\\pipe\\christ",
    "\\pipe\\zippyhe",
    "\\pipe\\zippyis",
    0,
    "\\pipe\\tyler",
    "",
    "",
    "\\pipe\\richard",
    "\\pipe\\richardh",
    "\\pipe\\david1",
    "\\pipe\\david2",
    "\\pipe\\bart",
    "\\pipe\\grant",
    "\\pipe\\herman",
    "\\pipe\\ivan",
    "\\pipe\\jason",
    "\\pipe\\kenneth",
    "\\pipe\\testyield"
};

char * NetBiosAddresses [] =
{
    "201",    // sigfried
    "202",    // elliotmi
    "203",    // elliotma
    "204",    // elliotno
    "205",    // andromno
    0,
    0,
    "206",    // fredrick
    0,
    0,
    "207",    // isabelno
    "208",    // isabelmi
    "209",    // isabelma
    "210",    // christ
    "211",    // zippyhe
    "212",    // zippyis
    0,
    "214",    // tyler
    "300",    // christ fail 1
    "BadName",// christ fail 2
    "215",    // richard
    "216",    // richardh
    "217",    // david1
    "218",    // david2
    "219",    // bart
    "220",    // grant
    "221",    // herman
    "222",    // ivan
    "223",    // jason
    "224",     // kenneth
    "225"     //testyield
};

char * TCPAddresses [] =
{
    "2025", // SIGFRIED
    "2026", // ELLIOTMINIMIZE
    "2027", // ELLIOTMAXIMIZE
    "2028", // ELLIOTNORMAL
    "2029", // ANDROMIDA
    0,
    0,
    "2032", // FREDRICK
    0,
    0,
    "2035", // ISABELLENORMAL
    "2036", // ISABELLEMINIMIZE
    "2037", // ISABELLEMAXIMIZE
    "2038", // CHRISTOPHER
    "2039", // CHRISTOPHERHELGA
    "2040", // CHRISTOPHERISABELLE
    0,
    "2042", // TYLER
    "chrismfo",
    "chrismft",
    "2043", // RICHARD
    "2044", // RICHARDHELPER
    "2045", // D1
    "2046", // D2
    "2047", // BARTHOLOMEW
    "2048", // GRANT
    "2049", // HERMAN
    "2050", // IVAN
    "2051", // JASON
    "2052",  // KENNETH
    "2053"  // TESTYIELD
};

char * UDPAddresses [] =
{
    "2025", // SIGFRIED
    "2026", // ELLIOTMINIMIZE
    "2027", // ELLIOTMAXIMIZE
    "2028", // ELLIOTNORMAL
    "2029", // ANDROMIDA
    0,
    0,
    "2032", // FREDRICK
    0,
    0,
    "2035", // ISABELLENORMAL
    "2036", // ISABELLEMINIMIZE
    "2037", // ISABELLEMAXIMIZE
    "2038", // CHRISTOPHER
    "2039", // CHRISTOPHERHELGA
    "2040", // CHRISTOPHERISABELLE
    0,
    "2042", // TYLER
    "chrismfo",
    "chrismft",
    "2043", // RICHARD
    "2044", // RICHARDHELPER
    "2045", // D1
    "2046", // D2
    "2047", // BARTHOLOMEW
    "2048", // GRANT
    "2049", // HERMAN
    "2050", // IVAN
    "2051", // JASON
    "2052",  // KENNETH
    "2053"  // TESTYIELD
};

char * SPCAddresses [] =
{
    "sigfried",
    "elliotminimize",
    "elliotmaximize",
    "elliotnormal",
    "andromida",
    0,
    0,
    "fredrick",
    0,
    0,
    "isabellenormal",
    "isabelleminimize",
    "isabellemaximize",
    "christopher",
    "christopherhelga",
    "christopherisabelle",
    0,
    "tyler",
    "\\christophermustfailone",
    "christopher\\mustfailtwo",
    "richard",
    "richardhelper",
    "davidfirst",
    "davidsecond",
    "bartholomew",
    "grant",
    "herman",
    "ivan",
    "jason",
    "kenneth",
    "testyield"
};

char * SPXAddresses [] =
{
    "5000",    // sigfried
    "5001",    // elliotmi
    "5002",    // elliotma
    "5003",    // elliotno
    "5004",    // andromno
    "5005",
    "5006",
    "5007",    // fredrick
    "5008",
    "5009",
    "5010",    // isabelno
    "5011",    // isabelmi
    "5012",    // isabelma
    "5013",    // christ
    "5014",    // zippyhe
    "5015",    // zippyis
    "5016",
    "5017",    // tyler
    "hello",    // christ fail 1
    "50195019",    // christ fail 2
    "5020",    // richard
    "5021",    // richardh
    "5022",    // david1
    "5023",    // david2
    "5024",    // bart
    "5025",    // grant
    "5026",    // herman
    "5027",    // ivan
    "5028",    // jason
    "5029",     // kenneth
    "5030"     // testyield
};

char * IPXAddresses [] =
{
    "5000",    // sigfried
    "5001",    // elliotmi
    "5002",    // elliotma
    "5003",    // elliotno
    "5004",    // andromno
    "5005",
    "5006",
    "5007",    // fredrick
    "5008",
    "5009",
    "5010",    // isabelno
    "5011",    // isabelmi
    "5012",    // isabelma
    "5013",    // christ
    "5014",    // zippyhe
    "5015",    // zippyis
    "5016",
    "5017",    // tyler
    "hello",    // christ fail 1
    "50195019",    // christ fail 2
    "5020",    // richard
    "5021",    // richardh
    "5022",    // david1
    "5023",    // david2
    "5024",    // bart
    "5025",    // grant
    "5026",    // herman
    "5027",    // ivan
    "5028",    // jason
    "5029",     // kenneth
    "5030"     // testyield
};


char * VNSAddresses [] =
{
    "250",    // sigfried
    "251",    // elliotmi
    "252",    // elliotma
    "253",    // elliotno
    "254",    // andromno
    "255",
    "256",
    "257",    // fredrick
    "258",
    "259",
    "260",    // isabelno
    "261",    // isabelmi
    "262",    // isabelma
    "263",    // christ
    "264",    // zippyhe
    "265",    // zippyis
    "266",
    "267",    // tyler
    "hello",    // christ fail 1
    "50195019",    // christ fail 2
    "270",    // richard
    "271",    // richardh
    "272",    // david1
    "273",    // david2
    "274",    // bart
    "275",    // grant
    "276",    // herman
    "277",    // ivan
    "278",    // jason
    "279",     // kenneth
    "280"     // testyield
};

char * MSMQAddresses [] =
{
    "SIGFRIED",
    "ELLIOTMINIMIZE",
    "ELLIOTMAXIMIZE",
    "ELLIOTNORMAL",
    "ANDROMIDA",
    0,
    0,
    "FREDRICK",
    0,
    0,
    "ISABELLENORMAL",
    "ISABELLEMINIMIZE",
    "ISABELLEMAXIMIZE",
    "CHRISTOPHER",
    "CHRISTOPHERHELGA",
    "CHRISTOPHERISABELLE",
    0,
    "TYLER",
    " \\  \\  \\chrismfo",
    "chr\\\\\\\\  $$$$ismft",
    "RICHARD",
    "RICHARDHELPER",
    "D1",
    "D2",
    "BARTHOLOMEW",
    "GRANT",
    "HERMAN",
    "IVAN",
    "JASON",
    "KENNETH",
    "TESTYIELD"
};



unsigned char *
GetProtocolSequence (
    )
/*++

Routine Description:

    This routine is used to obtain an rpc protocol sequence.

Return Value:

    A pointer to an rpc protocol sequence is returned.  This pointer
    should not be freed.

Transports:

    Update this to add a new transport.

--*/
{
    if (TransportType == RPC_TRANSPORT_NAMEPIPE)
        return((unsigned char *) "ncacn_np");

    if (TransportType == RPC_LRPC)
        {
        return((unsigned char *) "ncalrpc");
        }

    if (TransportType == RPC_TRANSPORT_NETBIOS)
        return((unsigned char *) NetBiosProtocol);

    if (TransportType == RPC_TRANSPORT_SPX)
        return((unsigned char *) "ncacn_spx");

    if (TransportType == RPC_TRANSPORT_TCP)
        return((unsigned char *) "ncacn_ip_tcp");

    if (TransportType == RPC_TRANSPORT_UDP)
        return((unsigned char *) "ncadg_ip_udp");

    if (TransportType == RPC_TRANSPORT_IPX)
        return((unsigned char *) "ncadg_ipx");

    if (TransportType == RPC_TRANSPORT_DSP)
            return((unsigned char *) "ncacn_at_dsp") ;

    if (TransportType == RPC_TRANSPORT_VNS)
                return((unsigned char *) "ncacn_vns_spp") ;

    if (TransportType == RPC_TRANSPORT_MSMQ)
                return((unsigned char *) "ncadg_mq") ;

    return(0);
}


unsigned char *
GetEndpoint (
    IN unsigned int Endpoint
    )
/*++

Routine Description:

    This routine is used to obtain the endpoint corresponding to a
    give endpoint index.

Arguments:

    Endpoint - Supplies an index into a table of endpoints.

Return Value:

    A pointer to an endpoint from the table of endpoints will be returned.

Transports:

    Update this to add a new transport.

--*/
{
    if (TransportType == RPC_TRANSPORT_NAMEPIPE)
        return((unsigned char *) NamepipeAddresses[Endpoint]);

    else if (TransportType == RPC_TRANSPORT_NETBIOS)
        return((unsigned char *) NetBiosAddresses[Endpoint]);

    else if (TransportType == RPC_TRANSPORT_TCP)
        return((unsigned char *) TCPAddresses[Endpoint]);

    else if (TransportType == RPC_TRANSPORT_UDP)
        return((unsigned char *) UDPAddresses[Endpoint]);

    else if ((TransportType == RPC_LRPC) || (TransportType == RPC_WMSG))
        return((unsigned char *) SPCAddresses[Endpoint]);

    else if (TransportType == RPC_TRANSPORT_SPX)
        return((unsigned char *) SPXAddresses[Endpoint]);

    else if (TransportType == RPC_TRANSPORT_IPX)
        return((unsigned char *) IPXAddresses[Endpoint]);

    else if (TransportType == RPC_TRANSPORT_VNS)
        return((unsigned char *) VNSAddresses[Endpoint]);

    else if (TransportType == RPC_TRANSPORT_DSP)
                return ((unsigned char *) DspAddresses[Endpoint]) ;

    else if (TransportType == RPC_TRANSPORT_MSMQ)
                return ((unsigned char *) MSMQAddresses[Endpoint]) ;

    return(0);
}


/* --------------------------------------------------------------------

Helga Interface

-------------------------------------------------------------------- */

unsigned int HelgaCheckManagerEpv = 0;
RPC_MGR_EPV PAPI * HelgaManagerEpv;
unsigned int HelgaCheckObject = 0;
unsigned short HelgaMagicNumber;


int
CheckUuidValue (
    IN unsigned short MagicNumber,
    OUT UUID PAPI * Uuid
    )
/*++

Routine Description:

    This routine is used to check that a generated uuid value is correct.

Arguments:

    MagicNumber - Supplies a magic number which will be used to
        check a generated uuid.

    Uuid - Supplies a generated uuid to check.

Return Value:

    Zero will be returned if the uuid value is correct; otherwise, non-zero
    will be returned.

--*/
{
    if ( Uuid->Data1 != ((unsigned long) MagicNumber)
                * ((unsigned long) MagicNumber))
        return(1);
    if ( Uuid->Data2 != MagicNumber )
        return(1);
    if ( Uuid->Data3 != MagicNumber / 2 )
        return(1);
    if ( Uuid->Data4[0] != MagicNumber % 256 )
        return(1);
    if ( Uuid->Data4[1] != MagicNumber % 257 )
        return(1);
    if ( Uuid->Data4[2] != MagicNumber % 258 )
        return(1);
    if ( Uuid->Data4[3] != MagicNumber % 259 )
        return(1);
    if ( Uuid->Data4[4] != MagicNumber % 260 )
        return(1);
    if ( Uuid->Data4[5] != MagicNumber % 261 )
        return(1);
    if ( Uuid->Data4[6] != MagicNumber % 262 )
        return(1);
    if ( Uuid->Data4[7] != MagicNumber % 263 )
        return(1);
    return(0);
}


void
InitializeBuffer (
    IN OUT void PAPI * Buffer,
    IN unsigned int BufferLength
    )
/*++

Routine Description:

    This routine is used to initialize the buffer; the first long in the
    buffer is set to be the length of the buffer.  The rest of the buffer
    is initialized with a pattern which will be checked by the receiver.

Arguments:

    Buffer - Supplies the buffer to be initialized.

    BufferLength - Supplies the length of the buffer.

--*/
{
    unsigned long PAPI * Length;
    unsigned char PAPI * BufferScan;
    static unsigned char InitialValue = 69;
    unsigned char Value;

    Length = (unsigned long PAPI *) Buffer;
    *Length = BufferLength;
    Value = InitialValue;
    InitialValue += 1;

    for (BufferScan = (unsigned char PAPI *) (Length + 1), BufferLength -= 4;
        BufferLength > 0; BufferLength--, BufferScan++, Value++)
        *BufferScan = Value;
}


int
CheckBuffer (
    IN void PAPI * Buffer,
    IN unsigned long BufferLength
    )
/*++

Routine Description:

    We need to check that the correct bytes were sent.  We do not check
    the length of the buffer.

Arguments:

    Buffer - Supplies the buffer to be checked.

    BufferLength - Supplies the length of the buffer to be checked.

Return Value:

    A value of zero will be returned if the buffer contains the correct
    bytes; otherwise, non-zero will be returned.

--*/
{
    unsigned long PAPI * Length;
    unsigned char PAPI * BufferScan;
    unsigned char Value;

    Length = (unsigned long PAPI *) Buffer;

    for (BufferScan = (unsigned char PAPI *) (Length + 1),
                Value = *BufferScan, BufferLength -= 4;
                BufferLength > 0; BufferLength--, BufferScan++, Value++)
        {
        if (*BufferScan != Value)
            {
            return(1);
            }
        }

    return(0);
}



int
CheckInitialBuffer (
    IN void PAPI * Buffer,
    IN unsigned long BufferLength,
    OUT unsigned char * pNextValue
    )
/*++

Routine Description:

    We need to check that the correct bytes were sent.  We do not check
    the length of the buffer.

Arguments:

    Buffer - Supplies the buffer to be checked.

    BufferLength - Supplies the length of the buffer to be checked.

Return Value:

    A value of zero will be returned if the buffer contains the correct
    bytes; otherwise, non-zero will be returned.

--*/
{
    unsigned long PAPI * Length;
    unsigned char PAPI * BufferScan;
    unsigned char Value;

    Length = (unsigned long PAPI *) Buffer;

    for (BufferScan = (unsigned char PAPI *) (Length + 1),
                Value = *BufferScan, BufferLength -= 4;
                BufferLength > 0; BufferLength--, BufferScan++, Value++)
        {
        if (*BufferScan != Value)
            {
            return(1);
            }
        }

    *pNextValue = Value;

    return(0);
}



int
CheckContinuedBuffer (
    IN void PAPI * Buffer,
    IN unsigned long BufferLength,
    IN  unsigned char BeginningValue,
    OUT unsigned char * pNextValue
    )
/*++

Routine Description:

    We need to check that the correct bytes were sent.  We do not check
    the length of the buffer.

Arguments:

    Buffer - Supplies the buffer to be checked.

    BufferLength - Supplies the length of the buffer to be checked.

Return Value:

    A value of zero will be returned if the buffer contains the correct
    bytes; otherwise, non-zero will be returned.

    *pValue

--*/
{
    unsigned long PAPI * Length;
    unsigned char PAPI * BufferScan;
    unsigned char Value;

    for (BufferScan = (unsigned char PAPI *) Buffer, Value = BeginningValue;
         BufferLength > 0;
         BufferLength--, BufferScan++, Value++)
        {
        if (*BufferScan != Value)
            {
            return(1);
            }
        }

    *pNextValue = Value;

    return(0);
}


extern RPC_DISPATCH_TABLE HelgaDispatchTable;

RPC_PROTSEQ_ENDPOINT HelgaRpcProtseqEndpoint[] =
{
    {(unsigned char *) "ncacn_np",
#ifdef WIN32RPC
     (unsigned char *) "\\pipe\\zippyhe"},
#else // WIN32RPC
     (unsigned char *) "\\device\\namedpipe\\christopherhelga"},
#endif // WIN32RPC
    {(unsigned char *) "ncacn_ip_tcp", (unsigned char *) "2039"},
    {(unsigned char *) "ncadg_ip_udp", (unsigned char *) "2039"},
    {(unsigned char *) "ncalrpc", (unsigned char *) "christopherhelga"},
    {(unsigned char *) "ncacn_nb_nb", (unsigned char *) "211"},
    {(unsigned char *) "ncacn_spx", (unsigned char *) "5014"},
    {(unsigned char *) "ncadg_ipx", (unsigned char *) "5014"},
    {(unsigned char *) "ncacn_vns_spp", (unsigned char *) "264"},
    {(unsigned char *) "ncacn_at_dsp",(unsigned char *) "\\pipe\\zippyhe"},
    {(unsigned char *) "ncadg_mq",(unsigned char *) "christopherhelga"}
};

RPC_SERVER_INTERFACE HelgaInterfaceInformation =
{
    sizeof(RPC_SERVER_INTERFACE),
    {{1,2,2,{3,3,3,3,3,3,3,3}},
     {1,1}},
    {{0x8A885D04, 0x1CEB, 0x11C9, {0x9F, 0xE8, 0x08, 0x00, 0x2B, 0x10, 0x48, 0x60}},
     {2, 0}},
    &HelgaDispatchTable,
    sizeof(HelgaRpcProtseqEndpoint) / sizeof(RPC_PROTSEQ_ENDPOINT),
    HelgaRpcProtseqEndpoint,
    NULL,
    NULL,
    RPC_INTERFACE_HAS_PIPES
};

void __RPC_STUB
HelgaStub (
    PRPC_MESSAGE Callee
    )
{
    UUID ObjectUuid;

    CompleteReceive(Callee) ;

    if ( HelgaCheckObject != 0 )
        {
        Status = RpcBindingInqObject(Callee->Handle, &ObjectUuid);
        if (Status)
            {
            ApiError("HelgaStub", "RpcBindingInqObject", Status);
            HelgaError();
            }
        else if ( CheckUuidValue(HelgaMagicNumber, &ObjectUuid) != 0 )
            {
            OtherError("HelgaStub", "CheckUuidValue() != 0");
            HelgaError();
            }

        Status = RpcBindingInqObject(0, &ObjectUuid);  // zero handle
        if (Status)
            {
            ApiError("HelgaStub", "RpcBindingInqObject", Status);
            HelgaError();
            }
        else if ( CheckUuidValue(HelgaMagicNumber, &ObjectUuid) != 0 )
            {
            OtherError("HelgaStub", "CheckUuidValue() != 0");
            HelgaError();
            }
        }
    HelgaMagicNumber += 1;

    if ( Callee->ProcNum != 0 )
        {
        OtherError("HelgaStub", "Callee->ProcNum != 0");
        HelgaError();
        }

    if ( memcmp(Callee->RpcInterfaceInformation, &HelgaInterfaceInformation,
                sizeof(HelgaInterfaceInformation)) != 0 )
        {
        OtherError("HelgaStub",
                "Callee->RpcInteraceInformation != &HelgaInterfaceInformation");
        HelgaError();
        }

    if ( HelgaCheckManagerEpv != 0 )
        {
        if ( Callee->ManagerEpv != HelgaManagerEpv )
            {
            OtherError("HelgaStub", "Callee->ManagerEpv != HelgaManagerEpv");
            HelgaError();
            }
        }

    if (Callee->BufferLength != 0)
        {
        OtherError("HelgaStub","*BufferLength != 0");
        HelgaError();
        }

    Callee->BufferLength = 0;

    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("HelgaStub","I_RpcGetBuffer",Status);
        HelgaError();
        }
}

void __RPC_STUB
HelgaINStub (
    PRPC_MESSAGE Callee
    )
{
    unsigned long Length;
    UUID ObjectUuid;

    if ( HelgaCheckObject != 0 )
        {
        Status = RpcBindingInqObject(Callee->Handle, &ObjectUuid);
        if (Status)
            {
            ApiError("HelgaINStub", "RpcBindingInqObject", Status);
            HelgaError();
            }
        else if ( CheckUuidValue(HelgaMagicNumber, &ObjectUuid) != 0 )
            {
            OtherError("HelgaINStub", "CheckUuidValue() != 0");
            HelgaError();
            }
        }
    HelgaMagicNumber += 1;

    if ( Callee->ProcNum != 1 )
        {
        OtherError("HelgaINStub", "Callee->ProcNum != 0");
        HelgaError();
        }

    if ( memcmp(Callee->RpcInterfaceInformation, &HelgaInterfaceInformation,
                sizeof(HelgaInterfaceInformation)) != 0 )
        {
        OtherError("HelgaINStub",
                "Callee->RpcInteraceInformation != &HelgaInterfaceInformation");
        HelgaError();
        }

    if ( HelgaCheckManagerEpv != 0 )
        {
        if ( Callee->ManagerEpv != HelgaManagerEpv )
            {
            OtherError("HelgaINStub", "Callee->ManagerEpv != HelgaManagerEpv");
            HelgaError();
            }
        }

    //
    // Check the data we have so far.
    //
    Length = *(unsigned long *) Callee->Buffer;
    if (Length < Callee->BufferLength)
        {
        OtherError("HelgaINStub","*Length < *BufferLength");
        HelgaError();
        }

    if (0 == (Callee->RpcFlags & RPC_BUFFER_COMPLETE))
        {
        CompleteReceive(Callee) ;
        }

    if (Length != Callee->BufferLength)
        {
        OtherError("HelgaINStub","incomplete buffer marked as complete");
        HelgaError();
        }

    unsigned char InitialValue;
    if (CheckInitialBuffer(Callee->Buffer, Callee->BufferLength, &InitialValue) != 0)
        {
        OtherError("HelgaINStub","CheckBuffer Failed");
        HelgaError();
        }

    //
    // The [out] buffer.
    //
    Callee->BufferLength = 0;

    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("HelgaINStub","I_RpcGetBuffer",Status);
        HelgaError();
        }
}

void __RPC_STUB
HelgaOUTStub (
    PRPC_MESSAGE Callee
    )
{
    unsigned long * Length;
    unsigned int Size;
    UUID ObjectUuid;

    CompleteReceive(Callee) ;

    if ( HelgaCheckObject != 0 )
        {
        Status = RpcBindingInqObject(Callee->Handle, &ObjectUuid);
        if (Status)
            {
            ApiError("HelgaOUTStub", "RpcBindingInqObject", Status);
            HelgaError();
            }
        else if ( CheckUuidValue(HelgaMagicNumber, &ObjectUuid) != 0 )
            {
            OtherError("HelgaOUTStub", "CheckUuidValue() != 0");
            HelgaError();
            }
        }
    HelgaMagicNumber += 1;

    if ( Callee->ProcNum != 2 )
        {
        OtherError("HelgaOUTStub", "Callee->ProcNum != 0");
        HelgaError();
        }

    if ( memcmp(Callee->RpcInterfaceInformation, &HelgaInterfaceInformation,
                sizeof(HelgaInterfaceInformation)) != 0 )
        {
        OtherError("HelgaOUTStub",
                "Callee->RpcInteraceInformation != &HelgaInterfaceInformation");
        HelgaError();
        }

    if ( HelgaCheckManagerEpv != 0 )
        {
        if ( Callee->ManagerEpv != HelgaManagerEpv )
            {
            OtherError("HelgaOUTStub", "Callee->ManagerEpv != HelgaManagerEpv");
            HelgaError();
            }
        }

    if (Callee->BufferLength != sizeof(unsigned long))
        {
        //
        // secure datagram calls round the stub data length to a multiple
        // of eight.
        //
        if (!DatagramFlag || Callee->BufferLength != 8)
            {
            OtherError("HelgaOUTStub","*BufferLength != sizeof(unsigned int)");
            HelgaError();
            }
        }

    Length = (unsigned long *) Callee->Buffer;
    Size = (unsigned int) *Length;
    Callee->BufferLength = Size;

    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("HelgaOUTStub","I_RpcGetBuffer",Status);
        HelgaError();
        }
    else
        {
        InitializeBuffer(Callee->Buffer, Size);
        }
}

void __RPC_STUB
HelgaINOUTStub (
    PRPC_MESSAGE Callee
    )
{
    unsigned long Length;
    UUID ObjectUuid;

    if ( HelgaCheckObject != 0 )
        {
        Status = RpcBindingInqObject(Callee->Handle, &ObjectUuid);
        if (Status)
            {
            ApiError("HelgaINOUTStub", "RpcBindingInqObject", Status);
            HelgaError();
            }
        else if ( CheckUuidValue(HelgaMagicNumber, &ObjectUuid) != 0 )
            {
            OtherError("HelgaINOUTStub", "CheckUuidValue() != 0");
            HelgaError();
            }
        }
    HelgaMagicNumber += 1;

    if ( Callee->ProcNum != 3 )
        {
        OtherError("HelgaINOUTStub", "Callee->ProcNum != 0");
        HelgaError();
        }

    if ( memcmp(Callee->RpcInterfaceInformation, &HelgaInterfaceInformation,
                sizeof(HelgaInterfaceInformation)) != 0 )
        {
        OtherError("HelgaINOUTStub",
                "Callee->RpcInteraceInformation != &HelgaInterfaceInformation");
        HelgaError();
        }

    if ( HelgaCheckManagerEpv != 0 )
        {
        if ( Callee->ManagerEpv != HelgaManagerEpv )
            {
            OtherError("HelgaINOUTStub",
                    "Callee->ManagerEpv != HelgaManagerEpv");
            HelgaError();
            }
        }

    //
    // Check the data we have so far.
    //
    Length = *(unsigned long *) Callee->Buffer;
    if (Length < Callee->BufferLength)
        {
        OtherError("HelgaINOUTStub","*Length < *BufferLength");
        HelgaError();
        }

    unsigned char InitialValue;
    if (CheckInitialBuffer(Callee->Buffer, Callee->BufferLength, &InitialValue) != 0)
        {
        OtherError("HelgaINOUTStub","initial CheckBuffer Failed");
        HelgaError();
        }

    if (Length > Callee->BufferLength)
        {
        if (Callee->RpcFlags & RPC_BUFFER_COMPLETE)
            {
            OtherError("HelgaINOUTStub","incomplete buffer marked as complete");
            HelgaError();
            }
        }

    if (0 == (Callee->RpcFlags & RPC_BUFFER_COMPLETE))
        {
        //
        // Get the rest of the data and check it.
        //
        CompleteReceive(Callee) ;

        if (0 != CheckInitialBuffer(Callee->Buffer, Callee->BufferLength, &InitialValue))
            {
            OtherError("HelgaINOUTStub","second CheckBuffer Failed");
            HelgaError();
            }
        }

    Callee->BufferLength = Length;

    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("HelgaINOUTStub","I_RpcGetBuffer",Status);
        HelgaError();
        }
    else
        {
        InitializeBuffer(Callee->Buffer, Length);
        }
}

void Synchro(
    PRPC_MESSAGE Callee
    )
{
    PrintToConsole("Sychro called\n") ;
    RpcServerYield();
}

void SvrLazyFunc(
    PRPC_MESSAGE Callee
    )
{
    PrintToConsole("About to sleep\n") ;
    PauseExecution(100000) ;
    PrintToConsole("Waking up\n") ;

    Shutdown() ;
}

void HelgaLpcSecurity(
    PRPC_MESSAGE Callee
    )
{
    RPC_STATUS RpcStatus ;
    RPC_CHAR *UserName ;

    PrintToConsole("HelgaLpcSecurity\n") ;

    RpcStatus = RpcBindingInqAuthClient(Callee->Handle, (void **) &UserName,
                                        NULL, NULL, NULL, NULL) ;
    if ((RpcStatus != RPC_S_OK) && (RpcStatus != RPC_S_BINDING_HAS_NO_AUTH))
        {
        HelgaError() ;


        PrintToConsole("HelgaLpcSecurity: (1) UserName: %S\n", UserName) ;
        }

    UserName = NULL ;

    RpcStatus = RpcBindingInqAuthClient(Callee->Handle, (void **) &UserName,
                                        NULL, NULL, NULL, NULL) ;
    if ((RpcStatus != RPC_S_OK) && (RpcStatus != RPC_S_BINDING_HAS_NO_AUTH))
        {
        HelgaError() ;
        PrintToConsole("HelgaLpcSecurity: (2) UserName: %S\n", UserName) ;
        }
}

void
HelgaObjectUuids (
    PRPC_MESSAGE Callee
    )
{
    PrintToConsole("HelgaObjectUuids\n") ;

    char *Ptr = (char *) Callee->Buffer;
    BOOL fObjectUuid = *((BOOL *) Ptr);
    UUID MyObjectUuid;

    Status = RpcBindingInqObject(Callee->Handle, &MyObjectUuid);
    if (Status)
        {
        ApiError("HelgaStub", "RpcBindingInqObject", Status);
        HelgaError();
        RpcRaiseException(Status);
        }

    UUID Uuid;
    Ptr += sizeof(BOOL);

    if (fObjectUuid)
        {
        RpcpMemoryCopy(&Uuid, Ptr, sizeof(UUID));
        }
    else
        {
        RpcpMemorySet(&Uuid, 0, sizeof(UUID));
        }

    if (RpcpMemoryCompare(&Uuid, &MyObjectUuid, sizeof(UUID)))
        {
        HelgaError();
        RpcRaiseException(-1);
        }

    Callee->BufferLength = 0;

    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("HelgaStub","I_RpcGetBuffer",Status);
        HelgaError();
        RpcRaiseException(Status);
        }
}

void
HelgaConnId (
    PRPC_MESSAGE Callee
    )
{
    PrintToConsole("HelgaConnId\n") ;
    static void *OldId = 0;
    void *ConnId;
    BOOL fFirstTime;

    Status = I_RpcBindingInqConnId(
                                   Callee->Handle,
                                   &ConnId,
                                   &fFirstTime);
    if (Status)
        {
        HelgaError();
        ApiError("HelgaStub","I_RpcBindingInqConnId",Status);
        RpcRaiseException(Status);
        }

    PrintToConsole("HelgaConnId: ConnId: %p, fFirstTime: %d\n", ConnId, fFirstTime);

    char *Ptr = (char *) Callee->Buffer;
    BOOL fNewConnExpected = *((BOOL *) Ptr);


    if (fNewConnExpected != fFirstTime)
        {
        HelgaError();
        RpcRaiseException(-1);
        }

    if (fFirstTime)
        {
        OldId = ConnId;
        }
    else
        {
        if (ConnId != OldId)
            {
            HelgaError();
            RpcRaiseException(-1);
            }
        }

    Callee->BufferLength = 0;

    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("HelgaStub","I_RpcGetBuffer",Status);
        HelgaError();
        RpcRaiseException(Status);
        }
}

typedef struct _WIRE_CONTEXT
{
    unsigned long ContextType;
    UUID ContextUuid;
} WIRE_CONTEXT;

void UsvrRundown (
    void *Context
    )
{
    PrintToConsole("UsvrRundown called");
}

// partial replica of SCONTEXTItem in scontext.cxx
typedef struct tagUserContext
{
    void *R1;
    void *R2;
    void * userContext;       /* context for the user */
} UserContext;


// the buffer should be of type and size WIRE_CONTEXT
void OpenContextHandle (
    RPC_MESSAGE *Callee
    )
{
    void *pGuard;
    RPC_SERVER_INTERFACE *ServerIf;
    RPC_STATUS RpcStatus;
    void *Context;
    WIRE_CONTEXT WireContext;

    ASSERT(Callee->BufferLength == sizeof(WIRE_CONTEXT));

    if (Callee->ProcNum == 21)
        {
        ServerIf = &IsabelleInterfaceInformation;
        }
    else if (Callee->ProcNum == 10)
        {
        ServerIf = &HelgaInterfaceInformation;
        }
    else
        {
        ASSERT(0);
        }

    pGuard = &ServerIf->InterfaceId;

    Context = NDRSContextUnmarshall2(Callee->Handle,
        Callee->Buffer,
        10,
        pGuard,
        0);

    ((UserContext *)Context)->userContext = pGuard;

    Callee->BufferLength = 0;

    RpcStatus = I_RpcGetBuffer(Callee);
    if (RpcStatus != RPC_S_OK)
        {
        ApiError("Get Buffer", "I_RpcGetBuffer", Status) ;
        return ;
        }

    NDRSContextMarshall2(Callee->Handle,
        (NDR_SCONTEXT)Context,
        &WireContext,
        UsvrRundown,
        pGuard,
        0);
}

extern void
Foo_s (
    PRPC_MESSAGE Message
    ) ;

extern void
FooPipe_s (
    PRPC_MESSAGE Message
    )  ;

extern void
FooBar_s (
    PRPC_MESSAGE Message
    ) ;

void
FooCH_s (
    PRPC_MESSAGE Message
    ) ;



RPC_DISPATCH_FUNCTION HelgaDispatchFunctions[] =
{
        HelgaStub,
        HelgaINStub,
        HelgaOUTStub,
        HelgaINOUTStub,
        Synchro,
        SvrLazyFunc,
        HelgaLpcSecurity,
        Foo_s,
        HelgaObjectUuids,
        HelgaConnId,
        OpenContextHandle
};

RPC_DISPATCH_TABLE HelgaDispatchTable =
{
    11, HelgaDispatchFunctions
};

/* --------------------------------------------------------------------

Sylvia Interface

-------------------------------------------------------------------- */

extern RPC_DISPATCH_TABLE SylviaDispatchTable;

RPC_SERVER_INTERFACE SylviaInterfaceInformation =
{
    sizeof(RPC_SERVER_INTERFACE),
    {{3,2,2,{1,1,1,1,1,1,1,1}},
     {1,1}},
    {{0x8A885D04, 0x1CEB, 0x11C9, {0x9F, 0xE8, 0x08, 0x00, 0x2B, 0x10, 0x48, 0x60}},
     {2, 0}},
    &SylviaDispatchTable,
    0,
    0,
    0,
    0,
    RPC_INTERFACE_HAS_PIPES
};


unsigned int SylviaQueryBinding = 0;
unsigned int SylviaQueryProtocolStack = 0;
unsigned int SylviaQueryCall = 0;
char * SylviaTransportInfo = 0;

unsigned /*int*/ char // Specifies the new count of calls.
SylviaCallback (
    unsigned /*long*/ char Depth, // Specifies the depth of recursion desired.
    unsigned /*long*/ char Breadth, // Specifies the breadth desired.
    unsigned /*long*/ char Count // Specifies the count of calls up to this point.
    )
{
    RPC_MESSAGE Caller;
    unsigned /*long*/ char * plScan, ReturnValue;

    Caller.ProcNum = 0;
    Caller.Handle = I_RpcGetCurrentCallHandle();

    if (Caller.Handle == (RPC_BINDING_HANDLE) 0)
        {
        OtherError("SylviaCallback","Call == (RPC_BINDING_HANDLE) 0");
        SylviaError();
        return(0);
        }

    Caller.BufferLength = sizeof(unsigned /*long*/ char)*4+10240;
    Status = I_RpcGetBuffer(&Caller);
    if (Status)
        {
        ApiError("SylviaCallback","I_RpcGetBuffer",Status);
        SylviaError();
        return(0);
        }
    plScan = (unsigned /*long*/ char *) Caller.Buffer;
    plScan[0] = (unsigned char) Depth;
    plScan[1] = (unsigned char) Breadth;
    plScan[2] = (unsigned char) Count;

    Status = I_RpcSendReceive(&Caller);
    if (Status)
        {
        ApiError("SylviaCallback","I_RpcSendReceive",Status);
        SylviaError();
        return(0);
        }

    plScan = (unsigned /*long*/ char *) Caller.Buffer;
    ReturnValue = *plScan;
    Status = I_RpcFreeBuffer(&Caller);
    if (Status)
        {
        ApiError("SylviaCallback","I_RpcFreeBuffer",Status);
        SylviaError();
        return(0);
        }
    return(ReturnValue);
}

unsigned /*long*/ char
SylviaCallUserCode ( // The user code for SylviaCall.
    unsigned /*long*/ char Depth,
    unsigned /*long*/ char Breadth,
    unsigned /*long*/ char Count
    )
{
    if (Depth > 0)
        {
        if (Depth == Breadth)
            {
            Count = SylviaCallUserCode(Depth-1,Breadth,Count);
            }
        else
            Count = SylviaCallback(Depth-1,Breadth,Count);
        }
    return(Count+1);
}

void __RPC_STUB
SylviaCall (
    PRPC_MESSAGE Callee
    )
{
    unsigned /*long*/ char ReturnValue, *plScan;

    if ( Callee->ProcNum != 0 )
        {
        OtherError("SylviaCall", "Callee->ProcNum != 0");
        SylviaError();
        }

    if ( memcmp(Callee->RpcInterfaceInformation, &SylviaInterfaceInformation,
                sizeof(SylviaInterfaceInformation)) != 0 )
        {
        OtherError("SylviaCall",
                "Callee->RpcInteraceInformation != &SylviaInterfaceInformation");
        SylviaError();
        }

    if (Callee->BufferLength != sizeof(unsigned /*long*/ char)*4+10240)
        {
        OtherError("SylviaCall","*BufferLength != sizeof(unsigned  char)*4");
        SylviaError();
        }

    plScan = (unsigned /*long*/ char *) Callee->Buffer;

//    if (   SylviaQueryCall
//        && VerifyQueryCall(Callee->Handle,&SylviaProtocolStack))
//        {
//        OtherError("SylviaCallback","VerifyQueryCall");
//        SylviaError();
//        }

//    if (   SylviaQueryBinding
//        && VerifyQueryBinding(Callee->Handle,SylviaServer))
//        {
//        OtherError("SylviaCallback","VerifyQueryBinding");
//        SylviaError();
//        }

//    if (   SylviaQueryProtocolStack
//        && VerifyQueryProtocolStack(Callee->Handle,&SylviaProtocolStack,
//                        SylviaTransportInfo))
//        {
//        OtherError("SylviaCallback","VerifyQueryProtocolStack");
//        SylviaError();
//        }

    ReturnValue = (unsigned char) SylviaCallUserCode(plScan[0],plScan[1],plScan[2]);

//    if (   SylviaQueryCall
//        && VerifyQueryCall(Callee->Handle,&SylviaProtocolStack))
//        {
//        OtherError("SylviaCallback","VerifyQueryCall");
//        SylviaError();
//        }

//    if (   SylviaQueryBinding
//        && VerifyQueryBinding(Callee->Handle,SylviaServer))
//        {
//        OtherError("SylviaCallback","VerifyQueryBinding");
//        SylviaError();
//        }

//    if (   SylviaQueryProtocolStack
//        && VerifyQueryProtocolStack(Callee->Handle,&SylviaProtocolStack,
//                        SylviaTransportInfo))
//        {
//        OtherError("SylviaCallback","VerifyQueryProtocolStack");
//        SylviaError();
//        }

    Callee->BufferLength = sizeof(unsigned /*long*/ char);
    Status = I_RpcGetBuffer((PRPC_MESSAGE) Callee);
    if (Status)
        {
        ApiError("SylviaCall","I_RpcGetBuffer",Status);
        SylviaError();
        }
    plScan = (unsigned /*long*/ char *) Callee->Buffer;
    *plScan = ReturnValue;
}

RPC_DISPATCH_FUNCTION SylviaDispatchFunction[] = {SylviaCall};
RPC_DISPATCH_TABLE SylviaDispatchTable =
{
    1, SylviaDispatchFunction
};

/* --------------------------------------------------------------------

Isabelle Interface

-------------------------------------------------------------------- */


extern RPC_DISPATCH_TABLE IsabelleDispatchTable;

RPC_PROTSEQ_ENDPOINT IsabelleRpcProtseqEndpoint[] =
{
    {(unsigned char *) "ncacn_np",
#ifdef WIN32RPC
     (unsigned char *) "\\pipe\\zippyis"},
#else // WIN32RPC
     (unsigned char *) "\\device\\namedpipe\\christopherisabelle"},
#endif // WIN32RPC
    {(unsigned char *) "ncacn_ip_tcp",(unsigned char *) "2040"},
    {(unsigned char *) "ncadg_ip_udp",(unsigned char *) "2040"},
    {(unsigned char *) "ncalrpc",(unsigned char *) "christopherisabelle"},
    {(unsigned char *) "ncacn_nb_nb",(unsigned char *) "212"},
    {(unsigned char *) "ncacn_nb_tcp",(unsigned char *) "213"},
    {(unsigned char *) "ncacn_nb_ipx",(unsigned char *) "214"},
    {(unsigned char *) "ncacn_spx",(unsigned char *) "5015"},
    {(unsigned char *) "ncadg_ipx",(unsigned char *) "5015"},
    {(unsigned char *) "ncacn_vns_spp",(unsigned char *) "265"},
    {(unsigned char *) "ncacn_at_dsp", (unsigned char *) "\\pipe\\zippyis"},
    {(unsigned char *) "ncadg_mq", (unsigned char *) "christopherisabelle"}
};

RPC_SERVER_INTERFACE IsabelleInterfaceInformation =
{
    sizeof(RPC_SERVER_INTERFACE),
    {{9,8,8,{7,7,7,7,7,7,7,7}},
     {1,1}},
    {{0x8A885D04, 0x1CEB, 0x11C9, {0x9F, 0xE8, 0x08, 0x00, 0x2B, 0x10, 0x48, 0x60}},
     {2, 0}},
    &IsabelleDispatchTable,
    sizeof(IsabelleRpcProtseqEndpoint) / sizeof(RPC_PROTSEQ_ENDPOINT),
    IsabelleRpcProtseqEndpoint,
    0,
    0,
    RPC_INTERFACE_HAS_PIPES
};

void __RPC_STUB
IsabelleShutdown (
    PRPC_MESSAGE Callee
    )
{
    RPC_BINDING_HANDLE BindingHandle;
    unsigned char PAPI * StringBinding;
    unsigned int ClientLocalFlag = 0;
    RPC_STATUS IsClientLocalStatus;

    CompleteReceive(Callee) ;

    Status = I_RpcBindingIsClientLocal(0, &ClientLocalFlag);
    if ( (IsClientLocalStatus = Status) != RPC_S_CANNOT_SUPPORT )
        {
        if ( Status != RPC_S_OK )
            {
            ApiError("IsabelleShutdown", "I_RpcBindingIsClientLocal", Status);
            IsabelleError();
            }
        }

    if (Callee->BufferLength != 0)
        {
        OtherError("IsabelleShutdown","*BufferLength != 0");
        IsabelleError();
        }

    if (AutoListenFlag == 0)
        {
        Status = RpcMgmtIsServerListening(0);
        if (Status)
            {
            ApiError("IsabelleShutdown", "RpcMgmtIsServerListening", Status);
            IsabelleError();
            }
        }

    Status = RpcBindingServerFromClient(Callee->Handle, &BindingHandle);
    if (Status)
        {
        if ( Status != RPC_S_CANNOT_SUPPORT && (DatagramFlag == 0) )
            {
            ApiError("IsabelleShutdown", "RpcBindingServerFromClient", Status);
            IsabelleError();
            }

        if(IsClientLocalStatus == RPC_S_OK)
           {
               if ( ClientLocalFlag != 0 )
                 PrintToConsole("Local Client\n");
               else
                 PrintToConsole("Remote Client\n");
           }
        }
    else
        {
        Status = RpcBindingToStringBindingA(BindingHandle, &StringBinding);
        if (Status)
            {
            ApiError("IsabelleShutdown", "RpcBindingToStringBinding", Status);
            IsabelleError();
            }
        else
            {
            if ( ClientLocalFlag != 0 )
                {
                PrintToConsole("Local Client [%s]\n", StringBinding);
                }
            else
                {
                PrintToConsole("Remote Client [%s]\n", StringBinding);
                }
            RpcStringFreeA(&StringBinding);
            RpcBindingFree(&BindingHandle);
            }
        }

    Shutdown();

    Callee->BufferLength = 0;
    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("IsabelleShutdown","I_RpcGetBuffer",Status);
        IsabelleError();
        }
}


void __RPC_STUB
IsabelleNtSecurity (
    PRPC_MESSAGE CalleeMessage
    )
/*++

Routine Description:

    A client will call this routine with some quality of service
    specified.  The server will impersonate the client and check
    that the impersonation level is that specified.  The request
    buffer will contain the network options passed by the client
    to RpcBindingFromStringBinding.

Arguments:

    CalleeMessage - Supplies the request message and returns the
        response message for the remote procedure call.

--*/
{
    RPC_STATUS Status;

    Status = RpcImpersonateClient(0);
    if (Status != RPC_S_OK)
        {
        ApiError("IsabelleNtSecurity","RpcImpersonateClient",Status);
        IsabelleError();
        }
    else
        {
        Status = RpcRevertToSelf();
        if (Status != RPC_S_OK)
            {
            ApiError("IsabelleNtSecurity","RpcRevertToSelf",Status);
            IsabelleError();
            }
        else
            {
            Status = RpcImpersonateClient(CalleeMessage->Handle);
            if (Status != RPC_S_OK)
                {
                ApiError("IsabelleNtSecurity","RpcImpersonateClient",
                        Status);
                IsabelleError();
                }
            else
                {
                Status = RpcRevertToSelf();
                if (Status != RPC_S_OK)
                    {
                    ApiError("IsabelleNtSecurity","RpcRevertToSelf",Status);
                    IsabelleError();
                    }
                }
            }
        }

    CalleeMessage->BufferLength = 0;
    Status = I_RpcGetBuffer(CalleeMessage);

    if (Status)
        {
        ApiError("IsabelleNtSecurity","I_RpcGetBuffer",Status);
        IsabelleError();
        }

}

int ChristopherIsabelleError;

void __RPC_STUB
IsabelleToStringBinding (
    PRPC_MESSAGE Callee
    )
{
    unsigned char PAPI * StringBinding;

    if (Callee->BufferLength != 0)
        {
        OtherError("IsabelleToStringBinding","*BufferLength != 0");
        IsabelleError();
        }

    Status = RpcBindingToStringBindingA(Callee->Handle, &StringBinding);
    if (Status)
        {
        ApiError("Christopher","RpcBindingToStringBinding",Status);
        PrintToConsole("Christopher : FAIL - RpcBindingToStringBinding\n");
        ChristopherIsabelleError = 1;
        }
    else
        {
        PrintToConsole("Christopher : (RpcBindingToStringBinding)\n    ");
        PrintToConsole((char *) StringBinding);
        PrintToConsole("\n");

        Status = RpcStringFreeA(&StringBinding);
        if (Status)
            {
            ApiError("Christopher","RpcStringFree",Status);
            PrintToConsole("Christopher : FAIl - RpcStringFree\n");
            ChristopherIsabelleError = 1;
            }
        else
            {
            if (StringBinding != 0)
                {
                PrintToConsole("Christopher : FAIL - ");
                PrintToConsole("StringBinding != 0\n");
                ChristopherIsabelleError = 1;
                }
            }
        }

    Callee->BufferLength = 0;
    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("Christopher","I_RpcGetBuffer",Status);
        HelgaError();
        }
}

#define RICHARDHELPER_EXIT 1
#define RICHARDHELPER_EXECUTE 2
#define RICHARDHELPER_IGNORE 3
#define RICHARDHELPER_DELAY_EXIT 4


void
RichardHelperExit (
    void * Ignore
    )
{
    PauseExecution(2000L);
    PrintToConsole("Richard : RichardHelper Exiting\n");

#ifdef WIN32RPC

    ExitProcess(0);

#endif // WIN32RPC
}


void __RPC_STUB
IsabelleRichardHelper (
    PRPC_MESSAGE Callee
    )
/*++

Routine Description:

    This routine is the stub (and actually the manager code as well) for
    the IsabelleRichardHelper routine.  The client will call a stub and
    specify a command argument which will be passed in the buffer.  We
    need to extract the argument, and then execute the requested command.

Arguments:

    Callee - Supplies the input arguments and returns the output arguments
        and return value for the stub.

--*/
{
    unsigned /*long*/ char Command;
    RPC_STATUS RpcStatus = RPC_S_OK;

    if (   Callee->BufferLength != sizeof(unsigned char)
        && Callee->BufferLength != sizeof(unsigned long) )
        {
        OtherError("IsabelleRichardHelper",
                "*BufferLength != sizeof(unsigned long)");
        IsabelleError();
        Callee->BufferLength = 0;

         Status = I_RpcGetBuffer(Callee);

        if (Status)
            {
            ApiError("IsabelleRichardHelper","I_RpcGetBuffer",Status);
            IsabelleError();
            }
        return;
        }

    Command = *((unsigned char *) Callee->Buffer);

    if (Command == RICHARDHELPER_EXIT)
        {
        PrintToConsole("Richard : RichardHelper Exiting\n");
#ifdef OS2_12
        DosExit(EXIT_PROCESS, 0);

#endif // OS2_12

#ifdef WIN32RPC

        ExitProcess(0);

#endif // WIN32RPC
        }
    else if (Command == RICHARDHELPER_EXECUTE)
        {
#ifdef OS2_12

        USHORT Os2Status;
        RESULTCODES ResultCodes;
        char CommandLine[200], *pT;

        pT = CommandLine;
        *pT = 0;

        pT += strlen(strcpy(pT, "usvr")) + 1;
        pT += strlen(strcpy(pT, TransportOption));
        pT += strlen(strcpy(pT, "-error -richardhelper")) + 1;
        *pT = 0;

        Os2Status = DosExecPgm(0,0,EXEC_ASYNC, (unsigned char *)CommandLine, 0,
                &ResultCodes,(unsigned char *)"usvr.exe");
        if (Os2Status != 0)
            {
            OtherError("IsabelleRichardHelper","DosExecPgm Failed");
            IsabelleError();
            }

#endif // OS2_12

#ifdef WIN32RPC

        PROCESS_INFORMATION ProcessInformation;
        STARTUPINFOA StartupInfo;

        StartupInfo.cb = sizeof(STARTUPINFOA);
        StartupInfo.lpReserved = 0;
        StartupInfo.lpDesktop = 0;
        StartupInfo.lpTitle = 0;
        StartupInfo.dwX = 0;
        StartupInfo.dwY = 0;
        StartupInfo.dwXSize = 0;
        StartupInfo.dwYSize = 0;
        StartupInfo.dwFlags = 0;
        StartupInfo.wShowWindow = 0;
        StartupInfo.cbReserved2 = 0;
        StartupInfo.lpReserved2 = 0;

        char CommandLine[200];

    PrintToConsole("Spawning richardhelper\n") ;
        strcpy(CommandLine, "usvr ");
        strcat(CommandLine, TransportOption);

        strcat(CommandLine, " -richardhelper");

        if (CreateProcessA(0, CommandLine, 0, 0, FALSE,
                0, 0, 0, &StartupInfo, &ProcessInformation) == FALSE)
            {
            OtherError("IsabelleRichardHelper","CreateProcessA Failed");
            IsabelleError();
            }

#endif // WIN32RPC
        }
    else if (Command == RICHARDHELPER_DELAY_EXIT)
        {
        HANDLE HandleToThread ;
        unsigned long ThreadIdentifier;

        HandleToThread = CreateThread(
                                    0,
                                    0,
                                    (LPTHREAD_START_ROUTINE) RichardHelperExit,
                                    0,
                                    0,
                                    &ThreadIdentifier);

        if (HandleToThread == 0)
            {
            OtherError("IsabelleRichardHelper","Can Not Create Thread");
            IsabelleError();
            }
        }
    else if (Command != RICHARDHELPER_IGNORE)
        {
        OtherError("IsabelleRichardHelper","Unknown Command Requested");
        IsabelleError();
        OtherError("IsabelleRichardHelper","Unknown Command Requested");
        IsabelleError();
        OtherError("IsabelleRichardHelper","Unknown Command Requested");
        IsabelleError();
        OtherError("IsabelleRichardHelper","Unknown Command Requested");
        IsabelleError();
        OtherError("IsabelleRichardHelper","Unknown Command Requested");
        IsabelleError();
        OtherError("IsabelleRichardHelper","Unknown Command Requested");
        IsabelleError();
        OtherError("IsabelleRichardHelper","Unknown Command Requested");
        IsabelleError();
        OtherError("IsabelleRichardHelper","Unknown Command Requested");
        IsabelleError();
        OtherError("IsabelleRichardHelper","Unknown Command Requested");
        IsabelleError();
        OtherError("IsabelleRichardHelper","Unknown Command Requested");
        IsabelleError();
        OtherError("IsabelleRichardHelper","Unknown Command Requested");
        IsabelleError();
        }

    Callee->BufferLength = 0;
    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("IsabelleRichardHelper","I_RpcGetBuffer",Status);
        }

}


void __RPC_STUB
IsabelleRaiseException (
    PRPC_MESSAGE Callee
    )
/*++

Routine Description:

    This routine is the stub (and actually the manager code as well) for
    the IsabelleRaiseException routine.  The client will call a stub and
    specify an exception to be raised which will be passed in the buffer.  We
    need to extract the argument, and then raise the exception.

Arguments:

    Callee - Supplies the input arguments and returns the output arguments
        and return value for the stub.

--*/
{
    unsigned /*long*/ char Exception;

    CompleteReceive(Callee) ;

    if (   Callee->BufferLength != sizeof(unsigned long)
        && Callee->BufferLength != sizeof(unsigned char) )
        {
        OtherError("IsabelleRaiseException",
                "*BufferLength != 1 or 4");
        IsabelleError();
        Callee->BufferLength = 0;

        Status = I_RpcGetBuffer(Callee);

        if (Status)
            {
            ApiError("IsabelleRaiseException","I_RpcGetBuffer",Status);
            IsabelleError();
            }
        return;
        }

    Exception = *((unsigned /*long*/ char *) Callee->Buffer);

    RpcRaiseException((RPC_STATUS) Exception);

    // This should never be reached.

    OtherError("IsabelleRaiseException", "RpcRaiseException Failed");
    IsabelleError();

    Callee->BufferLength = 0;
    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("IsabelleRaiseException","I_RpcGetBuffer",Status);
        }

}

unsigned int IsabelleRundownFlag = 0;
void PAPI * IsabelleAssociationContext = 0;


void __RPC_STUB
IsabelleRundownRoutine (
    IN void PAPI * AssociationContext
    )
/*++

Routine Description:

    This routine will get called when the association closes.  We just
    need to check that the association context is correct, and then
    note that we got called.

Arguments:

    AssociationContext - Supplies the association context for the association
        which closed.

--*/
{
    if (AssociationContext == IsabelleAssociationContext)
        IsabelleRundownFlag += 1;
}


void __RPC_STUB
IsabelleSetRundown (
    IN PRPC_MESSAGE Callee
    )
/*++

Routine Description:

    We want to set an association context in this routine, and a rundown
    routine.  The rundown will set a flag when it is called.  Later, the
    client, will call another routine to check to set the flag has been
    set.

Arguments:

    Callee - Supplies the input arguments and returns the output arguments
        and return value for the stub.

--*/
{
    CompleteReceive(Callee) ;

    if (Callee->BufferLength != 0)
        {
        OtherError("IsabelleSetException", "*BufferLength != 0");
        IsabelleError();
        }

    IsabelleRundownFlag = 0;
    IsabelleAssociationContext = Callee->Buffer;

    Status = I_RpcMonitorAssociation(Callee->Handle, IsabelleRundownRoutine,
            IsabelleAssociationContext);
    if (Status)
        {
        ApiError("IsabelleSetRundown","I_RpcMonitorAssociation",Status);
        IsabelleError();
        }

    Callee->BufferLength = 0;
    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("IsabelleSetRundown","I_RpcGetBuffer",Status);
        }

}


void __RPC_STUB
IsabelleCheckRundown (
    PRPC_MESSAGE Callee
    )
/*++

Routine Description:

    This routine will be called to check that context rundown did, in
    fact, occur.

Arguments:

    Callee - Supplies the input arguments and returns the output arguments
        and return value for the stub.

--*/
{
    CompleteReceive(Callee) ;

    if (Callee->BufferLength != 0)
        {
        OtherError("IsabelleCheckRundown", "*BufferLength != 0");
        IsabelleError();
        }

    if (0 == DatagramFlag)
        {
        if (IsabelleRundownFlag != 1)
            {
            OtherError("IsabelleCheckRundown", "IsabelleRundownFlag != 1");
            IsabelleError();
            }
        }

    Callee->BufferLength = 0;
    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("IsabelleCheckRundown","I_RpcGetBuffer",Status);
        }

}


void __RPC_STUB
IsabelleCheckNoRundown (
    PRPC_MESSAGE Callee
    )
/*++

Routine Description:

    This routine will be called to check that context rundown did not
    occur.

Arguments:

    Callee - Supplies the input arguments and returns the output arguments
        and return value for the stub.

--*/
{
    CompleteReceive(Callee) ;

    if (Callee->BufferLength != 0)
        {
        OtherError("IsabelleCheckNoRundown", "*BufferLength != 0");
        IsabelleError();
        }

    if (IsabelleRundownFlag == 1)
        {
        OtherError("IsabelleCheckNoRundown", "IsabelleRundownFlag == 1");
        IsabelleError();
        }

    Callee->BufferLength = 0;
    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("IsabelleCheckNoRundown","I_RpcGetBuffer",Status);
        }

}


void __RPC_STUB
IsabelleCheckContext (
    PRPC_MESSAGE Callee
    )
/*++

Routine Description:

    This routine will be called to check the context for an association,
    and then to set a new context.

Arguments:

    Callee - Supplies the input arguments and returns the output arguments
        and return value for the stub.

--*/
{
    void PAPI * Context;

    CompleteReceive(Callee) ;

    if (Callee->BufferLength != 0)
        {
        OtherError("IsabelleCheckContext", "*BufferLength != 0");
        IsabelleError();
        }

    Status = I_RpcGetAssociationContext(Callee->Handle, &Context);
    if (Status)
        {
        ApiError("IsabelleCheckContext", "I_RpcGetAssociationContext",
                Status);
        IsabelleError();

        Callee->BufferLength = 0;

        Status = I_RpcGetBuffer(Callee);

        if (Status)
            {
            ApiError("IsabelleCheckContext","I_RpcGetBuffer",Status);
            IsabelleError();
            }

        return;
        }

    if (Context != IsabelleAssociationContext)
        {
        OtherError("IsabelleCheckContext",
                "Context != IsabelleAssociationContext");
        IsabelleError();

        Callee->BufferLength = 0;

        Status = I_RpcGetBuffer(Callee);

        if (Status)
            {
            ApiError("IsabelleCheckContext","I_RpcGetBuffer",Status);
            IsabelleError();
            }
        return;
        }

    Callee->BufferLength = 0;
    Status = I_RpcGetBuffer(Callee);

    if (Status)
        {
        ApiError("IsabelleCheckContext","I_RpcGetBuffer",Status);
        }

}

RPC_BINDING_VECTOR * BartholomewRpcBindingVector;
unsigned int BartholomewIndex;


unsigned char *
UnicodeToAnsiString (
    IN RPC_CHAR * WideCharString,
    OUT RPC_STATUS * RpcStatus
    )
/*++

Routine Description:

    This routine will convert a unicode string into an ansi string,
    including allocating memory for the ansi string.

Arguments:

    WideCharString - Supplies the unicode string to be converted into
        an ansi string.

    RpcStatus - Returns the status of the operation; this will be one
        of the following values.

        RPC_S_OK - The unicode string has successfully been converted
            into an ansi string.

        RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate
            the ansi string.

Return Value:

    A pointer to the ansi string will be returned.

--*/
{
    NTSTATUS NtStatus;
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    unsigned char * NewString;

    RtlInitUnicodeString(&UnicodeString,WideCharString);
    NtStatus = RtlUnicodeStringToAnsiString(&AnsiString,&UnicodeString,TRUE);
    if (!NT_SUCCESS(NtStatus))
        {
        *RpcStatus = RPC_S_OUT_OF_MEMORY;
        return(0);
        }

    NewString = new unsigned char[AnsiString.Length + 1];
    if (NewString == 0)
        {
        RtlFreeAnsiString(&AnsiString);
        *RpcStatus = RPC_S_OUT_OF_MEMORY;
        return(0);
        }

    memcpy(NewString,AnsiString.Buffer,AnsiString.Length + 1);
    RtlFreeAnsiString(&AnsiString);
    *RpcStatus = RPC_S_OK;
    return(NewString);
}


unsigned char PAPI *
StringBindingWithDynamicEndpoint (
    IN unsigned char PAPI * StringBinding,
    IN RPC_CHAR PAPI * DynamicEndpoint
    )
/*++

Routine Description:

    This routine adds the dynamic endpoint to the string binding.  A
    new string binding will be returned, and the supplied string binding
    and dynamic endpoint will be freed.

Arguments:

    StringBinding - Supplies the string binding to which the dynamic
        endpoint should be added.

    DynamicEndpoint - Supplies the dynamic endpoint.

Return Value:

    A new string binding will be returned which contains the dynamic
    endpoint if the operation is successful; otherwise, zero will be
    returned.

--*/
{
    unsigned char PAPI * ObjectUuid;
    unsigned char PAPI * RpcProtocolSequence;
    unsigned char PAPI * NetworkAddress;
    unsigned char PAPI * Endpoint;
    unsigned char PAPI * NetworkOptions;

    Status = RpcStringBindingParseA(StringBinding, &ObjectUuid,
            &RpcProtocolSequence, &NetworkAddress, &Endpoint,
            &NetworkOptions);
    if (Status)
        {
        ApiError("StringBindingWithDynamicEndpoint",
                "RpcStringBindingParse", Status);
        return(0);
        }

    Status = RpcStringFreeA(&StringBinding);
    if (Status)
        {
        ApiError("StringBindingWithDynamicEndpoint", "RpcStringFree", Status);
        return(0);
        }

    Status = RpcStringFreeA(&Endpoint);
    if (Status)
        {
        ApiError("StringBindingWithDynamicEndpoint", "RpcStringFree", Status);
        return(0);
        }

    Endpoint = UnicodeToAnsiString(DynamicEndpoint, &Status);
    if (Status)
        {
        ApiError("StringBindingWithDynamicEndpoint", "UnicodeToAnsiString",
                Status);
        return(0);
        }

    Status = RpcStringFreeW(&DynamicEndpoint);
    if (Status)
        {
        ApiError("StringBindingWithDynamicEndpoint", "RpcStringFreeW",
                Status);
        return(0);
        }

    Status = RpcStringBindingComposeA(ObjectUuid, RpcProtocolSequence,
            NetworkAddress, Endpoint, NetworkOptions, &StringBinding);
    if (Status)
        {
        ApiError("StringBindingWithDynamicEndpoint",
                "RpcStringBindingCompose", Status);
        return(0);
        }

    delete Endpoint;

    Status = RpcStringFreeA(&ObjectUuid);
    if (Status)
        {
        ApiError("StringBindingWithDynamicEndpoint", "RpcStringFree", Status);
        return(0);
        }

    Status = RpcStringFreeA(&RpcProtocolSequence);
    if (Status)
        {
        ApiError("StringBindingWithDynamicEndpoint", "RpcStringFree", Status);
        return(0);
        }

    Status = RpcStringFreeA(&NetworkAddress);
    if (Status)
        {
        ApiError("StringBindingWithDynamicEndpoint", "RpcStringFree", Status);
        return(0);
        }

    Status = RpcStringFreeA(&NetworkOptions);
    if (Status)
        {
        ApiError("StringBindingWithDynamicEndpoint", "RpcStringFree", Status);
        return(0);
        }

    return(StringBinding);
}


void __RPC_STUB
IsabelleGetStringBinding (
    PRPC_MESSAGE Callee
    )
/*++

Routine Description:

    This routine will be called to obtain a string binding for one of
    the protocol sequences supported by this server.

Arguments:

    Callee - Supplies the input arguments and returns the output arguments
        and return value for the stub.

--*/
{
    unsigned char * StringBinding;
    WCHAR * DynamicEndpointW;
        RPC_CHAR *DynamicEndpoint;
    unsigned int TransportType ;
    unsigned int CurTransportType;

    CompleteReceive(Callee) ;

    while (BartholomewRpcBindingVector == 0)
        {
        Sleep(100);
        }

    if (Callee->BufferLength != 0)
        {
        OtherError("IsabelleGetStringBinding", "*BufferLength != 0");
        IsabelleError();
        }

    Status = I_RpcBindingInqTransportType(Callee->Handle, &TransportType);

    if (Status)
        {
        ApiError("IsabelleGetStringBinding", "I_RpcBindingInqTransportType", Status);
        IsabelleError();
        return;
        }

    if (TransportType != TRANSPORT_TYPE_LPC)
        {
        while (BartholomewIndex < BartholomewRpcBindingVector->Count)
            {
            Status = I_RpcBindingInqTransportType(
                            BartholomewRpcBindingVector->BindingH[BartholomewIndex],
                            &CurTransportType);

            if (Status)
                {
                ApiError("IsabelleGetStringBinding",
                         "I_RpcBindingInqTransportType", Status);
                IsabelleError();
                return;
                }

            if (CurTransportType == TRANSPORT_TYPE_LPC)
                {
                BartholomewIndex ++;
                continue;
                }
            break;
            }
        }

    if (BartholomewIndex < BartholomewRpcBindingVector->Count)
        {
        Status = RpcBindingToStringBindingA(
                BartholomewRpcBindingVector->BindingH[BartholomewIndex],
                &StringBinding);
        if (Status)
            {
            ApiError("IsabelleGetStringBinding", "RpcBindingToStringBinding",
                    Status);
            IsabelleError();
            Callee->BufferLength = 0;

            Status = I_RpcGetBuffer(Callee);

            if (Status)
                {
                ApiError("IsabelleGetStringBinding","I_RpcGetBuffer",Status);
                IsabelleError();
                }
            return;
            }

        Status = I_RpcBindingInqDynamicEndpointW(
                BartholomewRpcBindingVector->BindingH[BartholomewIndex],
                &DynamicEndpointW);
        if (Status)
            {
            ApiError("IsabelleGetStringBinding",
                    "I_RpcBindingInqDynamicEndpoint", Status);
            IsabelleError();
            Callee->BufferLength = 0;

            Status = I_RpcGetBuffer(Callee);

            if (Status)
                {
                ApiError("IsabelleGetStringBinding","I_RpcGetBuffer",Status);
                IsabelleError();
                }
            return;
            }

        DynamicEndpoint = DynamicEndpointW;

        if (DynamicEndpoint != 0)
            {

            StringBinding = StringBindingWithDynamicEndpoint(StringBinding,
                    DynamicEndpoint);
            if (StringBinding == 0)
                {
                OtherError("IsabelleGetStringBinding",
                        "StringBinding == 0");
                IsabelleError();
                Callee->BufferLength = 0;

                Status = I_RpcGetBuffer(Callee);

                if (Status)
                    {
                    ApiError("IsabelleGetStringBinding","I_RpcGetBuffer",Status);
                    IsabelleError();
                    }
                return;
                }
            }

        Callee->BufferLength = strlen((char PAPI *) StringBinding) + 1;

        Status = I_RpcGetBuffer(Callee);
        if (Status)
            {
            ApiError("IsabelleGetStringBinding", "I_RpcGetBuffer", Status);
            IsabelleError();
            return;
            }

        memcpy(Callee->Buffer, StringBinding,
                strlen((char PAPI *) StringBinding) + 1);

        Status = RpcStringFreeA(&StringBinding);
        if (Status)
            {
            ApiError("IsabelleGetStringBinding", "RpcStringFree", Status);
            IsabelleError();
            return;
            }

        BartholomewIndex += 1;
        }
    else
        {
        Callee->BufferLength = 0;

        Status = I_RpcGetBuffer(Callee);

        if (Status)
            {
            ApiError("IsabelleGetStringBinding","I_RpcGetBuffer",Status);
            IsabelleError();
            }
        return;
        }
}

void IsabelleUnregisterInterfaces(
    PRPC_MESSAGE Callee
    )
{
    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("IsabelleUnregsterInterface","RpcServerUnregisterIf",Status);
        PrintToConsole("IsabelleUnregsterInterfaces : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }
}

void IsabelleRegisterInterfaces(
    PRPC_MESSAGE Callee
    )
{
    Status = stub_RegisterIf((RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0,0);
    if (Status)
        {
        ApiError("Hybrid","stub_RegisterIf",Status);
        PrintToConsole("Hybrid : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,0,0);
    if (Status)
        {
        ApiError("Hybrid","stub_RegisterIf",Status);
        PrintToConsole("Hybrid : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }
}

void PipeAlloc(
    PIPE_STATE *state,
    int requested_size,
    pipe_element_t **allocated_buf,
    int *allocated_size)
{
    if (state->BufferSize < requested_size)
        {
        if (state->AllocatedBuffer)
            {
            I_RpcFree(state->AllocatedBuffer) ;
            }

        state->AllocatedBuffer =  I_RpcAllocate(requested_size) ;
        if (state->AllocatedBuffer == 0)
            {
            *allocated_size = 0 ;
            state->BufferSize = 0 ;
            }
        else
            {
            *allocated_size = requested_size ;
            state->BufferSize = requested_size ;
            }

        *allocated_buf = (pipe_element_t *) state->AllocatedBuffer ;
        }
    else
        {
        *allocated_buf = (pipe_element_t *) state->AllocatedBuffer ;
        *allocated_size = state->BufferSize ;
        }
}

void PipePull(
    PIPE_STATE *state,
    pipe_element_t *buffer,
    int ecount,
    int *actual_transfer_count
    )
{
    int num_elements = 0;
    DWORD size = (DWORD) ecount * state->PipeElementSize ;
    RPC_MESSAGE Callee ;

    *actual_transfer_count = 0 ;

    if (state->EndOfPipe)
        {
        return ;
        }

    I_RpcReadPipeElementsFromBuffer(state, (char *) buffer, size, &num_elements) ;
    *actual_transfer_count += num_elements ;
    size -= num_elements * state->PipeElementSize ;

    if (state->EndOfPipe == 0 &&
        num_elements < ecount)
        {
        Callee.RpcFlags = RPC_BUFFER_PARTIAL ;

        Callee.Buffer = state->Buffer ;
        Callee.BufferLength = state->BufferLength ;

        Status = I_RpcReceive(&Callee, size) ;
        if (Status)
            {
            ApiError("PipePull", "I_RpcReceive", Status) ;
            num_elements = 0 ;
            return ;
            }

        state->Buffer = Callee.Buffer ;
        state->BufferLength = Callee.BufferLength ;
        state->CurPointer = (char *) Callee.Buffer ;
        state->BytesRemaining = Callee.BufferLength ;

        buffer = (pipe_element_t *)
                    ((char *) buffer + num_elements * state->PipeElementSize) ;

        num_elements = 0 ;
        I_RpcReadPipeElementsFromBuffer(state,
                                (char *) buffer, size, &num_elements) ;
        *actual_transfer_count += num_elements ;
        }
}

void PipePush(
    PIPE_STATE *state,
    pipe_element_t *buffer,
    int count
    )
{
    RPC_MESSAGE TempBuf ;
    int size = count * state->PipeElementSize + sizeof(DWORD) ;
    char *temp ;
    RPC_MESSAGE Callee ;

    Callee.Buffer = state->Buffer ;
    Callee.BufferLength = state->BufferLength ;
    Callee.Handle = state->BindingHandle;

    Status = I_RpcReallocPipeBuffer(&Callee, size+state->SendBufferOffset) ;
    if (Status)
        {
        ApiError("PipePush", "I_RpcGetBuffer", Status) ;
        return ;
        }

    temp = (char *) Callee.Buffer+state->SendBufferOffset ;

    *((DWORD *) temp) = count ;
    RpcpMemoryCopy(temp+sizeof(DWORD),
                               buffer, count * state->PipeElementSize) ;

    Callee.RpcFlags = RPC_BUFFER_PARTIAL ;

    Status = I_RpcSend(&Callee) ;
    if (Status == RPC_S_SEND_INCOMPLETE)
        {
        state->SendBufferOffset = Callee.BufferLength ;
        }
    else if (Status)
        {
        ApiError("PipePush", "I_RpcSend", Status) ;
        state->SendBufferOffset = 0 ;
        return;
        }
    else
        {
        state->SendBufferOffset = 0 ;
        }
}

void IsabelleMgrIN(
    pipe_t *pipe,
    int chunksize,
    int numchunks,
    int checksum,
    int buffsize,
    char *buffer
    )
{
    static pipe_element_t local_buf[CHUNK_SIZE] ;
    int num_elements ;
    int i, j ;
    int localchecksum = 0;

    PrintToConsole("IsabelleMgrIN: client chunk size: %d\n", chunksize) ;
    PrintToConsole("IsabelleMgrIN: client number of chunks: %d\n", numchunks) ;
    PrintToConsole("IsabelleMgrIN: buffer size: %d\n", buffsize) ;
    PrintToConsole("IsabelleMgrIN: checksum: %d\n", checksum) ;

    do
         {
         pipe->Pull(pipe->state,
                        local_buf,
                        CHUNK_SIZE,
                        &num_elements
                        ) ;

         for (i = 0; i <num_elements; i++)
             {
             localchecksum += local_buf[i] ;
             }
         }
     while ( num_elements > 0  );

     if (localchecksum != checksum)
         {
         IsabelleError() ;
         PrintToConsole("IsabelleMgrIN: checksums don't match\n") ;
         }
}

void IsabellePipeIN(
    PRPC_MESSAGE Callee
    )
{
    pipe_t mypipe ;
    PIPE_STATE pipestate ;
    pipe_element_t pipe_element ;
    DWORD size = 3* sizeof(int)  ;
    int chunksize, numchunks, checksum, buffsize ;
    char *buffer, *temp ;
    void *savedbuffer ;

    PrintToConsole("IsabellePipeIN called\n") ;

    if (!(Callee->RpcFlags & RPC_BUFFER_COMPLETE) &&
        Callee->BufferLength < size)
        {
        Callee->RpcFlags |= (RPC_BUFFER_PARTIAL | RPC_BUFFER_EXTRA) ;
        size = size - Callee->BufferLength ;

        Status = I_RpcReceive(Callee, size) ;
        if (Status)
            {
            ApiError("PipePull", "I_RpcReceive", Status) ;
            return ;
            }
        }

    temp = (char *) Callee->Buffer ;

    chunksize = *((int *) temp) ;
    temp += sizeof(int) ;

    numchunks = *((int *) temp) ;
    temp += sizeof(int) ;

    checksum = *((int *) temp) ;
    temp += sizeof(int) ;

    buffsize = *((int *) temp) ;
    temp += sizeof(int) ;

    size = 4 * sizeof(int) + buffsize + sizeof(DWORD) ;

    if (!(Callee->RpcFlags & RPC_BUFFER_COMPLETE) &&
        Callee->BufferLength < size)
        {
        Callee->RpcFlags |= (RPC_BUFFER_PARTIAL | RPC_BUFFER_EXTRA) ;
        size = size - Callee->BufferLength ;

        Status = I_RpcReceive(Callee, size) ;
        if (Status)
            {
            ApiError("PipePull", "I_RpcReceive", Status) ;
            return ;
            }
        }

    buffer = (char *) Callee->Buffer + 3 * sizeof(int) ;

    savedbuffer = Callee->Buffer ;
    Callee->Buffer = 0;

    pipestate.Buffer = Callee->Buffer ;
    pipestate.BufferLength = Callee->BufferLength ;
    pipestate.CurrentState = start ;
    pipestate.CurPointer = (char *) buffer+buffsize ;
    pipestate.BytesRemaining = Callee->BufferLength - 3 * sizeof(int) - buffsize ;
    pipestate.EndOfPipe = 0 ;
    pipestate.PipeElementSize = sizeof(pipe_element_t) ;
    pipestate.PartialPipeElement = &pipe_element ;
    pipestate.AllocatedBuffer = 0 ;
    pipestate.BufferSize = 0 ;

    mypipe.Pull = PipePull ;
    mypipe.Push = PipePush ;
    mypipe.state = &pipestate ;

    IsabelleMgrIN(&mypipe, chunksize, numchunks, checksum, buffsize, buffer) ;

    Callee->Buffer = savedbuffer ;
 }

void IsabelleMgrOUT(
    pipe_t *pipe,
    int *chunksize,
    int *numchunks,
    int *checksum,
    int *buffsize,
    char **buffer
    )
{
    static pipe_element_t local_buf[CHUNK_SIZE] ;
    static int buf[BUFF_SIZE] ;
    int i ;
    char j = 0;
    int localchecksum = 0;

    PrintToConsole("IsabelleMgrOUT called\n") ;

    for (i = 0; i < CHUNK_SIZE; i++, j++)
        {
        RpcpMemorySet((char *) &(local_buf[i]), j, sizeof(pipe_element_t)) ;
        localchecksum += local_buf[i] ;
        }

    for (i = 0; i < NUM_CHUNKS; i++)
        {
        pipe->Push(pipe->state,
                        local_buf,
                        CHUNK_SIZE
                        ) ;
        }
    pipe->Push(pipe->state, local_buf, 0) ;

    for (i = 0; i < BUFF_SIZE; i++)
        {
        local_buf[i] = i ;
        }

    *chunksize = CHUNK_SIZE ;
    *numchunks = NUM_CHUNKS ;
    *checksum = localchecksum * NUM_CHUNKS;
    *buffsize = BUFF_SIZE ;
    *buffer = (char *) buf ;
}

void IsabellePipeOUT(
    PRPC_MESSAGE Callee
    )
{
    pipe_t mypipe ;
    char *Temp ;
    PIPE_STATE pipestate ;
    pipe_element_t pipe_element ;
    int size ;
    char *buffer ;
    int chunksize, numchunks, buffsize, checksum ;
    RPC_MESSAGE TempBuffer ;
    void *savedbuffer ;

    PrintToConsole("IsabellePipeOUT called\n") ;

    pipestate.Buffer = Callee->Buffer ;
    pipestate.BufferLength = Callee->BufferLength ;
    pipestate.CurrentState = start ;
    pipestate.CurPointer = (char *) Callee->Buffer ;
    pipestate.BytesRemaining = Callee->BufferLength ;
    pipestate.EndOfPipe = 0 ;
    pipestate.PipeElementSize = sizeof(pipe_element_t) ;
    pipestate.PartialPipeElement = &pipe_element ;
    pipestate.AllocatedBuffer = 0 ;
    pipestate.BufferSize = 0 ;
    pipestate.SendBufferOffset = 0 ;
    pipestate.BindingHandle = Callee->Handle;

    Callee->Buffer = 0;

    mypipe.Pull = PipePull ;
    mypipe.Push = PipePush ;
    mypipe.state = &pipestate ;

    IsabelleMgrOUT(&mypipe, &chunksize, &numchunks, &checksum, &buffsize, &buffer) ;

    size = 3 *sizeof(int) + buffsize ;

    Status = I_RpcReallocPipeBuffer(Callee, size+pipestate.SendBufferOffset) ;
    if (Status)
        {
        ApiError("PipePull", "I_RpcReceive", Status) ;
        return ;
        }

    Temp = (char *) Callee->Buffer+pipestate.SendBufferOffset ;

    *((int *) Temp) = chunksize ;
    Temp += sizeof(int) ;

    *((int *) Temp) = numchunks ;
    Temp += sizeof(int) ;

    *((int *) Temp) = checksum ;
    Temp += sizeof(int) ;

    *((int *) Temp) = buffsize ;
    Temp += sizeof(int) ;

    RpcpMemoryCopy(Temp, buffer, buffsize) ;
}

void IsabelleMgrINOUT(
    pipe_t *pipe
    )
{
    int num_elements ;
    int i;
    char j = 0;
    static pipe_element_t local_buf[CHUNK_SIZE] ;
    char *PipeData ;
    int localchecksum = 0;
    int outchecksum = 0;

    do
         {
         pipe->Pull(pipe->state,
                        local_buf,
                        CHUNK_SIZE,
                        &num_elements
                        ) ;

         for (i = 0; i <num_elements; i++)
             {
             localchecksum += local_buf[i] ;
             }
         }
     while ( num_elements > 0  );

     PrintToConsole("IsabelleMgrINOUT: checksum (IN) = %d\n", localchecksum) ;

     for (i = 0; i < CHUNK_SIZE; i++, j++)
        {
        RpcpMemorySet((char *) &(local_buf[i]), j, sizeof(pipe_element_t)) ;
        outchecksum += local_buf[i] ;
        }

    PrintToConsole("IsabelleMgrINOUT: checksum (OUT) = %d\n",
                            outchecksum * NUM_CHUNKS) ;

     for (i = 0; i <NUM_CHUNKS; i++)
         {
         pipe->Push(pipe->state, local_buf, CHUNK_SIZE) ;
         }

     pipe->Push(pipe->state, local_buf, 0) ;
}

void IsabellePipeINOUT(
    PRPC_MESSAGE Callee
    )
{
    pipe_t mypipe ;
    PIPE_STATE pipestate ;
    pipe_element_t pipe_element ;
    DWORD size = sizeof(pipe_element_t) + sizeof(DWORD) ;

    PrintToConsole("IsabellePipeINOUT called\n") ;

    if (!(Callee->RpcFlags & RPC_BUFFER_COMPLETE) &&
        Callee->BufferLength < size)
        {
        Callee->RpcFlags |= (RPC_BUFFER_PARTIAL | RPC_BUFFER_EXTRA) ;
        size = size - Callee->BufferLength ;

        Status = I_RpcReceive(Callee, size) ;
        if (Status)
            {
            ApiError("PipePull", "I_RpcReceive", Status) ;
            return ;
            }
        }


    pipestate.Buffer = Callee->Buffer ;
    pipestate.BufferLength = Callee->BufferLength ;
    pipestate.CurrentState = start ;
    pipestate.CurPointer = (char *) Callee->Buffer ;
    pipestate.BytesRemaining = Callee->BufferLength ;
    pipestate.EndOfPipe = 0 ;
    pipestate.PipeElementSize = sizeof(pipe_element_t) ;
    pipestate.PartialPipeElement = &pipe_element ;
    pipestate.AllocatedBuffer = 0 ;
    pipestate.BufferSize = 0 ;
    pipestate.SendBufferOffset = 0 ;

    Callee->Buffer = 0;

    mypipe.Pull = PipePull ;
    mypipe.Push = PipePush ;
    mypipe.state = &pipestate ;

    IsabelleMgrINOUT(&mypipe) ;
}

void GetServerType(
    PRPC_MESSAGE Callee
    )
{
    RPC_STATUS RpcStatus;
    OSVERSIONINFO *pOsVer;

    Callee->BufferLength = sizeof(OSVERSIONINFO);
    RpcStatus = I_RpcGetBuffer(Callee);
    if (RpcStatus != RPC_S_OK)
        {
        ApiError("Get Buffer", "I_RpcGetBuffer", Status) ;
        return ;
        }

    pOsVer = (OSVERSIONINFO *)Callee->Buffer;
    pOsVer->dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(pOsVer);
}

void UnregisterHelgaEx(
    PRPC_MESSAGE Callee
    )
{
    Status = RpcServerUnregisterIfEx(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, TRUE);
    if (Status)
        {
        ApiError("UnregisterHelgaEx","RpcServerUnregisterIfEx",Status);
        PrintToConsole("David : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }
}

RPC_DISPATCH_FUNCTION IsabelleDispatchFunction[] =
{
        IsabelleShutdown,
        IsabelleNtSecurity,
        IsabelleToStringBinding,
        IsabelleRichardHelper,
        IsabelleRaiseException,
        IsabelleSetRundown,
        IsabelleCheckRundown,
        IsabelleCheckContext,
        IsabelleGetStringBinding,
        IsabelleCheckNoRundown,
        Synchro,
        IsabelleUnregisterInterfaces,
        IsabelleRegisterInterfaces,
        IsabellePipeIN,
        IsabellePipeOUT,
        IsabellePipeINOUT,
        Foo_s,
        FooPipe_s,
        FooBar_s,
        FooCH_s,
        GetServerType,
        OpenContextHandle,
        UnregisterHelgaEx
};

RPC_DISPATCH_TABLE IsabelleDispatchTable =
{
    23, IsabelleDispatchFunction
};


int
InquireBindings (
    char * TestName
    )
/*++

Routine Description:

    This routine is used to test RpcServerInqBindings and
    RpcBindingVectorFree.  We call RpcServerInqBindings, and then
    use RpcBindingToStringBinding to get string bindings to print
    to the console.

Arguments:

    TestName - Supplies the name of the test, Christopher or Bartholomew
        which is invoking this routine.  This is necessary so that we
        can print out appropriate messages.

Return Value:

    Zero will be returned if this test completes successfully; otherwise,
    non-zero will be returned.

--*/
{
    RPC_BINDING_VECTOR * RpcBindingVector;
    unsigned int Index;
    unsigned char * StringBinding;

    Status = RpcServerInqBindings(&RpcBindingVector);
    if (Status)
        {
        ApiError(TestName,"RpcServerInqBindings",Status);
        PrintToConsole(TestName);
        PrintToConsole(" : FAIL - RpcServerInqBindings\n");
        return(1);
        }

    PrintToConsole("%s: (RpcServerInqBindings)\n", TestName);
    for (Index = 0; Index < RpcBindingVector->Count; Index++)
        {
        unsigned int   Transport;
        char *TransportName;

        Status = RpcBindingToStringBindingA(RpcBindingVector->BindingH[Index],
                &StringBinding);
        if (Status)
            {
            ApiError(TestName,"RpcBindingToStringBinding",Status);
            PrintToConsole(TestName);
            PrintToConsole(" : FAIL - RpcBindingToStringBinding\n");
            return(1);
            }

        Status =
        I_RpcBindingInqTransportType(RpcBindingVector->BindingH[Index],
                                     &Transport);

        if (Status)
            {
            ApiError(TestName,"I_RpcBindingInqTransportType",Status);
            PrintToConsole(TestName);
            PrintToConsole(" : FAIL - I_RpcBindingInqTransportType\n");
            return(1);
            }

        if (Transport == TRANSPORT_TYPE_CN)
            {
            TransportName = "cn";
            }
        else if (Transport == TRANSPORT_TYPE_DG)
            {
            TransportName = "dg";
            }
        else if (Transport == TRANSPORT_TYPE_LPC)
            {
            TransportName = "lpc";
            }
        else
            {
            PrintToConsole(TestName);
            PrintToConsole(" : FAIL - Unknown transport (I_RpcBindingInqTransportType)\n");
            return(1);
            }

        PrintToConsole("    %s - ( %s )\n",
                       (char *) StringBinding,
                       TransportName );

        Status = RpcStringFreeA(&StringBinding);
        if (Status)
            {
            ApiError(TestName,"RpcStringFree",Status);
            PrintToConsole(TestName);
            PrintToConsole(" : FAIL - RpcStringFree\n");
            return(1);
            }

        if (StringBinding != 0)
            {
            PrintToConsole(TestName);
            PrintToConsole(" : FAIL - StringBinding != 0\n");
            return(1);
            }
        }

    Status = RpcBindingVectorFree(&RpcBindingVector);
    if (Status)
        {
        ApiError(TestName,"RpcBindingVectorFree",Status);
        PrintToConsole(TestName);
        PrintToConsole(" : FAIL - RpcBindingVectorFree\n");
        return(1);
        }

    if (RpcBindingVector != 0)
        {
        PrintToConsole(TestName);
        PrintToConsole(" : FAIL - RpcBindingVector != 0\n");
        return(1);
        }

    return(0);
}


void
Sigfried (
    )
/*++

Routine Description:

    This routine is used to perform a build verification test of the
    rpc runtime.  This test checks for basic functionality of the
    runtime.  It works with Sebastian in uclnt.exe.

--*/
{
    PrintToConsole("Sigfried : Verify Basic Server Functionality\n");

    Status = stub_RegisterIf((RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0,0);
    if (Status)
        {
        ApiError("Sigfried","stub_RegisterIf",Status);
        PrintToConsole("Sigfried : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,0,0);
    if (Status)
        {
        ApiError("Sigfried","stub_RegisterIf",Status);
        PrintToConsole("Sigfried : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(SIGFRIED), 0);
    if (Status)
        {
        ApiError("Sigfried","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Sigfried : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

//    if ( InquireBindings("Sigfried") != 0 )
//        {
//        return;
//        }

    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("Sigfried","stub_ServerListen",Status);
        PrintToConsole("Sigfried : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("Sigfried : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Sigfried : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Sigfried","RpcServerUnregisterIf",Status);
        PrintToConsole("Sigfried : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Sigfried","RpcServerUnregisterIf",Status);
        PrintToConsole("Sigfried : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("Sigfried : PASS\n");
}


void
Hybrid (
    )
/*++

Routine Description:

    This routine is used to perform a build verification test of the
    rpc runtime.  This test checks for basic functionality of the
    runtime.  It works with Sebastian in uclnt.exe.

--*/
{
    PrintToConsole("Hybrid : Verify Basic Server Functionality\n");

    Status = stub_RegisterIf((RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0,0);
    if (Status)
        {
        ApiError("Hybrid","stub_RegisterIf",Status);
        PrintToConsole("Hybrid : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,0,0);
    if (Status)
        {
        ApiError("Hybrid","stub_RegisterIf",Status);
        PrintToConsole("Hybrid : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(SIGFRIED), 0);
    if (Status)
        {
        ApiError("Hybrid","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("Hybrid : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

//    if ( InquireBindings("Sigfried") != 0 )
//        {
//        return;
//        }

    Status = stub_ServerListen(MinimumListenThreads, MAXLISTENTHREADS, 0);
    if (Status)
        {
        ApiError("Hybrid","stub_ServerListen",Status);
        PrintToConsole("Hybrid : FAIL - stub_ServerListen Failed\n");
        return;
        }

    if (HelgaErrors != 0)
        {
        PrintToConsole("Hybrid : FAIL - Error(s) in Helga Interface\n");
        HelgaErrors = 0;
        return;
        }

    if (IsabelleErrors != 0)
        {
        PrintToConsole("Hybrid : FAIL - Error(s) in Isabelle Interface\n");
        IsabelleErrors = 0;
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Hybrid","RpcServerUnregisterIf",Status);
        PrintToConsole("Hybrid : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUnregisterIf(
            (RPC_IF_HANDLE) &HelgaInterfaceInformation, 0, 0);
    if (Status)
        {
        ApiError("Hybrid","RpcServerUnregisterIf",Status);
        PrintToConsole("Hybrid : FAIL - Unable to Unregister Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    PrintToConsole("Hybrid : PASS\n");
}


void
LpcSecurity (
    )
/*++

Routine Description:

    This routine is used to perform a build verification test of the
    rpc runtime.  This test checks for basic functionality of the
    runtime.  It works with Sebastian in uclnt.exe.

--*/
{
    PrintToConsole("LpcSecurity : Verify Basic Server Functionality\n");

    Status = stub_RegisterIf((RPC_IF_HANDLE) &HelgaInterfaceInformation,
            0,0);
    if (Status)
        {
        ApiError("LpcSecurity","stub_RegisterIf",Status);
        PrintToConsole("LpcSecurity : FAIL - Unable to Register Interface ");
        PrintToConsole("(Helga)\n");
        return;
        }

    Status = stub_RegisterIf(
            (RPC_IF_HANDLE) &IsabelleInterfaceInformation,0,0);
    if (Status)
        {
        ApiError("LpcSecurity","stub_RegisterIf",Status);
        PrintToConsole("LpcSecurity : FAIL - Unable to Register Interface ");
        PrintToConsole("(Isabelle)\n");
        return;
        }

    Status = RpcServerUseProtseqEpWrapper(GetProtocolSequence(), MAX_CALL_REQUESTS,
            GetEndpoint(SIGFRIED), 0);
    if (Status)
        {
        ApiError("LpcSecurity","RpcServerUseProtseqEpWrapper",Status);
        PrintToConsole("LpcSecurity : FAIL - Unable to Use Protseq Endpoint\n");
        return;
        }

//    if ( InquireBindings("Sigfried") != 0 )
//        {
//        return